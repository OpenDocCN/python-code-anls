# `.\numpy\numpy\linalg\lapack_lite\f2c_z_lapack.c`

```
/*
 * NOTE: This is generated code. Look in numpy/linalg/lapack_lite for
 *       information on remaking this file.
 */
#include "f2c.h"

#ifdef HAVE_CONFIG
#include "config.h"
#else
extern doublereal dlamch_(char *);
#define EPSILON dlamch_("Epsilon")
#define SAFEMINIMUM dlamch_("Safe minimum")
#define PRECISION dlamch_("Precision")
#define BASE dlamch_("Base")
#endif

extern doublereal dlapy2_(doublereal *x, doublereal *y);

/*
f2c knows the exact rules for precedence, and so omits parentheses where not
strictly necessary. Since this is generated code, we don't really care if
it's readable, and we know what is written is correct. So don't warn about
them.
*/
#if defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

/* Table of constant values */

static integer c__1 = 1;
static doublecomplex c_b56 = {0.,0.};
static doublecomplex c_b57 = {1.,0.};
static integer c_n1 = -1;
static integer c__3 = 3;
static integer c__2 = 2;
static integer c__0 = 0;
static integer c__65 = 65;
static integer c__9 = 9;
static integer c__6 = 6;
static doublereal c_b328 = 0.;
static doublereal c_b1034 = 1.;
static integer c__12 = 12;
static integer c__49 = 49;
static doublereal c_b1276 = -1.;
static integer c__13 = 13;
static integer c__15 = 15;
static integer c__14 = 14;
static integer c__16 = 16;
static logical c_false = FALSE_;
static logical c_true = TRUE_;
static doublereal c_b2435 = .5;

/* Subroutine */ int zgebak_(char *job, char *side, integer *n, integer *ilo,
    integer *ihi, doublereal *scale, integer *m, doublecomplex *v,
    integer *ldv, integer *info)
{
    /* System generated locals */
    integer v_dim1, v_offset, i__1;

    /* Local variables */
    static integer i__, k;
    static doublereal s;
    static integer ii;
    extern logical lsame_(char *, char *);
    static logical leftv;
    extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), xerbla_(char *, integer *),
        zdscal_(integer *, doublereal *, doublecomplex *, integer *);
    static logical rightv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    
    ZGEBAK forms the right or left eigenvectors of a complex general
    matrix by backward transformation on the computed eigenvectors of the
    balanced matrix output by ZGEBAL.

    Arguments
    ==========
    
    JOB     (input) CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to ZGEBAL.
*/
    # 定义字符变量 SIDE，指示是否存储右特征向量（'R'）或左特征向量（'L'）
    SIDE    (input) CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.

    # 定义整数变量 N，表示矩阵 V 的行数，要求 N >= 0
    N       (input) INTEGER
            The number of rows of the matrix V.  N >= 0.

    # 定义整数变量 ILO 和 IHI，由 ZGEBAL 确定
    ILO     (input) INTEGER
    IHI     (input) INTEGER
            The integers ILO and IHI determined by ZGEBAL.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    # 定义数组 SCALE，存储置换和缩放因子的细节，由 ZGEBAL 返回
    SCALE   (input) DOUBLE PRECISION array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by ZGEBAL.

    # 定义整数变量 M，表示矩阵 V 的列数，要求 M >= 0
    M       (input) INTEGER
            The number of columns of the matrix V.  M >= 0.

    # 定义复数矩阵 V，作为输入输出参数
    V       (input/output) COMPLEX*16 array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by ZHSEIN or ZTREVC.
            On exit, V is overwritten by the transformed eigenvectors.

    # 定义整数变量 LDV，表示矩阵 V 的第一维长度，要求 LDV >= max(1,N)
    LDV     (input) INTEGER
            The leading dimension of the array V. LDV >= max(1,N).

    # 定义整数变量 INFO，作为输出参数
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 以下是过程的解码和输入参数的测试
    =====================================================================
/* Parameter adjustments */
/* 参数调整 */

--scale;
/* 将指针scale向前移动一个位置 */

v_dim1 = *ldv;
/* 设置v_dim1为ldv的值，通常是v的第一维的大小 */

v_offset = 1 + v_dim1;
/* 计算v的偏移量 */

v -= v_offset;
/* 调整v的指针，使其指向正确的起始位置 */

/* Function Body */
/* 函数主体开始 */

rightv = lsame_(side, "R");
/* 检查side是否为'R'，返回布尔值给rightv */

leftv = lsame_(side, "L");
/* 检查side是否为'L'，返回布尔值给leftv */

*info = 0;
/* 初始化info为0 */

if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
    && ! lsame_(job, "B")) {
/* 检查job是否为有效值（不是'N', 'P', 'S', 'B'之一） */
*info = -1;
} else if (! rightv && ! leftv) {
/* 检查side是否为有效值（不是'R'也不是'L'） */
*info = -2;
} else if (*n < 0) {
/* 检查n是否小于0 */
*info = -3;
} else if (*ilo < 1 || *ilo > max(1,*n)) {
/* 检查ilo是否在有效范围内 */
*info = -4;
} else if (*ihi < min(*ilo,*n) || *ihi > *n) {
/* 检查ihi是否在有效范围内 */
*info = -5;
} else if (*m < 0) {
/* 检查m是否小于0 */
*info = -7;
} else if (*ldv < max(1,*n)) {
/* 检查ldv是否足够大 */
*info = -9;
}
if (*info != 0) {
/* 如果info不为0，说明有错误发生 */
i__1 = -(*info);
xerbla_("ZGEBAK", &i__1);
/* 调用错误处理程序xerbla_并返回 */
return 0;
}

/*     Quick return if possible */
/*     可能的话，快速返回 */

if (*n == 0) {
/* 如果n为0，直接返回 */
return 0;
}
if (*m == 0) {
/* 如果m为0，直接返回 */
return 0;
}
if (lsame_(job, "N")) {
/* 如果job为'N'，直接返回 */
return 0;
}

if (*ilo == *ihi) {
/* 如果ilo等于ihi，执行L30 */
goto L30;
}

/*     Backward balance */
/*     向后平衡 */

if (lsame_(job, "S") || lsame_(job, "B")) {

if (rightv) {
/* 如果rightv为真，执行右向平衡 */
i__1 = *ihi;
for (i__ = *ilo; i__ <= i__1; ++i__) {
s = scale[i__];
zdscal_(m, &s, &v[i__ + v_dim1], ldv);
/* 对v中的第i列进行缩放 */
/* L10: */
}
}

if (leftv) {
/* 如果leftv为真，执行左向平衡 */
i__1 = *ihi;
for (i__ = *ilo; i__ <= i__1; ++i__) {
s = 1. / scale[i__];
zdscal_(m, &s, &v[i__ + v_dim1], ldv);
/* 对v中的第i列进行缩放 */
/* L20: */
}
}

}

/*
   Backward permutation

   For  I = ILO-1 step -1 until 1,
            IHI+1 step 1 until N do --
*/
/* 向后排列 */

L30:
if (lsame_(job, "P") || lsame_(job, "B")) {
/* 如果job为'P'或'B'，执行向后排列 */

if (rightv) {
/* 如果rightv为真，执行右向排列 */
i__1 = *n;
for (ii = 1; ii <= i__1; ++ii) {
i__ = ii;
if (i__ >= *ilo && i__ <= *ihi) {
goto L40;
}
if (i__ < *ilo) {
i__ = *ilo - ii;
}
k = (integer) scale[i__];
if (k == i__) {
goto L40;
}
zswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L40:
;
}
}

if (leftv) {
/* 如果leftv为真，执行左向排列 */
i__1 = *n;
for (ii = 1; ii <= i__1; ++ii) {
i__ = ii;
if (i__ >= *ilo && i__ <= *ihi) {
goto L50;
}
if (i__ < *ilo) {
i__ = *ilo - ii;
}
k = (integer) scale[i__];
if (k == i__) {
goto L50;
}
zswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L50:
;
}
}
}

return 0;

/*     End of ZGEBAK */

} /* zgebak_ */

/* Subroutine */ int zgebal_(char *job, integer *n, doublecomplex *a, integer
*lda, integer *ilo, integer *ihi, doublereal *scale, integer *info)
{
/* 子程序开始 zgebal_ */

/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, i__1, i__2, i__3;
doublereal d__1, d__2;

/* Local variables */
/* 本地变量 */
static doublereal c__, f, g;
static integer i__, j, k, l, m;
static doublereal r__, s, ca, ra;
static integer ica, ira, iexc;
extern logical lsame_(char *, char *);
    extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    # 声明外部的子程序 zswap_，参数分别为整数指针、双复数数组、整数指针、双复数数组、整数指针

    static doublereal sfmin1, sfmin2, sfmax1, sfmax2;
    # 声明静态变量 sfmin1, sfmin2, sfmax1, sfmax2，类型为 doublereal

    extern logical disnan_(doublereal *);
    # 声明外部的逻辑函数 disnan_，参数为 doublereal 指针，返回逻辑值

    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 声明外部的子程序 xerbla_，参数为字符指针和整数指针

    extern /* Subroutine */ int zdscal_(
        integer *, doublereal *, doublecomplex *, integer *);
    # 声明外部的子程序 zdscal_，参数为整数指针、doublereal 指针、双复数数组、整数指针

    extern integer izamax_(integer *, doublecomplex *, integer *);
    # 声明外部的整数函数 izamax_，参数为整数指针、双复数数组、整数指针，返回整数值

    static logical noconv;
    # 声明静态的逻辑变量 noconv
/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    ZGEBAL balances a general complex matrix A.  This involves, first,
    permuting A by a similarity transformation to isolate eigenvalues
    in the first 1 to ILO-1 and last IHI+1 to N elements on the
    diagonal; and second, applying a diagonal similarity transformation
    to rows and columns ILO to IHI to make the rows and columns as
    close in norm as possible.  Both steps are optional.

    Balancing may reduce the 1-norm of the matrix, and improve the
    accuracy of the computed eigenvalues and/or eigenvectors.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    ILO     (output) INTEGER
    IHI     (output) INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.

    SCALE   (output) DOUBLE PRECISION array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The permutations consist of row and column interchanges which put
    the matrix in the form

               ( T1   X   Y  )
       P A P = (  0   B   Z  )
               (  0   0   T2 )

    where T1 and T2 are upper triangular matrices whose eigenvalues lie
    along the diagonal.  The column indices ILO and IHI mark the starting
    and ending columns of the submatrix B. Balancing consists of applying
*/

subroutine zgebal(character JOB, integer N, complex*16 A(LDA,*), integer LDA,
     & integer ILO, integer IHI, double precision SCALE(N), integer INFO)
{
    // LAPACK routine to balance a general complex matrix A.
    // JOB specifies operations to perform ('N', 'P', 'S', 'B').
    // N is the order of matrix A.
    // A is the input matrix to be balanced and the output balanced matrix.
    // LDA is the leading dimension of A.
    // ILO and IHI mark the starting and ending columns of the submatrix B.
    // SCALE contains details of permutations and scaling applied to A.
    // INFO is 0 if successful, < 0 if an illegal value is detected.

    // Declarations
    integer I, J, K, L, M, LAST
    double precision C, F, G, R, S
    complex*16 TMP

    // Initialize indices and flags
    ILO = 1
    IHI = N

    // Quick return if possible
    if (N <= 0) {
        return
    }

    // ...
    a diagonal similarity transformation inv(D) * B * D to make the
    1-norms of each row of B and its corresponding column nearly equal.
    The output matrix is

       ( T1     X*D          Y    )
       (  0  inv(D)*B*D  inv(D)*Z ).
       (  0      0           T2   )

    Information about the permutations P and the diagonal matrix D is
    returned in the vector SCALE.

    This subroutine is based on the EISPACK routine CBAL.

    Modified by Tzu-Yi Chen, Computer Science Division, University of
      California at Berkeley, USA

    =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --scale;

    /* Function Body */
    *info = 0;
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGEBAL", &i__1);
        return 0;
    }

    k = 1;
    l = *n;

    if (*n == 0) {
        goto L210;
    }

    if (lsame_(job, "N")) {
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scale[i__] = 1.;
        }
        goto L210;
    }

    if (lsame_(job, "S")) {
        goto L120;
    }

    /* Permutation to isolate eigenvalues if possible */
    goto L50;

    /* Row and column exchange. */
L20:
    scale[m] = (doublereal) j;
    if (j == m) {
        goto L30;
    }

    zswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    i__1 = *n - k + 1;
    zswap_(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

L30:
    switch (iexc) {
    case 1:  goto L40;
    case 2:  goto L80;
    }

    /* Search for rows isolating an eigenvalue and push them down. */
L40:
    if (l == 1) {
        goto L210;
    }
    --l;

L50:
    for (j = l; j >= 1; --j) {
        i__1 = l;
        for (i__ = 1; i__ <= i__1; ++i__) {
            if (i__ == j) {
                goto L60;
            }
            i__2 = j + i__ * a_dim1;
            if (a[i__2].r != 0. || d_imag(&a[j + i__ * a_dim1]) != 0.) {
                goto L70;
            }
L60:
            ;
        }

        m = l;
        iexc = 1;
        goto L20;
L70:
        ;
    }

    goto L90;

    /* Search for columns isolating an eigenvalue and push them left. */
L80:
    ++k;

L90:
    i__1 = l;
    for (j = k; j <= i__1; ++j) {
        i__2 = l;
        for (i__ = k; i__ <= i__2; ++i__) {
            if (i__ == j) {
                goto L100;
            }
            i__3 = i__ + j * a_dim1;
            if (a[i__3].r != 0. || d_imag(&a[i__ + j * a_dim1]) != 0.) {
                goto L110;
            }
L100:
            ;
        }

        m = k;
        iexc = 2;
        goto L20;
L110:
        ;
    }

L120:
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        scale[i__] = 1.;
    }

    if (lsame_(job, "P")) {
        goto L210;
    }

    /*
       Balance the submatrix in rows K to L.

       Iterative loop for norm reduction
    */
    sfmin1 = SAFEMINIMUM / PRECISION;
    sfmax1 = 1. / sfmin1;
    sfmin2 = sfmin1 * 2.;
    sfmax2 = 1. / sfmin2;
L140:
    noconv = FALSE_;

    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        c__ = 0.;
        r__ = 0.;

        i__2 = l;
        for (j = k; j <= i__2; ++j) {
            if (j == i__) {
                goto L150;
            }
            i__3 = j + i__ * a_dim1;
            c__ += (d__1 = a[i__3].r, abs(d__1)) + (d__2 = d_imag(&a[j + i__ *
                 a_dim1]), abs(d__2));
            i__3 = i__ + j * a_dim1;
            r__ += (d__1 = a[i__3].r, abs(d__1)) + (d__2 = d_imag(&a[i__ + j *
                 a_dim1]), abs(d__2));
L150:
            ;
        }
    # 调用外部函数 izamax_()，找到数组 a[i__ * a_dim1 + 1] 中绝对值最大元素的索引
    ica = izamax_(&l, &a[i__ * a_dim1 + 1], &c__1);
    # 计算数组 a 中索引为 ica + i__ * a_dim1 的元素的复数绝对值
    ca = z_abs(&a[ica + i__ * a_dim1]);

    # 计算有效范围内的数组 a 的列数
    i__2 = *n - k + 1;
    # 调用外部函数 izamax_()，找到数组 a[i__ + k * a_dim1] 中绝对值最大元素的索引
    ira = izamax_(&i__2, &a[i__ + k * a_dim1], lda);
    # 计算数组 a 中索引为 i__ + (ira + k - 1) * a_dim1 的元素的复数绝对值
    ra = z_abs(&a[i__ + (ira + k - 1) * a_dim1]);
/*        Guard against zero C or R due to underflow. */

/* 如果 c__ 或者 r__ 为零则跳转到标签 L200 */
if (c__ == 0. || r__ == 0.) {
    goto L200;
}
/* 计算 g = r__ / 2., f = 1., s = c__ + r__ */
g = r__ / 2.;
f = 1.;
s = c__ + r__;
L160:
/* Computing MAX */
/* 计算最大值 */
d__1 = max(f,c__);
/* Computing MIN */
/* 计算最小值 */
d__2 = min(r__,g);
/* 如果 c__ >= g 或者 max(d__1,ca) >= sfmax2 或者 min(d__2,ra) <= sfmin2 则跳转到 L170 */
if (c__ >= g || max(d__1,ca) >= sfmax2 || min(d__2,ra) <= sfmin2) {
    goto L170;
}
/* 计算 d__1 = c__ + f + ca + r__ + g + ra */
d__1 = c__ + f + ca + r__ + g + ra;
/* 如果 disnan_(&d__1) 返回真（即出现 NaN），则设置 *info = -3 并调用 xerbla_ 函数，然后返回 0 */
if (disnan_(&d__1)) {

/*           Exit if NaN to avoid infinite loop */

    *info = -3;
    i__2 = -(*info);
    xerbla_("ZGEBAL", &i__2);
    return 0;
}
/* f *= 2., c__ *= 2., ca *= 2., r__ /= 2., g /= 2., ra /= 2.，然后跳转到 L160 */
f *= 2.;
c__ *= 2.;
ca *= 2.;
r__ /= 2.;
g /= 2.;
ra /= 2.;
goto L160;

L170:
g = c__ / 2.;
L180:
/* Computing MIN */
/* 计算最小值 */
d__1 = min(f,c__), d__1 = min(d__1,g);
/* 如果 g < r__ 或者 max(r__,ra) >= sfmax2 或者 min(d__1,ca) <= sfmin2 则跳转到 L190 */
if (g < r__ || max(r__,ra) >= sfmax2 || min(d__1,ca) <= sfmin2) {
    goto L190;
}
/* f /= 2., c__ /= 2., g /= 2., ca /= 2., r__ *= 2., ra *= 2.，然后跳转到 L180 */
f /= 2.;
c__ /= 2.;
g /= 2.;
ca /= 2.;
r__ *= 2.;
ra *= 2.;
goto L180;

/*        Now balance. */

L190:
/* 如果 c__ + r__ >= s * .95 则跳转到 L200 */
if (c__ + r__ >= s * .95) {
    goto L200;
}
/* 如果 f < 1. 并且 scale[i__] < 1.，且 f * scale[i__] <= sfmin1 则跳转到 L200 */
if (f < 1. && scale[i__] < 1.) {
    if (f * scale[i__] <= sfmin1) {
    goto L200;
    }
}
/* 如果 f > 1. 并且 scale[i__] > 1.，且 scale[i__] >= sfmax1 / f 则跳转到 L200 */
if (f > 1. && scale[i__] > 1.) {
    if (scale[i__] >= sfmax1 / f) {
    goto L200;
    }
}
/* g = 1. / f，scale[i__] *= f，设置 noconv = TRUE_，然后调用 zdscal_ 函数两次 */
g = 1. / f;
scale[i__] *= f;
noconv = TRUE_;

i__2 = *n - k + 1;
zdscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
zdscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
;
}

/* 如果 noconv 为真则跳转到 L140 */
if (noconv) {
goto L140;
}

L210:
/* 设置 *ilo = k，*ihi = l */
*ilo = k;
*ihi = l;

/* 返回 0 */
return 0;

/*     End of ZGEBAL */

} /* zgebal_ */

/* Subroutine */ int zgebd2_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublereal *d__, doublereal *e, doublecomplex *tauq,
    doublecomplex *taup, doublecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublecomplex alpha;
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), zlacgv_(integer *, doublecomplex *,
        integer *);
    N       (input) INTEGER
            矩阵 A 的列数。N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            在入口处，表示要进行减少的 m × n 一般矩阵 A。
            在出口处，
            如果 m >= n，则对角线和第一个超对角线被上三角双对角矩阵 B 覆盖；
              在对角线下方的元素，用 TAUQ 数组表示 Q 单位矩阵作为一系列反射变换的乘积；
              在第一个超对角线上方的元素，用 TAUP 数组表示 P 单位矩阵作为一系列反射变换的乘积；
            如果 m < n，则对角线和第一个次对角线被下三角双对角矩阵 B 覆盖；
              在第一个次对角线下方的元素，用 TAUQ 数组表示 Q 单位矩阵作为一系列反射变换的乘积；
              在对角线上方的元素，用 TAUP 数组表示 P 单位矩阵作为一系列反射变换的乘积。
            详见 Further Details。

    LDA     (input) INTEGER
            数组 A 的主维度。LDA >= max(1, M)。

    D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            双对角矩阵 B 的对角线元素：
            D(i) = A(i,i)。

    E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            双对角矩阵 B 的非对角线元素：
            如果 m >= n，则 E(i) = A(i,i+1) (i = 1,2,...,n-1)；
            如果 m < n，则 E(i) = A(i+1,i) (i = 1,2,...,m-1)。

    TAUQ    (output) COMPLEX*16 array, dimension (min(M,N))
            表示单位矩阵 Q 的反射变换的标量因子。详见 Further Details。

    TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
            表示单位矩阵 P 的反射变换的标量因子。详见 Further Details。

    WORK    (workspace) COMPLEX*16 array, dimension (max(M,N))

    INFO    (output) INTEGER
            = 0: 成功退出
            < 0: 如果 INFO = -i，则第 i 个参数具有非法值。

    Further Details
    ===============

    矩阵 Q 和 P 被表示为一系列反射变换的乘积：

    如果 m >= n，

       Q = H(1) H(2) . . . H(n)  且  P = G(1) G(2) . . . G(n-1)

    每个 H(i) 和 G(i) 的形式为：

       H(i) = I - tauq * v * v'  且  G(i) = I - taup * u * u'

    其中 tauq 和 taup 是复数标量，v 和 u 是复数向量；
    v(1:i-1) = 0, v(i) = 1，并且 v(i+1:m) 在出口时存储在 A(i+1:m,i) 中；
    u(1:i) = 0, u(i+1) = 1，并且 u(i+2:n) 在出口时存储在 A(i,i+2:n) 中；
    tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。

    如果 m < n，

       Q = H(1) H(2) . . . H(m-1)  且  P = G(1) G(2) . . . G(m)
    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are complex scalars, v and u are complex vectors;
    v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
    u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
    tauq is stored in TAUQ(i) and taup in TAUP(i).

    The contents of A on exit are illustrated by the following examples:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
      (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
      (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
      (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
      (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
      (  v1  v2  v3  v4  v5 )

    where d and e denote diagonal and off-diagonal elements of B, vi
    denotes an element of the vector defining H(i), and ui an element of
    the vector defining G(i).

    =====================================================================

# 测试输入参数
    /* Parameter adjustments */
    // 设置数组 a 的第一维大小为 lda
    a_dim1 = *lda;
    // a 数组的偏移量计算
    a_offset = 1 + a_dim1;
    // 对 a 数组进行偏移，使其指向正确位置
    a -= a_offset;
    // d__ 数组的偏移
    --d__;
    // e 数组的偏移
    --e;
    // tauq 数组的偏移
    --tauq;
    // taup 数组的偏移
    --taup;
    // work 数组的偏移
    --work;

    /* Function Body */
    // 将 info 初始化为 0
    *info = 0;
    // 检查参数 *m 是否小于 0
    if (*m < 0) {
        // 设置 info 为 -1，表示 m 参数不合法
        *info = -1;
    } else if (*n < 0) {
        // 设置 info 为 -2，表示 n 参数不合法
        *info = -2;
    } else if (*lda < max(1,*m)) {
        // 设置 info 为 -4，表示 lda 参数不合法
        *info = -4;
    }
    // 如果参数有误，调用错误处理函数 xerbla_
    if (*info < 0) {
        // 计算 info 的绝对值，并传递给 xerbla_ 函数处理
        i__1 = -(*info);
        xerbla_("ZGEBD2", &i__1);
        // 返回，结束函数
        return 0;
    }

    // 如果 m 大于或等于 n
    if (*m >= *n) {

/*        Reduce to upper bidiagonal form */

        // 循环处理每一列，将矩阵化为上（右）对角的双对角形式
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {

/*           Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

            // 计算当前处理的主对角元素位置
            i__2 = i__ + i__ * a_dim1;
            // 获取主对角元素 alpha
            alpha.r = a[i__2].r, alpha.i = a[i__2].i;
            // 计算对 H(i) 的长度
            i__2 = *m - i__ + 1;
            // 计算参与反射计算的向量长度
            // min 函数用于确保不超出数组范围
            i__3 = i__ + 1;
            zlarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1, &
                tauq[i__]);
            // 将 alpha 存入 d__ 数组中
            i__2 = i__;
            d__[i__2] = alpha.r;
            // 将对角元素置为 1
            i__2 = i__ + i__ * a_dim1;
            a[i__2].r = 1., a[i__2].i = 0.;

/*           Apply H(i)' to A(i:m,i+1:n) from the left */

            // 如果当前列 i 小于 n，进行左乘 H(i)
            if (i__ < *n) {
                // 计算左乘 H(i) 的维度
                i__2 = *m - i__ + 1;
                i__3 = *n - i__;
                // 对 tauq[i__] 求共轭
                d_cnjg(&z__1, &tauq[i__]);
                // 对 A 的子矩阵应用左乘 H(i)
                zlarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &
                    z__1, &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
            }
            // 恢复对角元素的值
            i__2 = i__ + i__ * a_dim1;
            i__3 = i__;
            a[i__2].r = d__[i__3], a[i__2].i = 0.;

            // 如果当前列 i 小于 n，处理对角下方的元素

            if (i__ < *n) {

/*
                Generate elementary reflector G(i) to annihilate
                A(i,i+2:n)
*/

                // 计算需要处理的非对角元素的长度
                i__2 = *n - i__;
                // 对 A 的子矩阵应用左乘 G(i)
                zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                // 获取当前非对角元素的值
                i__2 = i__ + (i__ + 1) * a_dim1;
                alpha.r = a[i__2].r, alpha.i = a[i__2].i;
                // 计算参与反射计算的向量长度
                // min 函数用于确保不超出数组范围
                i__2 = *n - i__;
                i__3 = i__ + 2;
                zlarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
                    taup[i__]);
                // 将 alpha 存入 e 数组中
                i__2 = i__;
                e[i__2] = alpha.r;
                // 将对角元素置为 1
                i__2 = i__ + (i__ + 1) * a_dim1;
                a[i__2].r = 1., a[i__2].i = 0.;

/*              Apply G(i) to A(i+1:m,i+1:n) from the right */

                // 计算 G(i) 应用的右乘维度
                i__2 = *m - i__;
                i__3 = *n - i__;
                // 对 A 的子矩阵应用右乘 G(i)
                zlarf_("Right", &i__2, &i__3, &a[i__ + (i__ + 1) * a_dim1],
                    lda, &taup[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
                    lda, &work[1]);
                // 恢复处理过的非对角元素的值
                i__2 = *n - i__;
                zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                // 恢复对角元素的值
                i__2 = i__ + (i__ + 1) * a_dim1;
                i__3 = i__;
                a[i__2].r = e[i__3], a[i__2].i = 0.;
            } else {
                // 如果 i 大于等于 n，设置 taup[i__] 为 0
                i__2 = i__;
                taup[i__2].r = 0., taup[i__2].i = 0.;
            }
/* L10: */
        }
    } else {

/*        Reduce to lower bidiagonal form */

        // 循环处理每一行，将矩阵化为下（左）对角的双对角形式
        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {

/*           Generate elementary reflector G(i) to annihilate A(i,i+1:n) */

            // 对 A 的子矩阵应用左乘 G(i)
            i__2 = *n - i__ + 1;
            zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
            // 获取当前处理的主对角元素
            i__2 = i__ + i__ * a_dim1;
            alpha.r = a[i__2].r, alpha.i = a[i__2].i;
            // 计算参与反射计算的向量长度
            i__2 = *n - i__ + 1;
/* Computing MIN */
/* 计算最小值 */
i__3 = i__ + 1;
/* 设置变量 i__3 为 i__ + 1 */
zlarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
    taup[i__]);
/* 调用 zlarfg 函数，生成一个 Householder 变换，将 alpha 和 a[i__ + min(i__3,*n) * a_dim1] 中的元素转化为零 */
i__2 = i__;
/* 设置变量 i__2 为 i__ */
d__[i__2] = alpha.r;
/* 将 alpha 的实部赋值给 d__[i__2] */
i__2 = i__ + i__ * a_dim1;
/* 设置变量 i__2 为 i__ + i__ * a_dim1 */
a[i__2].r = 1., a[i__2].i = 0.;
/* 将 a[i__2] 的实部设为 1，虚部设为 0 */

/* Apply G(i) to A(i+1:m,i:n) from the right */
/* 将 G(i) 从右侧应用到 A(i+1:m,i:n) */

if (i__ < *m) {
/* 如果 i__ 小于 *m */
i__2 = *m - i__;
/* 设置变量 i__2 为 *m - i__ */
i__3 = *n - i__ + 1;
/* 设置变量 i__3 为 *n - i__ + 1 */
zlarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &
    taup[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
/* 调用 zlarf 函数，将 Householder 变换应用到右侧的矩阵区域 */
}
i__2 = *n - i__ + 1;
/* 设置变量 i__2 为 *n - i__ + 1 */
zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
/* 调用 zlacgv 函数，对 a[i__ + i__ * a_dim1] 执行共轭 */
i__2 = i__ + i__ * a_dim1;
/* 设置变量 i__2 为 i__ + i__ * a_dim1 */
i__3 = i__;
/* 设置变量 i__3 为 i__ */
a[i__2].r = d__[i__3], a[i__2].i = 0.;
/* 将 a[i__2] 的实部设为 d__[i__3]，虚部设为 0 */

if (i__ < *m) {
/* 如果 i__ 小于 *m */

/*
        Generate elementary reflector H(i) to annihilate
        A(i+2:m,i)
*/
/* 生成用于消除 A(i+2:m,i) 的初等反射器 H(i) */

i__2 = i__ + 1 + i__ * a_dim1;
/* 设置变量 i__2 为 i__ + 1 + i__ * a_dim1 */
alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 将 a[i__2] 的实部和虚部分别赋值给 alpha 的实部和虚部 */
i__2 = *m - i__;
/* 设置变量 i__2 为 *m - i__ */
i__3 = i__ + 2;
/* 设置变量 i__3 为 i__ + 2 */
zlarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1,
     &tauq[i__]);
/* 调用 zlarfg 函数，生成一个 Householder 变换，将 alpha 和 a[min(i__3,*m) + i__ * a_dim1] 中的元素转化为零 */
i__2 = i__;
/* 设置变量 i__2 为 i__ */
e[i__2] = alpha.r;
/* 将 alpha 的实部赋值给 e[i__2] */
i__2 = i__ + 1 + i__ * a_dim1;
/* 设置变量 i__2 为 i__ + 1 + i__ * a_dim1 */
a[i__2].r = 1., a[i__2].i = 0.;
/* 将 a[i__2] 的实部设为 1，虚部设为 0 */

/* Apply H(i)' to A(i+1:m,i+1:n) from the left */
/* 将 H(i)' 从左侧应用到 A(i+1:m,i+1:n) */

i__2 = *m - i__;
/* 设置变量 i__2 为 *m - i__ */
i__3 = *n - i__;
/* 设置变量 i__3 为 *n - i__ */
d_cnjg(&z__1, &tauq[i__]);
/* 计算 tauq[i__] 的共轭 */
zlarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &
    c__1, &z__1, &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &
    work[1]);
/* 调用 zlarf 函数，将 Householder 变换应用到左侧的矩阵区域 */
i__2 = i__ + 1 + i__ * a_dim1;
/* 设置变量 i__2 为 i__ + 1 + i__ * a_dim1 */
i__3 = i__;
/* 设置变量 i__3 为 i__ */
a[i__2].r = e[i__3], a[i__2].i = 0.;
/* 将 a[i__2] 的实部设为 e[i__3]，虚部设为 0 */
} else {
/* 否则 */
i__2 = i__;
/* 设置变量 i__2 为 i__ */
tauq[i__2].r = 0., tauq[i__2].i = 0.;
/* 将 tauq[i__2] 的实部和虚部设为 0 */
}
/* L20: */
/* L20: */
}
/* 结束循环 */

/* End of ZGEBD2 */
/* ZGEBD2 的结束 */

} /* zgebd2_ */
/* 子程序 zgebd2_ 的结束 */

/* Subroutine */ int zgebrd_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublereal *d__, doublereal *e, doublecomplex *tauq,
    doublecomplex *taup, doublecomplex *work, integer *lwork, integer *
    info)
{
/* 子程序 zgebrd_ */
/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
doublereal d__1;
doublecomplex z__1;

/* Local variables */
/* 局部变量 */
static integer i__, j, nb, nx;
static doublereal ws;
static integer nbmin, iinfo, minmn;
extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *), zgebd2_(integer *, integer *,
    doublecomplex *, integer *, doublereal *, doublereal *,
    doublecomplex *, doublecomplex *, doublecomplex *, integer *),
    xerbla_(char *, integer *), zlabrd_(integer *, integer *,
    integer *, doublecomplex *, integer *, doublereal *, doublereal *,
     doublecomplex *, doublecomplex *, doublecomplex *, integer *,
    doublecomplex *, integer *);
/* 外部函数声明 */
    # 外部函数声明，ilaenv_ 是一个外部函数，参数及其类型如下：
    #   - integer *: 指向整数的指针
    #   - char *: 指向字符的指针
    #   - static integer *: 静态整数指针
    #   - static logical lquery: 静态逻辑查询

    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    # 静态整数变量，用于存储工作数组的维度
    static integer ldwrkx, ldwrky;

    # 静态整数变量，用于存储查询工作空间所需的最佳长度
    static integer lwkopt;

    # 静态逻辑变量，用于指示是否进行查询操作
    static logical lquery;
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
    bidiagonal form B by a unitary transformation: Q**H * A * P = B.

    If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns in the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).

    E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

    TAUQ    (output) COMPLEX*16 array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.

    TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
"""
    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.
            如果 LWORK = -1，则假定为工作空间查询；该例程仅计算 WORK 数组的最佳大小，将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会报告与 LWORK 相关的任何错误消息。

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            = 0：成功退出。
            < 0：如果 INFO = -i，则第 i 个参数的值非法。

    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:
    进一步细节
    ===============

    矩阵 Q 和 P 被表示为初等反射器的乘积

    If m >= n,
    如果m >= n

       Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
       Q = H(1) H(2) . . . H(n) 且 P = G(1) G(2) . . . G(n-1)

    Each H(i) and G(i) has the form:
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

    /* Determine optimal block size NB */
    /* Computing MAX */
    i__1 = 1, i__2 = ilaenv_(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    nb = max(i__1, i__2);  // 计算最优的块大小 NB

    lwkopt = (*m + *n) * nb;  // 计算所需的工作空间大小
    d__1 = (doublereal)lwkopt;
    work[1].r = d__1, work[1].i = 0.;  // 设置工作空间大小到 work 数组中
    lquery = *lwork == -1;  // 判断是否为查询工作空间大小的模式

    /* Check for invalid input parameters */
    if (*m < 0) {
        *info = -1;  // 若 m 小于 0，则设置错误码为 -1
    } else if (*n < 0) {
        *info = -2;  // 若 n 小于 0，则设置错误码为 -2
    } else if (*lda < max(1,*m)) {
        *info = -4;  // 若 lda 小于 max(1, m)，则设置错误码为 -4
    } else /* if(complicated condition) */ {
        /* Computing MAX */
        i__1 = max(1,*m);
        if (*lwork < max(i__1,*n) && !lquery) {
            *info = -10;  // 若 lwork 小于 max(1, m) 或 n，则设置错误码为 -10
        }
    }

    /* Handle errors and return */
    if (*info < 0) {
        i__1 = -(*info);
        xerbla_("ZGEBRD", &i__1);  // 处理错误情况，调用错误处理函数 xerbla_
        return 0;  // 返回
    } else if (lquery) {
        return 0;  // 若是查询工作空间大小的模式，则直接返回
    }

    /* Quick return if possible */
    minmn = min(*m, *n);  // 计算 m 和 n 中的较小值 minmn
    if (minmn == 0) {
        work[1].r = 1., work[1].i = 0.;  // 若 minmn 为 0，则设置工作空间的第一个元素为 1
        return 0;  // 返回
    }

    ws = (doublereal)max(*m, *n);  // 设置 ws 为 m 和 n 中的较大值
    ldwrkx = *m;  // 设置 ldwrkx 为 m
    ldwrky = *n;  // 设置 ldwrky 为 n

    if (nb > 1 && nb < minmn) {

        /* Determine the crossover point NX */
        /* Computing MAX */
        i__1 = nb, i__2 = ilaenv_(&c__3, "ZGEBRD", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1, i__2);  // 计算交叉点 NX

        /* Determine when to switch from blocked to unblocked code */
        if (nx < minmn) {
            ws = (doublereal)((*m + *n) * nb);  // 更新 ws
            if ((doublereal)(*lwork) < ws) {

                /* Not enough workspace for the optimal NB, consider using a smaller block size */
                nbmin = ilaenv_(&c__2, "ZGEBRD", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算最小块大小 nbmin
                if (*lwork >= (*m + *n) * nbmin) {
                    nb = *lwork / (*m + *n);  // 调整块大小 nb
                } else {
                    nb = 1;
                    nx = minmn;
                }
            }
        }
    } else {
        nx = minmn;
    }

    /* Reduce rows and columns i:i+ib-1 to bidiagonal form */
    /* and return the matrices X and Y */
    /* which are needed to update the unreduced part of the matrix */
    i__1 = minmn - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {

        zlabrd_(&(*m - i__ + 1), &(*n - i__ + 1), &nb, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__],
                &tauq[i__], &taup[i__], &work[1], &ldwrkx, &work[ldwrkx * nb + 1], &ldwrky);

        /* Update the trailing submatrix A(i+ib:m,i+ib:n) */
        /* using an update of the form A := A - V*Y' - X*U' */
        i__3 = *m - i__ - nb + 1;
        i__4 = *n - i__ - nb + 1;
        z__1.r = -1., z__1.i = -0.;
        zgemm_("No transpose", "Conjugate transpose", &i__3, &i__4, &nb, &z__1,
               &a[i__ + nb + i__ * a_dim1], lda, &work[ldwrkx * nb + nb + 1], &ldwrky, &c_b57,
               &a[i__ + nb + (i__ + nb) * a_dim1], lda);
        i__3 = *m - i__ - nb + 1;
        i__4 = *n - i__ - nb + 1;
        z__1.r = -1., z__1.i = -0.;
    # 调用名为 zgemm_ 的函数，进行矩阵乘法操作
    zgemm_("No transpose",             # 第一个矩阵不需要转置
           "No transpose",             # 第二个矩阵也不需要转置
           &i__3,                       # 第一个矩阵的行数
           &i__4,                       # 第二个矩阵的列数
           &nb,                         # 第一个矩阵的列数或第二个矩阵的行数（取决于矩阵乘法的顺序）
           &z__1,                       # 乘法的标量系数
           &work[nb + 1],               # 第一个矩阵的起始地址
           &ldwrkx,                     # 第一个矩阵的列数
           &a[i__ + (i__ + nb) * a_dim1], lda,  # 第二个矩阵的起始地址和列数
           &c_b57,                      # 第二个矩阵的标量系数
           &a[i__ + nb + (i__ + nb) * a_dim1], lda);  # 结果矩阵的起始地址和列数
/*        Copy diagonal and off-diagonal elements of B back into A */

/* 如果 m >= n，则将 B 的对角线和非对角线元素复制回 A */
if (*m >= *n) {
    /* 循环遍历对角线上的元素和其右侧的一个非对角线元素 */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 将 d 中的元素复制到 A 的对应位置，并设置虚部为0 */
        i__4 = j + j * a_dim1;
        i__5 = j;
        a[i__4].r = d__[i__5], a[i__4].i = 0.;
        /* 将 e 中的元素复制到 A 的对角线右侧位置，并设置虚部为0 */
        i__4 = j + (j + 1) * a_dim1;
        i__5 = j;
        a[i__4].r = e[i__5], a[i__4].i = 0.;
        /* L10: */
    }
} else {
    /* 如果 m < n，则将 B 的对角线和对角线右侧的元素复制回 A */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 将 d 中的元素复制到 A 的对应位置，并设置虚部为0 */
        i__4 = j + j * a_dim1;
        i__5 = j;
        a[i__4].r = d__[i__5], a[i__4].i = 0.;
        /* 将 e 中的元素复制到 A 的对角线右侧位置，并设置虚部为0 */
        i__4 = j + 1 + j * a_dim1;
        i__5 = j;
        a[i__4].r = e[i__5], a[i__4].i = 0.;
        /* L20: */
    }
}
/* L30: 结束对 B 元素的复制操作 */

/* 使用未阻塞的代码处理矩阵的剩余部分 */

/* 计算剩余矩阵的维度 */
i__2 = *m - i__ + 1;
i__1 = *n - i__ + 1;
/* 调用 zgebd2_ 函数对剩余部分进行处理 */
zgebd2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__], &
    tauq[i__], &taup[i__], &work[1], &iinfo);
/* 设置工作数组的第一个元素为 ws，虚部为0 */
work[1].r = ws, work[1].i = 0.;
/* 返回操作成功的标志 */
return 0;

/* ZGEBRD 过程结束 */

} /* zgebrd_ */

/* 子程序 zgeev_ */
/* 计算矩阵的特征值和特征向量 */

/* System generated locals */
/* 系统生成的本地变量声明 */

/* Local variables */
/* 本地变量声明 */
static integer i__, k, ihi;
static doublereal scl;
static integer ilo;
static doublereal dum[1], eps;
static doublecomplex tmp;
static integer ibal;
static char side[1];
static doublereal anrm;
static integer ierr, itau, iwrk, nout;
/* 外部函数和子程序声明 */
extern logical lsame_(char *, char *);
extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
    doublecomplex *, integer *), dlabad_(doublereal *, doublereal *);
extern doublereal dznrm2_(integer *, doublecomplex *, integer *);
static logical scalea;

static doublereal cscale;
extern /* Subroutine */ int zgebak_(char *, char *, integer *, integer *,
    integer *, doublereal *, integer *, doublecomplex *, integer *,
    integer *), zgebal_(char *, integer *,
    doublecomplex *, integer *, integer *, integer *, doublereal *,
    integer *);
extern integer idamax_(integer *, doublereal *, integer *);
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static logical select[1];
extern /* Subroutine */ int zdscal_(integer *, doublereal *,
    doublecomplex *, integer *);
static doublereal bignum;
extern doublereal zlange_(char *, integer *, integer *, doublecomplex *,
    integer *, doublereal *);
    ! 声明外部 Fortran 子程序 zgehrd，接受多个参数
    extern /* Subroutine */ int zgehrd_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);
    ! 声明外部 Fortran 子程序 zlascl，接受多个参数
    extern /* Subroutine */ int zlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublecomplex *,
         integer *, integer *);
    ! 声明外部 Fortran 子程序 zlacpy，接受多个参数
    extern /* Subroutine */ int zlacpy_(char *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *, integer *);
    ! 定义静态整型变量 minwrk 和 maxwrk
    static integer minwrk, maxwrk;
    ! 定义静态逻辑变量 wantvl
    static logical wantvl;
    ! 定义静态双精度实型变量 smlnum
    static doublereal smlnum;
    ! 定义静态整型变量 hswork 和 irwork
    static integer hswork, irwork;
    ! 声明外部 Fortran 子程序 zhseqr，接受多个参数
    extern /* Subroutine */ int zhseqr_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);
    ! 声明外部 Fortran 子程序 ztrevc，接受多个参数
    extern /* Subroutine */ int ztrevc_(char *, char *, logical *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, integer *, doublecomplex *,
         doublereal *, integer *);
    ! 定义静态逻辑变量 lquery 和 wantvr
    static logical lquery, wantvr;
    ! 声明外部 Fortran 子程序 zunghr，接受多个参数
    extern /* Subroutine */ int zunghr_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);
"""
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues.

    VL      (output) COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.

    VR      (output) COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
"""
    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,2*N).
            For good performance, LWORK must generally be larger.
            如果 LWORK = -1，则假设为工作空间查询；例程仅计算 WORK 数组的最佳大小，将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会输出与 LWORK 相关的任何错误消息。

    RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
            工作空间，用于存储双精度浮点数数组，维度为 (2*N)。

    INFO    (output) INTEGER
            = 0:  successful exit
                 成功退出，没有错误发生。
            < 0:  if INFO = -i, the i-th argument had an illegal value.
                 如果 INFO = -i，表示第 i 个参数具有非法值。
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
                 如果 INFO = i，QR 算法无法计算所有特征值，并且没有计算任何特征向量；W 的元素和 i+1 到 N 的部分包含已收敛的特征值。

    =====================================================================

       Test the input arguments
       检测输入参数是否合法
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --w;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;
    --rwork;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    wantvl = lsame_(jobvl, "V");
    wantvr = lsame_(jobvr, "V");
    if (! wantvl && ! lsame_(jobvl, "N")) {
        *info = -1;
    } else if (! wantvr && ! lsame_(jobvr, "N")) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
        *info = -8;
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
        *info = -10;
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         CWorkspace refers to complex workspace, and RWorkspace to real
         workspace. NB refers to the optimal block size for the
         immediately following subroutine, as returned by ILAENV.
         HSWORK refers to the workspace preferred by ZHSEQR, as
         calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
         the worst case.)
*/

    if (*info == 0) {
        if (*n == 0) {
            minwrk = 1;
            maxwrk = 1;
        } else {
            maxwrk = *n + *n * ilaenv_(&c__1, "ZGEHRD", " ", n, &c__1, n, &
                c__0, (ftnlen)6, (ftnlen)1);
            minwrk = *n << 1;
            if (wantvl) {
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + (*n - 1) * ilaenv_(&c__1, "ZUNGHR",
                     " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                zhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1], &vl[
                    vl_offset], ldvl, &work[1], &c_n1, info);
            } else if (wantvr) {
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + (*n - 1) * ilaenv_(&c__1, "ZUNGHR",
                     " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                zhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1], &vr[
                    vr_offset], ldvr, &work[1], &c_n1, info);
            } else {
                zhseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &w[1], &vr[
                    vr_offset], ldvr, &work[1], &c_n1, info);
            }
            hswork = (integer) work[1].r;
            /* Computing MAX */
            i__1 = max(maxwrk,hswork);
            maxwrk = max(i__1,minwrk);
        }
        work[1].r = (doublereal) maxwrk, work[1].i = 0.;

        if (*lwork < minwrk && ! lquery) {
            *info = -12;
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGEEV ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        return 0;
    }

/*     Get machine constants */

    eps = PRECISION;
    smlnum = SAFEMINIMUM;
    # 计算大数与小数的比值
    bignum = 1. / smlnum;
    # 调用外部函数 dlabad_，传入参数 smlnum 和 bignum
    dlabad_(&smlnum, &bignum);
    # 计算小数的平方根并除以机器精度 eps
    smlnum = sqrt(smlnum) / eps;
    # 重新计算大数与小数的比值
    bignum = 1. / smlnum;
/*     Scale A if max element outside range [SMLNUM,BIGNUM] */
/* 如果 A 的最大元素超出范围 [SMLNUM, BIGNUM]，则对 A 进行缩放 */

anrm = zlange_("M", n, n, &a[a_offset], lda, dum);
/* 计算矩阵 A 的无穷范数 */

scalea = FALSE_;
/* 初始化标志位 scalea 为假 */

if (anrm > 0. && anrm < smlnum) {
/* 如果 anrm 大于 0 且小于 smlnum */
    scalea = TRUE_;
    /* 设置 scalea 为真 */
    cscale = smlnum;
    /* 将 cscale 设置为 smlnum */
} else if (anrm > bignum) {
/* 否则如果 anrm 大于 bignum */
    scalea = TRUE_;
    /* 设置 scalea 为真 */
    cscale = bignum;
    /* 将 cscale 设置为 bignum */
}

if (scalea) {
/* 如果需要缩放 */
    zlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &ierr);
    /* 调用 zlascl 函数，按比例缩放矩阵 A */
}

/*
       Balance the matrix
       (CWorkspace: none)
       (RWorkspace: need N)
*/
/* 对矩阵进行平衡处理，无需复杂工作空间，但需要大小为 N 的实数工作空间 */

ibal = 1;
/* 设置平衡算法的参数 ibal 为 1 */

zgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &rwork[ibal], &ierr);
/* 调用 zgebal 函数，对矩阵进行平衡化处理 */

/*
       Reduce to upper Hessenberg form
       (CWorkspace: need 2*N, prefer N+N*NB)
       (RWorkspace: none)
*/
/* 将矩阵约化为上 Hessenberg 形式，需要复杂工作空间大小为 2*N，推荐大小为 N+N*NB */

itau = 1;
/* 设置用于存储 Householder 向量的工作空间起始索引 itau */

iwrk = itau + *n;
/* 设置整型工作空间的起始索引 iwrk */

i__1 = *lwork - iwrk + 1;
/* 计算可用的工作空间大小 */

zgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1, &ierr);
/* 调用 zgehrd 函数，将矩阵约化为上 Hessenberg 形式 */

if (wantvl) {

/*
          Want left eigenvectors
          Copy Householder vectors to VL
*/

    *(unsigned char *)side = 'L';
    /* 设置 side 参数表示我们需要左特征向量 */

    zlacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl);
    /* 将 Householder 变换向量复制到 VL 矩阵 */

/*
          Generate unitary matrix in VL
          (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
          (RWorkspace: none)
*/

    i__1 = *lwork - iwrk + 1;
    /* 计算可用的工作空间大小 */

    zunghr_(n, &ilo, &ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk], &i__1, &ierr);
    /* 调用 zunghr 函数，生成 VL 中的单位ary 矩阵 */

/*
          Perform QR iteration, accumulating Schur vectors in VL
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/

    iwrk = itau;
    /* 更新工作空间起始索引 */

    i__1 = *lwork - iwrk + 1;
    /* 计算可用的工作空间大小 */

    zhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vl[vl_offset], ldvl, &work[iwrk], &i__1, info);
    /* 调用 zhseqr 函数，执行 QR 迭代，累积 Schur 向量在 VL 中 */

    if (wantvr) {

/*
             Want left and right eigenvectors
             Copy Schur vectors to VR
*/

        *(unsigned char *)side = 'B';
        /* 设置 side 参数表示我们需要左右特征向量 */

        zlacpy_("F", n, n, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr);
        /* 将 Schur 向量复制到 VR 矩阵 */

    }

} else if (wantvr) {

/*
          Want right eigenvectors
          Copy Householder vectors to VR
*/

    *(unsigned char *)side = 'R';
    /* 设置 side 参数表示我们需要右特征向量 */

    zlacpy_("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr);
    /* 将 Householder 变换向量复制到 VR 矩阵 */

/*
          Generate unitary matrix in VR
          (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
          (RWorkspace: none)
*/

    i__1 = *lwork - iwrk + 1;
    /* 计算可用的工作空间大小 */

    zunghr_(n, &ilo, &ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk], &i__1, &ierr);
    /* 调用 zunghr 函数，生成 VR 中的单位ary 矩阵 */

/*
          Perform QR iteration, accumulating Schur vectors in VR
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/

    iwrk = itau;
    /* 更新工作空间起始索引 */

    i__1 = *lwork - iwrk + 1;
    /* 计算可用的工作空间大小 */

    zhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vr[vr_offset], ldvr, &work[iwrk], &i__1, info);

} else {

/*
          Compute eigenvalues only
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/

    iwrk = itau;
    /* 设置工作空间起始索引 */

    i__1 = *lwork - iwrk + 1;
    /* 计算可用的工作空间大小 */
    # 调用名为 zhseqr_ 的外部函数，进行特定操作，传入以下参数：
    # - 第一个参数 "E"
    # - 第二个参数 "N"
    # - 第三个参数 n
    # - 第四个参数指向变量 ilo 的指针
    # - 第五个参数指向变量 ihi 的指针
    # - 第六个参数指向数组 a 的偏移量
    # - 第七个参数 lda，表示数组 a 的列数
    # - 第八个参数指向数组 w 的第一个元素
    # - 第九个参数指向数组 vr 的偏移量
    # - 第十个参数 ldvr，表示数组 vr 的列数
    # - 第十一个参数指向数组 work 的第 iwrk 个元素
    # - 第十二个参数指针 i__1
    # - 最后一个参数指向变量 info 的指针
    zhseqr_("E", "N", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vr[
        vr_offset], ldvr, &work[iwrk], &i__1, info);
    }


这段代码看起来是调用一个名为 `zhseqr_` 的外部函数，传递了多个参数，包括指针和数组的偏移量等。
/*     If INFO > 0 from ZHSEQR, then quit */
if (*info > 0) {
    goto L50;  // 如果从 ZHSEQR 返回的 INFO > 0，则跳转到标签 L50
}

if (wantvl || wantvr) {

/*
      Compute left and/or right eigenvectors
      (CWorkspace: need 2*N)
      (RWorkspace: need 2*N)
*/

    irwork = ibal + *n;  // 计算 RWorkspace 中的起始位置
    ztrevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
         &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &rwork[irwork],
        &ierr);  // 调用 ztrevc 函数计算特征向量
}

if (wantvl) {

/*
      Undo balancing of left eigenvectors
      (CWorkspace: none)
      (RWorkspace: need N)
*/

    zgebak_("B", "L", n, &ilo, &ihi, &rwork[ibal], n, &vl[vl_offset],
        ldvl, &ierr);  // 调用 zgebak 函数对左特征向量进行平衡处理

/*        Normalize left eigenvectors and make largest component real */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        scl = 1. / dznrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);  // 计算归一化因子
        zdscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);  // 对左特征向量进行归一化
        i__2 = *n;
        for (k = 1; k <= i__2; ++k) {
            i__3 = k + i__ * vl_dim1;
            // 计算左特征向量最大分量的平方模
            /* Computing 2nd power */
            d__1 = vl[i__3].r;
            /* Computing 2nd power */
            d__2 = d_imag(&vl[k + i__ * vl_dim1]);
            rwork[irwork + k - 1] = d__1 * d__1 + d__2 * d__2;
        }
        k = idamax_(n, &rwork[irwork], &c__1);  // 找到最大模的位置
        d_cnjg(&z__2, &vl[k + i__ * vl_dim1]);
        d__1 = sqrt(rwork[irwork + k - 1]);
        z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
        tmp.r = z__1.r, tmp.i = z__1.i;
        zscal_(n, &tmp, &vl[i__ * vl_dim1 + 1], &c__1);  // 归一化左特征向量
        i__2 = k + i__ * vl_dim1;
        i__3 = k + i__ * vl_dim1;
        d__1 = vl[i__3].r;
        z__1.r = d__1, z__1.i = 0.;
        vl[i__2].r = z__1.r, vl[i__2].i = z__1.i;  // 使左特征向量最大分量为实数
    }
}

if (wantvr) {

/*
      Undo balancing of right eigenvectors
      (CWorkspace: none)
      (RWorkspace: need N)
*/

    zgebak_("B", "R", n, &ilo, &ihi, &rwork[ibal], n, &vr[vr_offset],
        ldvr, &ierr);  // 调用 zgebak 函数对右特征向量进行平衡处理

/*        Normalize right eigenvectors and make largest component real */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        scl = 1. / dznrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);  // 计算归一化因子
        zdscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);  // 对右特征向量进行归一化
        i__2 = *n;
        for (k = 1; k <= i__2; ++k) {
            i__3 = k + i__ * vr_dim1;
            // 计算右特征向量最大分量的平方模
            /* Computing 2nd power */
            d__1 = vr[i__3].r;
            /* Computing 2nd power */
            d__2 = d_imag(&vr[k + i__ * vr_dim1]);
            rwork[irwork + k - 1] = d__1 * d__1 + d__2 * d__2;
        }
        k = idamax_(n, &rwork[irwork], &c__1);  // 找到最大模的位置
        d_cnjg(&z__2, &vr[k + i__ * vr_dim1]);
        d__1 = sqrt(rwork[irwork + k - 1]);
        z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
        tmp.r = z__1.r, tmp.i = z__1.i;
        zscal_(n, &tmp, &vr[i__ * vr_dim1 + 1], &c__1);  // 归一化右特征向量
        i__2 = k + i__ * vr_dim1;
        i__3 = k + i__ * vr_dim1;
        d__1 = vr[i__3].r;
        z__1.r = d__1, z__1.i = 0.;
        vr[i__2].r = z__1.r, vr[i__2].i = z__1.i;  // 使右特征向量最大分量为实数
    }
}

/*     Undo scaling if necessary */
/* Subroutine */ int zgehd2_(integer *n, integer *ilo, integer *ihi,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublecomplex alpha;
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *);

    /*
        -- LAPACK routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
        November 2006


        Purpose
        =======

        ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H
        by a unitary similarity transformation:  Q' * A * Q = H .

        Arguments
        =========

        N       (input) INTEGER
                The order of the matrix A.  N >= 0.

        ILO     (input) INTEGER
        IHI     (input) INTEGER
                It is assumed that A is already upper triangular in rows
                and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
                set by a previous call to ZGEBAL; otherwise they should be
                set to 1 and N respectively. See Further Details.
                1 <= ILO <= IHI <= max(1,N).

        A       (input/output) COMPLEX*16 array, dimension (LDA,N)
                On entry, the n by n general matrix to be reduced.
                On exit, the upper triangle and the first subdiagonal of A
                are overwritten with the upper Hessenberg matrix H, and the
                elements below the first subdiagonal, with the array TAU,
                represent the unitary matrix Q as a product of elementary
                reflectors. See Further Details.

        LDA     (input) INTEGER
                The leading dimension of the array A.  LDA >= max(1,N).

        TAU     (output) COMPLEX*16 array, dimension (N-1)
                The scalar factors of the elementary reflectors (see Further
                Details).

        WORK    (workspace) COMPLEX*16 array, dimension (N)

        INFO    (output) INTEGER
                = 0:  successful exit
                < 0:  if INFO = -i, the i-th argument had an illegal value.

        Further Details
        ===============

        The matrix Q is represented as a product of (ihi-ilo) elementary
    */
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

# 计算反射器 Q，它是 H(ilo) 到 H(ihi-1) 的乘积。

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:

    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    =====================================================================


       Test the input parameters

# 每个 H(i) 的形式为 I - tau * v * v'，其中 tau 是复数标量，v 是复向量，满足 v(1:i) = 0, v(i+1) = 1，v(ihi+1:n) = 0；v(i+2:ihi) 的值存储在 A(i+2:ihi,i) 中，tau 存储在 TAU(i) 中。矩阵 A 的内容在示例中进行了说明，其中 n = 7, ilo = 2, ihi = 6。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    // 检查输入参数是否合法
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    }
    // 如果有错误参数，调用错误处理程序并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGEHD2", &i__1);
        return 0;
    }

    // 循环处理每一个元素
    i__1 = *ihi - 1;
    for (i__ = *ilo; i__ <= i__1; ++i__) {

/*        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) */

        // 计算用于消除 A(i+2:ihi, i) 的元素反射器 H(i)
        i__2 = i__ + 1 + i__ * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
        i__2 = *ihi - i__;
        // 调用 LAPACK 中的 zlarfg 函数计算反射系数和向量
        /* Computing MIN */
        i__3 = i__ + 2;
        zlarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1, &tau[
            i__]);
        i__2 = i__ + 1 + i__ * a_dim1;
        a[i__2].r = 1., a[i__2].i = 0.;

/*        Apply H(i) to A(1:ihi,i+1:ihi) from the right */

        // 应用反射器 H(i) 到 A(1:ihi, i+1:ihi) 的右侧
        i__2 = *ihi - i__;
        zlarf_("Right", ihi, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &a[(i__ + 1) * a_dim1 + 1], lda, &work[1]);

/*        Apply H(i)' to A(i+1:ihi,i+1:n) from the left */

        // 应用 H(i)' 到 A(i+1:ihi, i+1:n) 的左侧
        i__2 = *ihi - i__;
        i__3 = *n - i__;
        d_cnjg(&z__1, &tau[i__]);
        zlarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &z__1,
             &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);

        i__2 = i__ + 1 + i__ * a_dim1;
        a[i__2].r = alpha.r, a[i__2].i = alpha.i;
/* L10: */
    }

    return 0;

/*     End of ZGEHD2 */

} /* zgehd2_ */

/* Subroutine */ int zgehrd_(integer *n, integer *ilo, integer *ihi,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j;
    static doublecomplex t[4160]    /* was [65][64] */;
    static integer ib;
    static doublecomplex ei;
    static integer nb, nh, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *), ztrmm_(char *, char *, char *, char *,
         integer *, integer *, doublecomplex *, doublecomplex *, integer *
        , doublecomplex *, integer *),
        zaxpy_(integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *), zgehd2_(integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *), zlahr2_(integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(
        char *, integer *);
    # 外部函数声明：ilaenv_ 是一个外部函数，接受多个参数，返回整数值
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 外部子程序声明：zlarfb_ 是一个外部子程序，接受多个参数，无返回值
    extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    # 静态变量声明：ldwork 是一个整数类型的静态变量
    static integer ldwork,

    # lwkopt 是一个整数类型的静态变量
    static integer lwkopt;

    # 逻辑类型的静态变量声明：lquery 是一个逻辑（布尔）类型的静态变量
    static logical lquery;
"""
    -- LAPACK routine (version 3.2.1)                                  --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --

    Purpose
    =======
    
    ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
    an unitary similarity transformation:  Q' * A * Q = H .

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to ZGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.

    WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:
"""
    # Test the input parameters
    # 测试输入参数

    on entry,
    # 在进入时，

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    # 原始矩阵 A 的一部分
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    # 原始矩阵 A 的一部分
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    # 原始矩阵 A 的一部分
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    # 原始矩阵 A 的一部分
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    # 原始矩阵 A 的一部分
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    # 原始矩阵 A 的一部分
    (                         a )    (                          a )
    # 原始矩阵 A 的一部分

    where a denotes an element of the original matrix A, h denotes a
    # 这里的 a 表示原始矩阵 A 中的一个元素，h 表示上 Hessenberg 矩阵 H 中的一个修改后的元素，

    modified element of the upper Hessenberg matrix H, and vi denotes an
    # vi 表示定义 H(i) 的向量中的一个元素。

    This file is a slight modification of LAPACK-3.0's DGEHRD
    subroutine incorporating improvements proposed by Quintana-Orti and
    Van de Geijn (2006). (See DLAHR2.)
    # 这个文件是 LAPACK-3.0 版本的 DGEHRD 子程序的轻微修改，包括 Quintana-Orti 和 Van de Geijn（2006年）提出的改进。详见 DLAHR2。

    =====================================================================
    # =====================================================================
/*
    调整参数
*/
    /* 将维度参数 a_dim1 设为 lda */
    a_dim1 = *lda;
    /* 计算数组 a 的 offset */
    a_offset = 1 + a_dim1;
    a -= a_offset;
    /* 调整数组 tau 和 work 的指针 */
    --tau;
    --work;

    /* 初始化 info 为 0 */
    *info = 0;
    /* 计算最小值 */
/* Computing MIN */
    i__1 = 64, i__2 = ilaenv_(&c__1, "ZGEHRD", " ", n, ilo, ihi, &c_n1, (ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);
    /* 计算工作区大小的估计值 */
    lwkopt = *n * nb;
    /* 设置 work 的第一个元素为估计的工作区大小 */
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    /* 检查是否为查询工作区大小 */
    lquery = *lwork == -1;
    /* 根据不同情况设置 info 的值 */
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;
    }
    /* 如果 info 不为 0，调用错误处理函数并返回 */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGEHRD", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     设置 TAU 元素的值为零 */

    i__1 = *ilo - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        tau[i__2].r = 0., tau[i__2].i = 0.;
    }
    i__1 = *n - 1;
    for (i__ = max(1,*ihi); i__ <= i__1; ++i__) {
        i__2 = i__;
        tau[i__2].r = 0., tau[i__2].i = 0.;
    }

/*     若可能，快速返回 */

    nh = *ihi - *ilo + 1;
    if (nh <= 1) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

/*
       确定块大小

   Computing MIN
*/
    i__1 = 64, i__2 = ilaenv_(&c__1, "ZGEHRD", " ", n, ilo, ihi, &c_n1, (ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);
    nbmin = 2;
    iws = 1;
    if (nb > 1 && nb < nh) {

/*
          确定何时从分块代码切换到非分块代码
          (最后一块始终由非分块代码处理)

   Computing MAX
*/
    i__1 = nb, i__2 = ilaenv_(&c__3, "ZGEHRD", " ", n, ilo, ihi, &c_n1, (ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);
    if (nx < nh) {

/*           确定工作区是否足够用于分块代码 */

        iws = *n * nb;
        if (*lwork < iws) {

/*
                工作区不足以使用最佳的 NB：确定 NB 的最小值，并减小 NB 或强制使用非分块代码

   Computing MAX
*/
        i__1 = 2, i__2 = ilaenv_(&c__2, "ZGEHRD", " ", n, ilo, ihi, &c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);
        if (*lwork >= *n * nbmin) {
            nb = *lwork / *n;
        } else {
            nb = 1;
        }
        }
    }
    }
    ldwork = *n;

    if (nb < nbmin || nb >= nh) {

/*        在下面使用非分块代码 */

    i__ = *ilo;

    } else {

/*        使用分块代码 */

    i__1 = *ihi - 1 - nx;
    i__2 = nb;
    for (i__ = *ilo; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = nb, i__4 = *ihi - i__;
        ib = min(i__3,i__4);
/*
             Reduce columns i:i+ib-1 to Hessenberg form, returning the
             matrices V and T of the block reflector H = I - V*T*V'
             which performs the reduction, and also the matrix Y = A*V*T
*/

        zlahr2_(ihi, &i__, &ib, &a[i__ * a_dim1 + 1], lda, &tau[i__], t, &
            c__65, &work[1], &ldwork);
/*
             调用 LAPACK 子程序 zlahr2_ 对矩阵的列 i 到 i+ib-1 进行 Hessenberg 形式的约化。
             返回的 V 和 T 矩阵构成分块反射器 H = I - V*T*V'，同时计算 A*V*T 的结果 Y。
*/

/*
             Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
             right, computing  A := A - Y * V'. V(i+ib,ib-1) must be set
             to 1
*/

        i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
        ei.r = a[i__3].r, ei.i = a[i__3].i;
        i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
        a[i__3].r = 1., a[i__3].i = 0.;
        i__3 = *ihi - i__ - ib + 1;
        z__1.r = -1., z__1.i = -0.;
        zgemm_("No transpose", "Conjugate transpose", ihi, &i__3, &ib, &
            z__1, &work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda,
             &c_b57, &a[(i__ + ib) * a_dim1 + 1], lda);
        i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
        a[i__3].r = ei.r, a[i__3].i = ei.i;

/*
             将分块反射器 H 从右边应用于 A(1:ihi,i+ib:ihi)，
             计算 A := A - Y * V'。需要设置 V(i+ib,ib-1) 为 1。

/*
             Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
             right
*/

        i__3 = ib - 1;
        ztrmm_("Right", "Lower", "Conjugate transpose", "Unit", &i__, &
            i__3, &c_b57, &a[i__ + 1 + i__ * a_dim1], lda, &work[1], &
            ldwork);
        i__3 = ib - 2;
        for (j = 0; j <= i__3; ++j) {
        z__1.r = -1., z__1.i = -0.;
        zaxpy_(&i__, &z__1, &work[ldwork * j + 1], &c__1, &a[(i__ + j
            + 1) * a_dim1 + 1], &c__1);
/* L30: */
        }

/*
             将分块反射器 H 从右边应用于 A(1:i,i+1:i+ib-1)。

/*
             Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
             left
*/

        i__3 = *ihi - i__;
        i__4 = *n - i__ - ib + 1;
        zlarfb_("Left", "Conjugate transpose", "Forward", "Columnwise", &
            i__3, &i__4, &ib, &a[i__ + 1 + i__ * a_dim1], lda, t, &
            c__65, &a[i__ + 1 + (i__ + ib) * a_dim1], lda, &work[1], &
            ldwork);
/* L40: */
    }
    }

/*     Use unblocked code to reduce the rest of the matrix */

    zgehd2_(n, &i__, ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
    work[1].r = (doublereal) iws, work[1].i = 0.;

    return 0;

/*     End of ZGEHRD */

} /* zgehrd_ */

/* Subroutine */ int zgelq2_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublecomplex *tau, doublecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k;
    static doublecomplex alpha;
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), zlacgv_(integer *, doublecomplex *,
        integer *);

/*
    -- LAPACK routine (version 3.2.2) --
*/
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


# LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，版本为2010年6月。



    Purpose
    =======


# 函数目的说明



    ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
    A = L * Q.


# ZGELQ2 函数计算复数矩阵 A 的 LQ 分解：
# A = L * Q。



    Arguments
    =========


# 函数参数



    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.


# M       (输入) 整数
#         矩阵 A 的行数。要求 M >= 0。



    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.


# N       (输入) 整数
#         矩阵 A 的列数。要求 N >= 0。



    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m <= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).


# A       (输入/输出) 复数数组，维度为 COMPLEX*16 (LDA,N)
#         在输入时，是一个 m 行 n 列的矩阵 A。
#         在输出时，数组的对角线及其以下元素包含 m 行 min(m,n) 列的下梯形矩阵 L
#         （如果 m <= n，则 L 是下三角矩阵）；对角线以上的元素以及数组 TAU 表示单位矩阵 Q，
#         是由一系列初等反射变换的乘积（详见 Further Details）。



    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).


# LDA     (输入) 整数
#         数组 A 的主维度。要求 LDA >= max(1,M)。



    TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).


# TAU     (输出) 复数数组，维度为 COMPLEX*16 (min(M,N))
#         初等反射变换的标量因子（详见 Further Details）。



    WORK    (workspace) COMPLEX*16 array, dimension (M)


# WORK    (工作空间) 复数数组，维度为 COMPLEX*16 (M)



    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value


# INFO    (输出) 整数
#         = 0: 执行成功退出
#         < 0: 如果 INFO = -i，第 i 个参数值非法



    Further Details
    ===============


# 更多细节说明



    The matrix Q is represented as a product of elementary reflectors

       Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).


# 矩阵 Q 表示为一系列初等反射变换的乘积

#    Q = H(k)' . . . H(2)' H(1)', 其中 k = min(m,n)。



    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
    A(i,i+1:n), and tau in TAU(i).


# 每个 H(i) 的形式为

#    H(i) = I - tau * v * v'

# 其中 tau 是一个复数标量，v 是一个复向量，满足 v(1:i-1) = 0 和 v(i) = 1；
# conjg(v(i+1:n)) 存储在 A(i,i+1:n) 中，tau 存储在 TAU(i) 中。



    =====================================================================

       Test the input arguments


# 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  /* 初始化 info 参数为 0 */

    /* 检查输入参数的有效性 */
    if (*m < 0) {  /* 如果输入参数 m 小于 0 */
        *info = -1;  /* 将 info 设为 -1 */
    } else if (*n < 0) {  /* 否则如果输入参数 n 小于 0 */
        *info = -2;  /* 将 info 设为 -2 */
    } else if (*lda < max(1,*m)) {  /* 否则如果输入参数 lda 小于 max(1, m) */
        *info = -4;  /* 将 info 设为 -4 */
    }

    /* 如果有错误参数，调用 xerbla 函数报错 */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGELQ2", &i__1);  /* 调用 xerbla 函数报告错误 */
        return 0;  /* 返回 */
    }

    k = min(*m,*n);  /* 计算 k 为 m 和 n 中较小的那个 */

    /* 对矩阵进行 LQ 分解的主循环 */
    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i,i+1:n) */

        i__2 = *n - i__ + 1;
        zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);  /* 调用 zlacgv 函数 */
        i__2 = i__ + i__ * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;  /* 获取当前元素的值 */
        i__2 = *n - i__ + 1;
        /* 计算 zlarfg 函数所需的参数 */
        /* Computing MIN */
        i__3 = i__ + 1;
        zlarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &tau[i__]);
        
        if (i__ < *m) {

/*           Apply H(i) to A(i+1:m,i:n) from the right */

            i__2 = i__ + i__ * a_dim1;
            a[i__2].r = 1., a[i__2].i = 0.;  /* 设置单位矩阵 */
            i__2 = *m - i__;
            i__3 = *n - i__ + 1;
            zlarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__],
                   &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);  /* 调用 zlarf 函数 */
        }
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = alpha.r, a[i__2].i = alpha.i;  /* 恢复当前元素的值 */
        i__2 = *n - i__ + 1;
        zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);  /* 调用 zlacgv 函数 */
        /* L10: */
    }

    return 0;

/*     End of ZGELQ2 */

} /* zgelq2_ */

/* Subroutine */ int zgelqf_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublecomplex *tau, doublecomplex *work, integer *lwork,
    integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int zgelq2_(integer *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *), xerbla_(
        char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    static integer lwkopt;
    static logical lquery;


    /*
        -- LAPACK routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006


        Purpose
        =======

        ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
        A = L * Q.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A.  M >= 0.
    ! 测试输入参数的有效性
    N       (input) INTEGER
            矩阵 A 的列数。要求 N >= 0。

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            输入时，M×N 矩阵 A。
            输出时，数组的对角线及其以下元素包含了 M×min(M,N) 的下梯形矩阵 L
            （若 m <= n，则 L 是下三角形矩阵）；对角线以上的元素，配合数组 TAU，
            表示单位矩阵 Q，作为一系列基本反射器的乘积（详见 Further Details）。

    LDA     (input) INTEGER
            数组 A 的领先维数。要求 LDA >= max(1,M)。

    TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            基本反射器的标量因子（详见 Further Details）。

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            输出时，如果 INFO = 0，则 WORK(1) 返回最优 LWORK 的值。

    LWORK   (input) INTEGER
            数组 WORK 的维数。要求 LWORK >= max(1,M)。
            为了最佳性能，要求 LWORK >= M*NB，其中 NB 是最优块大小。

            若 LWORK = -1，则假定需要一个工作空间查询；程序只计算 WORK 数组的最优大小，
            将该值作为 WORK 数组的第一个条目返回，且不会因 LWORK 相关的任何错误信息
            而调用 XERBLA。

    INFO    (output) INTEGER
            = 0:  成功退出
            < 0:  若 INFO = -i，则第 i 个参数的值非法

    Further Details
    ===============

    矩阵 Q 被表示为一系列基本反射器的乘积

       Q = H(k)' . . . H(2)' H(1)'

    其中 k = min(m,n)。

    每个 H(i) 具有以下形式

       H(i) = I - tau * v * v'

    这里 tau 是一个复数标量，v 是一个复向量，满足 v(1:i-1) = 0 且 v(i) = 1；
    conjg(v(i+1:n)) 在退出时存储在 A(i,i+1:n) 中，tau 存储在 TAU(i) 中。

    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 变量为 0
    nb = ilaenv_(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 获取最优块大小 nb
    lwkopt = *m * nb;  // 计算所需的最大工作空间大小
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;  // 设置工作数组第一个元素为所需工作空间大小
    lquery = *lwork == -1;  // 判断是否为查询工作空间大小的特殊情况
    if (*m < 0) {  // 检查 m 的有效性
    *info = -1;
    } else if (*n < 0) {  // 检查 n 的有效性
    *info = -2;
    } else if (*lda < max(1,*m)) {  // 检查 lda 的有效性
    *info = -4;
    } else if (*lwork < max(1,*m) && ! lquery) {  // 检查 lwork 的有效性
    *info = -7;
    }
    if (*info != 0) {  // 如果出现错误信息不为零，调用错误处理函数并返回
    i__1 = -(*info);
    xerbla_("ZGELQF", &i__1);
    return 0;
    } else if (lquery) {  // 如果是查询工作空间大小的情况，直接返回
    return 0;
    }

/*     Quick return if possible */

    k = min(*m,*n);  // 计算 k 的值为 m 和 n 中的较小者
    if (k == 0) {  // 如果 k 为 0，直接返回
    work[1].r = 1., work[1].i = 0.;
    return 0;
    }

    nbmin = 2;  // 设置最小的块大小为 2
    nx = 0;  // 初始化 nx 变量为 0
    iws = *m;  // 设置初始工作空间大小为 m
    if (nb > 1 && nb < k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "ZGELQF", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算 nx 的值为 0 和 ilaenv 调用结果的较大者
    if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *m;  // 设置 ldwork 为 m
        iws = ldwork * nb;  // 计算所需工作空间大小
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        nb = *lwork / ldwork;  // 调整 nb 的大小为可用工作空间大小除以 ldwork
/* Computing MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "ZGELQF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);  // 计算 nbmin 的值为 2 和 ilaenv 调用结果的较大者
        }
    }
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

    i__1 = k - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = k - i__ + 1;
        ib = min(i__3,nb);  // 计算当前块的大小 ib

/*
             Compute the LQ factorization of the current block
             A(i:i+ib-1,i:n)
*/

        i__3 = *n - i__ + 1;
        zgelq2_(&ib, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);  // 执行 LQ 分解

        if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__3 = *n - i__ + 1;
        zlarft_("Forward", "Rowwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);  // 计算分块反射器的三角因子

/*              Apply H to A(i+ib:m,i:n) from the right */

        i__3 = *m - i__ - ib + 1;
        i__4 = *n - i__ + 1;
        zlarfb_("Right", "No transpose", "Forward", "Rowwise", &i__3,
            &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
            ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib +
            1], &ldwork);  // 应用分块反射器到 A 的右下角区域
        }
/* L10: */
    }
    } else {
    i__ = 1;
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {
    i__2 = *m - i__ + 1;
    i__1 = *n - i__ + 1;
    # 调用 LAPACK 库函数 zgelq2_ 进行 LQ 分解计算
    zgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    # 结束循环后，设置 work 数组的第一个元素为 iws 的实部，虚部为 0
    work[1].r = (doublereal) iws, work[1].i = 0.;
    # 返回函数执行成功的标志，通常用整数 0 表示成功
    return 0;
/*     End of ZGELQF */

} /* zgelqf_ */

/* Subroutine */ int zgelsd_(integer *m, integer *n, integer *nrhs,
    doublecomplex *a, integer *lda, doublecomplex *b, integer *ldb,
    doublereal *s, doublereal *rcond, integer *rank, doublecomplex *work,
    integer *lwork, doublereal *rwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer ie, il, mm;
    static doublereal eps, anrm, bnrm;
    static integer itau, nlvl, iascl, ibscl;
    static doublereal sfmin;
    static integer minmn, maxmn, itaup, itauq, mnthr, nwork;
    extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);

    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), dlaset_(char *, integer *, integer
        *, doublereal *, doublereal *, doublereal *, integer *),
        xerbla_(char *, integer *), zgebrd_(integer *, integer *,
        doublecomplex *, integer *, doublereal *, doublereal *,
        doublecomplex *, doublecomplex *, doublecomplex *, integer *,
        integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern doublereal zlange_(char *, integer *, integer *, doublecomplex *,
        integer *, doublereal *);
    static doublereal bignum;
    extern /* Subroutine */ int zgelqf_(integer *, integer *, doublecomplex *,
         integer *, doublecomplex *, doublecomplex *, integer *, integer *
        ), zlalsd_(char *, integer *, integer *, integer *, doublereal *,
        doublereal *, doublecomplex *, integer *, doublereal *, integer *,
         doublecomplex *, doublereal *, integer *, integer *),
        zlascl_(char *, integer *, integer *, doublereal *, doublereal *,
        integer *, integer *, doublecomplex *, integer *, integer *), zgeqrf_(integer *, integer *, doublecomplex *, integer *,
         doublecomplex *, doublecomplex *, integer *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *),
        zlaset_(char *, integer *, integer *, doublecomplex *,
        doublecomplex *, doublecomplex *, integer *);
    static integer liwork, minwrk, maxwrk;
    static doublereal smlnum;
    extern /* Subroutine */ int zunmbr_(char *, char *, char *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         doublecomplex *, integer *, doublecomplex *, integer *, integer *
        );
    static integer lrwork;
    static logical lquery;
    static integer nrwork, smlsiz;



注释：
    # 声明外部函数 `zunmlq_` 和 `zunmqr_`，它们在其他地方定义或实现。
    extern /* Subroutine */ int zunmlq_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *), zunmqr_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);
"""
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZGELSD computes the minimum-norm solution to a real linear least
    squares problem:
        minimize 2-norm(| b - A*x |)
    using the singular value decomposition (SVD) of A. A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The problem is solved in three steps:
    (1) Reduce the coefficient matrix A to bidiagonal form with
        Householder tranformations, reducing the original problem
        into a "bidiagonal least squares problem" (BLS)
    (2) Solve the BLS using a divide and conquer approach.
    (3) Apply back all the Householder tranformations to solve
        the original least squares problem.

    The effective rank of A is determined by treating as zero those
    singular values which are less than RCOND times the largest singular
    value.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A. N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrices B and X. NRHS >= 0.

    A       (input) COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,M).

    B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, B is overwritten by the N-by-NRHS solution matrix X.
            If m >= n and RANK = n, the residual sum-of-squares for
            the solution in the i-th column is given by the sum of
            squares of the modulus of elements n+1:m in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M,N).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A in decreasing order.
            The condition number of A in the 2-norm = S(1)/S(min(m,n)).
"""
    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A.
            Singular values S(i) <= RCOND*S(1) are treated as zero.
            If RCOND < 0, machine precision is used instead.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the number of singular values
            which are greater than RCOND*S(1).

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK must be at least 1.
            The exact minimum amount of workspace needed depends on M,
            N and NRHS. As long as LWORK is at least
                2*N + N*NRHS
            if M is greater than or equal to N or
                2*M + M*NRHS
            if M is less than N, the code will execute correctly.
            For good performance, LWORK should generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the array WORK and the
            minimum sizes of the arrays RWORK and IWORK, and returns
            these values as the first entries of the WORK, RWORK and
            IWORK arrays, and no error message related to LWORK is issued
            by XERBLA.

    RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
            LRWORK >=
               10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
               MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )
            if M is greater than or equal to N or
               10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
               MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )
            if M is less than N, the code will execute correctly.
            SMLSIZ is returned by ILAENV and is equal to the maximum
            size of the subproblems at the bottom of the computation
            tree (usually about 25), and
               NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
            On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK.

    IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
            LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),
            where MINMN = MIN( M,N ).
            On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value.
            > 0:  the algorithm for computing the SVD failed to converge;
                  if INFO = i, i off-diagonal elements of an intermediate
                  bidiagonal form did not converge to zero.

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA
    =====================================================================

       Test the input arguments.
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --s;
    --work;
    --rwork;
    --iwork;

    /* Function Body */
    *info = 0;
    minmn = min(*m,*n);
    maxmn = max(*m,*n);
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*nrhs < 0) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*ldb < max(1,maxmn)) {
        *info = -7;
    }

/*
       Compute workspace.
       (Note: Comments in the code beginning "Workspace:" describe the
       minimal amount of workspace needed at that point in the code,
       as well as the preferred amount for good performance.
       NB refers to the optimal block size for the immediately
       following subroutine, as returned by ILAENV.)
*/

    if (*info == 0) {
        minwrk = 1;
        maxwrk = 1;
        liwork = 1;
        lrwork = 1;
        if (minmn > 0) {
            smlsiz = ilaenv_(&c__9, "ZGELSD", " ", &c__0, &c__0, &c__0, &c__0,
                             (ftnlen)6, (ftnlen)1);
            mnthr = ilaenv_(&c__6, "ZGELSD", " ", m, n, nrhs, &c_n1, (ftnlen)6,
                            (ftnlen)1);
            /* Computing MAX */
            i__1 = (integer) (log((doublereal) minmn / (doublereal) (smlsiz +
                1)) / log(2.)) + 1;
            nlvl = max(i__1,0);
            liwork = minmn * 3 * nlvl + minmn * 11;
            mm = *m;
            if (*m >= *n && *m >= mnthr) {

/*
                Path 1a - overdetermined, with many more rows than
                          columns.
*/

                mm = *n;
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n * ilaenv_(&c__1, "ZGEQRF", " ", m, n,
                     &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *nrhs * ilaenv_(&c__1, "ZUNMQR", "LC",
                    m, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)2);
                maxwrk = max(i__1,i__2);
            }
            if (*m >= *n) {

/*
                Path 1 - overdetermined or exactly determined.

   Computing MAX
   Computing 2nd power
*/

                i__3 = smlsiz + 1;
                i__1 = i__3 * i__3, i__2 = *n * (*nrhs + 1) + (*nrhs << 1);
                lrwork = *n * 10 + (*n << 1) * smlsiz + (*n << 3) * nlvl +
                    smlsiz * 3 * *nrhs + max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (mm + *n) * ilaenv_(&c__1,
                    "ZGEBRD", " ", &mm, n, &c_n1, &c_n1, (ftnlen)6, (
                    ftnlen)1);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + *nrhs * ilaenv_(&c__1,
                    "ZUNMBR", "QLC", &mm, nrhs, n, &c_n1, (ftnlen)6, (
                    ftnlen)3);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                    "ZUNMBR", "PLN", n, nrhs, n, &c_n1, (ftnlen)6, (
                    ftnlen)3);
                maxwrk = max(i__1,i__2);
            }
        }
    }
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
        i__1 = maxwrk, i__2 = (*n << 1) + *n * *nrhs;
        maxwrk = max(i__1,i__2);

/* Computing MAX */
/* 计算两个值的最大值，并更新 minwrk */
        i__1 = (*n << 1) + mm, i__2 = (*n << 1) + *n * *nrhs;
        minwrk = max(i__1,i__2);
        }
        if (*n > *m) {

/*
   Computing MAX
   Computing 2nd power
*/
/* 计算一个表达式的值，用于计算 lrwork */
        i__3 = smlsiz + 1;
        i__1 = i__3 * i__3, i__2 = *n * (*nrhs + 1) + (*nrhs << 1);
        lrwork = *m * 10 + (*m << 1) * smlsiz + (*m << 3) * nlvl +
            smlsiz * 3 * *nrhs + max(i__1,i__2);

        if (*n >= mnthr) {

/*
                   Path 2a - underdetermined, with many more columns
                             than rows.
*/

/* 根据不同条件计算 maxwrk 的值 */
            maxwrk = *m + *m * ilaenv_(&c__1, "ZGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m << 1) *
                ilaenv_(&c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1,
                (ftnlen)6, (ftnlen)1);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *nrhs *
                ilaenv_(&c__1, "ZUNMBR", "QLC", m, nrhs, m, &c_n1,
                 (ftnlen)6, (ftnlen)3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m - 1) *
                ilaenv_(&c__1, "ZUNMLQ", "LC", n, nrhs, m, &c_n1,
                (ftnlen)6, (ftnlen)2);
            maxwrk = max(i__1,i__2);
            if (*nrhs > 1) {
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + *m + *m * *nrhs;
            maxwrk = max(i__1,i__2);
            } else {
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 1);
            maxwrk = max(i__1,i__2);
            }
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *m * *nrhs;
            maxwrk = max(i__1,i__2);
/*
       XXX: Ensure the Path 2a case below is triggered.  The workspace
       calculation should use queries for all routines eventually.
   Computing MAX
   Computing MAX
*/
/* 计算一系列表达式的最大值，并更新 maxwrk */
            i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4),
                i__3 = max(i__3,*nrhs), i__4 = *n - *m * 3;
            i__1 = maxwrk, i__2 = (*m << 2) + *m * *m + max(i__3,i__4)
                ;
            maxwrk = max(i__1,i__2);
        } else {

/*                 Path 2 - underdetermined. */

/* 根据不同条件计算 maxwrk 的值 */
            maxwrk = (*m << 1) + (*n + *m) * ilaenv_(&c__1, "ZGEBRD",
                " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = (*m << 1) + *nrhs * ilaenv_(&c__1,
                "ZUNMBR", "QLC", m, nrhs, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，并更新 maxwrk */
            i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "PLN", n, nrhs, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */
i__1 = maxwrk, i__2 = (*m << 1) + *m * *nrhs;
maxwrk = max(i__1,i__2);



/* Computing MAX */
/* 计算两个值的最大值，用于确定最小工作空间的大小 */
i__1 = (*m << 1) + *n, i__2 = (*m << 1) + *m * *nrhs;
minwrk = max(i__1,i__2);



minwrk = min(minwrk,maxwrk);
/* 确定最终需要的工作空间大小，取最小值 */



work[1].r = (doublereal) maxwrk, work[1].i = 0.;
/* 设置工作空间数组的第一个元素为最大工作空间大小 */



iwork[1] = liwork;
/* 设置整型工作空间数组的第一个元素为整型工作空间大小 */



rwork[1] = (doublereal) lrwork;
/* 设置实型工作空间数组的第一个元素为实型工作空间大小 */



if (*lwork < minwrk && ! lquery) {
    *info = -12;
}
/* 如果提供的工作空间小于所需的最小工作空间且非查询模式，则返回错误码 */



if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZGELSD", &i__1);
    return 0;
} else if (lquery) {
    return 0;
}
/* 处理错误信息和查询模式的返回情况 */



/* Quick return if possible. */
/* 如果可能的话，快速返回 */
if (*m == 0 || *n == 0) {
    *rank = 0;
    return 0;
}
/* 如果矩阵维度为零，则设置秩为零并快速返回 */



/* Get machine parameters. */
/* 获取机器参数 */
eps = PRECISION;
sfmin = SAFEMINIMUM;
smlnum = sfmin / eps;
bignum = 1. / smlnum;
dlabad_(&smlnum, &bignum);
/* 设置机器精度相关的参数 */



/* Scale A if max entry outside range [SMLNUM,BIGNUM]. */
/* 如果矩阵A的最大元素超出了范围[SMLNUM,BIGNUM]，则进行缩放 */
anrm = zlange_("M", m, n, &a[a_offset], lda, &rwork[1]);
iascl = 0;
if (anrm > 0. && anrm < smlnum) {
    /* 如果矩阵A的范数在SMLNUM以下，则将矩阵缩放到SMLNUM */
} else if (anrm > bignum) {
    /* 如果矩阵A的范数超过BIGNUM，则将矩阵缩放到BIGNUM */
} else if (anrm == 0.) {
    /* 如果矩阵A全为零，则返回零解 */
}



/* Scale B if max entry outside range [SMLNUM,BIGNUM]. */
/* 如果矩阵B的最大元素超出了范围[SMLNUM,BIGNUM]，则进行缩放 */
bnrm = zlange_("M", m, nrhs, &b[b_offset], ldb, &rwork[1]);
ibscl = 0;
if (bnrm > 0. && bnrm < smlnum) {
    /* 如果矩阵B的范数在SMLNUM以下，则将矩阵缩放到SMLNUM */
} else if (bnrm > bignum) {
    /* 如果矩阵B的范数超过BIGNUM，则将矩阵缩放到BIGNUM */
}



/* If M < N make sure B(M+1:N,:) = 0 */
/* 如果M < N，则确保B(M+1:N,:) = 0 */
if (*m < *n) {
    /* 将B的下部分置零 */
}



/* Overdetermined case. */
/* 超定或完全确定的情况 */
if (*m >= *n) {
    /* 如果行数大于等于列数 */

    /* Path 1 - overdetermined or exactly determined. */
    /* 路径1 - 超定或完全确定的情况 */

    if (*m >= mnthr) {
        /* 如果行数大于等于mnthr */

        /* Path 1a - overdetermined, with many more rows than columns */
        /* 路径1a - 超定，行数远大于列数 */

        mm = *n;
        itau = 1;
        nwork = itau + *n;

        /*
             Compute A=Q*R.
             (RWorkspace: need N)
             (CWorkspace: need N, prefer N*NB)
        */
        /* 计算QR分解 */
    }
}
/*
             Multiply B by transpose(Q).
             (RWorkspace: need N)
             (CWorkspace: need NRHS, prefer NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
zunmqr_("L", "C", m, nrhs, n, &a[a_offset], lda, &work[itau], &b[
    b_offset], ldb, &work[nwork], &i__1, info);

/*           Zero out below R. */
if (*n > 1) {
    i__1 = *n - 1;
    i__2 = *n - 1;
    zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &a[a_dim1 + 2],
        lda);
}
}

itauq = 1;
itau = itauq + *n;
nwork = itau + *n;
ie = 1;
nrwork = ie + *n;

/*
          Bidiagonalize R in A.
          (RWorkspace: need N)
          (CWorkspace: need 2*N+MM, prefer 2*N+(MM+N)*NB)
*/
i__1 = *lwork - nwork + 1;
zgebrd_(&mm, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq], &
    work[itau], &work[nwork], &i__1, info);

/*
          Multiply B by transpose of left bidiagonalizing vectors of R.
          (CWorkspace: need 2*N+NRHS, prefer 2*N+NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
zunmbr_("Q", "L", "C", &mm, nrhs, n, &a[a_offset], lda, &work[itauq],
    &b[b_offset], ldb, &work[nwork], &i__1, info);

/*        Solve the bidiagonal least squares problem. */
zlalsd_("U", &smlsiz, n, nrhs, &s[1], &rwork[ie], &b[b_offset], ldb,
    rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1], info);
if (*info != 0) {
    goto L10;
}

/*        Multiply B by right bidiagonalizing vectors of R. */
i__1 = *lwork - nwork + 1;
zunmbr_("P", "L", "N", n, nrhs, n, &a[a_offset], lda, &work[itau],
    &b[b_offset], ldb, &work[nwork], &i__1, info);

} else /* if(complicated condition) */ {
/* Computing MAX */
i__1 = *m, i__2 = (*m << 1) - 4, i__1 = max(i__1,i__2), i__1 = max(
    i__1,*nrhs), i__2 = *n - *m * 3;
if (*n >= mnthr && *lwork >= (*m << 2) + *m * *m + max(i__1,i__2)) {

/*
          Path 2a - underdetermined, with many more columns than rows
          and sufficient workspace for an efficient algorithm.
*/

ldwork = *m;
/*
   Computing MAX
   Computing MAX
*/
i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4), i__3 =
    max(i__3,*nrhs), i__4 = *n - *m * 3;
i__1 = (*m << 2) + *m * *lda + max(i__3,i__4), i__2 = *m * *lda +
    *m + *m * *nrhs;
if (*lwork >= max(i__1,i__2)) {
ldwork = *lda;
}
itau = 1;
nwork = *m + 1;

/*
          Compute A=L*Q.
          (CWorkspace: need 2*M, prefer M+M*NB)
*/
i__1 = *lwork - nwork + 1;
zgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
     info);
il = nwork;
/*        Copy L to WORK(IL), zeroing out above its diagonal. */
将 L 复制到 WORK(IL)，并将其对角线以上的部分清零。

        zlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwork);
调用 zlacpy 函数，将矩阵 a 的下三角部分（L 矩阵）复制到工作数组 work 的位置 il 处。

        i__1 = *m - 1;
        i__2 = *m - 1;
        zlaset_("U", &i__1, &i__2, &c_b56, &c_b56, &work[il + ldwork], &
            ldwork);
调用 zlaset 函数，在工作数组中清零 L 矩阵对角线以上的部分。

        itauq = il + ldwork * *m;
设置 itauq 为工作数组中用于存储向量的位置。

        itaup = itauq + *m;
设置 itaup 为工作数组中用于存储向量的位置。

        nwork = itaup + *m;
设置 nwork 为工作数组中的起始位置，用于后续计算。

        ie = 1;
设置 ie 为一个索引值，用于存储实数工作空间的起始位置。

        nrwork = ie + *m;
设置 nrwork 为实数工作空间的起始位置。

/*
          Bidiagonalize L in WORK(IL).
          (RWorkspace: need M)
          (CWorkspace: need M*M+4*M, prefer M*M+4*M+2*M*NB)
*/
对 L 矩阵进行双对角化处理，结果存储在工作数组中的位置 il 处。

        i__1 = *lwork - nwork + 1;
调用 zgebrd 函数，对 L 矩阵进行双对角化处理，并在工作数组中保存相关的信息。

        zunmbr_("Q", "L", "C", m, nrhs, m, &work[il], &ldwork, &work[
            itauq], &b[b_offset], ldb, &work[nwork], &i__1, info);
调用 zunmbr 函数，将矩阵 B 乘以 L 矩阵的左边的双对角化向量的转置。

/*        Solve the bidiagonal least squares problem. */
解决双对角化最小二乘问题。

        zlalsd_("U", &smlsiz, m, nrhs, &s[1], &rwork[ie], &b[b_offset],
            ldb, rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1],
             info);
调用 zlalsd 函数，解决双对角化的最小二乘问题，得到最终的解。

        if (*info != 0) {
        goto L10;
        }
检查返回信息是否为 0，如果不为 0，则跳转到标签 L10。

        i__1 = *lwork - nwork + 1;
调用 zunmbr 函数，将矩阵 B 乘以 L 矩阵的右边的双对角化向量。

/*        Zero out below first M rows of B. */
将矩阵 B 的前 M 行以下的部分清零。

        i__1 = *n - *m;
调用 zlaset 函数，将矩阵 B 的前 M 行以下的部分清零。

        nwork = itau + *m;
更新 nwork 的值，用于存储后续计算的工作空间。

/*
          Multiply transpose(Q) by B.
          (CWorkspace: need NRHS, prefer NRHS*NB)
*/
将矩阵 B 乘以 Q 的转置。

        i__1 = *lwork - nwork + 1;
调用 zunmlq 函数，将矩阵 B 乘以 Q 的转置，得到最终的结果。

    } else {

/*        Path 2 - remaining underdetermined cases. */
路径 2 - 处理剩余的欠定情况。

        itauq = 1;
设置 itauq 为一个起始位置，用于存储 Q 的左边双对角化向量。

        itaup = itauq + *m;
设置 itaup 为一个起始位置，用于存储 Q 的右边双对角化向量。

        nwork = itaup + *m;
设置 nwork 为工作数组的起始位置，用于存储后续计算的中间结果。

        ie = 1;
设置 ie 为一个起始位置，用于实数工作空间的存储。

        nrwork = ie + *m;
设置 nrwork 为一个起始位置，用于实数工作空间的存储。

/*
          Bidiagonalize A.
          (RWorkspace: need M)
          (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
*/
对矩阵 A 进行双对角化处理，结果存储在工作数组中。

        i__1 = *lwork - nwork + 1;
调用 zgebrd 函数，对矩阵 A 进行双对角化处理，并在工作数组中保存相关的信息。

/*
          Multiply B by transpose of left bidiagonalizing vectors.
          (CWorkspace: need 2*M+NRHS, prefer 2*M+NRHS*NB)
*/
将矩阵 B 乘以 A 的左边的双对角化向量的转置。

        i__1 = *lwork - nwork + 1;
调用 zunmbr 函数，将矩阵 B 乘以 A 的左边的双对角化向量的转置，得到最终结果。
/*        Solve the bidiagonal least squares problem. */

        zlalsd_("L", &smlsiz, m, nrhs, &s[1], &rwork[ie], &b[b_offset],
            ldb, rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1],
             info);
        if (*info != 0) {
        goto L10;
        }

/*        Multiply B by right bidiagonalizing vectors of A. */

        i__1 = *lwork - nwork + 1;
        zunmbr_("P", "L", "N", n, nrhs, m, &a[a_offset], lda, &work[itaup]
            , &b[b_offset], ldb, &work[nwork], &i__1, info);

    }
    }

/*     Undo scaling. */

    if (iascl == 1) {
    zlascl_("G", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb,
         info);
    dlascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &
        minmn, info);
    } else if (iascl == 2) {
    zlascl_("G", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb,
         info);
    dlascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
        minmn, info);
    }
    if (ibscl == 1) {
    zlascl_("G", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb,
         info);
    } else if (ibscl == 2) {
    zlascl_("G", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb,
         info);
    }

L10:
    work[1].r = (doublereal) maxwrk, work[1].i = 0.;
    iwork[1] = liwork;
    rwork[1] = (doublereal) lrwork;
    return 0;

/*     End of ZGELSD */

} /* zgelsd_ */

/* Subroutine */ int zgeqr2_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublecomplex *tau, doublecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, k;
    static doublecomplex alpha;
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    ZGEQR2 computes a QR factorization of a complex m by n matrix A:
    A = Q * R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.
    ! Test the input arguments
    ! 检查输入参数

    IF (N.LT.0) THEN
        ! If N is negative, set INFO to -4 and return
        ! 如果 N 是负数，则将 INFO 设为 -4 并返回
        INFO = -4
        RETURN
    ELSE IF (M.LT.N) THEN
        ! If M is less than N, set INFO to -1 and return
        ! 如果 M 小于 N，则将 INFO 设为 -1 并返回
        INFO = -1
        RETURN
    ELSE IF (LDA.LT.MAX(1,M)) THEN
        ! If LDA is less than max(1,M), set INFO to -3 and return
        ! 如果 LDA 小于 max(1,M)，则将 INFO 设为 -3 并返回
        INFO = -3
        RETURN
    ELSE IF (N.EQ.0) THEN
        ! If N is zero, no operations are required
        ! 如果 N 等于零，则无需进行操作
        RETURN
    END IF

    ! Initialize INFO to 0 (successful exit)
    ! 将 INFO 初始化为 0（成功退出）

    INFO = 0
/* Parameter adjustments */
/* 调整参数 */
a_dim1 = *lda;
/* 设置 a_dim1 为 lda */
a_offset = 1 + a_dim1;
/* 计算偏移量 a_offset */
a -= a_offset;
/* 对 a 进行偏移 */
--tau;
/* 对 tau 进行递减操作 */
--work;
/* 对 work 进行递减操作 */

/* Function Body */
/* 函数主体开始 */
*info = 0;
/* 将 info 初始化为 0 */
if (*m < 0) {
/* 如果 m 小于 0 */
*info = -1;
/* 将 info 设置为 -1 */
} else if (*n < 0) {
/* 否则，如果 n 小于 0 */
*info = -2;
/* 将 info 设置为 -2 */
} else if (*lda < max(1,*m)) {
/* 否则，如果 lda 小于 1 和 m 中的较大值 */
*info = -4;
/* 将 info 设置为 -4 */
}
if (*info != 0) {
/* 如果 info 不等于 0 */
i__1 = -(*info);
/* 计算 -info */
xerbla_("ZGEQR2", &i__1);
/* 调用 xerbla 函数 */
return 0;
/* 返回 0 */
}

k = min(*m,*n);

i__1 = k;
for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i+1:m,i) */
/*        生成元反射器 H(i)，使得 A(i+1:m,i) 被消除 */

i__2 = *m - i__ + 1;
/* 计算 i__2 */
/* Computing MIN */
i__3 = i__ + 1;
/* 计算 i__3 */
zlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ * a_dim1]
    , &c__1, &tau[i__]);
/* 调用 zlarfg 函数 */

if (i__ < *n) {

/*           Apply H(i)' to A(i:m,i+1:n) from the left */
/*           将 H(i)' 应用到 A(i:m,i+1:n) 的左边 */

i__2 = i__ + i__ * a_dim1;
/* 计算 i__2 */
alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 将 a[i__2] 的实部和虚部分别赋给 alpha.r 和 alpha.i */
i__2 = i__ + i__ * a_dim1;
/* 计算 i__2 */
a[i__2].r = 1., a[i__2].i = 0.;
/* 将 a[i__2] 设置为 (1, 0) */
i__2 = *m - i__ + 1;
/* 计算 i__2 */
i__3 = *n - i__;
/* 计算 i__3 */
d_cnjg(&z__1, &tau[i__]);
/* 调用 d_cnjg 函数 */
zlarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &z__1,
     &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
/* 调用 zlarf 函数 */
i__2 = i__ + i__ * a_dim1;
/* 计算 i__2 */
a[i__2].r = alpha.r, a[i__2].i = alpha.i;
/* 将 alpha.r 和 alpha.i 分别赋给 a[i__2] 的实部和虚部 */
}

/* L10: */
}
return 0;

/*     End of ZGEQR2 */

} /* zgeqr2_ */

/* Subroutine */ int zgeqrf_(integer *m, integer *n, doublecomplex *a,
    integer *lda, doublecomplex *tau, doublecomplex *work, integer *lwork,
     integer *info)
{
/* 子程序 zgeqrf_ 开始 */
/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

/* Local variables */
/* 本地变量 */
static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
/* 静态整型变量声明 */
extern /* Subroutine */ int zgeqr2_(integer *, integer *, doublecomplex *,
     integer *, doublecomplex *, doublecomplex *, integer *);
/* 外部子程序 zgeqr2_ 声明 */
extern /* Subroutine */ int xerbla_(char *, integer *);
/* 外部子程序 xerbla_ 声明 */
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
/* 外部整型函数 ilaenv_ 声明 */
extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
    integer *, integer *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *);
/* 外部子程序 zlarfb_ 声明 */
static integer ldwork;
/* 静态整型变量 ldwork 声明 */
extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *);
/* 外部子程序 zlarft_ 声明 */
static integer lwkopt;
/* 静态整型变量 lwkopt 声明 */
static logical lquery;
/* 静态逻辑型变量 lquery 声明 */
    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.


    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).


    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).


    TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).


    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.


    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.


    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value


    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).

    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    // 对参数进行调整，这些是Fortran风格代码中用于数组索引的调整
    a_dim1 = *lda;
    // 计算数组 a 的偏移量
    a_offset = 1 + a_dim1;
    // 将数组 a 进行偏移
    a -= a_offset;
    // 调整 tau 数组的指针
    --tau;
    // 调整 work 数组的指针
    --work;

    /* Function Body */
    // 初始化 info 参数为 0
    *info = 0;
    // 调用 ilaenv 函数获取矩阵分解过程中的优化参数
    nb = ilaenv_(&c__1, "ZGEQRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    // 计算所需工作空间的最优大小
    lwkopt = *n * nb;
    // 将最优工作空间大小记录到 work 数组的第一个元素中
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    // 如果 lwork 参数为 -1，表示只查询工作空间需求，直接返回
    lquery = *lwork == -1;
    // 检查输入参数的合法性
    if (*m < 0) {
        // 若 m 参数小于 0，设置 info 为 -1
        *info = -1;
    } else if (*n < 0) {
        // 若 n 参数小于 0，设置 info 为 -2
        *info = -2;
    } else if (*lda < max(1,*m)) {
        // 若 lda 参数小于 1 和 m 中的较大者，设置 info 为 -4
        *info = -4;
    } else if (*lwork < max(1,*n) && ! lquery) {
        // 若 lwork 参数小于 1 和 n 中的较大者，并且不是查询模式，设置 info 为 -7
        *info = -7;
    }
    // 如果 info 不为 0，调用 xerbla 函数处理错误并返回
    if (*info != 0) {
        // 将 info 取负值传递给 xerbla 函数
        i__1 = -(*info);
        xerbla_("ZGEQRF", &i__1);
        // 直接返回
        return 0;
    } else if (lquery) {
        // 如果是查询模式，直接返回
        return 0;
    }

/*     Quick return if possible */

    // 计算矩阵的秩 k
    k = min(*m,*n);
    // 如果 k 为 0，直接设置 work 数组的第一个元素为 (1, 0) 并返回
    if (k == 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    // 设置默认的分块大小 nbmin 和 nx
    nbmin = 2;
    nx = 0;
    // 初始化 iws 为 n
    iws = *n;
    // 如果分块大小 nb 大于 1 并且小于 k
    if (nb > 1 && nb < k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    // 计算 ilaenv 函数返回的值，决定何时从分块算法转换为非分块算法
    i__1 = 0, i__2 = ilaenv_(&c__3, "ZGEQRF", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    // 取两者中的较大值赋给 nx
    nx = max(i__1,i__2);
    // 如果 nx 小于 k
    if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

        // 设置 ldwork 为 n
        ldwork = *n;
        // 计算所需工作空间大小
        iws = ldwork * nb;
        // 如果 lwork 小于所需工作空间大小
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        // 减少 nb 的值，并计算最小的 nbmin 值
        nb = *lwork / ldwork;
/* Computing MAX */
        // 计算 ilaenv 函数返回的值，确定 nbmin 的最小值
        i__1 = 2, i__2 = ilaenv_(&c__2, "ZGEQRF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);
        // 取两者中的较大值赋给 nbmin
        nbmin = max(i__1,i__2);
        }
    }
    }

    // 如果 nb 大于等于 nbmin 并且小于 k 且 nx 小于 k
    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

    // 循环分块处理每一个块
    i__1 = k - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        // 计算当前块的大小 ib
        i__3 = k - i__ + 1;
        ib = min(i__3,nb);

/*
             Compute the QR factorization of the current block
             A(i:m,i:i+ib-1)
*/

        // 调用 zgeqr2 函数进行 QR 分解
        i__3 = *m - i__ + 1;
        zgeqr2_(&i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);
        // 如果 i+ib 小于等于 n
        if (i__ + ib <= *n) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        // 计算块反射器的三角因子
        i__3 = *m - i__ + 1;
        zlarft_("Forward", "Columnwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              Apply H' to A(i:m,i+ib:n) from the left */

        // 从左边将 H' 应用到 A(i:m,i+ib:n)
        i__3 = *m - i__ + 1;
        i__4 = *n - i__ - ib + 1;
        zlarfb_("Left", "Conjugate transpose", "Forward", "Columnwise"
            , &i__3, &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &
            work[1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda,
            &work[ib + 1], &ldwork);
        }
/* L10: */
    }
    } else {
    // 如果不满足分块条件，使用非分块算法处理剩余部分
    i__ = 1;
    }

/*     Use unblocked code to factor the last or only block. */

    // 使用非分块算法对最后一个或唯一的块进行处理
    if (i__ <= k) {
    // 计算未处理部分的行数和列数
    i__2 = *m - i__ + 1;
    i__1 = *n - i__ + 1;
    # 调用 LAPACK 函数 zgeqr2_ 执行 QR 分解的第二步操作
    zgeqr2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    }

    # 设置工作数组中第一个元素的实部为 iws，虚部为 0
    work[1].r = (doublereal) iws, work[1].i = 0.;
    # 返回整数值 0，表示函数执行成功
    return 0;
/*     End of ZGEQRF */
/* Subroutine */ int zgesdd_(char *jobz, integer *m, integer *n,
    doublecomplex *a, integer *lda, doublereal *s, doublecomplex *u,
    integer *ldu, doublecomplex *vt, integer *ldvt, doublecomplex *work,
    integer *lwork, doublereal *rwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2, i__3;

    /* Local variables */
    static integer i__, ie, il, ir, iu, blk;
    static doublereal dum[1], eps;
    static integer iru, ivt, iscl;
    static doublereal anrm;
    static integer idum[1], ierr, itau, irvt;
    extern logical lsame_(char *, char *);
    static integer chunk, minmn;
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    static integer wrkbl, itaup, itauq;
    static logical wntqa;
    static integer nwork;
    static logical wntqn, wntqo, wntqs;
    extern /* Subroutine */ int zlacp2_(char *, integer *, integer *,
        doublereal *, integer *, doublecomplex *, integer *);
    static integer mnthr1, mnthr2;
    extern /* Subroutine */ int dbdsdc_(char *, char *, integer *, doublereal
        *, doublereal *, doublereal *, integer *, doublereal *, integer *,
         doublereal *, integer *, doublereal *, integer *, integer *);

    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), xerbla_(char *, integer *),
         zgebrd_(integer *, integer *, doublecomplex *, integer *,
        doublereal *, doublereal *, doublecomplex *, doublecomplex *,
        doublecomplex *, integer *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static doublereal bignum;
    extern doublereal zlange_(char *, integer *, integer *, doublecomplex *,
        integer *, doublereal *);
    extern /* Subroutine */ int zgelqf_(integer *, integer *, doublecomplex *,
         integer *, doublecomplex *, doublecomplex *, integer *, integer *
        ), zlacrm_(integer *, integer *, doublecomplex *, integer *,
        doublereal *, integer *, doublecomplex *, integer *, doublereal *)
        , zlarcm_(integer *, integer *, doublereal *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublereal *), zlascl_(char *, integer *, integer *, doublereal *,
         doublereal *, integer *, integer *, doublecomplex *, integer *,
        integer *), zgeqrf_(integer *, integer *, doublecomplex *,
         integer *, doublecomplex *, doublecomplex *, integer *, integer *
        );
    static integer ldwrkl;

/*     End of ZGEQRF */

} /* zgeqrf_ */


注释：
    # 外部函数声明，声明 zlacpy_, zlaset_, zungbr_, zunmbr_, zunglq_, zungqr_ 函数的原型
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *),
        zlaset_(char *, integer *, integer *, doublecomplex *,
        doublecomplex *, doublecomplex *, integer *);

    # 静态变量声明
    static integer ldwrkr, minwrk, ldwrku, maxwrk;
    static integer ldwkvt;
    static doublereal smlnum;
    static logical wntqas;
    static integer nrwork;

    # 外部函数声明，声明 zungbr_, zunmbr_, zunglq_, zungqr_ 函数的原型
    extern /* Subroutine */ int zungbr_(char *, integer *, integer *, integer
        *, doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);
    extern /* Subroutine */ int zunmbr_(char *, char *, char *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         doublecomplex *, integer *, doublecomplex *, integer *, integer *);
    extern /* Subroutine */ int zunglq_(integer *, integer *, integer *
        , doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);
    extern /* Subroutine */ int zungqr_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);
/*
    -- LAPACK driver routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010
       8-15-00:  Improve consistency of WS calculations (eca)


    Purpose
    =======

    ZGESDD computes the singular value decomposition (SVD) of a complex
    M-by-N matrix A, optionally computing the left and/or right singular
    vectors, by using divide-and-conquer method. The SVD is written

         A = U * SIGMA * conjugate-transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
    V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns VT = V**H, not V.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**H are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**H are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V**H are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**H are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**H are computed.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N >= 0.
*/
    ! A       (input/output) COMPLEX*16 array, dimension (LDA,N)
    !          On entry, the M-by-N matrix A.
    !          On exit,
    !          if JOBZ = 'O',  A is overwritten with the first N columns
    !                          of U (the left singular vectors, stored
    !                          columnwise) if M >= N;
    !                          A is overwritten with the first M rows
    !                          of V**H (the right singular vectors, stored
    !                          rowwise) otherwise.
    !          if JOBZ .ne. 'O', the contents of A are destroyed.

    ! LDA     (input) INTEGER
    !          The leading dimension of the array A.  LDA >= max(1,M).

    ! S       (output) DOUBLE PRECISION array, dimension (min(M,N))
    !          The singular values of A, sorted so that S(i) >= S(i+1).

    ! U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
    !          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
    !          UCOL = min(M,N) if JOBZ = 'S'.
    !          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
    !          unitary matrix U;
    !          if JOBZ = 'S', U contains the first min(M,N) columns of U
    !          (the left singular vectors, stored columnwise);
    !          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.

    ! LDU     (input) INTEGER
    !          The leading dimension of the array U.  LDU >= 1; if
    !          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.

    ! VT      (output) COMPLEX*16 array, dimension (LDVT,N)
    !          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
    !          N-by-N unitary matrix V**H;
    !          if JOBZ = 'S', VT contains the first min(M,N) rows of
    !          V**H (the right singular vectors, stored rowwise);
    !          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.

    ! LDVT    (input) INTEGER
    !          The leading dimension of the array VT.  LDVT >= 1; if
    !          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
    !          if JOBZ = 'S', LDVT >= min(M,N).

    ! WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
    !          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    ! LWORK   (input) INTEGER
    !          The dimension of the array WORK. LWORK >= 1.
    !          if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
    !          if JOBZ = 'O',
    !                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
    !          if JOBZ = 'S' or 'A',
    !                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
    !          For good performance, LWORK should generally be larger.
    !          If LWORK = -1, a workspace query is assumed.  The optimal
    !          size for the WORK array is calculated and stored in WORK(1),
    !          and no other work except argument checking is performed.

    ! RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
    !          If JOBZ = 'N', LRWORK >= 5*min(M,N).
    !          Otherwise,
    !          LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)
    IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
    # 定义整数数组 IWORK 作为工作空间，其长度为 8*min(M,N)
    # M 和 N 是输入参数的维度，取较小值用于确定数组的长度。

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The updating process of DBDSDC did not converge.
    # INFO 是输出参数，用于指示函数的执行状态：
    #   - 0 表示成功退出。
    #   - 负数表示具体哪个参数有非法值。
    #   - 正数表示 DBDSDC 的更新过程未收敛。

    Further Details
    ===============
    # 进一步细节
    # ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA
    # 本部分基于 Ming Gu 和 Huan Ren 在美国加州大学伯克利分校计算机科学系的贡献。

    =====================================================================
    # =====================================================================


       Test the input arguments
    # 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --s;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --work;
    --rwork;
    --iwork;

    /* Function Body */
    *info = 0;
    minmn = min(*m,*n);  // 计算 m 和 n 中的较小值
    mnthr1 = (integer) (minmn * 17. / 9.);  // 计算阈值 mnthr1
    mnthr2 = (integer) (minmn * 5. / 3.);   // 计算阈值 mnthr2
    wntqa = lsame_(jobz, "A");  // 判断 jobz 是否为 "A"
    wntqs = lsame_(jobz, "S");  // 判断 jobz 是否为 "S"
    wntqas = wntqa || wntqs;    // 判断是否为 "A" 或 "S"
    wntqo = lsame_(jobz, "O");  // 判断 jobz 是否为 "O"
    wntqn = lsame_(jobz, "N");  // 判断 jobz 是否为 "N"
    minwrk = 1;                 // 初始化最小工作空间
    maxwrk = 1;                 // 初始化最大工作空间

    if (! (wntqa || wntqs || wntqo || wntqn)) {  // 判断 jobz 的合法性
        *info = -1;              // 设置错误码为 -1
    } else if (*m < 0) {         // 判断 m 是否小于 0
        *info = -2;              // 设置错误码为 -2
    } else if (*n < 0) {         // 判断 n 是否小于 0
        *info = -3;              // 设置错误码为 -3
    } else if (*lda < max(1,*m)) {  // 判断 lda 是否小于 max(1, m)
        *info = -5;              // 设置错误码为 -5
    } else if (*ldu < 1 || wntqas && *ldu < *m || wntqo && *m < *n && *ldu < *m) {
        // 判断 ldu 的合法性
        *info = -8;              // 设置错误码为 -8
    } else if (*ldvt < 1 || wntqa && *ldvt < *n || wntqs && *ldvt < minmn ||
               wntqo && *m >= *n && *ldvt < *n) {
        // 判断 ldvt 的合法性
        *info = -10;             // 设置错误码为 -10
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         CWorkspace refers to complex workspace, and RWorkspace to
         real workspace. NB refers to the optimal block size for the
         immediately following subroutine, as returned by ILAENV.)
*/

    if (*info == 0 && *m > 0 && *n > 0) {
        if (*m >= *n) {

/*
             There is no complex work space needed for bidiagonal SVD
             The real work space needed for bidiagonal SVD is BDSPAC
             for computing singular values and singular vectors; BDSPAN
             for computing singular values only.
             BDSPAC = 5*N*N + 7*N
             BDSPAN = MAX(7*N+4, 3*N+2+SMLSIZ*(SMLSIZ+8))
*/

            if (*m >= mnthr1) {
                if (wntqn) {

/*                 Path 1 (M much larger than N, JOBZ='N') */

                    maxwrk = *n + *n * ilaenv_(&c__1, "ZGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                    /* Computing MAX */
                    i__1 = maxwrk, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
                        c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
                        6, (ftnlen)1);
                    maxwrk = max(i__1,i__2);
                    minwrk = *n * 3;
                } else if (wntqo) {

/*                 Path 2 (M much larger than N, JOBZ='O') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "ZGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                    /* Computing MAX */
                    i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "ZUNGQR",
                        " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
                    wrkbl = max(i__1,i__2);
/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
    c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + (*n << 1) * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "QLN", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

maxwrk = *m * *n + *n * *n + wrkbl;
/* 计算 maxwrk 的值 */

minwrk = (*n << 1) * *n + *n * 3;
/* 计算 minwrk 的值 */

} else if (wntqs) {

/* Path 3 (M much larger than N, JOBZ='S') */
/* 第三种情况（M 远大于 N，JOBZ='S'） */

wrkbl = *n + *n * ilaenv_(&c__1, "ZGEQRF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 设置 wrkbl 为 *n + *n * ilaenv_ 的值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "ZUNGQR",
    " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
/* 设置 i__1 为 wrkbl 和 *n + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
    c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + (*n << 1) * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "QLN", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

maxwrk = *n * *n + wrkbl;
/* 计算 maxwrk 的值 */

minwrk = *n * *n + *n * 3;
/* 计算 minwrk 的值 */

} else if (wntqa) {

/* Path 4 (M much larger than N, JOBZ='A') */
/* 第四种情况（M 远大于 N，JOBZ='A'） */

wrkbl = *n + *n * ilaenv_(&c__1, "ZGEQRF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 设置 wrkbl 为 *n + *n * ilaenv_ 的值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *n + *m * ilaenv_(&c__1, "ZUNGQR",
    " ", m, m, n, &c_n1, (ftnlen)6, (ftnlen)1);
/* 设置 i__1 为 wrkbl 和 *n + *m * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
    c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + (*n << 1) * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "QLN", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 设置 i__1 为 wrkbl 和 (*n << 1) + *n * ilaenv_ 的较大值 */
wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为两者的最大值 */
/* Computing MAX */
计算最大值，用于确定工作空间大小

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "ZUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
wrkbl = max(i__1,i__2);
// 更新工作空间大小的下界

maxwrk = *n * *n + wrkbl;
// 计算所需的最大工作空间大小

minwrk = *n * *n + (*n << 1) + *m;
// 计算所需的最小工作空间大小



/*              Path 5 (M much larger than N, but not as much as MNTHR1) */
// 当 M 远大于 N 但不到 MNTHR1 的情况下，选择这条路径

maxwrk = (*n << 1) + (*m + *n) * ilaenv_(&c__1, "ZGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
// 根据 ZGEBRD 的 ILAENV 值计算最大工作空间大小

minwrk = (*n << 1) + *m;
// 计算最小工作空间大小

if (wntqo) {
/* Computing MAX */
    // 如果需要 Q 则计算额外的最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
/* Computing MAX */
    // 继续计算额外的最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNGBR", "Q", m, n, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
    maxwrk += *m * *n;
    minwrk += *n * *n;
} else if (wntqs) {
/* Computing MAX */
    // 如果需要 QS 则计算最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
/* Computing MAX */
    // 继续计算最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNGBR", "Q", m, n, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
} else if (wntqa) {
/* Computing MAX */
    // 如果需要 QA 则计算最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
/* Computing MAX */
    // 继续计算最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *m * ilaenv_(&c__1,
        "ZUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
        1);
    maxwrk = max(i__1,i__2);
}



/*              Path 6 (M at least N, but not much larger) */
// 当 M 至少等于 N 但不是远大于 N 的情况下，选择这条路径

maxwrk = (*n << 1) + (*m + *n) * ilaenv_(&c__1, "ZGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
// 根据 ZGEBRD 的 ILAENV 值计算最大工作空间大小

minwrk = (*n << 1) + *m;
// 计算最小工作空间大小

if (wntqo) {
/* Computing MAX */
    // 如果需要 Q 则计算额外的最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
        ftnlen)3);
    maxwrk = max(i__1,i__2);
/* Computing MAX */
    // 继续计算额外的最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNMBR", "QLN", m, n, n, &c_n1, (ftnlen)6, (
        ftnlen)3);
    maxwrk = max(i__1,i__2);
    maxwrk += *m * *n;
    minwrk += *n * *n;
} else if (wntqs) {
/* Computing MAX */
    // 如果需要 QS 则计算最大工作空间大小
    i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
        "ZUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
        ftnlen)3);
    maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
                "ZUNMBR", "QLN", m, n, n, &c_n1, (ftnlen)6, (
                ftnlen)3);
            // 计算需要的工作空间大小，考虑复杂矩阵乘法的工作空间
            maxwrk = max(i__1,i__2);
        } else if (wntqa) {
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
                "ZUNGBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
                ftnlen)3);
            // 计算需要的工作空间大小，考虑复杂矩阵乘法的工作空间
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*n << 1) + *m * ilaenv_(&c__1,
                "ZUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
                ftnlen)3);
            // 计算需要的工作空间大小，考虑复杂矩阵乘法的工作空间
            maxwrk = max(i__1,i__2);
        }
        }
    } else {

/*
             There is no complex work space needed for bidiagonal SVD
             The real work space needed for bidiagonal SVD is BDSPAC
             for computing singular values and singular vectors; BDSPAN
             for computing singular values only.
             BDSPAC = 5*M*M + 7*M
             BDSPAN = MAX(7*M+4, 3*M+2+SMLSIZ*(SMLSIZ+8))
*/

        if (*n >= mnthr1) {
        if (wntqn) {

/*                 Path 1t (N much larger than M, JOBZ='N') */

            // 计算需要的工作空间大小，考虑QR分解的工作空间
            maxwrk = *m + *m * ilaenv_(&c__1, "ZGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
                c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
                6, (ftnlen)1);
            // 综合考虑需要的工作空间大小，选择较大值
            maxwrk = max(i__1,i__2);
            // 计算最小需要的工作空间大小
            minwrk = *m * 3;
        } else if (wntqo) {

/*                 Path 2t (N much larger than M, JOBZ='O') */

            // 计算GELQF和GEBRD的工作空间大小
            wrkbl = *m + *m * ilaenv_(&c__1, "ZGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "ZUNGLQ",
                " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            // 综合考虑需要的工作空间大小，选择较大值
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
                c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
                6, (ftnlen)1);
            // 综合考虑需要的工作空间大小，选择较大值
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            // 综合考虑需要的工作空间大小，选择较大值
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            // 综合考虑需要的工作空间大小，选择较大值
            wrkbl = max(i__1,i__2);
            // 计算最大需要的工作空间大小
            maxwrk = *m * *n + *m * *m + wrkbl;
            // 计算最小需要的工作空间大小
            minwrk = (*m << 1) * *m + *m * 3;
        } else if (wntqs) {

/*                 Path 3t (N much larger than M, JOBZ='S') */

            // 计算GELQF的工作空间大小
            wrkbl = *m + *m * ilaenv_(&c__1, "ZGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "ZUNGLQ",
                " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
                c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
                6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            wrkbl = max(i__1,i__2);
            maxwrk = *m * *m + wrkbl;
            minwrk = *m * *m + *m * 3;
        } else if (wntqa) {

/*                 Path 4t (N much larger than M, JOBZ='A') */

            wrkbl = *m + *m * ilaenv_(&c__1, "ZGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m + *n * ilaenv_(&c__1, "ZUNGLQ",
                " ", n, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
                c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
                6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (
                ftnlen)3);
            wrkbl = max(i__1,i__2);
            maxwrk = *m * *m + wrkbl;
            minwrk = *m * *m + (*m << 1) + *n;
        }
        } else if (*n >= mnthr2) {

/*              Path 5t (N much larger than M, but not as much as MNTHR1) */

        maxwrk = (*m << 1) + (*m + *n) * ilaenv_(&c__1, "ZGEBRD",
            " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        minwrk = (*m << 1) + *n;
        if (wntqo) {
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNGBR", "P", m, n, m, &c_n1, (ftnlen)6, (ftnlen)
                1);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
                "ZUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
                1);
            maxwrk = max(i__1,i__2);
            maxwrk += *m * *n;
            minwrk += *m * *m;
        } else if (wntqs) {
/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "P", m, n, m, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

} else if (wntqa) {

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *n * ilaenv_(&c__1,
    "ZUNGBR", "P", n, n, m, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

} else {

/*              Path 6t (N greater than M, but not much larger) */
/*              路径 6t（N 大于 M，但不是大得多）*/

maxwrk = (*m << 1) + (*m + *n) * ilaenv_(&c__1, "ZGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算工作空间大小，用于调用 ZGEBRD 函数 */

minwrk = (*m << 1) + *n;
/* 计算最小所需工作空间大小 */

if (wntqo) {

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNMBR", "PRC", m, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNMBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

maxwrk += *m * *n;
minwrk += *m * *m;
/* 调整 maxwrk 和 minwrk 以反映额外的工作空间需求 */

} else if (wntqs) {

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "PRC", m, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

} else if (wntqa) {

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *n * ilaenv_(&c__1,
    "ZUNGBR", "PRC", n, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

/* Computing MAX */
/* 计算两个值的最大值，用于确定工作空间的大小 */

i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "ZUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 更新 maxwrk 为当前计算的最大工作空间大小 */

}

maxwrk = max(maxwrk,minwrk);
/* 确保 maxwrk 至少为 minwrk */

}

if (*info == 0) {
/* 如果没有错误信息 */

work[1].r = (doublereal) maxwrk, work[1].i = 0.;
/* 设置工作空间数组的第一个元素为 maxwrk */

if (*lwork < minwrk && *lwork != -1) {
/* 如果实际工作空间小于最小所需工作空间且不是查询模式 */

*info = -13;
/* 设置错误代码为 -13 */
}

}

/*     Quick returns */

if (*info != 0) {
/* 如果有错误信息 */

i__1 = -(*info);
/* 计算错误代码的负值 */

xerbla_("ZGESDD", &i__1);
/* 调用 xerbla 函数报告错误 */

return 0;
/* 返回错误代码 */
}

if (*lwork == -1) {
/* 如果在查询工作空间大小 */

return 0;
/* 返回成功状态 */
}

if (*m == 0 || *n == 0) {
/* 如果输入的矩阵维度为 0 */

return 0;
/* 直接返回成功状态 */
}

/*     Get machine constants */
/* 获取机器常数 */
    # 定义精度常量，通常用于表示数值计算的精度要求
    eps = PRECISION;
    # 定义一个较小的数值，用于避免数值计算中的除零错误，其计算方法是安全最小值的平方根除以精度
    smlnum = sqrt(SAFEMINIMUM) / eps;
    # 定义一个较大的数值，是较小数值的倒数，用于数值计算中的放大因子
    bignum = 1. / smlnum;
/*     如果最大元素超出范围 [SMLNUM,BIGNUM]，则对 A 进行缩放 */

anrm = zlange_("M", m, n, &a[a_offset], lda, dum);
iscl = 0;
if (anrm > 0. && anrm < smlnum) {
    iscl = 1;
    zlascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, &
        ierr);
} else if (anrm > bignum) {
    iscl = 1;
    zlascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, &
        ierr);
}

if (*m >= *n) {

/*
      A 的行数大于等于列数。如果 A 的行数远远大于列数，则首先使用 QR
      分解（如果有足够的工作空间）
*/

    if (*m >= mnthr1) {

        if (wntqn) {

/*
            路径 1（M 远大于 N，JOBZ='N'）
            不计算奇异向量
*/

            itau = 1;
            nwork = itau + *n;

/*
            计算 A=Q*R
            (CWorkspace: 需要 2*N，优先 N+N*NB)
            (RWorkspace: 需要 0)
*/

            i__1 = *lwork - nwork + 1;
            zgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
                i__1, &ierr);

/*          将 R 的下方置零 */

            i__1 = *n - 1;
            i__2 = *n - 1;
            zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &a[a_dim1 + 2],
                lda);
            ie = 1;
            itauq = 1;
            itaup = itauq + *n;
            nwork = itaup + *n;

/*
            对 A 中的 R 进行双对角化
            (CWorkspace: 需要 3*N，优先 2*N+2*N*NB)
            (RWorkspace: 需要 N)
*/

            i__1 = *lwork - nwork + 1;
            zgebrd_(n, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[
                itauq], &work[itaup], &work[nwork], &i__1, &ierr);
            nrwork = ie + *n;

/*
            执行双对角 SVD，仅计算奇异值
            (CWorkspace: 0)
            (RWorkspace: 需要 BDSPAN)
*/

            dbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &
                c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

        } else if (wntqo) {

/*
            路径 2（M 远大于 N，JOBZ='O'）
            在 A 上覆盖 N 左奇异向量，并在 VT 中计算 N 右奇异向量
*/

            iu = 1;

/*          WORK(IU) 是 N*N 的矩阵 */

            ldwrku = *n;
            ir = iu + ldwrku * *n;
            if (*lwork >= *m * *n + *n * *n + *n * 3) {

/*              WORK(IR) 是 M*N 的矩阵 */

                ldwrkr = *m;
            } else {
                ldwrkr = (*lwork - *n * *n - *n * 3) / *n;
            }
            itau = ir + ldwrkr * *n;
            nwork = itau + *n;

/*
            计算 A=Q*R
            (CWorkspace: 需要 N*N+2*N，优先 M*N+N+N*NB)
            (RWorkspace: 0)
*/

            i__1 = *lwork - nwork + 1;
            zgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
                i__1, &ierr);
/*              Copy R to WORK( IR ), zeroing out below it */
将矩阵 R 复制到 WORK(IR)，并将其下方清零*/

        zlacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
        /* 调用 LAPACK 函数 zlacpy 将矩阵 a 的上三角部分复制到 work 的 IR 行，
           'U' 表示复制上三角部分，n 表示矩阵的大小，a 是输入矩阵，work 是输出矩阵，
           lda 和 ldwrkr 是矩阵 a 和 work 的 leading dimension。*/

        i__1 = *n - 1;
        i__2 = *n - 1;
        zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &work[ir + 1], &
            ldwrkr);
        /* 调用 LAPACK 函数 zlaset 在 work 的 IR+1 行以下的矩阵区域填充为 c_b56，
           'L' 表示填充下三角部分，i__1 和 i__2 是填充区域的行列数，c_b56 是填充值，
           ldwrkr 是 work 的 leading dimension。*/

/*
                Generate Q in A
                (CWorkspace: need 2*N, prefer N+N*NB)
                (RWorkspace: 0)
*/
        在矩阵 A 中生成 Q
        (CWorkspace: 需要 2*N，推荐 N+N*NB)
        (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        zungqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__1, &ierr);
        /* 调用 LAPACK 函数 zungqr 生成矩阵 Q，m 和 n 是矩阵 A 的行列数，
           a 是输入矩阵，work[itau] 和 work[nwork] 是工作空间数组，
           i__1 是工作空间的大小，lda 是 a 的 leading dimension，ierr 是输出的错误码。*/

        ie = 1;
        itauq = itau;
        itaup = itauq + *n;
        nwork = itaup + *n;
        /* 初始化变量 ie, itauq, itaup 和 nwork，用于后续的计算和存储。*/

/*
                Bidiagonalize R in WORK(IR)
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+2*N*NB)
                (RWorkspace: need N)
*/
        在 WORK(IR) 中将矩阵 R 进行双对角化
        (CWorkspace: 需要 N*N+3*N，推荐 M*N+2*N+2*N*NB)
        (RWorkspace: 需要 N)
*/

        i__1 = *lwork - nwork + 1;
        zgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);
        /* 调用 LAPACK 函数 zgebrd 对矩阵 R 进行双对角化，
           n 是矩阵的大小，work[ir] 是输入矩阵，s 和 rwork 是工作空间数组，
           work[itauq] 和 work[itaup] 是用于计算的工作空间，i__1 是工作空间大小，
           ldwrkr 是 work 的 leading dimension，ierr 是输出的错误码。*/

/*
                Perform bidiagonal SVD, computing left singular vectors
                of R in WORK(IRU) and computing right singular vectors
                of R in WORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
        执行双对角奇异值分解，计算 R 的左奇异向量存储在 WORK(IRU) 中，
        右奇异向量存储在 WORK(IRVT) 中
        (CWorkspace: 需要 0)
        (RWorkspace: 需要 BDSPAC)
*/

        iru = ie + *n;
        irvt = iru + *n * *n;
        nrwork = irvt + *n * *n;
        /* 设置工作空间数组的索引值 iru, irvt 和 nrwork，用于存储中间计算结果。*/

        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);
        /* 调用 LAPACK 函数 dbdsdc 执行奇异值分解，
           n 是矩阵的大小，s 是双对角矩阵的对角元素，rwork 和 iwork 是工作空间数组，
           info 是输出的状态码。*/

/*
                Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                Overwrite WORK(IU) by the left singular vectors of R
                (CWorkspace: need 2*N*N+3*N, prefer M*N+N*N+2*N+N*NB)
                (RWorkspace: 0)
*/
        将实数矩阵 RWORK(IRU) 复制到复数矩阵 WORK(IU)
        用 R 的左奇异向量覆盖 WORK(IU)
        (CWorkspace: 需要 2*N*N+3*N，推荐 M*N+N*N+2*N+N*NB)
        (RWorkspace: 0)
*/

        zlacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
        /* 调用 LAPACK 函数 zlacp2 将实数矩阵复制到复数矩阵，
           'F' 表示复制整个矩阵，n 是矩阵的大小，rwork[iru] 是输入矩阵，
           work[iu] 是输出矩阵，ldwrku 是 work 的 leading dimension。*/

        i__1 = *lwork - nwork + 1;
        zunmbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
            itauq], &work[iu], &ldwrku, &work[nwork], &i__1, &
            ierr);
        /* 调用 LAPACK 函数 zunmbr 通过 Q 矩阵对 WORK(IU) 进行变换，
           'Q' 表示使用 Q 矩阵进行变换，'L' 表示左乘 Q，n 是矩阵的大小，
           work[ir] 是输入的双对角矩阵，work[itauq] 是工作空间数组，
           work[iu] 是输入和输出的矩阵，ldwrku 是 work[iu] 的 leading dimension，
           i__1 是工作空间大小，ierr 是输出的错误码。*/

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by the right singular vectors of R
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                (RWorkspace: 0)
*/
        将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
        用 R 的右奇异向量覆盖 VT
        (CWorkspace: 需要 N*N+3*N，推荐 M*N+2*N+N*NB)
        (RWorkspace: 0)
*/

        zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        /* 调用 LAPACK 函数 zlacp2 将实数矩阵复制到复数矩阵，
           'F' 表示复制整个矩阵，n 是矩阵的大小，rwork[irvt] 是输入矩阵，
           vt 是输出矩阵，ldvt 是 vt 的 leading dimension。*/

        i__1 = *lwork - nwork + 1;
        zunmbr_("P", "R", "C", n
        # 计算 MIN
        i__3 = *m - i__ + 1
        chunk = min(i__3,ldwrkr)
        zgemm_("N", "N", &chunk, n, n, &c_b57, &a[i__ + a_dim1],
            lda, &work[iu], &ldwrku, &c_b56, &work[ir], &
            ldwrkr)
        zlacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ +
            a_dim1], lda)
        # L10

        elif (wntqs):

        # Path 3 (M much larger than N, JOBZ='S')
        # N left singular vectors to be computed in U and
        # N right singular vectors to be computed in VT

        ir = 1

        # WORK(IR) is N by N
        ldwrkr = *n
        itau = ir + ldwrkr * *n
        nwork = itau + *n

        # Compute A=Q*R
        # (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
        # (RWorkspace: 0)
        i__2 = *lwork - nwork + 1
        zgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr)

        # Copy R to WORK(IR), zeroing out below it
        zlacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr)
        i__2 = *n - 1
        i__1 = *n - 1
        zlaset_("L", &i__2, &i__1, &c_b56, &c_b56, &work[ir + 1], &
            ldwrkr)

        # Generate Q in A
        # (CWorkspace: need 2*N, prefer N+N*NB)
        # (RWorkspace: 0)
        i__2 = *lwork - nwork + 1
        zungqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__2, &ierr)
        ie = 1
        itauq = itau
        itaup = itauq + *n
        nwork = itaup + *n

        # Bidiagonalize R in WORK(IR)
        # (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
        # (RWorkspace: need N)
        i__2 = *lwork - nwork + 1
        zgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr)

        # Perform bidiagonal SVD, computing left singular vectors
        # of bidiagonal matrix in RWORK(IRU) and computing right
        # singular vectors of bidiagonal matrix in RWORK(IRVT)
        # (CWorkspace: need 0)
        # (RWorkspace: need BDSPAC)
        iru = ie + *n
        irvt = iru + *n * *n
        nrwork = irvt + *n * *n
        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info)

        # Copy real matrix RWORK(IRU) to complex matrix U
        # Overwrite U by left singular vectors of R
        # (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
        # (RWorkspace: 0)
        zlacp2_("F", n, n, &rwork[iru], n, &u[u_offset], ldu)
        i__2 = *lwork - nwork + 1
        zunmbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr)
/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                用 R 的右奇异向量覆盖 VT
                (CWorkspace: 需要 N*N+3*N, 最好 N*N+2*N+N*NB)
                (RWorkspace: 0)
*/
zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
zunmbr_("P", "R", "C", n, n, n, &work[ir], &ldwrkr, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

/*
                将 A 中的 Q 乘以 R 的左奇异向量，结果存储在 U 中
                (CWorkspace: 需要 N*N)
                (RWorkspace: 0)
*/
zlacpy_("F", n, n, &u[u_offset], ldu, &work[ir], &ldwrkr);
zgemm_("N", "N", m, n, n, &c_b57, &a[a_offset], lda, &work[ir]
    , &ldwrkr, &c_b56, &u[u_offset], ldu);

} else if (wntqa) {

/*
                路径 4 (M 远大于 N, JOBZ='A')
                在 U 中计算 M 个左奇异向量，并在 VT 中计算 N 个右奇异向量
*/
iu = 1;

/*              WORK(IU) 是一个 N by N 的矩阵 */
ldwrku = *n;
itau = iu + ldwrku * *n;
nwork = itau + *n;

/*
                计算 A=Q*R，并将结果复制到 U 中
                (CWorkspace: 需要 2*N, 最好 N+N*NB)
                (RWorkspace: 0)
*/
i__2 = *lwork - nwork + 1;
zgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__2, &ierr);
zlacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);

/*
                在 U 中生成 Q
                (CWorkspace: 需要 N+M, 最好 N+M*NB)
                (RWorkspace: 0)
*/
i__2 = *lwork - nwork + 1;
zungqr_(m, m, n, &u[u_offset], ldu, &work[itau], &work[nwork],
     &i__2, &ierr);

/*              在 A 中生成 R，并将其下方归零 */
i__2 = *n - 1;
i__1 = *n - 1;
zlaset_("L", &i__2, &i__1, &c_b56, &c_b56, &a[a_dim1 + 2],
    lda);
ie = 1;
itauq = itau;
itaup = itauq + *n;
nwork = itaup + *n;

/*
                对 A 中的 R 进行双对角化
                (CWorkspace: 需要 3*N, 最好 2*N+2*N*NB)
                (RWorkspace: 需要 N)
*/
i__2 = *lwork - nwork + 1;
zgebrd_(n, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__2, &ierr);
iru = ie + *n;
irvt = iru + *n * *n;
nrwork = irvt + *n * *n;

/*
                执行双对角 SVD，在 RWORK(IRU) 中计算双对角矩阵的左奇异向量，
                在 RWORK(IRVT) 中计算双对角矩阵的右奇异向量
                (CWorkspace: 不需要)
                (RWorkspace: 需要 BDSPAC)
*/
dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
    rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
    info);
/*
    将实数矩阵 RWORK(IRU) 复制到复数矩阵 WORK(IU)
    使用 R 的左奇异向量覆盖 WORK(IU)
    (CWorkspace: 需要 N*N+3*N, 更倾向于 N*N+2*N+N*NB)
    (RWorkspace: 0)
*/
zlacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
i__2 = *lwork - nwork + 1;
zunmbr_("Q", "L", "N", n, n, n, &a[a_offset], lda, &work[itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &ierr);

/*
    将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
    使用 R 的右奇异向量覆盖 VT
    (CWorkspace: 需要 3*N, 更倾向于 2*N+N*NB)
    (RWorkspace: 0)
*/
zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
zunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);

/*
    将 U 中的 Q 乘以 R 的左奇异向量，结果存储在 A 中
    (CWorkspace: 需要 N*N)
    (RWorkspace: 0)
*/
zgemm_("N", "N", m, n, n, &c_b57, &u[u_offset], ldu, &work[iu], &ldwrku, &c_b56, &a[a_offset], lda);

/*
    将 A 中的左奇异向量复制到 U 中
*/
zlacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);

}

} else if (*m >= mnthr2) {

/*
    MNTHR2 <= M < MNTHR1

    路径 5 (M 比 N 大很多，但不如 MNTHR1 大)
    将 A 缩减到奇异对角形式而不使用 QR 分解，使用 ZUNGBR 和矩阵乘法计算奇异向量
*/

ie = 1;
nrwork = ie + *n;
itauq = 1;
itaup = itauq + *n;
nwork = itaup + *n;

/*
    将 A 缩减为奇异双对角形式
    (CWorkspace: 需要 2*N+M, 更倾向于 2*N+(M+N)*NB)
    (RWorkspace: 需要 N)
*/
i__2 = *lwork - nwork + 1;
zgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);

if (wntqn) {

/*
    仅计算奇异值
    (Cworkspace: 0)
    (Rworkspace: 需要 BDSPAN)
*/
dbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

} else if (wntqo) {
iu = nwork;
iru = nrwork;
irvt = iru + *n * *n;
nrwork = irvt + *n * *n;

/*
    将 A 复制到 VT，生成 P**H
    (Cworkspace: 需要 2*N, 更倾向于 N+N*NB)
    (Rworkspace: 0)
*/
zlacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
zungbr_("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &work[nwork], &i__2, &ierr);

/*
    在 A 中生成 Q
    (Cworkspace: 需要 2*N, 更倾向于 N+N*NB)
    (Rworkspace: 0)
*/
        i__2 = *lwork - nwork + 1;
        zungbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &work[
            nwork], &i__2, &ierr);

// 使用 ZUNGQR 函数生成 Q 矩阵，用于后续的奇异值分解，将其应用到 A 的列上，生成单位正交矩阵 Q


        if (*lwork >= *m * *n + *n * 3) {

// 检查工作空间是否足够大，以便存储临时数据和结果


            ldwrku = *m;
        } else {

// 如果工作空间不够大，则根据条件设置 LDWRKU，它决定了工作空间中存储矩阵的行数


            ldwrku = (*lwork - *n * 3) / *n;
        }
        nwork = iu + ldwrku * *n;

// 计算用于存储中间结果的工作空间的大小，其中 LDWRKU 是存储矩阵的列数


        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

// 执行双对角奇异值分解，计算双对角矩阵的左奇异向量存储在 RWORK(IRU) 中，右奇异向量存储在 RWORK(IRVT) 中


        zlarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &work[iu]
            , &ldwrku, &rwork[nrwork]);
        zlacpy_("F", n, n, &work[iu], &ldwrku, &vt[vt_offset], ldvt);

// 将实矩阵 RWORK(IRVT) 与 P 的共轭转置相乘，结果存储在 WORK(IU) 中，然后拷贝到 VT 中


        nrwork = irvt;
        i__2 = *m;
        i__1 = ldwrku;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
            i__1) {
/* Computing MIN */
            i__3 = *m - i__ + 1;
            chunk = min(i__3,ldwrku);
            zlacrm_(&chunk, n, &a[i__ + a_dim1], lda, &rwork[iru], n,
                &work[iu], &ldwrku, &rwork[nrwork]);
            zlacpy_("F", &chunk, n, &work[iu], &ldwrku, &a[i__ +
                a_dim1], lda);
/* L20: */
        }

// 将 Q 矩阵乘以实矩阵 RWORK(IRU)，结果存储在 WORK(IU) 中，然后拷贝回 A 的对应部分


        } else if (wntqs) {

// 如果需要计算 Q 和 P，执行以下操作


        zlacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
        i__1 = *lwork - nwork + 1;
        zungbr_("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &
            work[nwork], &i__1, &ierr);

// 拷贝 A 到 VT，然后生成 P 的共轭转置，存储在 VT 中


        zlacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        i__1 = *lwork - nwork + 1;
        zungbr_("Q", m, n, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);

// 拷贝 A 到 U，然后生成 Q 矩阵，存储在 U 中


        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

// 执行双对角奇异值分解，计算双对角矩阵的左奇异向量存储在 RWORK(IRU) 中，右奇异向量存储在 RWORK(IRVT) 中
        iru = nrwork;
        irvt = iru + *n * *n;
        nrwork = irvt + *n * *n;
        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);


        // 执行双对角SVD，计算双对角矩阵的左奇异向量存储在RWORK(IRU)中，
        // 计算右奇异向量存储在RWORK(IRVT)中
        // (CWorkspace: 不需要)
        // (RWorkspace: 需要 BDSPAC)



                zlarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);
        zlacpy_("F", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);


                // 将实矩阵RWORK(IRVT)乘以P**H，将结果存储在A中，复制到VT中
                // (CWorkspace: 需要 0)
                // (RWorkspace: 需要 3*N*N)



        zlacrm_(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset],
             lda, &rwork[nrwork]);
        zlacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        } else {


        // 将Q乘以实矩阵RWORK(IRU)，将结果存储在A中，复制到U中
        // (CWorkspace: 需要 0)
        // (RWorkspace: 需要 N*N+2*M*N)



        zlacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
        i__1 = *lwork - nwork + 1;
        zungbr_("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &
            work[nwork], &i__1, &ierr);


        // 将A复制到VT中，生成P**H
        // (CWorkspace: 需要 2*N，最好 N+N*NB)
        // (RWorkspace: 0)



        zlacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        i__1 = *lwork - nwork + 1;
        zungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);


        // 将A复制到U中，生成Q
        // (CWorkspace: 需要 2*N，最好 N+N*NB)
        // (RWorkspace: 0)



        iru = nrwork;
        irvt = iru + *n * *n;
        nrwork = irvt + *n * *n;
        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);


        // 执行双对角SVD，计算双对角矩阵的左奇异向量存储在RWORK(IRU)中，
        // 计算右奇异向量存储在RWORK(IRVT)中
        // (CWorkspace: 不需要)
        // (RWorkspace: 需要 BDSPAC)



        zlarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);
        zlacpy_("F", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);


        // 将实矩阵RWORK(IRVT)乘以P**H，将结果存储在A中，复制到VT中
        // (CWorkspace: 需要 0)
        // (RWorkspace: 需要 3*N*N)



        zlacrm_(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset],
             lda, &rwork[nrwork]);
        zlacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        }


        // 将Q乘以实矩阵RWORK(IRU)，将结果存储在A中，复制到U中
        // (CWorkspace: 0)
        // (RWorkspace: 需要 3*N*N)
        nrwork = irvt;
        // 将 irvt 的值赋给 nrwork，用于后续计算
        zlacrm_(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset],
             lda, &rwork[nrwork]);
        // 调用 zlacrm 函数，将 u 和 a 进行乘法运算并存储在 rwork 数组中
        zlacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        // 调用 zlacpy 函数，复制 a 到 u，其中 F 表示完整复制

    } else {

/*
             M .LT. MNTHR2

             Path 6 (M at least N, but not much larger)
             Reduce to bidiagonal form without QR decomposition
             Use ZUNMBR to compute singular vectors
*/

        ie = 1;
        // 设置 ie 的初始值为 1
        nrwork = ie + *n;
        // 计算 nrwork 的值为 ie + n
        itauq = 1;
        // 设置 itauq 的初始值为 1
        itaup = itauq + *n;
        // 计算 itaup 的值为 itauq + n
        nwork = itaup + *n;
        // 计算 nwork 的值为 itaup + n

/*
             Bidiagonalize A
             (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
             (RWorkspace: need N)
*/

        i__1 = *lwork - nwork + 1;
        // 计算 i__1 的值为 *lwork - nwork + 1
        zgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, &ierr);
        // 调用 zgebrd 函数，对矩阵 a 进行双对角化处理，并返回结果

        if (wntqn) {

/*
                Compute singular values only
                (Cworkspace: 0)
                (Rworkspace: need BDSPAN)
*/

        dbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
        // 调用 dbdsdc 函数，计算奇异值并存储在 s 数组中

        } else if (wntqo) {

        iu = nwork;
        // 设置 iu 的值为 nwork
        iru = nrwork;
        // 设置 iru 的值为 nrwork
        irvt = iru + *n * *n;
        // 计算 irvt 的值为 iru + n*n
        nrwork = irvt + *n * *n;
        // 更新 nrwork 的值为 irvt + n*n

        if (*lwork >= *m * *n + *n * 3) {

/*                 WORK( IU ) is M by N */

            ldwrku = *m;
            // 设置 ldwrku 的值为 m
        } else {

/*                 WORK( IU ) is LDWRKU by N */

            ldwrku = (*lwork - *n * 3) / *n;
            // 计算 ldwrku 的值为 (*lwork - n*3) / n
        }
        nwork = iu + ldwrku * *n;

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by right singular vectors of A
                (Cworkspace: need 2*N, prefer N+N*NB)
                (Rworkspace: need 0)
*/

        zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 调用 zlacp2 函数，复制 rwork[irvt] 到 vt 矩阵

        i__1 = *lwork - nwork + 1;
        // 计算 i__1 的值为 *lwork - nwork + 1
        zunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);

        if (*lwork >= *m * *n + *n * 3) {

/*
                Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                Overwrite WORK(IU) by left singular vectors of A, copying
                to A
                (Cworkspace: need M*N+2*N, prefer M*N+N+N*NB)
                (Rworkspace: need 0)
*/
/*

            zlaset_("F", m, n, &c_b56, &c_b56, &work[iu], &ldwrku);
            // 初始化矩阵 WORK(IU) 为常数 c_b56，F 表示填充整个矩阵
            zlacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
            // 复制矩阵 RWORK(IRU) 到 WORK(IU)，F 表示复制整个矩阵
            i__1 = *lwork - nwork + 1;
            // 计算剩余可用工作空间大小
            zunmbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
                itauq], &work[iu], &ldwrku, &work[nwork], &i__1, &
                ierr);
            // 从矩阵 A 中构造单位正交矩阵 Q，并复制到 WORK(IU)，然后存储在 A 中
            zlacpy_("F", m, n, &work[iu], &ldwrku, &a[a_offset], lda);
            // 复制矩阵 WORK(IU) 到 A，F 表示复制整个矩阵
        } else {

/*
                   Generate Q in A
                   (Cworkspace: need 2*N, prefer N+N*NB)
                   (Rworkspace: need 0)
*/

            i__1 = *lwork - nwork + 1;
            // 计算剩余可用工作空间大小
            zungbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &
                work[nwork], &i__1, &ierr);
            // 从矩阵 A 中构造单位正交矩阵 Q，存储在 A 中

/*
                   Multiply Q in A by real matrix RWORK(IRU), storing the
                   result in WORK(IU), copying to A
                   (CWorkspace: need N*N, prefer M*N)
                   (Rworkspace: need 3*N*N, prefer N*N+2*M*N)
*/

            nrwork = irvt;
            // 将 IRVT 赋给 nrwork
            i__1 = *m;
            // 循环操作每一行
            i__2 = ldwrku;
            // 设置每次迭代步长
            for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
                 i__2) {
/* Computing MIN */
            i__3 = *m - i__ + 1;
            chunk = min(i__3,ldwrku);
            // 计算需要复制的列数
            zlacrm_(&chunk, n, &a[i__ + a_dim1], lda, &rwork[iru],
                 n, &work[iu], &ldwrku, &rwork[nrwork]);
            // 以数据优先的方式从矩阵 A 中复制到 WORK(IU) 中
            zlacpy_("F", &chunk, n, &work[iu], &ldwrku, &a[i__ +
                a_dim1], lda);
/* L30: */
            }
        }

        } else if (wntqs) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = nrwork;
        // 设置 IRU 为 nrwork
        irvt = iru + *n * *n;
        // 设置 IRVT 为 IRU 加 N*N
        nrwork = irvt + *n * *n;
        // 设置 nrwork 为 IRVT 加 N*N
        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of A
                (CWorkspace: need 3*N, prefer 2*N+N*NB)
                (RWorkspace: 0)
*/

        zlaset_("F", m, n, &c_b56, &c_b56, &u[u_offset], ldu);
        // 初始化矩阵 U 为常数 c_b56
        zlacp2_("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
        // 复制矩阵 RWORK(IRU) 到 U，F 表示复制整个矩阵
        i__2 = *lwork - nwork + 1;
        // 计算剩余可用工作空间大小
        zunmbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by right singular vectors of A
                (CWorkspace: need 3*N, prefer 2*N+N*NB)
                (RWorkspace: 0)
*/
        zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
        i__2 = *lwork - nwork + 1;
        // 计算工作空间剩余大小
        zunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);
        // 计算右奇异向量并覆盖 VT
        } else {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = nrwork;
        // 设置实数矩阵 RWORK(IRU) 的位置
        irvt = iru + *n * *n;
        // 设置实数矩阵 RWORK(IRVT) 的位置
        nrwork = irvt + *n * *n;
        // 更新工作空间大小
        dbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);
        // 执行奇异值分解并计算奇异向量

/*              Set the right corner of U to identity matrix */

        zlaset_("F", m, m, &c_b56, &c_b56, &u[u_offset], ldu);
        // 将 U 矩阵的右下角设置为单位矩阵
        if (*m > *n) {
            i__2 = *m - *n;
            i__1 = *m - *n;
            zlaset_("F", &i__2, &i__1, &c_b56, &c_b57, &u[*n + 1 + (*
                n + 1) * u_dim1], ldu);
            // 根据 U 的维度设置其他部分为零矩阵
        }

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of A
                (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
        // 将实数矩阵 RWORK(IRU) 复制到复数矩阵 U
        i__2 = *lwork - nwork + 1;
        // 计算工作空间剩余大小
        zunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
        // 计算左奇异向量并覆盖 U

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by right singular vectors of A
                (CWorkspace: need 3*N, prefer 2*N+N*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
        i__2 = *lwork - nwork + 1;
        // 计算工作空间剩余大小
        zunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);
        // 计算右奇异向量并覆盖 VT
        }

    }

    } else {

/*
          A has more columns than rows. If A has sufficiently more
          columns than rows, first reduce using the LQ decomposition (if
          sufficient workspace available)
*/

    if (*n >= mnthr1) {

        if (wntqn) {

/*
                Path 1t (N much larger than M, JOBZ='N')
                No singular vectors to be computed
*/

        itau = 1;
        // 设置工作数组的起始位置
        nwork = itau + *m;
        // 设置工作空间的大小

/*
                Compute A=L*Q
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        i__2 = *lwork - nwork + 1;
        // 计算工作空间剩余大小
        zgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);
        // 计算 LQ 分解并存储结果在 A 中
/*              Zero out above L */

        // 计算 i__2 和 i__1 分别为 m-1，即要处理的子矩阵的维度
        i__2 = *m - 1;
        i__1 = *m - 1;
        // 调用 zlaset 函数，将矩阵 A 的上三角部分置零
        zlaset_("U", &i__2, &i__1, &c_b56, &c_b56, &a[(a_dim1 << 1) +
            1], lda);
        // 初始化 ie、itauq、itaup、nwork
        ie = 1;
        itauq = 1;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
                Bidiagonalize L in A
                (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                (RWorkspace: need M)
*/

        // 调用 zgebrd 函数，对矩阵 A 中的 L 进行双对角化
        // 结果存储在 s、rwork 和 work 数组中
        i__2 = *lwork - nwork + 1;
        zgebrd_(m, m, &a[a_offset], lda, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
        // 更新 nrwork 的值
        nrwork = ie + *m;

/*
                Perform bidiagonal SVD, compute singular values only
                (CWorkspace: 0)
                (RWorkspace: need BDSPAN)
*/

        // 调用 dbdsdc 函数，执行双对角 SVD 分解，仅计算奇异值
        dbdsdc_("U", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

        } else if (wntqo) {

/*
                Path 2t (N much larger than M, JOBZ='O')
                M right singular vectors to be overwritten on A and
                M left singular vectors to be computed in U
*/

        // 初始化 ivt 和 ldwkvt
        ivt = 1;
        ldwkvt = *m;

/*              WORK(IVT) is M by M */

        // 计算 il 和 ldwrkl
        il = ivt + ldwkvt * *m;
        // 根据工作空间大小选择 ldwrkl 和 chunk 的值
        if (*lwork >= *m * *n + *m * *m + *m * 3) {

/*                 WORK(IL) M by N */

            ldwrkl = *m;
            chunk = *n;
        } else {

/*                 WORK(IL) is M by CHUNK */

            ldwrkl = *m;
            chunk = (*lwork - *m * *m - *m * 3) / *m;
        }
        // 计算 itau 和 nwork
        itau = il + ldwrkl * chunk;
        nwork = itau + *m;

/*
                Compute A=L*Q
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        // 调用 zgelqf 函数，计算 L*Q，结果存储在矩阵 A 中
        i__2 = *lwork - nwork + 1;
        zgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);

/*              Copy L to WORK(IL), zeroing about above it */

        // 调用 zlacpy 函数，将矩阵 L 复制到 WORK(IL) 中，并将其上方的元素置零
        zlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
        // 将 WORK(IL) 中的上三角部分置零
        i__2 = *m - 1;
        i__1 = *m - 1;
        zlaset_("U", &i__2, &i__1, &c_b56, &c_b56, &work[il + ldwrkl],
             &ldwrkl);

/*
                Generate Q in A
                (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                (RWorkspace: 0)
*/

        // 调用 zunglq 函数，生成矩阵 Q，并存储在矩阵 A 中
        i__2 = *lwork - nwork + 1;
        zunglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__2, &ierr);
        // 更新 itauq、itaup 和 nwork 的值
        ie = 1;
        itauq = itau;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
                Bidiagonalize L in WORK(IL)
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/

        // 调用 zgebrd 函数，对 WORK(IL) 中的 L 进行双对角化
        i__2 = *lwork - nwork + 1;
        zgebrd_(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *m;
        // 设置 IRU 作为 ie + *m 的值，ie 和 *m 是给定的输入参数
        irvt = iru + *m * *m;
        // 设置 IRVT 作为 iru + *m * *m 的值，其中 iru 已经被计算出来
        nrwork = irvt + *m * *m;
        // 设置 nrwork 作为 irvt + *m * *m 的值，用于存储后续计算的工作空间大小
        dbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);
        // 调用 LAPACK 子程序 dbdsdc，进行双对角奇异值分解，计算左奇异向量存储在 rwork[iru]，右奇异向量存储在 rwork[irvt]

/*
                Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                Overwrite WORK(IU) by the left singular vectors of L
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
        // 将实数矩阵 rwork[iru] 复制到复数矩阵 u[u_offset]，用于存储左奇异向量
        i__2 = *lwork - nwork + 1;
        // 计算剩余工作空间大小
        zunmbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
        // 调用 LAPACK 子程序 zunmbr，计算左奇异向量的乘积，并将结果存储在 u[u_offset]

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by the right singular vectors of L
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
        // 将实数矩阵 rwork[irvt] 复制到复数矩阵 work[ivt]，用于存储右奇异向量
        i__2 = *lwork - nwork + 1;
        // 计算剩余工作空间大小
        zunmbr_("P", "R", "C", m, m, m, &work[il], &ldwrkl, &work[
            itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &
            ierr);
        // 调用 LAPACK 子程序 zunmbr，计算右奇异向量的乘积，并将结果存储在 work[ivt]

/*
                Multiply right singular vectors of L in WORK(IL) by Q
                in A, storing result in WORK(IL) and copying to A
                (CWorkspace: need 2*M*M, prefer M*M+M*N))
                (RWorkspace: 0)
*/

        i__2 = *n;
        i__1 = chunk;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
            i__1) {
/* Computing MIN */
            i__3 = *n - i__ + 1;
            blk = min(i__3,chunk);
            // 计算当前块的大小 blk
            zgemm_("N", "N", m, &blk, m, &c_b57, &work[ivt], m, &a[
                i__ * a_dim1 + 1], lda, &c_b56, &work[il], &
                ldwrkl);
            // 调用 BLAS 子程序 zgemm，将左奇异向量乘以 A 的块，并将结果存储在 work[il]
            zlacpy_("F", m, &blk, &work[il], &ldwrkl, &a[i__ * a_dim1
                + 1], lda);
            // 将结果复制回 A 的相应位置
/* L40: */
        }

        } else if (wntqs) {

/*
               Path 3t (N much larger than M, JOBZ='S')
               M right singular vectors to be computed in VT and
               M left singular vectors to be computed in U
*/

        il = 1;
        // 设置 IL 的初始值为 1

/*              WORK(IL) is M by M */

        ldwrkl = *m;
        // 设置 ldwrkl 为 *m，即 M 的大小
        itau = il + ldwrkl * *m;
        // 设置 itau 为 il + ldwrkl * *m，用于存储后续计算的工作空间
        nwork = itau + *m;
        // 设置 nwork 为 itau + *m，计算剩余工作空间大小

/*
                Compute A=L*Q
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        // 计算剩余工作空间大小
        zgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);
        // 调用 LAPACK 子程序 zgelqf，计算 LQ 分解
/*              Copy L to WORK(IL), zeroing out above it */
/* 将L复制到WORK(IL)，上面的部分置零 */

        zlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
        /* 使用 zlacpy_ 函数将矩阵 L 复制到 WORK(IL)
           'L' 表示复制下三角部分
           m 是矩阵的维度
           a 是源矩阵的起始地址
           lda 是源矩阵的 leading dimension
           work 是目标矩阵的起始地址
           ldwrkl 是目标矩阵的 leading dimension */

        i__1 = *m - 1;
        i__2 = *m - 1;
        zlaset_("U", &i__1, &i__2, &c_b56, &c_b56, &work[il + ldwrkl],
             &ldwrkl);
        /* 使用 zlaset_ 函数将 WORK(IL) 的上三角部分置零
           'U' 表示设置上三角部分
           i__1 和 i__2 是行列数
           c_b56 是一个常数
           work[il + ldwrkl] 是起始位置
           ldwrkl 是 leading dimension */
        
/*
                Generate Q in A
                (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        zunglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__1, &ierr);
        /* 使用 zunglq_ 函数在矩阵 A 中生成 Q
           m 是矩阵 A 的行数
           n 是矩阵 A 的列数
           work[itau] 是存储 elementary reflectors 的工作数组
           work[nwork] 是工作空间
           i__1 是工作数组的长度
           ierr 是返回的错误码 */

        ie = 1;
        itauq = itau;
        itaup = itauq + *m;
        nwork = itaup + *m;
        /* 设置各种工作数组的偏移量和长度 */

/*
                Bidiagonalize L in WORK(IL)
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/

        i__1 = *lwork - nwork + 1;
        zgebrd_(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);
        /* 使用 zgebrd_ 函数对 WORK(IL) 中的矩阵 L 进行双对角化处理
           m 是矩阵的维度
           work[il] 是要双对角化的矩阵
           ldwrkl 是 WORK(IL) 的 leading dimension
           s 是存储奇异值的数组
           rwork[ie] 是工作数组
           work[itauq], work[itaup], work[nwork] 是工作空间 */

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *m;
        irvt = iru + *m * *m;
        nrwork = irvt + *m * *m;
        dbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);
        /* 使用 dbdsdc_ 函数进行双对角矩阵的奇异值分解
           m 是矩阵的维度
           s 是双对角矩阵的对角元素（奇异值）
           rwork[ie], rwork[iru], rwork[irvt] 是工作空间和存储结果的空间
           dum, idum 是临时存储空间
           rwork[nrwork], iwork 是工作空间和整数工作数组 */

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
        /* 使用 zlacp2_ 函数将实数矩阵 RWORK(IRU) 复制到复数矩阵 U
           'F' 表示复制整个矩阵
           m 是矩阵的维度
           rwork[iru] 是实数矩阵的起始位置
           m 是 leading dimension
           u[u_offset] 是复数矩阵的起始位置
           ldu 是复数矩阵的 leading dimension */

        i__1 = *lwork - nwork + 1;
        zunmbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        /* 使用 zunmbr_ 函数将左奇异向量 Q 应用到 U 上
           'Q' 表示应用 Q
           'L' 表示左边应用
           'N' 表示不传输共轭
           m 是矩阵的维度
           work[il] 是存储 elementary reflectors 的工作数组
           ldwrkl 是 leading dimension
           work[itauq] 是工作空间
           u[u_offset] 是要乘以 Q 的矩阵 U
           ldu 是 U 的 leading dimension
           work[nwork] 是工作空间 */

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by left singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
        /* 使用 zlacp2_ 函数将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
           'F' 表示复制整个矩阵
           m 是矩阵的维度
           rwork[irvt] 是实数矩阵的起始位置
           m 是 leading dimension
           vt[vt_offset] 是复数矩阵的起始位置
           ldvt 是复数矩阵的 leading dimension */

        i__1 = *lwork - nwork + 1;
        zunmbr_("P", "R", "C", m, m, m, &work[il], &ldwrkl, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        /* 使用 zunmbr_ 函数将右奇异向量 P 应用到 VT 上
           'P' 表示应用 P
           'R' 表示右边应用
           'C' 表示传输共轭
           m 是矩阵的维度
           work[il] 是存储 elementary reflectors 的工作数组
           ldwrkl 是 leading dimension
           work[itaup] 是工作空间
           vt[vt_offset] 是要乘以 P 的矩阵 VT
           ldvt 是 VT 的 leading dimension
           work[nwork] 是工作空间 */

/*
                Copy VT to WORK(IL), multiply right singular vectors of L
                in WORK(IL) by Q in A, storing result in VT
                (CWorkspace: need M*M)
                (RWorkspace: 0)
*/

        zlacpy_("F", m, m, &vt[vt_offset], ldvt, &work[il], &ldwrkl);
        /* 使用 zlac
/*
                Path 9t (N much larger than M, JOBZ='A')
                N right singular vectors to be computed in VT and
                M left singular vectors to be computed in U
*/

        ivt = 1;  // 设置 ivt 的起始索引为 1

/*              WORK(IVT) is M by M */

        ldwkvt = *m;  // ldwkvt 表示 WORK(IVT) 的列数，即 M
        itau = ivt + ldwkvt * *m;  // itau 是下一个工作区数组的起始索引，用于存储元素对应于 LQ 分解的 tau
        nwork = itau + *m;  // nwork 是下一个工作区数组的起始索引，用于存储其他工作区数组

/*
                Compute A=L*Q, copying result to VT
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        zgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);  // 执行 LQ 分解，结果存储在 A 中，复制到 VT 中

        zlacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);  // 将 A 的上三角部分复制到 VT 中

/*
                Generate Q in VT
                (CWorkspace: need M+N, prefer M+N*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        zunglq_(n, n, m, &vt[vt_offset], ldvt, &work[itau], &work[
            nwork], &i__1, &ierr);  // 生成 Q，并存储在 VT 中

/*              Produce L in A, zeroing out above it */

        i__1 = *m - 1;
        i__2 = *m - 1;
        zlaset_("U", &i__1, &i__2, &c_b56, &c_b56, &a[(a_dim1 << 1) +
            1], lda);  // 将 A 的上三角部分设置为零，得到 L

        ie = 1;  // 设置 rwork 数组的起始索引
        itauq = itau;  // itauq 是用于存储 Q 的左部分的起始索引
        itaup = itauq + *m;  // itaup 是用于存储 Q 的右部分的起始索引
        nwork = itaup + *m;  // 更新 nwork，用于存储其他工作区数组

/*
                Bidiagonalize L in A
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/

        i__1 = *lwork - nwork + 1;
        zgebrd_(m, m, &a[a_offset], lda, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);  // 对 L 进行双对角化

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *m;  // iru 是存储左奇异向量的起始索引
        irvt = iru + *m * *m;  // irvt 是存储右奇异向量的起始索引
        nrwork = irvt + *m * *m;  // 更新 nrwork，用于存储其他 rwork 数组

        dbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);  // 执行双对角 SVD，计算左右奇异向量

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of L
                (CWorkspace: need 3*M, prefer 2*M+M*NB)
                (RWorkspace: 0)
*/

        zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);  // 将 rwork 中的左奇异向量复制到 U 中
        i__1 = *lwork - nwork + 1;
        zunmbr_("Q", "L", "N", m, m, m, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);  // 使用 Q 的左部分更新 U

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by right singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/
        zlacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);

```        
        // 调用 LAPACK 函数 zlacp2 复制矩阵
        // 将 rwork[irvt] 的 m*m 部分复制到 work[ivt] 中，使用列优先存储方式，行宽为 ldwkvt
        zlacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);



        i__1 = *lwork - nwork + 1;
        zunmbr_("P", "R", "C", m, m, m, &a[a_offset], lda, &work[
            itaup], &work[ivt], &ldwkvt, &work[nwork], &i__1, &
            ierr);


        // 调用 LAPACK 函数 zunmbr 应用 Q 矩阵到 work[ivt] 的右奇异向量上
        // 使用 P 方式应用右乘，生成矩阵 C
        // a[a_offset] 是输入矩阵 A，work[itaup] 存储 Q 的元素，work[ivt] 存储右奇异向量，ldwkvt 是 work[ivt] 的行宽
        // work[nwork] 是工作空间，i__1 是工作数组的长度，ierr 是输出的错误码
        zunmbr_("P", "R", "C", m, m, m, &a[a_offset], lda, &work[
            itaup], &work[ivt], &ldwkvt, &work[nwork], &i__1, &
            ierr);



        zgemm_("N", "N", m, n, m, &c_b57, &work[ivt], &ldwkvt, &vt[
            vt_offset], ldvt, &c_b56, &a[a_offset], lda);


        // 调用 BLAS 函数 zgemm 计算矩阵乘积
        // 计算 work[ivt] 和 vt 的矩阵乘积，结果存储在矩阵 A 中
        // ldwkvt 是 work[ivt] 的行宽，vt[vt_offset] 是输入矩阵 VT，ldvt 是 vt 的行宽
        // a[a_offset] 是输出矩阵 A，lda 是 A 的行宽
        zgemm_("N", "N", m, n, m, &c_b57, &work[ivt], &ldwkvt, &vt[
            vt_offset], ldvt, &c_b56, &a[a_offset], lda);



        zlacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);


        // 调用 LAPACK 函数 zlacpy 复制矩阵
        // 复制矩阵 A 的 m*n 部分到矩阵 VT
        // 使用列优先存储方式，行宽为 ldvt
        zlacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);



        zgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, &ierr);


        // 调用 LAPACK 函数 zgebrd 将矩阵 A 变为双对角形式
        // 输出的对角线元素存储在 s 数组中，对角线下的元素存储在 rwork[ie] 中
        // work[itauq] 和 work[itaup] 分别存储生成的 Householder 变换的元素
        // work[nwork] 是工作空间，i__1 是工作数组的长度，ierr 是输出的错误码
        zgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, &ierr);



        dbdsdc_("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);


        // 调用 LAPACK 函数 dbdsdc 计算奇异值
        // 只计算奇异值，不生成任何矩阵
        // 输入参数包括 s 数组和相关工作空间
        // 输出结果存储在 rwork[nrwork] 中，info 是输出的错误码
        dbdsdc_("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);



        zlacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);


        // 调用 LAPACK 函数 zlacpy 复制矩阵
        // 复制矩阵 A 的 m*m 部分到矩阵 U
        // 使用行优先存储方式，行宽为 ldu
        zlacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);



        zungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);


        // 调用 LAPACK 函数 zungbr 生成 Q 矩阵
        // 从 Householder 变换中重构 Q 矩阵，存储在矩阵 U 中
        // 输入参数包括工作空间 work 和 Householder 变换的元素 work[itauq]
        // 输出结果存储在矩阵 U 中，i__1 是工作数组的长度，ierr 是输出的错误码
        zungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);



        zungbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &work[
            nwork], &i__1, &ierr);


        // 调用 LAPACK 函数 zungbr 生成 P**H 矩阵
        // 从 Householder 变换中重构 P**H 矩阵，存储在矩阵 A 中
        // 输入参数包括工作空间 work 和 Householder 变换的元素 work[itaup]
        // 输出结果存储在矩阵 A 中，i__1 是工作数组的长度，ierr 是输出的错误码
        zungbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &work[
            nwork], &i__1, &ierr);



        if (*lwork >= *m * *n + *m * 3) {


        // 检查工作空间是否足够大
        // 如果 lwork 大于等于 m*n + m*3，则使用全尺寸的工作空间



        } else {


        // 如果工作空间不够大，则使用缩减后的工作空间
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Multiply Q in U by real matrix RWORK(IRVT)
                storing the result in WORK(IVT), copying to U
                (Cworkspace: need 0)
                (Rworkspace: need 2*M*M)
*/
zlacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &work[ivt], &
    ldwkvt, &rwork[nrwork]);
zlacpy_("F", m, m, &work[ivt], &ldwkvt, &u[u_offset], ldu);

/*
                Multiply RWORK(IRVT) by P**H in A, storing the
                result in WORK(IVT), copying to A
                (CWorkspace: need M*M, prefer M*N)
                (Rworkspace: need 2*M*M, prefer 2*M*N)
*/
nrwork = iru;
i__1 = *n;
i__2 = chunk;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
    i__2) {
    /* Computing MIN */
    i__3 = *n - i__ + 1;
    blk = min(i__3,chunk);
    zlarcm_(m, &blk, &rwork[irvt], m, &a[i__ * a_dim1 + 1],
        lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
    zlacpy_("F", m, &blk, &work[ivt], &ldwkvt, &a[i__ *
        a_dim1 + 1], lda);
    /* L50: */
}

} else if (wntqs) {

/*
                Copy A to U, generate Q
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: 0)
*/
zlacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
i__2 = *lwork - nwork + 1;
zungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
    nwork], &i__2, &ierr);

/*
                Copy A to VT, generate P**H
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: 0)
*/
zlacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
zungbr_("P", m, n, m, &vt[vt_offset], ldvt, &work[itaup], &
    work[nwork], &i__2, &ierr);

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
irvt = nrwork;
iru = irvt + *m * *m;
nrwork = iru + *m * *m;
dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Multiply Q in U by real matrix RWORK(IRU), storing the
                result in A, copying to U
                (CWorkspace: need 0)
                (Rworkspace: need 3*M*M)
*/
        zlacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset],
             lda, &rwork[nrwork]);

```    
        # Multiply the complex matrix U by the real matrix RWORK(IRU),
        # storing the result in A. This operation combines the transformation
        # represented by U with the real matrix stored in RWORK(IRU).
        # (Cworkspace: need 0)
        # (Rworkspace: need 3*M*M)



        zlacpy_("F", m, m, &a[a_offset], lda, &u[u_offset], ldu);


        # Copy matrix A to matrix U.
        # This function makes a full copy of matrix A into matrix U.



        nrwork = iru;
        zlarcm_(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);


        # Multiply the complex matrix VT by the real matrix RWORK(IRVT),
        # storing the result in A. This operation combines the transformation
        # represented by VT with the real matrix stored in RWORK(IRVT).
        # (Cworkspace: need 0)
        # (Rworkspace: need M*M+2*M*N)



        zlacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);


        # Copy matrix A to matrix VT.
        # This function makes a full copy of matrix A into matrix VT.



        zlacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);


        # Copy matrix A to matrix U.
        # This function copies the lower triangular part of matrix A to matrix U.



        i__2 = *lwork - nwork + 1;
        zungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__2, &ierr);


        # Generate the complex unitary matrix Q.
        # This function applies a complex unitary transformation represented
        # by Q to matrix U, overwriting U with the result.
        # (Cworkspace: need 2*M, prefer M+M*NB)
        # (Rworkspace: 0)



        zlacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);


        # Copy matrix A to matrix VT.
        # This function copies the upper triangular part of matrix A to matrix VT.



        i__2 = *lwork - nwork + 1;
        zungbr_("P", n, n, m, &vt[vt_offset], ldvt, &work[itaup], &
            work[nwork], &i__2, &ierr);


        # Generate the complex unitary matrix P**H.
        # This function applies a complex unitary transformation represented
        # by P**H to matrix VT, overwriting VT with the result.
        # (Cworkspace: need 2*M, prefer M+M*NB)
        # (Rworkspace: 0)



        irvt = nrwork;
        iru = irvt + *m * *m;
        nrwork = iru + *m * *m;
        dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);


        # Perform the bidiagonal SVD of matrix A.
        # This function computes the singular value decomposition (SVD) of
        # the bidiagonal matrix represented by matrix A. It computes the left
        # singular vectors in RWORK(IRU) and the right singular vectors in
        # RWORK(IRVT).
        # (CWorkspace: need 0)
        # (RWorkspace: need BDSPAC)



        zlacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset],
             lda, &rwork[nrwork]);


        # Multiply the complex matrix U by the real matrix RWORK(IRU),
        # storing the result in A. This operation combines the transformation
        # represented by U with the real matrix stored in RWORK(IRU).
        # (Cworkspace: need 0)
        # (Rworkspace: need 3*M*M)



        zlarcm_(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);


        # Multiply the complex matrix VT by the real matrix RWORK(IRVT),
        # storing the result in A. This operation combines the transformation
        # represented by VT with the real matrix stored in RWORK(IRVT).
        # (Cworkspace: need 0)
        # (Rworkspace: need M*M+2*M*N)



        }


        # End of if statement block.
        # This marks the end of the if-else block that determines the path of
        # execution based on the value of N relative to MNTHR2.



    } else {


    # Beginning of else block.
    # This part of the code executes when N < MNTHR2.
    # It starts the path 6t where N is greater than M but not significantly larger.
    # The code reduces matrix A to bidiagonal form without performing an LQ decomposition
    # and subsequently uses ZUNMBR to compute singular vectors.
    ```


        ie = 1;
        nrwork = ie + *m;
        itauq = 1;
        itaup = itauq + *m;
        nwork = itaup + *m;


        # Initialize indices and workspace sizes for the bidiagonalization process.
        # ie is set to 1, nrwork is initialized to ie + *m,
        # itauq is set to 1, itaup is set to itauq + *m,
        # nwork is set to itaup + *m.
        ```
/*
             Bidiagonalize A
             (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
             (RWorkspace: M)
*/
i__2 = *lwork - nwork + 1;
zgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
    &work[itaup], &work[nwork], &i__2, &ierr);
if (wntqn) {

/*
                Compute singular values only
                (Cworkspace: 0)
                (Rworkspace: need BDSPAN)
*/
dbdsdc_("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
    c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
} else if (wntqo) {
ldwkvt = *m;
ivt = nwork;
if (*lwork >= *m * *n + *m * 3) {

/*                 WORK( IVT ) is M by N */

zlaset_("F", m, n, &c_b56, &c_b56, &work[ivt], &ldwkvt);
nwork = ivt + ldwkvt * *n;
} else {

/*                 WORK( IVT ) is M by CHUNK */

chunk = (*lwork - *m * 3) / *m;
nwork = ivt + ldwkvt * chunk;
}

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
irvt = nrwork;
iru = irvt + *m * *m;
nrwork = iru + *m * *m;
dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of A
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: need 0)
*/
zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
i__2 = *lwork - nwork + 1;
zunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

if (*lwork >= *m * *n + *m * 3) {

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by right singular vectors of A,
                copying to A
                (Cworkspace: need M*N+2*M, prefer M*N+M+M*NB)
                (Rworkspace: need 0)
*/
zlacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
i__2 = *lwork - nwork + 1;
zunmbr_("P", "R", "C", m, n, m, &a[a_offset], lda, &work[
    itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2,
    &ierr);
zlacpy_("F", m, n, &work[ivt], &ldwkvt, &a[a_offset], lda);
} else {

/*
                   Generate P**H in A
                   (Cworkspace: need 2*M, prefer M+M*NB)
                   (Rworkspace: need 0)
*/
i__2 = *lwork - nwork + 1;
zungbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &
    work[nwork], &i__2, &ierr);
/*
   Multiply Q in A by real matrix RWORK(IRU), storing the
   result in WORK(IU), copying to A
   (CWorkspace: need M*M, prefer M*N)
   (Rworkspace: need 3*M*M, prefer M*M+2*M*N)
*/
            nrwork = iru;
            i__2 = *n;
            i__1 = chunk;
            for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
                 i__1) {
                /* Computing MIN */
                i__3 = *n - i__ + 1;
                blk = min(i__3,chunk);
                zlarcm_(m, &blk, &rwork[irvt], m, &a[i__ * a_dim1 + 1]
                    , lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
                zlacpy_("F", m, &blk, &work[ivt], &ldwkvt, &a[i__ *
                    a_dim1 + 1], lda);
                /* L60: */
            }
        }
        } else if (wntqs) {

/*
   Perform bidiagonal SVD, computing left singular vectors
   of bidiagonal matrix in RWORK(IRU) and computing right
   singular vectors of bidiagonal matrix in RWORK(IRVT)
   (CWorkspace: need 0)
   (RWorkspace: need BDSPAC)
*/
            irvt = nrwork;
            iru = irvt + *m * *m;
            nrwork = iru + *m * *m;
            dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
                rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
                info);

/*
   Copy real matrix RWORK(IRU) to complex matrix U
   Overwrite U by left singular vectors of A
   (CWorkspace: need 3*M, prefer 2*M+M*NB)
   (RWorkspace: M*M)
*/
            zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
            i__1 = *lwork - nwork + 1;
            zunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
                itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

/*
   Copy real matrix RWORK(IRVT) to complex matrix VT
   Overwrite VT by right singular vectors of A
   (CWorkspace: need 3*M, prefer 2*M+M*NB)
   (RWorkspace: M*M)
*/
            zlaset_("F", m, n, &c_b56, &c_b56, &vt[vt_offset], ldvt);
            zlacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
            i__1 = *lwork - nwork + 1;
            zunmbr_("P", "R", "C", m, n, m, &a[a_offset], lda, &work[
                itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
                ierr);
        } else {

/*
   Perform bidiagonal SVD, computing left singular vectors
   of bidiagonal matrix in RWORK(IRU) and computing right
   singular vectors of bidiagonal matrix in RWORK(IRVT)
   (CWorkspace: need 0)
   (RWorkspace: need BDSPAC)
*/
            irvt = nrwork;
            iru = irvt + *m * *m;
            nrwork = iru + *m * *m;

            dbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
                rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
                info);
/*
    Copy real matrix RWORK(IRU) to complex matrix U
    Overwrite U by left singular vectors of A
    (CWorkspace: need 3*M, prefer 2*M+M*NB)
    (RWorkspace: M*M)
*/
zlacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
i__1 = *lwork - nwork + 1;
zunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[itauq],
       &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

/*
    Set all of VT to identity matrix
*/
zlaset_("F", n, n, &c_b56, &c_b57, &vt[vt_offset], ldvt);

/*
    Copy real matrix RWORK(IRVT) to complex matrix VT
    Overwrite VT by right singular vectors of A
    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
    (RWorkspace: M*M)
*/
zlacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
i__1 = *lwork - nwork + 1;
zunmbr_("P", "R", "C", n, n, m, &a[a_offset], lda, &work[itaup],
       &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);

}

}

}

/* Undo scaling if necessary */
if (iscl == 1) {
    if (anrm > bignum) {
        dlascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1],
                &minmn, &ierr);
    }
    if (*info != 0 && anrm > bignum) {
        i__1 = minmn - 1;
        dlascl_("G", &c__0, &c__0, &bignum, &anrm, &i__1, &c__1, &rwork[ie],
                &minmn, &ierr);
    }
    if (anrm < smlnum) {
        dlascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1],
                &minmn, &ierr);
    }
    if (*info != 0 && anrm < smlnum) {
        i__1 = minmn - 1;
        dlascl_("G", &c__0, &c__0, &smlnum, &anrm, &i__1, &c__1, &rwork[ie],
                &minmn, &ierr);
    }
}

/* Return optimal workspace in WORK(1) */
work[1].r = (doublereal) maxwrk, work[1].i = 0.;

return 0;

/* End of ZGESDD */
} /* zgesdd_ */

/* Subroutine */ int zgesv_(integer *n, integer *nrhs, doublecomplex *a,
                             integer *lda, integer *ipiv, doublecomplex *b,
                             integer *ldb, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, b_dim1, b_offset, i__1;

/* Local variables */
extern /* Subroutine */ int xerbla_(char *, integer *), zgetrf_(
    integer *, integer *, doublecomplex *, integer *, integer *,
    integer *), zgetrs_(char *, integer *, integer *, doublecomplex *,
                         integer *, integer *, doublecomplex *, integer *,
                         integer *);

/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

Purpose
=======

ZGESV computes the solution to a complex system of linear equations
   A * X = B,
where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

The LU decomposition with partial pivoting and row interchanges is
    used to factor A as
       A = P * L * U,
    where P is a permutation matrix, L is unit lower triangular, and U is
    upper triangular.  The factored form of A is then used to solve the
    system of equations A * X = B.


# 用于将矩阵 A 分解为
   A = P * L * U，
其中 P 是置换矩阵，L 是单位下三角矩阵，U 是上三角矩阵。然后使用分解后的形式来解
方程组 A * X = B。



    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N coefficient matrix A.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, so the solution could not be computed.

    =====================================================================


# 参数说明

N       (input) INTEGER
        线性方程的数量，即矩阵 A 的阶数。N >= 0.

NRHS    (input) INTEGER
        右手边的数量，即矩阵 B 的列数。NRHS >= 0.

A       (input/output) COMPLEX*16 数组，维度为 (LDA,N)
        输入时为 N×N 的系数矩阵 A。
        输出时，为分解后的 L 和 U，满足 A = P*L*U；L 的单位对角线元素不存储。

LDA     (input) INTEGER
        数组 A 的领先维度。LDA >= max(1,N).

IPIV    (output) INTEGER 数组，维度为 (N)
        定义置换矩阵 P 的主元索引；
        矩阵的第 i 行与第 IPIV(i) 行进行了交换。

B       (input/output) COMPLEX*16 数组，维度为 (LDB,NRHS)
        输入时为 N×NRHS 的右手边矩阵 B。
        输出时，如果 INFO = 0，则为 N×NRHS 的解矩阵 X。

LDB     (input) INTEGER
        数组 B 的领先维度。LDB >= max(1,N).

INFO    (output) INTEGER
        = 0:  成功退出
        < 0:  若 INFO = -i，则第 i 个参数具有非法值
        > 0:  若 INFO = i，则 U(i,i) 正好为零。已完成分解，
              但因 U 正好奇异，因此无法计算解。

=====================================================================



       Test the input parameters.


# 检测输入参数。
    /* Parameter adjustments */
    // 设置矩阵 A 的维度和偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    // 设置 ipiv 数组的偏移量
    --ipiv;
    // 设置矩阵 B 的维度和偏移量
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 检查输入参数是否合法
    if (*n < 0) {
        *info = -1;
    } else if (*nrhs < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*ldb < max(1,*n)) {
        *info = -7;
    }
    // 如果有非法参数，调用错误处理函数 xerbla_ 并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZGESV ", &i__1);
        return 0;
    }

    /*     Compute the LU factorization of A. */
    // 计算矩阵 A 的 LU 分解
    zgetrf_(n, n, &a[a_offset], lda, &ipiv[1], info);
    // 如果计算成功，继续解线性方程组
    if (*info == 0) {

        /*        Solve the system A*X = B, overwriting B with X. */
        // 解线性方程组 A*X = B，将解 X 覆盖到 B 中
        zgetrs_("No transpose", n, nrhs, &a[a_offset], lda, &ipiv[1], &b[
            b_offset], ldb, info);
    }
    // 返回执行成功
    return 0;

/*     End of ZGESV */

} /* zgesv_ */

/* Subroutine */ int zgetf2_(integer *m, integer *n, doublecomplex *a,
    integer *lda, integer *ipiv, integer *info)
{
    /* System generated locals */
    // 系统自动生成的局部变量声明
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    // 局部变量声明
    static integer i__, j, jp;
    static doublereal sfmin;
    // 外部函数声明
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *), zgeru_(integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *), zswap_(integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);

    // 错误处理函数声明
    extern /* Subroutine */ int xerbla_(char *, integer *);
    // 找到向量中绝对值最大元素的函数声明
    extern integer izamax_(integer *, doublecomplex *, integer *);


注释：这段代码是一个 LAPACK（线性代数包）中的子程序，用于计算复数矩阵的 LU 分解和解线性方程组。
    IPIV    (output) INTEGER array, dimension (min(M,N))
            存储主元的索引数组；对于 1 <= i <= min(M,N)，表示第 i 行与第 IPIV(i) 行进行了交换。

    INFO    (output) INTEGER
            返回状态信息：
            = 0: 成功完成
            < 0: 如果 INFO = -k，表示第 k 个参数具有非法值
            > 0: 如果 INFO = k，表示 U(k,k) 恰好为零。已完成因式分解，
                 但因子 U 恰好是奇异的，如果用它来解方程组将会导致除以零的错误。

    =====================================================================

       Test the input parameters.
    /* Parameter adjustments */
    // 对参数进行调整，a_dim1 为每行的偏移量，a_offset 是起始位置偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 检查 m 是否小于 0
    if (*m < 0) {
    // 若 m 小于 0，则设置 info 为 -1
    *info = -1;
    } else if (*n < 0) {
    // 若 n 小于 0，则设置 info 为 -2
    *info = -2;
    } else if (*lda < max(1,*m)) {
    // 若 lda 小于 1 和 m 中的较大者，则设置 info 为 -4
    *info = -4;
    }
    // 如果 info 不为 0，则调用错误处理函数 xerbla_，并返回
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZGETF2", &i__1);
    return 0;
    }

/*     Quick return if possible */

    // 若 m 或 n 为 0，则直接返回
    if (*m == 0 || *n == 0) {
    return 0;
    }

/*     Compute machine safe minimum */

    // 计算机器的安全最小值，具体值由 SAFEMINIMUM 给出

    sfmin = SAFEMINIMUM;

    // 对于 j 从 1 到 min(m, n) 的循环
    i__1 = min(*m,*n);
    for (j = 1; j <= i__1; ++j) {

/*        Find pivot and test for singularity. */

    // 计算出最大元素的行索引 jp
    i__2 = *m - j + 1;
    jp = j - 1 + izamax_(&i__2, &a[j + j * a_dim1], &c__1);
    // 将行索引 jp 记录在 ipiv 数组中
    ipiv[j] = jp;
    // 检查主元是否为零
    i__2 = jp + j * a_dim1;
    if (a[i__2].r != 0. || a[i__2].i != 0.) {

/*           Apply the interchange to columns 1:N. */

        // 如果 jp 不等于 j，则交换矩阵的列
        if (jp != j) {
        zswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);
        }

/*           Compute elements J+1:M of J-th column. */

        // 计算第 J 列的 J+1 到 M 元素
        if (j < *m) {
        // 如果主元的绝对值大于等于 sfmin，则进行数值除法和缩放
        if (z_abs(&a[j + j * a_dim1]) >= sfmin) {
            i__2 = *m - j;
            z_div(&z__1, &c_b57, &a[j + j * a_dim1]);
            zscal_(&i__2, &z__1, &a[j + 1 + j * a_dim1], &c__1);
        } else {
            // 否则，对列进行数值除法
            i__2 = *m - j;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = j + i__ + j * a_dim1;
            z_div(&z__1, &a[j + i__ + j * a_dim1], &a[j + j *
                a_dim1]);
            a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L20: */
            }
        }
        }

    } else if (*info == 0) {

        // 如果 info 为 0，则记录行索引 j 到 info
        *info = j;
    }

    // 如果 j 小于 min(m, n)，则更新剩余的子矩阵
    if (j < min(*m,*n)) {

/*           Update trailing submatrix. */

        // 计算需要更新的子矩阵大小
        i__2 = *m - j;
        i__3 = *n - j;
        // 执行矩阵乘法更新
        z__1.r = -1., z__1.i = -0.;
        zgeru_(&i__2, &i__3, &z__1, &a[j + 1 + j * a_dim1], &c__1, &a[j +
            (j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1], lda)
            ;
    }
/* L10: */
    }
    // 返回
    return 0;

/*     End of ZGETF2 */

} /* zgetf2_ */

/* Subroutine */ int zgetrf_(integer *m, integer *n, doublecomplex *a,
    integer *lda, integer *ipiv, integer *info)
{
    /* System generated locals */
    // 系统生成的本地变量声明
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    doublecomplex z__1;

    /* Local variables */
    // 本地变量声明
    static integer i__, j, jb, nb, iinfo;
    // 外部子程序声明
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *), ztrsm_(char *, char *, char *, char *,
         integer *, integer *, doublecomplex *, doublecomplex *, integer *
        , doublecomplex *, integer *),
        zgetf2_(integer *, integer *, doublecomplex *, integer *, integer
        *, integer *), xerbla_(char *, integer *);
    // 环境参数查询函数声明
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    # extern 关键字表明这是一个外部声明，通常用于声明在其他文件中定义的函数或变量
    # zlaswp_ 是一个外部子程序（subroutine）的名称，其功能和实现在当前文件之外定义
    # 参数说明：
    # - 第一个参数 integer *：指针类型，可能用于传递整数值的地址
    # - 第二个参数 doublecomplex *：指针类型，可能用于传递复数数据的地址
    # - 第三个参数 integer *：指针类型，可能用于传递整数值的地址
    # - 第四个参数 integer *：指针类型，可能用于传递整数值的地址
    # - 第五个参数 integer *：指针类型，可能用于传递整数值的地址
    # - 第六个参数 integer *：指针类型，可能用于传递整数值的地址
    # - 第七个参数 integer *：指针类型，可能用于传递整数值的地址
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.

    =====================================================================


       Test the input parameters.
*/
{
    /* Parameter adjustments */
    a_dim1 = *lda;                  // 设置矩阵 A 的第一维度为 LDA
    a_offset = 1 + a_dim1;          // 计算数组 A 的偏移量
    a -= a_offset;                  // 将 A 数组移动到正确的起始位置
    --ipiv;                         // 将 ipiv 数组向前移动一个位置

    /* Function Body */
    *info = 0;                      // 初始化 INFO 为 0
    if (*m < 0) {                   // 检查参数 m 是否小于 0
        *info = -1;                 // 若是，将 INFO 设为 -1
    } else if (*n < 0) {            // 检查参数 n 是否小于 0
        *info = -2;                 // 若是，将 INFO 设为 -2
    } else if (*lda < max(1,*m)) {  // 检查 LDA 是否小于 max(1, m)
        *info = -4;                 // 若是，将 INFO 设为 -4
    }
    if (*info != 0) {               // 若 INFO 不为 0，则出现错误
        i__1 = -(*info);            // 计算错误编号
        xerbla_("ZGETRF", &i__1);    // 调用错误处理函数 xerbla_
        return 0;                   // 返回 0 表示出错
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {       // 若 m 或 n 为 0，直接返回
        return 0;
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "ZGETRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)
        1);                         // 确定适合当前环境的块大小 nb
    if (nb <= 1 || nb >= min(*m,*n)) {

/*        Use unblocked code. */

    zgetf2_(m, n, &a[a_offset], lda, &ipiv[1], info);  // 调用 zgetf2_ 函数执行未块化的 LU 分解
    } else {

/*        Use blocked code. */

    i__1 = min(*m,*n);              // 计算要处理的最小尺寸
    i__2 = nb;
    for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
        i__3 = min(*m,*n) - j + 1;  // 计算当前块的尺寸
        jb = min(i__3,nb);

/*
             Factor diagonal and subdiagonal blocks and test for exact
             singularity.
*/
        i__3 = *m - j + 1;
        zgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);

// 计算 LU 分解的第 j 列和其后面的部分，使用 zgetf2_ 函数。


        if (*info == 0 && iinfo > 0) {
        *info = iinfo + j - 1;
        }

// 如果 *info == 0 且 iinfo > 0，则更新 *info 为 iinfo + j - 1，表示发现一个奇异点。


        i__3 = min(i__4,i__5);
        for (i__ = j; i__ <= i__3; ++i__) {
        ipiv[i__] = j - 1 + ipiv[i__];
// 将当前列的行交换索引 ipiv 更新为全局行索引。
        }

// 更新 ipiv 数组，将当前块的行交换索引调整为全局行索引。


        i__3 = j - 1;
        i__4 = j + jb - 1;
        zlaswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);

// 应用行交换到 A 的列 1 到 J-1 上，使用 zlaswp_ 函数。


        if (j + jb <= *n) {

// 如果当前处理的块的列索引加块大小小于或等于总列数 *n，则继续处理剩余的列。


        i__3 = *n - j - jb + 1;
        i__4 = j + jb - 1;
        zlaswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
            ipiv[1], &c__1);

// 应用行交换到 A 的列 J+JB 到 N 上，使用 zlaswp_ 函数。


        i__3 = *n - j - jb + 1;
        ztrsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
            c_b57, &a[j + j * a_dim1], lda, &a[j + (j + jb) *
            a_dim1], lda);

// 计算 U 的块行，使用 ztrsm_ 函数进行矩阵乘法。


        if (j + jb <= *m) {

// 如果当前处理的块的列索引加块大小小于或等于总行数 *m，则更新剩余子矩阵。


            i__3 = *m - j - jb + 1;
            i__4 = *n - j - jb + 1;
            z__1.r = -1., z__1.i = -0.;
            zgemm_("No transpose", "No transpose", &i__3, &i__4, &jb,
                &z__1, &a[j + jb + j * a_dim1], lda, &a[j + (j +
                jb) * a_dim1], lda, &c_b57, &a[j + jb + (j + jb) *
                 a_dim1], lda);

// 更新剩余子矩阵的计算，使用 zgemm_ 函数进行矩阵乘法。


    }
    }
    return 0;

// 返回 0，表示成功执行完 ZGETRF 函数。


} /* zgetrf_ */

// 结束 zgetrf_ 子程序的定义。


/* Subroutine */ int zgetrs_(char *trans, integer *n, integer *nrhs,
    doublecomplex *a, integer *lda, integer *ipiv, doublecomplex *b,
    integer *ldb, integer *info)
{

// 开始 zgetrs_ 子程序的定义，解决线性方程组问题。
    ! 检查输入参数的有效性

    ! TRANS (input) CHARACTER*1
    ! 系统方程的形式：
    ! = 'N':  A * X = B     (不转置)
    ! = 'T':  A**T * X = B  (转置)
    ! = 'C':  A**H * X = B  (共轭转置)

    ! N (input) INTEGER
    ! 矩阵 A 的阶数。要求 N >= 0。

    ! NRHS (input) INTEGER
    ! 右手边的数量，即矩阵 B 的列数。要求 NRHS >= 0。

    ! A (input) COMPLEX*16 array, dimension (LDA,N)
    ! ZGETRF 计算后的因子 L 和 U，使得 A = P*L*U。

    ! LDA (input) INTEGER
    ! 数组 A 的领先维度。要求 LDA >= max(1,N)。

    ! IPIV (input) INTEGER array, dimension (N)
    ! 来自 ZGETRF 的主元素索引；对于 1<=i<=N，第 i 行与第 IPIV(i) 行交换。

    ! B (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
    ! 输入时为右手边矩阵 B，输出时为解矩阵 X。

    ! LDB (input) INTEGER
    ! 数组 B 的领先维度。要求 LDB >= max(1,N)。

    ! INFO (output) INTEGER
    ! 返回的状态信息：
    ! = 0: 成功退出
    ! < 0: 如果 INFO = -i，表示第 i 个参数具有非法值

    !=====================================================================

    ! 测试输入参数的有效性。
    /* Parameter adjustments */
    // 调整参数偏移
    a_dim1 = *lda;
    // 设置矩阵 A 的第一维度
    a_offset = 1 + a_dim1;
    // 计算 a 的偏移量
    a -= a_offset;
    // 调整矩阵 a 的指针
    --ipiv;
    // 降低指针数组 ipiv 的索引
    b_dim1 = *ldb;
    // 设置矩阵 B 的第一维度
    b_offset = 1 + b_dim1;
    // 计算 b 的偏移量
    b -= b_offset;

    /* Function Body */
    // 函数体开始
    *info = 0;
    // 初始化 info 为 0，表示无错误
    notran = lsame_(trans, "N");
    // 检查是否为非转置操作
    if (! notran && ! lsame_(trans, "T") && ! lsame_(
        trans, "C")) {
    // 如果不是非转置、转置（T）、共轭转置（C）之一，设置 info 为 -1
    *info = -1;
    } else if (*n < 0) {
    // 如果 n 小于 0，设置 info 为 -2
    *info = -2;
    } else if (*nrhs < 0) {
    // 如果 nrhs 小于 0，设置 info 为 -3
    *info = -3;
    } else if (*lda < max(1,*n)) {
    // 如果 lda 小于 max(1, n)，设置 info 为 -5
    *info = -5;
    } else if (*ldb < max(1,*n)) {
    // 如果 ldb 小于 max(1, n)，设置 info 为 -8
    *info = -8;
    }
    if (*info != 0) {
    // 如果 info 不等于 0，调用错误处理函数 xerbla_
    i__1 = -(*info);
    xerbla_("ZGETRS", &i__1);
    // 返回 0
    return 0;
    }

/*     Quick return if possible */

    // 如果 n 或 nrhs 为 0，直接返回 0
    if (*n == 0 || *nrhs == 0) {
    return 0;
    }

    if (notran) {

/*
          Solve A * X = B.

          Apply row interchanges to the right hand sides.
*/

    // 如果不是转置操作

    zlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c__1);
    // 调用 zlaswp_ 函数，对右侧向量应用行交换

/*        Solve L*X = B, overwriting B with X. */

    // 解 L*X = B，覆盖 B 为 X
    ztrsm_("Left", "Lower", "No transpose", "Unit", n, nrhs, &c_b57, &a[
        a_offset], lda, &b[b_offset], ldb);

/*        Solve U*X = B, overwriting B with X. */

    // 解 U*X = B，覆盖 B 为 X
    ztrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b57, &
        a[a_offset], lda, &b[b_offset], ldb);
    } else {

/*
          Solve A**T * X = B  or A**H * X = B.

          Solve U'*X = B, overwriting B with X.
*/

    // 如果是转置操作

    ztrsm_("Left", "Upper", trans, "Non-unit", n, nrhs, &c_b57, &a[
        a_offset], lda, &b[b_offset], ldb);

/*        Solve L'*X = B, overwriting B with X. */

    // 解 L'*X = B，覆盖 B 为 X
    ztrsm_("Left", "Lower", trans, "Unit", n, nrhs, &c_b57, &a[a_offset],
        lda, &b[b_offset], ldb);

/*        Apply row interchanges to the solution vectors. */

    // 对解向量应用行交换
    zlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c_n1);
    }

    // 返回 0
    return 0;

/*     End of ZGETRS */

} /* zgetrs_ */

/* Subroutine */ int zheevd_(char *jobz, char *uplo, integer *n,
    doublecomplex *a, integer *lda, doublereal *w, doublecomplex *work,
    integer *lwork, doublereal *rwork, integer *lrwork, integer *iwork,
    integer *liwork, integer *info)
{
    // zheevd_ 子程序开始
    /* System generated locals */
    // 系统自动生成的本地变量声明
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    // 本地变量声明
    static doublereal eps;
    static integer inde;
    static doublereal anrm;
    static integer imax;
    static doublereal rmin, rmax;
    static integer lopt;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    static doublereal sigma;
    extern logical lsame_(char *, char *);
    static integer iinfo, lwmin, liopt;
    static logical lower;
    static integer llrwk, lropt;
    static logical wantz;
    static integer indwk2, llwrk2;

    static integer iscale;
    static doublereal safmin;
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal bignum;
    # 外部函数声明，用于计算 Hermitian 矩阵或带状矩阵的范数
    extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *,
        integer *, doublereal *);

    # 静态变量声明：指示向量的索引
    static integer indtau;

    # 外部子程序声明：用于计算实对称矩阵的所有特征值
    extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *,
         integer *);

    # 外部子程序声明：用于矩阵的缩放
    extern /* Subroutine */ int zlascl_(char *, integer *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublecomplex *, integer *,
        integer *);

    # 外部子程序声明：用于计算双对称三对角化矩阵的特征值和（可选）特征向量
    extern /* Subroutine */ int zstedc_(char *, integer *, doublereal *,
        doublereal *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublereal *, integer *, integer *, integer *, integer *);

    # 静态变量声明：指示工作数组的索引
    static integer indrwk, indwrk;

    # 静态变量声明：最小整型工作数组的大小
    static integer liwmin;

    # 外部子程序声明：用于 Hermitian 矩阵的特征分解
    extern /* Subroutine */ int zhetrd_(char *, integer *, doublecomplex *,
        integer *, doublereal *, doublereal *, doublecomplex *,
        doublecomplex *, integer *, integer *);

    # 外部子程序声明：用于复制矩阵
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *);

    # 静态变量声明：最小实数值
    static doublereal smlnum;

    # 逻辑变量声明：用于查询工作数组大小
    static logical lquery;

    # 外部子程序声明：用于乘以 Householder 变换的三角矩阵
    extern /* Subroutine */ int zunmtr_(char *, char *, char *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);
/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a
    complex Hermitian matrix A.  If eigenvectors are desired, it uses a
    divide and conquer algorithm.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.
            If N <= 1,                LWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
            If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
*/
    RWORK   (workspace/output) DOUBLE PRECISION array,
                                           dimension (LRWORK)
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.


# RWORK 是用于存储双精度实数的工作空间或输出数组
# 它的维度由 LRWORK 决定，在函数执行完成后，如果 INFO = 0，RWORK(1) 返回最优的 LRWORK 大小



    LRWORK  (input) INTEGER
            The dimension of the array RWORK.
            If N <= 1,                LRWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
            If JOBZ  = 'V' and N > 1, LRWORK must be at least
                           1 + 5*N + 2*N**2.


# LRWORK 是 RWORK 数组的维度，是一个整数输入参数
# 根据 JOBZ 的取值和 N 的大小，LRWORK 需要满足不同的最小要求：
# - 如果 N <= 1，LRWORK 至少为 1
# - 如果 JOBZ = 'N' 且 N > 1，LRWORK 至少为 N
# - 如果 JOBZ = 'V' 且 N > 1，LRWORK 至少为 1 + 5*N + 2*N**2



            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.


# 如果 LRWORK = -1，则假定为工作空间查询；该例程仅计算 WORK、RWORK 和 IWORK 数组的最优大小，
# 并将这些值作为 WORK、RWORK 和 IWORK 数组的第一个条目返回，而不会由 XERBLA 发出与 LWORK、LRWORK 或 LIWORK 相关的错误消息



    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.


# IWORK 是用于存储整数的工作空间或输出数组
# 它的维度由 LIWORK 决定，在函数执行完成后，如果 INFO = 0，IWORK(1) 返回最优的 LIWORK 大小



    LIWORK  (input) INTEGER
            The dimension of the array IWORK.
            If N <= 1,                LIWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
            If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.


# LIWORK 是 IWORK 数组的维度，是一个整数输入参数
# 根据 JOBZ 的取值和 N 的大小，LIWORK 需要满足不同的最小要求：
# - 如果 N <= 1，LIWORK 至少为 1
# - 如果 JOBZ = 'N' 且 N > 1，LIWORK 至少为 1
# - 如果 JOBZ = 'V' 且 N > 1，LIWORK 至少为 3 + 5*N



            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.


# 如果 LIWORK = -1，则假定为工作空间查询；该例程仅计算 WORK、RWORK 和 IWORK 数组的最优大小，
# 并将这些值作为 WORK、RWORK 和 IWORK 数组的第一个条目返回，而不会由 XERBLA 发出与 LWORK、LRWORK 或 LIWORK 相关的错误消息



    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the submatrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).


# INFO 是一个整数输出参数，表示函数执行的退出状态：
# - INFO = 0：成功退出
# - INFO < 0：如果 INFO = -i，则第 i 个参数具有非法值
# - INFO > 0：
#   - 如果 JOBZ = 'N'，则算法未能收敛；中间三对角形式的 i 个非对角元素未收敛为零
#   - 如果 JOBZ = 'V'，则算法未能计算出一个特征值，当处理行和列 INFO/(N+1) 到 mod(INFO,N+1) 的子矩阵时



    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA

    Modified description of INFO. Sven, 16 Feb 05.
    =====================================================================


# 进一步细节说明
# 基于 Jeff Rutter 在加州大学伯克利分校的计算机科学系的贡献
# INFO 的修改描述。Sven，2005年2月16日



       Test the input parameters.


# 检测输入参数
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--w;
--work;
--rwork;
--iwork;

/* Function Body */
wantz = lsame_(jobz, "V");
lower = lsame_(uplo, "L");
lquery = *lwork == -1 || *lrwork == -1 || *liwork == -1;

*info = 0;
if (! (wantz || lsame_(jobz, "N"))) {
    *info = -1;
} else if (! (lower || lsame_(uplo, "U"))) {
    *info = -2;
} else if (*n < 0) {
    *info = -3;
} else if (*lda < max(1,*n)) {
    *info = -5;
}

if (*info == 0) {
    if (*n <= 1) {
        lwmin = 1;
        lrwmin = 1;
        liwmin = 1;
        lopt = lwmin;
        lropt = lrwmin;
        liopt = liwmin;
    } else {
        if (wantz) {
            lwmin = (*n << 1) + *n * *n;
            /* Computing 2nd power */
            i__1 = *n;
            lrwmin = *n * 5 + 1 + (i__1 * i__1 << 1);
            liwmin = *n * 5 + 3;
        } else {
            lwmin = *n + 1;
            lrwmin = *n;
            liwmin = 1;
        }
        /* Computing MAX */
        i__1 = lwmin, i__2 = *n + ilaenv_(&c__1, "ZHETRD", uplo, n, &c_n1,
             &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        lopt = max(i__1,i__2);
        lropt = lrwmin;
        liopt = liwmin;
    }
    work[1].r = (doublereal) lopt, work[1].i = 0.;
    rwork[1] = (doublereal) lropt;
    iwork[1] = liopt;

    if (*lwork < lwmin && ! lquery) {
        *info = -8;
    } else if (*lrwork < lrwmin && ! lquery) {
        *info = -10;
    } else if (*liwork < liwmin && ! lquery) {
        *info = -12;
    }
}

if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZHEEVD", &i__1);
    return 0;
} else if (lquery) {
    return 0;
}

/* Quick return if possible */

if (*n == 0) {
    return 0;
}

if (*n == 1) {
    i__1 = a_dim1 + 1;
    w[1] = a[i__1].r;
    if (wantz) {
        i__1 = a_dim1 + 1;
        a[i__1].r = 1., a[i__1].i = 0.;
    }
    return 0;
}

/* Get machine constants. */

safmin = SAFEMINIMUM;
eps = PRECISION;
smlnum = safmin / eps;
bignum = 1. / smlnum;
rmin = sqrt(smlnum);
rmax = sqrt(bignum);

/* Scale matrix to allowable range, if necessary. */

anrm = zlanhe_("M", uplo, n, &a[a_offset], lda, &rwork[1]);
iscale = 0;
if (anrm > 0. && anrm < rmin) {
    iscale = 1;
    sigma = rmin / anrm;
} else if (anrm > rmax) {
    iscale = 1;
    sigma = rmax / anrm;
}
if (iscale == 1) {
    zlascl_(uplo, &c__0, &c__0, &c_b1034, &sigma, n, n, &a[a_offset], lda,
         info);
}

/* Call ZHETRD to reduce Hermitian matrix to tridiagonal form. */

inde = 1;
indtau = 1;
indwrk = indtau + *n;
indrwk = inde + *n;
indwk2 = indwrk + *n * *n;
llwork = *lwork - indwrk + 1;
llwrk2 = *lwork - indwk2 + 1;
llrwk = *lrwork - indrwk + 1;
zhetrd_(uplo, n, &a[a_offset], lda, &w[1], &rwork[inde], &work[indtau], &
    work[indwrk], &llwork, &iinfo);
/*
   For eigenvalues only, call DSTERF.  For eigenvectors, first call
   ZSTEDC to generate the eigenvector matrix, WORK(INDWRK), of the
   tridiagonal matrix, then call ZUNMTR to multiply it to the
   Householder transformations represented as Householder vectors in
   A.
*/

if (! wantz) {
    // 如果不需要计算特征向量，直接调用 DSTERF 计算特征值
    dsterf_(n, &w[1], &rwork[inde], info);
} else {
    // 如果需要计算特征向量，先调用 ZSTEDC 生成三对角矩阵的特征向量矩阵 WORK(INDWRK)
    // 然后调用 ZUNMTR 将其乘到 A 中的以 Householder 变换表示的 Householder 向量
    zstedc_("I", n, &w[1], &rwork[inde], &work[indwrk], n, &work[indwk2],
            &llwrk2, &rwork[indrwk], &llrwk, &iwork[1], liwork, info);
    // 复制 WORK(INDWRK) 的内容到 A，即将特征向量矩阵复制到 A
    zlacpy_("A", n, n, &work[indwrk], n, &a[a_offset], lda);
}

/*     If matrix was scaled, then rescale eigenvalues appropriately. */

if (iscale == 1) {
    if (*info == 0) {
        imax = *n;
    } else {
        imax = *info - 1;
    }
    // 如果矩阵被缩放过，则适当地重新缩放特征值
    d__1 = 1. / sigma;
    dscal_(&imax, &d__1, &w[1], &c__1);
}

// 设置工作空间相关的优化参数
work[1].r = (doublereal) lopt, work[1].i = 0.;
rwork[1] = (doublereal) lropt;
iwork[1] = liopt;

return 0;

/*     End of ZHEEVD */

} /* zheevd_ */

/* Subroutine */ int zhetd2_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, doublereal *d__, doublereal *e, doublecomplex *tau,
    integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;
doublereal d__1;
doublecomplex z__1, z__2, z__3, z__4;

/* Local variables */
static integer i__;
static doublecomplex taui;
extern /* Subroutine */ int zher2_(char *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *);
static doublecomplex alpha;
extern logical lsame_(char *, char *);
extern /* Double Complex */ VOID zdotc_(doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *);
extern /* Subroutine */ int zhemv_(char *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, doublecomplex *, integer *);
static logical upper;
extern /* Subroutine */ int zaxpy_(integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(
    char *, integer *), zlarfg_(integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *);

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

ZHETD2 reduces a complex Hermitian matrix A to real symmetric
tridiagonal form T by a unitary similarity transformation:
Q' * A * Q = T.

Arguments
=========
*/


注释：以上是对给定代码的详细注释，包括了每一行代码的功能和作用说明。
    # 指定Hermitian矩阵A的存储方式：上三角或下三角
    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    # 矩阵A的阶数N，必须大于等于0
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    # 复数双精度数组A，作为输入输出。维度为(LDA,N)
    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.

    # 数组A的第一维度LDA，必须大于等于max(1,N)
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    # 存储三对角矩阵T的对角元素数组D，维度为(N)
    D       (output) DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).

    # 存储三对角矩阵T的非对角元素数组E，维度为(N-1)
    E       (output) DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

    # 存储初等反射器的标量因子数组TAU，维度为(N-1)
    TAU     (output) COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).

    # 输出参数，表示函数调用是否成功的状态：
    # = 0: 成功退出
    # < 0: 若INFO = -i，表示第i个参数的值非法
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步的细节说明
    # 如果UPLO = 'U'，则矩阵Q表示为初等反射器的乘积
    # 如果UPLO = 'L'，则矩阵Q表示为初等反射器的乘积
    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n-1) . . . H(2) H(1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    A(1:i-1,i+1), and tau in TAU(i).

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(n-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    and tau in TAU(i).
    The contents of A on exit are illustrated by the following examples
    with n = 5:

    if UPLO = 'U':                       if UPLO = 'L':

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    where d and e denote diagonal and off-diagonal elements of T, and vi
    denotes an element of the vector defining H(i).

    =====================================================================

    Test the input parameters



# 说明：
在文档中示例化了矩阵 A 在 n = 5 时不同情况下的内容。对角元素和非对角元素使用 d 和 e 表示，vi 表示定义 H(i) 向量的元素。

此外，文档还包含了一个用于测试输入参数的部分。
    /* Parameter adjustments */
    // 调整参数指针和数组的偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 判断上三角或下三角的标志位
    upper = lsame_(uplo, "U");
    // 如果不是 'U' 或 'L'，将 info 设为 -1
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {  // 如果 n 小于 0，将 info 设为 -2
        *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 max(1, n)，将 info 设为 -4
        *info = -4;
    }
    // 如果 info 不为 0，则调用错误处理程序并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZHETD2", &i__1);
        return 0;
    }

    /*     Quick return if possible */

    // 如果 n 小于等于 0，直接返回
    if (*n <= 0) {
        return 0;
    }

    if (upper) {

        /*        Reduce the upper triangle of A */

        // 设置对角线元素 A(n,n) 的实部为 A(n,n)
        i__1 = *n + *n * a_dim1;
        i__2 = *n + *n * a_dim1;
        d__1 = a[i__2].r;
        a[i__1].r = d__1, a[i__1].i = 0.;
        // 从第 n-1 列开始循环处理每列
        for (i__ = *n - 1; i__ >= 1; --i__) {

            /* 
               Generate elementary reflector H(i) = I - tau * v * v'
               to annihilate A(1:i-1,i+1)
            */

            // 获取 A(i+1,i+1) 元素的值
            i__1 = i__ + (i__ + 1) * a_dim1;
            alpha.r = a[i__1].r, alpha.i = a[i__1].i;
            // 计算并存储向量 v 和相应的 tau
            zlarfg_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &taui);
            // 存储到 e 数组中
            i__1 = i__;
            e[i__1] = alpha.r;

            // 如果 taui 不为 0，则执行以下操作
            if (taui.r != 0. || taui.i != 0.) {

                /* 
                   Apply H(i) from both sides to A(1:i,1:i)
                */

                // 将 A(i+1,i+1) 设置为 1
                i__1 = i__ + (i__ + 1) * a_dim1;
                a[i__1].r = 1., a[i__1].i = 0.;

                /* 
                   Compute  x := tau * A * v  storing x in TAU(1:i)
                */
                // 计算 x := tau * A * v，将结果存储在 tau 数组中
                zhemv_(uplo, &i__, &taui, &a[a_offset], lda, &a[(i__ + 1) *
                    a_dim1 + 1], &c__1, &c_b56, &tau[1], &c__1);

                /* 
                   Compute  w := x - 1/2 * tau * (x'*v) * v
                */
                // 计算 w := x - 1/2 * tau * (x'*v) * v
                z__3.r = -.5, z__3.i = -0.;
                z__2.r = z__3.r * taui.r - z__3.i * taui.i, z__2.i = z__3.r *
                    taui.i + z__3.i * taui.r;
                zdotc_(&z__4, &i__, &tau[1], &c__1, &a[(i__ + 1) * a_dim1 + 1]
                    , &c__1);
                z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r *
                    z__4.i + z__2.i * z__4.r;
                alpha.r = z__1.r, alpha.i = z__1.i;
                zaxpy_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &tau[
                    1], &c__1);

                /* 
                   Apply the transformation as a rank-2 update:
                   A := A - v * w' - w * v'
                */
                z__1.r = -1., z__1.i = -0.;
                zher2_(uplo, &i__, &z__1, &a[(i__ + 1) * a_dim1 + 1], &c__1, &
                    tau[1], &c__1, &a[a_offset], lda);

            } else {
                // 如果 taui 为 0，则将 A(i,i) 设置为 A(i+1,i+1)
                i__1 = i__ + i__ * a_dim1;
                i__2 = i__ + i__ * a_dim1;
                d__1 = a[i__2].r;
                a[i__1].r = d__1, a[i__1].i = 0.;
            }
            // 将 A(i+1,i+1) 设置为 e[i] 的值
            i__1 = i__ + (i__ + 1) * a_dim1;
            i__2 = i__;
            a[i__1].r = e[i__2], a[i__1].i = 0.;
            // 将 d[i+1] 设置为 A(i+1,i+1) 的值
            i__1 = i__ + 1;
            i__2 = i__ + 1 + (i__ + 1) * a_dim1;
            d__[i__1] = a[i__2].r;
            // 将 taui 存储到 tau[i] 中
            i__1 = i__;
            tau[i__1].r = taui.r, tau[i__1].i = taui.i;
            /* L10: */
        }
        // 将 A(1,1) 设置为 A(1,1) 的值
        i__1 = a_dim1 + 1;
        d__[1] = a[i__1].r;
    } else {

        /*        Reduce the lower triangle of A */

        // 将 A(1,1) 设置为 A(1,1) 的值
        i__1 = a_dim1 + 1;
        i__2 = a_dim1 + 1;
        d__1 = a[i__2].r;
        a[i__1].r = d__1, a[i__1].i = 0.;
        // 从第 2 行开始循环处理每行
        i__1 = *n - 1;
    # 循环从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
/*
     Generate elementary reflector H(i) = I - tau * v * v'
     to annihilate A(i+2:n,i)
*/
i__2 = i__ + 1 + i__ * a_dim1;
alpha.r = a[i__2].r, alpha.i = a[i__2].i;
i__2 = *n - i__;
/* Computing MIN */
i__3 = i__ + 2;
zlarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1, &
    taui);
i__2 = i__;
e[i__2] = alpha.r;

if (taui.r != 0. || taui.i != 0.) {

/* Apply H(i) from both sides to A(i+1:n,i+1:n) */

i__2 = i__ + 1 + i__ * a_dim1;
a[i__2].r = 1., a[i__2].i = 0.;

/* Compute  x := tau * A * v  storing y in TAU(i:n-1) */

i__2 = *n - i__;
zhemv_(uplo, &i__2, &taui, &a[i__ + 1 + (i__ + 1) * a_dim1],
    lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b56, &tau[
    i__], &c__1);

/* Compute  w := x - 1/2 * tau * (x'*v) * v */

z__3.r = -.5, z__3.i = -0.;
z__2.r = z__3.r * taui.r - z__3.i * taui.i, z__2.i = z__3.r *
    taui.i + z__3.i * taui.r;
i__2 = *n - i__;
zdotc_(&z__4, &i__2, &tau[i__], &c__1, &a[i__ + 1 + i__ *
    a_dim1], &c__1);
z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r *
    z__4.i + z__2.i * z__4.r;
alpha.r = z__1.r, alpha.i = z__1.i;
i__2 = *n - i__;
zaxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
    i__], &c__1);

/*
   Apply the transformation as a rank-2 update:
   A := A - v * w' - w * v'
*/

i__2 = *n - i__;
z__1.r = -1., z__1.i = -0.;
zher2_(uplo, &i__2, &z__1, &a[i__ + 1 + i__ * a_dim1], &c__1,
    &tau[i__], &c__1, &a[i__ + 1 + (i__ + 1) * a_dim1],
    lda);

} else {
i__2 = i__ + 1 + (i__ + 1) * a_dim1;
i__3 = i__ + 1 + (i__ + 1) * a_dim1;
d__1 = a[i__3].r;
a[i__2].r = d__1, a[i__2].i = 0.;
}
i__2 = i__ + 1 + i__ * a_dim1;
i__3 = i__;
a[i__2].r = e[i__3], a[i__2].i = 0.;
i__2 = i__;
i__3 = i__ + i__ * a_dim1;
d__[i__2] = a[i__3].r;
i__2 = i__;
tau[i__2].r = taui.r, tau[i__2].i = taui.i;
/* L20: */
}
i__1 = *n;
i__2 = *n + *n * a_dim1;
d__[i__1] = a[i__2].r;
}

return 0;

/* End of ZHETD2 */

} /* zhetd2_ */

/* Subroutine */ int zhetrd_(char *uplo, integer *n, doublecomplex *a,
integer *lda, doublereal *d__, doublereal *e, doublecomplex *tau,
doublecomplex *work, integer *lwork, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
doublecomplex z__1;

/* Local variables */
static integer i__, j, nb, kk, nx, iws;
extern logical lsame_(char *, char *);
static integer nbmin, iinfo;
static logical upper;
    ! 声明外部的子程序 zhetd2, zher2k, xerbla 和函数 ilaenv
    extern /* Subroutine */ int zhetd2_(char *, integer *, doublecomplex *,
        integer *, doublereal *, doublereal *, doublecomplex *, integer *), zher2k_(char *, char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublereal *, doublecomplex *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    ! 声明静态变量 ldwork, lwkopt 和 lquery
    static integer ldwork, lwkopt;
    static logical lquery;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZHETRD reduces a complex Hermitian matrix A to real symmetric
    tridiagonal form T by a unitary similarity transformation:
    Q**H * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            指定矩阵 A 的存储方式：'U' 表示存储 A 的上三角部分，'L' 表示存储 A 的下三角部分。

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
            矩阵 A 的阶数，必须大于等于零。

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            输入时为 Hermitian 矩阵 A，输出时将被转换为实对称三对角矩阵 T。
            根据 UPLO 的不同，输出时 A 的对角线和第一个超对角线（或者次对角线）将被 T 的对应元素覆盖，
            同时数组 TAU 表示的元素将构成单位矩阵 Q 的一系列基本反射变换。

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            数组 A 的第一个维度大小，必须大于等于 max(1, N)。

    D       (output) DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            T 的对角线元素数组。

    E       (output) DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            T 的非对角线元素数组，根据 UPLO 的值不同，表示不同的元素。

    TAU     (output) COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            基本反射变换的标量因子数组。

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            用作工作区的数组，输出时，如果 INFO = 0，WORK(1) 返回最优 LWORK 大小。
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            如果 LWORK = -1，则假定为工作空间查询；该例程仅计算 WORK 数组的最佳大小，并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会发出与 LWORK 相关的任何错误消息。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            输出参数：
            = 0: 成功退出
            < 0: 如果 INFO = -i，则第 i 个参数具有非法值

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n-1) . . . H(2) H(1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    A(1:i-1,i+1), and tau in TAU(i).

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(n-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    and tau in TAU(i).

    The contents of A on exit are illustrated by the following examples
    with n = 5:

    if UPLO = 'U':                       if UPLO = 'L':

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    where d and e denote diagonal and off-diagonal elements of T, and vi
    denotes an element of the vector defining H(i).

    进一步细节：
    ===============

    如果 UPLO = 'U'，矩阵 Q 被表示为基本反射器的乘积

       Q = H(n-1) . . . H(2) H(1)。

    每个 H(i) 的形式为

       H(i) = I - tau * v * v'

    其中 tau 是一个复标量，v 是一个复向量，满足 v(i+1:n) = 0 和 v(i) = 1；在退出时，v(1:i-1) 存储在 A(1:i-1,i+1) 中，tau 存储在 TAU(i) 中。

    如果 UPLO = 'L'，矩阵 Q 被表示为基本反射器的乘积

       Q = H(1) H(2) . . . H(n-1)。

    每个 H(i) 的形式为

       H(i) = I - tau * v * v'

    其中 tau 是一个复标量，v 是一个复向量，满足 v(1:i) = 0 和 v(i+1) = 1；在退出时，v(i+2:n) 存储在 A(i+2:n,i) 中，tau 存储在 TAU(i) 中。

    A 在退出时的内容通过以下示例说明，其中 n = 5：

    如果 UPLO = 'U'：                     如果 UPLO = 'L'：

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    其中 d 和 e 表示 T 的对角线和非对角线元素，vi 表示定义 H(i) 的向量的元素。

    =====================================================================


       测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*lwork < 1 && ! lquery) {
        *info = -9;
    }

    if (*info == 0) {

        /* Determine the block size. */

        nb = ilaenv_(&c__1, "ZHETRD", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6,
                     (ftnlen)1);
        lwkopt = *n * nb;
        work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZHETRD", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */

    if (*n == 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    nx = *n;
    iws = 1;
    if (nb > 1 && nb < *n) {

        /*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code).

          Computing MAX
        */
        i__1 = nb, i__2 = ilaenv_(&c__3, "ZHETRD", uplo, n, &c_n1, &c_n1, &
                                  c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1, i__2);
        if (nx < *n) {

            /* Determine if workspace is large enough for blocked code. */

            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

                /*
                  Not enough workspace to use optimal NB:  determine the
                  minimum value of NB, and reduce NB or force use of
                  unblocked code by setting NX = N.

                  Computing MAX
                */
                i__1 = *lwork / ldwork;
                nb = max(i__1, 1);
                nbmin = ilaenv_(&c__2, "ZHETRD", uplo, n, &c_n1, &c_n1, &c_n1,
                                 (ftnlen)6, (ftnlen)1);
                if (nb < nbmin) {
                    nx = *n;
                }
            }
        } else {
            nx = *n;
        }
    } else {
        nb = 1;
    }

    if (upper) {

        /*
          Reduce the upper triangle of A.
          Columns 1:kk are handled by the unblocked method.
        */

        kk = *n - (*n - nx + nb - 1) / nb * nb;
        i__1 = kk + 1;
        i__2 = -nb;
        for (i__ = *n - nb + 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
             i__2) {

            /*
              Reduce columns i:i+nb-1 to tridiagonal form and form the
              matrix W which is needed to update the unreduced part of
              the matrix
            */

            i__3 = i__ + nb - 1;
            zlatrd_(uplo, &i__3, &nb, &a[a_offset], lda, &e[1], &tau[1], &
                    work[1], &ldwork);

            /*
              Update the unreduced submatrix A(1:i-1,1:i-1), using an
              update of the form:  A := A - V*W' - W*V'
            */

            i__3 = i__ - 1;
            z__1.r = -1., z__1.i = -0.;
            zher2k_(uplo, "No transpose", &i__3, &nb, &z__1, &a[i__ *
                    a_dim1 + 1], lda, &work[1], &ldwork, &c_b1034, &a[a_offset], lda);
/*
     Copy superdiagonal elements back into A, and diagonal
     elements into D
*/



i__3 = i__ + nb - 1;
for (j = i__; j <= i__3; ++j) {
    i__4 = j - 1 + j * a_dim1;
    i__5 = j - 1;
    a[i__4].r = e[i__5], a[i__4].i = 0.;
    i__4 = j;
    i__5 = j + j * a_dim1;
    d__[i__4] = a[i__5].r;
/* L10: */
}
/* L20: */



/*        Use unblocked code to reduce the last or only block */



zhetd2_(uplo, &kk, &a[a_offset], lda, &d__[1], &e[1], &tau[1], &iinfo);
} else {



/*        Reduce the lower triangle of A */



i__2 = *n - nx;
i__1 = nb;
for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {



/*
     Reduce columns i:i+nb-1 to tridiagonal form and form the
     matrix W which is needed to update the unreduced part of
     the matrix
*/



i__3 = *n - i__ + 1;
zlatrd_(uplo, &i__3, &nb, &a[i__ + i__ * a_dim1], lda, &e[i__], &
    tau[i__], &work[1], &ldwork);



/*
     Update the unreduced submatrix A(i+nb:n,i+nb:n), using
     an update of the form:  A := A - V*W' - W*V'
*/



i__3 = *n - i__ - nb + 1;
z__1.r = -1., z__1.i = -0.;
zher2k_(uplo, "No transpose", &i__3, &nb, &z__1, &a[i__ + nb +
    i__ * a_dim1], lda, &work[nb + 1], &ldwork, &c_b1034, &a[
    i__ + nb + (i__ + nb) * a_dim1], lda);



/*
     Copy subdiagonal elements back into A, and diagonal
     elements into D
*/



i__3 = i__ + nb - 1;
for (j = i__; j <= i__3; ++j) {
    i__4 = j + 1 + j * a_dim1;
    i__5 = j;
    a[i__4].r = e[i__5], a[i__4].i = 0.;
    i__4 = j;
    i__5 = j + j * a_dim1;
    d__[i__4] = a[i__5].r;
/* L30: */
}
/* L40: */



/*        Use unblocked code to reduce the last or only block */



i__1 = *n - i__ + 1;
zhetd2_(uplo, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__],
    &tau[i__], &iinfo);



work[1].r = (doublereal) lwkopt, work[1].i = 0.;
return 0;

/*     End of ZHETRD */
} /* zhetrd_ */

/* Subroutine */ int zhseqr_(char *job, char *compz, integer *n, integer *ilo,
 integer *ihi, doublecomplex *h__, integer *ldh, doublecomplex *w,
doublecomplex *z__, integer *ldz, doublecomplex *work, integer *lwork,
 integer *info)
{



/*
 System generated locals
*/



address a__1[2];
integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3[2];
doublereal d__1, d__2, d__3;
doublecomplex z__1;
char ch__1[2];



/*
 Local variables
*/



static doublecomplex hl[2401]    /* was [49][49] */;
static integer kbot, nmin;
extern logical lsame_(char *, char *);
static logical initz;
static doublecomplex workl[49];
static logical wantt, wantz;
    # 声明 zcopy_ 子程序用于复制复数数组，参数包括数组大小和源与目标数组
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    # 声明 zlaqr0_ 子程序，执行特定的计算任务，参数包括逻辑控制、整数和复数数组等
    extern /* Subroutine */ int zlaqr0_(logical *, logical *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, doublecomplex *, integer *,
         doublecomplex *, integer *, integer *);

    # 声明 xerbla_ 子程序，处理错误信息输出，参数包括错误信息字符串和整数
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明 ilaenv_ 函数，返回某些环境参数的值，参数包括整数、字符串和其他整数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 声明 zlahqr_ 子程序，执行特定的计算任务，参数包括逻辑控制、整数和复数数组等
    extern /* Subroutine */ int zlahqr_(logical *, logical *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         integer *, integer *, doublecomplex *, integer *, integer *);

    # 声明 zlacpy_ 子程序，复制复数矩阵，参数包括矩阵类型、大小和源与目标矩阵
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    # 声明 zlaset_ 子程序，设置复数矩阵中的元素值，参数包括矩阵类型、大小和设定值
    extern /* Subroutine */ int zlaset_(char *, integer *,
        integer *, doublecomplex *, doublecomplex *, doublecomplex *,
        integer *);

    # 声明静态逻辑变量 lquery，用于表示是否进行了查询
    static logical lquery;
    /* Parameter adjustments */
    h_dim1 = *ldh;  // 获取 h 的第一维度大小
    h_offset = 1 + h_dim1;  // 计算 h 的偏移量
    h__ -= h_offset;  // 调整 h 指针的起始位置
    --w;  // 减小 w 数组的指针
    z_dim1 = *ldz;  // 获取 z 的第一维度大小
    z_offset = 1 + z_dim1;  // 计算 z 的偏移量
    z__ -= z_offset;  // 调整 z 指针的起始位置
    --work;  // 减小 work 数组的指针

    /* Function Body */
    wantt = lsame_(job, "S");  // 检查 job 是否为 "S"，确定是否需要计算特征向量
    initz = lsame_(compz, "I");  // 检查 compz 是否为 "I"，确定是否需要初始化 z
    wantz = initz || lsame_(compz, "V");  // 如果需要初始化 z 或计算特征向量，则设置为 true
    d__1 = (doublereal) max(1,*n);  // 将 max(1,*n) 转换为双精度实数
    z__1.r = d__1, z__1.i = 0.;  // 设置复数值 z__1 为 (d__1, 0)
    work[1].r = z__1.r, work[1].i = z__1.i;  // 将 z__1 复制到 work 数组的第一个元素

    lquery = *lwork == -1;  // 检查是否进行工作空间查询

    *info = 0;  // 初始化 info 为 0，表示调用成功

    if (! lsame_(job, "E") && ! wantt) {  // 检查 job 是否为 "E" 且 wantt 为 false
        *info = -1;  // 设置错误码为 -1
    } else if (! lsame_(compz, "N") && ! wantz) {  // 检查 compz 是否为 "N" 且 wantz 为 false
        *info = -2;  // 设置错误码为 -2
    } else if (*n < 0) {  // 检查 n 是否小于 0
        *info = -3;  // 设置错误码为 -3
    } else if (*ilo < 1 || *ilo > max(1,*n)) {  // 检查 ilo 是否在合理范围内
        *info = -4;  // 设置错误码为 -4
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {  // 检查 ihi 是否在合理范围内
        *info = -5;  // 设置错误码为 -5
    } else if (*ldh < max(1,*n)) {  // 检查 ldh 是否足够大
        *info = -7;  // 设置错误码为 -7
    } else if (*ldz < 1 || wantz && *ldz < max(1,*n)) {  // 检查 ldz 是否足够大
        *info = -10;  // 设置错误码为 -10
    } else if (*lwork < max(1,*n) && ! lquery) {  // 检查 lwork 是否足够大
        *info = -12;  // 设置错误码为 -12
    }

    if (*info != 0) {

        /* ==== Quick return in case of invalid argument. ==== */

        i__1 = -(*info);  // 计算 info 的相反数
        xerbla_("ZHSEQR", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0 表示异常结束

    } else if (*n == 0) {

        /* ==== Quick return in case N = 0; nothing to do. ==== */

        return 0;  // 返回 0 表示无需操作

    } else if (lquery) {

        /* ==== Quick return in case of a workspace query ==== */

        zlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1], ilo,
            ihi, &z__[z_offset], ldz, &work[1], lwork, info);
        /*
              ==== Ensure reported workspace size is backward-compatible with
              .    previous LAPACK versions. ====
           Computing MAX
        */
        d__2 = work[1].r, d__3 = (doublereal) max(1,*n);  // 计算工作空间的最大需求
        d__1 = max(d__2,d__3);  // 取两者中的较大值
        z__1.r = d__1, z__1.i = 0.;  // 设置复数值 z__1
        work[1].r = z__1.r, work[1].i = z__1.i;  // 将结果存储在 work 数组的第一个元素
        return 0;  // 返回 0 表示查询结束

    } else {

        /* ==== copy eigenvalues isolated by ZGEBAL ==== */

        if (*ilo > 1) {  // 如果 ilo 大于 1
            i__1 = *ilo - 1;
            i__2 = *ldh + 1;
            zcopy_(&i__1, &h__[h_offset], &i__2, &w[1], &c__1);  // 复制 h 中的特征值到 w
        }
        if (*ihi < *n) {  // 如果 ihi 小于 n
            i__1 = *n - *ihi;
            i__2 = *ldh + 1;
            zcopy_(&i__1, &h__[*ihi + 1 + (*ihi + 1) * h_dim1], &i__2, &w[
                *ihi + 1], &c__1);  // 复制 h 中的特征值到 w
        }

        /* ==== Initialize Z, if requested ==== */

        if (initz) {
            zlaset_("A", n, n, &c_b56, &c_b57, &z__[z_offset], ldz);  // 初始化 z 矩阵
        }

        /* ==== Quick return if possible ==== */

        if (*ilo == *ihi) {  // 如果 ilo 等于 ihi
            i__1 = *ilo;
            i__2 = *ilo + *ilo * h_dim1;
            w[i__1].r = h__[i__2].r, w[i__1].i = h__[i__2].i;  // 将 h 的对角元素作为特征值
            return 0;  // 返回 0 表示结束
        }

        /*
              ==== ZLAHQR/ZLAQR0 crossover point ====

           Writing concatenation
        */
        i__3[0] = 1, a__1[0] = job;  // 将 job 的第一个字符赋给 a__1 数组的第一个元素
        i__3[1] = 1, a__1[1] = compz;  // 将 compz 的第一个字符赋给 a__1 数组的第二个元素
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 合并字符串形成 ch__1
        nmin = ilaenv_(&c__12, "ZHSEQR", ch__1, n, ilo, ihi, lwork, (ftnlen)6,
             (ftnlen)2);  // 计算最小工作空间需求
        nmin = max(11,nmin);  // 取 nmin 和 11 中的较大值

        /* ==== ZLAQR0 for big matrices; ZLAHQR for small ones ==== */
    // 如果 *n 大于 nmin，则执行以下代码块
    if (*n > nmin) {
        // 调用 zlaqr0_ 函数，进行特定的计算任务
        zlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
            ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
    } else {
/*           ==== Small matrix ==== */

/* 调用 LAPACK 函数 zlahqr_ 处理小型矩阵的特征值计算 */
zlahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
    ilo, ihi, &z__[z_offset], ldz, info);

/* 检查 zlahqr_ 函数返回的信息 *info，如果大于0，表示特征值计算失败 */
if (*info > 0) {

/*
    ==== A rare ZLAHQR failure!  ZLAQR0 sometimes succeeds
    .    when ZLAHQR fails. ====
*/

/* 将失败信息记录在 kbot 中 */
kbot = *info;

/* 根据矩阵大小决定调用 ZLAQR0 或者进行额外处理 */
if (*n >= 49) {

/*
    ==== Larger matrices have enough subdiagonal scratch
    .    space to call ZLAQR0 directly. ====
*/

/* 直接调用 ZLAQR0 处理大型矩阵 */
zlaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset],
    ldh, &w[1], ilo, ihi, &z__[z_offset], ldz, &work[
    1], lwork, info);

} else {

/*
    ==== Tiny matrices don't have enough subdiagonal
    .    scratch space to benefit from ZLAQR0.  Hence,
    .    tiny matrices must be copied into a larger
    .    array before calling ZLAQR0. ====
*/

/* 将小型矩阵复制到一个大数组中，并调用 ZLAQR0 处理 */
zlacpy_("A", n, n, &h__[h_offset], ldh, hl, &c__49);
i__1 = *n + 1 + *n * 49 - 50;
hl[i__1].r = 0., hl[i__1].i = 0.;
i__1 = 49 - *n;
zlaset_("A", &c__49, &i__1, &c_b56, &c_b56, &hl[(*n + 1) *
     49 - 49], &c__49);
zlaqr0_(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49, &
    w[1], ilo, ihi, &z__[z_offset], ldz, workl, &
    c__49, info);

/* 如果需要计算 Schur 形式（wantt=1），或者 ZLAQR0 处理失败，则将数据复制回原始矩阵 */
if (wantt || *info != 0) {
    zlacpy_("A", n, n, hl, &c__49, &h__[h_offset], ldh);
}
}
}

/*        ==== Clear out the trash, if necessary. ==== */

/* 如果需要计算 Schur 形式（wantt=1），或者 ZLAQR0 处理失败，并且矩阵维度大于2，则清除多余部分 */
if ((wantt || *info != 0) && *n > 2) {
    i__1 = *n - 2;
    i__2 = *n - 2;
    zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &h__[h_dim1 + 3], ldh);
}

/*
    ==== Ensure reported workspace size is backward-compatible with
    .    previous LAPACK versions. ====

   Computing MAX
*/

/* 确保报告的工作空间大小兼容于之前的 LAPACK 版本 */
d__2 = (doublereal) max(1,*n), d__3 = work[1].r;
d__1 = max(d__2,d__3);
z__1.r = d__1, z__1.i = 0.;
work[1].r = z__1.r, work[1].i = z__1.i;
}

/*     ==== End of ZHSEQR ==== */

/* 返回 0 表示正常执行完成 */
return 0;
} /* zhseqr_ */

/* Subroutine */ int zlabrd_(integer *m, integer *n, integer *nb,
    doublecomplex *a, integer *lda, doublereal *d__, doublereal *e,
    doublecomplex *tauq, doublecomplex *taup, doublecomplex *x, integer *
    ldx, doublecomplex *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublecomplex alpha;
    # 声明外部的四个复数运算子程序，用于处理复数向量和矩阵的操作
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *), 
        # zscal_：复数向量的缩放操作
        zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *),
        # zgemv_：复数矩阵-向量乘法操作
        zlarfg_(integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *), 
        # zlarfg_：生成一个标量反射，用于Householder变换
        zlacgv_(integer *, doublecomplex *, integer *);
        # zlacgv_：对复数向量进行共轭变换
"""
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLABRD reduces the first NB rows and columns of a complex general
    m by n matrix A to upper or lower real bidiagonal form by a unitary
    transformation Q' * A * P, and returns the matrices X and Y which
    are needed to apply the transformation to the unreduced part of A.

    If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
    bidiagonal form.

    This is an auxiliary routine called by ZGEBRD

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.

    N       (input) INTEGER
            The number of columns in the matrix A.

    NB      (input) INTEGER
            The number of leading rows and columns of A to be reduced.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the unitary matrix P as a product
              of elementary reflectors.
            If m < n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    D       (output) DOUBLE PRECISION array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).

    E       (output) DOUBLE PRECISION array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.

    TAUQ    (output) COMPLEX*16 array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.

    TAUP    (output) COMPLEX*16 array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.

    X       (output) COMPLEX*16 array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
"""
    LDX     (input) INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
            数组 X 的首维度。LDX 必须满足 LDX >= max(1,M)。

    Y       (output) COMPLEX*16 array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
            输出数组 Y，类型为复数数组，维度为 (LDY,NB)，用于更新矩阵 A 的未约简部分。
            
    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).
            数组 Y 的首维度。LDY 必须满足 LDY >= max(1,N)。

    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

       Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)

    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are complex scalars, and v and u are complex
    vectors.

    If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
    A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
    A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    The elements of the vectors v and u together form the m-by-nb matrix
    V and the nb-by-n matrix U' which are needed, with X and Y, to apply
    the transformation to the unreduced part of the matrix, using a block
    update of the form:  A := A - V*Y' - X*U'.

    The contents of A on exit are illustrated by the following examples
    with nb = 2:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
      (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
      (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )

    where a denotes an element of the original matrix which is unchanged,
    vi denotes an element of the vector defining H(i), and ui an element
    of the vector defining G(i).

    =====================================================================


       Quick return if possible
    /* Parameter adjustments */
    // 对参数进行调整
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    y_dim1 = *ldy;
    y_offset = 1 + y_dim1;
    y -= y_offset;

    /* Function Body */
    // 函数体开始
    if (*m <= 0 || *n <= 0) {
    // 如果 m 或 n 小于等于 0，则直接返回
    return 0;
    }

    if (*m >= *n) {

/*        Reduce to upper bidiagonal form */

    // 将矩阵约化为上分块双对角形式
    i__1 = *nb;
    // 循环开始，对每个分块操作
    for (i__ = 1; i__ <= i__1; ++i__) {

/*           Update A(i:m,i) */

        // 更新 A(i:m,i)

        // Conjugate vector y
        i__2 = i__ - 1;
        zlacgv_(&i__2, &y[i__ + y_dim1], ldy);
        // Perform matrix-vector multiplication
        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &a[i__ + a_dim1], lda,
             &y[i__ + y_dim1], ldy, &c_b57, &a[i__ + i__ * a_dim1], &
            c__1);
        // Conjugate vector y back
        i__2 = i__ - 1;
        zlacgv_(&i__2, &y[i__ + y_dim1], ldy);
        // Perform matrix-vector multiplication
        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &x[i__ + x_dim1], ldx,
             &a[i__ * a_dim1 + 1], &c__1, &c_b57, &a[i__ + i__ *
            a_dim1], &c__1);

/*           Generate reflection Q(i) to annihilate A(i+1:m,i) */

        // 生成反射矩阵 Q(i)，将 A(i+1:m,i) 变为零
        i__2 = i__ + i__ * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
        // 计算反射向量
        i__2 = *m - i__ + 1;
        // 计算最小值
        i__3 = i__ + 1;
        zlarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1, &
            tauq[i__]);
        // 将反射系数存储到 tauq 数组中
        i__2 = i__;
        d__[i__2] = alpha.r;
        // 如果 i 小于 n，则设置 A(i,i) 为单位矩阵
        if (i__ < *n) {
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = 1., a[i__2].i = 0.;
        }
/*              Compute Y(i+1:n,i) */

/* 计算 Y(i+1:n,i) */
        i__2 = *m - i__ + 1;
        i__3 = *n - i__;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ + (
            i__ + 1) * a_dim1], lda, &a[i__ + i__ * a_dim1], &
            c__1, &c_b56, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 对于第一个 zgemv 函数调用：
   - 使用共轭转置操作符计算矩阵乘法
   - 参数说明：矩阵大小为 i__2 x i__3，矩阵 a 的列数为 lda
   - a 是输入矩阵，y 是输出矩阵，计算结果存放在 y[i__ + 1 + i__ * y_dim1] 中 */

        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            a_dim1], lda, &a[i__ + i__ * a_dim1], &c__1, &c_b56, &
            y[i__ * y_dim1 + 1], &c__1);
/* 对于第二个 zgemv 函数调用：
   - 使用共轭转置操作符计算矩阵乘法
   - 参数说明：矩阵大小为 i__2 x i__3，矩阵 a 的列数为 lda
   - a 是输入矩阵，y 是输出矩阵，计算结果存放在 y[i__ * y_dim1 + 1] 中 */

        i__2 = *n - i__;
        i__3 = i__ - 1;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b57, &y[
            i__ + 1 + i__ * y_dim1], &c__1);
/* 对于第三个 zgemv 函数调用：
   - 不使用转置操作符计算矩阵乘法，进行向量减法
   - 参数说明：矩阵大小为 i__2 x i__3，向量 y[i__ + 1 + y_dim1] 是输入向量
   - 计算结果存放在 y[i__ + 1 + i__ * y_dim1] 中 */

        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &x[i__ +
            x_dim1], ldx, &a[i__ + i__ * a_dim1], &c__1, &c_b56, &
            y[i__ * y_dim1 + 1], &c__1);
/* 对于第四个 zgemv 函数调用：
   - 使用共轭转置操作符计算矩阵乘法
   - 参数说明：矩阵大小为 i__2 x i__3，矩阵 x 的列数为 ldx
   - a 是输入矩阵，y 是输出矩阵，计算结果存放在 y[i__ * y_dim1 + 1] 中 */

        i__2 = i__ - 1;
        i__3 = *n - i__;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("Conjugate transpose", &i__2, &i__3, &z__1, &a[(i__ +
            1) * a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &
            c_b57, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 对于第五个 zgemv 函数调用：
   - 使用共轭转置操作符计算矩阵乘法
   - 参数说明：矩阵大小为 i__2 x i__3，矩阵 a 的列数为 lda
   - 计算结果存放在 y[i__ + 1 + i__ * y_dim1] 中 */

        i__2 = *n - i__;
        zscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 对 y[i__ + 1 + i__ * y_dim1] 进行标量乘法，标量为 tauq[i__] */

/*              Update A(i,i+1:n) */

/* 更新 A(i,i+1:n) */

        i__2 = *n - i__;
        zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
/* 对矩阵 a[i__ + (i__ + 1) * a_dim1] 进行共轭转置 */

        zlacgv_(&i__, &a[i__ + a_dim1], lda);
/* 对矩阵 a[i__ + a_dim1] 进行共轭转置 */

        i__2 = *n - i__;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__, &z__1, &y[i__ + 1 +
            y_dim1], ldy, &a[i__ + a_dim1], lda, &c_b57, &a[i__ +
            (i__ + 1) * a_dim1], lda);
/* 使用矩阵乘法计算更新操作
   - 参数说明：矩阵大小为 i__2 x i__，不使用转置操作符
   - y[i__ + 1 + y_dim1] 是输入向量，a[i__ + a_dim1] 是输入矩阵
   - 结果存放在 a[i__ + (i__ + 1) * a_dim1] 中 */

        zlacgv_(&i__, &a[i__ + a_dim1], lda);
/* 对矩阵 a[i__ + a_dim1] 进行共轭转置 */

        i__2 = i__ - 1;
        zlacgv_(&i__2, &x[i__ + x_dim1], ldx);
/* 对矩阵 x[i__ + x_dim1] 进行共轭转置 */

        i__2 = i__ - 1;
        i__3 = *n - i__;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("Conjugate transpose", &i__2, &i__3, &z__1, &a[(i__ +
            1) * a_dim1 + 1], lda, &x[i__ + x_dim1], ldx, &c_b57,
            &a[i__ + (i__ + 1) * a_dim1], lda);
/* 使用共轭转置操作符计算矩阵乘法
   - 参数说明：矩阵大小为 i__2 x i__3，矩阵 a 的列数为 lda
   - 计算结果存放在 a[i__ + (i__ + 1) * a_dim1] 中 */

        i__2 = i__ - 1;
        zlacgv_(&i__2, &x[i__ + x_dim1], ldx);
/* 对矩阵 x[i__ + x_dim1] 进行共轭转置 */

/*              Generate reflection P(i) to annihilate A(i,i+2:n) */

/* 生成反射变换 P(i)，用于消除 A(i,i+2:n) */

        i__2 = i__ + (i__ + 1) * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 获取 alpha 作为 a[i__ + (i__ + 1) * a_dim1] 的值 */

        i__2 = *n - i__;
        i__3 = i__ + 2;
        zlarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
            taup[i__]);
/* 使用 ZLAR
/*              Compute X(i+1:m,i) */

/* 计算 X(i+1:m,i) */

        i__2 = *m - i__;
        i__3 = *n - i__;
        zgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ + 1 + (
            i__ + 1) * a_dim1], lda, &a[i__ + (i__ + 1) * a_dim1],
             lda, &c_b56, &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 调用 BLAS 库函数 zgemv 计算矩阵乘积：
   - "No transpose" 表示不对矩阵进行转置
   - &i__2 是矩阵的行数
   - &i__3 是矩阵的列数
   - &c_b57 是一个复数常量
   - &a[i__ + 1 + (i__ + 1) * a_dim1] 是矩阵 A 的起始位置
   - lda 是 A 的列偏移量
   - &a[i__ + (i__ + 1) * a_dim1] 是矩阵 A 的列向量
   - &c_b56 是一个复数常量
   - &x[i__ + 1 + i__ * x_dim1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = *n - i__;
        zgemv_("Conjugate transpose", &i__2, &i__, &c_b57, &y[i__ + 1
            + y_dim1], ldy, &a[i__ + (i__ + 1) * a_dim1], lda, &
            c_b56, &x[i__ * x_dim1 + 1], &c__1);

/* 调用 BLAS 库函数 zgemv 计算矩阵乘积：
   - "Conjugate transpose" 表示对矩阵进行共轭转置
   - &i__2 是矩阵的行数
   - &i__ 是矩阵的列数
   - &c_b57 是一个复数常量
   - &y[i__ + 1 + y_dim1] 是矩阵 Y 的起始位置
   - ldy 是 Y 的列偏移量
   - &a[i__ + (i__ + 1) * a_dim1] 是矩阵 A 的列向量
   - lda 是 A 的列偏移量
   - &c_b56 是一个复数常量
   - &x[i__ * x_dim1 + 1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = *m - i__;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__, &z__1, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);

/* 调用 BLAS 库函数 zgemv 计算矩阵乘积：
   - "No transpose" 表示不对矩阵进行转置
   - &i__2 是矩阵的行数
   - &i__ 是矩阵的列数
   - &z__1.r = -1., z__1.i = -0. 是一个复数常量
   - &a[i__ + 1 + a_dim1] 是矩阵 A 的起始位置
   - lda 是 A 的列偏移量
   - &x[i__ * x_dim1 + 1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量
   - &c_b57 是一个复数常量
   - &x[i__ + 1 + i__ * x_dim1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = i__ - 1;
        i__3 = *n - i__;
        zgemv_("No transpose", &i__2, &i__3, &c_b57, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            c_b56, &x[i__ * x_dim1 + 1], &c__1);

/* 调用 BLAS 库函数 zgemv 计算矩阵乘积：
   - "No transpose" 表示不对矩阵进行转置
   - &i__2 是矩阵的行数
   - &i__3 是矩阵的列数
   - &c_b57 是一个复数常量
   - &a[(i__ + 1) * a_dim1 + 1] 是矩阵 A 的起始位置
   - lda 是 A 的列偏移量
   - &a[i__ + (i__ + 1) * a_dim1] 是矩阵 A 的列向量
   - lda 是 A 的列偏移量
   - &c_b56 是一个复数常量
   - &x[i__ * x_dim1 + 1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = *m - i__;
        i__3 = i__ - 1;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);

/* 调用 BLAS 库函数 zgemv 计算矩阵乘积：
   - "No transpose" 表示不对矩阵进行转置
   - &i__2 是矩阵的行数
   - &i__3 是矩阵的列数
   - &z__1.r = -1., z__1.i = -0. 是一个复数常量
   - &x[i__ + 1 + x_dim1] 是矩阵 X 的起始位置
   - ldx 是 X 的列偏移量
   - &x[i__ * x_dim1 + 1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量
   - &c_b57 是一个复数常量
   - &x[i__ + 1 + i__ * x_dim1] 是结果向量 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = *m - i__;
        zscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 调用 BLAS 库函数 zscal 对矩阵进行标量乘法操作：
   - &i__2 是矩阵的行数
   - &taup[i__] 是标量乘数
   - &x[i__ + 1 + i__ * x_dim1] 是矩阵 X 的起始位置
   - &c__1 是 X 的列偏移量 */

        i__2 = *n - i__;
        zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);

/* 调用 LAPACK 库函数 zlacgv 对矩阵进行共轭变换：
   - &i__2 是矩阵的列数
   - &a[i__ + (i__ + 1) * a_dim1] 是矩阵 A 的起始位置
   - lda 是 A 的列偏移量 */
        }
/* L10: */
    }
    } else {

/*        Reduce to lower bidiagonal form */

/* 将矩阵 A 降为下角双对角形式 */

    i__1 = *nb;
    for (i__ = 1; i__
/*              Compute X(i+1:m,i) */

/* 计算 X(i+1:m,i) */
i__2 = *m - i__;
i__3 = *n - i__ + 1;
zgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ + 1 + i__ * a_dim1], lda, &a[i__ + i__ * a_dim1], lda, &c_b56, &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 计算 X(i+1:m,i) 的第二部分 */
i__2 = *n - i__ + 1;
i__3 = i__ - 1;
zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &y[i__ + y_dim1], ldy, &a[i__ + i__ * a_dim1], lda, &c_b56, &x[i__ * x_dim1 + 1], &c__1);

/* 计算 X(i+1:m,i) 的第三部分 */
i__2 = *m - i__;
i__3 = i__ - 1;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__3, &z__1, &a[i__ + 1 + a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 计算 X(i+1:m,i) 的第四部分 */
i__2 = i__ - 1;
i__3 = *n - i__ + 1;
zgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ * a_dim1 + 1], lda, &a[i__ + i__ * a_dim1], lda, &c_b56, &x[i__ * x_dim1 + 1], &c__1);

/* 计算 X(i+1:m,i) 的第五部分 */
i__2 = *m - i__;
i__3 = i__ - 1;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__3, &z__1, &x[i__ + 1 + x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 对 X(i+1:m,i) 进行缩放 */
i__2 = *m - i__;
zscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 反转 A(i,i+1:n) 的元素 */
i__2 = *n - i__ + 1;
zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);

/*              Update A(i+1:m,i) */

/* 更新 A(i+1:m,i) 的部分 */

/* 反转 Y(i,1:i-1) 的元素 */
i__2 = i__ - 1;
zlacgv_(&i__2, &y[i__ + y_dim1], ldy);

/* 计算 A(i+1:m,i) 的第一部分 */
i__2 = *m - i__;
i__3 = i__ - 1;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__3, &z__1, &a[i__ + 1 + a_dim1], lda, &y[i__ + y_dim1], ldy, &c_b57, &a[i__ + 1 + i__ * a_dim1], &c__1);

/* 反转 Y(i,1:i-1) 的元素 */
i__2 = i__ - 1;
zlacgv_(&i__2, &y[i__ + y_dim1], ldy);

/* 计算 A(i+1:m,i) 的第二部分 */
i__2 = *m - i__;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__, &z__1, &x[i__ + 1 + x_dim1], ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b57, &a[i__ + 1 + i__ * a_dim1], &c__1);

/*              Generate reflection Q(i) to annihilate A(i+2:m,i) */

/* 生成反射变换 Q(i)，使得 A(i+2:m,i) 被消除 */

/* 获取 alpha */
i__2 = i__ + 1 + i__ * a_dim1;
alpha.r = a[i__2].r, alpha.i = a[i__2].i;

/* 计算反射变换 Q(i) */
i__2 = *m - i__;
/* 计算 i+2 和 *m 中的较小值 */
i__3 = i__ + 2;
zlarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1, &tauq[i__]);

/* 存储结果到 e(i) */
i__2 = i__;
e[i__2] = alpha.r;

/* 设置 A(i+1,i) 为 1 */
i__2 = i__ + 1 + i__ * a_dim1;
a[i__2].r = 1., a[i__2].i = 0.;
/*              Compute Y(i+1:n,i) */

/* 计算 Y(i+1:n,i) */

        i__2 = *m - i__;
        i__3 = *n - i__;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + (i__ + 1) * a_dim1], lda, &a[i__ + 1 + i__ *
            a_dim1], &c__1, &c_b56, &y[i__ + 1 + i__ * y_dim1], &
            c__1);
/* 使用双精度复数进行向量-矩阵乘法，计算 Y(i+1:n,i) */

        i__2 = *m - i__;
        i__3 = i__ - 1;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &y[i__ * y_dim1 + 1], &c__1);
/* 使用双精度复数进行向量-矩阵乘法，计算 Y(1:i-1,i) */

        i__2 = *n - i__;
        i__3 = i__ - 1;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b57, &y[
            i__ + 1 + i__ * y_dim1], &c__1);
/* 使用双精度复数进行向量-矩阵乘法，计算 Y(i+1:n,i) 的负乘积 */

        i__2 = *m - i__;
        zgemv_("Conjugate transpose", &i__2, &i__, &c_b57, &x[i__ + 1
            + x_dim1], ldx, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &y[i__ * y_dim1 + 1], &c__1);
/* 使用双精度复数进行向量-矩阵乘法，计算 Y(1:i,i) */

        i__2 = *n - i__;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("Conjugate transpose", &i__, &i__2, &z__1, &a[(i__ + 1)
             * a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &
            c_b57, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 使用双精度复数进行向量-矩阵乘法，计算 Y(i+1:n,i) 的负乘积 */

        i__2 = *n - i__;
        zscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 对向量进行双精度复数的缩放 */

        } else {
        i__2 = *n - i__ + 1;
        zlacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
        }
/* L20: */
    }
    }
    return 0;

/*     End of ZLABRD */

} /* zlabrd_ */

/* Subroutine */ int zlacgv_(integer *n, doublecomplex *x, integer *incx)
{
    /* System generated locals */
    integer i__1, i__2;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, ioff;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLACGV conjugates a complex vector of length N.

    Arguments
    =========

    N       (input) INTEGER
            The length of the vector X.  N >= 0.

    X       (input/output) COMPLEX*16 array, dimension
                           (1+(N-1)*abs(INCX))
            On entry, the vector of length N to be conjugated.
            On exit, X is overwritten with conjg(X).

    INCX    (input) INTEGER
            The spacing between successive elements of X.

   =====================================================================
*/


    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*incx == 1) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        d_cnjg(&z__1, &x[i__]);
        x[i__2].r = z__1.r, x[i__2].i = z__1.i;
/* L10: */
    }
    } else {
    ioff = 1;
    if (*incx < 0) {
        ioff = 1 - (*n - 1) * *incx;
    }
    i__1 = *n;

/* L20: */
    }
/* 结束子程序 ZLABRD */

} /* zlacgv_ */


注释完成，按照要求对每行代码进行了详细的解释。
    # 循环遍历 i__ 从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 计算当前元素的偏移量 ioff
        i__2 = ioff;
        # 调用 d_cnjg 函数对 x[ioff] 进行共轭操作，结果存入 z__1
        d_cnjg(&z__1, &x[ioff]);
        # 将共轭结果 z__1 的实部赋值给 x[i__2].r，虚部赋值给 x[i__2].i
        x[i__2].r = z__1.r, x[i__2].i = z__1.i;
        # 增加 ioff 的值，以便下一个元素的偏移
        ioff += *incx;
/*
   LAPACK subroutine zlacp2

   Purpose
   =======
   ZLACP2 copies all or part of a real two-dimensional matrix A to a
   complex matrix B.

   Arguments
   ==========
   UPLO    (input) CHARACTER*1
           Specifies the part of the matrix A to be copied to B.
           = 'U':      Upper triangular part
           = 'L':      Lower triangular part
           Otherwise:  All of the matrix A

   M       (input) INTEGER
           The number of rows of the matrix A.  M >= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N >= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The m by n matrix A.  If UPLO = 'U', only the upper trapezium
           is accessed; if UPLO = 'L', only the lower trapezium is
           accessed.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,M).

   B       (output) COMPLEX*16 array, dimension (LDB,N)
           On exit, B = A in the locations specified by UPLO.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB >= max(1,M).

   =====================================================================
*/

/* System generated locals */
integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

/* Local variables */
static integer i__, j;
extern logical lsame_(char *, char *);

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
b_dim1 = *ldb;
b_offset = 1 + b_dim1;
b -= b_offset;

/* Function Body */
if (lsame_(uplo, "U")) {
    /* Copy upper triangular part of A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
            /* Copy real values from A to B, imaginary part set to 0 */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            b[i__3].r = a[i__4], b[i__3].i = 0.;
            /* L10: */
        }
        /* L20: */
    }

} else if (lsame_(uplo, "L")) {
    /* Copy lower triangular part of A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = j; i__ <= i__2; ++i__) {
            /* Copy real values from A to B, imaginary part set to 0 */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            b[i__3].r = a[i__4], b[i__3].i = 0.;
            /* L30: */
        }
        /* L40: */
    }

} else {
    /* Copy entire matrix A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            /* Copy real values from A to B, imaginary part set to 0 */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            b[i__3].r = a[i__4], b[i__3].i = 0.;
            /* L50: */
        }
        /* L60: */
    }
}

return 0;

/* End of ZLACP2 */

} /* zlacp2_ */


注释已经按照要求添加到每一行代码，解释了代码的具体作用和执行过程。
/*
    LAPACK auxiliary routine (version 3.2)
    LAPACK is a software package provided by Univ. of Tennessee,
    Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.,
    November 2006

    Purpose
    =======
    ZLACPY copies all or part of a two-dimensional matrix A to another
    matrix B.

    Arguments
    ==========
    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input) COMPLEX*16 array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (output) COMPLEX*16 array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
*/

/* Subroutine */ int zlacpy_(char *uplo, integer *m, integer *n,
    doublecomplex *a, integer *lda, doublecomplex *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    /* Check if UPLO is 'U' */
    if (lsame_(uplo, "U")) {
        /* Copy upper triangular part of A to B */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = min(j,*m);
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
                /* L10: */
            }
            /* L20: */
        }

    /* Check if UPLO is 'L' */
    } else if (lsame_(uplo, "L")) {
        /* Copy lower triangular part of A to B */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = j; i__ <= i__2; ++i__) {
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
                /* L30: */
            }
            /* L40: */
        }

    /* Copy entire matrix A to B */
    } else {
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
                /* L50: */
            }
            /* L60: */
        }
    }

    /* Return success */
    return 0;

/* End of ZLACPY */
} /* zlacpy_ */
    # 参数类型为整型指针，指向A的第一个维度
    integer *lda,
    # 参数类型为双精度实型指针，指向B的第一个元素
    doublereal *b,
    # 参数类型为整型指针，指向B的第一个维度
    integer *ldb,
    # 参数类型为双复数类型指针，指向C的第一个元素
    doublecomplex *c__,
    # 参数类型为整型指针，指向C的第一个维度
    integer *ldc,
    # 参数类型为双精度实型指针，指向工作数组
    doublereal *rwork
{
    /* System generated locals */
    integer b_dim1, b_offset, a_dim1, a_offset, c_dim1, c_offset, i__1, i__2,
        i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
        November 2006

        Purpose
        =======

        ZLACRM performs a very simple matrix-matrix multiplication:
                 C := A * B,
        where A is M by N and complex; B is N by N and real;
        C is M by N and complex.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A and of the matrix C.
                M >= 0.

        N       (input) INTEGER
                The number of columns and rows of the matrix B and
                the number of columns of the matrix C.
                N >= 0.

        A       (input) COMPLEX*16 array, dimension (LDA, N)
                A contains the M by N matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >=max(1,M).

        B       (input) DOUBLE PRECISION array, dimension (LDB, N)
                B contains the N by N matrix B.

        LDB     (input) INTEGER
                The leading dimension of the array B. LDB >=max(1,N).

        C       (input) COMPLEX*16 array, dimension (LDC, N)
                C contains the M by N matrix C.

        LDC     (input) INTEGER
                The leading dimension of the array C. LDC >=max(1,N).

        RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)

        =====================================================================

        Quick return if possible.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;  // 计算 A 的第一维的起始位置
    a_offset = 1 + a_dim1;  // 计算 A 的偏移量
    a -= a_offset;  // 调整 A 的起始地址

    b_dim1 = *ldb;  // 计算 B 的第一维的起始位置
    b_offset = 1 + b_dim1;  // 计算 B 的偏移量
    b -= b_offset;  // 调整 B 的起始地址

    c_dim1 = *ldc;  // 计算 C 的第一维的起始位置
    c_offset = 1 + c_dim1;  // 计算 C 的偏移量
    c__ -= c_offset;  // 调整 C 的起始地址

    --rwork;  // 调整 RWORK 数组的起始地址

    /* Function Body */
    if (*m == 0 || *n == 0) {  // 如果 M 或者 N 为零，则直接返回
        return 0;
    }

    // 将矩阵 A 的实部复制到 RWORK 数组中
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            rwork[(j - 1) * *m + i__] = a[i__3].r;
        }
    }

    l = *m * *n + 1;  // 计算 RWORK 数组的起始位置

    // 执行矩阵乘法 C := A * B，结果存储在 RWORK 数组中
    dgemm_("N", "N", m, n, n, &c_b1034, &rwork[1], m, &b[b_offset], ldb, &
        c_b328, &rwork[l], m);

    // 从 RWORK 数组中将结果复制回矩阵 C 中
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = l + (j - 1) * *m + i__ - 1;
            c__[i__3].r = rwork[i__4];
            c__[i__3].i = 0.;
        }
    }
}
    # 对于循环中的每个索引 i__，执行以下操作
    for (i__ = 1; i__ <= i__2; ++i__) {
        # 计算复数矩阵 a 中第 j 行、第 i__ 列元素的虚部，并将其存入 rwork 数组中
        rwork[(j - 1) * *m + i__] = d_imag(&a[i__ + j * a_dim1]);
/* L50: */
    }
/* L60: */
    }
    // 调用 BLAS 库中的双精度复杂数矩阵乘法函数 dgemm_
    dgemm_("N", "N", m, n, n, &c_b1034, &rwork[1], m, &b[b_offset], ldb, &
        c_b328, &rwork[l], m);
    // 循环遍历矩阵 c 的每个元素
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 计算 c 的索引
        i__3 = i__ + j * c_dim1;
        i__4 = i__ + j * c_dim1;
        // 将 rwork 数组中的值与 c 的对应元素相乘，并赋值给 c
        d__1 = c__[i__4].r;
        i__5 = l + (j - 1) * *m + i__ - 1;
        z__1.r = d__1, z__1.i = rwork[i__5];
        c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L70: */
    }
/* L80: */
    }

    return 0;

/*     End of ZLACRM */

} /* zlacrm_ */

/* Double Complex */ VOID zladiv_(doublecomplex * ret_val, doublecomplex *x,
    doublecomplex *y)
{
    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;
    doublecomplex z__1;

    /* Local variables */
    static doublereal zi, zr;
    extern /* Subroutine */ int dladiv_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y
    will not overflow on an intermediary step unless the results
    overflows.

    Arguments
    =========

    X       (input) COMPLEX*16
    Y       (input) COMPLEX*16
            The complex scalars X and Y.

    =====================================================================
*/

    // 调用 LAPACK 中的 dladiv_ 函数进行复数除法运算
    d__1 = x->r;
    d__2 = d_imag(x);
    d__3 = y->r;
    d__4 = d_imag(y);
    dladiv_(&d__1, &d__2, &d__3, &d__4, &zr, &zi);
    z__1.r = zr, z__1.i = zi;
     ret_val->r = z__1.r,  ret_val->i = z__1.i;

    return ;

/*     End of ZLADIV */

} /* zladiv_ */

/* Subroutine */ int zlaed0_(integer *qsiz, integer *n, doublereal *d__,
    doublereal *e, doublecomplex *q, integer *ldq, doublecomplex *qstore,
    integer *ldqs, doublereal *rwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, qstore_dim1, qstore_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, ll, iq, lgn, msd2, smm1, spm1, spm2;
    static doublereal temp;
    static integer curr, iperm;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer indxq, iwrem, iqptr, tlvls;
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), zlaed7_(integer *, integer *,
        integer *, integer *, integer *, integer *, doublereal *,
        doublecomplex *, integer *, doublereal *, integer *, doublereal *,
        integer *, integer *, integer *, integer *, integer *,
        doublereal *, doublecomplex *, doublereal *, integer *, integer *);
    static integer igivcl;
    # 声明一个外部子程序 xerbla_，该子程序的参数类型为 char* 和 integer*，返回类型为 void
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明一个外部函数 ilaenv_，该函数的参数类型分别为 integer*, char*, char*, integer*, integer*, integer*, integer*, ftnlen, ftnlen
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 声明一个外部子程序 zlacrm_，该子程序的参数类型为 integer*, integer*, doublecomplex*, integer*, doublereal*, integer*, doublecomplex*, integer*, doublereal*
    extern /* Subroutine */ int zlacrm_(integer *, integer *, doublecomplex *,
         integer *, doublereal *, integer *, doublecomplex *, integer *,
        doublereal *);

    # 声明一个静态整型变量 igivnm
    static integer igivnm;

    # 声明一个静态整型变量 submat
    static integer submat;

    # 声明一个静态整型变量 curprb
    static integer curprb;

    # 声明一个静态整型变量 subpbs
    static integer subpbs;

    # 声明一个静态整型变量 igivpt
    static integer igivpt;

    # 声明一个外部子程序 dsteqr_，该子程序的参数类型为 char*, integer*, doublereal*, doublereal*, doublereal*, integer*, doublereal*, integer*
    extern /* Subroutine */ int dsteqr_(char *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);

    # 声明一个静态整型变量 curlvl
    static integer curlvl;

    # 声明一个静态整型变量 matsiz
    static integer matsiz;

    # 声明一个静态整型变量 iprmpt
    static integer iprmpt;

    # 声明一个静态整型变量 smlsiz
    static integer smlsiz;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    Using the divide and conquer method, ZLAED0 computes all eigenvalues
    of a symmetric tridiagonal matrix which is one diagonal block of
    those from reducing a dense or band Hermitian matrix and
    corresponding eigenvectors of the dense or band matrix.

    Arguments
    =========

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry, the diagonal elements of the tridiagonal matrix.
           On exit, the eigenvalues in ascending order.

    E      (input/output) DOUBLE PRECISION array, dimension (N-1)
           On entry, the off-diagonal elements of the tridiagonal matrix.
           On exit, E has been destroyed.

    Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
           On entry, Q must contain an QSIZ x N matrix whose columns
           are unitarily orthonormal. It is a part of the unitary matrix
           that reduces the full dense Hermitian matrix to a
           (reducible) symmetric tridiagonal matrix.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    IWORK  (workspace) INTEGER array,
           the dimension of IWORK must be at least
                        6 + 6*N + 5*N*lg N
                        ( lg( N ) = smallest integer k
                                    such that 2^k >= N )

    RWORK  (workspace) DOUBLE PRECISION array,
                                 dimension (1 + 3*N + 2*N*lg N + 3*N**2)
                          ( lg( N ) = smallest integer k
                                      such that 2^k >= N )

    QSTORE (workspace) COMPLEX*16 array, dimension (LDQS, N)
           Used to store parts of
           the eigenvector matrix when the updating matrix multiplies
           take place.

    LDQS   (input) INTEGER
           The leading dimension of the array QSTORE.
           LDQS >= max(1,N).

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).

    =====================================================================

    Warning:      N could be as big as QSIZ!


       Test the input parameters.
*/

    /* Parameter adjustments */
    --d__;                // 定义数组 d__，存储对角元素
    --e;                  // 定义数组 e，存储次对角元素
    q_dim1 = *ldq;        // 计算数组 Q 的第一维长度，Q 是一个二维数组，存储单位正交矩阵
    q_offset = 1 + q_dim1;// 计算数组 Q 的偏移量
    q -= q_offset;        // 调整数组 Q 的起始地址
    qstore_dim1 = *ldqs;  // 计算数组 QSTORE 的第一维长度，QSTORE 用于存储部分特征向量矩阵
    qstore_offset = 1 + qstore_dim1;  // 计算数组 QSTORE 的偏移量
    qstore -= qstore_offset;          // 调整数组 QSTORE 的起始地址
    # 计算 qstore 数组的起始偏移量，这里 qstore_dim1 代表第一维的大小
    qstore_offset = 1 + qstore_dim1;
    # 将 qstore 指针移动到正确的起始位置
    qstore -= qstore_offset;
    # rwork 指针向前移动一个位置
    --rwork;
    # iwork 指针向前移动一个位置
    --iwork;

    # 将 info 指针所指的值设置为 0，用于初始化
    *info = 0;
/*
       IF( ICOMPQ .LT. 0 .OR. ICOMPQ .GT. 2 ) THEN
          INFO = -1
       ELSE IF( ( ICOMPQ .EQ. 1 ) .AND. ( QSIZ .LT. MAX( 0, N ) ) )
      $        THEN
*/
    // 检查输入参数的有效性，如果不满足条件则返回错误信息
    if (*qsiz < max(0,*n)) {  
        *info = -1;  // 设置错误代码为-1
    } else if (*n < 0) {
        *info = -2;  // 设置错误代码为-2
    } else if (*ldq < max(1,*n)) {
        *info = -6;  // 设置错误代码为-6
    } else if (*ldqs < max(1,*n)) {
        *info = -8;  // 设置错误代码为-8
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZLAED0", &i__1);  // 调用错误处理函数并返回
        return 0;
    }

/*     Quick return if possible */

    // 如果矩阵维度为0，直接返回
    if (*n == 0) {
        return 0;
    }

    // 获取系统设定的小矩阵阈值
    smlsiz = ilaenv_(&c__9, "ZLAED0", " ", &c__0, &c__0, &c__0, &c__0, (
        ftnlen)6, (ftnlen)1);

/*
       Determine the size and placement of the submatrices, and save in
       the leading elements of IWORK.
*/

    // 初始化工作数组，保存子矩阵的尺寸和位置信息
    iwork[1] = *n;  // 第一个元素表示整个矩阵的大小
    subpbs = 1;  // 子矩阵的数量初始化为1
    tlvls = 0;  // 子矩阵分割的层数初始化为0
L10:
    // 循环计算子矩阵的尺寸和位置信息
    if (iwork[subpbs] > smlsiz) {
        for (j = subpbs; j >= 1; --j) {
            iwork[j * 2] = (iwork[j] + 1) / 2;  // 计算子矩阵的左半部分大小
            iwork[(j << 1) - 1] = iwork[j] / 2;  // 计算子矩阵的右半部分大小
/* L20: */  
        }
        ++tlvls;  // 层数加一
        subpbs <<= 1;  // 子矩阵数量乘以2
        goto L10;  // 回到循环开始处
    }
    // 计算每个子矩阵在整体矩阵中的起始位置
    i__1 = subpbs;
    for (j = 2; j <= i__1; ++j) {
        iwork[j] += iwork[j - 1];
/* L30: */
    }

/*
       Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
       using rank-1 modifications (cuts).
*/

    // 对矩阵进行划分，每个子矩阵的大小不超过SMLSIZ+1，并使用一阶修正进行分割
    spm1 = subpbs - 1;
    i__1 = spm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        submat = iwork[i__] + 1;  // 子矩阵的起始位置
        smm1 = submat - 1;  // 子矩阵起始位置减一
        d__[smm1] -= (d__1 = e[smm1], abs(d__1));  // 子矩阵对角线元素减去绝对值辅助对角线元素
        d__[submat] -= (d__1 = e[smm1], abs(d__1));  // 子矩阵对角线元素减去绝对值辅助对角线元素
/* L40: */
    }

    indxq = (*n << 2) + 3;

/*
       Set up workspaces for eigenvalues only/accumulate new vectors
       routine
*/

    // 设置工作空间，用于仅计算特征值或累积新向量的例程
    temp = log((doublereal) (*n)) / log(2.);
    lgn = (integer) temp;  // 计算log2(n)
    if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;  // 如果2的lgn次幂小于n，则lgn加一
    }
    if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;  // 再次检查，如果依旧小于n，则lgn再加一
    }
    iprmpt = indxq + *n + 1;  // 初始化iprmpt指针位置
    iperm = iprmpt + *n * lgn;  // 初始化iperm指针位置
    iqptr = iperm + *n * lgn;  // 初始化iqptr指针位置
    igivpt = iqptr + *n + 2;  // 初始化igivpt指针位置
    igivcl = igivpt + *n * lgn;  // 初始化igivcl指针位置

    igivnm = 1;  // 初始化igivnm
    iq = igivnm + (*n << 1) * lgn;  // 初始化iq指针位置
/* Computing 2nd power */
    i__1 = *n;
    iwrem = iq + i__1 * i__1 + 1;  // 初始化iwrem指针位置
/*     Initialize pointers */
    i__1 = subpbs;
    for (i__ = 0; i__ <= i__1; ++i__) {
        iwork[iprmpt + i__] = 1;  // 初始化iprmpt后的每个元素为1
        iwork[igivpt + i__] = 1;  // 初始化igivpt后的每个元素为1
/* L50: */
    }

/*
       Solve each submatrix eigenproblem at the bottom of the divide and
       conquer tree.
*/

    // 解决分治树底部的每个子矩阵的特征值问题
    curr = 0;
    i__1 = spm1;
    for (i__ = 0; i__ <= i__1; ++i__) {
        if (i__ == 0) {
            submat = 1;  // 第一个子矩阵的起始位置
            matsiz = iwork[1];  // 第一个子矩阵的大小
        } else {
            submat = iwork[i__] + 1;  // 当前子矩阵的起始位置
            matsiz = iwork[i__ + 1] - iwork[i__];  // 当前子矩阵的大小
        }
        ll = iq - 1 + iwork[iqptr + curr];  // ll指向当前子矩阵在iq中的位置
        dsteqr_("I", &matsiz, &d__[submat], &e[submat], &rwork[ll], &matsiz, &
            rwork[1], info);  // 调用特征值计算函数
        zlacrm_(qsiz, &matsiz, &q[submat * q_dim1 + 1], ldq, &rwork[ll], &
            matsiz, &qstore[submat * qstore_dim1 + 1], ldqs, &rwork[iwrem]
            );  // 计算左右矩阵乘积
/* Computing 2nd power */
        i__2 = matsiz;
        iwork[iqptr + curr + 1] = iwork[iqptr + curr] + i__2 * i__2;  // 更新iqptr
/* L60: */
    }
    # 增加 curr 变量的值
    ++curr;
    # 如果指针 info 指向的值大于 0
    if (*info > 0) {
        # 计算新的 *info 值，基于子矩阵的偏移和大小
        *info = submat * (*n + 1) + submat + matsiz - 1;
        # 返回 0 表示成功
        return 0;
    }
    # 初始化 k 为 1
    k = 1;
    # 设置循环的结束条件为 iwork[i__ + 1]
    i__2 = iwork[i__ + 1];
    # 循环从 submat 到 i__2
    for (j = submat; j <= i__2; ++j) {
        # 设置 indxq + j 处的 iwork 数组元素为 k
        iwork[indxq + j] = k;
        # 增加 k 的值
        ++k;
/* L60
    ! 声明外部子程序 dlaed9, zlaed8, dlaeda, xerbla 和 zlacrm 的接口
    extern /* Subroutine */ int dlaed9_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, integer *),
        zlaed8_(integer *, integer *, integer *, doublecomplex *, integer
        *, doublereal *, doublereal *, integer *, doublereal *,
        doublereal *, doublecomplex *, integer *, doublereal *, integer *,
         integer *, integer *, integer *, integer *,
        doublereal *, integer *), dlaeda_(integer *, integer *, integer *,
         integer *, integer *, integer *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         integer *);

    ! 静态变量 idlmda，用于某种用途的整数
    static integer idlmda;

    ! 声明外部子程序 dlamrg 的接口
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *);

    ! 声明外部子程序 xerbla 的接口，用于处理错误信息
    extern /* Subroutine */ int xerbla_(char *, integer *);

    ! 声明外部子程序 zlacrm 的接口，用于矩阵计算
    extern /* Subroutine */ int zlacrm_(integer *, integer *, doublecomplex *,
        integer *, doublereal *, integer *, doublecomplex *, integer *, doublereal *);
    
    ! 静态变量 coltyp，用于表示某种列类型的整数
    static integer coltyp;
/*
    ZLAED7 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix. This
    routine is used only for the eigenproblem which requires all
    eigenvalues and optionally eigenvectors of a dense or banded
    Hermitian matrix that has been reduced to tridiagonal form.

    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)

    where Z = Q'u, u is a vector of length N with ones in the
    CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

    The eigenvectors of the original matrix are stored in Q, and the
    eigenvalues are in D. The algorithm consists of three stages:

    The first stage consists of deflating the size of the problem
    when there are multiple eigenvalues or if there is a zero in
    the Z vector. For each such occurrence the dimension of the
    secular equation problem is reduced by one. This stage is
    performed by the routine DLAED2.

    The second stage consists of calculating the updated
    eigenvalues. This is done by finding the roots of the secular
    equation via the routine DLAED4 (as called by SLAED3).
    This routine also calculates the eigenvectors of the current
    problem.

    The final stage consists of computing the updated eigenvectors
    directly using the updated eigenvalues. The eigenvectors for
    the current problem are multiplied with the eigenvectors from
    the overall problem.
*/

/*
    Arguments
    =========

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    CUTPNT (input) INTEGER
           Contains the location of the last eigenvalue in the leading
           sub-matrix.  min(1,N) <= CUTPNT <= N.

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N.

    TLVLS  (input) INTEGER
           The total number of merging levels in the overall divide and
           conquer tree.

    CURLVL (input) INTEGER
           The current level in the overall merge routine,
           0 <= curlvl <= tlvls.

    CURPBM (input) INTEGER
           The current problem in the current level in the overall
           merge routine (counting from upper left to lower right).

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry, the eigenvalues of the rank-1-perturbed matrix.
           On exit, the eigenvalues of the repaired matrix.
*/
    Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
           On entry, the eigenvectors of the rank-1-perturbed matrix.
           On exit, the eigenvectors of the repaired tridiagonal matrix.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    RHO    (input) DOUBLE PRECISION
           Contains the subdiagonal element used to create the rank-1
           modification.

    INDXQ  (output) INTEGER array, dimension (N)
           This contains the permutation which will reintegrate the
           subproblem just solved back into sorted order,
           ie. D( INDXQ( I = 1, N ) ) will be in ascending order.

    IWORK  (workspace) INTEGER array, dimension (4*N)

    RWORK  (workspace) DOUBLE PRECISION array,
                                   dimension (3*N+2*QSIZ*N)

    WORK   (workspace) COMPLEX*16 array, dimension (QSIZ*N)

    QSTORE (input/output) DOUBLE PRECISION array, dimension (N**2+1)
           Stores eigenvectors of submatrices encountered during
           divide and conquer, packed together. QPTR points to
           beginning of the submatrices.

    QPTR   (input/output) INTEGER array, dimension (N+2)
           List of indices pointing to beginning of submatrices stored
           in QSTORE. The submatrices are numbered starting at the
           bottom left of the divide and conquer tree, from left to
           right and bottom to top.

    PRMPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in PERM a
           level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
           indicates the size of the permutation and also the size of
           the full, non-deflated problem.

    PERM   (input) INTEGER array, dimension (N lg N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.

    GIVPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in GIVCOL a
           level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
           indicates the number of Givens rotations.

    GIVCOL (input) INTEGER array, dimension (2, N lg N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

    GIVNUM (input) DOUBLE PRECISION array, dimension (2, N lg N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge

    =====================================================================


       Test the input parameters.



       Test the input parameters.
    /* Parameter adjustments */
    --d__;                          // 调整指针d__，指向一维数组d__的起始地址
    q_dim1 = *ldq;                  // 获取q数组的第一维度大小
    q_offset = 1 + q_dim1;          // 计算q数组的偏移量
    q -= q_offset;                  // 将q指针向前移动偏移量，使其指向q的起始地址
    --indxq;                        // 调整指针indxq，指向一维数组indxq的起始地址
    --qstore;                       // 调整指针qstore，指向一维数组qstore的起始地址
    --qptr;                         // 调整指针qptr，指向一维数组qptr的起始地址
    --prmptr;                       // 调整指针prmptr，指向一维数组prmptr的起始地址
    --perm;                         // 调整指针perm，指向一维数组perm的起始地址
    --givptr;                       // 调整指针givptr，指向一维数组givptr的起始地址
    givcol -= 3;                    // 调整指针givcol，使其指向数组givcol的第三个元素
    givnum -= 3;                    // 调整指针givnum，使其指向数组givnum的第三个元素
    --work;                         // 调整指针work，指向一维数组work的起始地址
    --rwork;                        // 调整指针rwork，指向一维数组rwork的起始地址
    --iwork;                        // 调整指针iwork，指向一维数组iwork的起始地址

    /* Function Body */
    *info = 0;                      // 将info的值设为0，表示未发生错误

    if (*n < 0) {                   // 检查n的值是否小于0
        *info = -1;                 // 如果是，将info设为-1，表示参数错误
    } else if (min(1,*n) > *cutpnt || *n < *cutpnt) {  // 检查cutpnt和n的大小关系
        *info = -2;                 // 如果不满足条件，将info设为-2，表示参数错误
    } else if (*qsiz < *n) {        // 检查qsiz是否小于n
        *info = -3;                 // 如果是，将info设为-3，表示参数错误
    } else if (*ldq < max(1,*n)) {  // 检查ldq是否小于max(1, n)
        *info = -9;                 // 如果是，将info设为-9，表示参数错误
    }

    if (*info != 0) {               // 如果info不为0，表示有错误发生
        i__1 = -(*info);            // 将info取反
        xerbla_("ZLAED7", &i__1);    // 调用错误处理函数xerbla_
        return 0;                   // 返回0，表示函数执行结束
    }

    if (*n == 0) {                  // 如果n为0，直接返回
        return 0;                   // 返回0，表示函数执行结束
    }

    /* 
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in DLAED2 and SLAED3.
    */
    // 以下数值仅用于记录目的。它们是整数指针，指示在DLAED2和SLAED3中特定数组使用的工作空间部分。

    iz = 1;                         // 初始化iz为1
    idlmda = iz + *n;               // 计算idlmda的值
    iw = idlmda + *n;               // 计算iw的值
    iq = iw + *n;                   // 计算iq的值

    indx = 1;                       // 初始化indx为1
    indxc = indx + *n;              // 计算indxc的值
    coltyp = indxc + *n;            // 计算coltyp的值
    indxp = coltyp + *n;            // 计算indxp的值

    /* 
       Form the z-vector which consists of the last row of Q_1 and the
       first row of Q_2.
    */
    // 形成z向量，其中包括Q_1的最后一行和Q_2的第一行。

    ptr = pow_ii(&c__2, tlvls) + 1;  // 计算ptr的值
    i__1 = *curlvl - 1;             // 计算循环次数
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = *tlvls - i__;        // 计算指数
        ptr += pow_ii(&c__2, &i__2); // 更新ptr的值
    }
    curr = ptr + *curpbm;           // 计算curr的值
    dlaeda_(n, tlvls, curlvl, curpbm, &prmptr[1], &perm[1], &givptr[1], &
        givcol[3], &givnum[3], &qstore[1], &qptr[1], &rwork[iz], &rwork[
        iz + *n], info);            // 调用dlaeda_函数处理特定的计算任务

    /*
       When solving the final problem, we no longer need the stored data,
       so we will overwrite the data from this level onto the previously
       used storage space.
    */
    // 解决最终问题时，我们不再需要存储的数据，因此我们将从此级别覆盖以前使用的存储空间中的数据。

    if (*curlvl == *tlvls) {        // 如果当前级别等于总级别
        qptr[curr] = 1;             // 将qptr[curr]设为1
        prmptr[curr] = 1;           // 将prmptr[curr]设为1
        givptr[curr] = 1;           // 将givptr[curr]设为1
    }

    /* 
       Sort and Deflate eigenvalues. 
    */
    // 对特征值进行排序和缩减。

    zlaed8_(&k, n, qsiz, &q[q_offset], ldq, &d__[1], rho, cutpnt, &rwork[iz],
        &rwork[idlmda], &work[1], qsiz, &rwork[iw], &iwork[indxp], &iwork[
        indx], &indxq[1], &perm[prmptr[curr]], &givptr[curr + 1], &givcol[
        (givptr[curr] << 1) + 1], &givnum[(givptr[curr] << 1) + 1], info); // 调用zlaed8_函数处理特定的计算任务
    prmptr[curr + 1] = prmptr[curr] + *n; // 更新prmptr[curr + 1]的值
    givptr[curr + 1] += givptr[curr];     // 更新givptr[curr + 1]的值

    /* 
       Solve Secular Equation. 
    */
    // 解决牛顿下降法的迭代过程。

    if (k != 0) {                   // 如果k不为0
        dlaed9_(&k, &c__1, &k, n, &d__[1], &rwork[iq], &k, rho, &rwork[idlmda]
            , &rwork[iw], &qstore[qptr[curr]], &k, info); // 调用dlaed9_函数处理特定的计算任务
        zlacrm_(qsiz, &k, &work[1], qsiz, &qstore[qptr[curr]], &k, &q[
            q_offset], ldq, &rwork[iq]); // 调用zlacrm_函数处理特定的计算任务
        i__1 = k * k;               // 计算k的平方
        qptr[curr + 1] = qptr[curr] + i__1; // 更新qptr[curr + 1]的值
        if (*info != 0) {           // 如果info不为
    // 循环遍历从 1 到 i__1 的整数序列
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 将当前索引 i__ 存储到 indxq 数组中，初始化时与 i__ 相等
        indxq[i__] = i__;
/* L20: */
    }
    }

    return 0;

/*     End of ZLAED7 */

} /* zlaed7_ */

/* Subroutine */ int zlaed8_(integer *k, integer *n, integer *qsiz,
    doublecomplex *q, integer *ldq, doublereal *d__, doublereal *rho,
    integer *cutpnt, doublereal *z__, doublereal *dlamda, doublecomplex *
    q2, integer *ldq2, doublereal *w, integer *indxp, integer *indx,
    integer *indxq, integer *perm, integer *givptr, integer *givcol,
    doublereal *givnum, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, q2_dim1, q2_offset, i__1;
    doublereal d__1;

    /* Local variables */
    static doublereal c__;
    static integer i__, j;
    static doublereal s, t;
    static integer k2, n1, n2, jp, n1p1;
    static doublereal eps, tau, tol;
    static integer jlam, imax, jmax;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dcopy_(integer *, doublereal *, integer *, doublereal
        *, integer *), zdrot_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublereal *, doublereal *), zcopy_(
        integer *, doublecomplex *, integer *, doublecomplex *, integer *);

    extern integer idamax_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *), xerbla_(char *, integer *), zlacpy_(char *, integer *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    ZLAED8 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny element in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    K      (output) INTEGER
           Contains the number of non-deflated eigenvalues.
           This is the order of the related secular equation.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the dense or band matrix to tridiagonal form.
           QSIZ >= N if ICOMPQ = 1.

    Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
           On entry, Q contains the eigenvectors of the partially solved
           system which has been previously updated in matrix
           multiplies with other partially solved eigensystems.
           On exit, Q contains the trailing (N-K) updated eigenvectors
           (those which were deflated) in its last N-K columns.


注释：
    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max( 1, N ).
           数组 Q 的前导维度，LDQ 需满足 LDQ >= max( 1, N )。

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry, D contains the eigenvalues of the two submatrices to
           be combined.  On exit, D contains the trailing (N-K) updated
           eigenvalues (those which were deflated) sorted into increasing
           order.
           输入时，D 包含待合并的两个子矩阵的特征值。输出时，D 包含按升序排序的更新后的 trailing (N-K) 个特征值（即被消除的特征值）。

    RHO    (input/output) DOUBLE PRECISION
           Contains the off diagonal element associated with the rank-1
           cut which originally split the two submatrices which are now
           being recombined. RHO is modified during the computation to
           the value required by DLAED3.
           包含与分裂两个现在正在重新组合的子矩阵的秩-1切割相关联的非对角元素。在计算过程中，RHO 被修改为 DLAED3 需要的值。

    CUTPNT (input) INTEGER
           Contains the location of the last eigenvalue in the leading
           sub-matrix.  MIN(1,N) <= CUTPNT <= N.
           包含主导子矩阵中最后一个特征值的位置。要求 MIN(1,N) <= CUTPNT <= N。

    Z      (input) DOUBLE PRECISION array, dimension (N)
           On input this vector contains the updating vector (the last
           row of the first sub-eigenvector matrix and the first row of
           the second sub-eigenvector matrix).  The contents of Z are
           destroyed during the updating process.
           输入时，该向量包含更新向量（第一个子特征向量矩阵的最后一行和第二个子特征向量矩阵的第一行）。Z 的内容在更新过程中被破坏。

    DLAMDA (output) DOUBLE PRECISION array, dimension (N)
           Contains a copy of the first K eigenvalues which will be used
           by DLAED3 to form the secular equation.
           包含将由 DLAED3 用来形成伪态方程的前 K 个特征值的副本。

    Q2     (output) COMPLEX*16 array, dimension (LDQ2,N)
           If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
           Contains a copy of the first K eigenvectors which will be used
           by DLAED7 in a matrix multiply (DGEMM) to update the new
           eigenvectors.
           如果 ICOMPQ = 0，则不引用 Q2。否则，包含将由 DLAED7 在矩阵乘法（DGEMM）中用来更新新特征向量的前 K 个特征向量的副本。

    LDQ2   (input) INTEGER
           The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
           数组 Q2 的前导维度，LDQ2 需满足 LDQ2 >= max( 1, N )。

    W      (output) DOUBLE PRECISION array, dimension (N)
           This will hold the first k values of the final
           deflation-altered z-vector and will be passed to DLAED3.
           这将保存最终改变的第一个 k 个值的 deflation-altered z-向量，并将传递给 DLAED3。

    INDXP  (workspace) INTEGER array, dimension (N)
           This will contain the permutation used to place deflated
           values of D at the end of the array. On output INDXP(1:K)
           points to the nondeflated D-values and INDXP(K+1:N)
           points to the deflated eigenvalues.
           这将包含用于将 D 的被消除值放置在数组末尾的排列。在输出时，INDXP(1:K) 指向非消除的 D 值，INDXP(K+1:N) 指向消除的特征值。

    INDX   (workspace) INTEGER array, dimension (N)
           This will contain the permutation used to sort the contents of
           D into ascending order.
           这将包含用于将 D 的内容排序为升序的排列。

    INDXQ  (input) INTEGER array, dimension (N)
           This contains the permutation which separately sorts the two
           sub-problems in D into ascending order.  Note that elements in
           the second half of this permutation must first have CUTPNT
           added to their values in order to be accurate.
           这包含分别对 D 中两个子问题进行升序排序的排列。请注意，此排列的第二半部分的元素必须首先在它们的值上加上 CUTPNT 以保持准确性。

    PERM   (output) INTEGER array, dimension (N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.
           包含要应用于每个特征块的排列（来自消除和排序）。

    GIVPTR (output) INTEGER
           Contains the number of Givens rotations which took place in
           this subproblem.
           包含在此子问题中发生的 Givens 旋转的数量。
    GIVCOL (output) INTEGER array, dimension (2, N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

GIVCOL是一个输出参数，是一个整型数组，维度为(2, N)，每一对数字表示在一个Givens旋转中参与的列对。


    GIVNUM (output) DOUBLE PRECISION array, dimension (2, N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.

GIVNUM是一个输出参数，是一个双精度实数数组，维度为(2, N)，每个数字表示在对应的Givens旋转中使用的S值。


    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

INFO是一个输出参数，是一个整数。如果INFO等于0，表示成功执行；如果INFO小于0，如INFO等于-i，表示第i个参数具有非法值。


    =====================================================================

分隔线，用于标记程序说明的开始。


       Test the input parameters.

测试输入参数的开始。
    /* Parameter adjustments */
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --d__;
    --z__;
    --dlamda;
    q2_dim1 = *ldq2;
    q2_offset = 1 + q2_dim1;
    q2 -= q2_offset;
    --w;
    --indxp;
    --indx;
    --indxq;
    --perm;
    givcol -= 3;
    givnum -= 3;

    /* Function Body */
    *info = 0;

    if (*n < 0) {
    *info = -2;
    } else if (*qsiz < *n) {
    *info = -3;
    } else if (*ldq < max(1,*n)) {
    *info = -5;
    } else if (*cutpnt < min(1,*n) || *cutpnt > *n) {
    *info = -8;
    } else if (*ldq2 < max(1,*n)) {
    *info = -12;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZLAED8", &i__1);
    return 0;
    }

/*
       Need to initialize GIVPTR to O here in case of quick exit
       to prevent an unspecified code behavior (usually sigfault)
       when IWORK array on entry to *stedc is not zeroed
       (or at least some IWORK entries which used in *laed7 for GIVPTR).
*/

    *givptr = 0;

/*     Quick return if possible */

    if (*n == 0) {
    return 0;
    }

    n1 = *cutpnt;
    n2 = *n - n1;
    n1p1 = n1 + 1;

    if (*rho < 0.) {
    dscal_(&n2, &c_b1276, &z__[n1p1], &c__1);
    }

/*     Normalize z so that norm(z) = 1 */

    t = 1. / sqrt(2.);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
    indx[j] = j;
/* L10: */
    }
    dscal_(n, &t, &z__[1], &c__1);
    *rho = (d__1 = *rho * 2., abs(d__1));

/*     Sort the eigenvalues into increasing order */

    i__1 = *n;
    for (i__ = *cutpnt + 1; i__ <= i__1; ++i__) {
    indxq[i__] += *cutpnt;
/* L20: */
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    dlamda[i__] = d__[indxq[i__]];
    w[i__] = z__[indxq[i__]];
/* L30: */
    }
    i__ = 1;
    j = *cutpnt + 1;
    dlamrg_(&n1, &n2, &dlamda[1], &c__1, &c__1, &indx[1]);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    d__[i__] = dlamda[indx[i__]];
    z__[i__] = w[indx[i__]];
/* L40: */
    }

/*     Calculate the allowable deflation tolerance */

    imax = idamax_(n, &z__[1], &c__1);
    jmax = idamax_(n, &d__[1], &c__1);
    eps = EPSILON;
    tol = eps * 8. * (d__1 = d__[jmax], abs(d__1));

/*
       If the rank-1 modifier is small enough, no more needs to be done
       -- except to reorganize Q so that its columns correspond with the
       elements in D.
*/

    if (*rho * (d__1 = z__[imax], abs(d__1)) <= tol) {
    *k = 0;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        perm[j] = indxq[indx[j]];
        zcopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1]
            , &c__1);
/* L50: */
    }
    zlacpy_("A", qsiz, n, &q2[q2_dim1 + 1], ldq2, &q[q_dim1 + 1], ldq);
    return 0;
    }
/*
   If there are multiple eigenvalues then the problem deflates.  Here
   the number of equal eigenvalues are found.  As each equal
   eigenvalue is found, an elementary reflector is computed to rotate
   the corresponding eigensubspace so that the corresponding
   components of Z are zero in this new basis.
*/

*k = 0;  // Initialize count of equal eigenvalues found
k2 = *n + 1;  // Initialize index for storing indices of deflated eigenvalues

// Loop over all eigenvalues
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    if (*rho * (d__1 = z__[j], abs(d__1)) <= tol) {

        /* Deflate due to small z component. */

        --k2;  // Decrement index for deflated eigenvalues
        indxp[k2] = j;  // Store index of deflated eigenvalue

        // Check if this is the last eigenvalue
        if (j == *n) {
            goto L100;  // Exit loop if last eigenvalue is deflated
        }
    } else {
        jlam = j;
        goto L70;  // Continue to check for equal eigenvalues
    }
    // L60:  // Unused label, commented out
}
L70:
++j;  // Increment j to continue checking for equal eigenvalues
if (j > *n) {
    goto L90;  // Exit loop if j exceeds number of eigenvalues
}
if (*rho * (d__1 = z__[j], abs(d__1)) <= tol) {

    /* Deflate due to small z component. */

    --k2;  // Decrement index for deflated eigenvalues
    indxp[k2] = j;  // Store index of deflated eigenvalue
} else {

    /* Check if eigenvalues are close enough to allow deflation. */

    s = z__[jlam];
    c__ = z__[j];

    /*
       Find sqrt(a**2+b**2) without overflow or
       destructive underflow.
    */
    tau = dlapy2_(&c__, &s);  // Compute sqrt(c__^2 + s^2)
    t = d__[j] - d__[jlam];  // Compute difference between eigenvalues
    c__ /= tau;  // Normalize c__ by tau
    s = -s / tau;  // Normalize s by -tau (to maintain rotation properties)

    // Check if deflation is possible
    if ((d__1 = t * c__ * s, abs(d__1)) <= tol) {

        /* Deflation is possible. */

        z__[j] = tau;  // Update j-th eigenvalue with tau
        z__[jlam] = 0.;  // Set jlam-th eigenvalue to zero

        /* Record the appropriate Givens rotation */

        ++(*givptr);  // Increment count of Givens rotations
        givcol[(*givptr << 1) + 1] = indxq[indx[jlam]];  // Record indices
        givcol[(*givptr << 1) + 2] = indxq[indx[j]];
        givnum[(*givptr << 1) + 1] = c__;  // Record rotation parameters
        givnum[(*givptr << 1) + 2] = s;
        zdrot_(qsiz, &q[indxq[indx[jlam]] * q_dim1 + 1], &c__1, &q[indxq[
            indx[j]] * q_dim1 + 1], &c__1, &c__, &s);  // Apply Givens rotation to Q matrix

        // Update eigenvalues after deflation
        t = d__[jlam] * c__ * c__ + d__[j] * s * s;
        d__[j] = d__[jlam] * s * s + d__[j] * c__ * c__;
        d__[jlam] = t;

        --k2;  // Decrement index for deflated eigenvalues
        i__ = 1;
L80:
        if (k2 + i__ <= *n) {
            if (d__[jlam] < d__[indxp[k2 + i__]]) {
                indxp[k2 + i__ - 1] = indxp[k2 + i__];  // Shift indices
                indxp[k2 + i__] = jlam;
                ++i__;  // Increment i__
                goto L80;  // Continue shifting if necessary
            } else {
                indxp[k2 + i__ - 1] = jlam;
            }
        } else {
            indxp[k2 + i__ - 1] = jlam;
        }
        jlam = j;  // Update jlam to current j
    } else {
        ++(*k);  // Increment count of found eigenvalues
        w[*k] = z__[jlam];  // Store jlam-th eigenvalue
        dlamda[*k] = d__[jlam];  // Store corresponding d value
        indxp[*k] = jlam;  // Store index of jlam-th eigenvalue
        jlam = j;  // Update jlam to current j
    }
}
goto L70;  // Repeat loop to continue checking for eigenvalues
L90:

/* Record the last eigenvalue. */

++(*k);  // Increment count of found eigenvalues
w[*k] = z__[jlam];  // Store last found eigenvalue
dlamda[*k] = d__[jlam];  // Store corresponding d value
indxp[*k] = jlam;  // Store index of last found eigenvalue

L100:

/*
   Sort the eigenvalues and corresponding eigenvectors into DLAMDA
   and Q2 respectively.  The eigenvalues/vectors which were not
   deflated go into the first K slots of DLAMDA and Q2 respectively,
   while those which were deflated go into the last N - K slots.
*/

// Sort eigenvalues and update corresponding arrays
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    jp = indxp[j];  // Get index from sorted indices
    dlamda[j] = d__[jp];  // Store eigenvalue
    perm[j] = indxq[indx[jp]];  // Store corresponding permutation index
}
    将数组 q 中 perm[j] 行的数据复制到数组 q2 的第 j 行
    zcopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1], &
        c__1);
/* L110: */
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

/* 检查是否需要复制精炼后的特征值和对应的特征向量 */

if (*k < *n) {
    /* 计算需要复制的元素个数 */
    i__1 = *n - *k;
    /* 复制 Dlamda 中的元素到 D 中 */
    dcopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
    /* 复制 Q2 中的子矩阵到 Q 中 */
    i__1 = *n - *k;
    zlacpy_("A", qsiz, &i__1, &q2[(*k + 1) * q2_dim1 + 1], ldq2, &q[(*k +
        1) * q_dim1 + 1], ldq);
}

/* 返回操作成功的标志 */
return 0;

/*     End of ZLAED8 */

} /* zlaed8_ */

/* Subroutine */ int zlahqr_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublecomplex *h__, integer *ldh,
    doublecomplex *w, integer *iloz, integer *ihiz, doublecomplex *z__,
    integer *ldz, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7;

    /* Local variables */
    static integer i__, j, k, l, m;
    static doublereal s;
    static doublecomplex t, u, v[2], x, y;
    static integer i1, i2;
    static doublecomplex t1;
    static doublereal t2;
    static doublecomplex v2;
    static doublereal aa, ab, ba, bb, h10;
    static doublecomplex h11;
    static doublereal h21;
    static doublecomplex h22, sc;
    static integer nh, nz;
    static doublereal sx;
    static integer jhi;
    static doublecomplex h11s;
    static integer jlo, its;
    static doublereal ulp;
    static doublecomplex sum;
    static doublereal tst;
    static doublecomplex temp;
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *);
    static doublereal rtemp;
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), dlabad_(doublereal *, doublereal *);

    static doublereal safmin, safmax;
    extern /* Subroutine */ int zlarfg_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *);
    extern /* Double Complex */ VOID zladiv_(doublecomplex *, doublecomplex *,
         doublecomplex *);
    static doublereal smlnum;

/*
*/


注释：


/* 检查是否需要复制精炼后的特征值和对应的特征向量 */

/* 如果要求保留的特征值数量少于总特征值数量 */
if (*k < *n) {
    /* 计算需要复制的元素个数 */
    i__1 = *n - *k;
    /* 复制 Dlamda 中的元素到 D 中 */
    dcopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
    /* 复制 Q2 中的子矩阵到 Q 中 */
    i__1 = *n - *k;
    zlacpy_("A", qsiz, &i__1, &q2[(*k + 1) * q2_dim1 + 1], ldq2, &q[(*k +
        1) * q_dim1 + 1], ldq);
}


这段代码的注释解释了对特征值和特征向量的操作，以及在特定条件下的复制动作。
/*     ==== ensure that subdiagonal entries are real ==== */

    /* 如果要求计算Schur分解（wantt为真），则设置矩阵的下标范围为1到n，否则使用输入的ilo和ihi */
    if (*wantt) {
        jlo = 1;
        jhi = *n;
    } else {
        jlo = *ilo;
        jhi = *ihi;
    }

    /* 循环遍历从ilo到ihi之间的所有行 */
    i__1 = *ihi;
    for (i__ = *ilo + 1; i__ <= i__1; ++i__) {

        /* 检查H矩阵中的(i, i-1)位置是否包含虚部 */
        if (d_imag(&h__[i__ + (i__ - 1) * h_dim1]) != 0.) {

/*
             ==== The following redundant normalization
             .    avoids problems with both gradual and
             .    sudden underflow in ABS(H(I,I-1)) ====

             下面的冗余归一化避免了ABS(H(I,I-1))中的逐渐和突然的下溢问题
*/
            i__2 = i__ + (i__ - 1) * h_dim1;
            i__3 = i__ + (i__ - 1) * h_dim1;
            d__3 = (d__1 = h__[i__3].r, abs(d__1)) + (d__2 = d_imag(&h__[i__
                + (i__ - 1) * h_dim1]), abs(d__2));
            z__1.r = h__[i__2].r / d__3, z__1.i = h__[i__2].i / d__3;
            sc.r = z__1.r, sc.i = z__1.i;

            /* 计算复共轭，并计算模 */
            d_cnjg(&z__2, &sc);
            d__1 = z_abs(&sc);
            z__1.r = z__2.r / d__1, z__1.i = z__2.i / d__1;
            sc.r = z__1.r, sc.i = z__1.i;

            /* 对H的(i, i-1)位置进行归一化处理，将虚部设为0 */
            i__2 = i__ + (i__ - 1) * h_dim1;
            d__1 = z_abs(&h__[i__ + (i__ - 1) * h_dim1]);
            h__[i__2].r = d__1, h__[i__2].i = 0.;

            /* 对H的(i, i)位置及其之后的元素进行变换，使用归一化的因子sc */
            i__2 = jhi - i__ + 1;
            zscal_(&i__2, &sc, &h__[i__ + i__ * h_dim1], ldh);

            /* 计算最小的行列下标范围 */
            i__2 = min(jhi,i__ + 1) - jlo + 1;

            /* 对H的第i行的一部分进行变换，使用sc的复共轭作为变换因子 */
            d_cnjg(&z__1, &sc);
            zscal_(&i__2, &z__1, &h__[jlo + i__ * h_dim1], &c__1);

            /* 如果要计算Schur向量，则对Z矩阵的列进行相同的变换 */
            if (*wantz) {
                i__2 = *ihiz - *iloz + 1;
                d_cnjg(&z__1, &sc);
                zscal_(&i__2, &z__1, &z__[*iloz + i__ * z_dim1], &c__1);
            }
        }
/* L20: */
    }

    /* 计算活动子矩阵的行数和列数 */
    nh = *ihi - *ilo + 1;
    nz = *ihiz - *iloz + 1;

/*     Set machine-dependent constants for the stopping criterion. */

    /* 设置机器相关的常量作为停止准则 */
    safmin = SAFEMINIMUM;
    safmax = 1. / safmin;
    dlabad_(&safmin, &safmax);
    ulp = PRECISION;
    smlnum = safmin * ((doublereal) nh / ulp);

/*
       I1 and I2 are the indices of the first row and last column of H
       to which transformations must be applied. If eigenvalues only are
       being computed, I1 and I2 are set inside the main loop.
*/

    /* 如果要计算Schur分解（wantt为真），则设置I1为1，I2为n */
    if (*wantt) {
        i1 = 1;
        i2 = *n;
    }

/*
       The main loop begins here. I is the loop index and decreases from
       IHI to ILO in steps of 1. Each iteration of the loop works
       with the active submatrix in rows and columns L to I.
       Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
       H(L,L-1) is negligible so that the matrix splits.
*/

    /* 主循环从IHI到ILO逐步进行Schur分解 */
    i__ = *ihi;
L30:
    if (i__ < *ilo) {
        goto L150;
    }

/*
       Perform QR iterations on rows and columns ILO to I until a
       submatrix of order 1 splits off at the bottom because a
       subdiagonal element has become negligible.
*/

    /* 在行列ILO到I上执行QR迭代，直到一个1阶子矩阵分离出来 */
    l = *ilo;
    for (its = 0; its <= 30; ++its) {

/*        Look for a single small subdiagonal element. */

        /* 寻找单个小的次对角元素 */
        i__1 = l + 1;
    // 从 i__ 开始向 i__1 反向遍历 k
    for (k = i__; k >= i__1; --k) {
        // 计算 h__ 中 k 行 k 列元素的实部的绝对值与虚部的绝对值之和，判断是否小于等于 smlnum
        i__2 = k + (k - 1) * h_dim1;
        if ((d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[k + (k
            - 1) * h_dim1]), abs(d__2)) <= smlnum) {
            // 如果满足条件，跳转到标签 L50 处
            goto L50;
        }
        // 计算 h__ 中 k-1 行 k-1 列元素的实部的绝对值与虚部的绝对值之和
        i__2 = k - 1 + (k - 1) * h_dim1;
        // 计算 h__ 中 k 行 k 列元素的实部的绝对值与虚部的绝对值之和，以及 h__ 中 k+1 行 k+1 列元素的实部的绝对值之和
        i__3 = k + k * h_dim1;
        tst = (d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[k - 1
            + (k - 1) * h_dim1]), abs(d__2)) + ((d__3 = h__[i__3].r,
            abs(d__3)) + (d__4 = d_imag(&h__[k + k * h_dim1]), abs(
            d__4)));
        // 如果 tst 等于 0
        if (tst == 0.) {
            // 如果 k-2 大于等于 *ilo
            if (k - 2 >= *ilo) {
                // 将 h__ 中 k-1 行 k-2 列元素的实部的绝对值添加到 tst 中
                i__2 = k - 1 + (k - 2) * h_dim1;
                tst += (d__1 = h__[i__2].r, abs(d__1));
            }
            // 如果 k+1 小于等于 *ihi
            if (k + 1 <= *ihi) {
                // 将 h__ 中 k+1 行 k 列元素的实部的绝对值添加到 tst 中
                i__2 = k + 1 + k * h_dim1;
                tst += (d__1 = h__[i__2].r, abs(d__1));
            }
        }
    }
/*
             ==== The following is a conservative small subdiagonal
             .    deflation criterion due to Ahues & Tisseur (LAWN 122,
             .    1997). It has better mathematical foundation and
             .    improves accuracy in some examples.  ====
*/
        i__2 = k + (k - 1) * h_dim1;
        // 检查 h__(k, k-1) 是否足够小，用于判断是否进行子对角线缩减
        if ((d__1 = h__[i__2].r, abs(d__1)) <= ulp * tst) {
/* Computing MAX */
        i__2 = k + (k - 1) * h_dim1;
        i__3 = k - 1 + k * h_dim1;
        // 计算 ab，用于后续的比较
        d__5 = (d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[
            k + (k - 1) * h_dim1]), abs(d__2)), d__6 = (d__3 =
            h__[i__3].r, abs(d__3)) + (d__4 = d_imag(&h__[k - 1 +
            k * h_dim1]), abs(d__4));
        ab = max(d__5,d__6);
/* Computing MIN */
        i__2 = k + (k - 1) * h_dim1;
        i__3 = k - 1 + k * h_dim1;
        // 计算 ba，用于后续的比较
        d__5 = (d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[
            k + (k - 1) * h_dim1]), abs(d__2)), d__6 = (d__3 =
            h__[i__3].r, abs(d__3)) + (d__4 = d_imag(&h__[k - 1 +
            k * h_dim1]), abs(d__4));
        ba = min(d__5,d__6);
        i__2 = k - 1 + (k - 1) * h_dim1;
        i__3 = k + k * h_dim1;
        // 计算 aa，用于后续的比较
        z__2.r = h__[i__2].r - h__[i__3].r, z__2.i = h__[i__2].i -
            h__[i__3].i;
        z__1.r = z__2.r, z__1.i = z__2.i;
/* Computing MAX */
        i__4 = k + k * h_dim1;
        // 计算 aa 的绝对值和与 h__(k-1, k) 的差的绝对值的和，用于后续的比较
        d__5 = (d__1 = h__[i__4].r, abs(d__1)) + (d__2 = d_imag(&h__[
            k + k * h_dim1]), abs(d__2)), d__6 = (d__3 = z__1.r,
            abs(d__3)) + (d__4 = d_imag(&z__1), abs(d__4));
        aa = max(d__5,d__6);
        i__2 = k - 1 + (k - 1) * h_dim1;
        i__3 = k + k * h_dim1;
        // 计算 bb，用于后续的比较
        z__2.r = h__[i__2].r - h__[i__3].r, z__2.i = h__[i__2].i -
            h__[i__3].i;
        z__1.r = z__2.r, z__1.i = z__2.i;
/* Computing MIN */
        i__4 = k + k * h_dim1;
        // 计算 bb 的绝对值和与 h__(k-1, k) 的差的绝对值的和，用于后续的比较
        d__5 = (d__1 = h__[i__4].r, abs(d__1)) + (d__2 = d_imag(&h__[
            k + k * h_dim1]), abs(d__2)), d__6 = (d__3 = z__1.r,
            abs(d__3)) + (d__4 = d_imag(&z__1), abs(d__4));
        bb = min(d__5,d__6);
        s = aa + ab;
/* Computing MAX */
        // 计算 s 与 smlnum 和 ulp * (bb * (aa / s)) 的最大值，用于后续的比较
        d__1 = smlnum, d__2 = ulp * (bb * (aa / s));
        if (ba * (ab / s) <= max(d__1,d__2)) {
            goto L50;
        }
        }
/* L40: */
    }
L50:
    l = k;
    if (l > *ilo) {

/*           H(L,L-1) is negligible */

        i__1 = l + (l - 1) * h_dim1;
        // 将 H(L,L-1) 设置为零，因为它被视为可以忽略的小量
        h__[i__1].r = 0., h__[i__1].i = 0.;
    }

/*        Exit from loop if a submatrix of order 1 has split off. */

    if (l >= i__) {
        // 如果分离出了一个1阶子矩阵，则退出循环
        goto L140;
    }

/*
          Now the active submatrix is in rows and columns L to I. If
          eigenvalues only are being computed, only the active submatrix
          need be transformed.
*/

    if (! (*wantt)) {
        // 如果只计算特征值，则只需转换活动子矩阵
        i1 = l;
        i2 = i__;
    }

    if (its == 10) {
/*           Exceptional shift. */

/* 计算要使用的特殊移位值。 */
        i__1 = l + 1 + l * h_dim1;
/* 获取对角线上第l+1个元素的索引。 */
        s = (d__1 = h__[i__1].r, abs(d__1)) * .75;
/* 计算绝对值并乘以0.75，得到移位所需的值s。 */
        i__1 = l + l * h_dim1;
/* 获取对角线上第l个元素的索引。 */
        z__1.r = s + h__[i__1].r, z__1.i = h__[i__1].i;
/* 计算新的对角线上第l个元素t，加上s的结果。 */
        t.r = z__1.r, t.i = z__1.i;
/* 将计算得到的结果存入t。 */
    } else if (its == 20) {

/*           Exceptional shift. */

/* 计算要使用的特殊移位值。 */
        i__1 = i__ + (i__ - 1) * h_dim1;
/* 获取对角线上第(i,i-1)个元素的索引。 */
        s = (d__1 = h__[i__1].r, abs(d__1)) * .75;
/* 计算绝对值并乘以0.75，得到移位所需的值s。 */
        i__1 = i__ + i__ * h_dim1;
/* 获取对角线上第i个元素的索引。 */
        z__1.r = s + h__[i__1].r, z__1.i = h__[i__1].i;
/* 计算新的对角线上第i个元素t，加上s的结果。 */
        t.r = z__1.r, t.i = z__1.i;
/* 将计算得到的结果存入t。 */
    } else {

/*           Wilkinson's shift. */

/* 使用Wilkinson移位方法计算t的值。 */
        i__1 = i__ + i__ * h_dim1;
/* 获取对角线上第(i,i)个元素的索引。 */
        t.r = h__[i__1].r, t.i = h__[i__1].i;
/* 将对角线上第(i,i)的元素值赋给t。 */
        z_sqrt(&z__2, &h__[i__ - 1 + i__ * h_dim1]);
/* 计算并存储第(i-1,i)元素的平方根值。 */
        z_sqrt(&z__3, &h__[i__ + (i__ - 1) * h_dim1]);
/* 计算并存储第(i,i-1)元素的平方根值。 */
        z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r *
            z__3.i + z__2.i * z__3.r;
/* 计算两个平方根元素的乘积。 */
        u.r = z__1.r, u.i = z__1.i;
/* 将计算得到的结果存入u。 */
        s = (d__1 = u.r, abs(d__1)) + (d__2 = d_imag(&u), abs(d__2));
/* 计算u的绝对值的和。 */
        if (s != 0.) {
/* 如果s不等于0，则执行以下操作。 */
        i__1 = i__ - 1 + (i__ - 1) * h_dim1;
/* 获取对角线上第(i-1,i-1)个元素的索引。 */
        z__2.r = h__[i__1].r - t.r, z__2.i = h__[i__1].i - t.i;
/* 计算t和(i-1,i-1)元素之差的一半。 */
        z__1.r = z__2.r * .5, z__1.i = z__2.i * .5;
/* 将计算得到的结果存入x。 */
        x.r = z__1.r, x.i = z__1.i;
/* 计算x的绝对值的和。 */
        sx = (d__1 = x.r, abs(d__1)) + (d__2 = d_imag(&x), abs(d__2));
/* 计算x的绝对值的和。 */
/* Computing MAX */
        d__3 = s, d__4 = (d__1 = x.r, abs(d__1)) + (d__2 = d_imag(&x),
             abs(d__2));
/* 将最大值存入s。 */
        s = max(d__3,d__4);
/* 计算u和x的绝对值的和的最大值。 */
        z__5.r = x.r / s, z__5.i = x.i / s;
/* 计算x/s的值并存入z__5。 */
        pow_zi(&z__4, &z__5, &c__2);
/* 计算x/s的2次方并存入z__4。 */
        z__7.r = u.r / s, z__7.i = u.i / s;
/* 计算u/s的值并存入z__7。 */
        pow_zi(&z__6, &z__7, &c__2);
/* 计算u/s的2次方并存入z__6。 */
        z__3.r = z__4.r + z__6.r, z__3.i = z__4.i + z__6.i;
/* 计算z__4和z__6的和并存入z__3。 */
        z_sqrt(&z__2, &z__3);
/* 计算z__3的平方根并存入z__2。 */
        z__1.r = s * z__2.r, z__1.i = s * z__2.i;
/* 计算s*z__2的值并存入y。 */
        y.r = z__1.r, y.i = z__1.i;
/* 将计算得到的结果存入y。 */
        if (sx > 0.) {
/* 如果sx大于0，则执行以下操作。 */
            z__1.r = x.r / sx, z__1.i = x.i / sx;
/* 计算x/sx的值并存入z__1。 */
            z__2.r = x.r / sx, z__2.i = x.i / sx;
/* 计算x/sx的值并存入z__2。 */
            if (z__1.r * y.r + d_imag(&z__2) * d_imag(&y) < 0.) {
/* 如果z__1的实部乘以y的实部加上z__2的虚部乘以y的虚部小于0，则执行以下操作。 */
            z__3.r = -y.r, z__3.i = -y.i;
/* 将-y的值存入z__3。 */
            y.r = z__3.r, y.i = z__3.i;
/* 将计算得到的结果存入y。 */
            }
        }
/* 计算u和y的和的值并存入z__4。 */
        z__4.r = x.r + y.r, z__4.i = x.i + y.i;
/* 将计算得到的结果存入zladiv。 */
        zladiv_(&z__3, &u, &z__4);
/* 将计算得到的结果存入z__3。 */
        z__2.r = u.r * z__3.r - u.i * z__3.i, z__2.i = u.r * z__3.i +
            u.i * z__3.r;
/* 计算u和z__3的差的值并存入z__2。 */
        z__1.r = t.r - z__2.r, z__1.i = t.i - z__2.i;
/* 计算t和z__2的差的值并存入z__1。 */
        t.r = z__1.r, t.i = z__1.i;
/* 将计算得到的结果存入t。 */
        }
    }

/*        Look for two consecutive small subdiagonal elements. */

/* 寻找两个连续的小的次对角元素。 */
    i__1 = l + 1;
/* 设置循环的起始位置。 */
    for (m = i__ - 1; m >= i__1; --m) {
/* 从大到小遍历m的值。 */
        i__2 = m + m * h_dim1;
        h11.r = h__[i__2].r, h11.i = h__[i__2].i;
        i__2 = m + 1 + (m + 1) * h_dim1;
        h22.r = h__[i__2].r, h22.i = h__[i__2].i;
        z__1.r = h11.r - t.r, z__1.i = h11.i - t.i;
        h11s.r = z__1.r, h11s.i = z__1.i;
        i__2 = m + 1 + m * h_dim1;
        h21 = h__[i__2].r;
        s = (d__1 = h11s.r, abs(d__1)) + (d__2 = d_imag(&h11s), abs(d__2))
             + abs(h21);
        z__1.r = h11s.r / s, z__1.i = h11s.i / s;
        h11s.r = z__1.r, h11s.i = z__1.i;
        h21 /= s;
        v[0].r = h11s.r, v[0].i = h11s.i;
        v[1].r = h21, v[1].i = 0.;
        i__2 = m + (m - 1) * h_dim1;
        h10 = h__[i__2].r;
        if (abs(h10) * abs(h21) <= ulp * (((d__1 = h11s.r, abs(d__1)) + (
            d__2 = d_imag(&h11s), abs(d__2))) * ((d__3 = h11.r, abs(
            d__3)) + (d__4 = d_imag(&h11), abs(d__4)) + ((d__5 =
            h22.r, abs(d__5)) + (d__6 = d_imag(&h22), abs(d__6)))))) {
        goto L70;
        }


        i__1 = l + l * h_dim1;
        h11.r = h__[i__1].r, h11.i = h__[i__1].i;
        i__1 = l + 1 + (l + 1) * h_dim1;
        h22.r = h__[i__1].r, h22.i = h__[i__1].i;
        z__1.r = h11.r - t.r, z__1.i = h11.i - t.i;
        h11s.r = z__1.r, h11s.i = z__1.i;
        i__1 = l + 1 + l * h_dim1;
        h21 = h__[i__1].r;
        s = (d__1 = h11s.r, abs(d__1)) + (d__2 = d_imag(&h11s), abs(d__2)) +
            abs(h21);
        z__1.r = h11s.r / s, z__1.i = h11s.i / s;
        h11s.r = z__1.r, h11s.i = z__1.i;
        h21 /= s;
        v[0].r = h11s.r, v[0].i = h11s.i;
        v[1].r = h21, v[1].i = 0.;
L70:


/*        Single-shift QR step */

    i__1 = i__ - 1;
    for (k = m; k <= i__1; ++k) {

/*
             The first iteration of this loop determines a reflection G
             from the vector V and applies it from left and right to H,
             thus creating a nonzero bulge below the subdiagonal.

             Each subsequent iteration determines a reflection G to
             restore the Hessenberg form in the (K-1)th column, and thus
             chases the bulge one step toward the bottom of the active
             submatrix.

             V(2) is always real before the call to ZLARFG, and hence
             after the call T2 ( = T1*V(2) ) is also real.
*/

        if (k > m) {
        zcopy_(&c__2, &h__[k + (k - 1) * h_dim1], &c__1, v, &c__1);
        }
        zlarfg_(&c__2, v, &v[1], &c__1, &t1);
        if (k > m) {
        i__2 = k + (k - 1) * h_dim1;
        h__[i__2].r = v[0].r, h__[i__2].i = v[0].i;
        i__2 = k + 1 + (k - 1) * h_dim1;
        h__[i__2].r = 0., h__[i__2].i = 0.;
        }
        v2.r = v[1].r, v2.i = v[1].i;
        z__1.r = t1.r * v2.r - t1.i * v2.i, z__1.i = t1.r * v2.i + t1.i *
            v2.r;
        t2 = z__1.r;
        i__2 = i2;
        // 循环：从 k 到 i2，处理每一个 j
        for (j = k; j <= i__2; ++j) {
        // 计算 t1 的共轭
        d_cnjg(&z__3, &t1);
        // 计算 h[k+j*h_dim1] 和 h[k+1+j*h_dim1] 的线性组合并赋给 sum
        i__3 = k + j * h_dim1;
        z__2.r = z__3.r * h__[i__3].r - z__3.i * h__[i__3].i, z__2.i =
             z__3.r * h__[i__3].i + z__3.i * h__[i__3].r;
        i__4 = k + 1 + j * h_dim1;
        z__4.r = t2 * h__[i__4].r, z__4.i = t2 * h__[i__4].i;
        z__1.r = z__2.r + z__4.r, z__1.i = z__2.i + z__4.i;
        sum.r = z__1.r, sum.i = z__1.i;
        // 更新 h[k+j*h_dim1]
        i__3 = k + j * h_dim1;
        i__4 = k + j * h_dim1;
        z__1.r = h__[i__4].r - sum.r, z__1.i = h__[i__4].i - sum.i;
        h__[i__3].r = z__1.r, h__[i__3].i = z__1.i;
        // 更新 h[k+1+j*h_dim1]
        i__3 = k + 1 + j * h_dim1;
        i__4 = k + 1 + j * h_dim1;
        z__2.r = sum.r * v2.r - sum.i * v2.i, z__2.i = sum.r * v2.i +
            sum.i * v2.r;
        z__1.r = h__[i__4].r - z__2.r, z__1.i = h__[i__4].i - z__2.i;
        h__[i__3].r = z__1.r, h__[i__3].i = z__1.i;
/* L80: */
        }

/*
             对矩阵的行 I1 到 min(K+2,I) 应用 G 从右边转换列

   Computing MIN
*/
        // 计算要处理的列数，不超过 K+2 和 I 的较小值
        i__3 = k + 2;
        i__2 = min(i__3,i__);
        // 循环：从 i1 到计算出的列数，处理每一个 j
        for (j = i1; j <= i__2; ++j) {
        // 计算 h[j+k*h_dim1] 和 h[j+(k+1)*h_dim1] 的线性组合并赋给 sum
        i__3 = j + k * h_dim1;
        z__2.r = t1.r * h__[i__3].r - t1.i * h__[i__3].i, z__2.i =
            t1.r * h__[i__3].i + t1.i * h__[i__3].r;
        i__4 = j + (k + 1) * h_dim1;
        z__3.r = t2 * h__[i__4].r, z__3.i = t2 * h__[i__4].i;
        z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
        sum.r = z__1.r, sum.i = z__1.i;
        // 更新 h[j+k*h_dim1]
        i__3 = j + k * h_dim1;
        i__4 = j + k * h_dim1;
        z__1.r = h__[i__4].r - sum.r, z__1.i = h__[i__4].i - sum.i;
        h__[i__3].r = z__1.r, h__[i__3].i = z__1.i;
        // 更新 h[j+(k+1)*h_dim1]
        i__3 = j + (k + 1) * h_dim1;
        i__4 = j + (k + 1) * h_dim1;
        d_cnjg(&z__3, &v2);
        z__2.r = sum.r * z__3.r - sum.i * z__3.i, z__2.i = sum.r *
            z__3.i + sum.i * z__3.r;
        z__1.r = h__[i__4].r - z__2.r, z__1.i = h__[i__4].i - z__2.i;
        h__[i__3].r = z__1.r, h__[i__3].i = z__1.i;
/* L90: */
        }

        // 如果需要计算特征向量（wantz 为真）
        if (*wantz) {
/* 累积变换到矩阵 Z 中 */

i__2 = *ihiz;
for (j = *iloz; j <= i__2; ++j) {
    // 计算 Z[j, k] 和 Z[j, k+1] 的线性组合，存储在 sum 中
    i__3 = j + k * z_dim1;
    z__2.r = t1.r * z__[i__3].r - t1.i * z__[i__3].i, z__2.i =
         t1.r * z__[i__3].i + t1.i * z__[i__3].r;
    i__4 = j + (k + 1) * z_dim1;
    z__3.r = t2 * z__[i__4].r, z__3.i = t2 * z__[i__4].i;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    sum.r = z__1.r, sum.i = z__1.i;

    // 更新 Z[j, k] = Z[j, k] - sum 和 Z[j, k+1] = Z[j, k+1] - conj(v2) * sum
    i__3 = j + k * z_dim1;
    i__4 = j + k * z_dim1;
    z__1.r = z__[i__4].r - sum.r, z__1.i = z__[i__4].i - sum.i;
    z__[i__3].r = z__1.r, z__[i__3].i = z__1.i;
    i__3 = j + (k + 1) * z_dim1;
    i__4 = j + (k + 1) * z_dim1;
    d_cnjg(&z__3, &v2);
    z__2.r = sum.r * z__3.r - sum.i * z__3.i, z__2.i = sum.r * z__3.i + sum.i * z__3.r;
    z__1.r = z__[i__4].r - z__2.r, z__1.i = z__[i__4].i - z__2.i;
    z__[i__3].r = z__1.r, z__[i__3].i = z__1.i;
/* L100: */
}

// 如果 k == m 且 m > l，则需要额外的缩放以确保 H(m, m-1) 保持为实数
if (k == m && m > l) {
    /*
        如果 QR 步骤从行 M > L 开始，因为发现了两个连续的小的次对角线元素，
        则必须执行额外的缩放以确保 H(M, M-1) 保持为实数。
    */
    z__1.r = 1. - t1.r, z__1.i = 0. - t1.i;
    temp.r = z__1.r, temp.i = z__1.i;
    d__1 = z_abs(&temp);
    z__1.r = temp.r / d__1, z__1.i = temp.i / d__1;
    temp.r = z__1.r, temp.i = z__1.i;

    // 更新 H(m+1, m) = H(m+1, m) * conj(temp)
    i__2 = m + 1 + m * h_dim1;
    i__3 = m + 1 + m * h_dim1;
    d_cnjg(&z__2, &temp);
    z__1.r = h__[i__3].r * z__2.r - h__[i__3].i * z__2.i, z__1.i = h__[i__3].r * z__2.i + h__[i__3].i * z__2.r;
    h__[i__2].r = z__1.r, h__[i__2].i = z__1.i;

    // 如果 m+2 <= i__，则更新 H(m+2, m+1) = H(m+2, m+1) * temp
    if (m + 2 <= i__) {
        i__2 = m + 2 + (m + 1) * h_dim1;
        i__3 = m + 2 + (m + 1) * h_dim1;
        z__1.r = h__[i__3].r * temp.r - h__[i__3].i * temp.i, z__1.i = h__[i__3].r * temp.i + h__[i__3].i * temp.r;
        h__[i__2].r = z__1.r, h__[i__2].i = z__1.i;
    }

    // 对于 j 从 m 到 i__，更新相应的行和列
    i__2 = i__;
    for (j = m; j <= i__2; ++j) {
        if (j != m + 1) {
            if (i2 > j) {
                i__3 = i2 - j;
                // 对 H[j, j+1] 的 i3 列应用缩放因子 temp
                zscal_(&i__3, &temp, &h__[j + (j + 1) * h_dim1], ldh);
            }
            i__3 = j - i1;
            d_cnjg(&z__1, &temp);
            // 对 H[i1, j] 的 j 列应用缩放因子 conj(temp)
            zscal_(&i__3, &z__1, &h__[i1 + j * h_dim1], &c__1);
            if (*wantz) {
                // 如果需要计算 Z 矩阵，对 Z[iloz, j] 的 nz 列应用缩放因子 conj(temp)
                d_cnjg(&z__1, &temp);
                zscal_(&nz, &z__1, &z__[*iloz + j * z_dim1], &c__1);
            }
        }
/* L110: */
    }
}

/* L120: */
}

/* 确保 H(i, i-1) 是实数 */

i__1 = i__ + (i__ - 1) * h_dim1;
temp.r = h__[i__1].r, temp.i = h__[i__1].i;
    # 如果临时复数的虚部不为零，则执行以下操作
    if (d_imag(&temp) != 0.) {
        # 计算临时复数的模长
        rtemp = z_abs(&temp);
        # 将模长存入哈密尔顿矩阵的特定位置，并将虚部设为零
        i__1 = i__ + (i__ - 1) * h_dim1;
        h__[i__1].r = rtemp, h__[i__1].i = 0.;
        # 将临时复数除以其模长，更新临时复数
        z__1.r = temp.r / rtemp, z__1.i = temp.i / rtemp;
        temp.r = z__1.r, temp.i = z__1.i;
        # 如果 i2 大于当前索引 i__，则执行以下操作
        if (i2 > i__) {
            # 计算共轭复数，用于下面的缩放操作
            d_cnjg(&z__1, &temp);
            # 对哈密尔顿矩阵的特定列进行复数缩放
            zscal_(&i2 - i__, &z__1, &h__[i__ + (i__ + 1) * h_dim1], ldh);
        }
        # 计算 i__ - i1 的值，用于下面的缩放操作
        i__1 = i__ - i1;
        # 对哈密尔顿矩阵的特定行进行复数缩放
        zscal_(&i__1, &temp, &h__[i1 + i__ * h_dim1], &c__1);
        # 如果 *wantz 为真，则对特定列的 Z 矩阵进行复数缩放
        if (*wantz) {
            zscal_(&nz, &temp, &z__[*iloz + i__ * z_dim1], &c__1);
        }
    }
/* L130: */
    }

/*     Failure to converge in remaining number of iterations */

    *info = i__;
    return 0;

L140:

/*     H(I,I-1) is negligible: one eigenvalue has converged. */

    i__1 = i__;
    i__2 = i__ + i__ * h_dim1;
    w[i__1].r = h__[i__2].r, w[i__1].i = h__[i__2].i;

/*     return to start of the main loop with new value of I. */

    i__ = l - 1;
    goto L30;

L150:
    return 0;

/*     End of ZLAHQR */

} /* zlahqr_ */

/* Subroutine */ int zlahr2_(integer *n, integer *k, integer *nb,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *t,
    integer *ldt, doublecomplex *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublecomplex ei;
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *), zgemm_(char *, char *, integer *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer *,
         doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *), zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *),
        zcopy_(integer *, doublecomplex *, integer *, doublecomplex *,
        integer *), ztrmm_(char *, char *, char *, char *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *),
        zaxpy_(integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *), ztrmv_(char *, char *, char *,
        integer *, doublecomplex *, integer *, doublecomplex *, integer *), zlarfg_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *), zlacgv_(integer *,
        doublecomplex *, integer *), zlacpy_(char *, integer *, integer *,
         doublecomplex *, integer *, doublecomplex *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --


    Purpose
    =======

    ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
    matrix A so that elements below the k-th subdiagonal are zero. The
    reduction is performed by an unitary similarity transformation
    Q' * A * Q. The routine returns the matrices V and T which determine
    Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.

    This is an auxiliary routine called by ZGEHRD.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.

    K       (input) INTEGER
            The offset for the reduction.

    NB      (input) INTEGER
            The number of columns to be reduced.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal
            are overwritten with the corresponding elements of the
            reduced matrix; the elements below the k-th subdiagonal,
            with the array TAU, represent the matrix Q as a product of
            elementary reflectors.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,N).

    TAU     (output) COMPLEX*16 array, dimension (NB)
            The scalar factors of the elementary reflectors.

    T       (output) COMPLEX*16 array, dimension (LDT,NB)
            The upper triangular matrix T.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= NB.

    Y       (output) COMPLEX*16 array, dimension (LDY,NB)
            The n-by-nb matrix Y.

    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= N.
*/
    K       (input) INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K < N.
    NB      (input) INTEGER
            The number of columns to be reduced.
    A       (input/output) COMPLEX*16 array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    TAU     (output) COMPLEX*16 array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.
    T       (output) COMPLEX*16 array, dimension (LDT,NB)
            The upper triangular matrix T.
    LDT     (input) INTEGER
            The leading dimension of the array T.  LDT >= NB.
    Y       (output) COMPLEX*16 array, dimension (LDY,NB)
            The n-by-nb matrix Y.
    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= N.
    Further Details
    ===============

    The matrix Q is represented as a product of nb elementary reflectors
       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form
       H(i) = I - tau * v * v'
    where tau is a complex scalar, and v is a complex vector with
    v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
    A(i+k+1:n,i), and tau in TAU(i).

    The elements of the vectors v together form the (n-k+1)-by-nb matrix
    V which is needed, with T and Y, to apply the transformation to the
    unreduced part of the matrix, using an update of the form:
    A := (I - V*T*V') * (A - Y*V').

    The contents of A on exit are illustrated by the following example
    with n = 7, k = 3 and nb = 2:

       ( a   a   a   a   a )
       ( a   a   a   a   a )
       ( a   a   a   a   a )
       ( h   h   a   a   a )
       ( v1  h   a   a   a )
       ( v1  v2  a   a   a )
       ( v1  v2  a   a   a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This subroutine is a slight modification of LAPACK-3.0's DLAHRD
    incorporating improvements proposed by Quintana-Orti and Van de
    Gejin. Note that the entries of A(1:K,2:NB) differ from those
    returned by the original LAPACK-3.0's DLAHRD routine. (This
    subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)

    References
    ==========

    Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
    performance of reduction to Hessenberg form," ACM Transactions on
    Mathematical Software, 32(2):180-194, June 2006.

    =====================================================================


       Quick return if possible


    # 这部分是注释文档或者引用说明的开始部分，提到了一个与代码无关的文献引用。

    # 这是一个分隔线，通常用来分隔文档的不同部分或章节。

    # 下面是一个注释，表示此处代码的快速返回，如果条件允许的话，可能会立即结束函数的执行。
    /* 参数调整 */
    --tau;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    y_dim1 = *ldy;
    y_offset = 1 + y_dim1;
    y -= y_offset;

    /* 函数体 */
    if (*n <= 1) {
        return 0;
    }

    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (i__ > 1) {

            /* 更新 A(K+1:N,I) */

            i__2 = i__ - 1;
            zlacgv_(&i__2, &a[*k + i__ - 1 + a_dim1], lda);
            i__2 = *n - *k;
            i__3 = i__ - 1;
            z__1.r = -1., z__1.i = -0.;
            zgemv_("NO TRANSPOSE", &i__2, &i__3, &z__1, &y[*k + 1 + y_dim1],
                ldy, &a[*k + i__ - 1 + a_dim1], lda, &c_b57, &a[*k + 1 +
                i__ * a_dim1], &c__1);
            i__2 = i__ - 1;
            zlacgv_(&i__2, &a[*k + i__ - 1 + a_dim1], lda);

            /* 应用 I - V * T' * V' 到 A 的第 I 列 */

            i__2 = i__ - 1;
            zcopy_(&i__2, &a[*k + 1 + i__ * a_dim1], &c__1, &t[*nb * t_dim1 +
                1], &c__1);
            i__2 = i__ - 1;
            ztrmv_("Lower", "Conjugate transpose", "UNIT", &i__2, &a[*k + 1 +
                a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);

            /* w := w + V2'*b2 */

            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[*k + i__ +
                a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b57,
                &t[*nb * t_dim1 + 1], &c__1);

            /* w := T'*w */

            i__2 = i__ - 1;
            ztrmv_("Upper", "Conjugate transpose", "NON-UNIT", &i__2, &t[
                t_offset], ldt, &t[*nb * t_dim1 + 1], &c__1);

            /* b2 := b2 - V2*w */

            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            z__1.r = -1., z__1.i = -0.;
            zgemv_("NO TRANSPOSE", &i__2, &i__3, &z__1, &a[*k + i__ + a_dim1],
                 lda, &t[*nb * t_dim1 + 1], &c__1, &c_b57, &a[*k + i__ +
                i__ * a_dim1], &c__1);

            /* b1 := b1 - V1*w */

            i__2 = i__ - 1;
            ztrmv_("Lower", "NO TRANSPOSE", "UNIT", &i__2, &a[*k + 1 + a_dim1]
                , lda, &t[*nb * t_dim1 + 1], &c__1);
            i__2 = i__ - 1;
            z__1.r = -1., z__1.i = -0.;
            zaxpy_(&i__2, &z__1, &t[*nb * t_dim1 + 1], &c__1, &a[*k + 1 + i__
                * a_dim1], &c__1);

            /* 将 ei 赋值给 A(K+I-1, I-1) */

            i__2 = *k + i__ - 1 + (i__ - 1) * a_dim1;
            a[i__2].r = ei.r, a[i__2].i = ei.i;
        }

        /* 生成第 I 个元素的 Householder 变换，使得 A(K+I+1:N,I) 变成零 */

        i__2 = *n - *k - i__ + 1;
        /* 计算下限 */
        /* k+i+1 和 n 之间的最小值 */
        i__3 = *k + i__ + 1;
        zlarfg_(&i__2, &a[*k + i__ + i__ * a_dim1], &a[min(i__3,*n) + i__ *
            a_dim1], &c__1, &tau[i__]);
    }
    # 计算矩阵元素在一维数组中的索引
    i__2 = *k + i__ + i__ * a_dim1;
    # 获取矩阵元素的实部和虚部，并赋给复数结构体 ei
    ei.r = a[i__2].r, ei.i = a[i__2].i;
    # 将矩阵元素设为复数单位矩阵中的对应元素 (1, 0)
    i__2 = *k + i__ + i__ * a_dim1;
    a[i__2].r = 1., a[i__2].i = 0.;
/*        Compute  Y(K+1:N,I) */

    // 计算 Y(K+1:N,I) 向量的长度
    i__2 = *n - *k;
    // 计算 Y(K+1:N,I) 的元素个数
    i__3 = *n - *k - i__ + 1;
    // 调用 BLAS 函数 zgemv 计算 Y(K+1:N,I)，这里是一个矩阵-向量乘法
    zgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b57, &a[*k + 1 + (i__ + 1) *
        a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b56, &y[*
        k + 1 + i__ * y_dim1], &c__1);
    // 计算 T(1:I-1, I) 的长度
    i__2 = *n - *k - i__ + 1;
    // 计算 T(1:I-1, I) 的宽度
    i__3 = i__ - 1;
    // 调用 BLAS 函数 zgemv 计算 T(1:I-1, I)，这里是一个矩阵-向量乘法
    zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[*k + i__ +
        a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b56, &t[
        i__ * t_dim1 + 1], &c__1);
    // 计算 Y(K+1:N,I) 和 T(1:I-1, I) 的乘积并更新 Y(K+1:N,I)
    i__2 = *n - *k;
    i__3 = i__ - 1;
    z__1.r = -1., z__1.i = -0.;
    // 调用 BLAS 函数 zgemv 计算 Y(K+1:N,I) - T(1:I-1, I) * T(1:I-1, I)^H
    zgemv_("NO TRANSPOSE", &i__2, &i__3, &z__1, &y[*k + 1 + y_dim1], ldy,
        &t[i__ * t_dim1 + 1], &c__1, &c_b57, &y[*k + 1 + i__ * y_dim1]
        , &c__1);
    // 对 Y(K+1:N,I) 进行缩放
    i__2 = *n - *k;
    zscal_(&i__2, &tau[i__], &y[*k + 1 + i__ * y_dim1], &c__1);

/*        Compute T(1:I,I) */

    // 计算 T(1:I-1,I) 中元素的缩放
    i__2 = i__ - 1;
    i__3 = i__;
    z__1.r = -tau[i__3].r, z__1.i = -tau[i__3].i;
    zscal_(&i__2, &z__1, &t[i__ * t_dim1 + 1], &c__1);
    // 对 T(1:I-1,I) 进行上三角矩阵乘法
    i__2 = i__ - 1;
    ztrmv_("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
        &t[i__ * t_dim1 + 1], &c__1)
        ;
    // 将 tau[i__] 的值复制到 T(I,I) 上
    i__2 = i__ + i__ * t_dim1;
    i__3 = i__;
    t[i__2].r = tau[i__3].r, t[i__2].i = tau[i__3].i;

/* L10: */
    }
    // 将 ei 的值赋给 A(K+NB+NB,A_DIM1)
    i__1 = *k + *nb + *nb * a_dim1;
    a[i__1].r = ei.r, a[i__1].i = ei.i;

/*     Compute Y(1:K,1:NB) */

    // 复制 A 中的部分数据到 Y
    zlacpy_("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
    // 对 Y 进行左下三角矩阵乘法
    ztrmm_("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b57, &a[*k + 1
        + a_dim1], lda, &y[y_offset], ldy);
    // 如果 n > k + nb，则对 Y 进行矩阵乘法
    if (*n > *k + *nb) {
    i__1 = *n - *k - *nb;
    zgemm_("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b57, &a[(*nb
        + 2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &
        c_b57, &y[y_offset], ldy);
    }
    // 对 Y 进行右上三角矩阵乘法
    ztrmm_("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b57, &t[
        t_offset], ldt, &y[y_offset], ldy);

    // 返回成功标志
    return 0;

/*     End of ZLAHR2 */

} /* zlahr2_ */

/* Subroutine */ int zlals0_(integer *icompq, integer *nl, integer *nr,
    integer *sqre, integer *nrhs, doublecomplex *b, integer *ldb,
    doublecomplex *bx, integer *ldbx, integer *perm, integer *givptr,
    integer *givcol, integer *ldgcol, doublereal *givnum, integer *ldgnum,
     doublereal *poles, doublereal *difl, doublereal *difr, doublereal *
    z__, integer *k, doublereal *c__, doublereal *s, doublereal *rwork,
    integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, difr_dim1, difr_offset, givnum_dim1,
        givnum_offset, poles_dim1, poles_offset, b_dim1, b_offset,
        bx_dim1, bx_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, m, n;
    static doublereal dj;
    static integer nlp1, jcol;
    static doublereal temp;
    static integer jrow;
    extern doublereal dnrm2_(integer *, doublereal *, integer *);
    static doublereal diflj, difrj, dsigj;


注释结束
    # 声明外部的双精度复数向量乘法子程序 dgemv_
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *);

    # 声明外部的复双精度旋转子程序 zdrot_
    extern /* Subroutine */ int zdrot_(integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublereal *, doublereal *);

    # 声明静态的双精度数 dsigjp
    static doublereal dsigjp;

    # 声明外部的双精度数处理子程序 dlamc3_
    extern doublereal dlamc3_(doublereal *, doublereal *);

    # 声明外部的复数复制子程序 zcopy_
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    # 声明外部的异常处理子程序 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明外部的复双精度向量缩放子程序 zdscal_
    extern /* Subroutine */ int zdscal_(integer *, doublereal *,
        doublecomplex *, integer *);

    # 声明外部的复数矩阵缩放子程序 zlascl_
    extern /* Subroutine */ int zlascl_(char *, integer *, integer *,
         doublereal *, doublereal *, integer *, integer *, doublecomplex *,
        integer *, integer *);

    # 声明外部的复数矩阵复制子程序 zlacpy_
    extern /* Subroutine */ int zlacpy_(char *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *, integer *);
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

ZLALS0 applies back the multiplying factors of either the left or the
right singular vector matrix of a diagonal matrix appended by a row
to the right hand side matrix B in solving the least squares problem
using the divide-and-conquer SVD approach.

For the left singular vector matrix, three types of orthogonal
matrices are involved:

(1L) Givens rotations: the number of such rotations is GIVPTR; the
     pairs of columns/rows they were applied to are stored in GIVCOL;
     and the C- and S-values of these rotations are stored in GIVNUM.

(2L) Permutation. The (NL+1)-st row of B is to be moved to the first
     row, and for J=2:N, PERM(J)-th row of B is to be moved to the
     J-th row.

(3L) The left singular vector matrix of the remaining matrix.

For the right singular vector matrix, four types of orthogonal
matrices are involved:

(1R) The right singular vector matrix of the remaining matrix.

(2R) If SQRE = 1, one extra Givens rotation to generate the right
     null space.

(3R) The inverse transformation of (2L).

(4R) The inverse transformation of (1L).

Arguments
=========

ICOMPQ (input) INTEGER
       Specifies whether singular vectors are to be computed in
       factored form:
       = 0: Left singular vector matrix.
       = 1: Right singular vector matrix.

NL     (input) INTEGER
       The row dimension of the upper block. NL >= 1.

NR     (input) INTEGER
       The row dimension of the lower block. NR >= 1.

SQRE   (input) INTEGER
       = 0: the lower block is an NR-by-NR square matrix.
       = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

       The bidiagonal matrix has row dimension N = NL + NR + 1,
       and column dimension M = N + SQRE.

NRHS   (input) INTEGER
       The number of columns of B and BX. NRHS must be at least 1.

B      (input/output) COMPLEX*16 array, dimension ( LDB, NRHS )
       On input, B contains the right hand sides of the least
       squares problem in rows 1 through M. On output, B contains
       the solution X in rows 1 through N.

LDB    (input) INTEGER
       The leading dimension of B. LDB must be at least
       max(1,MAX( M, N ) ).

BX     (workspace) COMPLEX*16 array, dimension ( LDBX, NRHS )

LDBX   (input) INTEGER
       The leading dimension of BX.

PERM   (input) INTEGER array, dimension ( N )
       The permutations (from deflation and sorting) applied
       to the two blocks.

GIVPTR (input) INTEGER
       The number of Givens rotations which took place in this
       subproblem.
"""
    ! GIVCOL (输入) 整数数组，维度为 (LDGCOL, 2)
    ! 每对数字表示参与 Givens 旋转的行/列对。

    ! LDGCOL (输入) 整数
    ! GIVCOL 的主导维度，至少应为 N。

    ! GIVNUM (输入) 双精度数组，维度为 (LDGNUM, 2)
    ! 每个数字表示相应 Givens 旋转中使用的 C 或 S 值。

    ! LDGNUM (输入) 整数
    ! 数组 DIFR、POLES 和 GIVNUM 的主导维度，至少应为 K。

    ! POLES (输入) 双精度数组，维度为 (LDGNUM, 2)
    ! 在输入时，POLES(1:K, 1) 包含解决谱方程获得的新奇异值，
    ! POLES(1:K, 2) 是包含谱方程中极点的数组。

    ! DIFL (输入) 双精度数组，维度为 (K)
    ! 在输入时，DIFL(I) 是第 I 个更新（未膨胀）奇异值与第 I 个（未膨胀）旧奇异值之间的距离。

    ! DIFR (输入) 双精度数组，维度为 (LDGNUM, 2)
    ! 在输入时，DIFR(I, 1) 包含第 I 个更新（未膨胀）奇异值与第 I+1 个（未膨胀）旧奇异值之间的距离。
    ! 而 DIFR(I, 2) 是第 I 个右奇异向量的归一化因子。

    ! Z (输入) 双精度数组，维度为 (K)
    ! 包含膨胀调整后的更新行向量的分量。

    ! K (输入) 整数
    ! 包含非膨胀矩阵的维度，这是相关谱方程的阶数。1 <= K <= N。

    ! C (输入) 双精度
    ! 如果 SQRE = 0，则 C 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 C 值。

    ! S (输入) 双精度
    ! 如果 SQRE = 0，则 S 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 S 值。

    ! RWORK (工作区) 双精度数组，维度为 (K*(1+NRHS) + 2*NRHS)

    ! INFO (输出) 整数
    ! = 0: 成功退出。
    ! < 0: 如果 INFO = -i，则第 i 个参数具有非法值。

    ! 进一步细节
    ! ===============
    ! 基于以下贡献
    !    Ming Gu 和 Ren-Cang Li, 加州大学伯克利分校，美国计算机科学部
    !    Osni Marques, LBNL/NERSC，美国

    ! 测试输入参数。
    /* Parameter adjustments */
    // Adjusting the dimensions and offsets of arrays and matrices based on input parameters
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    --perm;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    difr_dim1 = *ldgnum;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    poles_dim1 = *ldgnum;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    givnum_dim1 = *ldgnum;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    --difl;
    --z__;
    --rwork;

    /* Function Body */
    // Initialize info to zero
    *info = 0;

    // Check validity of icompq
    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*nl < 1) {
        *info = -2;
    } else if (*nr < 1) {
        *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -4;
    }

    // Calculate total size of n
    n = *nl + *nr + 1;

    // Check validity of nrhs and ldbx
    if (*nrhs < 1) {
        *info = -5;
    } else if (*ldb < n) {
        *info = -7;
    } else if (*ldbx < n) {
        *info = -9;
    } else if (*givptr < 0) {
        *info = -11;
    } else if (*ldgcol < n) {
        *info = -13;
    } else if (*ldgnum < n) {
        *info = -15;
    } else if (*k < 1) {
        *info = -20;
    }

    // If there's an error in parameters, call error handling and return
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZLALS0", &i__1);
        return 0;
    }

    // Calculate m and nlp1 based on input parameters
    m = n + *sqre;
    nlp1 = *nl + 1;

    // Check icompq flag and perform operations accordingly
    if (*icompq == 0) {

        /*
          Apply back orthogonal transformations from the left.

          Step (1L): apply back the Givens rotations performed.
        */

        // Loop through Givens rotations and apply them to matrix B
        i__1 = *givptr;
        for (i__ = 1; i__ <= i__1; ++i__) {
            zdrot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
                b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
                (givnum_dim1 << 1)], &givnum[i__ + givnum_dim1]);
            /* L10: */
        }

        /*
          Step (2L): permute rows of B.
        */

        // Copy permuted rows of B to matrix BX
        zcopy_(nrhs, &b[nlp1 + b_dim1], ldb, &bx[bx_dim1 + 1], ldbx);
        i__1 = n;
        for (i__ = 2; i__ <= i__1; ++i__) {
            zcopy_(nrhs, &b[perm[i__] + b_dim1], ldb, &bx[i__ + bx_dim1],
                ldbx);
            /* L20: */
        }

        /*
          Step (3L): apply the inverse of the left singular vector
          matrix to BX.
        */

        // Special case when k equals 1
        if (*k == 1) {
            zcopy_(nrhs, &bx[bx_offset], ldbx, &b[b_offset], ldb);
            // Adjust signs based on z__ values
            if (z__[1] < 0.) {
                zdscal_(nrhs, &c_b1276, &b[b_offset], ldb);
            }
        }
    cpp
        } else {
            // 计算对角元素为 j 的情况
            i__1 = *k;
            for (j = 1; j <= i__1; ++j) {
                diflj = difl[j];
                dj = poles[j + poles_dim1];
                dsigj = -poles[j + (poles_dim1 << 1)];
                // 如果不是最后一个元素，设置 difrj 和 dsigjp
                if (j < *k) {
                    difrj = -difr[j + difr_dim1];
                    dsigjp = -poles[j + 1 + (poles_dim1 << 1)];
                }
                // 如果 z__[j] 或 poles[j + (poles_dim1 << 1)] 为零，则 rwork[j] 设为零
                if (z__[j] == 0. || poles[j + (poles_dim1 << 1)] == 0.) {
                    rwork[j] = 0.;
                } else {
                    // 计算 rwork[j] 的值
                    rwork[j] = -poles[j + (poles_dim1 << 1)] * z__[j] / diflj
                        / (poles[j + (poles_dim1 << 1)] + dj);
                }
                // 计算对角元素为 i 的情况
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    // 如果 z__[i__] 或 poles[i__ + (poles_dim1 << 1)] 为零，则 rwork[i__] 设为零
                    if (z__[i__] == 0. || poles[i__ + (poles_dim1 << 1)] == 0.) {
                        rwork[i__] = 0.;
                    } else {
                        // 计算 rwork[i__] 的值
                        rwork[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                             / (dlamc3_(&poles[i__ + (poles_dim1 << 1)], &
                                dsigj) - diflj) / (poles[i__ + (poles_dim1 <<
                                1)] + dj);
                    }
/* L30: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            if (z__[i__] == 0. || poles[i__ + (poles_dim1 << 1)] ==
                0.) {
                rwork[i__] = 0.;
            } else {
                // 计算复杂数的乘积和除法，更新 rwork 数组
                rwork[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                     / (dlamc3_(&poles[i__ + (poles_dim1 << 1)], &
                        dsigjp) + difrj) / (poles[i__ + (poles_dim1 <<
                         1)] + dj);
            }
/* L40: */
        }
        // 设置 rwork 数组的第一个元素为 -1
        rwork[1] = -1.;
        // 计算 rwork 数组的范数
        temp = dnrm2_(k, &rwork[1], &c__1);

/*
                Since B and BX are complex, the following call to DGEMV
                is performed in two steps (real and imaginary parts).

                CALL DGEMV( 'T', K, NRHS, ONE, BX, LDBX, WORK, 1, ZERO,
      $                     B( J, 1 ), LDB )
*/

        i__ = *k + (*nrhs << 1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
                ++i__;
                // 提取复数数组 bx 中的实部并存储到 rwork 数组中
                i__4 = jrow + jcol * bx_dim1;
                rwork[i__] = bx[i__4].r;
/* L50: */
            }
/* L60: */
        }
        // 调用 DGEMV 计算矩阵-向量乘积（转置模式）
        dgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1], &c__1);
        i__ = *k + (*nrhs << 1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
                ++i__;
                // 提取复数数组 bx 中的虚部并存储到 rwork 数组中
                rwork[i__] = d_imag(&bx[jrow + jcol * bx_dim1]);
/* L70: */
            }
/* L80: */
        }
        // 再次调用 DGEMV 计算矩阵-向量乘积（转置模式）
        dgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1 + *nrhs],
            &c__1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            // 将计算得到的结果存储到复数数组 b 中
            i__3 = j + jcol * b_dim1;
            i__4 = jcol + *k;
            i__5 = jcol + *k + *nrhs;
            z__1.r = rwork[i__4], z__1.i = rwork[i__5];
            b[i__3].r = z__1.r, b[i__3].i = z__1.i;
/* L90: */
        }
        // 调用 ZLASCL 执行矩阵的缩放操作
        zlascl_("G", &c__0, &c__0, &temp, &c_b1034, &c__1, nrhs, &b[j
            + b_dim1], ldb, info);
/* L100: */
        }
    }

/*        Move the deflated rows of BX to B also. */

    if (*k < max(m,n)) {
        // 将矩阵 bx 中剩余的行复制到 b 中
        i__1 = n - *k;
        zlacpy_("A", &i__1, nrhs, &bx[*k + 1 + bx_dim1], ldbx, &b[*k + 1
            + b_dim1], ldb);
    }
    } else {

/*
          Apply back the right orthogonal transformations.

          Step (1R): apply back the new right singular vector matrix
          to B.
*/

    if (*k == 1) {
        // 将矩阵 b 的第一列复制到 bx 的第一列
        zcopy_(nrhs, &b[b_offset], ldb, &bx[bx_offset], ldbx);
    } else {
        // 如果不满足条件，则执行以下代码块
        i__1 = *k;
        // 将*k的值赋给i__1，*k是一个指向整数的指针
        for (j = 1; j <= i__1; ++j) {
            // 循环j从1到i__1
            dsigj = poles[j + (poles_dim1 << 1)];
            // 获取poles数组中指定位置的值赋给dsigj
            if (z__[j] == 0.) {
                // 如果z__数组中第j个元素等于0
                rwork[j] = 0.;
                // 将rwork数组中第j个元素置为0
            } else {
                // 否则
                rwork[j] = -z__[j] / difl[j] / (dsigj + poles[j +
                    poles_dim1]) / difr[j + (difr_dim1 << 1)];
                // 计算rwork数组中第j个元素的值
            }
            i__2 = j - 1;
            // 将j-1的值赋给i__2
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 循环i从1到i__2
                if (z__[j] == 0.) {
                    // 如果z__数组中第j个元素等于0
                    rwork[i__] = 0.;
                    // 将rwork数组中第i个元素置为0
                } else {
                    // 否则
                    d__1 = -poles[i__ + 1 + (poles_dim1 << 1)];
                    // 将-poles数组中指定位置的值赋给d__1
                    rwork[i__] = z__[j] / (dlamc3_(&dsigj, &d__1) - difr[
                        i__ + difr_dim1]) / (dsigj + poles[i__ +
                        poles_dim1]) / difr[i__ + (difr_dim1 << 1)];
                    // 计算rwork数组中第i个元素的值
                }
            }
        }
    }


这段代码是一段嵌套循环结构的C语言代码，注释详细解释了每个条件判断和计算操作的含义和作用。
/*
    此处为一个嵌套的循环结构，用于计算每个列向量的更新值。
    每个列向量的计算是基于一个复杂的数学表达式，涉及到数组和常数。
*/
i__2 = *k;
for (j = j + 1; j <= i__2; ++j) {
    /*
        如果 z__[j] 等于 0，则将 rwork[i__] 设置为 0。
        否则，根据 z__[j] 和其他参数计算 rwork[i__] 的值。
    */
    if (z__[j] == 0.) {
        rwork[i__] = 0.;
    } else {
        d__1 = -poles[i__ + (poles_dim1 << 1)];
        rwork[i__] = z__[j] / (dlamc3_(&dsigj, &d__1) - difl[
            i__]) / (dsigj + poles[i__ + poles_dim1]) /
            difr[i__ + (difr_dim1 << 1)];
    }
}

/*
    以下代码段调用 DGEMV 函数来执行矩阵向量乘法。
    由于 B 和 BX 是复数，调用分成两步（实部和虚部）进行。
*/
i__ = *k + (*nrhs << 1);
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = *k;
    for (jrow = 1; jrow <= i__3; ++jrow) {
        /*
            将复数矩阵 B 的实部提取到 rwork 数组中。
        */
        ++i__;
        i__4 = jrow + jcol * b_dim1;
        rwork[i__] = b[i__4].r;
    }
}

/*
    调用 DGEMV 函数来执行矩阵向量乘法，这次是处理虚部。
*/
i__ = *k + (*nrhs << 1);
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = *k;
    for (jrow = 1; jrow <= i__3; ++jrow) {
        /*
            将复数矩阵 B 的虚部提取到 rwork 数组中。
        */
        ++i__;
        rwork[i__] = d_imag(&b[jrow + jcol * b_dim1]);
    }
}

/*
    将 rwork 数组中的计算结果通过 DGEMV 函数应用回 BX 矩阵。
*/
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    /*
        将 rwork 数组中的结果按照规定的格式写入到 BX 矩阵中。
    */
    i__3 = j + jcol * bx_dim1;
    i__4 = jcol + *k;
    i__5 = jcol + *k + *nrhs;
    z__1.r = rwork[i__4], z__1.i = rwork[i__5];
    bx[i__3].r = z__1.r, bx[i__3].i = z__1.i;
}
    # 对给定的 givptr 指向的元素进行逆序循环处理，从 *givptr 到 1
    for (i__ = *givptr; i__ >= 1; --i__) {
        # 计算-givnum[i__ + givnum_dim1]的值
        d__1 = -givnum[i__ + givnum_dim1];
        # 调用 zdrot_ 函数，进行一种特定的旋转操作，作用于矩阵 b 的特定行
        zdrot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &d__1);
/* L200: */
    }
    }

    return 0;

/*     End of ZLALS0 */

} /* zlals0_ */

/* Subroutine */ int zlalsa_(integer *icompq, integer *smlsiz, integer *n,
    integer *nrhs, doublecomplex *b, integer *ldb, doublecomplex *bx,
    integer *ldbx, doublereal *u, integer *ldu, doublereal *vt, integer *
    k, doublereal *difl, doublereal *difr, doublereal *z__, doublereal *
    poles, integer *givptr, integer *givcol, integer *ldgcol, integer *
    perm, doublereal *givnum, doublereal *c__, doublereal *s, doublereal *
    rwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
        difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
        z_dim1, z_offset, b_dim1, b_offset, bx_dim1, bx_offset, i__1,
        i__2, i__3, i__4, i__5, i__6;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, jcol, nlvl, sqre, jrow, jimag;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static integer jreal, inode, ndiml, ndimr;
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), zlals0_(integer *, integer *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         doublereal *, integer *), dlasdt_(integer *, integer *, integer *
        , integer *, integer *, integer *, integer *), xerbla_(char *,
        integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, ZLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, ZLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by ZLALSA.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether the left or the right singular vector
           matrix is involved.
           = 0: Left singular vector matrix
           = 1: Right singular vector matrix

/* zlalsa_ subroutine starts here */



注释：
    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The row and column dimensions of the upper bidiagonal matrix.

    NRHS   (input) INTEGER
           The number of columns of B and BX. NRHS must be at least 1.

    B      (input/output) COMPLEX*16 array, dimension ( LDB, NRHS )
           On input, B contains the right hand sides of the least
           squares problem in rows 1 through M.
           On output, B contains the solution X in rows 1 through N.

    LDB    (input) INTEGER
           The leading dimension of B in the calling subprogram.
           LDB must be at least max(1,MAX( M, N ) ).

    BX     (output) COMPLEX*16 array, dimension ( LDBX, NRHS )
           On exit, the result of applying the left or right singular
           vector matrix to B.

    LDBX   (input) INTEGER
           The leading dimension of BX.

    U      (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
           On entry, U contains the left singular vector matrices of all
           subproblems at the bottom level.

    LDU    (input) INTEGER, LDU = > N.
           The leading dimension of arrays U, VT, DIFL, DIFR,
           POLES, GIVNUM, and Z.

    VT     (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
           On entry, VT' contains the right singular vector matrices of
           all subproblems at the bottom level.

    K      (input) INTEGER array, dimension ( N ).
           Array storing integers related to the computation.

    DIFL   (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
           where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
           Contains distances between singular values on successive levels.

    DIFR   (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
           distances between singular values on the I-th level and
           singular values on the (I -1)-th level, and DIFR(*, 2 * I)
           record the normalizing factors of the right singular vectors
           matrices of subproblems on I-th level.

    Z      (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
           On entry, Z(1, I) contains the components of the deflation-
           adjusted updating row vector for subproblems on the I-th
           level.

    POLES  (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
           singular values involved in the secular equations on the I-th
           level.

    GIVPTR (input) INTEGER array, dimension ( N ).
           On entry, GIVPTR( I ) records the number of Givens
           rotations performed on the I-th problem on the computation
           tree.

    GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
           On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
           locations of Givens rotations performed on the I-th level on
           the computation tree.
    # LDGCOL 是数组 GIVCOL 和 PERM 的列数
    LDGCOL (input) INTEGER, LDGCOL = > N.
           The leading dimension of arrays GIVCOL and PERM.

    # PERM 是记录在计算树的第 I 级上执行的置换的数组
    PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
           On entry, PERM(*, I) records permutations done on the I-th
           level of the computation tree.

    # GIVNUM 记录在计算树的第 I 级上执行的 Givens 旋转的 C 和 S 值
    GIVNUM (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
           values of Givens rotations performed on the I-th level on the
           computation tree.

    # 如果第 I 个子问题不是方阵，则 C(I) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 C 值
    C      (input) DOUBLE PRECISION array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           C( I ) contains the C-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    # 如果第 I 个子问题不是方阵，则 S(I) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 S 值
    S      (input) DOUBLE PRECISION array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           S( I ) contains the S-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    # RWORK 是用作工作空间的双精度数组
    RWORK  (workspace) DOUBLE PRECISION array, dimension at least
           MAX( (SMLSZ+1)*NRHS*3, N*(1+NRHS) + 2*NRHS ).

    # IWORK 是用作工作空间的整数数组
    IWORK  (workspace) INTEGER array.
           The dimension must be at least 3 * N

    # INFO 是输出参数，表示函数的执行结果
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 详情
    Further Details
    ===============

    # 根据贡献者备注
    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    =====================================================================

    # 测试输入参数
       Test the input parameters.
    /* Parameter adjustments */
    // Adjusting the dimensions and offsets for arrays and matrices
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    givnum_dim1 = *ldu;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    poles_dim1 = *ldu;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    z_dim1 = *ldu;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    difr_dim1 = *ldu;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    difl_dim1 = *ldu;
    difl_offset = 1 + difl_dim1;
    difl -= difl_offset;
    vt_dim1 = *ldu;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    --k;
    --givptr;
    perm_dim1 = *ldgcol;
    perm_offset = 1 + perm_dim1;
    perm -= perm_offset;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    --c__;
    --s;
    --rwork;
    --iwork;

    /* Function Body */
    // Initialize info flag
    *info = 0;

    // Check validity of input parameters
    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*smlsiz < 3) {
        *info = -2;
    } else if (*n < *smlsiz) {
        *info = -3;
    } else if (*nrhs < 1) {
        *info = -4;
    } else if (*ldb < *n) {
        *info = -6;
    } else if (*ldbx < *n) {
        *info = -8;
    } else if (*ldu < *n) {
        *info = -10;
    } else if (*ldgcol < *n) {
        *info = -19;
    }

    // If any parameter check failed, call error handler and return
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZLALSA", &i__1);
        return 0;
    }

/*     Book-keeping and  setting up the computation tree. */

    // Initialize variables for computation tree
    inode = 1;
    ndiml = inode + *n;
    ndimr = ndiml + *n;

    // Set up split points for divide-and-conquer approach
    dlasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
            smlsiz);

/*
       The following code applies back the left singular vector factors.
       For applying back the right singular vector factors, go to 170.
*/

    // Check if only left singular vectors are to be applied
    if (*icompq == 1) {
        goto L170;
    }

/*
       The nodes on the bottom level of the tree were solved
       by DLASDQ. The corresponding left and right singular vector
       matrices are in explicit form. First apply back the left
       singular vector matrices.
*/

    // Calculate the number of nodes solved by DLASDQ
    ndb1 = (nd + 1) / 2;
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
          IC : center row of each node
          NL : number of rows of left  subproblem
          NR : number of rows of right subproblem
          NLF: starting row of the left   subproblem
          NRF: starting row of the right  subproblem
*/

        // Compute indices and dimensions for current node
        i1 = i__ - 1;
        ic = iwork[inode + i1];
        nl = iwork[ndiml + i1];
        nr = iwork[ndimr + i1];
        nlf = ic - nl;
        nrf = ic + 1;

/*
          Since B and BX are complex, the following call to DGEMM
          is performed in two steps (real and imaginary parts).

          CALL DGEMM( 'T', 'N', NL, NRHS, NL, ONE, U( NLF, 1 ), LDU,
       $               B( NLF, 1 ), LDB, ZERO, BX( NLF, 1 ), LDBX )
*/

        // Compute matrix multiplication for left singular vectors
        j = nl * *nrhs << 1;
        i__2 = *nrhs;
        // Continue with further operations
    // 循环遍历列索引 jcol 从 1 到 i__2
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // 计算当前循环所需的行索引范围，从 nlf 到 nlf + nl - 1
        i__3 = nlf + nl - 1;
        // 循环遍历行索引 jrow 从 nlf 到 i__3
        for (jrow = nlf; jrow <= i__3; ++jrow) {
            // 增加结果数组 rwork 的索引 j
            ++j;
            // 计算当前元素在二维数组 b 中的索引，存入 rwork 数组中
            i__4 = jrow + jcol * b_dim1;
            rwork[j] = b[i__4].r;
/* L10: */
        }
/* L20: */
    }
    // Perform matrix multiplication: B^T * U
    dgemm_("T", "N", &nl, nrhs, &nl, &c_b1034, &u[nlf + u_dim1], ldu, &
        rwork[(nl * *nrhs << 1) + 1], &nl, &c_b328, &rwork[1], &nl);
    // Initialize index for complex part in rwork array
    j = nl * *nrhs << 1;
    // Loop over columns of B and rows of U to compute intermediate values in rwork
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // Loop over rows of B and rows of U to compute complex values in rwork
        i__3 = nlf + nl - 1;
        for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        // Store imaginary part of B into rwork
        rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
/* L30: */
        }
/* L40: */
    }
    // Perform matrix multiplication: B^T * U
    dgemm_("T", "N", &nl, nrhs, &nl, &c_b1034, &u[nlf + u_dim1], ldu, &
        rwork[(nl * *nrhs << 1) + 1], &nl, &c_b328, &rwork[nl * *nrhs
        + 1], &nl);
    // Initialize indices for real and imaginary parts in rwork array
    jreal = 0;
    jimag = nl * *nrhs;
    // Loop over columns of B and rows of U to compute real and imaginary parts
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // Loop over rows of B and rows of U to assign real and imaginary parts to BX
        i__3 = nlf + nl - 1;
        for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        z__1.r = rwork[i__5], z__1.i = rwork[i__6];
        // Assign computed complex values from rwork to BX
        bx[i__4].r = z__1.r, bx[i__4].i = z__1.i;
/* L50: */
        }
/* L60: */
    }

/*
          Since B and BX are complex, the following call to DGEMM
          is performed in two steps (real and imaginary parts).

          CALL DGEMM( 'T', 'N', NR, NRHS, NR, ONE, U( NRF, 1 ), LDU,
      $               B( NRF, 1 ), LDB, ZERO, BX( NRF, 1 ), LDBX )
*/

    // Initialize index for real part in rwork array
    j = nr * *nrhs << 1;
    // Loop over columns of B and rows of U to compute real part in rwork
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // Loop over rows of B and rows of U to compute real part in rwork
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        // Store real part of B into rwork
        rwork[j] = b[i__4].r;
/* L70: */
        }
/* L80: */
    }
    // Perform matrix multiplication: B^T * U
    dgemm_("T", "N", &nr, nrhs, &nr, &c_b1034, &u[nrf + u_dim1], ldu, &
        rwork[(nr * *nrhs << 1) + 1], &nr, &c_b328, &rwork[1], &nr);
    // Initialize index for imaginary part in rwork array
    j = nr * *nrhs << 1;
    // Loop over columns of B and rows of U to compute imaginary part in rwork
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // Loop over rows of B and rows of U to compute imaginary part in rwork
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        // Store imaginary part of B into rwork
        rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
/* L90: */
        }
/* L100: */
    }
    // Perform matrix multiplication: B^T * U
    dgemm_("T", "N", &nr, nrhs, &nr, &c_b1034, &u[nrf + u_dim1], ldu, &
        rwork[(nr * *nrhs << 1) + 1], &nr, &c_b328, &rwork[nr * *nrhs
        + 1], &nr);
    // Initialize indices for real and imaginary parts in rwork array
    jreal = 0;
    jimag = nr * *nrhs;
    // Loop over columns of B and rows of U to assign real and imaginary parts to BX
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // Loop over rows of B and rows of U to assign real and imaginary parts to BX
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        z__1.r = rwork[i__5], z__1.i = rwork[i__6];
        // Assign computed complex values from rwork to BX
        bx[i__4].r = z__1.r, bx[i__4].i = z__1.i;
/* L110: */
        }
/* L120: */
    }

/* L130: */
    }

/*
       Next copy the rows of B that correspond to unchanged rows
       in the bidiagonal matrix to BX.
*/

    // Loop over rows of B to copy corresponding rows to BX
    i__1 = nd;
    for (i__ = 1; i__ <= i__1; ++i__) {
    // Determine the current row index from iwork and copy to BX
    ic = iwork[inode + i__ - 1];
    // Copy the complex vector from B to BX
    zcopy_(nrhs, &b[ic + b_dim1], ldb, &bx[ic + bx_dim1], ldbx);
/* L140: */
    }
/*
       Finally go through the left singular vector matrices of all
       the other subproblems bottom-up on the tree.
*/
j = pow_ii(&c__2, &nlvl);
sqre = 0;

for (lvl = nlvl; lvl >= 1; --lvl) {
lvl2 = (lvl << 1) - 1;

/*
          find the first node LF and last node LL on
          the current level LVL
*/
if (lvl == 1) {
    lf = 1;
    ll = 1;
} else {
    i__1 = lvl - 1;
    lf = pow_ii(&c__2, &i__1);
    ll = (lf << 1) - 1;
}
i__1 = ll;
for (i__ = lf; i__ <= i__1; ++i__) {
    im1 = i__ - 1;
    ic = iwork[inode + im1];
    nl = iwork[ndiml + im1];
    nr = iwork[ndimr + im1];
    nlf = ic - nl;
    nrf = ic + 1;
    --j;

    // 调用子程序 zlals0_ 进行计算
    zlals0_(icompq, &nl, &nr, &sqre, nrhs, &bx[nlf + bx_dim1], ldbx, &
        b[nlf + b_dim1], ldb, &perm[nlf + lvl * perm_dim1], &
        givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
        givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
         poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
        lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
        j], &s[j], &rwork[1], info);
    /* L150: */
}
/* L160: */
}
goto L330;

/*     ICOMPQ = 1: applying back the right singular vector factors. */

L170:

/*
       First now go through the right singular vector matrices of all
       the tree nodes top-down.
*/
j = 0;
i__1 = nlvl;
for (lvl = 1; lvl <= i__1; ++lvl) {
lvl2 = (lvl << 1) - 1;

/*
          Find the first node LF and last node LL on
          the current level LVL.
*/
if (lvl == 1) {
    lf = 1;
    ll = 1;
} else {
    i__2 = lvl - 1;
    lf = pow_ii(&c__2, &i__2);
    ll = (lf << 1) - 1;
}
i__2 = lf;
for (i__ = ll; i__ >= i__2; --i__) {
    im1 = i__ - 1;
    ic = iwork[inode + im1];
    nl = iwork[ndiml + im1];
    nr = iwork[ndimr + im1];
    nlf = ic - nl;
    nrf = ic + 1;

    if (i__ == ll) {
        sqre = 0;
    } else {
        sqre = 1;
    }
    ++j;

    // 调用子程序 zlals0_ 进行计算
    zlals0_(icompq, &nl, &nr, &sqre, nrhs, &b[nlf + b_dim1], ldb, &bx[
        nlf + bx_dim1], ldbx, &perm[nlf + lvl * perm_dim1], &
        givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
        givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
         poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
        lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
        j], &s[j], &rwork[1], info);
    /* L180: */
}
/* L190: */
}

/*
       The nodes on the bottom level of the tree were solved
       by DLASDQ. The corresponding right singular vector
       matrices are in explicit form. Apply them back.
*/
ndb1 = (nd + 1) / 2;
i__1 = nd;
for (i__ = ndb1; i__ <= i__1; ++i__) {
i1 = i__ - 1;
ic = iwork[inode + i1];
nl = iwork[ndiml + i1];
nr = iwork[ndimr + i1];
nlp1 = nl + 1;
    # 如果 i__ 等于 nd，则将 nrp1 设为 nr
    if (i__ == nd) {
        nrp1 = nr;
    # 否则将 nrp1 设为 nr + 1
    } else {
        nrp1 = nr + 1;
    }
    # 计算 nlf，表示 ic 减去 nl 的结果
    nlf = ic - nl;
    # 计算 nrf，表示 ic 加 1 的结果
    nrf = ic + 1;
/*
      因为 B 和 BX 是复数，所以下面的 DGEMM 调用分两步进行（实部和虚部）。

      调用 DGEMM 函数计算矩阵乘法，传递 'T'（转置）和 'N'（不转置）作为参数，计算大小为 NLP1 x NRHS 的矩阵乘法。
      使用常数 ONE 和 ZERO 作为乘数和加数。
*/

j = nlp1 * *nrhs << 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nlf + nlp1 - 1;
    for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        rwork[j] = b[i__4].r;
    }
}

/*
  调用 DGEMM 函数计算矩阵乘法，传递 'T'（转置）和 'N'（不转置）作为参数，计算大小为 NLP1 x NRHS 的矩阵乘法。
  使用常数 c_b1034 和 c_b328 作为乘数和加数。
*/

dgemm_("T", "N", &nlp1, nrhs, &nlp1, &c_b1034, &vt[nlf + vt_dim1],
    ldu, &rwork[(nlp1 * *nrhs << 1) + 1], &nlp1, &c_b328, &rwork[
    1], &nlp1);

j = nlp1 * *nrhs << 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nlf + nlp1 - 1;
    for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
    }
}

/*
  因为 B 和 BX 是复数，所以下面的 DGEMM 调用分两步进行（实部和虚部）。

  调用 DGEMM 函数计算矩阵乘法，传递 'T'（转置）和 'N'（不转置）作为参数，计算大小为 NRP1 x NRHS 的矩阵乘法。
  使用常数 c_b1034 和 c_b328 作为乘数和加数。
*/

j = nrp1 * *nrhs << 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nrf + nrp1 - 1;
    for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        rwork[j] = b[i__4].r;
    }
}

/*
  调用 DGEMM 函数计算矩阵乘法，传递 'T'（转置）和 'N'（不转置）作为参数，计算大小为 NRP1 x NRHS 的矩阵乘法。
  使用常数 c_b1034 和 c_b328 作为乘数和加数。
*/

dgemm_("T", "N", &nrp1, nrhs, &nrp1, &c_b1034, &vt[nrf + vt_dim1],
    ldu, &rwork[(nrp1 * *nrhs << 1) + 1], &nrp1, &c_b328, &rwork[
    nrp1 * *nrhs + 1], &nrp1);

jreal = 0;
jimag = nrp1 * *nrhs;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nrf + nrp1 - 1;
    for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        z__1.r = rwork[i__5], z__1.i = rwork[i__6];
        bx[i__4].r = z__1.r, bx[i__4].i = z__1.i;
    }
}
    // 循环遍历列 jcol，从 1 到 i__2
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // 计算内层循环的结束条件 i__3
        i__3 = nrf + nrp1 - 1;
        // 循环遍历行 jrow，从 nrf 到 i__3
        for (jrow = nrf; jrow <= i__3; ++jrow) {
            // jreal 和 jimag 分别递增，用于访问 rwork 数组的下标
            ++jreal;
            ++jimag;
            // 计算 bx 数组中元素的索引 i__4
            i__4 = jrow + jcol * bx_dim1;
            // 获取 rwork 数组中 jreal 和 jimag 对应的值，构成复数 z__1
            i__5 = jreal;
            i__6 = jimag;
            z__1.r = rwork[i__5], z__1.i = rwork[i__6];
            // 将复数值 z__1 赋给 bx 数组中的元素
            bx[i__4].r = z__1.r, bx[i__4].i = z__1.i;
/* L300: */
        }
/* L310: */
    }

/* L320: */
    }

L330:

    return 0;

/*     End of ZLALSA */

} /* zlalsa_ */

/* Subroutine */ int zlalsd_(char *uplo, integer *smlsiz, integer *n, integer
    *nrhs, doublereal *d__, doublereal *e, doublecomplex *b, integer *ldb,
     doublereal *rcond, integer *rank, doublecomplex *work, doublereal *
    rwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer c__, i__, j, k;
    static doublereal r__;
    static integer s, u, z__;
    static doublereal cs;
    static integer bx;
    static doublereal sn;
    static integer st, vt, nm1, st1;
    static doublereal eps;
    static integer iwk;
    static doublereal tol;
    static integer difl, difr;
    static doublereal rcnd;
    static integer jcol, irwb, perm, nsub, nlvl, sqre, bxst, jrow, irwu,
        jimag;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static integer jreal, irwib, poles, sizei, irwrb, nsize;
    extern /* Subroutine */ int zdrot_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublereal *, doublereal *), zcopy_(
        integer *, doublecomplex *, integer *, doublecomplex *, integer *)
        ;
    static integer irwvt, icmpq1, icmpq2;

    extern /* Subroutine */ int dlasda_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         integer *), dlascl_(char *, integer *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *);
    extern integer idamax_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dlasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, doublereal *, doublereal *, doublereal *,
         integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *), dlaset_(char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *), dlartg_(doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *), xerbla_(char *, integer *);
    static integer givcol;
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);



注释：
    # 外部声明，引用在其他文件或模块中定义的子程序 zlalsa, zlascl, dlasrt, zlacpy, zlaset
    extern /* Subroutine */ int zlalsa_(integer *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *, integer *,
         doublereal *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, integer *,
        integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, integer *, integer *);

    # 声明静态变量
    static doublereal orgnrm;  # 存储原始范数
    static integer givnum, givptr, nrwork, irwwrk, smlszp;  # 分别为给定数量、指针、工作空间大小、工作空间索引、小规模问题大小
/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    ZLALSD uses the singular value decomposition of A to solve the least
    squares problem of finding X to minimize the Euclidean norm of each
    column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
    are N-by-NRHS. The solution X overwrites B.

    The singular values of A smaller than RCOND times the largest
    singular value are treated as zero in solving the least squares
    problem; in this case a minimum norm solution is returned.
    The actual singular values are returned in D in ascending order.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    UPLO   (input) CHARACTER*1
           = 'U': D and E define an upper bidiagonal matrix.
           = 'L': D and E define a  lower bidiagonal matrix.

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The dimension of the  bidiagonal matrix.  N >= 0.

    NRHS   (input) INTEGER
           The number of columns of B. NRHS must be at least 1.

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry D contains the main diagonal of the bidiagonal
           matrix. On exit, if INFO = 0, D contains its singular values.

    E      (input/output) DOUBLE PRECISION array, dimension (N-1)
           Contains the super-diagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    B      (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
           On input, B contains the right hand sides of the least
           squares problem. On output, B contains the solution X.

    LDB    (input) INTEGER
           The leading dimension of B in the calling subprogram.
           LDB must be at least max(1,N).

    RCOND  (input) DOUBLE PRECISION
           The singular values of A less than or equal to RCOND times
           the largest singular value are treated as zero in solving
           the least squares problem. If RCOND is negative,
           machine precision is used instead.
           For example, if diag(S)*X=B were the least squares problem,
           where diag(S) is a diagonal matrix of singular values, the
           solution would be X(i) = B(i) / S(i) if S(i) is greater than
           RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
           RCOND*max(S).
*/
    # 输出参数，表示大于 RCOND 倍最大奇异值的奇异值数量
    RANK   (output) INTEGER
           The number of singular values of A greater than RCOND times
           the largest singular value.

    # 复杂数双精度数组，至少为 N * NRHS 大小的工作空间
    WORK   (workspace) COMPLEX*16 array, dimension at least
           (N * NRHS).

    # 双精度数组，至少为 (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
    # MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )) 大小的工作空间
    # NLVL 的定义为 MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
    RWORK  (workspace) DOUBLE PRECISION array, dimension at least
           (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
           MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS ),
           where
           NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )

    # 整数数组，至少为 (3*N*NLVL + 11*N) 大小的工作空间
    IWORK  (workspace) INTEGER array, dimension at least
           (3*N*NLVL + 11*N).

    # 输出参数，表示算法的执行状态：
    # = 0: 成功退出。
    # < 0: 如果 INFO = -i，表示第 i 个参数有非法值。
    # > 0: 算法在处理子矩阵时无法计算奇异值，
    #      子矩阵位于行和列 INFO/(N+1) 到 MOD(INFO,N+1) 之间。
    INFO   (output) INTEGER
           = 0:  successful exit.
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  The algorithm failed to compute a singular value while
                 working on the submatrix lying in rows and columns
                 INFO/(N+1) through MOD(INFO,N+1).

    # 进一步的细节说明
    # 基于以下贡献：
    # Ming Gu 和 Ren-Cang Li，加州大学伯克利分校，美国计算机科学系
    # Osni Marques，LBNL/NERSC，美国
    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    # 测试输入参数的有效性
    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;               // 对数组 d__ 进行参数调整
    --e;                 // 对数组 e 进行参数调整
    b_dim1 = *ldb;       // 将 b 的第一维设置为 ldb
    b_offset = 1 + b_dim1;
    b -= b_offset;       // 调整 b 的指针位置
    --work;              // 对数组 work 进行参数调整
    --rwork;             // 对数组 rwork 进行参数调整
    --iwork;             // 对数组 iwork 进行参数调整

    /* Function Body */
    *info = 0;           // 初始化 info 为 0

    if (*n < 0) {        // 如果 n 小于 0
        *info = -3;      // 将 info 设置为 -3
    } else if (*nrhs < 1) {  // 否则如果 nrhs 小于 1
        *info = -4;      // 将 info 设置为 -4
    } else if (*ldb < 1 || *ldb < *n) {  // 否则如果 ldb 小于 1 或 ldb 小于 n
        *info = -8;      // 将 info 设置为 -8
    }
    if (*info != 0) {    // 如果 info 不等于 0
        i__1 = -(*info); // 计算 -info
        xerbla_("ZLALSD", &i__1);  // 调用错误处理函数 xerbla_
        return 0;         // 返回 0
    }

    eps = EPSILON;       // 设置 eps 为 EPSILON

/*     Set up the tolerance. */

    if (*rcond <= 0. || *rcond >= 1.) {  // 如果 rcond 小于等于 0 或者大于等于 1
        rcnd = eps;      // 设置 rcnd 为 eps
    } else {
        rcnd = *rcond;   // 否则设置 rcnd 为 rcond 的值
    }

    *rank = 0;           // 初始化 rank 为 0

/*     Quick return if possible. */

    if (*n == 0) {       // 如果 n 等于 0
        return 0;        // 直接返回 0
    } else if (*n == 1) {  // 否则如果 n 等于 1
        if (d__[1] == 0.) {  // 如果 d 的第一个元素等于 0
            zlaset_("A", &c__1, nrhs, &c_b56, &c_b56, &b[b_offset], ldb);  // 调用 zlaset_ 函数
        } else {
            *rank = 1;    // 设置 rank 为 1
            zlascl_("G", &c__0, &c__0, &d__[1], &c_b1034, &c__1, nrhs, &b[
                b_offset], ldb, info);  // 调用 zlascl_ 函数
            d__[1] = abs(d__[1]);  // 将 d 的第一个元素取绝对值
        }
        return 0;        // 返回 0
    }

/*     Rotate the matrix if it is lower bidiagonal. */

    if (*(unsigned char *)uplo == 'L') {  // 如果 uplo 是 'L'
        i__1 = *n - 1;   // 设置循环上限为 n-1
        for (i__ = 1; i__ <= i__1; ++i__) {  // 循环 i 从 1 到 n-1
            dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__);  // 调用 dlartg_ 函数
            d__[i__] = r__;   // 更新 d[i]
            e[i__] = sn * d__[i__ + 1];  // 更新 e[i]
            d__[i__ + 1] = cs * d__[i__ + 1];  // 更新 d[i+1]
            if (*nrhs == 1) {
                zdrot_(&c__1, &b[i__ + b_dim1], &c__1, &b[i__ + 1 + b_dim1], &
                    c__1, &cs, &sn);  // 调用 zdrot_ 函数
            } else {
                rwork[(i__ << 1) - 1] = cs;  // 更新 rwork
                rwork[i__ * 2] = sn;        // 更新 rwork
            }
        /* L10: */
        }
        if (*nrhs > 1) {  // 如果 nrhs 大于 1
            i__1 = *nrhs;  // 设置循环上限为 nrhs
            for (i__ = 1; i__ <= i__1; ++i__) {  // 外层循环 i 从 1 到 nrhs
                i__2 = *n - 1;  // 设置内层循环上限为 n-1
                for (j = 1; j <= i__2; ++j) {  // 内层循环 j 从 1 到 n-1
                    cs = rwork[(j << 1) - 1];  // 更新 cs
                    sn = rwork[j * 2];        // 更新 sn
                    zdrot_(&c__1, &b[j + i__ * b_dim1], &c__1, &b[j + 1 + i__
                        * b_dim1], &c__1, &cs, &sn);  // 调用 zdrot_ 函数
                /* L20: */
                }
            /* L30: */
            }
        }
    }

/*     Scale. */

    nm1 = *n - 1;         // 设置 nm1 为 n-1
    orgnrm = dlanst_("M", n, &d__[1], &e[1]);  // 调用 dlanst_ 函数
    if (orgnrm == 0.) {
        zlaset_("A", n, nrhs, &c_b56, &c_b56, &b[b_offset], ldb);  // 调用 zlaset_ 函数
        return 0;        // 返回 0
    }

    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, n, &c__1, &d__[1], n, info);  // 调用 dlascl_ 函数
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &nm1, &c__1, &e[1], &nm1,
        info);          // 调用 dlascl_ 函数

/*
       If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver.
*/

    if (*n <= *smlsiz) {  // 如果 n 小于等于 smlsiz
        irwu = 1;        // 设置 irwu 为 1
        irwvt = irwu + *n * *n;  // 设置 irwvt
        irwwrk = irwvt + *n * *n;  // 设置 irwwrk
        irwrb = irwwrk;  // 设置 irwrb
        irwib = irwrb + *n * *nrhs;  // 设置 irwib
        irwb = irwib + *n * *nrhs;  // 设置 irwb
        dlaset_("A", n, n, &c_b328, &c_b1034, &rwork[irwu], n);  // 调用 dlaset_ 函数
        dlaset_("A", n, n, &c_b328, &c_b1034, &rwork[irwvt], n);  // 调用 dlaset_ 函数
        dlasdq_("U", &c__0, n, n, n, &c__0, &d__[1], &e[1], &rwork[irwvt], n,
            &rwork[irwu], n, &rwork[irwwrk], &c__1, &rwork[irwwrk], info);  // 调用 dlasdq_ 函数
        if (*info != 0) {
            return 0;    // 返回 0
        }
    }
/*
    j = irwb - 1;
    以 irwb 减一为初始值，初始化循环变量 j。

    i__1 = *nrhs;
    循环次数由参数 nrhs 决定。

    for (jcol = 1; jcol <= i__1; ++jcol) {
        对每个 jcol（列索引）进行循环。

        i__2 = *n;
        循环次数由参数 n 决定。

        for (jrow = 1; jrow <= i__2; ++jrow) {
            对每个 jrow（行索引）进行循环。

            ++j;
            递增 j，用于访问 rwork 数组的下一个位置。

            i__3 = jrow + jcol * b_dim1;
            计算 b 数组中的元素索引，b_dim1 是 b 数组的第一维大小。

            rwork[j] = b[i__3].r;
            将 b 数组中的实部赋值给 rwork 数组的第 j 个位置。
/* L40: */
        }
/* L50: */
    }

    dgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwu], n, &rwork[irwb],
         n, &c_b328, &rwork[irwrb], n);
    调用 BLAS 库中的 DGEMM 函数进行矩阵乘法运算，计算 rwork[irwu]' * rwork[irwb] 存入 rwork[irwrb]。

    j = irwb - 1;
    重新初始化 j。

    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        循环次数由 nrhs 决定。

        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            循环次数由 n 决定。

            ++j;
            递增 j，用于访问 rwork 数组的下一个位置。

            rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
            将 b 数组中的虚部赋值给 rwork 数组的第 j 个位置。
/* L60: */
        }
/* L70: */
    }

    dgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwu], n, &rwork[irwb],
         n, &c_b328, &rwork[irwib], n);
    再次调用 DGEMM 函数进行矩阵乘法运算，计算 rwork[irwu]' * rwork[irwb] 存入 rwork[irwib]。

    jreal = irwrb - 1;
    初始化 jreal 为 irwrb 减一。

    jimag = irwib - 1;
    初始化 jimag 为 irwib 减一。

    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        对每个 jcol 进行循环。

        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            对每个 jrow 进行循环。

            ++jreal;
            递增 jreal，用于访问 rwork 数组的下一个位置。

            ++jimag;
            递增 jimag，用于访问 rwork 数组的下一个位置。

            i__3 = jrow + jcol * b_dim1;
            计算 b 数组中的元素索引。

            i__4 = jreal;
            i__5 = jimag;
            创建复数 z__1，实部为 rwork[i__4]，虚部为 rwork[i__5]。

            b[i__3].r = z__1.r, b[i__3].i = z__1.i;
            将复数 z__1 赋值给 b 数组中的元素。
/* L80: */
        }
/* L90: */
    }

    tol = rcnd * (d__1 = d__[idamax_(n, &d__[1], &c__1)], abs(d__1));
    计算容差 tol，为 rcnd 乘以 d__ 中的最大绝对值。

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        对每个 i 进行循环。

        if (d__[i__] <= tol) {
            如果 d__[i__] 小于或等于 tol，则执行以下操作：

            zlaset_("A", &c__1, nrhs, &c_b56, &c_b56, &b[i__ + b_dim1],
                ldb);
            使用 BLAS 库中的 ZLASET 函数，将 b[i__][1:*nrhs] 设置为零。
        } else {
            如果 d__[i__] 大于 tol，则执行以下操作：

            zlascl_("G", &c__0, &c__0, &d__[i__], &c_b1034, &c__1, nrhs, &
                b[i__ + b_dim1], ldb, info);
            使用 BLAS 库中的 ZLASCL 函数，按比例缩放矩阵 b[i__][1:*nrhs]。
            ++(*rank);
            增加 rank 的计数。
        }
/* L100: */
    }

    j = irwb - 1;
    重新初始化 j。

    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        对每个 jcol 进行循环。

        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            对每个 jrow 进行循环。

            ++j;
            递增 j，用于访问 rwork 数组的下一个位置。

            i__3 = jrow + jcol * b_dim1;
            计算 b 数组中的元素索引。

            rwork[j] = b[i__3].r;
/* L110: */
        }
/* L120: */
    }

    dgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwvt], n, &rwork[irwb],
         n, &c_b328, &rwork[irwrb], n);
    调用 DGEMM 函数进行矩阵乘法运算，计算 rwork[irwvt]' * rwork[irwb] 存入 rwork[irwrb]。

    j = irwb - 1;
    重新初始化 j。

    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        对每个 jcol 进行循环。

        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            对每个 jrow 进行循环。

            ++j;
            递增 j，用于访问 rwork 数组的下一个位置。

            rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
/* L130: */
        }
/* L140: */
    }

    dgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwvt], n, &rwork[irwb],
         n, &c_b328, &rwork[irwib], n);
    再次调用 DGEMM 函数进行矩阵乘法运算，计算 rwork[irwvt]' * rwork[irwb] 存入 rwork[irwib]。

    jreal = irwrb - 1;
    初始化 jreal 为 irwrb 减一。

    jimag = irwib - 1;
    初始化 jimag 为 irwib 减一。

    i__1 = *nrhs;
*/
    // 循环遍历列 jcol，从 1 到 i__1
    for (jcol = 1; jcol <= i__1; ++jcol) {
        // 循环遍历行 jrow，从 1 到 *n
        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            // 递增 jreal 和 jimag 的值
            ++jreal;
            ++jimag;
            // 计算数组 b 中元素的索引，以及 rwork 中数据的索引
            i__3 = jrow + jcol * b_dim1;
            i__4 = jreal;
            i__5 = jimag;
            // 构造复数 z__1，使用 rwork 中的实部和虚部赋值给 b 中对应元素的实部和虚部
            z__1.r = rwork[i__4], z__1.i = rwork[i__5];
            b[i__3].r = z__1.r, b[i__3].i = z__1.i;
    /* 循环遍历所有的子问题 */
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        /* 检查对角线元素和下对角线元素的绝对值是否小于 eps */
        if ((d__1 = e[i__], abs(d__1)) < eps || i__ == nm1) {
            /* 增加子问题计数 */
            ++nsub;
            /* 记录当前子问题的起始索引 */
            iwork[nsub] = st;

            /*
                 找到一个子问题。首先确定其大小，然后
                 对其应用分治算法。
            */

            if (i__ < nm1) {
                /* 对于 E(I) 小于 eps 的情况（其中 I < NM1） */
                nsize = i__ - st + 1;
                /* 记录子问题的大小 */
                iwork[sizei + nsub - 1] = nsize;
            } else if ((d__1 = e[i__], abs(d__1)) >= eps) {
                /* 对于 E(NM1) 不太小的情况，但是 I = NM1 */
                nsize = *n - st + 1;
                /* 记录子问题的大小 */
                iwork[sizei + nsub - 1] = nsize;
            } else {
                /*
                    对于 E(NM1) 很小的情况。这意味着在 D(N) 处有
                    一个 1x1 的子问题，不需要显式解决。
                */
                nsize = i__ - st + 1;
                /* 记录子问题的大小 */
                iwork[sizei + nsub - 1] = nsize;
                /* 增加另一个子问题计数 */
                ++nsub;
                /* 记录一个额外的子问题大小为 1 */
                iwork[nsub] = *n;
                /* 记录该子问题的大小为 1 */
                iwork[sizei + nsub - 1] = 1;
                /* 复制右侧边的向量到工作区 */
                zcopy_(nrhs, &b[*n + b_dim1], ldb, &work[bx + nm1], n);
            }
            /* 计算当前子问题的起始索引 */
            st1 = st - 1;
            if (nsize == 1) {
                /*
                    这是一个 1x1 的子问题，不需要显式解决。
                */
                zcopy_(nrhs, &b[st + b_dim1], ldb, &work[bx + st1], n);
            } else if (nsize <= *smlsiz) {
                /* 对于小型子问题，直接复制右侧边的向量到工作区 */
/*              This is a small subproblem and is solved by DLASDQ. */

/* 
   设置矩阵A的所有元素为常数c_b328，将结果存储在rwork[vt + st1]中
   参数'A'指定设置矩阵所有元素，nsize是矩阵的大小，c_b328是常数值
*/
        dlaset_("A", &nsize, &nsize, &c_b328, &c_b1034, &rwork[vt +
            st1], n);

/* 
   设置矩阵A的所有元素为常数c_b328，将结果存储在rwork[u + st1]中
   参数'A'指定设置矩阵所有元素，nsize是矩阵的大小，c_b328是常数值
*/
        dlaset_("A", &nsize, &nsize, &c_b328, &c_b1034, &rwork[u +
            st1], n);

/* 
   使用DLASDQ处理奇异值分解问题
   参数'U'表示使用标准的SVD方法，nsize是矩阵大小，d__[st]和e[st]是主对角线元素和次对角线元素
   rwork[vt + st1]和rwork[u + st1]是用于存储结果的工作数组
*/
        dlasdq_("U", &c__0, &nsize, &nsize, &nsize, &c__0, &d__[st], &
            e[st], &rwork[vt + st1], n, &rwork[u + st1], n, &
            rwork[nrwork], &c__1, &rwork[nrwork], info);

/* 
   检查DLASDQ运行后的信息状态，如果非零则表示出错
   如果info不为0，则退出当前函数
*/
        if (*info != 0) {
            return 0;
        }

/*
   在实数版本中，B被传递给DLASDQ并在内部与Q'相乘。
   这里B是复数，所以该乘积在下面以两步（实部和虚部）计算。
*/

/* 
   将矩阵B的实部从b数组复制到rwork数组中
   j从irwb - 1开始计数，遍历所有的列和行，将实部存储在rwork数组中
*/
        j = irwb - 1;
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = st + nsize - 1;
            for (jrow = st; jrow <= i__3; ++jrow) {
                ++j;
                i__4 = jrow + jcol * b_dim1;
                rwork[j] = b[i__4].r;
            }
        }

/* 
   使用DGEMM计算矩阵乘积的转置和复数乘法结果
   参数'T'表示转置矩阵，'N'表示不转置矩阵，nsize和nrhs是矩阵的维度，c_b1034和c_b328是常数值
*/
        dgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[u +
            st1], n, &rwork[irwb], &nsize, &c_b328, &rwork[irwrb],
             &nsize);

/* 
   将矩阵B的虚部从b数组复制到rwork数组中
   j从irwb - 1开始计数，遍历所有的列和行，将虚部存储在rwork数组中
*/
        j = irwb - 1;
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = st + nsize - 1;
            for (jrow = st; jrow <= i__3; ++jrow) {
                ++j;
                rwork[j] = d_imag(&b[jrow + jcol * b_dim1]);
            }
        }

/* 
   使用DGEMM计算矩阵乘积的转置和复数乘法结果
   参数'T'表示转置矩阵，'N'表示不转置矩阵，nsize和nrhs是矩阵的维度，c_b1034和c_b328是常数值
*/
        dgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[u +
            st1], n, &rwork[irwb], &nsize, &c_b328, &rwork[irwib],
             &nsize);

/* 
   将实部和虚部重新组合成复数并存储回矩阵B中
   jreal和jimag从irwrb - 1和irwib - 1开始计数，将复数值存储回矩阵B中
*/
        jreal = irwrb - 1;
        jimag = irwib - 1;
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = st + nsize - 1;
            for (jrow = st; jrow <= i__3; ++jrow) {
                ++jreal;
                ++jimag;
                i__4 = jrow + jcol * b_dim1;
                i__5 = jreal;
                i__6 = jimag;
                z__1.r = rwork[i__5], z__1.i = rwork[i__6];
                b[i__4].r = z__1.r, b[i__4].i = z__1.i;
            }
        }

/* 
   将计算后的结果从rwork数组复制回矩阵B中
   参数'A'表示复制整个矩阵，nsize和nrhs是矩阵的维度
*/
        zlacpy_("A", &nsize, nrhs, &b[st + b_dim1], ldb, &work[bx +
            st1], n);
/*              A large problem. Solve it using divide and conquer. */

/* 调用子程序 dlasda_ 处理一个大型问题，使用分治策略解决 */

dlasda_(&icmpq1, smlsiz, &nsize, &sqre, &d__[st], &e[st], &
    rwork[u + st1], n, &rwork[vt + st1], &iwork[k + st1],
    &rwork[difl + st1], &rwork[difr + st1], &rwork[z__ +
    st1], &rwork[poles + st1], &iwork[givptr + st1], &
    iwork[givcol + st1], n, &iwork[perm + st1], &rwork[
    givnum + st1], &rwork[c__ + st1], &rwork[s + st1], &
    rwork[nrwork], &iwork[iwk], info);

/* 检查是否有错误信息，如有错误则返回 */
if (*info != 0) {
    return 0;
}

/* 计算新的偏移量 bxst */
bxst = bx + st1;

/* 调用子程序 zlalsa_ 处理下一个子问题 */
zlalsa_(&icmpq2, smlsiz, &nsize, nrhs, &b[st + b_dim1], ldb, &
    work[bxst], n, &rwork[u + st1], n, &rwork[vt + st1], &
    iwork[k + st1], &rwork[difl + st1], &rwork[difr + st1]
    , &rwork[z__ + st1], &rwork[poles + st1], &iwork[
    givptr + st1], &iwork[givcol + st1], n, &iwork[perm +
    st1], &rwork[givnum + st1], &rwork[c__ + st1], &rwork[
    s + st1], &rwork[nrwork], &iwork[iwk], info);

/* 检查是否有错误信息，如有错误则返回 */
if (*info != 0) {
    return 0;
}

/* 更新 st 的值，准备处理下一个子问题 */
st = i__ + 1;
/* L240: */
}

/*     Apply the singular values and treat the tiny ones as zero. */

/* 应用奇异值，并将太小的奇异值视为零 */

tol = rcnd * (d__1 = d__[idamax_(n, &d__[1], &c__1)], abs(d__1));

i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {

/*
      Some of the elements in D can be negative because 1-by-1
      subproblems were not solved explicitly.
*/

/* D 中的某些元素可能为负数，因为一些 1x1 的子问题未显式求解 */

if ((d__1 = d__[i__], abs(d__1)) <= tol) {
    zlaset_("A", &c__1, nrhs, &c_b56, &c_b56, &work[bx + i__ - 1], n);
} else {
    ++(*rank);
    zlascl_("G", &c__0, &c__0, &d__[i__], &c_b1034, &c__1, nrhs, &
        work[bx + i__ - 1], n, info);
}
d__[i__] = (d__1 = d__[i__], abs(d__1));
/* L250: */
}

/*     Now apply back the right singular vectors. */

/* 现在应用右奇异向量 */

icmpq2 = 1;
i__1 = nsub;
for (i__ = 1; i__ <= i__1; ++i__) {
st = iwork[i__];
st1 = st - 1;
nsize = iwork[sizei + i__ - 1];
bxst = bx + st1;
if (nsize == 1) {
    zcopy_(nrhs, &work[bxst], n, &b[st + b_dim1], ldb);
} else if (nsize <= *smlsiz) {

/*
         Since B and BX are complex, the following call to DGEMM
         is performed in two steps (real and imaginary parts).

         CALL DGEMM( 'T', 'N', NSIZE, NRHS, NSIZE, ONE,
  $                  RWORK( VT+ST1 ), N, RWORK( BXST ), N, ZERO,
  $                  B( ST, 1 ), LDB )
*/

    j = bxst - *n - 1;
    jreal = irwb - 1;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
    j += *n;
    i__3 = nsize;
    for (jrow = 1; jrow <= i__3; ++jrow) {
        ++jreal;
        i__4 = j + jrow;
        rwork[jreal] = work[i__4].r;
/* L260: */
    }
/* L270: */
        }
        // Perform matrix-matrix multiplication with transposed operands
        // using double-precision real numbers.
        dgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[vt + st1],
             n, &rwork[irwb], &nsize, &c_b328, &rwork[irwrb], &nsize);
        // Adjust indices for subsequent computations.
        j = bxst - *n - 1;
        jimag = irwb - 1;
        // Iterate over columns of right-hand side matrix.
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
        j += *n;
        // Iterate over rows of right-hand side matrix.
        i__3 = nsize;
        for (jrow = 1; jrow <= i__3; ++jrow) {
            ++jimag;
            // Compute imaginary part of elements from complex data.
            rwork[jimag] = d_imag(&work[j + jrow]);
/* L280: */
        }
/* L290: */
        }
        // Perform another matrix-matrix multiplication with transposed operands.
        dgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[vt + st1],
             n, &rwork[irwb], &nsize, &c_b328, &rwork[irwib], &nsize);
        // Adjust indices for real and imaginary parts.
        jreal = irwrb - 1;
        jimag = irwib - 1;
        // Iterate over columns of right-hand side matrix.
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
        // Iterate over rows of right-hand side matrix.
        i__3 = st + nsize - 1;
        for (jrow = st; jrow <= i__3; ++jrow) {
            ++jreal;
            ++jimag;
            // Compute complex elements and store in matrix B.
            i__4 = jrow + jcol * b_dim1;
            i__5 = jreal;
            i__6 = jimag;
            z__1.r = rwork[i__5], z__1.i = rwork[i__6];
            b[i__4].r = z__1.r, b[i__4].i = z__1.i;
/* L300: */
        }
/* L310: */
        }
    } else {
        // Call LAPACK routine ZLASLA for singular value decomposition.
        zlalsa_(&icmpq2, smlsiz, &nsize, nrhs, &work[bxst], n, &b[st +
            b_dim1], ldb, &rwork[u + st1], n, &rwork[vt + st1], &
            iwork[k + st1], &rwork[difl + st1], &rwork[difr + st1], &
            rwork[z__ + st1], &rwork[poles + st1], &iwork[givptr +
            st1], &iwork[givcol + st1], n, &iwork[perm + st1], &rwork[
            givnum + st1], &rwork[c__ + st1], &rwork[s + st1], &rwork[
            nrwork], &iwork[iwk], info);
        // Check for errors in LAPACK routine call.
        if (*info != 0) {
        return 0;
        }
    }
/* L320: */
    }

/*     Unscale and sort the singular values. */

    // Rescale singular values based on original norm and sort them.
    dlascl_("G", &c__0, &c__0, &c_b1034, &orgnrm, n, &c__1, &d__[1], n, info);
    // Sort singular values in descending order.
    dlasrt_("D", n, &d__[1], info);
    // Rescale matrix B back to original scale.
    zlascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, n, nrhs, &b[b_offset], ldb,
        info);

    // Return 0 indicating successful completion.

    return 0;

/*     End of ZLALSD */

} /* zlalsd_ */

doublereal zlange_(char *norm, integer *m, integer *n, doublecomplex *a,
    integer *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal ret_val, d__1, d__2;

    /* Local variables */
    static integer i__, j;
    static doublereal sum, scale;
    extern logical lsame_(char *, char *);
    static doublereal value;
    extern /* Subroutine */ int zlassq_(integer *, doublecomplex *, integer *,
         doublereal *, doublereal *);
    ! ZLANGE returns the value
    !
    !    ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
    !             (
    !             ( norm1(A),         NORM = '1', 'O' or 'o'
    !             (
    !             ( normI(A),         NORM = 'I' or 'i'
    !             (
    !             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
    !
    ! where  norm1  denotes the  one norm of a matrix (maximum column sum),
    ! normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    ! normF  denotes the  Frobenius norm of a matrix (square root of sum of
    ! squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    !
    ! Arguments
    ! =========
    !
    ! NORM    (input) CHARACTER*1
    !         Specifies the value to be returned in ZLANGE as described
    !         above.
    !
    ! M       (input) INTEGER
    !         The number of rows of the matrix A.  M >= 0.  When M = 0,
    !         ZLANGE is set to zero.
    !
    ! N       (input) INTEGER
    !         The number of columns of the matrix A.  N >= 0.  When N = 0,
    !         ZLANGE is set to zero.
    !
    ! A       (input) COMPLEX*16 array, dimension (LDA,N)
    !         The m by n matrix A.
    !
    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(M,1).
    !
    ! WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
    !         where LWORK >= M when NORM = 'I'; otherwise, WORK is not
    !         referenced.
    !
    ! =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (min(*m,*n) == 0) {
        value = 0.;
    } else if (lsame_(norm, "M")) {

        /* Find max(abs(A(i,j))). */

        value = 0.;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* Computing MAX */
                d__1 = value, d__2 = z_abs(&a[i__ + j * a_dim1]);
                value = max(d__1,d__2);
                /* L10: */
            }
            /* L20: */
        }
    } else if (lsame_(norm, "O") || *(unsigned char *)
        norm == '1') {

        /* Find norm1(A). */

        value = 0.;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            sum = 0.;
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                sum += z_abs(&a[i__ + j * a_dim1]);
                /* L30: */
            }
            value = max(value,sum);
            /* L40: */
        }
    } else if (lsame_(norm, "I")) {

        /* Find normI(A). */

        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {
            work[i__] = 0.;
            /* L50: */
        }
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                work[i__] += z_abs(&a[i__ + j * a_dim1]);
                /* L60: */
            }
            /* L70: */
        }
        value = 0.;
        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {
            /* Computing MAX */
            d__1 = value, d__2 = work[i__];
            value = max(d__1,d__2);
            /* L80: */
        }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

        /* Find normF(A). */

        scale = 0.;
        sum = 1.;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            zlassq_(m, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
            /* L90: */
        }
        value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of ZLANGE */

} /* zlange_ */

doublereal zlanhe_(char *norm, char *uplo, integer *n, doublecomplex *a,
    integer *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal ret_val, d__1, d__2, d__3;

    /* Local variables */
    static integer i__, j;
    static doublereal sum, absa, scale;
    extern logical lsame_(char *, char *);
    static doublereal value;
    extern /* Subroutine */ int zlassq_(integer *, doublecomplex *, integer *,
         doublereal *, doublereal *);

    /*
       -- LAPACK auxiliary routine (version 3.2) --
       -- LAPACK is a software package provided by Univ. of Tennessee,    --
       -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

       Purpose
       =======

       ZLANHE  returns the value of the one norm,  or the Frobenius norm, or
       the  infinity norm,  or the  element of  largest absolute value  of a
       complex hermitian matrix A.

       Description
       ===========
    */
    ZLANHE returns the value

       ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

    Arguments
    =========

    NORM    (input) CHARACTER*1
            Specifies the value to be returned in ZLANHE as described
            above.

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            hermitian matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, ZLANHE is
            set to zero.

    A       (input) COMPLEX*16 array, dimension (LDA,N)
            The hermitian matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced. Note that the imaginary parts of the diagonal
            elements need not be set and are assumed to be zero.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).

    WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.

   =====================================================================



# ZLANHE函数返回如下值

# ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
#          (
#          ( norm1(A),         NORM = '1', 'O' or 'o'
#          (
#          ( normI(A),         NORM = 'I' or 'i'
#          (
#          ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

# 其中：
# norm1 表示矩阵的一范数（最大列和），
# normI 表示矩阵的无穷范数（最大行和），
# normF 表示矩阵的Frobenius范数（平方和的平方根）。
# max(abs(A(i,j))) 不是一种一致的矩阵范数。

# 参数说明：
# NORM    （输入） 字符串（长度为1）
#         指定ZLANHE返回的值如上所述。

# UPLO    （输入） 字符串（长度为1）
#         指定是引用Hermitian矩阵A的上三角部分还是下三角部分。
#         = 'U': 引用A的上三角部分
#         = 'L': 引用A的下三角部分

# N       （输入） 整数
#         矩阵A的阶数。N >= 0。当N = 0时，ZLANHE设为零。

# A       （输入） 复数数组 COMPLEX*16，维度为(LDA,N)
#         Hermitian矩阵A。如果UPLO = 'U'，则A的前n×n的上三角部分包含矩阵A的上三角部分，
#         并且不引用A的严格下三角部分。如果UPLO = 'L'，则A的前n×n的下三角部分包含矩阵A的下三角部分，
#         并且不引用A的严格上三角部分。注意，对角元素的虚部不需要设置，并假定为零。

# LDA     （输入） 整数
#         数组A的领导维度。LDA >= max(N,1)。

# WORK    （工作空间） 双精度数组，维度为(MAX(1,LWORK))
#         当NORM = 'I' 或 '1' 或 'O' 时，要求 LWORK >= N；否则，不引用WORK。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
        value = 0.;
    } else if (lsame_(norm, "M")) {

        /* Find max(abs(A(i,j))). */

        value = 0.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    d__1 = value, d__2 = z_abs(&a[i__ + j * a_dim1]);
                    value = max(d__1,d__2);
                    /* L10: */
                }
                /* Computing MAX */
                i__2 = j + j * a_dim1;
                d__2 = value, d__3 = (d__1 = a[i__2].r, abs(d__1));
                value = max(d__2,d__3);
                /* L20: */
            }
        } else {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                /* Computing MAX */
                i__2 = j + j * a_dim1;
                d__2 = value, d__3 = (d__1 = a[i__2].r, abs(d__1));
                value = max(d__2,d__3);
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    d__1 = value, d__2 = z_abs(&a[i__ + j * a_dim1]);
                    value = max(d__1,d__2);
                    /* L30: */
                }
                /* L40: */
            }
        }
    } else if (lsame_(norm, "I") || lsame_(norm, "O") || *(unsigned char *)norm == '1') {

        /* Find normI(A) ( = norm1(A), since A is hermitian). */

        value = 0.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = 0.;
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    absa = z_abs(&a[i__ + j * a_dim1]);
                    sum += absa;
                    work[i__] += absa;
                    /* L50: */
                }
                i__2 = j + j * a_dim1;
                work[j] = sum + (d__1 = a[i__2].r, abs(d__1));
                /* L60: */
            }
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                /* Computing MAX */
                d__1 = value, d__2 = work[i__];
                value = max(d__1,d__2);
                /* L70: */
            }
        } else {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                work[i__] = 0.;
                /* L80: */
            }
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j + j * a_dim1;
                sum = work[j] + (d__1 = a[i__2].r, abs(d__1));
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    absa = z_abs(&a[i__ + j * a_dim1]);
                    sum += absa;
                    work[i__] += absa;
                    /* L90: */
                }
                value = max(value,sum);
                /* L100: */
            }
        }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

        /* Find normF(A). */

        scale = 0.;
        sum = 1.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 2; j <= i__1; ++j) {
                i__2 = j - 1;
                zlassq_(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
                /* L110: */
            }
        } else {
            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                zlassq_(&i__2, &a[j + 1 + j * a_dim1], &c__1, &scale, &sum);
                /* L120: */
            }
        }
        sum *= 2;
        i__1 = *n;
        /* Further code lines might follow for this function */
    }
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 循环遍历 i__ 从 1 到 i__1
        i__2 = i__ + i__ * a_dim1;
        // 计算当前元素在数组 a 中的索引 i__2
        if (a[i__2].r != 0.) {
            // 如果数组 a 中索引为 i__2 的实部不为零
            i__2 = i__ + i__ * a_dim1;
            // 再次计算当前元素在数组 a 中的索引 i__2
            absa = (d__1 = a[i__2].r, abs(d__1));
            // 计算当前元素的实部的绝对值，赋给 absa
            if (scale < absa) {
                // 如果 scale 小于 absa
/* Computing 2nd power */
            d__1 = scale / absa;
            sum = sum * (d__1 * d__1) + 1.;
            scale = absa;
        } else {
/* Computing 2nd power */
            d__1 = absa / scale;
            sum += d__1 * d__1;
        }
        }
/* L130: */
    }
    value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of ZLANHE */

} /* zlanhe_ */

/* Subroutine */ int zlaqr0_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublecomplex *h__, integer *ldh,
    doublecomplex *w, integer *iloz, integer *ihiz, doublecomplex *z__,
    integer *ldz, doublecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Local variables */
    static integer i__, k;
    static doublereal s;
    static doublecomplex aa, bb, cc, dd;
    static integer ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
    static doublecomplex tr2, det;
    static integer inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot,
        nmin;
    static doublecomplex swap;
    static integer ktop;
    static doublecomplex zdum[1]    /* was [1][1] */;
    static integer kacc22, itmax, nsmax, nwmax, kwtop;
    extern /* Subroutine */ int zlaqr3_(logical *, logical *, integer *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        integer *, integer *, doublecomplex *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *, integer *,
         doublecomplex *, integer *, integer *, doublecomplex *, integer *
        , doublecomplex *, integer *), zlaqr4_(logical *, logical *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, doublecomplex *, integer *,
         doublecomplex *, integer *, integer *), zlaqr5_(logical *,
        logical *, integer *, integer *, integer *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, integer *, integer *,
         doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, doublecomplex *, integer *,
         integer *, doublecomplex *, integer *);
    static integer nibble;
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static char jbcmpz[2];
    static doublecomplex rtdisc;
    static integer nwupbd;
    static logical sorted;
    extern /* Subroutine */ int zlahqr_(logical *, logical *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         integer *, integer *, doublecomplex *, integer *, integer *),
        zlacpy_(char *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    static integer lwkopt;


/*
*/
    /* 参数调整 */
    // 计算二维数组 h__ 的起始偏移量
    h_dim1 = *ldh;
    // 调整 h__ 数组的起始地址，使其从正确的位置开始访问
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    // 将一维数组 w 调整为从零开始索引
    --w;
    // 计算二维数组 z__ 的起始偏移量
    z_dim1 = *ldz;
    // 调整 z__ 数组的起始地址，使其从正确的位置开始访问
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    // 调整一维数组 work 的起始地址，使其从零开始索引
    --work;

    /* 函数体 */
    // 将 info 设置为零，表示没有错误
    *info = 0;
/*     ==== Quick return for N = 0: nothing to do. ==== */

if (*n == 0) {
/* 设置工作数组中的第一个元素为 (1, 0) ，表示什么也不做。 */
    work[1].r = 1., work[1].i = 0.;
    return 0;
}

if (*n <= 11) {

/*        ==== Tiny matrices must use ZLAHQR. ==== */

/* 计算推荐的工作空间大小为 1 */
lwkopt = 1;
if (*lwork != -1) {
    /* 调用 ZLAHQR 处理小矩阵特例 */
    zlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
        iloz, ihiz, &z__[z_offset], ldz, info);
}
} else {

/*
      ==== Use small bulge multi-shift QR with aggressive early
      .    deflation on larger-than-tiny matrices. ====

      ==== Hope for the best. ====
*/

*info = 0;

/*        ==== Set up job flags for ILAENV. ==== */

if (*wantt) {
    /* 如果要计算 Schur 形式，则设置为 'S' */
    *(unsigned char *)jbcmpz = 'S';
} else {
    /* 否则设置为 'E' */
    *(unsigned char *)jbcmpz = 'E';
}
if (*wantz) {
    /* 如果要计算变换矩阵 Z，则设置为 'V' */
    *(unsigned char *)&jbcmpz[1] = 'V';
} else {
    /* 否则设置为 'N' */
    *(unsigned char *)&jbcmpz[1] = 'N';
}

/*
      ==== NWR = recommended deflation window size.  At this
      .    point,  N .GT. NTINY = 11, so there is enough
      .    subdiagonal workspace for NWR.GE.2 as required.
      .    (In fact, there is enough subdiagonal space for
      .    NWR.GE.3.) ====
*/

/* 调用 ILAENV 获取推荐的 deflation 窗口大小 */
nwr = ilaenv_(&c__13, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
     (ftnlen)2);
nwr = max(2,nwr);
/* 计算 NWR 与 (N-1)/3 的较小值 */
/* 计算 NWR 与 (N-1)/3 的较小值 */
/* 计算 NWR 与 (N-1)/3 的较小值 */
 最小值*/
 2
    # 调用外部函数ilaenv_，传入参数：第一个参数是常量14，第二个参数是字符串"ZLAQR0"，其余参数为变量
    nibble = ilaenv_(&c__14, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    # 将nibble的值设为0和当前nibble值的最大值之间的较大值
    nibble = max(0,nibble);
/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

// 调用 ILAENV 函数获取关于 ZLAQR0 的信息，确定是否在 ttswp 过程中累积反射，并在矩阵乘法过程中使用 2x2 结构。
kacc22 = ilaenv_(&c__16, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
// 确保 kacc22 至少为 0
kacc22 = max(0,kacc22);
// 确保 kacc22 最大为 2
kacc22 = min(2,kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/
// 计算 NWMAX，表示可用于缩减的最大窗口大小，受工作空间限制
i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
nwmax = min(i__1,i__2);
nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/
// 计算 NSMAX，表示可用于同时位移的最大数量，受工作空间限制
i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
nsmax = min(i__1,i__2);
nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

// NDFL 表示从缩减重新开始的迭代计数
ndfl = 1;

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/
// 计算迭代的最大次数上限
i__1 = 10, i__2 = *ihi - *ilo + 1;
itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

// kbot 是当前活动区块的最后一行和列
kbot = *ihi;

/*        ==== Main Loop ==== */

// 主循环，迭代次数为 itmax
i__1 = itmax;
for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

// 如果 kbot 小于 ilo，则跳出循环
if (kbot < *ilo) {
    goto L80;
}

/*           ==== Locate active block ==== */

// 定位当前活动区块的起始位置 ktop
i__2 = *ilo + 1;
for (k = kbot; k >= i__2; --k) {
    i__3 = k + (k - 1) * h_dim1;
    // 如果 h__(k, k-1) 是零，则说明找到了活动区块的边界
    if (h__[i__3].r == 0. && h__[i__3].i == 0.) {
        goto L20;
    }
    // L10 标签：继续循环
}
// 如果未找到边界，则 k 等于 ilo
k = *ilo;
L20:
// ktop 是当前活动区块的起始位置

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

// 计算当前的活动区块大小 nh
nh = kbot - ktop + 1;
// 计算可用于缩减的最大窗口大小
nwupbd = min(nh,nwmax);
// 根据特定情况选择缩减窗口的大小
if (ndfl < 5) {
    nw = min(nwupbd,nwr);
} else {
/* Computing MIN */
/* 计算两个值的最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        }
/* 检查 nw 是否小于 nwmax */
        if (nw < nwmax) {
/* 如果 nw 大于等于 nh - 1，则将 nw 设为 nh */
        if (nw >= nh - 1) {
            nw = nh;
        } else {
/* 计算 kwtop 的值 */
            kwtop = kbot - nw + 1;
/* 比较 h__ 中两个复数的绝对值，根据比较结果决定是否增加 nw 的值 */
            i__2 = kwtop + (kwtop - 1) * h_dim1;
            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
            if ((d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[
                kwtop + (kwtop - 1) * h_dim1]), abs(d__2)) > (
                d__3 = h__[i__3].r, abs(d__3)) + (d__4 = d_imag(&
                h__[kwtop - 1 + (kwtop - 2) * h_dim1]), abs(d__4))
                ) {
            ++nw;
            }
        }
        }
/* 检查 ndfl 是否小于 5 */
        if (ndfl < 5) {
/* 如果是，则将 ndec 设为 -1 */
        ndec = -1;
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 否则，根据 nw 和 ndec 的关系，调整 ndec 的值 */
        ++ndec;
/* 如果 nw - ndec 小于 2，则将 ndec 设为 0 */
        if (nw - ndec < 2) {
            ndec = 0;
        }
/* 减去 ndec 的值 */
        nw -= ndec;
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

/* 将 kv 的值设为 n - nw + 1 */
        kv = *n - nw + 1;
/* 将 kt 的值设为 nw + 1 */
        kt = nw + 1;
/* 将 nho 的值设为 n - nw - 1 - kt + 1 */
        nho = *n - nw - 1 - kt + 1;
/* 将 kwv 的值设为 nw + 2 */
        kwv = nw + 2;
/* 将 nve 的值设为 n - nw - kwv + 1 */
        nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

/* 调用 zlaqr3_ 函数处理矩阵的特征值问题 */
        zlaqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[kv
            + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], ldh, &nve, &
            h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

/* 调整 kbot 的值以反映新的缩减 */
        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

/* 将 ks 设为 kbot - ls + 1 */
        ks = kbot - ls + 1;

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

/* 如果 ld 为 0 或者 ld * 100 小于等于 nw * nibble 且 kbot - ktop + 1 大于 min(nmin,nwmax) */
        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if ZLAQR3
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* 计算 ns 的值 */
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
/* 将 ns 设为计算结果并且使其为偶数 */
        ns = min(i__2,i__3);
        ns -= ns % 2;

/* 计算两个值的最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        }

/* 检查 nw 是否小于 nwmax */
        if (nw < nwmax) {
/* 如果 nw 大于等于 nh - 1，则将 nw 设为 nh */
        if (nw >= nh - 1) {
            nw = nh;
        } else {
/* 计算 kwtop 的值 */
            kwtop = kbot - nw + 1;
/* 比较 h__ 中两个复数的绝对值，根据比较结果决定是否增加 nw 的值 */
            i__2 = kwtop + (kwtop - 1) * h_dim1;
            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
            if ((d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[
                kwtop + (kwtop - 1) * h_dim1]), abs(d__2)) > (
                d__3 = h__[i__3].r, abs(d__3)) + (d__4 = d_imag(&
                h__[kwtop - 1 + (kwtop - 2) * h_dim1]), abs(d__4))
                ) {
            ++nw;
            }
        }
        }

/* 检查 ndfl 是否小于 5 */
        if (ndfl < 5) {
/* 如果是，则将 ndec 设为 -1 */
        ndec = -1;
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 否则，根据 nw 和 ndec 的关系，调整 ndec 的值 */
        ++ndec;
/* 如果 nw - ndec 小于 2，则将 ndec 设为 0 */
        if (nw - ndec < 2) {
            ndec = 0;
        }
/* 减去 ndec 的值 */
        nw -= ndec;
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

/* 将 kv 的值设为 n - nw + 1 */
        kv = *n - nw + 1;
/* 将 kt 的值设为 nw + 1 */
        kt = nw + 1;
/* 将 nho 的值设为 n - nw - 1 - kt + 1 */
        nho = *n - nw - 1 - kt + 1;
/* 将 kwv 的值设为 nw + 2 */
        kwv = nw + 2;
/* 将 nve 的值设为 n - nw - kwv + 1 */
        nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

/* 调用 zlaqr3_ 函数处理矩阵的特征值问题 */
        zlaqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[kv
            + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], ldh, &nve, &
            h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

/* 调整 kbot 的值以反映新的缩减 */
        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

/* 将 ks 设为 kbot - ls + 1 */
        ks = kbot - ls + 1;

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

/* 如果 ld 为 0 或者 ld * 100 小于等于 nw * nibble 且 kbot - ktop + 1 大于 min(nmin,nwmax) */
        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if ZLAQR3
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* 计算 ns 的值 */
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
/* 将 ns 设为计算结果并且使其为偶数 */
        ns = min(i__2,i__3);
        ns -= ns % 2;
/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    ZLAQR3 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
if (ndfl % 6 == 0) {
    // 如果在多个 KEXSH 迭代中没有发生缩小
    ks = kbot - ns + 1;  // 计算 ks 的值
    i__2 = ks + 1;
    for (i__ = kbot; i__ >= i__2; i__ += -2) {
        i__3 = i__;
        i__4 = i__ + i__ * h_dim1;
        i__5 = i__ + (i__ - 1) * h_dim1;
        d__3 = ((d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
            d_imag(&h__[i__ + (i__ - 1) * h_dim1]), abs(
            d__2))) * .75;
        z__1.r = h__[i__4].r + d__3, z__1.i = h__[i__4].i;
        w[i__3].r = z__1.r, w[i__3].i = z__1.i;
        i__3 = i__ - 1;
        i__4 = i__;
        w[i__3].r = w[i__4].r, w[i__3].i = w[i__4].i;
        // 更新 w 数组的值
    }
} else {
/*
                   ==== Got NS/2 or fewer shifts? Use ZLAQR4 or
                   .    ZLAHQR on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
*/
    if (kbot - ks + 1 <= ns / 2) {
        // 如果有 NS/2 或更少的移位，则使用 ZLAQR4 或 ZLAHQR 处理
        ks = kbot - ns + 1;  // 计算 ks 的值
        kt = *n - ns + 1;
        zlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
            h__[kt + h_dim1], ldh);
        // 复制 h__ 的一部分到 h__ 的另一部分
        if (ns > nmin) {
            zlaqr4_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                zdum, &c__1, &work[1], lwork, &inf);
        } else {
            zlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                zdum, &c__1, &inf);
        }
        ks += inf;
        // 更新 ks 的值
/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  Scale to avoid
                      .    overflows, underflows and subnormals.
                      .    (The scale factor S can not be zero,
                      .    because H(KBOT,KBOT-1) is nonzero.) ====
*/
            // 计算矩阵H的底部kbot行的一些特定元素的绝对值和，用于后续的计算
            if (ks >= kbot) {
                // 计算H矩阵中特定位置的元素的绝对值并累加，构成s的值
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                i__3 = kbot + (kbot - 1) * h_dim1;
                i__4 = kbot - 1 + kbot * h_dim1;
                i__5 = kbot + kbot * h_dim1;
                s = (d__1 = h__[i__2].r, abs(d__1)) + (d__2 =
                    d_imag(&h__[kbot - 1 + (kbot - 1) *
                    h_dim1]), abs(d__2)) + ((d__3 = h__[i__3]
                    .r, abs(d__3)) + (d__4 = d_imag(&h__[kbot
                    + (kbot - 1) * h_dim1]), abs(d__4))) + ((
                    d__5 = h__[i__4].r, abs(d__5)) + (d__6 =
                    d_imag(&h__[kbot - 1 + kbot * h_dim1]),
                    abs(d__6))) + ((d__7 = h__[i__5].r, abs(
                    d__7)) + (d__8 = d_imag(&h__[kbot + kbot *
                     h_dim1]), abs(d__8)));
                
                // 计算H矩阵中特定位置的元素与s的比值，并将结果存入复数变量aa, cc, bb, dd
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                aa.r = z__1.r, aa.i = z__1.i;
                i__2 = kbot + (kbot - 1) * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                cc.r = z__1.r, cc.i = z__1.i;
                i__2 = kbot - 1 + kbot * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                bb.r = z__1.r, bb.i = z__1.i;
                i__2 = kbot + kbot * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                dd.r = z__1.r, dd.i = z__1.i;

                // 计算三角矩阵的特定和差的值，并计算行列式的值det
                z__2.r = aa.r + dd.r, z__2.i = aa.i + dd.i;
                z__1.r = z__2.r / 2., z__1.i = z__2.i / 2.;
                tr2.r = z__1.r, tr2.i = z__1.i;
                z__3.r = aa.r - tr2.r, z__3.i = aa.i - tr2.i;
                z__4.r = dd.r - tr2.r, z__4.i = dd.i - tr2.i;
                z__2.r = z__3.r * z__4.r - z__3.i * z__4.i,
                    z__2.i = z__3.r * z__4.i + z__3.i *
                    z__4.r;
                z__5.r = bb.r * cc.r - bb.i * cc.i, z__5.i = bb.r
                    * cc.i + bb.i * cc.r;
                z__1.r = z__2.r - z__5.r, z__1.i = z__2.i -
                    z__5.i;
                det.r = z__1.r, det.i = z__1.i;

                // 计算行列式的平方根，并存入rtdisc变量
                z__2.r = -det.r, z__2.i = -det.i;
                z_sqrt(&z__1, &z__2);
                rtdisc.r = z__1.r, rtdisc.i = z__1.i;

                // 计算特定值并存入w数组中的两个位置
                i__2 = kbot - 1;
                z__2.r = tr2.r + rtdisc.r, z__2.i = tr2.i +
                    rtdisc.i;
                z__1.r = s * z__2.r, z__1.i = s * z__2.i;
                w[i__2].r = z__1.r, w[i__2].i = z__1.i;
                i__2 = kbot;
                z__2.r = tr2.r - rtdisc.r, z__2.i = tr2.i -
                    rtdisc.i;
                z__1.r = s * z__2.r, z__1.i = s * z__2.i;
                w[i__2].r = z__1.r, w[i__2].i = z__1.i;

                // 更新ks的值
                ks = kbot - 1;
            }
            }

            // 如果kbot和ks之差加1大于ns，则执行以下代码
            if (kbot - ks + 1 > ns) {
/*
   ==== Sort the shifts (Helps a little) ====
*/

sorted = FALSE_;
i__2 = ks + 1;
// 从 kbot 向 ks 遍历，对位于 ks 到 kbot 之间的 shifts 进行排序
for (k = kbot; k >= i__2; --k) {
    if (sorted) {
        // 如果已经排序完成，则跳转到 L60 结束循环
        goto L60;
    }
    sorted = TRUE_;
    i__3 = k - 1;
    // 对位于 ks 到 k-1 之间的 shifts 进行冒泡排序
    for (i__ = ks; i__ <= i__3; ++i__) {
        i__4 = i__;
        i__5 = i__ + 1;
        // 检查当前 shift 和下一个 shift 的大小，若需要则交换它们
        if ((d__1 = w[i__4].r, abs(d__1)) + (d__2 = d_imag(&w[i__]), abs(d__2))
            < (d__3 = w[i__5].r, abs(d__3)) + (d__4 = d_imag(&w[i__ + 1]), abs(d__4))) {
            sorted = FALSE_;
            // 交换 w[i__] 和 w[i__+1]
            i__4 = i__;
            swap.r = w[i__4].r, swap.i = w[i__4].i;
            i__4 = i__;
            i__5 = i__ + 1;
            w[i__4].r = w[i__5].r, w[i__4].i = w[i__5].i;
            w[i__ + 1].r = swap.r, w[i__ + 1].i = swap.i;
        }
        // 继续下一个 shift 的比较
    }
    // 继续下一个 k 的排序
}

L60:
// 排序结束的标签

/*
   ==== If there are only two shifts, then use only one. ====
*/

if (kbot - ks + 1 == 2) {
    // 如果只有两个 shifts，则选择其中一个
    i__2 = kbot;
    i__3 = kbot + kbot * h_dim1;
    z__2.r = w[i__2].r - h__[i__3].r, z__2.i = w[i__2].i - h__[i__3].i;
    z__1.r = z__2.r, z__1.i = z__2.i;
    i__4 = kbot - 1;
    i__5 = kbot + kbot * h_dim1;
    z__4.r = w[i__4].r - h__[i__5].r, z__4.i = w[i__4].i - h__[i__5].i;
    z__3.r = z__4.r, z__3.i = z__4.i;
    if ((d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1), abs(d__2))
        < (d__3 = z__3.r, abs(d__3)) + (d__4 = d_imag(&z__3), abs(d__4))) {
        // 保留 kbot 的 shift，删除 kbot-1 的 shift
        i__2 = kbot - 1;
        i__3 = kbot;
        w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
    } else {
        // 保留 kbot-1 的 shift，删除 kbot 的 shift
        i__2 = kbot;
        i__3 = kbot - 1;
        w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
    }
}

/*
   ==== Use up to NS of the smallest magnitude shifts. ====
   ==== If there aren't NS shifts available, use them all, possibly dropping one to make the number of shifts even. ====
*/

// 计算最小值，确定要使用的 shifts 数量
i__2 = ns, i__3 = kbot - ks + 1;
ns = min(i__2, i__3);
// 将 ns 调整为偶数
ns -= ns % 2;
// 更新 ks，确定最终要处理的 shifts 范围
ks = kbot - ns + 1;
/*
                ==== Small-bulge multi-shift QR sweep:
                .    split workspace under the subdiagonal into
                .    - a KDU-by-KDU work array U in the lower
                .      left-hand-corner,
                .    - a KDU-by-at-least-KDU-but-more-is-better
                .      (KDU-by-NHo) horizontal work array WH along
                .      the bottom edge,
                .    - and an at-least-KDU-but-more-is-better-by-KDU
                .      (NVE-by-KDU) vertical work WV arrow along
                .      the left-hand-edge. ====
*/

        kdu = ns * 3 - 3;  // 计算 KDU 的大小
        ku = *n - kdu + 1;  // 计算 ku 的起始位置
        kwh = kdu + 1;  // 计算 kwh 的起始位置
        nho = *n - kdu - 3 - (kdu + 1) + 1;  // 计算 nho 的大小
        kwv = kdu + 4;  // 计算 kwv 的起始位置
        nve = *n - kdu - kwv + 1;  // 计算 nve 的大小

/*              ==== Small-bulge multi-shift QR sweep ==== */

        zlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks], &
            h__[h_offset], ldh, iloz, ihiz, &z__[z_offset], ldz, &
            work[1], &c__3, &h__[ku + h_dim1], ldh, &nve, &h__[
            kwv + h_dim1], ldh, &nho, &h__[ku + kwh * h_dim1],
            ldh);
        }

/*           ==== Note progress (or the lack of it). ==== */

        if (ld > 0) {  // 如果 ld 大于 0
        ndfl = 1;  // 设置 ndfl 为 1
        } else {  // 否则
        ++ndfl;  // ndfl 自增
        }

/*
             ==== End of main loop ====
   L70:
*/
    }

/*
          ==== Iteration limit exceeded.  Set INFO to show where
          .    the problem occurred and exit. ====
*/

    *info = kbot;  // 将 kbot 赋值给 info
L80:
    ;
    }

/*     ==== Return the optimal value of LWORK. ==== */

    d__1 = (doublereal) lwkopt;  // 转换 lwkopt 到双精度浮点数
    z__1.r = d__1, z__1.i = 0.;  // 构造复数 z__1
    work[1].r = z__1.r, work[1].i = z__1.i;  // 将 z__1 赋值给 work[1]

/*     ==== End of ZLAQR0 ==== */

    return 0;  // 返回 0 表示正常结束
} /* zlaqr0_ */

/* Subroutine */ int zlaqr1_(integer *n, doublecomplex *h__, integer *ldh,
    doublecomplex *s1, doublecomplex *s2, doublecomplex *v)
{
    /* System generated locals */
    integer h_dim1, h_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Local variables */
    static doublereal s;
    static doublecomplex h21s, h31s;


/*
    -- LAPACK auxiliary routine (version 3.2) --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
       November 2006


         Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a
         scalar multiple of the first column of the product

         (*)  K = (H - s1*I)*(H - s2*I)

         scaling to avoid overflows and most underflows.

         This is useful for starting double implicit shift bulges
         in the QR algorithm.


         N      (input) integer
                Order of the matrix H. N must be either 2 or 3.
                矩阵 H 的阶数 N。N 必须是 2 或 3。

         H      (input) COMPLEX*16 array of dimension (LDH,N)
                The 2-by-2 or 3-by-3 matrix H in (*).
                维度为 (LDH,N) 的 COMPLEX*16 数组，存储着矩阵 H 的内容。

         LDH    (input) integer
                The leading dimension of H as declared in
                the calling procedure.  LDH.GE.N
                H 的前导维度，即在调用过程中声明的维度。LDH 必须大于等于 N。

         S1     (input) COMPLEX*16
         S2     S1 and S2 are the shifts defining K in (*) above.
                S1 和 S2 是定义 K 的偏移量。

         V      (output) COMPLEX*16 array of dimension N
                A scalar multiple of the first column of the
                matrix K in (*).
                维度为 N 的 COMPLEX*16 数组，存储着矩阵 K 的第一列的标量倍数。
       
       ================================================================
       Based on contributions by
          Karen Braman and Ralph Byers, Department of Mathematics,
          University of Kansas, USA

       ================================================================
    /* Parameter adjustments */
    // 对参数进行调整，确保正确访问数组
    h_dim1 = *ldh;
    // 计算偏移量，h__ 是一个复数数组，这里将其偏移设置为1
    h_offset = 1 + h_dim1;
    // 对 h__ 数组进行偏移，使得索引从1开始
    h__ -= h_offset;
    // 减少 v 数组的索引，使其从1开始而不是从0开始
    --v;

    /* Function Body */
    // 如果 n 等于 2
    if (*n == 2) {
        // 计算矩阵的一些特定值，用于后续的计算
        i__1 = h_dim1 + 1;
        z__2.r = h__[i__1].r - s2->r, z__2.i = h__[i__1].i - s2->i;
        z__1.r = z__2.r, z__1.i = z__2.i;
        i__2 = h_dim1 + 2;
        // 计算 s 的值，用于条件判断
        s = (d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1), abs(d__2)) + (
            (d__3 = h__[i__2].r, abs(d__3)) + (d__4 = d_imag(&h__[h_dim1
            + 2]), abs(d__4)));
        // 如果 s 为 0，则设置 v[1] 和 v[2] 的实部和虚部为 0
        if (s == 0.) {
            v[1].r = 0., v[1].i = 0.;
            v[2].r = 0., v[2].i = 0.;
        } else {
            // 否则，进行复杂计算以设置 v[1] 和 v[2] 的值
            i__1 = h_dim1 + 2;
            z__1.r = h__[i__1].r / s, z__1.i = h__[i__1].i / s;
            h21s.r = z__1.r, h21s.i = z__1.i;
            i__1 = (h_dim1 << 1) + 1;
            z__2.r = h21s.r * h__[i__1].r - h21s.i * h__[i__1].i, z__2.i =
                h21s.r * h__[i__1].i + h21s.i * h__[i__1].r;
            i__2 = h_dim1 + 1;
            z__4.r = h__[i__2].r - s1->r, z__4.i = h__[i__2].i - s1->i;
            i__3 = h_dim1 + 1;
            z__6.r = h__[i__3].r - s2->r, z__6.i = h__[i__3].i - s2->i;
            z__5.r = z__6.r / s, z__5.i = z__6.i / s;
            z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r *
                z__5.i + z__4.i * z__5.r;
            z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
            v[1].r = z__1.r, v[1].i = z__1.i;
            i__1 = h_dim1 + 1;
            i__2 = (h_dim1 << 1) + 2;
            z__4.r = h__[i__1].r + h__[i__2].r, z__4.i = h__[i__1].i + h__[
                i__2].i;
            z__3.r = z__4.r - s1->r, z__3.i = z__4.i - s1->i;
            z__2.r = z__3.r - s2->r, z__2.i = z__3.i - s2->i;
            z__1.r = h21s.r * z__2.r - h21s.i * z__2.i, z__1.i = h21s.r *
                z__2.i + h21s.i * z__2.r;
            v[2].r = z__1.r, v[2].i = z__1.i;
        }
    } else {
        // 否则，如果 n 不等于 2，则进行另一种计算方式
        i__1 = h_dim1 + 1;
        z__2.r = h__[i__1].r - s2->r, z__2.i = h__[i__1].i - s2->i;
        z__1.r = z__2.r, z__1.i = z__2.i;
        i__2 = h_dim1 + 2;
        i__3 = h_dim1 + 3;
        // 计算 s 的值，用于条件判断
        s = (d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1), abs(d__2)) + (
            (d__3 = h__[i__2].r, abs(d__3)) + (d__4 = d_imag(&h__[h_dim1
            + 2]), abs(d__4))) + ((d__5 = h__[i__3].r, abs(d__5)) + (d__6
            = d_imag(&h__[h_dim1 + 3]), abs(d__6)));
        // 如果 s 为 0，则设置 v[1]、v[2] 和 v[3] 的实部和虚部为 0
        if (s == 0.) {
            v[1].r = 0., v[1].i = 0.;
            v[2].r = 0., v[2].i = 0.;
            v[3].r = 0., v[3].i = 0.;
        } else {
            // 否则，进行复杂计算以设置 v[1]、v[2] 和 v[3] 的值
            // 这部分计算与 n == 2 的情况下类似，但是涉及到更多的元素
            // 略...
        }
    }
    // 如果条件成立，执行以下代码块；否则执行下一个代码块
    } else {
        // 计算数组索引 h_dim1 + 2 处的复数除以标量 s 的结果，并将结果赋给 h21s
        i__1 = h_dim1 + 2;
        z__1.r = h__[i__1].r / s, z__1.i = h__[i__1].i / s;
        h21s.r = z__1.r, h21s.i = z__1.i;
        
        // 计算数组索引 h_dim1 + 3 处的复数除以标量 s 的结果，并将结果赋给 h31s
        i__1 = h_dim1 + 3;
        z__1.r = h__[i__1].r / s, z__1.i = h__[i__1].i / s;
        h31s.r = z__1.r, h31s.i = z__1.i;
        
        // 计算数组索引 h_dim1 + 1 处的复数与 s1 和 s2 复数的差值，并将结果存储在 z__4 中
        i__1 = h_dim1 + 1;
        z__4.r = h__[i__1].r - s1->r, z__4.i = h__[i__1].i - s1->i;
        
        // 计算数组索引 h_dim1 + 1 处的复数与 s2 复数的差值，并将结果除以标量 s，存储在 z__5 中
        i__2 = h_dim1 + 1;
        z__6.r = h__[i__2].r - s2->r, z__6.i = h__[i__2].i - s2->i;
        z__5.r = z__6.r / s, z__5.i = z__6.i / s;
        
        // 计算 z__4 和 z__5 的乘积，结果存储在 z__3 中
        z__3.r = z__4.r * z__5.r - z__4.i * z__5.i, z__3.i = z__4.r * z__5.i + z__4.i * z__5.r;
        
        // 计算数组索引 (h_dim1 << 1) + 1 处的复数与 h21s 的乘积，并将结果存储在 z__7 中
        i__3 = (h_dim1 << 1) + 1;
        z__7.r = h__[i__3].r * h21s.r - h__[i__3].i * h21s.i, z__7.i = h__[i__3].r * h21s.i + h__[i__3].i * h21s.r;
        
        // 计算 z__3 和 z__7 的和，并将结果存储在 z__2 中
        z__2.r = z__3.r + z__7.r, z__2.i = z__3.i + z__7.i;
        
        // 计算数组索引 h_dim1 * 3 + 1 处的复数与 h31s 的乘积，并将结果存储在 z__8 中
        i__4 = h_dim1 * 3 + 1;
        z__8.r = h__[i__4].r * h31s.r - h__[i__4].i * h31s.i, z__8.i = h__[i__4].r * h31s.i + h__[i__4].i * h31s.r;
        
        // 计算 z__2 和 z__8 的和，并将结果存储在 z__1 中
        z__1.r = z__2.r + z__8.r, z__1.i = z__2.i + z__8.i;
        
        // 将 z__1 的值赋给数组索引为 1 的复数向量 v
        v[1].r = z__1.r, v[1].i = z__1.i;
        
        // 计算数组索引 h_dim1 + 1 和 (h_dim1 << 1) + 2 处的复数之和，并与 s1、s2 的差值相减，结果存储在 z__4 中
        i__1 = h_dim1 + 1;
        i__2 = (h_dim1 << 1) + 2;
        z__5.r = h__[i__1].r + h__[i__2].r, z__5.i = h__[i__1].i + h__[i__2].i;
        z__4.r = z__5.r - s1->r, z__4.i = z__5.i - s1->i;
        z__3.r = z__4.r - s2->r, z__3.i = z__4.i - s2->i;
        
        // 计算 z__3 和 h21s 的乘积，并将结果存储在 z__2 中
        z__2.r = h21s.r * z__3.r - h21s.i * z__3.i, z__2.i = h21s.r * z__3.i + h21s.i * z__3.r;
        
        // 计算数组索引 h_dim1 * 3 + 2 处的复数与 h31s 的乘积，并将结果存储在 z__6 中
        i__3 = h_dim1 * 3 + 2;
        z__6.r = h__[i__3].r * h31s.r - h__[i__3].i * h31s.i, z__6.i = h__[i__3].r * h31s.i + h__[i__3].i * h31s.r;
        
        // 计算 z__2 和 z__6 的和，并将结果存储在 z__1 中
        z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
        
        // 将 z__1 的值赋给数组索引为 2 的复数向量 v
        v[2].r = z__1.r, v[2].i = z__1.i;
        
        // 计算数组索引 h_dim1 + 1 和 h_dim1 * 3 + 3 处的复数之和，并与 s1、s2 的差值相减，结果存储在 z__4 中
        i__1 = h_dim1 + 1;
        i__2 = h_dim1 * 3 + 3;
        z__5.r = h__[i__1].r + h__[i__2].r, z__5.i = h__[i__1].i + h__[i__2].i;
        z__4.r = z__5.r - s1->r, z__4.i = z__5.i - s1->i;
        z__3.r = z__4.r - s2->r, z__3.i = z__4.i - s2->i;
        
        // 计算 z__3 和 h31s 的乘积，并将结果存储在 z__2 中
        z__2.r = h31s.r * z__3.r - h31s.i * z__3.i, z__2.i = h31s.r * z__3.i + h31s.i * z__3.r;
        
        // 计算数组索引 (h_dim1 << 1) + 3 和 h21s 的乘积，并将结果存储在 z__6 中
        i__3 = (h_dim1 << 1) + 3;
        z__6.r = h21s.r * h__[i__3].r - h21s.i * h__[i__3].i, z__6.i = h21s.r * h__[i__3].i + h21s.i * h__[i__3].r;
        
        // 计算 z__2 和 z__6 的和，并将结果存储在 z__1 中
        z__1.r = z__2.r + z__6.r, z__1.i = z__2.i + z__6.i;
        
        // 将 z__1 的值赋给数组索引为 3 的复数向量 v
        v[3].r = z__1.r, v[3].i = z__1.i;
    }
    }
    // 返回值 0，表示函数执行完毕
    return 0;
} /* zlaqr1_ */

/* Subroutine */ int zlaqr2_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, doublecomplex *h__,
    integer *ldh, integer *iloz, integer *ihiz, doublecomplex *z__,
    integer *ldz, integer *ns, integer *nd, doublecomplex *sh,
    doublecomplex *v, integer *ldv, integer *nh, doublecomplex *t,
    integer *ldt, integer *nv, doublecomplex *wv, integer *ldwv,
    doublecomplex *work, integer *lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;
    doublecomplex z__1, z__2;

    /* Local variables */
    static integer i__, j;  // 声明整型变量 i 和 j
    static doublecomplex s;  // 声明复数变量 s
    static integer jw;  // 声明整型变量 jw
    static doublereal foo;  // 声明双精度实数变量 foo
    static integer kln;  // 声明整型变量 kln
    static doublecomplex tau;  // 声明复数变量 tau
    static integer knt;  // 声明整型变量 knt
    static doublereal ulp;  // 声明双精度实数变量 ulp
    static integer lwk1, lwk2;  // 声明整型变量 lwk1 和 lwk2
    static doublecomplex beta;  // 声明复数变量 beta
    static integer kcol, info, ifst, ilst, ltop, krow;  // 声明整型变量 kcol, info, ifst, ilst, ltop, krow
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *);  // 外部函数声明
    static integer infqr;  // 声明整型变量 infqr
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);  // 外部函数声明
    static integer kwtop;  // 声明整型变量 kwtop
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);  // 外部函数声明
    static doublereal safmin, safmax;  // 声明双精度实数变量 safmin 和 safmax
    extern /* Subroutine */ int zgehrd_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *), zlarfg_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *), zlahqr_(logical *,
        logical *, integer *, integer *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *, integer *, doublecomplex *,
         integer *, integer *);  // 外部函数声明
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *),
        zlaset_(char *, integer *, integer *, doublecomplex *,
        doublecomplex *, doublecomplex *, integer *);  // 外部函数声明
    static doublereal smlnum;  // 声明双精度实数变量 smlnum
    extern /* Subroutine */ int ztrexc_(char *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *, integer *, integer *,
        integer *);  // 外部函数声明
    static integer lwkopt;  // 声明整型变量 lwkopt
    extern /* Subroutine */ int zunmhr_(char *, char *, integer *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         doublecomplex *, integer *, doublecomplex *, integer *, integer *
        );  // 外部函数声明

/*
    # LAPACK辅助例程（版本3.2.1）
    # 田纳西大学，加利福尼亚大学伯克利分校，科罗拉多丹佛大学和NAG有限公司。
`
    /* Parameter adjustments */
    h_dim1 = *ldh;  // 设置维数为 ldh 的 h 的第一维
    h_offset = 1 + h_dim1;  // 计算 h 的偏移量
    h__ -= h_offset;  // 调整 h 指针位置以适应偏移量
    z_dim1 = *ldz;  // 设置维数为 ldz 的 z 的第一维
    z_offset = 1 + z_dim1;  // 计算 z 的偏移量
    z__ -= z_offset;  // 调整 z 指针位置以适应偏移量
    --sh;  // 将 sh 指针向前移动一个位置
    v_dim1 = *ldv;  // 设置维数为 ldv 的 v 的第一维
    v_offset = 1 + v_dim1;  // 计算 v 的偏移量
    v -= v_offset;  // 调整 v 指针位置以适应偏移量
    t_dim1 = *ldt;  // 设置维数为 ldt 的 t 的第一维
    t_offset = 1 + t_dim1;  // 计算 t 的偏移量
    t -= t_offset;  // 调整 t 指针位置以适应偏移量
    wv_dim1 = *ldwv;  // 设置维数为 ldwv 的 wv 的第一维
    wv_offset = 1 + wv_dim1;  // 计算 wv 的偏移量
    wv -= wv_offset;  // 调整 wv 指针位置以适应偏移量
    --work;  // 将 work 指针向前移动一个位置

    /* Function Body */
    /* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;  // 计算 *nw 和 (*kbot - *ktop + 1) 的最小值
    jw = min(i__1,i__2);  // 将较小的值赋给 jw
    if (jw <= 2) {  // 如果 jw 小于等于 2
        lwkopt = 1;  // 设置 lwkopt 为 1
    } else {
        /* ==== Workspace query call to ZGEHRD ==== */

        i__1 = jw - 1;  // 计算 jw - 1
        zgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
            c_n1, &info);  // 调用 ZGEHRD 函数进行工作空间查询
        lwk1 = (integer) work[1].r;  // 获取工作空间大小并赋给 lwk1

        /* ==== Workspace query call to ZUNMHR ==== */

        i__1 = jw - 1;  // 计算 jw - 1
        zunmhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[1], &c_n1, &info);  // 调用 ZUNMHR 函数进行工作空间查询
        lwk2 = (integer) work[1].r;  // 获取工作空间大小并赋给 lwk2

        /* ==== Optimal workspace ==== */

        lwkopt = jw + max(lwk1,lwk2);  // 计算最优工作空间大小
    }

    /* ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {  // 如果输入的工作空间大小为 -1，表示查询工作空间
        d__1 = (doublereal) lwkopt;  // 将最优工作空间大小转换为双精度
        z__1.r = d__1, z__1.i = 0.;  // 构造复数返回结果
        work[1].r = z__1.r, work[1].i = z__1.i;  // 将结果放入 work 数组中
        return 0;  // 返回 0 表示成功
    }

    /*
       ==== Nothing to do ...
       ... for an empty active block ... ====
    */
    *ns = 0;  // 将 ns 设置为 0
    *nd = 0;  // 将 nd 设置为 0
    work[1].r = 1., work[1].i = 0.;  // 将 work[1] 设置为 (1,0)
    if (*ktop > *kbot) {  // 如果 ktop 大于 kbot
        return 0;  // 返回 0 表示成功
    }
    /*     ... nor for an empty deflation window. ==== */
    if (*nw < 1) {  // 如果 nw 小于 1
        return 0;  // 返回 0 表示成功
    }

    /* ==== Machine constants ==== */

    safmin = SAFEMINIMUM;  // 设置 safmin 为安全最小值
    safmax = 1. / safmin;  // 设置 safmax 为 safmin 的倒数
    dlabad_(&safmin, &safmax);  // 调用 dlabad_ 函数处理 safmin 和 safmax
    ulp = PRECISION;  // 设置 ulp 为精度值
    smlnum = safmin * ((doublereal) (*n) / ulp);  // 计算 smlnum

    /*
       ==== Setup deflation window ====

       Computing MIN
    */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;  // 计算 *nw 和 (*kbot - *ktop + 1) 的最小值
    jw = min(i__1,i__2);  // 将较小的值赋给 jw
    kwtop = *kbot - jw + 1;  // 计算 kwtop
    if (kwtop == *ktop) {  // 如果 kwtop 等于 ktop
        s.r = 0., s.i = 0.;  // 设置 s 为 (0,0)
    } else {
        i__1 = kwtop + (kwtop - 1) * h_dim1;  // 计算 h 的索引
        s.r = h__[i__1].r, s.i = h__[
/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/

// 将矩阵转换为尖锐-三角形式。在QR分解出现稀有失败的情况下，此例程继续使用部分收缩窗口进行积极的早期缩小，这部分窗口使用INFQR追踪。
zlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
    ldt);
// 复制上三角部分到矩阵t中
i__1 = jw - 1;
i__2 = *ldh + 1;
i__3 = *ldt + 1;
zcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
    i__3);

// 将v矩阵初始化为单位矩阵
zlaset_("A", &jw, &jw, &c_b56, &c_b57, &v[v_offset], ldv);
// 使用双步QR方法计算特征值
zlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[kwtop],
    &c__1, &jw, &v[v_offset], ldv, &infqr);

/*     ==== Deflation detection loop ==== */

// 设置已收缩的特征值数量
*ns = jw;
// 初始化已收缩的特征值列表
ilst = infqr + 1;
// 开始检测是否有进一步的收缩
i__1 = jw;
for (knt = infqr + 1; knt <= i__1; ++knt) {

/*        ==== Small spike tip deflation test ==== */

// 计算当前特征值的大小
i__2 = *ns + *ns * t_dim1;
foo = (d__1 = t[i__2].r, abs(d__1)) + (d__2 = d_imag(&t[*ns + *ns *
    t_dim1]), abs(d__2));
if (foo == 0.) {
    foo = (d__1 = s.r, abs(d__1)) + (d__2 = d_imag(&s), abs(d__2));
}
// 计算判定值，以检测特征值是否收敛
i__2 = *ns * v_dim1 + 1;
/* Computing MAX */
d__5 = smlnum, d__6 = ulp * foo;
if (((d__1 = s.r, abs(d__1)) + (d__2 = d_imag(&s), abs(d__2))) * ((
    d__3 = v[i__2].r, abs(d__3)) + (d__4 = d_imag(&v[*ns * v_dim1
    + 1]), abs(d__4))) <= max(d__5,d__6)) {

/*           ==== One more converged eigenvalue ==== */

    --(*ns);
} else {

/*
             ==== One undeflatable eigenvalue.  Move it up out of the
             .    way.   (ZTREXC can not fail in this case.) ====
*/

    ifst = *ns;
    ztrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &
        ilst, &info);
    ++ilst;
}
/* L10: */
}

/*        ==== Return to Hessenberg form ==== */

// 如果没有剩余的未收敛特征值，则清空s
if (*ns == 0) {
s.r = 0., s.i = 0.;
}

// 如果有未收敛的特征值，则对T矩阵的对角线进行排序，以提高精度
if (*ns < jw) {

/*
          ==== sorting the diagonal of T improves accuracy for
          .    graded matrices.  ====
*/

i__1 = *ns;
for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    ifst = i__;
    i__2 = *ns;
    for (j = i__ + 1; j <= i__2; ++j) {
    i__3 = j + j * t_dim1;
    i__4 = ifst + ifst * t_dim1;
    if ((d__1 = t[i__3].r, abs(d__1)) + (d__2 = d_imag(&t[j + j *
        t_dim1]), abs(d__2)) > (d__3 = t[i__4].r, abs(d__3))
        + (d__4 = d_imag(&t[ifst + ifst * t_dim1]), abs(d__4))
        ) {
        ifst = j;
    }
    /* L20: */
    }
    ilst = i__;
    if (ifst != ilst) {
    ztrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
         &ilst, &info);
    }
    /* L30: */
}
}

/*     ==== Restore shift/eigenvalue array from T ==== */

// 将T矩阵中的特征值复制回sh数组
i__1 = jw;
for (i__ = infqr + 1; i__ <= i__1; ++i__) {
i__2 = kwtop + i__ - 1;
i__3 = i__ + i__ * t_dim1;
sh[i__2].r = t[i__3].r, sh[i__2].i = t[i__3].i;
/* L40: */
}
    # 如果 ns 小于 jw 或者 s 的实部和虚部都为0，则执行以下代码块
    if (*ns < jw || s.r == 0. && s.i == 0.) {
    
    # 如果 ns 大于1并且 s 的实部或虚部不同时为0，则执行以下代码块
    if (*ns > 1 && (s.r != 0. || s.i != 0.)) {
/*           ==== Reflect spike back into lower triangle ==== */

        zcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        ! 复制向量 v 到工作数组 work
        i__1 = *ns;
        do i__ = 1, i__1
        ! 循环处理每个元素
        i__2 = i__;
        d_cnjg(&z__1, &work[i__]);
        ! 计算共轭复数
        work[i__2].r = z__1.r, work[i__2].i = z__1.i;
        ! 更新工作数组中的值为其共轭复数
/* L50: */
        end do
        ! 循环结束
        beta.r = work[1].r, beta.i = work[1].i;
        ! 设置 beta 为工作数组第一个元素的值
        zlarfg_(ns, &beta, &work[2], &c__1, &tau);
        ! 计算 Householder 变换，更新 beta 和 work[2]
        work[1].r = 1., work[1].i = 0.;
        ! 将工作数组第一个元素设置为 (1, 0)

        i__1 = jw - 2;
        i__2 = jw - 2;
        zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &t[t_dim1 + 3], ldt);
        ! 设置矩阵 t 的下三角（不含对角线）为常数 c_b56

        d_cnjg(&z__1, &tau);
        ! 计算 tau 的共轭复数
        zlarf_("L", ns, &jw, &work[1], &c__1, &z__1, &t[t_offset], ldt, &
            work[jw + 1]);
        ! 对 t 的左边进行 Householder 变换
        zlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        ! 对 t 的右边进行 Householder 变换
        zlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);
        ! 对 v 的右边进行 Householder 变换

        i__1 = *lwork - jw;
        zgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
        ! 计算分解 HRD (reduce) 对 t 进行实对称矩阵的 Householder 形式

    }

/*        ==== Copy updated reduced window into place ==== */

    if (kwtop > 1) {
        i__1 = kwtop + (kwtop - 1) * h_dim1;
        d_cnjg(&z__2, &v[v_dim1 + 1]);
        z__1.r = s.r * z__2.r - s.i * z__2.i, z__1.i = s.r * z__2.i + s.i
            * z__2.r;
        h__[i__1].r = z__1.r, h__[i__1].i = z__1.i;
        ! 更新 h 的值
    }
    zlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    ! 复制 t 的上三角部分到 h 的对应位置
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    zcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);
    ! 复制 t 的严格上三角部分到 h 的对应位置

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    if (*ns > 1 && (s.r != 0. || s.i != 0.)) {
        i__1 = *lwork - jw;
        zunmhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
        ! 应用 Householder 变换积累正交矩阵
    }

/*        ==== Update vertical slab in H ==== */

    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    ! 设置 ltop 的值
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
    ! 循环处理每个 krow
/* Computing MIN */
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
        ! 计算 kln 的最小值
        zgemm_("N", "N", &kln, &jw, &jw, &c_b57, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b56, &wv[wv_offset],
            ldwv);
        ! 计算矩阵乘积
        zlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
        ! 复制结果到 h 的相应位置
/* L60: */
    }

/*        ==== Update horizontal slab in H ==== */

    if (*wantt) {
        i__2 = *n;
        i__1 = *nh;
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
        ! 循环处理每个 kcol
/* Computing MIN */
/* 计算最小值 */
i__3 = *nh, i__4 = *n - kcol + 1;
kln = min(i__3,i__4);
/* 计算 kln，其值为 *nh 和 (*n - kcol + 1) 的最小值 */

zgemm_("C", "N", &jw, &kln, &jw, &c_b57, &v[v_offset], ldv, &
    h__[kwtop + kcol * h_dim1], ldh, &c_b56, &t[t_offset],
    ldt);
/* 执行矩阵乘法运算，计算 t = c_b57 * v^H * h，其中 v^H 是 v 的共轭转置 */

zlacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
    h_dim1], ldh);
/* 将 t 的内容复制到 h 的指定部分 */

/* L70: */
}

/* ==== Update vertical slab in Z ==== */
/* ==== 更新 Z 中的垂直片段 ==== */

if (*wantz) {
/* 如果要计算 Z 矩阵 */
    i__1 = *ihiz;
    i__2 = *nv;
    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
         i__2) {
        /* Computing MIN */
        /* 计算最小值 */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
        kln = min(i__3,i__4);
        /* 计算 kln，其值为 *nv 和 (*ihiz - krow + 1) 的最小值 */

        zgemm_("N", "N", &kln, &jw, &jw, &c_b57, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b56, &wv[
            wv_offset], ldwv);
        /* 执行矩阵乘法运算，计算 wv = c_b57 * z * v */

        zlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
        /* 将 wv 的内容复制到 z 的指定部分 */

        /* L80: */
    }
}

/* ==== Return the number of deflations ... ==== */
/* ==== 返回失效数的数量 ... ==== */

*nd = jw - *ns;
/* 计算并返回失效数量 */

/*
   ==== ... and the number of shifts. (Subtracting
   .    INFQR from the spike length takes care
   .    of the case of a rare QR failure while
   .    calculating eigenvalues of the deflation
   .    window.)  ====
*/
/* ... 以及移位的数量。减去 INFQR 可以处理稀有情况下 QR 失败的情况，同时计算出失效窗口的特征值。 */

*ns -= infqr;
/* 更新并返回移位的数量 */

/* ==== Return optimal workspace. ==== */
/* ==== 返回最优工作空间。 ==== */

d__1 = (doublereal) lwkopt;
z__1.r = d__1, z__1.i = 0.;
work[1].r = z__1.r, work[1].i = z__1.i;
/* 返回最优工作空间大小 */

/* ==== End of ZLAQR2 ==== */
/* ==== ZLAQR2 结束 ==== */

return 0;
} /* zlaqr2_ */

/* Subroutine */ int zlaqr3_(logical *wantt, logical *wantz, integer *n,
integer *ktop, integer *kbot, integer *nw, doublecomplex *h__,
integer *ldh, integer *iloz, integer *ihiz, doublecomplex *z__,
integer *ldz, integer *ns, integer *nd, doublecomplex *sh,
doublecomplex *v, integer *ldv, integer *nh, doublecomplex *t,
integer *ldt, integer *nv, doublecomplex *wv, integer *ldwv,
doublecomplex *work, integer *lwork)
{
/* 子程序，用于计算特征值 */

/* System generated locals */
/* 系统生成的本地变量 */
integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
    wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
doublereal d__1, d__2, d__3, d__4, d__5, d__6;
doublecomplex z__1, z__2;

/* Local variables */
/* 本地变量 */
static integer i__, j;
static doublecomplex s;
static integer jw;
static doublereal foo;
static integer kln;
static doublecomplex tau;
static integer knt;
static doublereal ulp;
static integer lwk1, lwk2, lwk3;
static doublecomplex beta;
static integer kcol, info, nmin, ifst, ilst, ltop, krow;
extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *, doublecomplex *);
static integer infqr;
    # 声明一个外部的复数矩阵乘法子程序 zgemm_
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);

    # 声明一个静态整数变量 kwtop
    static integer kwtop;

    # 声明一个外部的复数向量复制子程序 zcopy_
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    # 声明一个外部的用于设置浮点数精度限制的子程序 dlabad_
    extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);

    # 声明一个外部的计算特定矩阵特征值的子程序 zlaqr4_
    extern /* Subroutine */ int zlaqr4_(logical *, logical *, integer *, integer *,
         integer *, doublecomplex *, integer *, doublecomplex *, integer *, integer *,
         doublecomplex *, integer *, doublecomplex *, integer *, integer *);

    # 声明一个静态的双精度浮点数变量 safmin
    static doublereal safmin;

    # 声明一个外部的用于获取环境参数的函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 声明一个静态的双精度浮点数变量 safmax
    static doublereal safmax;

    # 声明一个外部的对厄米特矩阵进行 Hessenberg 分解的子程序 zgehrd_
    extern /* Subroutine */ int zgehrd_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);

    # 声明一个外部的生成 Householder 变换向量的子程序 zlarfg_
    extern /* Subroutine */ int zlarfg_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *);

    # 声明一个外部的计算 Hessenberg 矩阵全部特征值的子程序 zlahqr_
    extern /* Subroutine */ int zlahqr_(logical *, logical *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *, integer *,
        integer *, doublecomplex *, integer *, integer *);

    # 声明一个外部的复制矩阵的子程序 zlacpy_
    extern /* Subroutine */ int zlacpy_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);

    # 声明一个外部的设置矩阵元素值的子程序 zlaset_
    extern /* Subroutine */ int zlaset_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, doublecomplex *, integer *);

    # 声明一个静态的双精度浮点数变量 smlnum
    static doublereal smlnum;

    # 声明一个外部的交换矩阵特定区域的子程序 ztrexc_
    extern /* Subroutine */ int ztrexc_(char *, integer *, doublecomplex *,
        integer *, doublecomplex *, integer *, integer *, integer *,
        integer *);

    # 声明一个静态整数变量 lwkopt
    static integer lwkopt;

    # 声明一个外部的应用 Householder 变换的子程序 zunmhr_
    extern /* Subroutine */ int zunmhr_(char *, char *, integer *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);
/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

/* Parameter adjustments */
h_dim1 = *ldh;
h_offset = 1 + h_dim1;
h__ -= h_offset;
z_dim1 = *ldz;
z_offset = 1 + z_dim1;
z__ -= z_offset;
--sh;
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;
t_dim1 = *ldt;
t_offset = 1 + t_dim1;
t -= t_offset;
wv_dim1 = *ldwv;
wv_offset = 1 + wv_dim1;
wv -= wv_offset;
--work;

/* Function Body */
/* Computing MIN */
i__1 = *nw, i__2 = *kbot - *ktop + 1;
jw = min(i__1,i__2);
if (jw <= 2) {
    lwkopt = 1;
} else {

/* ==== Workspace query call to ZGEHRD ==== */

i__1 = jw - 1;
zgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
    c_n1, &info);
lwk1 = (integer) work[1].r;

/* ==== Workspace query call to ZUNMHR ==== */

i__1 = jw - 1;
zunmhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
     &v[v_offset], ldv, &work[1], &c_n1, &info);
lwk2 = (integer) work[1].r;

/* ==== Workspace query call to ZLAQR4 ==== */

zlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[1],
    &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &infqr);
lwk3 = (integer) work[1].r;

/*
    ==== Optimal workspace ====

    Computing MAX
*/
i__1 = jw + max(lwk1,lwk2);
lwkopt = max(i__1,lwk3);
}

/* ==== Quick return in case of workspace query. ==== */

if (*lwork == -1) {
d__1 = (doublereal) lwkopt;
z__1.r = d__1, z__1.i = 0.;
work[1].r = z__1.r, work[1].i = z__1.i;
return 0;
}

/*
   ==== Nothing to do ...
   ... for an empty active block ... ====
*/
*ns = 0;
*nd = 0;
work[1].r = 1., work[1].i = 0.;
if (*ktop > *kbot) {
return 0;
}
/* ... nor for an empty deflation window. ==== */
if (*nw < 1) {
return 0;
}

/* ==== Machine constants ==== */

safmin = SAFEMINIMUM;
safmax = 1. / safmin;
dlabad_(&safmin, &safmax);
ulp = PRECISION;
smlnum = safmin * ((doublereal) (*n) / ulp);

/*
   ==== Setup deflation window ====

   Computing MIN
*/
i__1 = *nw, i__2 = *kbot - *ktop + 1;
jw = min(i__1,i__2);
kwtop = *kbot - jw + 1;
if (kwtop == *ktop) {
s.r = 0., s.i = 0.;
} else {
i__1 = kwtop + (kwtop - 1) * h_dim1;
s.r = h__[i__1].r, s.i = h__[i__1].i;
}

if (*kbot == kwtop) {

/* ==== 1-by-1 deflation window: not much to do ==== */

i__1 = kwtop;
i__2 = kwtop + kwtop * h_dim1;
sh[i__1].r = h__[i__2].r, sh[i__1].i = h__[i__2].i;
*ns = 1;
*nd = 0;
/* Computing MAX */
i__1 = kwtop + kwtop * h_dim1;
d__5 = smlnum, d__6 = ulp * ((d__1 = h__[i__1].r, abs(d__1)) + (d__2 =
     d_imag(&h__[kwtop + kwtop * h_dim1]), abs(d__2)));
    # 如果复数 s 的实部和虚部的绝对值之和小于等于 max(d__5, d__6)
    if ((d__3 = s.r, abs(d__3)) + (d__4 = d_imag(&s), abs(d__4)) <= max(
        d__5,d__6)) {
        # 设置 ns 为 0，nd 为 1
        *ns = 0;
        *nd = 1;
        # 如果 kwtop 大于 ktop
        if (kwtop > *ktop) {
            # 计算 h__ 中的索引位置并将其设置为零
            i__1 = kwtop + (kwtop - 1) * h_dim1;
            h__[i__1].r = 0., h__[i__1].i = 0.;
        }
    }
    # 将 work 数组的第一个元素设置为 (1, 0) 复数
    work[1].r = 1., work[1].i = 0.;
    # 返回 0 表示正常执行完毕
    return 0;
/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/

// 将 Hessenberg 矩阵的子区域转换为尖锐三角形式，处理 QR 分解稀有失败的情况，继续进行早期缩小处理
zlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
    ldt);

// 复制 H 的子区域到 T 中
i__1 = jw - 1;
i__2 = *ldh + 1;
i__3 = *ldt + 1;
zcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
    i__3);

// 在 V 矩阵的子区域中设置为零
zlaset_("A", &jw, &jw, &c_b56, &c_b57, &v[v_offset], ldv);

// 计算用于 ZLAQR3 的 ILAENV 函数的返回值
nmin = ilaenv_(&c__12, "ZLAQR3", "SV", &jw, &c__1, &jw, lwork, (ftnlen)6,
    (ftnlen)2);

// 根据 JW 和 NMIN 调用 ZLAQR4 或 ZLAHQR 函数进行 QR 迭代
if (jw > nmin) {
    zlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[
        kwtop], &c__1, &jw, &v[v_offset], ldv, &work[1], lwork, &
        infqr);
} else {
    zlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[
        kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
}

/*     ==== Deflation detection loop ==== */

// 设置输出参数 ns 为 jw
*ns = jw;

// 初始化 ILST 为 INFQR + 1
ilst = infqr + 1;

// 循环处理每个小主子矩阵的收敛情况
i__1 = jw;
for (knt = infqr + 1; knt <= i__1; ++knt) {

/*        ==== Small spike tip deflation test ==== */

// 计算当前 T 矩阵对应位置的绝对值和，用于判断是否收敛
i__2 = *ns + *ns * t_dim1;
foo = (d__1 = t[i__2].r, abs(d__1)) + (d__2 = d_imag(&t[*ns + *ns *
    t_dim1]), abs(d__2));

// 若 foo 为零，则计算相应 S 的绝对值和
if (foo == 0.) {
    foo = (d__1 = s.r, abs(d__1)) + (d__2 = d_imag(&s), abs(d__2));
}

// 计算下一个特征向量是否可收敛的条件
i__2 = *ns * v_dim1 + 1;
/* Computing MAX */
d__5 = smlnum, d__6 = ulp * foo;
if (((d__1 = s.r, abs(d__1)) + (d__2 = d_imag(&s), abs(d__2))) * ((
    d__3 = v[i__2].r, abs(d__3)) + (d__4 = d_imag(&v[*ns * v_dim1
    + 1]), abs(d__4))) <= max(d__5,d__6)) {

/*           ==== One more converged eigenvalue ==== */

    // 如果当前特征值可收敛，则减少 ns 的值
    --(*ns);
} else {

/*
             ==== One undeflatable eigenvalue.  Move it up out of the
             .    way.   (ZTREXC can not fail in this case.) ====
*/

    // 若特征值不可收敛，则调用 ZTREXC 函数处理
    ifst = *ns;
    ztrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &
        ilst, &info);
    ++ilst;
}
/* L10: */
}

/*        ==== Return to Hessenberg form ==== */

// 若 ns 为零，则置零 s
if (*ns == 0) {
s.r = 0., s.i = 0.;
}

// 若 ns 小于 jw，则排序 T 矩阵对角元素，提高精度
if (*ns < jw) {

/*
          ==== sorting the diagonal of T improves accuracy for
          .    graded matrices.  ====
*/

i__1 = *ns;
for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    ifst = i__;
    i__2 = *ns;
    for (j = i__ + 1; j <= i__2; ++j) {
    i__3 = j + j * t_dim1;
    i__4 = ifst + ifst * t_dim1;
    if ((d__1 = t[i__3].r, abs(d__1)) + (d__2 = d_imag(&t[j + j *
        t_dim1]), abs(d__2)) > (d__3 = t[i__4].r, abs(d__3))
        + (d__4 = d_imag(&t[ifst + ifst * t_dim1]), abs(d__4))
        ) {
        ifst = j;
    }
/* L20: */
    }
    ilst = i__;
    if (ifst != ilst) {
    ztrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
         &ilst, &info);
    }
/* L30: */
}
}
/* L30: */
    }
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__1 = jw;
    for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    i__2 = kwtop + i__ - 1;
    i__3 = i__ + i__ * t_dim1;
    sh[i__2].r = t[i__3].r, sh[i__2].i = t[i__3].i;
/* L40: */
    }


    if (*ns < jw || s.r == 0. && s.i == 0.) {
    if (*ns > 1 && (s.r != 0. || s.i != 0.)) {

/*           ==== Reflect spike back into lower triangle ==== */

        zcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        i__1 = *ns;
        for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        d_cnjg(&z__1, &work[i__]);
        work[i__2].r = z__1.r, work[i__2].i = z__1.i;
/* L50: */
        }
        beta.r = work[1].r, beta.i = work[1].i;
        zlarfg_(ns, &beta, &work[2], &c__1, &tau);
        work[1].r = 1., work[1].i = 0.;

        i__1 = jw - 2;
        i__2 = jw - 2;
        zlaset_("L", &i__1, &i__2, &c_b56, &c_b56, &t[t_dim1 + 3], ldt);

        d_cnjg(&z__1, &tau);
        zlarf_("L", ns, &jw, &work[1], &c__1, &z__1, &t[t_offset], ldt, &
            work[jw + 1]);
        zlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        zlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        i__1 = *lwork - jw;
        zgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== Copy updated reduced window into place ==== */

    if (kwtop > 1) {
        i__1 = kwtop + (kwtop - 1) * h_dim1;
        d_cnjg(&z__2, &v[v_dim1 + 1]);
        z__1.r = s.r * z__2.r - s.i * z__2.i, z__1.i = s.r * z__2.i + s.i
            * z__2.r;
        h__[i__1].r = z__1.r, h__[i__1].i = z__1.i;
    }
    zlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    zcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    if (*ns > 1 && (s.r != 0. || s.i != 0.)) {
        i__1 = *lwork - jw;
        zunmhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== Update vertical slab in H ==== */

    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
/* Computing MIN */
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
        zgemm_("N", "N", &kln, &jw, &jw, &c_b57, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b56, &wv[wv_offset],
            ldwv);
        zlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L60: */
    }

/*        ==== Update horizontal slab in H ==== */
    # 如果 *wantt 为真值（非零），则执行以下循环
    if (*wantt) {
        # 设置循环的终止条件和步长
        i__2 = *n;
        i__1 = *nh;
        # 循环变量 kcol 从 *kbot + 1 开始，根据 i__1 的正负决定循环方向
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
/* Computing MIN */
        i__3 = *nh, i__4 = *n - kcol + 1;
        kln = min(i__3,i__4);
/* Perform matrix-matrix multiplication with conjugate transpose of V and a submatrix of H */
        zgemm_("C", "N", &jw, &kln, &jw, &c_b57, &v[v_offset], ldv, &
            h__[kwtop + kcol * h_dim1], ldh, &c_b56, &t[t_offset],
             ldt);
/* Copy matrix T to a submatrix of H */
        zlacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
             h_dim1], ldh);
/* L70: */
        }
    }

/*        ==== Update vertical slab in Z ==== */

    if (*wantz) {
/* Compute the number of rows to update in Z */
        i__1 = *ihiz;
        i__2 = *nv;
        for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
             i__2) {
/* Computing MIN */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
        kln = min(i__3,i__4);
/* Perform matrix-matrix multiplication */
        zgemm_("N", "N", &kln, &jw, &jw, &c_b57, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b56, &wv[
            wv_offset], ldwv);
/* Copy matrix WV to Z */
        zlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
/* L80: */
        }
    }
    }

/*     ==== Return the number of deflations ... ==== */

/* Update the number of deflations */
    *nd = jw - *ns;

/*
       ==== ... and the number of shifts. (Subtracting
       .    INFQR from the spike length takes care
       .    of the case of a rare QR failure while
       .    calculating eigenvalues of the deflation
       .    window.)  ====
*/

/* Update the number of shifts */
    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */

/* Return the optimal workspace size */
    d__1 = (doublereal) lwkopt;
    z__1.r = d__1, z__1.i = 0.;
    work[1].r = z__1.r, work[1].i = z__1.i;

/*     ==== End of ZLAQR3 ==== */

/* End of subroutine ZLAQR3 */
    return 0;
} /* zlaqr3_ */

/* Subroutine */ int zlaqr4_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublecomplex *h__, integer *ldh,
    doublecomplex *w, integer *iloz, integer *ihiz, doublecomplex *z__,
    integer *ldz, doublecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8;
    doublecomplex z__1, z__2, z__3, z__4, z__5;

    /* Local variables */
    static integer i__, k;
    static doublereal s;
    static doublecomplex aa, bb, cc, dd;
    static integer ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
    static doublecomplex tr2, det;
    static integer inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot,
        nmin;
    static doublecomplex swap;
    static integer ktop;
    static doublecomplex zdum[1]    /* was [1][1] */;
    static integer kacc22, itmax, nsmax, nwmax, kwtop;
    ! 外部函数声明：zlaqr2_ 和 zlaqr5_ 是外部 Fortran 子程序
    extern /* Subroutine */ int zlaqr2_(logical *, logical *, integer *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        integer *, integer *, doublecomplex *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *, integer *,
         doublecomplex *, integer *, integer *, doublecomplex *, integer *
        , doublecomplex *, integer *), zlaqr5_(logical *, logical *,
        integer *, integer *, integer *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, integer *, integer *,
         doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, integer *, doublecomplex *, integer *,
         integer *, doublecomplex *, integer *);

    ! 静态变量声明：nibble 是一个整数
    static integer nibble;

    ! 外部函数声明：ilaenv_ 是外部 Fortran 函数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    ! 静态字符数组声明：jbcmpz 是一个长度为 2 的字符数组
    static char jbcmpz[2];

    ! 静态复数变量声明：rtdisc 是一个复数变量
    static doublecomplex rtdisc;

    ! 静态整数声明：nwupbd 是一个整数
    static integer nwupbd;

    ! 静态逻辑变量声明：sorted 是一个逻辑（布尔）变量
    static logical sorted;

    ! 外部子程序声明：zlahqr_ 和 zlacpy_ 是外部 Fortran 子程序
    extern /* Subroutine */ int zlahqr_(logical *, logical *, integer *,
        integer *, integer *, doublecomplex *, integer *, doublecomplex *,
         integer *, integer *, doublecomplex *, integer *, integer *),
        zlacpy_(char *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);

    ! 静态整数声明：lwkopt 是一个整数
    static integer lwkopt;
/*
   Parameter adjustments
*/
    /* 计算 h 的第一维长度 */
    h_dim1 = *ldh;
    /* 计算 h 的偏移量 */
    h_offset = 1 + h_dim1;
    /* 调整 h 的指针 */
    h__ -= h_offset;
    /* 调整 w 的指针 */
    --w;
    /* 计算 z 的第一维长度 */
    z_dim1 = *ldz;
    /* 计算 z 的偏移量 */
    z_offset = 1 + z_dim1;
    /* 调整 z 的指针 */
    z__ -= z_offset;
    /* 调整 work 的指针 */
    --work;

    /* Function Body */
    /* 初始化 info 为 0 */
    *info = 0;

/*     ==== Quick return for N = 0: nothing to do. ==== */

    /* 若 n 等于 0，则直接返回 */
    if (*n == 0) {
    work[1].r = 1., work[1].i = 0.;
    return 0;
    }

    /* 若 n 小于等于 11 */
    if (*n <= 11) {

/*        ==== Tiny matrices must use ZLAHQR. ==== */

    /* 设置 lwkopt 为 1 */
    lwkopt = 1;
    /* 若不是在查询工作空间，则调用 ZLAHQR 进行计算 */
    if (*lwork != -1) {
        zlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
            iloz, ihiz, &z__[z_offset], ldz, info);
    }
    } else {

/*
          ==== Use small bulge multi-shift QR with aggressive early
          .    deflation on larger-than-tiny matrices. ====

          ==== Hope for the best. ====
*/

    /* 再次初始化 info 为 0 */
    *info = 0;

/*        ==== Set up job flags for ILAENV. ==== */

    /* 根据 wantt 设置 jbcmpz 的第一个字符 */
    if (*wantt) {
        *(unsigned char *)jbcmpz = 'S';
    } else {
        *(unsigned char *)jbcmpz = 'E';
    }
    /* 根据 wantz 设置 jbcmpz 的第二个字符 */
    if (*wantz) {
        *(unsigned char *)&jbcmpz[1] = 'V';
    } else {
        *(unsigned char *)&jbcmpz[1] = 'N';
    }

/*
          ==== NWR = recommended deflation window size.  At this
          .    point,  N .GT. NTINY = 11, so there is enough
          .    subdiagonal workspace for NWR.GE.2 as required.
          .    (In fact, there is enough subdiagonal space for
          .    NWR.GE.3.) ====
*/

    /* 调用 ILAENV 计算推荐的 deflation 窗口大小 */
    nwr = ilaenv_(&c__13, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
    /* nwr 至少为 2 */
    nwr = max(2,nwr);
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
    /* nwr 至多为 i__1 和 nwr 中的较小值 */
    nwr = min(i__1,nwr);

/*
          ==== NSR = recommended number of simultaneous shifts.
          .    At this point N .GT. NTINY = 11, so there is at
          .    enough subdiagonal workspace for NSR to be even
          .    and greater than or equal to two as required. ====
*/

    /* 调用 ILAENV 计算推荐的 simultaneous shifts 数量 */
    nsr = ilaenv_(&c__15, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;
    /* nsr 至多为 i__1, i__2 和 nsr 中的较小值 */
    nsr = min(i__1,i__2);
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;
    /* nsr 至少为 2 和 nsr 中偶数的最大值 */
    nsr = max(i__1,i__2);

/*
          ==== Estimate optimal workspace ====

          ==== Workspace query call to ZLAQR2 ====
*/

    /* 调用 ZLAQR2 估算最优工作空间 */
    i__1 = nwr + 1;
    zlaqr2_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[h_offset],
        ldh, n, &h__[h_offset], ldh, n, &h__[h_offset], ldh, &work[1],
         &c_n1);

/*
          ==== Optimal workspace = MAX(ZLAQR5, ZLAQR2) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1].r;
    /* lwkopt 为 nsr * 3/2 和 work[1].r 中的较大值 */
    lwkopt = max(i__1,i__2);

/*        ==== Quick return in case of workspace query. ==== */

    /* 若在查询工作空间，则设置返回结果 */
    if (*lwork == -1) {
        d__1 = (doublereal) lwkopt;
        z__1.r = d__1, z__1.i = 0.;
        work[1].r = z__1.r, work[1].i = z__1.i;
        return 0;
    }
/*        ==== ZLAHQR/ZLAQR0 crossover point ==== */

// 调用ILAENV函数获取ZLAQR4算法的参数值，确定ZLAHQR/ZLAQR0切换点
nmin = ilaenv_(&c__12, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
    6, (ftnlen)2);
// 设置nmin为11和当前计算得到的nmin中的较大值
nmin = max(11,nmin);

/*        ==== Nibble crossover point ==== */

// 同样使用ILAENV函数获取ZLAQR4算法的参数值，确定nibble切换点
nibble = ilaenv_(&c__14, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
// 设置nibble为0和当前计算得到的nibble中的较大值
nibble = max(0,nibble);

/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

// 通过ILAENV函数获取ZLAQR4算法的参数值，确定是否在ttswp期间累积反射，以及在矩阵乘法中是否使用2x2块结构
kacc22 = ilaenv_(&c__16, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
// 将kacc22限制在0到2之间
kacc22 = max(0,kacc22);
kacc22 = min(2,kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/

// 计算NWMAX，表示可能的最大缩小窗口大小，以确保有足够的工作空间
i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
nwmax = min(i__1,i__2);
nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/

// 计算NSMAX，表示可能的最大同时位移数，以确保有足够的工作空间
i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
nsmax = min(i__1,i__2);
nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

// 初始化迭代计数器ndfl，在每次缩小窗口时重置
ndfl = 1;

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/

// 设置迭代次数上限itmax，通常为10与当前活跃块的行数之积的30倍中较大值
i__1 = 10, i__2 = *ihi - *ilo + 1;
itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

// 设置活跃块的最后一行和最后一列
kbot = *ihi;

/*        ==== Main Loop ==== */

// 主循环，迭代次数为itmax次
i__1 = itmax;
for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

// 如果kbot小于ilo，则跳出主循环
if (kbot < *ilo) {
goto L80;
}

/*           ==== Locate active block ==== */

// 确定活跃块的范围，从kbot递减到ilo+1，找到第一个全零的对角块
i__2 = *ilo + 1;
for (k = kbot; k >= i__2; --k) {
i__3 = k + (k - 1) * h_dim1;
if (h__[i__3].r == 0. && h__[i__3].i == 0.) {
goto L20;
}
// L10:
}
k = *ilo;
L20:
ktop = k;

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

// 计算活跃块的高度nh
nh = kbot - ktop + 1;
// 设置nwupbd为nh和nwmax中的较小值
nwupbd = min(nh,nwmax);
// 根据ndfl的值，选择缩小窗口的策略
if (ndfl < 5) {
nw = min(nwupbd,nwr);
} else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        }
        if (nw < nwmax) {
        if (nw >= nh - 1) {
            nw = nh;
        } else {
            kwtop = kbot - nw + 1;
            i__2 = kwtop + (kwtop - 1) * h_dim1;
            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
            if ((d__1 = h__[i__2].r, abs(d__1)) + (d__2 = d_imag(&h__[
                kwtop + (kwtop - 1) * h_dim1]), abs(d__2)) > (
                d__3 = h__[i__3].r, abs(d__3)) + (d__4 = d_imag(&
                h__[kwtop - 1 + (kwtop - 2) * h_dim1]), abs(d__4))
                ) {
            ++nw;
            }
        }
        }
        if (ndfl < 5) {
        ndec = -1;
        } else if (ndec >= 0 || nw >= nwupbd) {
        ++ndec;
        if (nw - ndec < 2) {
            ndec = 0;
        }
        nw -= ndec;
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

/* 设置工作区域尺寸 */
        kv = *n - nw + 1;
        kt = nw + 1;
        nho = *n - nw - 1 - kt + 1;
        kwv = nw + 2;
        nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

/* 执行 QR 方法 */
        zlaqr2_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[kv
            + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], ldh, &nve, &
            h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

/* 更新 KBOT */
        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

/* 设置 KS 指向的偏移量 */
        ks = kbot - ls + 1;

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

/* 检查是否需要跳过 QR 方法 */
        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if ZLAQR2
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* 计算 NS 的值 */
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
        ns = min(i__2,i__3);
        ns -= ns % 2;
/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    ZLAQR2 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
if (ndfl % 6 == 0) {
    // 计算 ks 的值，确定要处理的子矩阵范围
    ks = kbot - ns + 1;
    // 从 kbot 往回处理每两个步长的特征值
    i__2 = ks + 1;
    for (i__ = kbot; i__ >= i__2; i__ += -2) {
        i__3 = i__;
        // 计算新的特征值 w[i__]
        i__4 = i__ + i__ * h_dim1;
        i__5 = i__ + (i__ - 1) * h_dim1;
        d__3 = ((d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
            d_imag(&h__[i__ + (i__ - 1) * h_dim1]), abs(
            d__2))) * .75;
        z__1.r = h__[i__4].r + d__3, z__1.i = h__[i__4].i;
        w[i__3].r = z__1.r, w[i__3].i = z__1.i;
        // 设置下一个特征值
        i__3 = i__ - 1;
        i__4 = i__;
        w[i__3].r = w[i__4].r, w[i__3].i = w[i__4].i;
        // L30 标签，用于程序控制流程
/* L30: */
    }
} else {

/*
                   ==== Got NS/2 or fewer shifts? Use ZLAHQR
                   .    on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
*/

    // 如果没有足够的特征值，调用 ZLAHQR 获取更多特征值
    if (kbot - ks + 1 <= ns / 2) {
        // 重新计算 ks 的值，确定要处理的子矩阵范围
        ks = kbot - ns + 1;
        // 计算 kt 的值，用于复制子矩阵
        kt = *n - ns + 1;
        // 复制子矩阵，为 ZLAHQR 准备工作
        zlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
            h__[kt + h_dim1], ldh);
        // 调用 ZLAHQR 计算特征值和 Schur 形式
        zlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[kt
            + h_dim1], ldh, &w[ks], &c__1, &c__1, zdum, &
            c__1, &inf);
        // 更新 ks 值，准备下一轮特征值计算
        ks += inf;

/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  Scale to avoid
                      .    overflows, underflows and subnormals.
                      .    (The scale factor S can not be zero,
                      .    because H(KBOT,KBOT-1) is nonzero.) ====
*/
            if (ks >= kbot) {
                // 计算对角块的元素的绝对值和，用于后续计算
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                i__3 = kbot + (kbot - 1) * h_dim1;
                i__4 = kbot - 1 + kbot * h_dim1;
                i__5 = kbot + kbot * h_dim1;
                s = (d__1 = h__[i__2].r, abs(d__1)) + (d__2 =
                    d_imag(&h__[kbot - 1 + (kbot - 1) *
                    h_dim1]), abs(d__2)) + ((d__3 = h__[i__3]
                    .r, abs(d__3)) + (d__4 = d_imag(&h__[kbot
                    + (kbot - 1) * h_dim1]), abs(d__4))) + ((
                    d__5 = h__[i__4].r, abs(d__5)) + (d__6 =
                    d_imag(&h__[kbot - 1 + kbot * h_dim1]),
                    abs(d__6))) + ((d__7 = h__[i__5].r, abs(
                    d__7)) + (d__8 = d_imag(&h__[kbot + kbot *
                     h_dim1]), abs(d__8)));
                // 计算对角块元素的倒数，并分别存储到 aa, cc, bb, dd
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                aa.r = z__1.r, aa.i = z__1.i;
                i__2 = kbot + (kbot - 1) * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                cc.r = z__1.r, cc.i = z__1.i;
                i__2 = kbot - 1 + kbot * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                bb.r = z__1.r, bb.i = z__1.i;
                i__2 = kbot + kbot * h_dim1;
                z__1.r = h__[i__2].r / s, z__1.i = h__[i__2].i /
                    s;
                dd.r = z__1.r, dd.i = z__1.i;
                // 计算特征值的二阶特征多项式系数
                z__2.r = aa.r + dd.r, z__2.i = aa.i + dd.i;
                z__1.r = z__2.r / 2., z__1.i = z__2.i / 2.;
                tr2.r = z__1.r, tr2.i = z__1.i;
                z__3.r = aa.r - tr2.r, z__3.i = aa.i - tr2.i;
                z__4.r = dd.r - tr2.r, z__4.i = dd.i - tr2.i;
                z__2.r = z__3.r * z__4.r - z__3.i * z__4.i,
                    z__2.i = z__3.r * z__4.i + z__3.i *
                    z__4.r;
                z__5.r = bb.r * cc.r - bb.i * cc.i, z__5.i = bb.r
                    * cc.i + bb.i * cc.r;
                z__1.r = z__2.r - z__5.r, z__1.i = z__2.i -
                    z__5.i;
                det.r = z__1.r, det.i = z__1.i;
                // 计算特征值的平方根
                z__2.r = -det.r, z__2.i = -det.i;
                z_sqrt(&z__1, &z__2);
                rtdisc.r = z__1.r, rtdisc.i = z__1.i;
                // 计算特征值，并存储到 w 中
                i__2 = kbot - 1;
                z__2.r = tr2.r + rtdisc.r, z__2.i = tr2.i +
                    rtdisc.i;
                z__1.r = s * z__2.r, z__1.i = s * z__2.i;
                w[i__2].r = z__1.r, w[i__2].i = z__1.i;
                i__2 = kbot;
                z__2.r = tr2.r - rtdisc.r, z__2.i = tr2.i -
                    rtdisc.i;
                z__1.r = s * z__2.r, z__1.i = s * z__2.i;
                w[i__2].r = z__1.r, w[i__2].i = z__1.i;

                // 更新 ks 的值
                ks = kbot - 1;
            }
            }
/*                    ==== Sort the shifts (Helps a little) ==== */

            sorted = FALSE_;
            // 从 kbot 开始向前遍历，确保将最大的元素移到右侧
            i__2 = ks + 1;
            for (k = kbot; k >= i__2; --k) {
                if (sorted) {
                // 如果已经排序完成则跳出循环
                goto L60;
                }
                sorted = TRUE_;
                // 检查当前范围内的元素，确保每对相邻的元素按照大小排列
                i__3 = k - 1;
                for (i__ = ks; i__ <= i__3; ++i__) {
                i__4 = i__;
                i__5 = i__ + 1;
                // 如果前一个元素比后一个元素大，则交换它们
                if ((d__1 = w[i__4].r, abs(d__1)) + (d__2 =
                    d_imag(&w[i__]), abs(d__2)) < (d__3 =
                    w[i__5].r, abs(d__3)) + (d__4 =
                    d_imag(&w[i__ + 1]), abs(d__4))) {
                    sorted = FALSE_;
                    i__4 = i__;
                    // 交换 w[i__] 和 w[i__ + 1] 的值
                    swap.r = w[i__4].r, swap.i = w[i__4].i;
                    i__4 = i__;
                    i__5 = i__ + 1;
                    w[i__4].r = w[i__5].r, w[i__4].i = w[i__5]
                        .i;
                    i__4 = i__ + 1;
                    w[i__4].r = swap.r, w[i__4].i = swap.i;
                }
/* L40: */
                }
/* L50: */
            }
L60:
            // 标签，用于跳出排序循环
            ;
            }
        }

/*
                ==== If there are only two shifts, then use
                .    only one.  ====
*/

        // 如果只有两个移位，则只使用一个
        if (kbot - ks + 1 == 2) {
            i__2 = kbot;
            i__3 = kbot + kbot * h_dim1;
            z__2.r = w[i__2].r - h__[i__3].r, z__2.i = w[i__2].i -
                h__[i__3].i;
            z__1.r = z__2.r, z__1.i = z__2.i;
            i__4 = kbot - 1;
            i__5 = kbot + kbot * h_dim1;
            z__4.r = w[i__4].r - h__[i__5].r, z__4.i = w[i__4].i -
                h__[i__5].i;
            z__3.r = z__4.r, z__3.i = z__4.i;
            // 比较两个移位的大小，并更新 w[kbot-1] 或 w[kbot] 的值
            if ((d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1),
                abs(d__2)) < (d__3 = z__3.r, abs(d__3)) + (d__4 =
                d_imag(&z__3), abs(d__4))) {
            i__2 = kbot - 1;
            i__3 = kbot;
            w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
            } else {
            i__2 = kbot;
            i__3 = kbot - 1;
            w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
            }
        }

/*
                ==== Use up to NS of the smallest magnitude
                .    shifts.  If there aren't NS shifts available,
                .    then use them all, possibly dropping one to
                .    make the number of shifts even. ====

   Computing MIN
*/
        // 计算需要使用的最小移位数，确保移位数是偶数
        i__2 = ns, i__3 = kbot - ks + 1;
        ns = min(i__2,i__3);
        ns -= ns % 2;
        // 更新 ks 的值，使得 ks 指向最小移位的起始位置
        ks = kbot - ns + 1;
/* 
                ==== Small-bulge multi-shift QR sweep:
                .    split workspace under the subdiagonal into
                .    - a KDU-by-KDU work array U in the lower
                .      left-hand-corner,
                .    - a KDU-by-at-least-KDU-but-more-is-better
                .      (KDU-by-NHo) horizontal work array WH along
                .      the bottom edge,
                .    - and an at-least-KDU-but-more-is-better-by-KDU
                .      (NVE-by-KDU) vertical work array WV along
                .      the left-hand-edge. ====
*/

        kdu = ns * 3 - 3;
        // Calculate the dimension of the U workspace array
        ku = *n - kdu + 1;
        // Calculate the dimension of the WH workspace array
        kwh = kdu + 1;
        // Calculate the dimension of the NHo workspace array
        nho = *n - kdu - 3 - (kdu + 1) + 1;
        // Calculate the dimension of the WV workspace array
        kwv = kdu + 4;
        // Calculate the dimension of the NVE workspace array
        nve = *n - kdu - kwv + 1;

/* 
              ==== Small-bulge multi-shift QR sweep ==== 
*/

        zlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks], &
            h__[h_offset], ldh, iloz, ihiz, &z__[z_offset], ldz, &
            work[1], &c__3, &h__[ku + h_dim1], ldh, &nve, &h__[
            kwv + h_dim1], ldh, &nho, &h__[ku + kwh * h_dim1],
            ldh);

/* 
           ==== Note progress (or the lack of it). ==== 
*/

        if (ld > 0) {
        ndfl = 1;
        } else {
        ++ndfl;
        }

/* 
             ==== End of main loop ==== 
   L70: 
*/

/* 
          ==== Iteration limit exceeded.  Set INFO to show where
          .    the problem occurred and exit. ==== 
*/

    *info = kbot;
L80:
    ;

/* 
     ==== Return the optimal value of LWORK. ==== 
*/

    d__1 = (doublereal) lwkopt;
    z__1.r = d__1, z__1.i = 0.;
    work[1].r = z__1.r, work[1].i = z__1.i;

/* 
     ==== End of ZLAQR4 ==== 
*/

    return 0;
} /* zlaqr4_ */

/* Subroutine */ int zlaqr5_(logical *wantt, logical *wantz, integer *kacc22,
    integer *n, integer *ktop, integer *kbot, integer *nshfts,
    doublecomplex *s, doublecomplex *h__, integer *ldh, integer *iloz,
    integer *ihiz, doublecomplex *z__, integer *ldz, doublecomplex *v,
    integer *ldv, doublecomplex *u, integer *ldu, integer *nv,
    doublecomplex *wv, integer *ldwv, integer *nh, doublecomplex *wh,
    integer *ldwh)
{
    /* System generated locals */
    integer h_dim1, h_offset, u_dim1, u_offset, v_dim1, v_offset, wh_dim1,
        wh_offset, wv_dim1, wv_offset, z_dim1, z_offset, i__1, i__2, i__3,
         i__4, i__5, i__6, i__7, i__8, i__9, i__10, i__11;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8, d__9, d__10;
    doublecomplex z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

    /* Local variables */
    static integer j, k, m, i2, j2, i4, j4, k1;
    static doublereal h11, h12, h21, h22;
    static integer m22, ns, nu;
    static doublecomplex vt[3];
    static doublereal scl;
    static integer kdu, kms;
    static doublereal ulp;
    static integer knz, kzs;
    static doublereal tst1, tst2;
    static doublecomplex beta;
    static logical blk22, bmp22;
    static integer mend, jcol, jlen, jbot, mbot, jtop, jrow, mtop;
    # 声明静态变量 alpha，类型为 doublecomplex（复数结构体）
    static doublecomplex alpha;
    # 声明静态逻辑变量 accum，用于累积计算标记
    static logical accum;
    # 声明静态整型变量 ndcol, incol, krcol, nbmps，分别表示列数、输入列数、保留列数、波浪点数
    static integer ndcol, incol, krcol, nbmps;
    # 外部声明 zgemm_、ztrmm_、dlabad_、zlaqr1_ 函数，这些函数在其他地方实现
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *,
         integer *, integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *),
        dlabad_(doublereal *, doublereal *), zlaqr1_(integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        doublecomplex *);

    # 声明静态变量 safmin, safmax，分别表示安全最小值和安全最大值
    static doublereal safmin, safmax;
    # 外部声明 zlarfg_、zlacpy_、zlaset_ 函数，这些函数在其他地方实现
    extern /* Subroutine */ int zlarfg_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *);
    # 声明静态复数结构体变量 refsum，用于存储参考总和
    static doublecomplex refsum;
    # 声明静态整型变量 mstart，表示起始行数
    static integer mstart;
    # 声明静态变量 smlnum，表示小数值
    static doublereal smlnum;
    /* Parameter adjustments */
    --s;                    // 减少 s 数组的索引，以便从1到n开始访问
    h_dim1 = *ldh;          // h 的第一维度大小为 ldh
    h_offset = 1 + h_dim1;  // 计算 h__ 数组的偏移量
    h__ -= h_offset;        // 调整 h__ 指针以访问正确的内存位置
    z_dim1 = *ldz;          // z 的第一维度大小为 ldz
    z_offset = 1 + z_dim1;  // 计算 z__ 数组的偏移量
    z__ -= z_offset;        // 调整 z__ 指针以访问正确的内存位置
    v_dim1 = *ldv;          // v 的第一维度大小为 ldv
    v_offset = 1 + v_dim1;  // 计算 v 数组的偏移量
    v -= v_offset;          // 调整 v 指针以访问正确的内存位置
    u_dim1 = *ldu;          // u 的第一维度大小为 ldu
    u_offset = 1 + u_dim1;  // 计算 u 数组的偏移量
    u -= u_offset;          // 调整 u 指针以访问正确的内存位置
    wv_dim1 = *ldwv;        // wv 的第一维度大小为 ldwv
    wv_offset = 1 + wv_dim1; // 计算 wv 数组的偏移量
    wv -= wv_offset;        // 调整 wv 指针以访问正确的内存位置
    wh_dim1 = *ldwh;        // wh 的第一维度大小为 ldwh
    wh_offset = 1 + wh_dim1; // 计算 wh 数组的偏移量
    wh -= wh_offset;        // 调整 wh 指针以访问正确的内存位置

    /* Function Body */
    if (*nshfts < 2) {      // 如果输入的 nshfts 小于 2，则返回 0
        return 0;
    }

    /*
       ==== If the active block is empty or 1-by-1, then there
       .    is nothing to do. ====
    */
    if (*ktop >= *kbot) {   // 如果 active block 为空或者只有一个元素，则返回 0
        return 0;
    }

    /*
       ==== NSHFTS is supposed to be even, but if it is odd,
       .    then simply reduce it by one.  ====
    */
    ns = *nshfts - *nshfts % 2;  // 如果 nshfts 是奇数，则减少它使其成为偶数

    /*     ==== Machine constants for deflation ==== */
    safmin = SAFEMINIMUM;   // 设置最小安全数值
    safmax = 1. / safmin;   // 设置最大安全数值
    dlabad_(&safmin, &safmax);  // 根据 safmin 和 safmax 计算机器精度
    ulp = PRECISION;        // 设置单位舍入误差
    smlnum = safmin * ((doublereal) (*n) / ulp);  // 计算小数值 smlnum

    /*
       ==== Use accumulated reflections to update far-from-diagonal
       .    entries ? ====
    */
    accum = *kacc22 == 1 || *kacc22 == 2;  // 根据 kacc22 的值判断是否累积反射

    /*     ==== If so, exploit the 2-by-2 block structure? ==== */
    blk22 = ns > 2 && *kacc22 == 2;  // 根据 ns 和 kacc22 的值判断是否利用2x2块结构

    /*     ==== clear trash ==== */
    if (*ktop + 2 <= *kbot) {  // 如果 active block 至少有3个元素，则清零垃圾值
        i__1 = *ktop + 2 + *ktop * h_dim1;
        h__[i__1].r = 0., h__[i__1].i = 0.;  // 将指定位置的 h 元素清零
    }

    /*     ==== NBMPS = number of 2-shift bulges in the chain ==== */
    nbmps = ns / 2;  // 计算 2-shift bulges 的数量

    /*     ==== KDU = width of slab ==== */
    kdu = nbmps * 6 - 3;  // 计算 slab 的宽度

    /*     ==== Create and chase chains of NBMPS bulges ==== */
    i__1 = *kbot - 2;
    i__2 = nbmps * 3 - 2;
    for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 :
        incol <= i__1; incol += i__2) {
        ndcol = incol + kdu;
        if (accum) {
            zlaset_("ALL", &kdu, &kdu, &c_b56, &c_b57, &u[u_offset], ldu);  // 如果累积，初始化 u
        }

        /*
          ==== Near-the-diagonal bulge chase.  The following loop
          .    performs the near-the-diagonal part of a small bulge
          .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
          .    chunk extends from column INCOL to column NDCOL
          .    (including both column INCOL and column NDCOL). The
          .    following loop chases a 3*NBMPS column long chain of
          .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
          .    may be less than KTOP and and NDCOL may be greater than
          .    KBOT indicating phantom columns from which to chase
          .    bulges before they are actually introduced or to which
          .    to chase bulges beyond column KBOT.)  ====

           Computing MIN
        */
        i__4 = incol + nbmps * 3 - 3, i__5 = *kbot - 2;
        i__3 = min(i__4,i__5);  // 计算当前追踪的列数上限
        for (krcol = incol; krcol <= i__3; ++krcol) {
/*
             ==== Bulges number MTOP to MBOT are active double implicit
             .    shift bulges.  There may or may not also be small
             .    2-by-2 bulge, if there is room.  The inactive bulges
             .    (if any) must wait until the active bulges have moved
             .    down the diagonal to make room.  The phantom matrix
             .    paradigm described above helps keep track.  ====

   Computing MAX
*/
// 计算 MTOP 的值，表示活跃的双隐式位移的突起数目
i__4 = 1, i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
mtop = max(i__4,i__5);

/* Computing MIN */
// 计算 MBOT 的值，表示活跃的双隐式位移的底部边界
i__4 = nbmps, i__5 = (*kbot - krcol) / 3;
mbot = min(i__4,i__5);

// 计算 m22 的值，代表 2-by-2 位移的底部边界加一
m22 = mbot + 1;

// 计算 bmp22 是否为真，表示是否有足够空间容纳一个 2-by-2 位移
bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

/*
             ==== Generate reflections to chase the chain right
             .    one column.  (The minimum value of K is KTOP-1.) ====
*/
// 对每个活跃的位移生成反射以推进右边的链
i__4 = mbot;
for (m = mtop; m <= i__4; ++m) {
    // 计算当前位移的起始列索引 k
    k = krcol + (m - 1) * 3;

    // 如果 k 刚好是 KTOP-1，则执行特殊的反射生成过程
    if (k == *ktop - 1) {
        zlaqr1_(&c__3, &h__[*ktop + *ktop * h_dim1], ldh, &s[(m << 1) - 1], &s[m * 2], &v[m * v_dim1 + 1]);
        i__5 = m * v_dim1 + 1;
        alpha.r = v[i__5].r, alpha.i = v[i__5].i;
        zlarfg_(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);
    } else {
        // 否则，执行一般的反射生成过程
        i__5 = k + 1 + k * h_dim1;
        beta.r = h__[i__5].r, beta.i = h__[i__5].i;
        i__5 = m * v_dim1 + 2;
        i__6 = k + 2 + k * h_dim1;
        v[i__5].r = h__[i__6].r, v[i__5].i = h__[i__6].i;
        i__5 = m * v_dim1 + 3;
        i__6 = k + 3 + k * h_dim1;
        v[i__5].r = h__[i__6].r, v[i__5].i = h__[i__6].i;
        zlarfg_(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);

        /*
                   ==== A Bulge may collapse because of vigilant
                   .    deflation or destructive underflow.  In the
                   .    underflow case, try the two-small-subdiagonals
                   .    trick to try to reinflate the bulge.  ====
        */
        // 检查是否发生位移坍塌，如果发生了尝试重新膨胀位移
        i__5 = k + 3 + k * h_dim1;
        i__6 = k + 3 + (k + 1) * h_dim1;
        i__7 = k + 3 + (k + 2) * h_dim1;
        if (h__[i__5].r != 0. || h__[i__5].i != 0. || (h__[i__6].r != 0. || h__[i__6].i != 0.) || h__[i__7].r == 0. && h__[i__7].i == 0.) {
            // 典型情况下，位移没有坍塌，重置相关矩阵元素
            i__5 = k + 1 + k * h_dim1;
            h__[i__5].r = beta.r, h__[i__5].i = beta.i;
            i__5 = k + 2 + k * h_dim1;
            h__[i__5].r = 0., h__[i__5].i = 0.;
            i__5 = k + 3 + k * h_dim1;
            h__[i__5].r = 0., h__[i__5].i = 0.;
        } else {
            // 如果位移坍塌，执行特殊的处理方法

            // 在坍塌的情况下，尝试使用两个较小的次对角线元素重新膨胀位移
            i__5 = k + 1 + k * h_dim1;
            h__[i__5].r = beta.r, h__[i__5].i = beta.i;
            i__5 = k + 2 + k * h_dim1;
            h__[i__5].r = 0., h__[i__5].i = 0.;
            i__5 = k + 3 + k * h_dim1;
            h__[i__5].r = 0., h__[i__5].i = 0.;
        }
    }
}
/*
  ==== Atypical case: collapsed.  Attempt to
  .    reintroduce ignoring H(K+1,K) and H(K+2,K).
  .    If the fill resulting from the new
  .    reflector is too large, then abandon it.
  .    Otherwise, use the new one. ====
*/

zlaqr1_(&c__3, &h__[k + 1 + (k + 1) * h_dim1], ldh, &
    s[(m << 1) - 1], &s[m * 2], vt);
// 调用 LAPACK 子程序 zlaqr1_，处理 H 矩阵的特征值问题，生成新的反射器 vt

alpha.r = vt[0].r, alpha.i = vt[0].i;
// alpha 是 vt 的第一个元素的复数共轭，用于后续计算

zlarfg_(&c__3, &alpha, &vt[1], &c__1, vt);
// 使用 LAPACK 子程序 zlarfg_，计算 alpha 和 vt 中其余元素的 Householder 变换

d_cnjg(&z__2, vt);
// 复数共轭运算

i__5 = k + 1 + k * h_dim1;
d_cnjg(&z__5, &vt[1]);
i__6 = k + 2 + k * h_dim1;
z__4.r = z__5.r * h__[i__6].r - z__5.i * h__[i__6].i,
    z__4.i = z__5.r * h__[i__6].i + z__5.i * h__[i__6].r;
z__3.r = h__[i__5].r + z__4.r, z__3.i = h__[i__5].i +
    z__4.i;
z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i =
    z__2.r * z__3.i + z__2.i * z__3.r;
refsum.r = z__1.r, refsum.i = z__1.i;
// 计算 refsum，用于判断是否需要保留旧的反射器

i__5 = k + 2 + k * h_dim1;
z__3.r = refsum.r * vt[1].r - refsum.i * vt[1].i,
    z__3.i = refsum.r * vt[1].i + refsum.i * vt[1]
    .r;
z__2.r = h__[i__5].r - z__3.r, z__2.i = h__[i__5].i -
    z__3.i;
z__1.r = z__2.r, z__1.i = z__2.i;
z__5.r = refsum.r * vt[2].r - refsum.i * vt[2].i,
    z__5.i = refsum.r * vt[2].i + refsum.i * vt[2]
    .r;
z__4.r = z__5.r, z__4.i = z__5.i;
i__6 = k + k * h_dim1;
i__7 = k + 1 + (k + 1) * h_dim1;
i__8 = k + 2 + (k + 2) * h_dim1;
if ((d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1)
    , abs(d__2)) + ((d__3 = z__4.r, abs(d__3)) + (
    d__4 = d_imag(&z__4), abs(d__4))) > ulp * ((
    d__5 = h__[i__6].r, abs(d__5)) + (d__6 =
    d_imag(&h__[k + k * h_dim1]), abs(d__6)) + ((
    d__7 = h__[i__7].r, abs(d__7)) + (d__8 =
    d_imag(&h__[k + 1 + (k + 1) * h_dim1]), abs(
    d__8))) + ((d__9 = h__[i__8].r, abs(d__9)) + (
    d__10 = d_imag(&h__[k + 2 + (k + 2) * h_dim1])
    , abs(d__10))))) {
  /*
     ==== Starting a new bulge here would
     .    create non-negligible fill.  Use
     .    the old one with trepidation. ====
  */
  // 如果新反射器导致填充过大，则保留旧反射器

  i__5 = k + 1 + k * h_dim1;
  h__[i__5].r = beta.r, h__[i__5].i = beta.i;
  // 使用 beta 替换 H(K+1,K)

  i__5 = k + 2 + k * h_dim1;
  h__[i__5].r = 0., h__[i__5].i = 0.;
  // 将 H(K+2,K) 置为零

  i__5 = k + 3 + k * h_dim1;
  h__[i__5].r = 0., h__[i__5].i = 0.;
  // 将 H(K+3,K) 置为零
} else {
/*
                         ==== Stating a new bulge here would
                         .    create only negligible fill.
                         .    Replace the old reflector with
                         .    the new one. ====
*/

                // 计算数组索引 i__5
                i__5 = k + 1 + k * h_dim1;
                // 计算新的 h__ 值，使用 refsum 计算差值
                i__6 = k + 1 + k * h_dim1;
                z__1.r = h__[i__6].r - refsum.r, z__1.i = h__[i__6].i - refsum.i;
                h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
                // 将 h__ 的下一个元素置为零
                i__5 = k + 2 + k * h_dim1;
                h__[i__5].r = 0., h__[i__5].i = 0.;
                // 将 h__ 的再下一个元素置为零
                i__5 = k + 3 + k * h_dim1;
                h__[i__5].r = 0., h__[i__5].i = 0.;
                // 将 vt 中的值复制到 v 中相应位置
                i__5 = m * v_dim1 + 1;
                v[i__5].r = vt[0].r, v[i__5].i = vt[0].i;
                i__5 = m * v_dim1 + 2;
                v[i__5].r = vt[1].r, v[i__5].i = vt[1].i;
                i__5 = m * v_dim1 + 3;
                v[i__5].r = vt[2].r, v[i__5].i = vt[2].i;
            }
            }
        }
/* L10: */
        }

/*           ==== Generate a 2-by-2 reflection, if needed. ==== */

        // 计算 k 的值
        k = krcol + (m22 - 1) * 3;
        // 检查是否需要生成一个 2x2 反射
        if (bmp22) {
        // 如果 k 等于 ktop - 1，则生成 2x2 反射
        if (k == *ktop - 1) {
            // 调用 zlaqr1 函数生成反射
            zlaqr1_(&c__2, &h__[k + 1 + (k + 1) * h_dim1], ldh, &s[(
                m22 << 1) - 1], &s[m22 * 2], &v[m22 * v_dim1 + 1])
                ;
            // 将生成的 beta 值赋给 v 中对应位置
            i__4 = m22 * v_dim1 + 1;
            beta.r = v[i__4].r, beta.i = v[i__4].i;
            // 调用 zlarfg 函数
            zlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22
                * v_dim1 + 1]);
        } else {
            // 否则，从 h__ 中获取 beta 值
            i__4 = k + 1 + k * h_dim1;
            beta.r = h__[i__4].r, beta.i = h__[i__4].i;
            // 将 h__ 中的值复制到 v 中相应位置
            i__4 = m22 * v_dim1 + 2;
            i__5 = k + 2 + k * h_dim1;
            v[i__4].r = h__[i__5].r, v[i__4].i = h__[i__5].i;
            // 调用 zlarfg 函数
            zlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22
                * v_dim1 + 1]);
            // 将 beta 值写回 h__
            i__4 = k + 1 + k * h_dim1;
            h__[i__4].r = beta.r, h__[i__4].i = beta.i;
            // 将 h__ 的下一个元素置为零
            i__4 = k + 2 + k * h_dim1;
            h__[i__4].r = 0., h__[i__4].i = 0.;
        }
        }

/*           ==== Multiply H by reflections from the left ==== */

        // 根据 accum, wantt, kbot 的值确定 jbot
        if (accum) {
        jbot = min(ndcol,*kbot);
        } else if (*wantt) {
        jbot = *n;
        } else {
        jbot = *kbot;
        }
        // 循环乘以左侧反射
        i__4 = jbot;
        for (j = max(*ktop,krcol); j <= i__4; ++j) {
/* 计算 MIN */
        // 计算 mend 取 mbot 和 (j - krcol + 2) / 3 中较小的值
        i__5 = mbot, i__6 = (j - krcol + 2) / 3;
        mend = min(i__5,i__6);
        i__5 = mend;
        // 循环遍历 mtop 到 mend 之间的 m 值
        for (m = mtop; m <= i__5; ++m) {
            // 计算当前 k 的值
            k = krcol + (m - 1) * 3;
            // 计算复数的共轭并存储到 z__2 中
            d_cnjg(&z__2, &v[m * v_dim1 + 1]);
            // 计算 h__[k+1+j*h_dim1] 的复数乘积并存储到 z__5 中
            i__6 = k + 1 + j * h_dim1;
            d_cnjg(&z__6, &v[m * v_dim1 + 2]);
            i__7 = k + 2 + j * h_dim1;
            z__5.r = z__6.r * h__[i__7].r - z__6.i * h__[i__7].i,
                z__5.i = z__6.r * h__[i__7].i + z__6.i * h__[i__7]
                .r;
            // 计算 z__4，即 h__[k+1+j*h_dim1] 加上 z__5 的结果
            z__4.r = h__[i__6].r + z__5.r, z__4.i = h__[i__6].i +
                z__5.i;
            // 计算 h__[k+3+j*h_dim1] 的复数乘积并存储到 z__7 中
            d_cnjg(&z__8, &v[m * v_dim1 + 3]);
            i__8 = k + 3 + j * h_dim1;
            z__7.r = z__8.r * h__[i__8].r - z__8.i * h__[i__8].i,
                z__7.i = z__8.r * h__[i__8].i + z__8.i * h__[i__8]
                .r;
            // 计算 z__3，即 z__4 加上 z__7 的结果
            z__3.r = z__4.r + z__7.r, z__3.i = z__4.i + z__7.i;
            // 计算 z__1，即 z__2 乘以 z__3 的复数乘积
            z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i =
                z__2.r * z__3.i + z__2.i * z__3.r;
            // 将结果存储到 refsum 中
            refsum.r = z__1.r, refsum.i = z__1.i;
            // 更新 h__[k+1+j*h_dim1]，将其减去 refsum 的值
            i__6 = k + 1 + j * h_dim1;
            i__7 = k + 1 + j * h_dim1;
            z__1.r = h__[i__7].r - refsum.r, z__1.i = h__[i__7].i -
                refsum.i;
            h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
            // 更新 h__[k+2+j*h_dim1]，将其减去 refsum 与 v[m* v_dim1 + 2] 的复数乘积的值
            i__6 = k + 2 + j * h_dim1;
            i__7 = k + 2 + j * h_dim1;
            i__8 = m * v_dim1 + 2;
            z__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i,
                z__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8]
                .r;
            z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i -
                z__2.i;
            h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
            // 更新 h__[k+3+j*h_dim1]，将其减去 refsum 与 v[m* v_dim1 + 3] 的复数乘积的值
            i__6 = k + 3 + j * h_dim1;
            i__7 = k + 3 + j * h_dim1;
            i__8 = m * v_dim1 + 3;
            z__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i,
                z__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8]
                .r;
            z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i -
                z__2.i;
            h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
/* L20: */
        }
/* L30: */
        }
        // 如果 bmp22 为真，则执行以下操作
        if (bmp22) {
            // 计算当前 k 的值
            k = krcol + (m22 - 1) * 3;
/* Computing MAX */
/* 计算最大值 */
        i__4 = k + 1;
/* 设置循环变量的初始值 */
        i__5 = jbot;
/* 设置循环的终止条件 */
        for (j = max(i__4,*ktop); j <= i__5; ++j) {
/* 循环：从 max(i__4,*ktop) 开始到 i__5，每次增加1 */
            d_cnjg(&z__2, &v[m22 * v_dim1 + 1]);
/* 计算共轭 */
            i__4 = k + 1 + j * h_dim1;
/* 计算索引 */
            d_cnjg(&z__5, &v[m22 * v_dim1 + 2]);
/* 计算共轭 */
            i__6 = k + 2 + j * h_dim1;
/* 计算索引 */
            z__4.r = z__5.r * h__[i__6].r - z__5.i * h__[i__6].i,
/* 计算实部 */
                z__4.i = z__5.r * h__[i__6].i + z__5.i * h__[i__6].r;
/* 计算虚部 */
            z__3.r = h__[i__4].r + z__4.r, z__3.i = h__[i__4].i +
                z__4.i;
/* 计算和 */
            z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i =
                z__2.r * z__3.i + z__2.i * z__3.r;
/* 计算乘积 */
            refsum.r = z__1.r, refsum.i = z__1.i;
/* 赋值 */
            i__4 = k + 1 + j * h_dim1;
/* 计算索引 */
            i__6 = k + 1 + j * h_dim1;
/* 计算索引 */
            z__1.r = h__[i__6].r - refsum.r, z__1.i = h__[i__6].i -
                refsum.i;
/* 计算差 */
            h__[i__4].r = z__1.r, h__[i__4].i = z__1.i;
/* 赋值 */
            i__4 = k + 2 + j * h_dim1;
/* 计算索引 */
            i__6 = k + 2 + j * h_dim1;
/* 计算索引 */
            i__7 = m22 * v_dim1 + 2;
/* 计算索引 */
            z__2.r = refsum.r * v[i__7].r - refsum.i * v[i__7].i,
/* 计算实部 */
                z__2.i = refsum.r * v[i__7].i + refsum.i * v[i__7].r;
/* 计算虚部 */
            z__1.r = h__[i__6].r - z__2.r, z__1.i = h__[i__6].i -
                z__2.i;
/* 计算差 */
            h__[i__4].r = z__1.r, h__[i__4].i = z__1.i;
/* L40: */
/* 标签 */
        }
/* 结束循环 */

/*
             ==== Multiply H by reflections from the right.
             .    Delay filling in the last row until the
             .    vigilant deflation check is complete. ====
*/

/* 如果积累，设置 jtop 为 *ktop 和 incol 中的最大值；否则，如果要计算 T 矩阵，设置为 1；否则设置为 *ktop */
        if (accum) {
        jtop = max(*ktop,incol);
        } else if (*wantt) {
        jtop = 1;
        } else {
        jtop = *ktop;
        }
/* 设置循环的终止条件 */
        i__5 = mbot;
/* 循环：从 mtop 开始到 i__5，每次增加1 */
        for (m = mtop; m <= i__5; ++m) {
/* 如果 v[m * v_dim1 + 1] 的实部或虚部不为零 */
        i__4 = m * v_dim1 + 1;
        if (v[i__4].r != 0. || v[i__4].i != 0.) {
/* 计算 k 的值 */
            k = krcol + (m - 1) * 3;
/* 设置循环的终止条件 */
/* Computing MIN */
/* 计算最小值 */
i__6 = *kbot, i__7 = k + 3;
/* 取得 *kbot 和 k + 3 的值 */
i__4 = min(i__6, i__7);
/* 计算 i__4 为 *kbot 和 k + 3 的较小值 */
for (j = jtop; j <= i__4; ++j) {
/* 循环遍历 j 从 jtop 到 i__4 */
i__6 = m * v_dim1 + 1;
/* 计算数组索引 m * v_dim1 + 1 */
i__7 = j + (k + 1) * h_dim1;
/* 计算数组索引 j + (k + 1) * h_dim1 */
i__8 = m * v_dim1 + 2;
/* 计算数组索引 m * v_dim1 + 2 */
i__9 = j + (k + 2) * h_dim1;
/* 计算数组索引 j + (k + 2) * h_dim1 */
z__4.r = v[i__8].r * h__[i__9].r - v[i__8].i * h__[i__9].i, z__4.i = v[i__8].r * h__[i__9].i + v[i__8].i * h__[i__9].r;
/* 计算复数乘法并将结果存储在 z__4 中 */
z__3.r = h__[i__7].r + z__4.r, z__3.i = h__[i__7].i + z__4.i;
/* 计算复数加法并将结果存储在 z__3 中 */
i__10 = m * v_dim1 + 3;
/* 计算数组索引 m * v_dim1 + 3 */
i__11 = j + (k + 3) * h_dim1;
/* 计算数组索引 j + (k + 3) * h_dim1 */
z__5.r = v[i__10].r * h__[i__11].r - v[i__10].i * h__[i__11].i, z__5.i = v[i__10].r * h__[i__11].i + v[i__10].i * h__[i__11].r;
/* 计算复数乘法并将结果存储在 z__5 中 */
z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
/* 计算复数加法并将结果存储在 z__2 中 */
z__1.r = v[i__6].r * z__2.r - v[i__6].i * z__2.i, z__1.i = v[i__6].r * z__2.i + v[i__6].i * z__2.r;
/* 计算复数乘法并将结果存储在 z__1 中，最终结果存储在 refsum 中 */
refsum.r = z__1.r, refsum.i = z__1.i;
/* 将复数结果存储在 refsum 中 */
i__6 = j + (k + 1) * h_dim1;
/* 计算数组索引 j + (k + 1) * h_dim1 */
i__7 = j + (k + 1) * h_dim1;
/* 计算数组索引 j + (k + 1) * h_dim1 */
z__1.r = h__[i__7].r - refsum.r, z__1.i = h__[i__7].i - refsum.i;
/* 计算复数减法并将结果存储在 h__ 中 */
h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
/* 将结果存储在 h__ 中 */
i__6 = j + (k + 2) * h_dim1;
/* 计算数组索引 j + (k + 2) * h_dim1 */
i__7 = j + (k + 2) * h_dim1;
/* 计算数组索引 j + (k + 2) * h_dim1 */
d_cnjg(&z__3, &v[m * v_dim1 + 2]);
/* 计算 v[m * v_dim1 + 2] 的共轭复数并将结果存储在 z__3 中 */
z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;
/* 计算复数乘法并将结果存储在 z__2 中 */
z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i - z__2.i;
/* 计算复数减法并将结果存储在 h__ 中 */
h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
/* 将结果存储在 h__ 中 */
i__6 = j + (k + 3) * h_dim1;
/* 计算数组索引 j + (k + 3) * h_dim1 */
i__7 = j + (k + 3) * h_dim1;
/* 计算数组索引 j + (k + 3) * h_dim1 */
d_cnjg(&z__3, &v[m * v_dim1 + 3]);
/* 计算 v[m * v_dim1 + 3] 的共轭复数并将结果存储在 z__3 中 */
z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;
/* 计算复数乘法并将结果存储在 z__2 中 */
z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i - z__2.i;
/* 计算复数减法并将结果存储在 h__ 中 */
h__[i__6].r = z__1.r, h__[i__6].i = z__1.i;
/* 将结果存储在 h__ 中 */
/* L50: */
/* L50: */
}

if (accum) {

/*
              ==== Accumulate U. (If necessary, update Z later
              .    with an efficient matrix-matrix
              .    multiply.) ====
*/

/* 累加 U 矩阵。如果需要，稍后使用高效的矩阵乘法更新 Z */
kms = k - incol;
/* 计算 kms 为 k - incol */
/* Computing MAX */
/* 计算 MAX 值，选择 j 的起始值 */
i__4 = 1, i__6 = *ktop - incol;
/* 初始化 j 的起始值为 i__4 和 i__6 中的较大值 */
i__7 = kdu;
/* 循环遍历 j 的范围，从 max(i__4, i__6) 到 i__7 */
for (j = max(i__4,i__6); j <= i__7; ++j) {
    /* 计算数组索引 */
    i__4 = m * v_dim1 + 1;
    i__6 = j + (kms + 1) * u_dim1;
    i__8 = m * v_dim1 + 2;
    i__9 = j + (kms + 2) * u_dim1;
    /* 复数运算：计算 z__4 和 z__3 */
    z__4.r = v[i__8].r * u[i__9].r - v[i__8].i * u[i__9].i, z__4.i = v[i__8].r * u[i__9].i + v[i__8].i * u[i__9].r;
    z__3.r = u[i__6].r + z__4.r, z__3.i = u[i__6].i + z__4.i;
    i__10 = m * v_dim1 + 3;
    i__11 = j + (kms + 3) * u_dim1;
    z__5.r = v[i__10].r * u[i__11].r - v[i__10].i * u[i__11].i, z__5.i = v[i__10].r * u[i__11].i + v[i__10].i * u[i__11].r;
    z__2.r = z__3.r + z__5.r, z__2.i = z__3.i + z__5.i;
    z__1.r = v[i__4].r * z__2.r - v[i__4].i * z__2.i, z__1.i = v[i__4].r * z__2.i + v[i__4].i * z__2.r;
    /* 更新 refsum 的值 */
    refsum.r = z__1.r, refsum.i = z__1.i;
    /* 计算数组索引 */
    i__4 = j + (kms + 1) * u_dim1;
    i__6 = j + (kms + 1) * u_dim1;
    z__1.r = u[i__6].r - refsum.r, z__1.i = u[i__6].i - refsum.i;
    /* 更新 u 数组的值 */
    u[i__4].r = z__1.r, u[i__4].i = z__1.i;
    /* 计算数组索引 */
    i__4 = j + (kms + 2) * u_dim1;
    i__6 = j + (kms + 2) * u_dim1;
    /* 复数共轭运算：计算 z__3 和 z__2 */
    d_cnjg(&z__3, &v[m * v_dim1 + 2]);
    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;
    z__1.r = u[i__6].r - z__2.r, z__1.i = u[i__6].i - z__2.i;
    /* 更新 u 数组的值 */
    u[i__4].r = z__1.r, u[i__4].i = z__1.i;
    /* 计算数组索引 */
    i__4 = j + (kms + 3) * u_dim1;
    i__6 = j + (kms + 3) * u_dim1;
    /* 复数共轭运算：计算 z__3 和 z__2 */
    d_cnjg(&z__3, &v[m * v_dim1 + 3]);
    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;
    z__1.r = u[i__6].r - z__2.r, z__1.i = u[i__6].i - z__2.i;
    /* 更新 u 数组的值 */
    u[i__4].r = z__1.r, u[i__4].i = z__1.i;
    /* L60: */
}
/* L60: */
} else if (*wantz) {
/* 若 wantz 为真，则更新 Z 矩阵 */
/* U 没有累积，所以现在通过右侧的反射更新 Z */
/* 更新 Z 矩阵，乘以右侧的反射 */
            i__7 = *ihiz;
            // 循环：j 从 iloz 到 ihiz
            for (j = *iloz; j <= i__7; ++j) {
                i__4 = m * v_dim1 + 1;
                // 计算复数乘法结果并加到 z__[j + (k + 1) * z_dim1] 上
                i__6 = j + (k + 1) * z_dim1;
                i__8 = m * v_dim1 + 2;
                i__9 = j + (k + 2) * z_dim1;
                z__4.r = v[i__8].r * z__[i__9].r - v[i__8].i *
                    z__[i__9].i, z__4.i = v[i__8].r * z__[
                    i__9].i + v[i__8].i * z__[i__9].r;
                z__3.r = z__[i__6].r + z__4.r, z__3.i = z__[i__6]
                    .i + z__4.i;
                i__10 = m * v_dim1 + 3;
                i__11 = j + (k + 3) * z_dim1;
                z__5.r = v[i__10].r * z__[i__11].r - v[i__10].i *
                    z__[i__11].i, z__5.i = v[i__10].r * z__[
                    i__11].i + v[i__10].i * z__[i__11].r;
                z__2.r = z__3.r + z__5.r, z__2.i = z__3.i +
                    z__5.i;
                z__1.r = v[i__4].r * z__2.r - v[i__4].i * z__2.i,
                    z__1.i = v[i__4].r * z__2.i + v[i__4].i *
                    z__2.r;
                // 将结果赋给 refsum
                refsum.r = z__1.r, refsum.i = z__1.i;
                // 更新 z__[j + (k + 1) * z_dim1]
                i__4 = j + (k + 1) * z_dim1;
                i__6 = j + (k + 1) * z_dim1;
                z__1.r = z__[i__6].r - refsum.r, z__1.i = z__[
                    i__6].i - refsum.i;
                z__[i__4].r = z__1.r, z__[i__4].i = z__1.i;
                // 更新 z__[j + (k + 2) * z_dim1]
                i__4 = j + (k + 2) * z_dim1;
                i__6 = j + (k + 2) * z_dim1;
                d_cnjg(&z__3, &v[m * v_dim1 + 2]);
                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i,
                    z__2.i = refsum.r * z__3.i + refsum.i *
                    z__3.r;
                z__1.r = z__[i__6].r - z__2.r, z__1.i = z__[i__6]
                    .i - z__2.i;
                z__[i__4].r = z__1.r, z__[i__4].i = z__1.i;
                // 更新 z__[j + (k + 3) * z_dim1]
                i__4 = j + (k + 3) * z_dim1;
                i__6 = j + (k + 3) * z_dim1;
                d_cnjg(&z__3, &v[m * v_dim1 + 3]);
                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i,
                    z__2.i = refsum.r * z__3.i + refsum.i *
                    z__3.r;
                z__1.r = z__[i__6].r - z__2.r, z__1.i = z__[i__6]
                    .i - z__2.i;
                z__[i__4].r = z__1.r, z__[i__4].i = z__1.i;
                // 结束 j 的循环体
/* L70: */
            }
            // 结束 i__7 的循环体
            }
        }
/* L80: */
        }

/*           ==== Special case: 2-by-2 reflection (if needed) ==== */

        // 计算 k 的值
        k = krcol + (m22 - 1) * 3;
        // 判断是否需要进行 2x2 反射
        i__5 = m22 * v_dim1 + 1;
        if (bmp22 && (v[i__5].r != 0. || v[i__5].i != 0.)) {
/* Computing MIN */
/* 计算 MIN 函数的结果，选择最小的一个值 */
        i__7 = *kbot, i__4 = k + 3;
        i__5 = min(i__7,i__4);
        /* 循环迭代，处理从 jtop 到 i__5 的 j 值 */
        for (j = jtop; j <= i__5; ++j) {
            /* 计算数组索引 */
            i__7 = m22 * v_dim1 + 1;
            i__4 = j + (k + 1) * h_dim1;
            i__6 = m22 * v_dim1 + 2;
            i__8 = j + (k + 2) * h_dim1;
            /* 复数运算 */
            z__3.r = v[i__6].r * h__[i__8].r - v[i__6].i * h__[i__8]
                .i, z__3.i = v[i__6].r * h__[i__8].i + v[i__6].i *
                 h__[i__8].r;
            z__2.r = h__[i__4].r + z__3.r, z__2.i = h__[i__4].i +
                z__3.i;
            z__1.r = v[i__7].r * z__2.r - v[i__7].i * z__2.i, z__1.i =
                 v[i__7].r * z__2.i + v[i__7].i * z__2.r;
            /* 将结果赋给 refsum 变量 */
            refsum.r = z__1.r, refsum.i = z__1.i;
            i__7 = j + (k + 1) * h_dim1;
            i__4 = j + (k + 1) * h_dim1;
            /* 更新数组值 */
            z__1.r = h__[i__4].r - refsum.r, z__1.i = h__[i__4].i -
                refsum.i;
            h__[i__7].r = z__1.r, h__[i__7].i = z__1.i;
            i__7 = j + (k + 2) * h_dim1;
            i__4 = j + (k + 2) * h_dim1;
            /* 复数共轭乘法 */
            d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);
            z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i =
                refsum.r * z__3.i + refsum.i * z__3.r;
            /* 更新数组值 */
            z__1.r = h__[i__4].r - z__2.r, z__1.i = h__[i__4].i -
                z__2.i;
            h__[i__7].r = z__1.r, h__[i__7].i = z__1.i;
/* L90: */
        }

        /* 如果 accum 为真 */
        if (accum) {
            /* 计算 kms 变量 */
            kms = k - incol;
/* Computing MAX */
/* 计算 MAX 函数的结果，选择最大的一个值 */
            i__5 = 1, i__7 = *ktop - incol;
            i__4 = kdu;
            /* 循环迭代，处理从 max(i__5,i__7) 到 i__4 的 j 值 */
            for (j = max(i__5,i__7); j <= i__4; ++j) {
            i__5 = m22 * v_dim1 + 1;
            i__7 = j + (kms + 1) * u_dim1;
            i__6 = m22 * v_dim1 + 2;
            i__8 = j + (kms + 2) * u_dim1;
            /* 复数运算 */
            z__3.r = v[i__6].r * u[i__8].r - v[i__6].i * u[i__8]
                .i, z__3.i = v[i__6].r * u[i__8].i + v[i__6]
                .i * u[i__8].r;
            z__2.r = u[i__7].r + z__3.r, z__2.i = u[i__7].i +
                z__3.i;
            z__1.r = v[i__5].r * z__2.r - v[i__5].i * z__2.i,
                z__1.i = v[i__5].r * z__2.i + v[i__5].i *
                z__2.r;
            /* 将结果赋给 refsum 变量 */
            refsum.r = z__1.r, refsum.i = z__1.i;
            i__5 = j + (kms + 1) * u_dim1;
            i__7 = j + (kms + 1) * u_dim1;
            /* 更新数组值 */
            z__1.r = u[i__7].r - refsum.r, z__1.i = u[i__7].i -
                refsum.i;
            u[i__5].r = z__1.r, u[i__5].i = z__1.i;
            i__5 = j + (kms + 2) * u_dim1;
            i__7 = j + (kms + 2) * u_dim1;
            /* 复数共轭乘法 */
            d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);
            z__2.r = refsum.r * z__3.r - refsum.i * z__3.i,
                z__2.i = refsum.r * z__3.i + refsum.i *
                z__3.r;
            /* 更新数组值 */
            z__1.r = u[i__7].r - z__2.r, z__1.i = u[i__7].i -
                z__2.i;
            u[i__5].r = z__1.r, u[i__5].i = z__1.i;
/* L100: */
            }
        } else if (*wantz) {
            // 如果需要计算Z矩阵
            i__4 = *ihiz;
            for (j = *iloz; j <= i__4; ++j) {
                // 计算乘积和差，更新Z矩阵中的元素
                i__5 = m22 * v_dim1 + 1;
                i__7 = j + (k + 1) * z_dim1;
                i__6 = m22 * v_dim1 + 2;
                i__8 = j + (k + 2) * z_dim1;
                z__3.r = v[i__6].r * z__[i__8].r - v[i__6].i * z__[i__8].i, z__3.i = v[i__6].r * z__[i__8].i + v[i__6].i * z__[i__8].r;
                z__2.r = z__[i__7].r + z__3.r, z__2.i = z__[i__7].i + z__3.i;
                z__1.r = v[i__5].r * z__2.r - v[i__5].i * z__2.i, z__1.i = v[i__5].r * z__2.i + v[i__5].i * z__2.r;
                refsum.r = z__1.r, refsum.i = z__1.i;
                i__5 = j + (k + 1) * z_dim1;
                i__7 = j + (k + 1) * z_dim1;
                z__1.r = z__[i__7].r - refsum.r, z__1.i = z__[i__7].i - refsum.i;
                z__[i__5].r = z__1.r, z__[i__5].i = z__1.i;
                i__5 = j + (k + 2) * z_dim1;
                i__7 = j + (k + 2) * z_dim1;
                d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);
                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;
                z__1.r = z__[i__7].r - z__2.r, z__1.i = z__[i__7].i - z__2.i;
                z__[i__5].r = z__1.r, z__[i__5].i = z__1.i;
/* L110: */
            }
        }
        }

/*           ==== Vigilant deflation check ==== */

        mstart = mtop;
        if (krcol + (mstart - 1) * 3 < *ktop) {
            // 如果某些列需要进行额外的检查以防止过早的收缩
            ++mstart;
        }
        mend = mbot;
        if (bmp22) {
            // 如果有额外的块需要处理
            ++mend;
        }
        if (krcol == *kbot - 2) {
            // 在边界情况下增加块的处理
            ++mend;
        }
        i__4 = mend;
        for (m = mstart; m <= i__4; ++m) {
            // 计算当前块的下标
/* Computing MIN */
        i__5 = *kbot - 1, i__7 = krcol + (m - 1) * 3;
        k = min(i__5,i__7);

/*
                ==== The following convergence test requires that
                .    the tradition small-compared-to-nearby-diagonals
                .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
                .    criteria both be satisfied.  The latter improves
                .    accuracy in some examples. Falling back on an
                .    alternate convergence criterion when TST1 or TST2
                .    is zero (as done here) is traditional but probably
                .    unnecessary. ====
        i__5 = k + 1 + k * h_dim1;
        // 计算 h[k+1][k] 在一维数组 h__ 中的索引位置

        if (h__[i__5].r != 0. || h__[i__5].i != 0.) {
            // 如果 h[k+1][k] 的实部或虚部不为零，则执行以下操作

            i__5 = k + k * h_dim1;
            i__7 = k + 1 + (k + 1) * h_dim1;
            // 计算 h[k][k] 和 h[k+1][k+1] 在 h__ 中的索引位置

            tst1 = (d__1 = h__[i__5].r, abs(d__1)) + (d__2 = d_imag(&
                h__[k + k * h_dim1]), abs(d__2)) + ((d__3 = h__[
                i__7].r, abs(d__3)) + (d__4 = d_imag(&h__[k + 1 +
                (k + 1) * h_dim1]), abs(d__4)));
            // 计算 tst1，包括 h[k][k]、h[k][k] 的虚部、h[k+1][k+1]、h[k+1][k+1] 的虚部的绝对值之和

            if (tst1 == 0.) {
                // 如果 tst1 等于零，则进一步检查以下条件

                if (k >= *ktop + 1) {
                    i__5 = k + (k - 1) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + (k - 1) * h_dim1]), abs(
                        d__2));
                    // 如果 k 大于等于 ktop+1，则加上 h[k][k-1] 和其虚部的绝对值
                }
                if (k >= *ktop + 2) {
                    i__5 = k + (k - 2) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + (k - 2) * h_dim1]), abs(
                        d__2));
                    // 如果 k 大于等于 ktop+2，则加上 h[k][k-2] 和其虚部的绝对值
                }
                if (k >= *ktop + 3) {
                    i__5 = k + (k - 3) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + (k - 3) * h_dim1]), abs(
                        d__2));
                    // 如果 k 大于等于 ktop+3，则加上 h[k][k-3] 和其虚部的绝对值
                }
                if (k <= *kbot - 2) {
                    i__5 = k + 2 + (k + 1) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + 2 + (k + 1) * h_dim1]),
                        abs(d__2));
                    // 如果 k 小于等于 kbot-2，则加上 h[k+2][k+1] 和其虚部的绝对值
                }
                if (k <= *kbot - 3) {
                    i__5 = k + 3 + (k + 1) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + 3 + (k + 1) * h_dim1]),
                        abs(d__2));
                    // 如果 k 小于等于 kbot-3，则加上 h[k+3][k+1] 和其虚部的绝对值
                }
                if (k <= *kbot - 4) {
                    i__5 = k + 4 + (k + 1) * h_dim1;
                    tst1 += (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                        d_imag(&h__[k + 4 + (k + 1) * h_dim1]),
                        abs(d__2));
                    // 如果 k 小于等于 kbot-4，则加上 h[k+4][k+1] 和其虚部的绝对值
                }
            }

            i__5 = k + 1 + k * h_dim1;
            // 计算 h[k+1][k] 在 h__ 中的索引位置

            /* Computing MAX */
            d__3 = smlnum, d__4 = ulp * tst1;
            // 计算 smlnum 和 ulp*tst1 中的较大值

            if ((d__1 = h__[i__5].r, abs(d__1)) + (d__2 = d_imag(&h__[
                k + 1 + k * h_dim1]), abs(d__2)) <= max(d__3,d__4)
                ) {
                // 如果 h[k+1][k] 的绝对值和其虚部的绝对值不超过 max(smlnum, ulp*tst1)，则执行以下操作

                /* Computing MAX */
                i__5 = k + 1 + k * h_dim1;
                i__7 = k + (k + 1) * h_dim1;
                d__5 = (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                    d_imag(&h__[k + 1 + k * h_dim1]), abs(d__2)),
                    d__6 = (d__3 = h__[i__7].r, abs(d__3)) + (
                    d__4 = d_imag(&h__[k + (k + 1) * h_dim1]),
                    abs(d__4));
                h12 = max(d__5,d__6);
                // 计算 h12 为 h[k+1][k] 和 h[k][k+1] 绝对值的较大值
/* Computing MIN */
/* 计算最小值 */

            i__5 = k + 1 + k * h_dim1;
            /* 计算数组索引 i__5 */
            i__7 = k + (k + 1) * h_dim1;
            /* 计算数组索引 i__7 */
            d__5 = (d__1 = h__[i__5].r, abs(d__1)) + (d__2 =
                d_imag(&h__[k + 1 + k * h_dim1]), abs(d__2)),
                d__6 = (d__3 = h__[i__7].r, abs(d__3)) + (
                d__4 = d_imag(&h__[k + (k + 1) * h_dim1]),
                abs(d__4));
            /* 计算两个复数的绝对值并求和，作为 d__5 和 d__6 */
            h21 = min(d__5,d__6);
            /* 计算 d__5 和 d__6 的最小值并赋给 h21 */

            i__5 = k + k * h_dim1;
            /* 计算数组索引 i__5 */
            i__7 = k + 1 + (k + 1) * h_dim1;
            /* 计算数组索引 i__7 */
            z__2.r = h__[i__5].r - h__[i__7].r, z__2.i = h__[i__5]
                .i - h__[i__7].i;
            /* 计算两个复数之差并赋给 z__2 */
            z__1.r = z__2.r, z__1.i = z__2.i;
            /* 将 z__2 的值赋给 z__1 */
/* Computing MAX */
/* 计算最大值 */

            i__6 = k + 1 + (k + 1) * h_dim1;
            /* 计算数组索引 i__6 */
            d__5 = (d__1 = h__[i__6].r, abs(d__1)) + (d__2 =
                d_imag(&h__[k + 1 + (k + 1) * h_dim1]), abs(
                d__2)), d__6 = (d__3 = z__1.r, abs(d__3)) + (
                d__4 = d_imag(&z__1), abs(d__4));
            /* 计算两个复数的绝对值并求和，作为 d__5 和 d__6 */
            h11 = max(d__5,d__6);
            /* 计算 d__5 和 d__6 的最大值并赋给 h11 */

            i__5 = k + k * h_dim1;
            /* 计算数组索引 i__5 */
            i__7 = k + 1 + (k + 1) * h_dim1;
            /* 计算数组索引 i__7 */
            z__2.r = h__[i__5].r - h__[i__7].r, z__2.i = h__[i__5]
                .i - h__[i__7].i;
            /* 计算两个复数之差并赋给 z__2 */
            z__1.r = z__2.r, z__1.i = z__2.i;
            /* 将 z__2 的值赋给 z__1 */
/* Computing MIN */
/* 计算最小值 */

            i__6 = k + 1 + (k + 1) * h_dim1;
            /* 计算数组索引 i__6 */
            d__5 = (d__1 = h__[i__6].r, abs(d__1)) + (d__2 =
                d_imag(&h__[k + 1 + (k + 1) * h_dim1]), abs(
                d__2)), d__6 = (d__3 = z__1.r, abs(d__3)) + (
                d__4 = d_imag(&z__1), abs(d__4));
            /* 计算两个复数的绝对值并求和，作为 d__5 和 d__6 */
            h22 = min(d__5,d__6);
            /* 计算 d__5 和 d__6 的最小值并赋给 h22 */

            scl = h11 + h12;
            /* 计算 h11 和 h12 的和并赋给 scl */
            tst2 = h22 * (h11 / scl);
            /* 计算 h22 乘以 h11/scl 的值并赋给 tst2 */

/* Computing MAX */
/* 计算最大值 */

            d__1 = smlnum, d__2 = ulp * tst2;
            /* 计算 smlnum 和 ulp*tst2 的最大值 */
            if (tst2 == 0. || h21 * (h12 / scl) <= max(d__1,d__2))
                 {
                /* 若 tst2 为零或 h21*(h12/scl) 小于 max(d__1,d__2) */
                i__5 = k + 1 + k * h_dim1;
                /* 计算数组索引 i__5 */
                h__[i__5].r = 0., h__[i__5].i = 0.;
                /* 将 h__[i__5] 的实部和虚部设为零 */
            }
            /* 结束条件 */
            }
        }
/* L120: */
/* L120 标签 */
        }

/*
             ==== Fill in the last row of each bulge. ====

   Computing MIN
/* 计算最小值 */
        i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
        mend = min(i__4,i__5);
        i__4 = mend;
        for (m = mtop; m <= i__4; ++m) {
        k = krcol + (m - 1) * 3;
        i__5 = m * v_dim1 + 1;
        i__7 = m * v_dim1 + 3;
        z__2.r = v[i__5].r * v[i__7].r - v[i__5].i * v[i__7].i,
            z__2.i = v[i__5].r * v[i__7].i + v[i__5].i * v[i__7]
            .r;
        i__6 = k + 4 + (k + 3) * h_dim1;
        z__1.r = z__2.r * h__[i__6].r - z__2.i * h__[i__6].i, z__1.i =
             z__2.r * h__[i__6].i + z__2.i * h__[i__6].r;
        refsum.r = z__1.r, refsum.i = z__1.i;
        i__5 = k + 4 + (k + 1) * h_dim1;
        z__1.r = -refsum.r, z__1.i = -refsum.i;
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
        i__5 = k + 4 + (k + 2) * h_dim1;
        z__2.r = -refsum.r, z__2.i = -refsum.i;
        d_cnjg(&z__3, &v[m * v_dim1 + 2]);
        z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r *
            z__3.i + z__2.i * z__3.r;
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
        i__5 = k + 4 + (k + 3) * h_dim1;
        i__7 = k + 4 + (k + 3) * h_dim1;
        d_cnjg(&z__3, &v[m * v_dim1 + 3]);
        z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i =
            refsum.r * z__3.i + refsum.i * z__3.r;
        z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i - z__2.i;
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
/* L130: */
        }


注释：


        i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
        // 计算可以迭代的最大次数，取 nbmps 和 (*kbot - krcol - 1) / 3 中较小的一个
        mend = min(i__4,i__5);
        // 将 mend 赋值给 i__4
        i__4 = mend;
        // 开始循环，m 从 mtop 开始，直到达到 mend 为止，每次递增
        for (m = mtop; m <= i__4; ++m) {
        // 计算 k 的值
        k = krcol + (m - 1) * 3;
        // 计算复数乘积并赋给 z__2
        i__5 = m * v_dim1 + 1;
        i__7 = m * v_dim1 + 3;
        z__2.r = v[i__5].r * v[i__7].r - v[i__5].i * v[i__7].i,
            z__2.i = v[i__5].r * v[i__7].i + v[i__5].i * v[i__7]
            .r;
        // 计算矩阵 h__ 中的位置，并将结果赋给 z__1
        i__6 = k + 4 + (k + 3) * h_dim1;
        z__1.r = z__2.r * h__[i__6].r - z__2.i * h__[i__6].i, z__1.i =
             z__2.r * h__[i__6].i + z__2.i * h__[i__6].r;
        // 将 z__1 的实部和虚部分别赋给 refsum 的实部和虚部
        refsum.r = z__1.r, refsum.i = z__1.i;
        // 计算矩阵 h__ 中的位置，并将 -refsum 的结果赋给 z__1
        i__5 = k + 4 + (k + 1) * h_dim1;
        z__1.r = -refsum.r, z__1.i = -refsum.i;
        // 将 z__1 的结果赋给 h__ 的相应位置
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
        // 计算矩阵 h__ 中的位置，并将 -refsum * 复数共轭(v[m * v_dim1 + 2]) 的结果赋给 z__1
        i__5 = k + 4 + (k + 2) * h_dim1;
        z__2.r = -refsum.r, z__2.i = -refsum.i;
        d_cnjg(&z__3, &v[m * v_dim1 + 2]);
        z__1.r = z__2.r * z__3.r - z__2.i * z__3.i, z__1.i = z__2.r *
            z__3.i + z__2.i * z__3.r;
        // 将 z__1 的结果赋给 h__ 的相应位置
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
        // 计算矩阵 h__ 中的位置，并将 h__[i__7] - refsum * 复数共轭(v[m * v_dim1 + 3]) 的结果赋给 z__1
        i__5 = k + 4 + (k + 3) * h_dim1;
        i__7 = k + 4 + (k + 3) * h_dim1;
        d_cnjg(&z__3, &v[m * v_dim1 + 3]);
        z__2.r = refsum.r * z__3.r - refsum.i * z__3.i, z__2.i =
            refsum.r * z__3.i + refsum.i * z__3.r;
        z__1.r = h__[i__7].r - z__2.r, z__1.i = h__[i__7].i - z__2.i;
        // 将 z__1 的结果赋给 h__ 的相应位置
        h__[i__5].r = z__1.r, h__[i__5].i = z__1.i;
/* L130: */
        }
/* Computing MIN */
            i__5 = *nh, i__7 = jbot - jcol + 1;
            jlen = min(i__5,i__7);
            // 计算 jlen，即取 *nh 和 jbot - jcol + 1 之间的较小值，用于确定 zgemm 函数的参数

            zgemm_("C", "N", &nu, &jlen, &nu, &c_b57, &u[k1 + k1 *
                u_dim1], ldu, &h__[incol + k1 + jcol * h_dim1],
                ldh, &c_b56, &wh[wh_offset], ldwh);
            // 执行矩阵乘法操作，计算结果存储在 wh 数组中

            zlacpy_("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h__[
                incol + k1 + jcol * h_dim1], ldh);
            // 将 wh 数组的内容复制回 h__ 数组的指定位置
/* L150: */
        }

/*              ==== Vertical multiply ==== */

        i__4 = max(*ktop,incol) - 1;
        i__3 = *nv;
        for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
            jrow += i__3) {
/* Computing MIN */
            i__5 = *nv, i__7 = max(*ktop,incol) - jrow;
            jlen = min(i__5,i__7);
            // 计算 jlen，即取 *nv 和 max(*ktop,incol) - jrow 之间的较小值，用于确定 zgemm 函数的参数

            zgemm_("N", "N", &jlen, &nu, &nu, &c_b57, &h__[jrow + (
                incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1],
                ldu, &c_b56, &wv[wv_offset], ldwv);
            // 执行矩阵乘法操作，计算结果存储在 wv 数组中

            zlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h__[
                jrow + (incol + k1) * h_dim1], ldh);
/* L160: */
        }

/*              ==== Z multiply (also vertical) ==== */

        if (*wantz) {
            i__3 = *ihiz;
            i__4 = *nv;
            for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
                 jrow += i__4) {
/* Computing MIN */
            i__5 = *nv, i__7 = *ihiz - jrow + 1;
            jlen = min(i__5,i__7);
            // 计算 jlen，即取 *nv 和 *ihiz - jrow + 1 之间的较小值，用于确定 zgemm 函数的参数

            zgemm_("N", "N", &jlen, &nu, &nu, &c_b57, &z__[jrow +
                (incol + k1) * z_dim1], ldz, &u[k1 + k1 *
                u_dim1], ldu, &c_b56, &wv[wv_offset], ldwv);
            // 执行矩阵乘法操作，计算结果存储在 wv 数组中

            zlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z__[
                jrow + (incol + k1) * z_dim1], ldz)
                ;
/* L170: */
            }
        }
        } else {

/*
                ==== Updates exploiting U's 2-by-2 block structure.
                .    (I2, I4, J2, J4 are the last rows and columns
                .    of the blocks.) ====
*/

        i2 = (kdu + 1) / 2;
        i4 = kdu;
        j2 = i4 - i2;
        j4 = kdu;

/*
                ==== KZS and KNZ deal with the band of zeros
                .    along the diagonal of one of the triangular
                .    blocks. ====
*/

        kzs = j4 - j2 - (ns + 1);
        knz = ns + 1;
        // 计算 kzs 和 knz 的值，用于确定 zlacpy 函数的参数

/*              ==== Horizontal multiply ==== */

        i__4 = jbot;
        i__3 = *nh;
        for (jcol = min(ndcol,*kbot) + 1; i__3 < 0 ? jcol >= i__4 :
            jcol <= i__4; jcol += i__3) {
/* Computing MIN */
            i__5 = *nh, i__7 = jbot - jcol + 1;
            jlen = min(i__5,i__7);
            // 计算 jlen，即取 *nh 和 jbot - jcol + 1 之间的较小值，用于确定 zlacpy 函数的参数

/*
                   ==== Copy bottom of H to top+KZS of scratch ====
                    (The first KZS rows get multiplied by zero.) ====
*/

            zlacpy_("ALL", &knz, &jlen, &h__[incol + 1 + j2 + jcol *
                h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);
            // 将 h__ 数组的部分内容复制到 wh 数组的指定位置
/*                 ==== Multiply by U21' ==== */
在进行矩阵操作前，先使用 zlaset 函数将部分矩阵初始化为零。
然后，使用 ztrmm 函数执行左下角矩阵乘法，将 U21 的转置应用于 WH 矩阵的一部分。

/*                 ==== Multiply top of H by U11' ==== */
使用 zgemm 函数执行复杂的矩阵乘法运算，将 H 的一部分与 U11 的转置相乘，结果存储在 WH 矩阵的相应位置。

/*                 ==== Copy top of H to bottom of WH ==== */
使用 zlacpy 函数将 H 的一部分复制到 WH 矩阵的底部，以完成数据复制的任务。

/*                 ==== Multiply by U21' ==== */
再次使用 ztrmm 函数，但这次是在 WH 矩阵的另一部分上执行左下角矩阵乘法，应用 U21 的转置。

/*                 ==== Multiply by U22 ==== */
使用 zgemm 函数进行另一次复杂的矩阵乘法运算，将 U22 与 H 的一部分相乘，并将结果存储在 WH 矩阵的相应位置。

/*                 ==== Copy it back ==== */
最后一次使用 zlacpy 函数，将 WH 矩阵的数据复制回 H 矩阵的特定位置。

/* L180: */
标记一个代码行，但不提供具体的功能描述或注释。

/*              ==== Vertical multiply ==== */
进入一个循环，用于在垂直方向执行矩阵乘法的操作。

/*
                   ==== Copy right of H to scratch (the first KZS
                   .    columns get multiplied by zero) ====
*/
使用 zlacpy 函数将 H 矩阵的一部分复制到一个临时矩阵（称为 scratch），其中前 KZS 列的数据被乘以零。

/*                 ==== Multiply by U21 ==== */
使用 zlaset 函数将 scratch 矩阵的一部分初始化为零。
然后，使用 ztrmm 函数执行右上角矩阵乘法，将 U21 应用于 scratch 矩阵的一部分。

/*                 ==== Multiply by U11 ==== */
使用 zgemm 函数执行复杂的矩阵乘法运算，将 U11 与 scratch 矩阵的一部分相乘，结果存储在另一个临时矩阵中。

/*                 ==== Copy left of H to right of scratch ==== */
使用 zlacpy 函数将 H 矩阵的另一部分复制到 scratch 矩阵的右侧，以完成数据复制的任务。
/*                 ==== Multiply by U21 ==== */

            i__5 = i4 - i2;
            // 计算矩阵乘法的行数差
            ztrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b57, &u[(i2 +
                1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * wv_dim1 + 1]
                , ldwv);

/*                 ==== Multiply by U22 ==== */

            i__5 = i4 - i2;
            i__7 = j4 - j2;
            // 执行复杂矩阵乘法
            zgemm_("N", "N", &jlen, &i__5, &i__7, &c_b57, &h__[jrow +
                (incol + 1 + j2) * h_dim1], ldh, &u[j2 + 1 + (i2
                + 1) * u_dim1], ldu, &c_b57, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/*                 ==== Copy it back ==== */

            // 将矩阵数据复制回原位置
            zlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h__[
                jrow + (incol + 1) * h_dim1], ldh);
/* L190: */
        }

/*              ==== Multiply Z (also vertical) ==== */

        if (*wantz) {
            i__4 = *ihiz;
            i__3 = *nv;
            for (jrow = *iloz; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
                 jrow += i__3) {
/* Computing MIN */
            i__5 = *nv, i__7 = *ihiz - jrow + 1;
            // 计算有效长度
            jlen = min(i__5,i__7);

/*
                      ==== Copy right of Z to left of scratch (first
                      .     KZS columns get multiplied by zero) ====
*/

            // 将 Z 的右侧复制到临时存储的左侧，并在前 KZS 列乘以零
            zlacpy_("ALL", &jlen, &knz, &z__[jrow + (incol + 1 +
                j2) * z_dim1], ldz, &wv[(kzs + 1) * wv_dim1 +
                1], ldwv);

/*                    ==== Multiply by U12 ==== */

            // 执行矩阵乘法
            zlaset_("ALL", &jlen, &kzs, &c_b56, &c_b56, &wv[
                wv_offset], ldwv);
            ztrmm_("R", "U", "N", "N", &jlen, &knz, &c_b57, &u[j2
                + 1 + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1)
                * wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U11 ==== */

            // 执行复杂矩阵乘法
            zgemm_("N", "N", &jlen, &i2, &j2, &c_b57, &z__[jrow +
                (incol + 1) * z_dim1], ldz, &u[u_offset], ldu,
                 &c_b57, &wv[wv_offset], ldwv);

/*                    ==== Copy left of Z to right of scratch ==== */

            // 将 Z 的左侧复制到临时存储的右侧
            zlacpy_("ALL", &jlen, &j2, &z__[jrow + (incol + 1) *
                z_dim1], ldz, &wv[(i2 + 1) * wv_dim1 + 1],
                ldwv);

/*                    ==== Multiply by U21 ==== */

            i__5 = i4 - i2;
            // 执行矩阵乘法
            ztrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b57, &u[(
                i2 + 1) * u_dim1 + 1], ldu, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U22 ==== */

            i__5 = i4 - i2;
            i__7 = j4 - j2;
            // 执行复杂矩阵乘法
            zgemm_("N", "N", &jlen, &i__5, &i__7, &c_b57, &z__[
                jrow + (incol + 1 + j2) * z_dim1], ldz, &u[j2
                + 1 + (i2 + 1) * u_dim1], ldu, &c_b57, &wv[(
                i2 + 1) * wv_dim1 + 1], ldwv);

/*                    ==== Copy the result back to Z ==== */

            // 将结果复制回 Z
            zlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &
                z__[jrow + (incol + 1) * z_dim1], ldz);
/* L200: */
            }
        }
        }
    }
/* Subroutine */ int zlarcm_(integer *m, integer *n, doublereal *a, integer *
    lda, doublecomplex *b, integer *ldb, doublecomplex *c__, integer *ldc,
     doublereal *rwork)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
        i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006

        Purpose
        =======

        ZLARCM performs a very simple matrix-matrix multiplication:
                 C := A * B,
        where A is M by M and real; B is M by N and complex;
        C is M by N and complex.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A and of the matrix C.
                M >= 0.

        N       (input) INTEGER
                The number of columns and rows of the matrix B and
                the number of columns of the matrix C.
                N >= 0.

        A       (input) DOUBLE PRECISION array, dimension (LDA, M)
                A contains the M by M matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >=max(1,M).

        B       (input) DOUBLE PRECISION array, dimension (LDB, N)
                B contains the M by N matrix B.

        LDB     (input) INTEGER
                The leading dimension of the array B. LDB >=max(1,M).

        C       (input) COMPLEX*16 array, dimension (LDC, N)
                C contains the M by N matrix C.

        LDC     (input) INTEGER
                The leading dimension of the array C. LDC >=max(1,M).

        RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)

        =====================================================================


           Quick return if possible.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --rwork;

    /* Function Body */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    /* Store the real part of matrix B into RWORK */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * b_dim1;
            rwork[(j - 1) * *m + i__] = b[i__3].r;
            /* L10: */
        }
        /* L20: */
    }

    /* Perform matrix multiplication C := A * RWORK */
    l = *m * *n + 1;
    dgemm_("N", "N", m, n, m, &c_b1034, &a[a_offset], lda, &rwork[1], m, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
/* L210: */
        }
/*     ==== End of ZLAQR5 ==== */
/* L220: */
    }

    return 0;
} /* zlarcm_ */

/* Subroutine */ int zlarcm_(integer *m, integer *n, doublereal *a, integer *
    lda, doublecomplex *b, integer *ldb, doublecomplex *c__, integer *ldc,
     doublereal *rwork)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
        i__3, i__4, i__5;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006

        Purpose
        =======

        ZLARCM performs a very simple matrix-matrix multiplication:
                 C := A * B,
        where A is M by M and real; B is M by N and complex;
        C is M by N and complex.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A and of the matrix C.
                M >= 0.

        N       (input) INTEGER
                The number of columns and rows of the matrix B and
                the number of columns of the matrix C.
                N >= 0.

        A       (input) DOUBLE PRECISION array, dimension (LDA, M)
                A contains the M by M matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >=max(1,M).

        B       (input) DOUBLE PRECISION array, dimension (LDB, N)
                B contains the M by N matrix B.

        LDB     (input) INTEGER
                The leading dimension of the array B. LDB >=max(1,M).

        C       (input) COMPLEX*16 array, dimension (LDC, N)
                C contains the M by N matrix C.

        LDC     (input) INTEGER
                The leading dimension of the array C. LDC >=max(1,M).

        RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)

        =====================================================================


           Quick return if possible.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --rwork;

    /* Function Body */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    /* Store the real part of matrix B into RWORK */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * b_dim1;
            rwork[(j - 1) * *m + i__] = b[i__3].r;
            /* L10: */
        }
        /* L20: */
    }

    /* Perform matrix multiplication C := A * RWORK */
    l = *m * *n + 1;
    dgemm_("N", "N", m, n, m, &c_b1034, &a[a_offset], lda, &rwork[1], m, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            /* L210: */
        }
        /* ==== End of ZLAQR5 ==== */
        /* L220: */
    }

    return 0;
} /* zlarcm_ */


注释：
    # 循环迭代，从 i__ = 1 到 i__2
    for (i__ = 1; i__ <= i__2; ++i__) {
        # 计算出数组 c__ 中的索引 i__3，以及 rwork 数组中的索引 i__4
        i__3 = i__ + j * c_dim1;
        i__4 = l + (j - 1) * *m + i__ - 1;
        # 将 rwork 中的值赋给 c__ 数组中索引为 i__3 的实部，并将虚部设为 0
        c__[i__3].r = rwork[i__4], c__[i__3].i = 0.;
    }
/* L40: */
    }

    i__1 = *n;
    // 遍历矩阵C的列
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    // 遍历矩阵C的行
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 将矩阵B的虚部赋值给数组rwork
        rwork[(j - 1) * *m + i__] = d_imag(&b[i__ + j * b_dim1]);
/* L50: */
    }
/* L60: */
    }
    // 执行矩阵乘法操作，结果存储在rwork数组中
    dgemm_("N", "N", m, n, m, &c_b1034, &a[a_offset], lda, &rwork[1], m, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    // 遍历矩阵C的列
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    // 遍历矩阵C的行
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 计算c__中的复数元素的实部并与rwork数组中的元素组合赋值
        i__3 = i__ + j * c_dim1;
        i__4 = i__ + j * c_dim1;
        d__1 = c__[i__4].r;
        i__5 = l + (j - 1) * *m + i__ - 1;
        z__1.r = d__1, z__1.i = rwork[i__5];
        c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L70: */
    }
/* L80: */
    }

    return 0;

/*     End of ZLARCM */

} /* zlarcm_ */

/* Subroutine */ int zlarf_(char *side, integer *m, integer *n, doublecomplex
    *v, integer *incv, doublecomplex *tau, doublecomplex *c__, integer *
    ldc, doublecomplex *work)
{
    /* System generated locals */
    integer c_dim1, c_offset, i__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static logical applyleft;
    extern logical lsame_(char *, char *);
    static integer lastc;
    extern /* Subroutine */ int zgerc_(integer *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *);
    static integer lastv;
    extern integer ilazlc_(integer *, integer *, doublecomplex *, integer *),
        ilazlr_(integer *, integer *, doublecomplex *, integer *);



注释：
    TAU     (input) COMPLEX*16
            输入参数，复数类型，表示H的表示中的tau值。

    C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            输入/输出参数，复数类型的二维数组，维度为(M,N)。
            在输入时，存储了矩阵C的值。
            在输出时，如果SIDE = 'L'，则被矩阵H乘以C覆盖；
            如果SIDE = 'R'，则被C乘以H覆盖。

    LDC     (input) INTEGER
            输入参数，整数类型，数组C的第一个维度的长度。
            要求LDC >= max(1,M)，确保数组C的存储空间足够。

    WORK    (workspace) COMPLEX*16 array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            工作空间，复数类型的一维数组。
            如果SIDE = 'L'，长度为N；
            如果SIDE = 'R'，长度为M。
/* Parameter adjustments */
--v;  // 减小指针 v 的偏移量，使其指向正确的数组起始位置
c_dim1 = *ldc;  // 将 c_dim1 设置为参数 ldc 所指定的列数
c_offset = 1 + c_dim1;  // 计算 c__ 数组的偏移量
c__ -= c_offset;  // 调整 c__ 数组的起始地址，使其正确对齐
--work;  // 减小指针 work 的偏移量，使其指向正确的数组起始位置

/* Function Body */
applyleft = lsame_(side, "L");  // 判断 side 参数是否为 "L"，决定是否在左侧应用变换
lastv = 0;  // 初始化 lastv 为 0，表示 V 的最后一个位置
lastc = 0;  // 初始化 lastc 为 0，表示 C 的最后一个位置
if (tau->r != 0. || tau->i != 0.) {
    /*
       Set up variables for scanning V.  LASTV begins pointing to the end
       of V.
    */
    if (applyleft) {
        lastv = *m;  // 如果在左侧应用变换，初始化 lastv 为 m，表示 V 的最后一个位置
    } else {
        lastv = *n;  // 如果在右侧应用变换，初始化 lastv 为 n，表示 V 的最后一个位置
    }
    if (*incv > 0) {
        i__ = (lastv - 1) * *incv + 1;  // 计算向量 V 的起始位置
    } else {
        i__ = 1;  // 如果增量为负数，将起始位置设置为 1
    }
    /* Look for the last non-zero row in V. */
    for (;;) {  // 循环查找 V 中的最后一个非零行
        i__1 = i__;
        if (!(lastv > 0 && (v[i__1].r == 0. && v[i__1].i == 0.)))
            break;  // 找到第一个非零行后跳出循环
        --lastv;  // 更新 lastv，继续向前查找非零行
        i__ -= *incv;  // 更新 i__，继续向前查找非零行
    }
    if (applyleft) {
        /* Scan for the last non-zero column in C(1:lastv,:). */
        lastc = ilazlc_(&lastv, n, &c__[c_offset], ldc);  // 查找 C 中前 lastv 行的最后一个非零列
    } else {
        /* Scan for the last non-zero row in C(:,1:lastv). */
        lastc = ilazlr_(m, &lastv, &c__[c_offset], ldc);  // 查找 C 中前 lastv 列的最后一个非零行
    }
}
/*
   Note that lastc.eq.0 renders the BLAS operations null; no special
   case is needed at this level.
*/
if (applyleft) {
    /* Form  H * C */
    if (lastv > 0) {
        /* w(1:lastc,1) := C(1:lastv,1:lastc)' * v(1:lastv,1) */
        zgemv_("Conjugate transpose", &lastv, &lastc, &c_b57, &c__[
            c_offset], ldc, &v[1], incv, &c_b56, &work[1], &c__1);
        /* C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)' */
        z__1.r = -tau->r, z__1.i = -tau->i;
        zgerc_(&lastv, &lastc, &z__1, &v[1], incv, &work[1], &c__1, &c__[
            c_offset], ldc);
    }
} else {
    /* Form  C * H */
    if (lastv > 0) {
        /* w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1) */
        zgemv_("No transpose", &lastc, &lastv, &c_b57, &c__[c_offset],
            ldc, &v[1], incv, &c_b56, &work[1], &c__1);
        /* C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)' */
        z__1.r = -tau->r, z__1.i = -tau->i;
        zgerc_(&lastc, &lastv, &z__1, &work[1], &c__1, &v[1], incv, &c__[
            c_offset], ldc);
    }
}
return 0;

/* End of ZLARF */

} /* zlarf_ */
    # 声明一个外部子程序 zgemm_，用于矩阵乘法运算
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    # 声明一个静态整型变量 lastv
    static integer lastv;
    # 声明外部子程序 zcopy_，用于复制复数向量
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    # 声明外部子程序 ztrmm_，用于矩阵乘法运算
    extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer
        *, doublecomplex *, integer *);
    # 声明外部函数 ilazlc_，返回一个整型值，用于在复数矩阵中找到非零列的第一个索引
    extern integer ilazlc_(integer *, integer *, doublecomplex *, integer *);
    # 声明外部子程序 zlacgv_，用于共轭复数向量的操作
    extern /* Subroutine */ int zlacgv_(integer *, doublecomplex *, integer *);
    # 声明外部函数 ilazlr_，返回一个整型值，用于在复数矩阵中找到非零行的第一个索引
    extern integer ilazlr_(integer *, integer *, doublecomplex *, integer *);
    # 声明一个静态字符数组 transt，包含一个元素
    static char transt[1];
/*
    Parameter adjustments
    ---------------------

    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
*/

    /* Declare local variables */
    integer v_dim1, v_offset, t_dim1, t_offset;

    /* Set the values for v_dim1, v_offset, t_dim1, t_offset based on input parameters */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;      // Adjust pointer of V to account for offsets

    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;      // Adjust pointer of T to account for offsets
    c_dim1 = *ldc;

# 设置c_dim1为ldc的值，ldc是指向c数组的列维数的指针

    c_offset = 1 + c_dim1;

# 计算c_offset为1 + c_dim1，用于偏移计算

    c__ -= c_offset;

# 将c__减去c_offset，用于调整指向c数组的指针

    work_dim1 = *ldwork;

# 设置work_dim1为ldwork的值，ldwork是指向work数组的行维数的指针

    work_offset = 1 + work_dim1;

# 计算work_offset为1 + work_dim1，用于偏移计算

    work -= work_offset;

# 将work减去work_offset，用于调整指向work数组的指针

    /* Function Body */

# 开始函数体

    if (*m <= 0 || *n <= 0) {

# 如果m小于等于0或者n小于等于0，返回0

    return 0;

# 返回0，结束函数

    if (lsame_(trans, "N")) {

# 如果trans和"N"相同

    *(unsigned char *)transt = 'C';

# 将transt强制转换为unsigned char指针并赋值'C'

    } else {

# 否则

    *(unsigned char *)transt = 'N';

# 将transt强制转换为unsigned char指针并赋值'N'

    }

    if (lsame_(storev, "C")) {

# 如果storev和"C"相同

    if (lsame_(direct, "F")) {

# 如果direct和"F"相同
/*
   Let  V =  ( V1 )    (first K rows)
             ( V2 )
   where  V1  is unit lower triangular.
*/
if (lsame_(side, "L")) {

/*
   Form  H * C  or  H' * C  where  C = ( C1 )
                                       ( C2 )
   Computing MAX
*/
i__1 = *k, i__2 = ilazlr_(m, k, &v[v_offset], ldv);
lastv = max(i__1,i__2);
lastc = ilazlc_(&lastv, n, &c__[c_offset], ldc);

/*
   W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

   W := C1'
*/
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    zcopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1
        + 1], &c__1);
    zlacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
    /* L10: */
}

/* W := W * V1 */
ztrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
if (lastv > *k) {

   /* W := W + C2'*V2 */
   i__1 = lastv - *k;
   zgemm_("Conjugate transpose", "No transpose", &lastc, k, &
       i__1, &c_b57, &c__[*k + 1 + c_dim1], ldc, &v[*k +
       1 + v_dim1], ldv, &c_b57, &work[work_offset],
       ldwork);
}

/* W := W * T'  or  W * T */
ztrmm_("Right", "Upper", transt, "Non-unit", &lastc, k, &
    c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/* C := C - V * W' */
if (*m > *k) {

   /* C2 := C2 - V2 * W' */
   i__1 = lastv - *k;
   z__1.r = -1., z__1.i = -0.;
   zgemm_("No transpose", "Conjugate transpose", &i__1, &
       lastc, k, &z__1, &v[*k + 1 + v_dim1], ldv, &work[
       work_offset], ldwork, &c_b57, &c__[*k + 1 +
       c_dim1], ldc);
}

/* W := W * V1' */
ztrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
    lastc, k, &c_b57, &v[v_offset], ldv, &work[
    work_offset], ldwork);

/* C1 := C1 - W' */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = j + i__ * c_dim1;
        i__4 = j + i__ * c_dim1;
        d_cnjg(&z__2, &work[i__ + j * work_dim1]);
        z__1.r = c__[i__4].r - z__2.r, z__1.i = c__[i__4].i -
            z__2.i;
        c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
        /* L20: */
    }
    /* L30: */
}

} else if (lsame_(side, "R")) {

/*
   Form  C * H  or  C * H'  where  C = ( C1  C2 )
   Computing MAX
*/
i__1 = *k, i__2 = ilazlr_(n, k, &v[v_offset], ldv);
lastv = max(i__1,i__2);
lastc = ilazlr_(m, &lastv, &c__[c_offset], ldc);

/*
   W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

   W := C1
*/
/*

        i__1 = *k;
        // 循环遍历，复制 C 的列到工作区
        for (j = 1; j <= i__1; ++j) {
            // 调用 BLAS 函数 zcopy，将 C 的列复制到工作区
            zcopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
                work_dim1 + 1], &c__1);
/* L40: */
        }

/*              W := W * V1 */

        // 调用 BLAS 函数 ztrmm，计算 W = W * V1，W 是工作区的矩阵
        ztrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2 * V2 */

            // 计算 W = W + C2 * V2，其中 V2 是单位上三角矩阵的一部分
            i__1 = lastv - *k;
            zgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b57, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
                1 + v_dim1], ldv, &c_b57, &work[work_offset],
                ldwork);
        }

/*              W := W * T  or  W * T' */

        // 根据转置参数 trans 计算 W = W * T 或 W * T'
        ztrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */

        if (lastv > *k) {

/*                 C2 := C2 - W * V2' */

            // 计算 C2 = C2 - W * V2'，其中 V2 是单位上三角矩阵的一部分
            i__1 = lastv - *k;
            z__1.r = -1., z__1.i = -0.;
            zgemm_("No transpose", "Conjugate transpose", &lastc, &
                i__1, k, &z__1, &work[work_offset], ldwork, &v[*k
                + 1 + v_dim1], ldv, &c_b57, &c__[(*k + 1) *
                c_dim1 + 1], ldc);
        }

/*              W := W * V1' */

        // 计算 W = W * V1'，其中 V1 是下三角矩阵的一部分
        ztrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[v_offset], ldv, &work[
            work_offset], ldwork);

/*              C1 := C1 - W */

        // 计算 C1 = C1 - W，其中 W 是之前计算得到的矩阵
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = i__ + j * c_dim1;
            i__5 = i__ + j * work_dim1;
            // 执行 C1 = C1 - W 的数值计算
            z__1.r = c__[i__4].r - work[i__5].r, z__1.i = c__[
                i__4].i - work[i__5].i;
            c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L50: */
            }
/* L60: */
        }
        }

    } else {

/*
             Let  V =  ( V1 )
                       ( V2 )    (last K rows)
             where  V2  is unit upper triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilazlr_(m, k, &v[v_offset], ldv);
        // 计算 lastv，作为 V 的维度
        lastv = max(i__1,i__2);
        // 计算 lastc，作为 C 的维度
        lastc = ilazlc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

                W := C2'
*/

        i__1 = *k;
        // 循环遍历，复制 C2 的转置到工作区
        for (j = 1; j <= i__1; ++j) {
            // 调用 BLAS 函数 zcopy，将 C2 的转置复制到工作区
            zcopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
            // 调用 BLAS 函数 zlacgv，对复制的内容进行共轭
            zlacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
/* L70: */
        }
/*              W := W * V2 */

/* 对 W 进行右侧上三角矩阵乘法，V2 是矩阵的一部分 */

ztrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &work[
    work_offset], ldwork);
if (lastv > *k) {

/*                 W := W + C1'*V1 */

/* 如果 lastv 大于 k，则执行 W = W + C1' * V1 的复数共轭转置乘法 */

i__1 = lastv - *k;
zgemm_("Conjugate transpose", "No transpose", &lastc, k, &
    i__1, &c_b57, &c__[c_offset], ldc, &v[v_offset],
    ldv, &c_b57, &work[work_offset], ldwork);
}

/*              W := W * T'  or  W * T */

/* 对 W 进行右侧下三角矩阵乘法，T 是转置或非转置的下三角矩阵 */

ztrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
    c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V * W' */

/* 执行矩阵减法操作 C = C - V * W'，其中 W' 是 W 的复数共轭转置 */

if (lastv > *k) {

/*                 C1 := C1 - V1 * W' */

/* 如果 lastv 大于 k，则执行 C1 = C1 - V1 * W' 的复数共轭转置乘法 */

i__1 = lastv - *k;
z__1.r = -1., z__1.i = -0.;
zgemm_("No transpose", "Conjugate transpose", &i__1, &
    lastc, k, &z__1, &v[v_offset], ldv, &work[
    work_offset], ldwork, &c_b57, &c__[c_offset], ldc);
}

/*              W := W * V2' */

/* 对 W 进行右侧上三角矩阵乘法，V2' 是 V2 的复数共轭转置 */

ztrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
    lastc, k, &c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &
    work[work_offset], ldwork);

/*              C2 := C2 - W' */

/* 执行矩阵减法操作 C2 = C2 - W'，其中 W' 是 W 的复数共轭转置 */

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
    i__3 = lastv - *k + j + i__ * c_dim1;
    i__4 = lastv - *k + j + i__ * c_dim1;
    d_cnjg(&z__2, &work[i__ + j * work_dim1]);
    z__1.r = c__[i__4].r - z__2.r, z__1.i = c__[i__4].i -
        z__2.i;
    c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L80: */
    }
/* L90: */
}

} else if (lsame_(side, "R")) {

/*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

Computing MAX
*/

/* 计算 lastv 和 lastc 的值，用于后续计算 */

i__1 = *k, i__2 = ilazlr_(n, k, &v[v_offset], ldv);
lastv = max(i__1,i__2);
lastc = ilazlr_(m, &lastv, &c__[c_offset], ldc);

/*
        W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

        W := C2
*/

/* 将 C2 复制到工作数组中的相应位置 */

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    zcopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
         &work[j * work_dim1 + 1], &c__1);
/* L100: */
}

/*              W := W * V2 */

/* 对 W 进行右侧上三角矩阵乘法，V2 是矩阵的一部分 */

ztrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &work[
    work_offset], ldwork);
if (lastv > *k) {

/*                 W := W + C1 * V1 */

/* 如果 lastv 大于 k，则执行 W = W + C1 * V1 的乘法 */

i__1 = lastv - *k;
zgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
    c_b57, &c__[c_offset], ldc, &v[v_offset], ldv, &
    c_b57, &work[work_offset], ldwork);
}
/*              W := W * T  or  W * T' */

        ztrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */

        if (lastv > *k) {

/*                 C1 := C1 - W * V1' */

            i__1 = lastv - *k;
            z__1.r = -1., z__1.i = -0.;
            zgemm_("No transpose", "Conjugate transpose", &lastc, &
                i__1, k, &z__1, &work[work_offset], ldwork, &v[
                v_offset], ldv, &c_b57, &c__[c_offset], ldc);
        }

/*              W := W * V2' */

        ztrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &
            work[work_offset], ldwork);

/*              C2 := C2 - W */

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + (lastv - *k + j) * c_dim1;
            i__4 = i__ + (lastv - *k + j) * c_dim1;
            i__5 = i__ + j * work_dim1;
            z__1.r = c__[i__4].r - work[i__5].r, z__1.i = c__[
                i__4].i - work[i__5].i;
            c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L110: */
            }
/* L120: */
        }
        }
    }

    } else if (lsame_(storev, "R")) {

    if (lsame_(direct, "F")) {

/*
             Let  V =  ( V1  V2 )    (V1: first K columns)
             where  V1  is unit upper triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilazlc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilazlc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C1'
*/

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            zcopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1
                + 1], &c__1);
            zlacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
/* L130: */
        }

/*              W := W * V1' */

        ztrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[v_offset], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2'*V2' */

            i__1 = lastv - *k;
            zgemm_("Conjugate transpose", "Conjugate transpose", &
                lastc, k, &i__1, &c_b57, &c__[*k + 1 + c_dim1],
                ldc, &v[(*k + 1) * v_dim1 + 1], ldv, &c_b57, &
                work[work_offset], ldwork)
                ;
        }

/*              W := W * T'  or  W * T */

        ztrmm_("Right", "Upper", transt, "Non-unit", &lastc, k, &
            c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */

        if (lastv > *k) {
/*                 C2 := C2 - V2' * W' */

/* 
   这行代码计算 C2 = C2 - V2^H * W^H，其中：
   - C2 是一个复数矩阵
   - V2 是一个复数矩阵的部分视图
   - W 是一个复数矩阵的部分视图
   - ^H 表示共轭转置操作
*/

i__1 = lastv - *k;
/* 设置循环的上限值为 lastv - *k */

z__1.r = -1., z__1.i = -0.;
/* 初始化复数变量 z__1 为 -1 */

zgemm_("Conjugate transpose", "Conjugate transpose", &
    i__1, &lastc, k, &z__1, &v[(*k + 1) * v_dim1 + 1],
     ldv, &work[work_offset], ldwork, &c_b57, &c__[*k
    + 1 + c_dim1], ldc);
/*
   这行代码使用 BLAS 库中的 zgemm 函数，计算 Conjugate transpose(V2) * Conjugate transpose(W)，结果存储在 C2 矩阵中。
   参数说明：
   - "Conjugate transpose": 表示 V2 和 W 都是共轭转置的
   - i__1: V2^H 和 W^H 的行数
   - lastc: 结果矩阵 C2 的列数
   - k: V2^H 和 W^H 的列数
   - &z__1: 乘法的标量系数
   - &v[(*k + 1) * v_dim1 + 1]: V2 的数据数组起始地址
   - ldv: V2 数组的列数维度
   - &work[work_offset]: W 的数据数组起始地址
   - ldwork: W 数组的列数维度
   - &c_b57: 一个常数值，在这里表示乘法的第二个标量系数
   - &c__[*k + 1 + c_dim1]: 结果矩阵 C2 的起始地址
   - ldc: 结果矩阵 C2 的列数维度
*/

/*              W := W * V1 */

/* 
   计算 W = W * V1，其中：
   - W 是一个复数矩阵
   - V1 是一个复数矩阵
*/

ztrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
/*
   这行代码使用 BLAS 库中的 ztrmm 函数，计算 W = W * V1。
   参数说明：
   - "Right": 指定 W 在右侧
   - "Upper": 指定 V1 是上三角矩阵
   - "No transpose": 指定 V1 不进行转置操作
   - "Unit": 指定 V1 的对角线元素为单位元素
   - lastc: W 和 V1 的行数
   - k: W 的列数，V1 的行数
   - &c_b57: 一个常数值，在这里表示乘法的标量系数
   - &v[v_offset]: V1 的数据数组起始地址
   - ldv: V1 数组的列数维度
   - &work[work_offset]: W 的数据数组起始地址
   - ldwork: W 数组的列数维度
*/

/*              C1 := C1 - W' */

/*
   计算 C1 = C1 - W^H，其中：
   - C1 和 W 是复数矩阵
*/

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
    i__3 = j + i__ * c_dim1;
    i__4 = j + i__ * c_dim1;
    d_cnjg(&z__2, &work[i__ + j * work_dim1]);
    z__1.r = c__[i__4].r - z__2.r, z__1.i = c__[i__4].i -
        z__2.i;
    c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
    }
}
/*
   这段代码对 C1 进行更新，计算 C1 = C1 - W^H。
   参数说明：
   - *k: 内层循环的上限值
   - lastc: 外层循环的上限值
   - j, i__: 循环索引变量
   - c_dim1: C1 的列数维度
   - work_dim1: W 的列数维度
   - &c__: C1 的数据数组起始地址
   - &work: W 的数据数组起始地址
*/

} else if (lsame_(side, "R")) {

/*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
i__1 = *k, i__2 = ilazlc_(k, n, &v[v_offset], ldv);
lastv = max(i__1,i__2);
lastc = ilazlr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

                W := C1
*/

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    zcopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
        work_dim1 + 1], &c__1);
}

/*              W := W * V1' */

ztrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
    lastc, k, &c_b57, &v[v_offset], ldv, &work[
    work_offset], ldwork);
if (lastv > *k) {

/*                 W := W + C2 * V2' */

i__1 = lastv - *k;
zgemm_("No transpose", "Conjugate transpose", &lastc, k, &
    i__1, &c_b57, &c__[(*k + 1) * c_dim1 + 1], ldc, &
    v[(*k + 1) * v_dim1 + 1], ldv, &c_b57, &work[
    work_offset], ldwork);
}

/*              W := W * T  or  W * T' */

ztrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b57,
     &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

if (lastv > *k) {

/*                 C2 := C2 - W * V2 */

i__1 = lastv - *k;
z__1.r = -1., z__1.i = -0.;
zgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
    z__1, &work[work_offset], ldwork, &v[(*k + 1) *
    v_dim1 + 1], ldv, &c_b57, &c__[(*k + 1) * c_dim1
    + 1], ldc);
}

/*              W := W * V1 */

ztrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
/*              C1 := C1 - W */

/* 循环遍历每个列向量 */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            /* 循环遍历每个行向量 */
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* 计算 C1(i, j) - W(i, j) 并存储在 C1 中 */
                i__3 = i__ + j * c_dim1;
                i__4 = i__ + j * c_dim1;
                i__5 = i__ + j * work_dim1;
                z__1.r = c__[i__4].r - work[i__5].r, z__1.i = c__[
                    i__4].i - work[i__5].i;
                c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
/* L170: */
            }
/* L180: */
        }

        }

    } else {

/*
             Let  V =  ( V1  V2 )    (V2: last K columns)
             where  V2  is unit lower triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        /* 计算 lastv 和 lastc 的值 */
        i__1 = *k, i__2 = ilazlc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilazlc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C2'
*/

        /* 计算 W = C2' */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            zcopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
            zlacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
/* L190: */
        }

/*              W := W * V2' */

        /* 计算 W = W * V2' */
        ztrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[(lastv - *k + 1) * v_dim1 + 1],
            ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1'*V1' */

            /* 计算 W = W + C1'*V1' */
            i__1 = lastv - *k;
            zgemm_("Conjugate transpose", "Conjugate transpose", &
                lastc, k, &i__1, &c_b57, &c__[c_offset], ldc, &v[
                v_offset], ldv, &c_b57, &work[work_offset],
                ldwork);
        }

/*              W := W * T'  or  W * T */

        /* 计算 W = W * T' 或 W * T */
        ztrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
            c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */

        if (lastv > *k) {

/*                 C1 := C1 - V1' * W' */

            /* 计算 C1 = C1 - V1' * W' */
            i__1 = lastv - *k;
            z__1.r = -1., z__1.i = -0.;
            zgemm_("Conjugate transpose", "Conjugate transpose", &
                i__1, &lastc, k, &z__1, &v[v_offset], ldv, &work[
                work_offset], ldwork, &c_b57, &c__[c_offset], ldc);
        }

/*              W := W * V2 */

        /* 计算 W = W * V2 */
        ztrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);
/*              C2 := C2 - W' */

/* 循环遍历每列的每个元素 */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    /* 循环遍历每行 */
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 计算工作数组中的索引 */
        i__3 = lastv - *k + j + i__ * c_dim1;
        i__4 = lastv - *k + j + i__ * c_dim1;
        /* 计算更新后的C矩阵元素 */
        d_cnjg(&z__2, &work[i__ + j * work_dim1]);
        z__1.r = c__[i__4].r - z__2.r, z__1.i = c__[i__4].i - z__2.i;
        c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
        /* L200: */
    }
    /* L210: */
}

} else if (lsame_(side, "R")) {

/*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

        计算lastv和lastc的值
*/
i__1 = *k, i__2 = ilazlc_(k, n, &v[v_offset], ldv);
lastv = max(i__1, i__2);
lastc = ilazlr_(m, &lastv, &c__[c_offset], ldc);

/*
        W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

        初始化W为C2
*/

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    zcopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
           &work[j * work_dim1 + 1], &c__1);
    /* L220: */
}

/*              W := W * V2' */

ztrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
      lastc, k, &c_b57, &v[(lastv - *k + 1) * v_dim1 + 1],
      ldv, &work[work_offset], ldwork);
if (lastv > *k) {

/*                 W := W + C1 * V1' */

    i__1 = lastv - *k;
    zgemm_("No transpose", "Conjugate transpose", &lastc, k, &
           i__1, &c_b57, &c__[c_offset], ldc, &v[v_offset],
           ldv, &c_b57, &work[work_offset], ldwork);
}

/*              W := W * T  or  W * T' */

ztrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b57,
       &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

if (lastv > *k) {

/*                 C1 := C1 - W * V1 */

    i__1 = lastv - *k;
    z__1.r = -1., z__1.i = -0.;
    zgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
           z__1, &work[work_offset], ldwork, &v[v_offset],
           ldv, &c_b57, &c__[c_offset], ldc);
}

/*              W := W * V2 */

ztrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
       c_b57, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
       work_offset], ldwork);

/*              C1 := C1 - W */

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + (lastv - *k + j) * c_dim1;
        i__4 = i__ + (lastv - *k + j) * c_dim1;
        i__5 = i__ + j * work_dim1;
        z__1.r = c__[i__4].r - work[i__5].r, z__1.i = c__[
            i__4].i - work[i__5].i;
        c__[i__3].r = z__1.r, c__[i__3].i = z__1.i;
        /* L230: */
    }
    /* L240: */
}

}

}

return 0;

/*     End of ZLARFB */

} /* zlarfb_ */
/* Subroutine */ int zlarfg_(integer *n, doublecomplex *alpha, doublecomplex *
    x, integer *incx, doublecomplex *tau)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;
    doublecomplex z__1, z__2;

    /* Local variables */
    static integer j, knt;
    static doublereal beta, alphi, alphr;
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *);
    static doublereal xnorm;
    extern doublereal dlapy3_(doublereal *, doublereal *, doublereal *),
        dznrm2_(integer *, doublecomplex *, integer *), dlamch_(char *);
    static doublereal safmin;
    extern /* Subroutine */ int zdscal_(integer *, doublereal *,
        doublecomplex *, integer *);
    static doublereal rsafmn;
    extern /* Double Complex */ VOID zladiv_(doublecomplex *, doublecomplex *,
         doublecomplex *);

    /*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    ZLARFG generates a complex elementary reflector H of order n, such
    that

          H' * ( alpha ) = ( beta ),   H' * H = I.
               (   x   )   (   0  )

    where alpha and beta are scalars, with beta real, and x is an
    (n-1)-element complex vector. H is represented in the form

          H = I - tau * ( 1 ) * ( 1 v' ) ,
                        ( v )

    where tau is a complex scalar and v is a complex (n-1)-element
    vector. Note that H is not hermitian.

    If the elements of x are all zero and alpha is real, then tau = 0
    and H is taken to be the unit matrix.

    Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .

    Arguments
    =========

    N       (input) INTEGER
            The order of the elementary reflector.

    ALPHA   (input/output) COMPLEX*16
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.

    X       (input/output) COMPLEX*16 array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.

    INCX    (input) INTEGER
            The increment between elements of X. INCX > 0.

    TAU     (output) COMPLEX*16
            The value tau.

    =====================================================================
    */

    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 0) {
        tau->r = 0., tau->i = 0.;
        return 0;
    }

    i__1 = *n - 1;
    xnorm = dznrm2_(&i__1, &x[1], incx);
    alphr = alpha->r;
    alphi = d_imag(alpha);

    if (xnorm == 0. && alphi == 0.) {

        /*        H  =  I */

        tau->r = 0., tau->i = 0.;
    } else {

        /*        general case */

        d__1 = dlapy3_(&alphr, &alphi, &xnorm);
        beta = -d_sign(&d__1, &alphr);
        safmin = SAFEMINIMUM / EPSILON;
        rsafmn = 1. / safmin;

        knt = 0;
    # 如果 beta 的绝对值小于 safmin
/*           XNORM, BETA may be inaccurate; scale X and recompute them */

L10:
        ++knt;
        // 增加计数器 knt
        i__1 = *n - 1;
        // 计算下标范围
        zdscal_(&i__1, &rsafmn, &x[1], incx);
        // 对数组 X 进行按比例缩放
        beta *= rsafmn;
        // 更新 beta 的值
        alphi *= rsafmn;
        // 更新 alphi 的值
        alphr *= rsafmn;
        // 更新 alphr 的值
        if (abs(beta) < safmin) {
        goto L10;
        // 如果 beta 的绝对值小于 safmin，则回到标签 L10 处
        }

/*           New BETA is at most 1, at least SAFMIN */

        i__1 = *n - 1;
        // 计算下标范围
        xnorm = dznrm2_(&i__1, &x[1], incx);
        // 计算向量 X 的范数
        z__1.r = alphr, z__1.i = alphi;
        // 构造复数 z__1，赋值给 alpha
        alpha->r = z__1.r, alpha->i = z__1.i;
        // 更新 alpha 的值
        d__1 = dlapy3_(&alphr, &alphi, &xnorm);
        // 计算 dlapy3 函数的结果
        beta = -d_sign(&d__1, &alphr);
        // 更新 beta 的值为负 dlapy3 函数结果的符号乘以 dlapy3 的值
    }
    d__1 = (beta - alphr) / beta;
    d__2 = -alphi / beta;
    // 计算复数 z__1 的实部和虚部
    z__1.r = d__1, z__1.i = d__2;
    // 赋值给 tau
    tau->r = z__1.r, tau->i = z__1.i;
    // 更新 alpha 的值
    z__2.r = alpha->r - beta, z__2.i = alpha->i;
    // 计算复数 z__2
    zladiv_(&z__1, &c_b57, &z__2);
    // 计算 zladiv 函数的结果
    alpha->r = z__1.r, alpha->i = z__1.i;
    // 更新 alpha 的值
    i__1 = *n - 1;
    // 计算下标范围
    zscal_(&i__1, alpha, &x[1], incx);

/*        If ALPHA is subnormal, it may lose relative accuracy */

    i__1 = knt;
    // 计算循环次数
    for (j = 1; j <= i__1; ++j) {
        beta *= safmin;
        // 更新 beta 的值
/* L20: */
    }
    alpha->r = beta, alpha->i = 0.;
    // 更新 alpha 的值

    return 0;

/*     End of ZLARFG */

} /* zlarfg_ */

/* Subroutine */ int zlarft_(char *direct, char *storev, integer *n, integer *
    k, doublecomplex *v, integer *ldv, doublecomplex *tau, doublecomplex *
    t, integer *ldt)
{
    /* System generated locals */
    integer t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3, i__4;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, prevlastv;
    static doublecomplex vii;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *);
    static integer lastv;
    extern /* Subroutine */ int ztrmv_(char *, char *, char *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *), zlacgv_(integer *, doublecomplex *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    ZLARFT forms the triangular factor T of a complex block reflector H
    of order n, which is defined as a product of k elementary reflectors.

    If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

    If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

    If STOREV = 'C', the vector which defines the elementary reflector
    H(i) is stored in the i-th column of the array V, and

       H  =  I - V * T * V'

    If STOREV = 'R', the vector which defines the elementary reflector
    H(i) is stored in the i-th row of the array V, and

       H  =  I - V' * T * V

    Arguments
    =========
    ! 指定用于形成块反射器的基本反射器的顺序：
    ! 'F': H = H(1) H(2) . . . H(k)（向前）
    ! 'B': H = H(k) . . . H(2) H(1)（向后）
    DIRECT  (input) CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)

    ! 指定存储定义基本反射器的向量的方式：
    ! 'C': 列主序存储
    ! 'R': 行主序存储
    STOREV  (input) CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise

    ! 反射器 H 的阶数 N，N >= 0
    N       (input) INTEGER
            The order of the block reflector H. N >= 0.

    ! 三角因子 T 的阶数 K，即基本反射器的数量，K >= 1
    K       (input) INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.

    ! 矩阵 V，根据存储方式 STOREV 的不同，维度为：
    ! (LDV,K) 若 STOREV = 'C'
    ! (LDV,N) 若 STOREV = 'R'
    ! 参见 Further Details
    V       (input/output) COMPLEX*16 array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.

    ! 数组 V 的主维度 LDV
    ! 若 STOREV = 'C'，LDV >= max(1,N)
    ! 若 STOREV = 'R'，LDV >= K
    LDV     (input) INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.

    ! 元素反射器 H(i) 的标量因子，维度为 (K)
    TAU     (input) COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).

    ! 块反射器的 k × k 三角形因子 T
    ! 若 DIRECT = 'F'，T 是上三角形
    ! 若 DIRECT = 'B'，T 是下三角形
    ! 其余部分的数组不使用
    T       (output) COMPLEX*16 array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.

    ! 数组 T 的主维度 LDT，LDT >= K
    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= K.

    ! 进一步细节
    ! 矩阵 V 的形状和定义 H(i) 向量的存储方式的最佳示例见下面的例子，其中 n = 5，k = 3
    ! 值为 1 的元素未存储，但相应的数组元素在退出时被修改并恢复
    ! 其余数组部分不使用
    ! DIRECT = 'F' 且 STOREV = 'C':
    !                 DIRECT = 'F' 且 STOREV = 'R':
    ! DIRECT = 'B' 且 STOREV = 'C':
    !                 DIRECT = 'B' 且 STOREV = 'R':
    ! =====================================================================
    Further Details
    ===============

    The shape of the matrix V and the storage of the vectors which define
    the H(i) is best illustrated by the following example with n = 5 and
    k = 3. The elements equal to 1 are not stored; the corresponding
    array elements are modified but restored on exit. The rest of the
    array is not used.

    ! 如果可能，快速返回
    Quick return if possible
    /* 参数调整 */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --tau;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;

    /* 函数主体 */
    if (*n == 0) {
        return 0;
    }

    if (lsame_(direct, "F")) {
        prevlastv = *n;
        i__1 = *k;
        for (i__ = 1; i__ <= i__1; ++i__) {
            prevlastv = max(prevlastv,i__);
            i__2 = i__;
            if (tau[i__2].r == 0. && tau[i__2].i == 0.) {

                /* 对角元素为零，即 H(i) = I 的情况 */

                i__2 = i__;
                for (j = 1; j <= i__2; ++j) {
                    i__3 = j + i__ * t_dim1;
                    t[i__3].r = 0., t[i__3].i = 0.;
                }
            } else {

                /* 一般情况 */

                i__2 = i__ + i__ * v_dim1;
                vii.r = v[i__2].r, vii.i = v[i__2].i;
                i__2 = i__ + i__ * v_dim1;
                v[i__2].r = 1., v[i__2].i = 0.;
                if (lsame_(storev, "C")) {

                    /* 列主存储时，跳过任何尾随的零元素 */

                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        i__3 = lastv + i__ * v_dim1;
                        if (v[i__3].r != 0. || v[i__3].i != 0.) {
                            goto L15;
                        }
                    }
L15:
                    j = min(lastv,prevlastv);

                    /* 计算 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)' * V(i:j,i) */

                    i__2 = j - i__ + 1;
                    i__3 = i__ - 1;
                    i__4 = i__;
                    z__1.r = -tau[i__4].r, z__1.i = -tau[i__4].i;
                    zgemv_("Conjugate transpose", &i__2, &i__3, &z__1, &v[i__ + v_dim1], ldv, &v[i__ + i__ * v_dim1], &c__1, &c_b56, &t[i__ * t_dim1 + 1], &c__1);
                } else {

                    /* 行主存储时，跳过任何尾随的零元素 */

                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        i__3 = i__ + lastv * v_dim1;
                        if (v[i__3].r != 0. || v[i__3].i != 0.) {
                            goto L16;
                        }
                    }
L16:
                    j = min(lastv,prevlastv);

                    /* 计算 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)' */

                    if (i__ < j) {
                        i__2 = j - i__;
                        zlacgv_(&i__2, &v[i__ + (i__ + 1) * v_dim1], ldv);
                    }
                    i__2 = i__ - 1;
                    i__3 = j - i__ + 1;
                    i__4 = i__;
                    z__1.r = -tau[i__4].r, z__1.i = -tau[i__4].i;
                    zgemv_("No transpose", &i__2, &i__3, &z__1, &v[i__ * v_dim1 + 1], ldv, &v[i__ + i__ * v_dim1], ldv, &c_b56, &t[i__ * t_dim1 + 1], &c__1);
                    if (i__ < j) {
                        i__2 = j - i__;
                        zlacgv_(&i__2, &v[i__ + (i__ + 1) * v_dim1], ldv);
                    }
                }
                i__2 = i__ + i__ * v_dim1;
                v[i__2].r = vii.r, v[i__2].i = vii.i;
            }
        }
    }
/*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) */
        i__2 = i__ - 1;
        ztrmv_("Upper", "No transpose", "Non-unit", &i__2, &t[
            t_offset], ldt, &t[i__ * t_dim1 + 1], &c__1);
        i__2 = i__ + i__ * t_dim1;
        i__3 = i__;
        t[i__2].r = tau[i__3].r, t[i__2].i = tau[i__3].i;
        if (i__ > 1) {
            prevlastv = max(prevlastv,lastv);
        } else {
            prevlastv = lastv;
        }
/* L20: */
    }
    } else {
    prevlastv = 1;
    for (i__ = *k; i__ >= 1; --i__) {
        i__1 = i__;
        if (tau[i__1].r == 0. && tau[i__1].i == 0.) {

/*              H(i)  =  I */

        i__1 = *k;
        for (j = i__; j <= i__1; ++j) {
            i__2 = j + i__ * t_dim1;
            t[i__2].r = 0., t[i__2].i = 0.;
/* L30: */
        }
        } else {

/*              general case */

        if (i__ < *k) {
            if (lsame_(storev, "C")) {
            i__1 = *n - *k + i__ + i__ * v_dim1;
            vii.r = v[i__1].r, vii.i = v[i__1].i;
            i__1 = *n - *k + i__ + i__ * v_dim1;
            v[i__1].r = 1., v[i__1].i = 0.;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                i__2 = lastv + i__ * v_dim1;
                if (v[i__2].r != 0. || v[i__2].i != 0.) {
                goto L35;
                }
            }
L35:
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(j:n-k+i,i+1:k)' * V(j:n-k+i,i)
*/

            i__1 = *n - *k + i__ - j + 1;
            i__2 = *k - i__;
            i__3 = i__;
            z__1.r = -tau[i__3].r, z__1.i = -tau[i__3].i;
            zgemv_("Conjugate transpose", &i__1, &i__2, &z__1, &v[
                j + (i__ + 1) * v_dim1], ldv, &v[j + i__ *
                v_dim1], &c__1, &c_b56, &t[i__ + 1 + i__ *
                t_dim1], &c__1);
            i__1 = *n - *k + i__ + i__ * v_dim1;
            v[i__1].r = vii.r, v[i__1].i = vii.i;
            } else {
            i__1 = i__ + (*n - *k + i__) * v_dim1;
            vii.r = v[i__1].r, vii.i = v[i__1].i;
            i__1 = i__ + (*n - *k + i__) * v_dim1;
            v[i__1].r = 1., v[i__1].i = 0.;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                i__2 = i__ + lastv * v_dim1;
                if (v[i__2].r != 0. || v[i__2].i != 0.) {
                goto L36;
                }
            }
L36:
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)'
*/
/* 以下是需要注释的代码 */

            i__1 = *n - *k + i__ - 1 - j + 1;
            zlacgv_(&i__1, &v[i__ + j * v_dim1], ldv);
            // 对向量 v[i__ + j * v_dim1] 进行共轭变换

            i__1 = *k - i__;
            i__2 = *n - *k + i__ - j + 1;
            i__3 = i__;
            z__1.r = -tau[i__3].r, z__1.i = -tau[i__3].i;
            // 计算 -tau[i__3] 的复共轭，存储在 z__1 中

            zgemv_("No transpose", &i__1, &i__2, &z__1, &v[i__ +
                1 + j * v_dim1], ldv, &v[i__ + j * v_dim1],
                ldv, &c_b56, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            // 执行矩阵向量乘法操作，计算 T(i+1:k,i) = T(i+1:k,i+1:k) * T(i+1:k,i)

            i__1 = *n - *k + i__ - 1 - j + 1;
            zlacgv_(&i__1, &v[i__ + j * v_dim1], ldv);
            // 再次对向量 v[i__ + j * v_dim1] 进行共轭变换

            i__1 = i__ + (*n - *k + i__) * v_dim1;
            v[i__1].r = vii.r, v[i__1].i = vii.i;
            // 将复数 vii 存储在 v[i__ + (*n - *k + i__) * v_dim1] 处

/*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) */

            i__1 = *k - i__;
            ztrmv_("Lower", "No transpose", "Non-unit", &i__1, &t[i__
                + 1 + (i__ + 1) * t_dim1], ldt, &t[i__ + 1 + i__ *
                 t_dim1], &c__1)
                ;
            // 执行矩阵向量乘法操作，计算 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)

            if (i__ > 1) {
            prevlastv = min(prevlastv,lastv);
            // 如果 i__ > 1，则将 prevlastv 设置为 prevlastv 和 lastv 中的最小值
            } else {
            prevlastv = lastv;
            // 否则，将 prevlastv 设置为 lastv
            }

/* L40: */
        }
        i__1 = i__ + i__ * t_dim1;
        i__2 = i__;
        t[i__1].r = tau[i__2].r, t[i__1].i = tau[i__2].i;
        // 将 tau[i__2] 存储在 t[i__ + i__ * t_dim1] 处

/* L40: */
    }
    }
    return 0;

/*     End of ZLARFT */

} /* zlarft_ */

/* Subroutine */ int zlartg_(doublecomplex *f, doublecomplex *g, doublereal *
    cs, doublecomplex *sn, doublecomplex *r__)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8, d__9, d__10;
    doublecomplex z__1, z__2, z__3;

    /* Local variables */
    static doublereal d__;
    static integer i__;
    static doublereal f2, g2;
    static doublecomplex ff;
    static doublereal di, dr;
    static doublecomplex fs, gs;
    static doublereal f2s, g2s, eps, scale;
    static integer count;
    static doublereal safmn2;
    extern doublereal dlapy2_(doublereal *, doublereal *);
    static doublereal safmx2;

    static doublereal safmin;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLARTG generates a plane rotation so that

       [  CS  SN  ]     [ F ]     [ R ]
       [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
       [ -SN  CS  ]     [ G ]     [ 0 ]

    This is a faster version of the BLAS1 routine ZROTG, except for
    the following differences:
       F and G are unchanged on return.
       If G=0, then CS=1 and SN=0.
       If F=0, then CS=0 and SN is chosen so that R is real.

    Arguments
    =========

    F       (input) COMPLEX*16
            The first component of vector to be rotated.

    G       (input) COMPLEX*16
            The second component of vector to be rotated.
    # 输出变量 CS，保存了旋转角度的余弦值，为双精度浮点数
    CS      (output) DOUBLE PRECISION
            The cosine of the rotation.

    # 输出变量 SN，保存了旋转角度的正弦值，为复数*16
    SN      (output) COMPLEX*16
            The sine of the rotation.

    # 输出变量 R，保存了旋转后向量的非零分量，为复数*16
    R       (output) COMPLEX*16
            The nonzero component of the rotated vector.

    # 进一步细节说明
    Further Details
    ======= =======

    # 1996年3月5日 - 被 W. Kahan 和 J. Demmel 修改，使用新算法
    3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel

    # 此版本有几个语句被注释以确保线程安全
    # （机器参数在每次进入时计算）。2003年2月10日，SJH。
    This version has a few statements commented out for thread safety
    (machine parameters are computed on each entry). 10 feb 03, SJH.

    # =====================================================================
    =====================================================================

       # 逻辑变量 FIRST，用于标记是否第一次进入该代码段
       LOGICAL            FIRST
       # SAVE 用于声明变量在函数调用之间保持其值不变
       SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
       # DATA 用于初始化变量 FIRST 为 .TRUE.
       DATA               FIRST / .TRUE. /

       # 如果第一次进入，则执行以下代码块
       IF( FIRST ) THEN
/*
    safmin = SAFEMINIMUM;
    eps = EPSILON;
    d__1 = BASE;
    i__1 = (integer) (log(safmin / eps) / log(BASE) / 2.);
    safmn2 = pow_di(&d__1, &i__1);
    safmx2 = 1. / safmn2;
*/
    // 设置 safmin 为 SAFEMINIMUM，eps 为 EPSILON
    safmin = SAFEMINIMUM;
    eps = EPSILON;
    // 计算 BASE 的对数，用于后续的计算
    d__1 = BASE;
    i__1 = (integer) (log(safmin / eps) / log(BASE) / 2.);
    // 计算 SAFMN2 为 BASE 的 log(safmin / eps) / 2 次方
    safmn2 = pow_di(&d__1, &i__1);
    // SAFMX2 为 SAFMN2 的倒数
    safmx2 = 1. / safmn2;

/*
          FIRST = .FALSE.
       END IF
   Computing MAX
   Computing MAX
*/
    // 将 f 和 g 的实部和虚部的绝对值计算并取最大值
    d__7 = (d__1 = f->r, abs(d__1)), d__8 = (d__2 = d_imag(f), abs(d__2));
    /* Computing MAX */
    d__9 = (d__3 = g->r, abs(d__3)), d__10 = (d__4 = d_imag(g), abs(d__4));
    d__5 = max(d__7,d__8), d__6 = max(d__9,d__10);
    scale = max(d__5,d__6);
    // 复制 f 和 g 到 fs 和 gs
    fs.r = f->r, fs.i = f->i;
    gs.r = g->r, gs.i = g->i;
    count = 0;
    // 如果 scale 大于等于 safmx2，则执行以下循环
    if (scale >= safmx2) {
L10:
        // 计数加一
        ++count;
        // 对 fs 和 gs 各乘以 safmn2
        z__1.r = safmn2 * fs.r, z__1.i = safmn2 * fs.i;
        fs.r = z__1.r, fs.i = z__1.i;
        z__1.r = safmn2 * gs.r, z__1.i = safmn2 * gs.i;
        gs.r = z__1.r, gs.i = z__1.i;
        // scale 乘以 safmn2
        scale *= safmn2;
        // 如果 scale 仍然大于等于 safmx2，则继续循环
        if (scale >= safmx2) {
            goto L10;
        }
    } else if (scale <= safmn2) {
        // 如果 scale 小于等于 safmn2，则执行以下循环
        if (g->r == 0. && g->i == 0.) {
            // 如果 g 是零向量，则设置 cs 为 1，sn 为零向量，r__ 为 f
            *cs = 1.;
            sn->r = 0., sn->i = 0.;
            r__->r = f->r, r__->i = f->i;
            return 0;
        }
L20:
        // 计数减一
        --count;
        // 对 fs 和 gs 各乘以 safmx2
        z__1.r = safmx2 * fs.r, z__1.i = safmx2 * fs.i;
        fs.r = z__1.r, fs.i = z__1.i;
        z__1.r = safmx2 * gs.r, z__1.i = safmx2 * gs.i;
        gs.r = z__1.r, gs.i = z__1.i;
        // scale 乘以 safmx2
        scale *= safmx2;
        // 如果 scale 仍然小于等于 safmn2，则继续循环
        if (scale <= safmn2) {
            goto L20;
        }
    }

/*
   Computing 2nd power
*/
    // 计算 fs 的模的平方
    d__1 = fs.r;
    /* Computing 2nd power */
    d__2 = d_imag(&fs);
    f2 = d__1 * d__1 + d__2 * d__2;
    /* Computing 2nd power */
    // 计算 gs 的模的平方
    d__1 = gs.r;
    /* Computing 2nd power */
    d__2 = d_imag(&gs);
    g2 = d__1 * d__1 + d__2 * d__2;

    // 如果 f2 小于等于 max(g2,1.) * safmin，则执行以下操作
    if (f2 <= max(g2,1.) * safmin) {

        // 这是一个罕见的情况：F 很小
        if (f->r == 0. && f->i == 0.) {
            // 如果 f 是零向量，则设置 cs 为 0，计算 g 的模，设置 r__ 为 g 的模，sn 为 g 的单位向量
            *cs = 0.;
            d__2 = g->r;
            d__3 = d_imag(g);
            d__1 = dlapy2_(&d__2, &d__3);
            r__->r = d__1, r__->i = 0.;
            // 显式地使用两次实数除法进行复数除法
            d__1 = gs.r;
            d__2 = d_imag(&gs);
            d__ = dlapy2_(&d__1, &d__2);
            d__1 = gs.r / d__;
            d__2 = -d_imag(&gs) / d__;
            z__1.r = d__1, z__1.i = d__2;
            sn->r = z__1.r, sn->i = z__1.i;
            return 0;
        }

        // 计算 fs 的模
        d__1 = fs.r;
        d__2 = d_imag(&fs);
        f2s = dlapy2_(&d__1, &d__2);

/*
          G2 and G2S are accurate
          G2 is at least SAFMIN, and G2S is at least SAFMN2
*/
        // 计算 gs 的模
        g2s = sqrt(g2);

/*
          Error in CS from underflow in F2S is at most
          UNFL / SAFMN2 .lt. sqrt(UNFL*EPS) .lt. EPS
          If MAX(G2,ONE)=G2, then F2 .lt. G2*SAFMIN,
          and so CS .lt. sqrt(SAFMIN)
          If MAX(G2,ONE)=ONE, then F2 .lt. SAFMIN
          and so CS .lt. sqrt(SAFMIN)/SAFMN2 = sqrt(EPS)
          Therefore, CS = F2S/G2S / sqrt( 1 + (F2S/G2S)**2 ) = F2S/G2S
*/
        // 设置 cs 为 f2s/g2s
        *cs = f2s / g2s;

/*
          Make sure abs(FF) = 1
          Do complex/real division explicitly with 2 real divisions
   Computing MAX
*/
        // 计算 f 的实部和虚部的绝对值并取最大值
        d__3 = (d__1 = f->r, abs(d__1)), d__4 = (d__2 = d_imag(f), abs(d__2));
    // 如果 d__3 和 d__4 的最大值大于 1
    if (max(d__3,d__4) > 1.) {
        // 取复数 f 的实部和虚部
        d__1 = f->r;
        d__2 = d_imag(f);
        // 计算 f 的模长 d__
        d__ = dlapy2_(&d__1, &d__2);
        // 计算复数 f 的单位化
        d__1 = f->r / d__;
        d__2 = d_imag(f) / d__;
        z__1.r = d__1, z__1.i = d__2;
        // 将单位化后的结果赋给 ff
        ff.r = z__1.r, ff.i = z__1.i;
    } else {
        // 否则计算 dr 和 di
        dr = safmx2 * f->r;
        di = safmx2 * d_imag(f);
        // 计算 dr 和 di 的模长 d__
        d__ = dlapy2_(&dr, &di);
        // 计算复数 dr + di 的单位化
        d__1 = dr / d__;
        d__2 = di / d__;
        z__1.r = d__1, z__1.i = d__2;
        // 将单位化后的结果赋给 ff
        ff.r = z__1.r, ff.i = z__1.i;
    }
    // 计算 gs / g2s 的实部和虚部比例
    d__1 = gs.r / g2s;
    d__2 = -d_imag(&gs) / g2s;
    z__2.r = d__1, z__2.i = d__2;
    // 计算复数 ff 与 gs / g2s 的乘积
    z__1.r = ff.r * z__2.r - ff.i * z__2.i, z__1.i = ff.r * z__2.i + ff.i
        * z__2.r;
    // 将结果赋给 sn
    sn->r = z__1.r, sn->i = z__1.i;
    // 计算 cs 与 f 的乘积
    z__2.r = *cs * f->r, z__2.i = *cs * f->i;
    // 计算 sn 与 g 的乘积
    z__3.r = sn->r * g->r - sn->i * g->i, z__3.i = sn->r * g->i + sn->i *
        g->r;
    // 计算 z__2 + z__3 的结果，并将结果赋给 r__
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    r__->r = z__1.r, r__->i = z__1.i;
    // 结束 if 语句的条件分支
    } else {
/*
    This subroutine, ZLASCL, is part of the LAPACK library (version 3.2),
    which is a software package provided by various academic institutions
    and organizations. It is designed for performing operations on complex
    matrices while ensuring no over/underflow issues.

    Purpose
    =======
    ZLASCL multiplies the M by N complex matrix A by the real scalar
    CTO/CFROM. This operation avoids over/underflow as long as the final
    result CTO*A(I,J)/CFROM does not over/underflow. The type argument
    specifies the structure of matrix A, which can be full, upper triangular,
    lower triangular, upper Hessenberg, or banded.

    Arguments
    ==========
    TYPE: Specifies the structure of the input matrix A (char *)
    KL:   The number of subdiagonals within the band (integer *)
    KU:   The number of superdiagonals within the band (integer *)
    CFROM: The scalar to divide elements of A before scaling (doublereal *)
    CTO:   The scalar to multiply elements of A after scaling (doublereal *)
    M:     The number of rows of the matrix A (integer *)
    N:     The number of columns of the matrix A (integer *)
    A:     Complex matrix to be scaled (doublecomplex *)
    LDA:   Leading dimension of A as specified in the calling program (integer *)
    INFO:  Status variable indicating success or failure of the operation (integer *)

    Local Variables
    ================
    Various local variables are used to manage indices, scaling factors,
    and to check for NaN (not a number) conditions.

    Other Subroutines
    =================
    LSAME: Determines if two characters are the same, ignoring case (logical function)
    DISNAN: Checks if a double precision number is NaN (not a number) (logical function)
    XERBLA: Handles errors, printing a message and terminating the program (subroutine)

    Safety Measures
    ================
    The subroutine includes safeguards to prevent overflows and underflows
    during the scaling operation, ensuring numerical stability.

    Reference
    ==========
    LAPACK Users' Guide, Third Edition (2006), pages 2.1-2.12.

*/

/* Subroutine */ int zlascl_(char *type__, integer *kl, integer *ku,
    doublereal *cfrom, doublereal *cto, integer *m, integer *n,
    doublecomplex *a, integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, k1, k2, k3, k4;
    static doublereal mul, cto1;
    static logical done;
    static doublereal ctoc;
    extern logical lsame_(char *, char *);
    static integer itype;
    static doublereal cfrom1;

    static doublereal cfromc;
    extern logical disnan_(doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal bignum, smlnum;
    
    /*
        Initialize local variables for scaling factors and NaN checks.
    */
    ! TYPE (input) CHARACTER*1
    !       TYPE indices the storage type of the input matrix.
    !       = 'G':  A is a full matrix.
    !       = 'L':  A is a lower triangular matrix.
    !       = 'U':  A is an upper triangular matrix.
    !       = 'H':  A is an upper Hessenberg matrix.
    !       = 'B':  A is a symmetric band matrix with lower bandwidth KL
    !               and upper bandwidth KU and with only the lower
    !               half stored.
    !       = 'Q':  A is a symmetric band matrix with lower bandwidth KL
    !               and upper bandwidth KU and with only the upper
    !               half stored.
    !       = 'Z':  A is a band matrix with lower bandwidth KL and upper
    !               bandwidth KU.

    ! KL (input) INTEGER
    !     The lower bandwidth of A.  Referenced only if TYPE = 'B',
    !     'Q' or 'Z'.

    ! KU (input) INTEGER
    !     The upper bandwidth of A.  Referenced only if TYPE = 'B',
    !     'Q' or 'Z'.

    ! CFROM (input) DOUBLE PRECISION
    ! CTO (input) DOUBLE PRECISION
    !     The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
    !     without over/underflow if the final result CTO*A(I,J)/CFROM
    !     can be represented without over/underflow.  CFROM must be
    !     nonzero.

    ! M (input) INTEGER
    !     The number of rows of the matrix A.  M >= 0.

    ! N (input) INTEGER
    !     The number of columns of the matrix A.  N >= 0.

    ! A (input/output) COMPLEX*16 array, dimension (LDA,N)
    !     The matrix to be multiplied by CTO/CFROM.  See TYPE for the
    !     storage type.

    ! LDA (input) INTEGER
    !     The leading dimension of the array A.  LDA >= max(1,M).

    ! INFO (output) INTEGER
    !     0  - successful exit
    !     <0 - if INFO = -i, the i-th argument had an illegal value.

    !! Test the input arguments
    /* Parameter adjustments */
    // 对参数进行调整，a_dim1 是列数，a_offset 是偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 设置 info 初始值为 0
    *info = 0;

    // 根据 type__ 的值确定 itype 的类型
    if (lsame_(type__, "G")) {
        itype = 0;
    } else if (lsame_(type__, "L")) {
        itype = 1;
    } else if (lsame_(type__, "U")) {
        itype = 2;
    } else if (lsame_(type__, "H")) {
        itype = 3;
    } else if (lsame_(type__, "B")) {
        itype = 4;
    } else if (lsame_(type__, "Q")) {
        itype = 5;
    } else if (lsame_(type__, "Z")) {
        itype = 6;
    } else {
        itype = -1;
    }

    // 根据 itype 的不同值设置 info 的值
    if (itype == -1) {
        *info = -1;
    } else if (*cfrom == 0. || disnan_(cfrom)) {
        *info = -4;
    } else if (disnan_(cto)) {
        *info = -5;
    } else if (*m < 0) {
        *info = -6;
    } else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m) {
        *info = -7;
    } else if (itype <= 3 && *lda < max(1,*m)) {
        *info = -9;
    } else if (itype >= 4) {
        // 计算 *kl 和 *ku 的边界条件
        /* Computing MAX */
        i__1 = *m - 1;
        if (*kl < 0 || *kl > max(i__1,0)) {
            *info = -2;
        } else {
            /* Computing MAX */
            i__1 = *n - 1;
            // 对 *ku 进行边界条件的判断
            if (*ku < 0 || *ku > max(i__1,0) || (itype == 4 || itype == 5) &&
                *kl != *ku) {
                *info = -3;
            } else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *
                ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1) {
                *info = -9;
            }
        }
    }

    // 如果 info 不为 0，则调用 xerbla_ 函数并返回 0
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZLASCL", &i__1);
        return 0;
    }

    /*     Quick return if possible */

    // 如果 *n 或 *m 为 0，则直接返回 0
    if (*n == 0 || *m == 0) {
        return 0;
    }

    /*     Get machine parameters */

    // 设置 smlnum 和 bignum 的值
    smlnum = SAFEMINIMUM;
    bignum = 1. / smlnum;

    // 将 *cfrom 和 *cto 的值复制到 cfromc 和 ctoc
    cfromc = *cfrom;
    ctoc = *cto;

L10:
    // 计算 cfrom1 的值
    cfrom1 = cfromc * smlnum;
    if (cfrom1 == cfromc) {
        /*
              CFROMC 是一个 inf。用正确符号的零乘以有限的 CTOC，或者如果 CTOC 是无限的，则用 NaN。
        */
        mul = ctoc / cfromc;
        done = TRUE_;
        cto1 = ctoc;
    } else {
        // 计算 cto1 的值
        cto1 = ctoc / bignum;
        if (cto1 == ctoc) {
            /*
                 CTOC 是 0 或者一个 inf。在这两种情况下，CTOC 本身作为正确的乘法因子。
            */
            mul = ctoc;
            done = TRUE_;
            cfromc = 1.;
        } else if (abs(cfrom1) > abs(ctoc) && ctoc != 0.) {
            mul = smlnum;
            done = FALSE_;
            cfromc = cfrom1;
        } else if (abs(cto1) > abs(cfromc)) {
            mul = bignum;
            done = FALSE_;
            ctoc = cto1;
        } else {
            mul = ctoc / cfromc;
            done = TRUE_;
        }
    }

    // 根据 itype 的值进行矩阵操作
    if (itype == 0) {

        /*        Full matrix */

        // 对整个矩阵进行操作
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                i__4 = i__ + j * a_dim1;
                // 对矩阵元素进行缩放操作
                z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                /* L20: */
            }
            /* L30: */
        }

    } else if (itype == 1) {

        /*        Lower triangular matrix */

        // 对下三角矩阵进行操作
        i__1 = *n;
        // 循环遍历每一列
        for (j = 1; j <= i__1; ++j) {
            i__2 = min(j,*m);
            // 循环遍历每一行
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                i__4 = i__ + j * a_dim1;
                // 对矩阵元素进行缩放操作
                z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                /* L40: */
            }
            /* L50: */
        }

    } else {
        // 对其他类型的矩阵进行处理，这部分代码省略
    }
    // 循环：对矩阵 a 中的每个元素进行操作
    for (j = 1; j <= i__1; ++j) {
        // 循环：遍历从 j 到 m 的所有行
        i__2 = *m;
        for (i__ = j; i__ <= i__2; ++i__) {
            // 计算当前元素在一维数组 a 中的索引
            i__3 = i__ + j * a_dim1;
            // 计算当前元素在一维数组 a 中的索引（重复的）
            i__4 = i__ + j * a_dim1;
            // 计算乘积 mul * a[i__4] 的实部和虚部，并存储在 z__1 中
            z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
            // 将计算结果赋值给 a[i__3]
            a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L40: */
        }
/* L50: */
    }

    } else if (itype == 2) {

/*        Upper triangular matrix */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        i__4 = i__ + j * a_dim1;
        z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L60: */
        }
/* L70: */
    }

    } else if (itype == 3) {

/*        Upper Hessenberg matrix */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
        i__3 = j + 1;
        i__2 = min(i__3,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        i__4 = i__ + j * a_dim1;
        z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L80: */
        }
/* L90: */
    }

    } else if (itype == 4) {

/*        Lower half of a symmetric band matrix */

    k3 = *kl + 1;
    k4 = *n + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
        i__3 = k3, i__4 = k4 - j;
        i__2 = min(i__3,i__4);
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        i__4 = i__ + j * a_dim1;
        z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L100: */
        }
/* L110: */
    }

    } else if (itype == 5) {

/*        Upper half of a symmetric band matrix */

    k1 = *ku + 2;
    k3 = *ku + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
        i__2 = k1 - j;
        i__3 = k3;
        for (i__ = max(i__2,1); i__ <= i__3; ++i__) {
        i__2 = i__ + j * a_dim1;
        i__4 = i__ + j * a_dim1;
        z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
        a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L120: */
        }
/* L130: */
    }

    } else if (itype == 6) {

/*        Band matrix */

    k1 = *kl + *ku + 2;
    k2 = *kl + 1;
    k3 = (*kl << 1) + *ku + 1;
    k4 = *kl + *ku + 1 + *m;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
        i__3 = k1 - j;
/* Computing MIN */
        i__4 = k3, i__5 = k4 - j;
        i__2 = min(i__4,i__5);
        for (i__ = max(i__3,k2); i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        i__4 = i__ + j * a_dim1;
        z__1.r = mul * a[i__4].r, z__1.i = mul * a[i__4].i;
        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L140: */
        }
/* L150: */
    }

    }

    if (! done) {
    goto L10;
    }

    return 0;

/*     End of ZLASCL */

} /* zlascl_ */

/* Subroutine */ int zlaset_(char *uplo, integer *m, integer *n,
    doublecomplex *alpha, doublecomplex *beta, doublecomplex *a, integer *
    lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
*/

/* L160: */
    }
/* L170: */
}


注释：
    -- LAPACK is a software package provided by Univ. of Tennessee,
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
    November 2006
    
    
    
    # LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，发布于2006年11月。
    
    
    
    Purpose
    =======
    
    
    
    # 函数目的
    
    
    
    ZLASET initializes a 2-D array A to BETA on the diagonal and
    ALPHA on the offdiagonals.
    
    
    
    # ZLASET 函数用于初始化一个二维数组 A，对角线上的元素设为 BETA，非对角线上的元素设为 ALPHA。
    
    
    
    Arguments
    =========
    
    
    
    # 参数说明
    
    
    
    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set. The lower triangle
                        is unchanged.
            = 'L':      Lower triangular part is set. The upper triangle
                        is unchanged.
            Otherwise:  All of the matrix A is set.
    
    
    
    # UPLO（输入） CHARACTER*1
    # 指定要设置的矩阵 A 的部分。
    # = 'U':      设置上三角部分。下三角保持不变。
    # = 'L':      设置下三角部分。上三角保持不变。
    # 其他情况:    设置矩阵 A 的所有部分。
    
    
    
    M       (input) INTEGER
            On entry, M specifies the number of rows of A.
    
    
    
    # M（输入） INTEGER
    # 指定矩阵 A 的行数。
    
    
    
    N       (input) INTEGER
            On entry, N specifies the number of columns of A.
    
    
    
    # N（输入） INTEGER
    # 指定矩阵 A 的列数。
    
    
    
    ALPHA   (input) COMPLEX*16
            All the offdiagonal array elements are set to ALPHA.
    
    
    
    # ALPHA（输入） COMPLEX*16
    # 所有非对角线的数组元素都设为 ALPHA。
    
    
    
    BETA    (input) COMPLEX*16
            All the diagonal array elements are set to BETA.
    
    
    
    # BETA（输入） COMPLEX*16
    # 所有对角线的数组元素都设为 BETA。
    
    
    
    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
                     A(i,i) = BETA , 1 <= i <= min(m,n)
    
    
    
    # A（输入/输出） COMPLEX*16 数组，维度为 (LDA,N)
    # 在输入时，是一个 m 行 n 列的矩阵 A。
    # 在输出时，A(i,j) = ALPHA，其中 1 <= i <= m，1 <= j <= n，且 i ≠ j；
    #         A(i,i) = BETA，其中 1 <= i <= min(m,n)。
    
    
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
    
    
    
    # LDA（输入） INTEGER
    # 数组 A 的主维度。要求 LDA >= max(1,M)。
    
    
    
    =====================================================================
    
    
    
    # 结束注释
    /* Parameter adjustments */
    // 设置参数调整
    a_dim1 = *lda;
    // 将一维数组长度设置为参数 lda 的值
    a_offset = 1 + a_dim1;
    // 计算偏移量，使得 a 数组的起始索引为 1 + a_dim1
    a -= a_offset;
    // 调整数组 a 的起始地址，使其从 a_offset 处开始访问

    /* Function Body */
    // 函数体开始
    if (lsame_(uplo, "U")) {
    // 如果 uplo 参数值为 'U'，表示上三角部分需要设置

/*
          Set the diagonal to BETA and the strictly upper triangular
          part of the array to ALPHA.
*/
    // 将对角线设置为 beta，严格上三角部分设置为 alpha

    i__1 = *n;
    // 循环次数为 n
    for (j = 2; j <= i__1; ++j) {
    // 循环遍历列 j 从 2 到 n
/* Computing MIN */
        // 计算最小值
        i__3 = j - 1;
        // i__3 等于 j - 1
        i__2 = min(i__3,*m);
        // i__2 是 i__3 和 *m 中的最小值
        for (i__ = 1; i__ <= i__2; ++i__) {
        // 循环遍历行 i 从 1 到 i__2
        i__3 = i__ + j * a_dim1;
        // 计算数组 a 的索引 i__3
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
        // 设置数组 a 中索引为 i__3 的实部为 alpha 的实部，虚部为 alpha 的虚部
/* L10: */
        // 标号 L10
        }
/* L20: */
    // 标号 L20
    }
    // 循环结束
    i__1 = min(*n,*m);
    // 计算 i__1 为 *n 和 *m 中的最小值
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 循环遍历行 i 从 1 到 i__1
        i__2 = i__ + i__ * a_dim1;
        // 计算数组 a 的索引 i__2
        a[i__2].r = beta->r, a[i__2].i = beta->i;
        // 设置数组 a 中索引为 i__2 的实部为 beta 的实部，虚部为 beta 的虚部
/* L30: */
        // 标号 L30
    }
    // 循环结束

    } else if (lsame_(uplo, "L")) {
    // 如果 uplo 参数值为 'L'，表示下三角部分需要设置

/*
          Set the diagonal to BETA and the strictly lower triangular
          part of the array to ALPHA.
*/
    // 将对角线设置为 beta，严格下三角部分设置为 alpha

    i__1 = min(*m,*n);
    // 计算 i__1 为 *m 和 *n 中的最小值
    for (j = 1; j <= i__1; ++j) {
    // 循环遍历列 j 从 1 到 i__1
        i__2 = *m;
        // i__2 等于 *m
        for (i__ = j + 1; i__ <= i__2; ++i__) {
        // 循环遍历行 i 从 j + 1 到 i__2
        i__3 = i__ + j * a_dim1;
        // 计算数组 a 的索引 i__3
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
        // 设置数组 a 中索引为 i__3 的实部为 alpha 的实部，虚部为 alpha 的虚部
/* L40: */
        // 标号 L40
        }
/* L50: */
    // 标号 L50
    }
    // 循环结束
    i__1 = min(*n,*m);
    // 计算 i__1 为 *n 和 *m 中的最小值
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 循环遍历行 i 从 1 到 i__1
        i__2 = i__ + i__ * a_dim1;
        // 计算数组 a 的索引 i__2
        a[i__2].r = beta->r, a[i__2].i = beta->i;
        // 设置数组 a 中索引为 i__2 的实部为 beta 的实部，虚部为 beta 的虚部
/* L60: */
        // 标号 L60
    }
    // 循环结束

    } else {
    // 如果 uplo 参数值不是 'U' 也不是 'L'

/*
          Set the array to BETA on the diagonal and ALPHA on the
          offdiagonal.
*/
    // 将对角线设置为 beta，非对角线部分设置为 alpha

    i__1 = *n;
    // 循环次数为 n
    for (j = 1; j <= i__1; ++j) {
    // 循环遍历列 j 从 1 到 n
        i__2 = *m;
        // i__2 等于 *m
        for (i__ = 1; i__ <= i__2; ++i__) {
        // 循环遍历行 i 从 1 到 i__2
        i__3 = i__ + j * a_dim1;
        // 计算数组 a 的索引 i__3
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
        // 设置数组 a 中索引为 i__3 的实部为 alpha 的实部，虚部为 alpha 的虚部
/* L70: */
        // 标号 L70
        }
/* L80: */
    // 标号 L80
    }
    // 循环结束
    i__1 = min(*m,*n);
    // 计算 i__1 为 *m 和 *n 中的最小值
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 循环遍历行 i 从 1 到 i__1
        i__2 = i__ + i__ * a_dim1;
        // 计算数组 a 的索引 i__2
        a[i__2].r = beta->r, a[i__2].i = beta->i;
        // 设置数组 a 中索引为 i__2 的实部为 beta 的实部，虚部为 beta 的虚部
/* L90: */
        // 标号 L90
    }
    // 循环结束

    return 0;

/*     End of ZLASET */

} /* zlaset_ */

/* Subroutine */ int zlasr_(char *side, char *pivot, char *direct, integer *m,
     integer *n, doublereal *c__, doublereal *s, doublecomplex *a,
    integer *lda)
{
    /* System generated locals */
    // 系统生成的本地变量
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    doublecomplex z__1, z__2, z__3;

    /* Local variables */
    // 本地变量
    static integer i__, j, info;
    static doublecomplex temp;
    extern logical lsame_(char *, char *);
    static doublereal ctemp, stemp;
    extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
*/

    // ZLASR 应用一系列实数平面旋转到复矩阵 A，从左侧或右侧进行变换。

    // 当 SIDE = 'L' 时，变换形式为 A := P*A

    // 当 SIDE = 'R' 时，变换形式为 A := A*P**T

    // 其中 P 是由一系列 z 平面旋转组成的正交矩阵
    rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
    and P**T is the transpose of P.



    When DIRECT = 'F' (Forward sequence), then

       P = P(z-1) * ... * P(2) * P(1)



    and when DIRECT = 'B' (Backward sequence), then

       P = P(1) * P(2) * ... * P(z-1)



    where P(k) is a plane rotation matrix defined by the 2-by-2 rotation

       R(k) = (  c(k)  s(k) )
            = ( -s(k)  c(k) ).



    When PIVOT = 'V' (Variable pivot), the rotation is performed
    for the plane (k,k+1), i.e., P(k) has the form

       P(k) = (  1                                            )
              (       ...                                     )
              (              1                                )
              (                   c(k)  s(k)                  )
              (                  -s(k)  c(k)                  )
              (                                1              )
              (                                     ...       )
              (                                            1  )



    where R(k) appears as a rank-2 modification to the identity matrix in
    rows and columns k and k+1.



    When PIVOT = 'T' (Top pivot), the rotation is performed for the
    plane (1,k+1), so P(k) has the form

       P(k) = (  c(k)                    s(k)                 )
              (         1                                     )
              (              ...                              )
              (                     1                         )
              ( -s(k)                    c(k)                 )
              (                                 1             )
              (                                      ...      )
              (                                             1 )



    where R(k) appears in rows and columns 1 and k+1.



    Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
    performed for the plane (k,z), giving P(k) the form

       P(k) = ( 1                                             )
              (      ...                                      )
              (             1                                 )
              (                  c(k)                    s(k) )
              (                         1                     )
              (                              ...              )
              (                                     1         )
              (                 -s(k)                    c(k) )



    where R(k) appears in rows and columns k and z.  The rotations are
    performed without ever forming P(k) explicitly.



    Arguments
    =========

    SIDE    (input) CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
    ! PIVOT   (input) CHARACTER*1
    !         指定 P(k) 是一个平面旋转矩阵的平面。
    !         = 'V': 变量 pivot，平面 (k,k+1)
    !         = 'T': 顶部 pivot，平面 (1,k+1)
    !         = 'B': 底部 pivot，平面 (k,z)

    ! DIRECT  (input) CHARACTER*1
    !         指定 P 是一个前向还是后向平面旋转序列。
    !         = 'F': 前向，P = P(z-1)*...*P(2)*P(1)
    !         = 'B': 后向，P = P(1)*P(2)*...*P(z-1)

    ! M       (input) INTEGER
    !         矩阵 A 的行数。如果 m <= 1，则立即返回。

    ! N       (input) INTEGER
    !         矩阵 A 的列数。如果 n <= 1，则立即返回。

    ! C       (input) DOUBLE PRECISION array, dimension
    !                 (M-1) if SIDE = 'L'
    !                 (N-1) if SIDE = 'R'
    !         平面旋转的余弦值 c(k)。

    ! S       (input) DOUBLE PRECISION array, dimension
    !                 (M-1) if SIDE = 'L'
    !                 (N-1) if SIDE = 'R'
    !         平面旋转的正弦值 s(k)。矩阵 P(k) 的 2x2 平面旋转部分 R(k) 的形式为：
    !         R(k) = (  c(k)  s(k) )
    !                ( -s(k)  c(k) ).

    ! A       (input/output) COMPLEX*16 array, dimension (LDA,N)
    !         复数类型的 MxN 矩阵 A。退出时，如果 SIDE = 'R'，则 A 被 P*A 覆盖；
    !         如果 SIDE = 'L'，则被 A*P**T 覆盖。

    ! LDA     (input) INTEGER
    !         数组 A 的领导维度。LDA >= max(1,M).

    !=====================================================================

    ! 测试输入参数
    /* Parameter adjustments */
    --c__;
    --s;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    info = 0;
    // 检查参数 `side` 是否为 "L" 或 "R"
    if (! (lsame_(side, "L") || lsame_(side, "R"))) {
        info = 1;
    } else if (! (lsame_(pivot, "V") || lsame_(pivot, "T") || lsame_(pivot, "B"))) {
        // 检查参数 `pivot` 是否为 "V", "T", 或 "B"
        info = 2;
    } else if (! (lsame_(direct, "F") || lsame_(direct, "B"))) {
        // 检查参数 `direct` 是否为 "F" 或 "B"
        info = 3;
    } else if (*m < 0) {
        // 检查参数 `m` 是否小于 0
        info = 4;
    } else if (*n < 0) {
        // 检查参数 `n` 是否小于 0
        info = 5;
    } else if (*lda < max(1,*m)) {
        // 检查参数 `lda` 是否小于 max(1, m)
        info = 9;
    }
    // 如果有错误信息，调用错误处理函数并返回
    if (info != 0) {
        xerbla_("ZLASR ", &info);
        return 0;
    }

    /* Quick return if possible */
    // 如果 m 或 n 为 0，直接返回
    if (*m == 0 || *n == 0) {
        return 0;
    }
    // 如果 side 参数为 "L"，执行以下代码块

    /* Form P * A */
    // 如果 pivot 参数为 "V"，执行以下代码块
    if (lsame_(pivot, "V")) {
        // 如果 direct 参数为 "F"，执行以下代码块
        if (lsame_(direct, "F")) {
            // 循环遍历 j = 1 到 m-1
            i__1 = *m - 1;
            for (j = 1; j <= i__1; ++j) {
                // 获取 ctemp 和 stemp 的值
                ctemp = c__[j];
                stemp = s[j];
                // 如果 ctemp 不为 1 或 stemp 不为 0，执行以下代码块
                if (ctemp != 1. || stemp != 0.) {
                    // 循环遍历 i = 1 到 n
                    i__2 = *n;
                    for (i__ = 1; i__ <= i__2; ++i__) {
                        // 获取 a(j+1, i) 的值
                        i__3 = j + 1 + i__ * a_dim1;
                        temp.r = a[i__3].r, temp.i = a[i__3].i;
                        // 计算更新后的值并赋给 a(j+1, i)
                        i__3 = j + 1 + i__ * a_dim1;
                        z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                        i__4 = j + i__ * a_dim1;
                        z__3.r = stemp * a[i__4].r, z__3.i = stemp * a[i__4].i;
                        z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
                        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                        // 计算更新后的值并赋给 a(j, i)
                        i__3 = j + i__ * a_dim1;
                        z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                        i__4 = j + i__ * a_dim1;
                        z__3.r = ctemp * a[i__4].r, z__3.i = ctemp * a[i__4].i;
                        z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
                        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                    }
                }
            }
        }
    }
/* L20: 结束 if (lsame_(direct, "B")) 的条件判断块 */
        }
        /* 进入 else if (lsame_(direct, "B")) 分支 */
        } else if (lsame_(direct, "B")) {
        /* 从倒数第二行开始向上遍历 */
        for (j = *m - 1; j >= 1; --j) {
            /* 保存 c__[j] 和 s[j] 的值 */
            ctemp = c__[j];
            stemp = s[j];
            /* 如果 ctemp 不等于 1 或者 stemp 不等于 0 */
            if (ctemp != 1. || stemp != 0.) {
            /* 遍历列 */
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                /* temp 保存 a[j+1][i] 的值 */
                i__2 = j + 1 + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                /* a[j+1][i] 更新为 ctemp * temp - stemp * a[j][i] */
                i__2 = j + 1 + i__ * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__3 = j + i__ * a_dim1;
                z__3.r = stemp * a[i__3].r, z__3.i = stemp * a[
                    i__3].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                /* a[j][i] 更新为 stemp * temp + ctemp * a[j][i] */
                i__2 = j + i__ * a_dim1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__3 = j + i__ * a_dim1;
                z__3.r = ctemp * a[i__3].r, z__3.i = ctemp * a[
                    i__3].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L30: 结束列遍历 */
            }
            /* L40: 结束 if (ctemp != 1. || stemp != 0.) */
            }
/* L40: 结束行遍历 */
        }
        /* L40: 结束 else if (lsame_(direct, "B")) 分支 */
        }
    } else if (lsame_(pivot, "T")) {
        /* 如果 pivot 为 "T" */
        if (lsame_(direct, "F")) {
        /* 如果 direct 为 "F" */
        /* 遍历行 */
        i__1 = *m;
        for (j = 2; j <= i__1; ++j) {
            /* 保存 c__[j-1] 和 s[j-1] 的值 */
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            /* 如果 ctemp 不等于 1 或者 stemp 不等于 0 */
            if (ctemp != 1. || stemp != 0.) {
            /* 遍历列 */
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* temp 保存 a[j][i] 的值 */
                i__3 = j + i__ * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                /* a[j][i] 更新为 ctemp * temp - stemp * a[i][1] */
                i__3 = j + i__ * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__4 = i__ * a_dim1 + 1;
                z__3.r = stemp * a[i__4].r, z__3.i = stemp * a[
                    i__4].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                /* a[i][1] 更新为 stemp * temp + ctemp * a[i][1] */
                i__3 = i__ * a_dim1 + 1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__4 = i__ * a_dim1 + 1;
                z__3.r = ctemp * a[i__4].r, z__3.i = ctemp * a[
                    i__4].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L50: 结束列遍历 */
            }
            /* L50: 结束 if (ctemp != 1. || stemp != 0.) */
            }
/* L50: 结束行遍历 */
        }
        /* L50: 结束 if (lsame_(direct, "F")) */
        }
/* L50: 结束 if (lsame_(pivot, "T")) */
/* L60: */
        }
        } else if (lsame_(direct, "B")) {
        // 如果 direct 是 "B"，则执行以下操作
        for (j = *m; j >= 2; --j) {
            ctemp = c__[j - 1];  // 从数组 c__ 中获取 ctemp 的值
            stemp = s[j - 1];  // 从数组 s 中获取 stemp 的值
            if (ctemp != 1. || stemp != 0.) {
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下操作
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = j + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;  // 从数组 a 中获取 temp 的值
                i__2 = j + i__ * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;  // 计算 z__2 的值
                i__3 = i__ * a_dim1 + 1;
                z__3.r = stemp * a[i__3].r, z__3.i = stemp * a[
                    i__3].i;  // 计算 z__3 的值
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;  // 计算 z__1 的值
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;  // 将 z__1 的值赋给数组 a
                i__2 = i__ * a_dim1 + 1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;  // 计算 z__2 的值
                i__3 = i__ * a_dim1 + 1;
                z__3.r = ctemp * a[i__3].r, z__3.i = ctemp * a[
                    i__3].i;  // 计算 z__3 的值
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;  // 计算 z__1 的值
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;  // 将 z__1 的值赋给数组 a
/* L70: */
            }
            }
/* L80: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        // 如果 pivot 是 "B"，则执行以下操作
        if (lsame_(direct, "F")) {
        // 如果 direct 是 "F"，则执行以下操作
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];  // 从数组 c__ 中获取 ctemp 的值
            stemp = s[j];  // 从数组 s 中获取 stemp 的值
            if (ctemp != 1. || stemp != 0.) {
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下操作
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = j + i__ * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;  // 从数组 a 中获取 temp 的值
                i__3 = j + i__ * a_dim1;
                i__4 = *m + i__ * a_dim1;
                z__2.r = stemp * a[i__4].r, z__2.i = stemp * a[
                    i__4].i;  // 计算 z__2 的值
                z__3.r = ctemp * temp.r, z__3.i = ctemp * temp.i;  // 计算 z__3 的值
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;  // 计算 z__1 的值
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;  // 将 z__1 的值赋给数组 a
                i__3 = *m + i__ * a_dim1;
                i__4 = *m + i__ * a_dim1;
                z__2.r = ctemp * a[i__4].r, z__2.i = ctemp * a[
                    i__4].i;  // 计算 z__2 的值
                z__3.r = stemp * temp.r, z__3.i = stemp * temp.i;  // 计算 z__3 的值
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;  // 计算 z__1 的值
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;  // 将 z__1 的值赋给数组 a
/* L90: */
            }
            }
/* L100: */
        }
        } else if (lsame_(direct, "B")) {
        // 如果 direct 参数为 "B"，执行以下循环
        for (j = *m - 1; j >= 1; --j) {
            // 将 c__[j] 和 s[j] 的值分别赋给 ctemp 和 stemp
            ctemp = c__[j];
            stemp = s[j];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下循环
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *n;
            // 遍历 i__ 从 1 到 *n
            for (i__ = 1; i__ <= i__1; ++i__) {
                // 计算数组 a 中的复数值
                i__2 = j + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = j + i__ * a_dim1;
                i__3 = *m + i__ * a_dim1;
                z__2.r = stemp * a[i__3].r, z__2.i = stemp * a[
                    i__3].i;
                z__3.r = ctemp * temp.r, z__3.i = ctemp * temp.i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                i__2 = *m + i__ * a_dim1;
                i__3 = *m + i__ * a_dim1;
                z__2.r = ctemp * a[i__3].r, z__2.i = ctemp * a[
                    i__3].i;
                z__3.r = stemp * temp.r, z__3.i = stemp * temp.i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L110: */
            }
            }
/* L120: */
        }
        }
    }
    } else if (lsame_(side, "R")) {

/*        Form A * P' */

    // 如果 side 参数为 "R"，执行以下代码块
    if (lsame_(pivot, "V")) {
        // 如果 pivot 参数为 "V"，执行以下代码块
        if (lsame_(direct, "F")) {
        // 如果 direct 参数为 "F"，执行以下循环
        i__1 = *n - 1;
        // 遍历 j 从 1 到 *n-1
        for (j = 1; j <= i__1; ++j) {
            // 将 c__[j] 和 s[j] 的值分别赋给 ctemp 和 stemp
            ctemp = c__[j];
            stemp = s[j];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下循环
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *m;
            // 遍历 i__ 从 1 到 *m
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 计算数组 a 中的复数值
                i__3 = i__ + (j + 1) * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                i__3 = i__ + (j + 1) * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__4 = i__ + j * a_dim1;
                z__3.r = stemp * a[i__4].r, z__3.i = stemp * a[
                    i__4].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                i__3 = i__ + j * a_dim1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__4 = i__ + j * a_dim1;
                z__3.r = ctemp * a[i__4].r, z__3.i = ctemp * a[
                    i__4].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L130: */
            }
            }
/* L140: */
        }
        } else if (lsame_(direct, "B")) {
        // 如果 direct 参数为 "B"，执行以下循环
        for (j = *n - 1; j >= 1; --j) {
            // 保存当前列的 c 和 s 值
            ctemp = c__[j];
            stemp = s[j];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下循环
            if (ctemp != 1. || stemp != 0.) {
            // 循环遍历每一行
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                // 临时变量 temp 存储当前位置的复数值
                i__2 = i__ + (j + 1) * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                // 计算新值并赋给 a 数组
                i__2 = i__ + (j + 1) * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__3 = i__ + j * a_dim1;
                z__3.r = stemp * a[i__3].r, z__3.i = stemp * a[
                    i__3].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                // 计算新值并赋给 a 数组的另一位置
                i__2 = i__ + j * a_dim1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__3 = i__ + j * a_dim1;
                z__3.r = ctemp * a[i__3].r, z__3.i = ctemp * a[
                    i__3].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L150: */
            }
            }
/* L160: */
        }
        }
    } else if (lsame_(pivot, "T")) {
        // 如果 pivot 参数为 "T"，执行以下条件判断
        if (lsame_(direct, "F")) {
        // 如果 direct 参数为 "F"，执行以下循环
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
            // 保存当前列的 c 和 s 值
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行以下循环
            if (ctemp != 1. || stemp != 0.) {
            // 循环遍历每一行
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 临时变量 temp 存储当前位置的复数值
                i__3 = i__ + j * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                // 计算新值并赋给 a 数组
                i__3 = i__ + j * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__4 = i__ + a_dim1;
                z__3.r = stemp * a[i__4].r, z__3.i = stemp * a[
                    i__4].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                // 计算新值并赋给 a 数组的另一位置
                i__3 = i__ + a_dim1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__4 = i__ + a_dim1;
                z__3.r = ctemp * a[i__4].r, z__3.i = ctemp * a[
                    i__4].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L170: */
            }
            }
/* L180: */
        }
        } else if (lsame_(direct, "B")) {
        ! 如果 direct 参数为 "B"，执行以下操作
        for (j = *n; j >= 2; --j) {
            ! 从右向左遍历列索引 j，执行以下操作
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            ! 获取 c 和 s 向量中的值 ctemp 和 stemp
            if (ctemp != 1. || stemp != 0.) {
            ! 如果 ctemp 不等于 1 或 stemp 不等于 0，执行以下操作
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                ! 对于每个行索引 i，执行以下操作
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                ! 获取矩阵 A 中的复数元素 temp
                i__2 = i__ + j * a_dim1;
                z__2.r = ctemp * temp.r, z__2.i = ctemp * temp.i;
                i__3 = i__ + a_dim1;
                z__3.r = stemp * a[i__3].r, z__3.i = stemp * a[
                    i__3].i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                ! 计算更新矩阵 A 中的元素
                i__2 = i__ + a_dim1;
                z__2.r = stemp * temp.r, z__2.i = stemp * temp.i;
                i__3 = i__ + a_dim1;
                z__3.r = ctemp * a[i__3].r, z__3.i = ctemp * a[
                    i__3].i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L190: */
            }
            }
/* L200: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        ! 如果 pivot 参数为 "B"，执行以下操作
        if (lsame_(direct, "F")) {
        ! 如果 direct 参数为 "F"，执行以下操作
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            ! 遍历从 1 到 n-1 的列索引 j，执行以下操作
            ctemp = c__[j];
            stemp = s[j];
            ! 获取 c 和 s 向量中的值 ctemp 和 stemp
            if (ctemp != 1. || stemp != 0.) {
            ! 如果 ctemp 不等于 1 或 stemp 不等于 0，执行以下操作
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                ! 对于每个行索引 i，执行以下操作
                i__3 = i__ + j * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                ! 获取矩阵 A 中的复数元素 temp
                i__3 = i__ + j * a_dim1;
                i__4 = i__ + *n * a_dim1;
                z__2.r = stemp * a[i__4].r, z__2.i = stemp * a[
                    i__4].i;
                z__3.r = ctemp * temp.r, z__3.i = ctemp * temp.i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
                ! 计算更新矩阵 A 中的元素
                i__3 = i__ + *n * a_dim1;
                i__4 = i__ + *n * a_dim1;
                z__2.r = ctemp * a[i__4].r, z__2.i = ctemp * a[
                    i__4].i;
                z__3.r = stemp * temp.r, z__3.i = stemp * temp.i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__3].r = z__1.r, a[i__3].i = z__1.i;
/* L210: */
            }
            }
/* L220: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = i__ + j * a_dim1;
                i__3 = i__ + *n * a_dim1;
                z__2.r = stemp * a[i__3].r, z__2.i = stemp * a[
                    i__3].i;
                z__3.r = ctemp * temp.r, z__3.i = ctemp * temp.i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                i__2 = i__ + *n * a_dim1;
                i__3 = i__ + *n * a_dim1;
                z__2.r = ctemp * a[i__3].r, z__2.i = ctemp * a[
                    i__3].i;
                z__3.r = stemp * temp.r, z__3.i = stemp * temp.i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L230: */
            }
            }
/* L240: */
        }
        }
    }
    }

    return 0;

/*     End of ZLASR */

} /* zlasr_ */

/* Subroutine */ int zlassq_(integer *n, doublecomplex *x, integer *incx,
    doublereal *scale, doublereal *sumsq)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer ix;
    static doublereal temp1;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLASSQ returns the values scl and ssq such that

       ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
    assumed to be at least unity and the value of ssq will then satisfy

       1.0 .le. ssq .le. ( sumsq + 2*n ).

    scale is assumed to be non-negative and scl returns the value

       scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
              i

    scale and sumsq must be supplied in SCALE and SUMSQ respectively.
    SCALE and SUMSQ are overwritten by scl and ssq respectively.

    The routine makes only one pass through the vector X.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.

    X       (input) COMPLEX*16 array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.


/* L220: */
        }
        } else if (lsame_(direct, "B")) {
        // 反向循环处理列
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            // 如果旋转角度不是标准值
            if (ctemp != 1. || stemp != 0.) {
            // 循环处理每一行
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                // 记录当前元素到临时变量
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                // 计算乘积和差值
                i__2 = i__ + j * a_dim1;
                i__3 = i__ + *n * a_dim1;
                z__2.r = stemp * a[i__3].r, z__2.i = stemp * a[
                    i__3].i;
                z__3.r = ctemp * temp.r, z__3.i = ctemp * temp.i;
                z__1.r = z__2.r + z__3.r, z__1.i = z__2.i +
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
                i__2 = i__ + *n * a_dim1;
                i__3 = i__ + *n * a_dim1;
                z__2.r = ctemp * a[i__3].r, z__2.i = ctemp * a[
                    i__3].i;
                z__3.r = stemp * temp.r, z__3.i = stemp * temp.i;
                z__1.r = z__2.r - z__3.r, z__1.i = z__2.i -
                    z__3.i;
                a[i__2].r = z__1.r, a[i__2].i = z__1.i;
/* L230: */
            }
            }
/* L240: */
        }
        }
    }
    }

    // 返回成功标志
    return 0;

/*     End of ZLASR */

} /* zlasr_ */

/* Subroutine */ int zlassq_(integer *n, doublecomplex *x, integer *incx,
    doublereal *scale, doublereal *sumsq)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer ix;
    static doublereal temp1;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLASSQ returns the values scl and ssq such that

       ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
    assumed to be at least unity and the value of ssq will then satisfy

       1.0 .le. ssq .le. ( sumsq + 2*n ).

    scale is assumed to be non-negative and scl returns the value

       scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
              i

    scale and sumsq must be supplied in SCALE and SUMSQ respectively.
    SCALE and SUMSQ are overwritten by scl and ssq respectively.

    The routine makes only one pass through the vector X.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.

    X       (input) COMPLEX*16 array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.

    /* Local variables */
    static integer ix;
    static doublereal temp1;

/*     Begin block with constraints */

    # System-generated variables
    Integer statement particular Meaningcheng within
    SCALE   (input/output) DOUBLE PRECISION
            # 输入/输出参数，DOUBLE PRECISION 类型，表示上述方程中的 scale 值。
            # 在进入函数时，scale 表示上述方程中的值。
            # 在函数退出时，scale 被重写为 scl 的值。

    SUMSQ   (input/output) DOUBLE PRECISION
            # 输入/输出参数，DOUBLE PRECISION 类型，表示上述方程中的 sumsq 值。
            # 在进入函数时，sumsq 表示上述方程中的值。
            # 在函数退出时，sumsq 被重写为 ssq 的值。

   =====================================================================
    /* Parameter adjustments */
    --x;

    /* Function Body */
    // 如果 n 大于 0，则进入循环
    if (*n > 0) {
        // 计算循环的终点 ix
        i__1 = (*n - 1) * *incx + 1;
        i__2 = *incx;
        for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {
            // 检查实部不为零的情况
            i__3 = ix;
            if (x[i__3].r != 0.) {
                // 计算绝对值并更新 scale 和 sumsq
                i__3 = ix;
                temp1 = (d__1 = x[i__3].r, abs(d__1));
                if (*scale < temp1) {
                    // 更新 sumsq 和 scale
                    /* Computing 2nd power */
                    d__1 = *scale / temp1;
                    *sumsq = *sumsq * (d__1 * d__1) + 1;
                    *scale = temp1;
                } else {
                    /* Computing 2nd power */
                    d__1 = temp1 / *scale;
                    *sumsq += d__1 * d__1;
                }
            }
            // 检查虚部不为零的情况
            if (d_imag(&x[ix]) != 0.) {
                // 计算虚部的绝对值并更新 scale 和 sumsq
                temp1 = (d__1 = d_imag(&x[ix]), abs(d__1));
                if (*scale < temp1) {
                    // 更新 sumsq 和 scale
                    /* Computing 2nd power */
                    d__1 = *scale / temp1;
                    *sumsq = *sumsq * (d__1 * d__1) + 1;
                    *scale = temp1;
                } else {
                    /* Computing 2nd power */
                    d__1 = temp1 / *scale;
                    *sumsq += d__1 * d__1;
                }
            }
            // 循环的下一步
/* L10: */
        }
    }

    // 返回结果
    return 0;

/*     End of ZLASSQ */

} /* zlassq_ */

/* Subroutine */ int zlaswp_(integer *n, doublecomplex *a, integer *lda,
    integer *k1, integer *k2, integer *ipiv, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;

    /* Local variables */
    static integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    static doublecomplex temp;


    /* LAPACK auxiliary routine (version 3.2) */
    /* LAPACK is a software package provided by Univ. of Tennessee, */
    /* Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. */
    /* November 2006 */


    /* Purpose */
    /* ======= */

    // ZLASWP 执行对矩阵 A 的一系列行交换。
    // 对于 A 的每一行，都会进行一次行交换。

    /* Arguments */
    /* ========= */

    // N (input) INTEGER
    // 矩阵 A 的列数。

    // A (input/output) COMPLEX*16 array, dimension (LDA,N)
    // 进行行交换的矩阵 A。
    // 入口时，为列数为 N 的矩阵 A。
    // 出口时，为经过排列的矩阵。

    // LDA (input) INTEGER
    // 数组 A 的第一个维度的长度。

    // K1 (input) INTEGER
    // IPIV 的第一个元素，将进行行交换。

    // K2 (input) INTEGER
    // IPIV 的最后一个元素，将进行行交换。

    // IPIV (input) INTEGER array, dimension (K2*abs(INCX))
    // 枢轴指标向量。仅访问 IPIV 中位置 K1 到 K2 的元素。
    // IPIV(K) = L 意味着交换行 K 和 L。

    // INCX (input) INTEGER
    // IPIV 中连续值的增量。如果 IPIV 为负，则以相反顺序应用枢轴。

    /* Further Details */
    /* =============== */
    Modified by
     R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA


这行代码用于说明代码的修改者和他们的机构信息。


   =====================================================================


这行是用来分隔不同部分或者标志性注释行的分隔线。


       Interchange row I with row IPIV(I) for each of rows K1 through K2.


这行描述了一个算法步骤或操作，用于将矩阵中的行进行交换。
/* Parameter adjustments */
/* 调整参数 */
a_dim1 = *lda;
/* 获取矩阵 A 的第一维度大小 */
a_offset = 1 + a_dim1;
/* 计算矩阵 A 的偏移量 */
a -= a_offset;
/* 将矩阵 A 指针向前移动到正确的起始位置 */
--ipiv;
/* 将数组 ipiv 指针向前移动到正确的起始位置 */

/* Function Body */
/* 函数体开始 */
if (*incx > 0) {
    /* 如果增量 incx 大于 0 */
    ix0 = *k1;
    /* 设置 ix0 为 k1 */
    i1 = *k1;
    /* 设置 i1 为 k1 */
    i2 = *k2;
    /* 设置 i2 为 k2 */
    inc = 1;
    /* 设置增量 inc 为 1 */
} else if (*incx < 0) {
    /* 否则如果增量 incx 小于 0 */
    ix0 = (1 - *k2) * *incx + 1;
    /* 计算 ix0 */
    i1 = *k2;
    /* 设置 i1 为 k2 */
    i2 = *k1;
    /* 设置 i2 为 k1 */
    inc = -1;
    /* 设置增量 inc 为 -1 */
} else {
    /* 否则 */
    return 0;
    /* 返回 0 */
}

n32 = *n / 32 << 5;
/* 计算 n32 */
if (n32 != 0) {
    /* 如果 n32 不等于 0 */
    i__1 = n32;
    /* 循环次数为 n32 */
    for (j = 1; j <= i__1; j += 32) {
        /* j 每次增加 32 */
        ix = ix0;
        /* 设置 ix 为 ix0 */
        i__2 = i2;
        /* 循环次数为 i2 */
        i__3 = inc;
        /* 步长为 inc */
        for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3) {
            /* 循环 i__ */
            ip = ipiv[ix];
            /* 获取 ipiv[ix] 的值 */
            if (ip != i__) {
                /* 如果 ip 不等于 i__ */
                i__4 = j + 31;
                /* 循环次数为 j + 31 */
                for (k = j; k <= i__4; ++k) {
                    /* 循环 k */
                    i__5 = i__ + k * a_dim1;
                    /* 计算数组下标 */
                    temp.r = a[i__5].r, temp.i = a[i__5].i;
                    /* 临时变量保存 a[i__5] 的值 */
                    i__5 = i__ + k * a_dim1;
                    i__6 = ip + k * a_dim1;
                    a[i__5].r = a[i__6].r, a[i__5].i = a[i__6].i;
                    /* 交换 a[i__5] 和 a[i__6] 的值 */
                    i__5 = ip + k * a_dim1;
                    a[i__5].r = temp.r, a[i__5].i = temp.i;
                    /* 将临时变量的值赋给 a[i__5] */
/* L10: */
                    /* L10 标签 */
                }
            }
            ix += *incx;
/* L20: */
            /* L20 标签 */
        }
/* L30: */
        /* L30 标签 */
    }
}
/* 如果 n32 不为 0 的情况下的结束 */

if (n32 != *n) {
    /* 如果 n32 不等于 n */
    ++n32;
    /* n32 自增 */
    ix = ix0;
    /* 设置 ix 为 ix0 */
    i__1 = i2;
    /* 循环次数为 i2 */
    i__3 = inc;
    /* 步长为 inc */
    for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
        /* 循环 i__ */
        ip = ipiv[ix];
        /* 获取 ipiv[ix] 的值 */
        if (ip != i__) {
            /* 如果 ip 不等于 i__ */
            i__2 = *n;
            /* 循环次数为 n */
            for (k = n32; k <= i__2; ++k) {
                /* 循环 k */
                i__4 = i__ + k * a_dim1;
                /* 计算数组下标 */
                temp.r = a[i__4].r, temp.i = a[i__4].i;
                /* 临时变量保存 a[i__4] 的值 */
                i__4 = i__ + k * a_dim1;
                i__5 = ip + k * a_dim1;
                a[i__4].r = a[i__5].r, a[i__4].i = a[i__5].i;
                /* 交换 a[i__4] 和 a[i__5] 的值 */
                i__4 = ip + k * a_dim1;
                a[i__4].r = temp.r, a[i__4].i = temp.i;
                /* 将临时变量的值赋给 a[i__4] */
/* L40: */
                /* L40 标签 */
            }
        }
        ix += *incx;
/* L50: */
        /* L50 标签 */
    }
}
/* 如果 n32 不等于 n 的情况下的结束 */

return 0;
/* 返回 0 */

/*     End of ZLASWP */
/* ZLASWP 的结束 */

} /* zlaswp_ */
/* zlaswp_ 子程序的结束 */

/* Subroutine */ int zlatrd_(char *uplo, integer *n, integer *nb,
    doublecomplex *a, integer *lda, doublereal *e, doublecomplex *tau,
    doublecomplex *w, integer *ldw)
{
    /* System generated locals */
    /* 系统生成的本地变量 */
    integer a_dim1, a_offset, w_dim1, w_offset, i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Local variables */
    /* 局部变量 */
    static integer i__, iw;
    /* 静态整型变量 i__, iw */
    static doublecomplex alpha;
    /* 静态复数变量 alpha */
    extern logical lsame_(char *, char *);
    /* 外部函数 lsame_ 的声明 */
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *);
    /* 外部子程序 zscal_ 的声明 */
    extern /* Double Complex */ VOID zdotc_(doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    /* 外部复数函数 zdotc_ 的声明 */
    外部声明五个复杂数操作的子程序：zgemv_, zhemv_, zaxpy_, zlarfg_, zlacgv_

    extern /* Subroutine */ int zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *)
        # zgemv_ 子程序原型：
        #   - char *: 指定操作的特性
        #   - integer *: 各种整型参数
        #   - doublecomplex *: 复数数组和向量
        #   - 返回值类型为 int，表示子程序调用状态

    zhemv_(char *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *)
        # zhemv_ 子程序原型：
        #   - char *: 指定操作的特性
        #   - integer *: 各种整型参数
        #   - doublecomplex *: 复数数组和向量

    zaxpy_(integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *)
        # zaxpy_ 子程序原型：
        #   - integer *: 各种整型参数
        #   - doublecomplex *: 复数数组和向量

    zlarfg_(integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *)
        # zlarfg_ 子程序原型：
        #   - integer *: 各种整型参数
        #   - doublecomplex *: 复数数组和向量

    zlacgv_(integer *, doublecomplex *, integer *)
        # zlacgv_ 子程序原型：
        #   - integer *: 各种整型参数
        #   - doublecomplex *: 复数数组和向量
"""
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
    Hermitian tridiagonal form by a unitary similarity
    transformation Q' * A * Q, and returns the matrices V and W which are
    needed to apply the transformation to the unreduced part of A.

    If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
    matrix, of which the upper triangle is supplied;
    if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
    matrix, of which the lower triangle is supplied.

    This is an auxiliary routine called by ZHETRD.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular

    N       (input) INTEGER
            The order of the matrix A.

    NB      (input) INTEGER
            The number of rows and columns to be reduced.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the unitary matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  unitary matrix Q as a
              product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    E       (output) DOUBLE PRECISION array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
"""
    TAU     (output) COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.

TAU 是一个输出参数，是长度为 N-1 的复数数组，存储着初等反射器的标量因子。具体存储位置取决于 UPLO 参数的值。若 UPLO = 'U'，则存储在 TAU(n-nb:n-1)；若 UPLO = 'L'，则存储在 TAU(1:nb)。详细信息请参见进一步的详细说明部分。


    W       (output) COMPLEX*16 array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.

W 是一个输出参数，是一个 n 行 nb 列的复数矩阵，用于更新矩阵 A 的未降维部分。


    LDW     (input) INTEGER
            The leading dimension of the array W. LDW >= max(1,N).

LDW 是一个输入参数，是数组 W 的主导维度（leading dimension）。LDW 必须大于等于 max(1,N)，其中 N 是矩阵的维度。


    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n) H(n-1) . . . H(n-nb+1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
    and tau in TAU(i-1).

进一步详细说明部分，根据 UPLO 的值不同，矩阵 Q 被表示为一系列初等反射器的乘积。若 UPLO = 'U'，则为 H(n) H(n-1) ... H(n-nb+1)；每个 H(i) 的形式为单位矩阵减去 tau * v * v'，其中 tau 是复数标量，v 是复向量。v 的定义取决于 i 的位置。最终 v(1:i-1) 存储在 A(1:i-1,i) 中，tau 存储在 TAU(i-1) 中。


    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
    and tau in TAU(i).

若 UPLO = 'L'，矩阵 Q 被表示为一系列初等反射器的乘积 H(1) H(2) ... H(nb)。每个 H(i) 的形式与上述类似，但 v 的定义不同。具体而言，v(1:i) = 0，v(i+1) = 1，v(i+1:n) 存储在 A(i+1:n,i) 中，tau 存储在 TAU(i) 中。


    The elements of the vectors v together form the n-by-nb matrix V
    which is needed, with W, to apply the transformation to the unreduced
    part of the matrix, using a Hermitian rank-2k update of the form:
    A := A - V*W' - W*V'.

向量 v 的元素共同形成了一个 n 行 nb 列的矩阵 V，与矩阵 W 一起，用于对矩阵的未降维部分进行转换。这种转换采用了 Hermitian rank-2k 更新的形式：A := A - V*W' - W*V'。


    The contents of A on exit are illustrated by the following examples
    with n = 5 and nb = 2:

    if UPLO = 'U':                       if UPLO = 'L':

      (  a   a   a   v4  v5 )              (  d                  )
      (      a   a   v4  v5 )              (  1   d              )
      (          a   1   v5 )              (  v1  1   a          )
      (              d   1  )              (  v1  v2  a   a      )
      (                  d  )              (  v1  v2  a   a   a  )

退出时 A 的内容通过以下示例说明，其中 n = 5，nb = 2：
- 若 UPLO = 'U'，A 的结构如左侧所示。
- 若 UPLO = 'L'，A 的结构如右侧所示。其中 d 表示降维后的对角元素，a 表示未改变的原始矩阵元素，vi 表示定义 H(i) 的向量元素。


       Quick return if possible

如果可能的话，快速返回。
    /* 调整参数 */
    a_dim1 = *lda;           /* 获取参数 lda 的值 */
    a_offset = 1 + a_dim1;   /* 计算偏移量 */
    a -= a_offset;           /* 调整数组 a 的指针 */
    --e;                     /* 调整数组 e 的指针 */
    --tau;                   /* 调整数组 tau 的指针 */
    w_dim1 = *ldw;           /* 获取参数 ldw 的值 */
    w_offset = 1 + w_dim1;   /* 计算偏移量 */
    w -= w_offset;           /* 调整数组 w 的指针 */

    /* 函数体 */
    if (*n <= 0) {           /* 如果 n 小于等于 0，则返回 0 */
        return 0;
    }

    if (lsame_(uplo, "U")) {

        /* 减少上三角部分最后的 NB 列 */

        i__1 = *n - *nb + 1;
        for (i__ = *n; i__ >= i__1; --i__) {
            iw = i__ - *n + *nb;
            if (i__ < *n) {

                /* 更新 A(1:i,i) */

                i__2 = i__ + i__ * a_dim1;
                i__3 = i__ + i__ * a_dim1;
                d__1 = a[i__3].r;
                a[i__2].r = d__1, a[i__2].i = 0.;
                i__2 = *n - i__;
                zlacgv_(&i__2, &w[i__ + (iw + 1) * w_dim1], ldw);
                i__2 = *n - i__;
                z__1.r = -1., z__1.i = -0.;
                zgemv_("No transpose", &i__, &i__2, &z__1, &a[(i__ + 1) *
                    a_dim1 + 1], lda, &w[i__ + (iw + 1) * w_dim1], ldw, &
                    c_b57, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                zlacgv_(&i__2, &w[i__ + (iw + 1) * w_dim1], ldw);
                i__2 = *n - i__;
                zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                i__2 = *n - i__;
                z__1.r = -1., z__1.i = -0.;
                zgemv_("No transpose", &i__, &i__2, &z__1, &w[(iw + 1) *
                    w_dim1 + 1], ldw, &a[i__ + (i__ + 1) * a_dim1], lda, &
                    c_b57, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                i__2 = i__ + i__ * a_dim1;
                i__3 = i__ + i__ * a_dim1;
                d__1 = a[i__3].r;
                a[i__2].r = d__1, a[i__2].i = 0.;
            }
            if (i__ > 1) {

                /*
                    生成用于消除 A(1:i-2,i) 的初等反射器 H(i)
                */

                i__2 = i__ - 1 + i__ * a_dim1;
                alpha.r = a[i__2].r, alpha.i = a[i__2].i;
                i__2 = i__ - 1;
                zlarfg_(&i__2, &alpha, &a[i__ * a_dim1 + 1], &c__1, &tau[i__
                    - 1]);
                i__2 = i__ - 1;
                e[i__2] = alpha.r;
                i__2 = i__ - 1 + i__ * a_dim1;
                a[i__2].r = 1., a[i__2].i = 0.;
/*              Compute W(1:i-1,i) */

/* 计算 W(1:i-1,i) */

        i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

        zhemv_("Upper", &i__2, &c_b57, &a[a_offset], lda, &a[i__ *
            a_dim1 + 1], &c__1, &c_b56, &w[iw * w_dim1 + 1], &
            c__1);
/* 调用 zhemv 函数，计算复数 Hermitian 矩阵向量乘法：
   上三角部分，矩阵大小为 i__2 x i__2，乘法系数为 c_b57，矩阵 A 和向量 a[i__ * a_dim1 + 1] */

        if (i__ < *n) {
/* 如果 i__ 小于 n */

            i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

            i__3 = *n - i__;
/* 设置一个局部变量 i__3 为 n 减去 i__ */

            zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &w[(
                iw + 1) * w_dim1 + 1], ldw, &a[i__ * a_dim1 + 1],
                &c__1, &c_b56, &w[i__ + 1 + iw * w_dim1], &c__1);
/* 调用 zgemv 函数，计算复数矩阵-向量乘法：
   共轭转置形式，矩阵大小为 i__2 x i__3，乘法系数为 c_b57，矩阵 w[(iw + 1) * w_dim1 + 1] 和向量 a[i__ * a_dim1 + 1] */

            i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

            i__3 = *n - i__;
/* 设置一个局部变量 i__3 为 n 减去 i__ */

            z__1.r = -1., z__1.i = -0.;
/* 设置一个复数变量 z__1 为 -1.0 */

            zgemv_("No transpose", &i__2, &i__3, &z__1, &a[(i__ + 1) *
                 a_dim1 + 1], lda, &w[i__ + 1 + iw * w_dim1], &
                c__1, &c_b57, &w[iw * w_dim1 + 1], &c__1);
/* 调用 zgemv 函数，计算复数矩阵-向量乘法：
   不转置，矩阵大小为 i__2 x i__3，乘法系数为 z__1，矩阵 a[(i__ + 1) * a_dim1 + 1] 和向量 w[i__ + 1 + iw * w_dim1] */

            i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

            i__3 = *n - i__;
/* 设置一个局部变量 i__3 为 n 减去 i__ */

            zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[(
                i__ + 1) * a_dim1 + 1], lda, &a[i__ * a_dim1 + 1],
                 &c__1, &c_b56, &w[i__ + 1 + iw * w_dim1], &c__1);
/* 调用 zgemv 函数，计算复数矩阵-向量乘法：
   共轭转置形式，矩阵大小为 i__2 x i__3，乘法系数为 c_b57，矩阵 a[(i__ + 1) * a_dim1 + 1] 和向量 a[i__ * a_dim1 + 1] */

            i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

            i__3 = *n - i__;
/* 设置一个局部变量 i__3 为 n 减去 i__ */

            z__1.r = -1., z__1.i = -0.;
/* 设置一个复数变量 z__1 为 -1.0 */

            zgemv_("No transpose", &i__2, &i__3, &z__1, &w[(iw + 1) *
                w_dim1 + 1], ldw, &w[i__ + 1 + iw * w_dim1], &
                c__1, &c_b57, &w[iw * w_dim1 + 1], &c__1);
/* 调用 zgemv 函数，计算复数矩阵-向量乘法：
   不转置，矩阵大小为 i__2 x i__3，乘法系数为 z__1，矩阵 w[(iw + 1) * w_dim1 + 1] 和向量 w[i__ + 1 + iw * w_dim1] */
        }

        i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

        zscal_(&i__2, &tau[i__ - 1], &w[iw * w_dim1 + 1], &c__1);
/* 调用 zscal 函数，对向量 w[iw * w_dim1 + 1] 进行复数数乘：乘法系数为 tau[i__ - 1] */

        z__3.r = -.5, z__3.i = -0.;
/* 设置一个复数变量 z__3 为 -0.5 */

        i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

        z__2.r = z__3.r * tau[i__2].r - z__3.i * tau[i__2].i, z__2.i =
             z__3.r * tau[i__2].i + z__3.i * tau[i__2].r;
/* 设置一个复数变量 z__2 为 z__3 与 tau[i__2] 的乘积 */

        i__3 = i__ - 1;
/* 设置一个局部变量 i__3 为 i__ 减去 1 */

        zdotc_(&z__4, &i__3, &w[iw * w_dim1 + 1], &c__1, &a[i__ *
            a_dim1 + 1], &c__1);
/* 调用 zdotc 函数，计算复数向量内积：向量 w[iw * w_dim1 + 1] 和向量 a[i__ * a_dim1 + 1] */

        z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r *
            z__4.i + z__2.i * z__4.r;
/* 设置一个复数变量 z__1 为 z__2 与 z__4 的乘积 */

        alpha.r = z__1.r, alpha.i = z__1.i;
/* 设置 alpha 为 z__1 */

        i__2 = i__ - 1;
/* 设置一个局部变量 i__2 为 i__ 减去 1 */

        zaxpy_(&i__2, &alpha, &a[i__ * a_dim1 + 1], &c__1, &w[iw *
            w_dim1 + 1], &c__1);
/* 调用 zaxpy 函数，进行复数向量加法：向量 a[i__ * a_dim1 + 1] 与乘法系数 alpha */

        }

/* L10: */
/* 继续下一个循环 */
    }
    } else {

/*        Reduce first NB columns of lower triangle */

/* 减少下三角形的前 NB 列 */

    i__1 = *nb;
/* 设置一个局部变量 i__1 为 nb */

    for (i__ = 1; i__ <= i__1; ++i__) {
/* 开始一个循环，从 i__ 为 1 到 i__1（即 nb） */
/*           Update A(i:n,i) */

/* 计算数组中的索引位置 */
i__2 = i__ + i__ * a_dim1;
i__3 = i__ + i__ * a_dim1;
/* 获取复数的实部 */
d__1 = a[i__3].r;
/* 更新矩阵元素，将实部赋值给A(i,n)的实部，虚部设为0 */
a[i__2].r = d__1, a[i__2].i = 0.;
/* 对W进行共轭变换，W的第i行的前i-1列 */
i__2 = i__ - 1;
zlacgv_(&i__2, &w[i__ + w_dim1], ldw);
/* 计算矩阵乘法结果 */
i__2 = *n - i__ + 1;
i__3 = i__ - 1;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__3, &z__1, &a[i__ + a_dim1], lda,
     &w[i__ + w_dim1], ldw, &c_b57, &a[i__ + i__ * a_dim1], &
    c__1);
/* 再次对W进行共轭变换，W的第i行的前i-1列 */
i__2 = i__ - 1;
zlacgv_(&i__2, &w[i__ + w_dim1], ldw);
/* 对A进行共轭变换，A的第i行的前i-1列 */
i__2 = i__ - 1;
zlacgv_(&i__2, &a[i__ + a_dim1], lda);
/* 计算矩阵乘法结果 */
i__2 = *n - i__ + 1;
i__3 = i__ - 1;
z__1.r = -1., z__1.i = -0.;
zgemv_("No transpose", &i__2, &i__3, &z__1, &w[i__ + w_dim1], ldw,
     &a[i__ + a_dim1], lda, &c_b57, &a[i__ + i__ * a_dim1], &
    c__1);
/* 再次对A进行共轭变换，A的第i行的前i-1列 */
i__2 = i__ - 1;
zlacgv_(&i__2, &a[i__ + a_dim1], lda);
/* 更新矩阵元素，将实部赋值给A(i,n)的实部，虚部设为0 */
i__2 = i__ + i__ * a_dim1;
i__3 = i__ + i__ * a_dim1;
d__1 = a[i__3].r;
a[i__2].r = d__1, a[i__2].i = 0.;
/* 如果i小于n，则执行以下操作 */

/*
        Generate elementary reflector H(i) to annihilate
        A(i+2:n,i)
*/

/* 计算数组中的索引位置 */
i__2 = i__ + 1 + i__ * a_dim1;
/* 复制A(i+1, i)的值到alpha中 */
alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 计算数组中的索引位置 */
i__2 = *n - i__;
/* 计算最小值 */
/* 计算A(i+2,n)和n的最小值 */
i__3 = i__ + 2;
/* 生成一个Householder变换H(i)，使得A(i+2:n,i)为零 */
zlarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1,
     &tau[i__]);
/* 复制alpha.r到e[i__]中 */
i__2 = i__;
e[i__2] = alpha.r;
/* 设置A(i+1,i)的值为1 */
i__2 = i__ + 1 + i__ * a_dim1;
a[i__2].r = 1., a[i__2].i = 0.;
/*              Compute W(i+1:n,i) */
/* 计算 W(i+1:n,i) */

        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        zhemv_("Lower", &i__2, &c_b57, &a[i__ + 1 + (i__ + 1) *
            a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 Hermitian 矩阵向量乘法计算 W(i+1:n,i)，其中 'Lower' 指示矩阵 A 是下三角形式 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        i__3 = i__ - 1;
/* 计算 1 到 i-1 的范围 */
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &w[i__ +
            1 + w_dim1], ldw, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ * w_dim1 + 1], &c__1);
/* 使用复数矩阵向量乘法计算 W(i:n,i) 的共轭转置乘积，其中 'Conjugate transpose' 表示对 A 的转置操作 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        i__3 = i__ - 1;
/* 计算 1 到 i-1 的范围 */
        z__1.r = -1., z__1.i = -0.;
/* 设置复数乘法的系数 */
        zgemv_("No transpose", &i__2, &i__3, &z__1, &a[i__ + 1 +
            a_dim1], lda, &w[i__ * w_dim1 + 1], &c__1, &c_b57, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用复数矩阵向量乘法计算 W(i+1:n,i) 的乘积，并应用负数系数 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        i__3 = i__ - 1;
/* 计算 1 到 i-1 的范围 */
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ * w_dim1 + 1], &c__1);
/* 使用复数矩阵向量乘法计算 A(i+1:n,i) 的共轭转置乘积 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        i__3 = i__ - 1;
/* 计算 1 到 i-1 的范围 */
        z__1.r = -1., z__1.i = -0.;
/* 设置复数乘法的系数 */
        zgemv_("No transpose", &i__2, &i__3, &z__1, &w[i__ + 1 +
            w_dim1], ldw, &w[i__ * w_dim1 + 1], &c__1, &c_b57, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用复数矩阵向量乘法计算 W(i+1:n,i) 的乘积，并应用负数系数 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        zscal_(&i__2, &tau[i__], &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 对 W(i+1:n,i) 中的元素进行标量乘法 */
        z__3.r = -.5, z__3.i = -0.;
/* 设置复数的标量乘法系数 */
        i__2 = i__;
        z__2.r = z__3.r * tau[i__2].r - z__3.i * tau[i__2].i, z__2.i =
             z__3.r * tau[i__2].i + z__3.i * tau[i__2].r;
/* 计算复数的标量乘法 */
        i__3 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        zdotc_(&z__4, &i__3, &w[i__ + 1 + i__ * w_dim1], &c__1, &a[
            i__ + 1 + i__ * a_dim1], &c__1);
/* 计算两个复数向量的内积 */
        z__1.r = z__2.r * z__4.r - z__2.i * z__4.i, z__1.i = z__2.r *
            z__4.i + z__2.i * z__4.r;
/* 计算复数的乘积 */
        alpha.r = z__1.r, alpha.i = z__1.i;
/* 将计算结果赋值给 alpha 变量 */
        i__2 = *n - i__;
/* 计算 i+1 到 n 的范围 */
        zaxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 计算复数向量的线性组合 */
        }

/* L20: */
/* L20 标签：循环结束点 */
    }
/* 主循环结束 */

    }

    return 0;

/*     End of ZLATRD */
/* ZLATRD 结束 */

} /* zlatrd_ */
/* zlatrd_ 子程序结束 */

/* Subroutine */ int zlatrs_(char *uplo, char *trans, char *diag, char *
    normin, integer *n, doublecomplex *a, integer *lda, doublecomplex *x,
    doublereal *scale, doublereal *cnorm, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Local variables */
    static integer i__, j;
    static doublereal xj, rec, tjj;
    static integer jinc;
    static doublereal xbnd;
    static integer imax;
    static doublereal tmax;
    static doublecomplex tjjs;
    static doublereal xmax, grow;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    extern logical lsame_(char *, char *);
    static doublereal tscal;
    static doublecomplex uscal;
    static integer jlast;
    static doublecomplex csumj;


以上是给定代码块的完整注释，按照要求将每行代码进行了逐行解释和注释说明。
    # 外部函数声明，计算复数向量的内积（共轭计算）
    extern /* Double Complex */ VOID zdotc_(doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    # 静态变量声明，表示矩阵是否为上三角形式
    static logical upper;
    # 外部函数声明，计算复数向量的内积（不共轭计算）
    extern /* Double Complex */ VOID zdotu_(doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    # 外部函数声明，复数向量的线性组合
    extern /* Subroutine */ int zaxpy_(integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    # 外部函数声明，复数矩阵的向量解
    extern /* Subroutine */ int ztrsv_(
        char *, char *, char *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    # 外部函数声明，计算两个实数的较小值的参数
    extern /* Subroutine */ int dlabad_(
        doublereal *, doublereal *);

    # 外部函数声明，返回实数数组中的最大绝对值元素的索引
    extern integer idamax_(integer *, doublereal *, integer *);
    # 外部函数声明，复数向量的缩放
    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 外部函数声明，复数向量的缩放
    extern /* Subroutine */ int zdscal_(
        integer *, doublereal *, doublecomplex *, integer *);
    # 静态变量声明，用于存储一个大的浮点数值
    static doublereal bignum;
    # 外部函数声明，返回复数数组中的最大绝对值元素的索引
    extern integer izamax_(integer *, doublecomplex *, integer *);
    # 外部函数声明，复数的除法运算
    extern /* Double Complex */ VOID zladiv_(doublecomplex *, doublecomplex *,
         doublecomplex *);
    # 静态变量声明，表示矩阵是否不是传递的形式
    static logical notran;
    # 静态变量声明，存储用于矩阵运算的整数值
    static integer jfirst;
    # 外部函数声明，返回复数数组的绝对和
    extern doublereal dzasum_(integer *, doublecomplex *, integer *);
    # 静态变量声明，表示矩阵是否是单位矩阵
    static doublereal smlnum;
    # 静态变量声明，表示矩阵是否不是单位矩阵
    static logical nounit;
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLATRS solves one of the triangular systems

       A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,

    with scaling to prevent overflow.  Here A is an upper or lower
    triangular matrix, A**T denotes the transpose of A, A**H denotes the
    conjugate transpose of A, x and b are n-element vectors, and s is a
    scaling factor, usually less than or equal to 1, chosen so that the
    components of x will be less than the overflow threshold.  If the
    unscaled problem will not cause overflow, the Level 2 BLAS routine
    ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
    then s is set to 0 and a non-trivial solution to A*x = 0 is returned.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    TRANS   (input) CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b     (No transpose)
            = 'T':  Solve A**T * x = s*b  (Transpose)
            = 'C':  Solve A**H * x = s*b  (Conjugate transpose)

    DIAG    (input) CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular

    NORMIN  (input) CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input) COMPLEX*16 array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max (1,N).

    X       (input/output) COMPLEX*16 array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
*/
    SCALE   (output) DOUBLE PRECISION
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            如果 SCALE = 0，表示矩阵 A 是奇异的或者缩放很差，向量 x 是方程 A*x = 0 的精确或近似解。

    CNORM   (input or output) DOUBLE PRECISION array, dimension (N)

            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            如果 NORMIN = 'Y'，CNORM 是一个输入参数，CNORM(j) 包含矩阵 A 第 j 列的非对角线部分的范数。
            如果 TRANS = 'N'，CNORM(j) 必须大于或等于无穷范数；如果 TRANS = 'T' 或 'C'，CNORM(j) 必须大于或等于1范数。

            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            如果 NORMIN = 'N'，CNORM 是一个输出参数，CNORM(j) 返回矩阵 A 第 j 列的非对角线部分的1范数。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -k, the k-th argument had an illegal value
            = 0:  成功退出
            < 0:  如果 INFO = -k，表示第 k 个参数有非法值

    Further Details
    ======= =======

    A rough bound on x is computed; if that is less than overflow, ZTRSV
    is called, otherwise, specific code is used which checks for possible
    overflow or divide-by-zero at every operation.
    计算 x 的粗略上界；如果小于溢出值，调用 ZTRSV；否则使用特定代码，在每次操作时检查可能的溢出或除零情况。

    A columnwise scheme is used for solving A*x = b.  The basic algorithm
    if A is lower triangular is

         x[1:n] := b[1:n]
         for j = 1, ..., n
              x(j) := x(j) / A(j,j)
              x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
         end

    Define bounds on the components of x after j iterations of the loop:
       M(j) = bound on x[1:j]
       G(j) = bound on x[j+1:n]
    Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.

    Then for iteration j+1 we have
       M(j+1) <= G(j) / | A(j+1,j+1) |
       G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
              <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

    where CNORM(j+1) is greater than or equal to the infinity-norm of
    column j+1 of A, not counting the diagonal.  Hence

       G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                    1<=i<=j
    and

       |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                     1<=i< j

    Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTRSV if the
    reciprocal of the largest M(j), j=1,..,n, is larger than
    max(underflow, 1/overflow).
    由于 |x(j)| <= M(j)，如果 M(j) 的最大值的倒数大于 max(underflow, 1/overflow)，我们使用 Level 2 BLAS 程序 ZTRSV。

    The bound on x(j) is also used to determine when a step in the
    columnwise method can be performed without fear of overflow.  If
    the computed bound is greater than a large constant, x is scaled to
    prevent overflow, but if the bound overflows, x is set to 0, x(j) to
    1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
    对 x(j) 的界限也用于确定何时可以在不担心溢出的情况下执行列式方法的一步。如果计算的界限大于一个大常数，将对 x 进行缩放以防止溢出；但如果界限溢出，将 x 设置为 0，x(j) 设置为 1，并将 scale 设置为 0，找到 A*x = 0 的非平凡解。

    Similarly, a row-wise scheme is used to solve A**T *x = b  or
    类似地，使用行式方法解决 A**T *x = b 或者
    A**H *x = b.  The basic algorithm for A upper triangular is

# 计算 A**H *x = b 的线性方程组，其中 A 是上三角矩阵


         for j = 1, ..., n
              x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
         end

# 对于 j = 1 到 n 的每个 j，执行以下操作：
#   x(j) 的计算公式为 ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)，其中 A(j,j) 是矩阵 A 的第 j 行第 j 列元素


    We simultaneously compute two bounds
         G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
         M(j) = bound on x(i), 1<=i<=j

# 同时计算两个界限：
#   G(j) 是 ( b(i) - A[1:i-1,i]' * x[1:i-1] ) 的界限，其中 1 <= i <= j
#   M(j) 是 x(i) 的界限，其中 1 <= i <= j


    The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
    add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.

# 初始值为 G(0) = 0，M(0) = max{b(i), i=1,..,n}，并且对于 j >= 1，添加约束条件 G(j) >= G(j-1) 和 M(j) >= M(j-1)。


    Then the bound on x(j) is

# 因此，对于 x(j) 的界限为：


         M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

# M(j) 满足 M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) | 的条件，其中 CNORM(j) 是某种条件数。


              <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                        1<=i<=j

# 进一步可以得出 M(j) <= M(0) * ∏(1 <= i <= j) ( ( 1 + CNORM(i) ) / | A(i,i) | ) 的界限。


    and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater
    than max(underflow, 1/overflow).

# 如果 1/M(n) 和 1/G(n) 都大于 max(underflow, 1/overflow)，则可以安全地调用 ZTRSV 函数。


    =====================================================================

# 分隔线，标识文档的结尾或者不同部分的开始。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;
    --cnorm;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    notran = lsame_(trans, "N");
    nounit = lsame_(diag, "N");

    /* Test the input parameters. */

    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T") && !
        lsame_(trans, "C")) {
        *info = -2;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -3;
    } else if (! lsame_(normin, "Y") && ! lsame_(normin,
         "N")) {
        *info = -4;
    } else if (*n < 0) {
        *info = -5;
    } else if (*lda < max(1,*n)) {
        *info = -7;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZLATRS", &i__1);
        return 0;
    }

    /* Quick return if possible */

    if (*n == 0) {
        return 0;
    }

    /* Determine machine dependent parameters to control overflow. */

    smlnum = SAFEMINIMUM;
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum /= PRECISION;
    bignum = 1. / smlnum;
    *scale = 1.;

    if (lsame_(normin, "N")) {

        /* Compute the 1-norm of each column, not including the diagonal. */

        if (upper) {

            /* A is upper triangular. */

            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j - 1;
                cnorm[j] = dzasum_(&i__2, &a[j * a_dim1 + 1], &c__1);
                /* L10: */
            }
        } else {

            /* A is lower triangular. */

            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                cnorm[j] = dzasum_(&i__2, &a[j + 1 + j * a_dim1], &c__1);
                /* L20: */
            }
            cnorm[*n] = 0.;
        }
    }

    /*
       Scale the column norms by TSCAL if the maximum element in CNORM is
       greater than BIGNUM/2.
    */

    imax = idamax_(n, &cnorm[1], &c__1);
    tmax = cnorm[imax];
    if (tmax <= bignum * .5) {
        tscal = 1.;
    } else {
        tscal = .5 / (smlnum * tmax);
        dscal_(n, &tscal, &cnorm[1], &c__1);
    }

    /*
       Compute a bound on the computed solution vector to see if the
       Level 2 BLAS routine ZTRSV can be used.
    */

    xmax = 0.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        /* Computing MAX */
        i__2 = j;
        d__3 = xmax, d__4 = (d__1 = x[i__2].r / 2., abs(d__1)) + (d__2 =
            d_imag(&x[j]) / 2., abs(d__2));
        xmax = max(d__3,d__4);
        /* L30: */
    }
    xbnd = xmax;

    if (notran) {

        /* Compute the growth in A * x = b. */

        if (upper) {
            jfirst = *n;
            jlast = 1;
            jinc = -1;
        } else {
            jfirst = 1;
            jlast = *n;
            jinc = 1;
        }

        if (tscal != 1.) {
            grow = 0.;
            goto L60;
        }

        if (nounit) {

            /*
               A is non-unit triangular.

               Compute GROW = 1/G(j) and XBND = 1/M(j).
               Initially, G(0) = max{x(i), i=1,...,n}.
            */
        grow = .5 / max(xbnd,smlnum);
        xbnd = grow;
        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            goto L60;
        }

        i__3 = j + j * a_dim1;
        tjjs.r = a[i__3].r, tjjs.i = a[i__3].i;
        tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs), abs(
            d__2));

        if (tjj >= smlnum) {

/*
                   M(j) = G(j-1) / abs(A(j,j))

   Computing MIN
*/
            d__1 = xbnd, d__2 = min(1.,tjj) * grow;
            xbnd = min(d__1,d__2);
        } else {

/*                 M(j) could overflow, set XBND to 0. */

            xbnd = 0.;
        }

        if (tjj + cnorm[j] >= smlnum) {

/*                 G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) ) */

            grow *= tjj / (tjj + cnorm[j]);
        } else {

/*                 G(j) could overflow, set GROW to 0. */

            grow = 0.;
        }
/* L40: */
        }
        grow = xbnd;
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
        d__1 = 1., d__2 = .5 / max(xbnd,smlnum);
        grow = min(d__1,d__2);
        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            goto L60;
        }

/*              G(j) = G(j-1)*( 1 + CNORM(j) ) */

        grow *= 1. / (cnorm[j] + 1.);
/* L50: */
        }
    }
L60:

    ;
    } else {

/*        Compute the growth in A**T * x = b  or  A**H * x = b. */

    if (upper) {
        jfirst = 1;
        jlast = *n;
        jinc = 1;
    } else {
        jfirst = *n;
        jlast = 1;
        jinc = -1;
    }

    if (tscal != 1.) {
        grow = 0.;
        goto L90;
    }

    if (nounit) {

/*
             A is non-unit triangular.

             Compute GROW = 1/G(j) and XBND = 1/M(j).
             Initially, M(0) = max{x(i), i=1,...,n}.
*/

        grow = .5 / max(xbnd,smlnum);
        xbnd = grow;
        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            goto L90;
        }

/*              G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) ) */

        xj = cnorm[j] + 1.;
/* Computing MIN */
        d__1 = grow, d__2 = xbnd / xj;
        grow = min(d__1,d__2);

        i__3 = j + j * a_dim1;
        tjjs.r = a[i__3].r, tjjs.i = a[i__3].i;
        tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs), abs(
            d__2));

        if (tjj >= smlnum) {
/*                 M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j)) */
/* 计算增长因子 M(j)，如果 A(j,j) 的绝对值大于 CNORM(j)，更新 xbnd */
            if (xj > tjj) {
/* 如果 A(j,j) 的绝对值大于 CNORM(j)，更新 xbnd */
            xbnd *= tjj / xj;
            }
        } else {

/*                 M(j) could overflow, set XBND to 0. */
/* A(j,j) 的绝对值可能导致溢出，将 XBND 设为 0 */
            xbnd = 0.;
        }
/* L70: */
        }
        grow = min(grow,xbnd);
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
/* A 是单位上三角矩阵，计算 GROW = 1/G(j)，其中 G(0) = max{x(i), i=1,...,n} */
        d__1 = 1., d__2 = .5 / max(xbnd,smlnum);
        grow = min(d__1,d__2);
        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */
/* 如果增长因子太小，则退出循环 */
        if (grow <= smlnum) {
            goto L90;
        }

/*              G(j) = ( 1 + CNORM(j) )*G(j-1) */
/* 计算 G(j) = ( 1 + CNORM(j) )*G(j-1) */
        xj = cnorm[j] + 1.;
        grow /= xj;
/* L80: */
        }
    }
L90:
    ;
    }

    if (grow * tscal > smlnum) {

/*
          Use the Level 2 BLAS solve if the reciprocal of the bound on
          elements of X is not too small.
*/

/* 如果 X 元素的界限的倒数不太小，使用 Level 2 BLAS 解法 */
    ztrsv_(uplo, trans, diag, n, &a[a_offset], lda, &x[1], &c__1);
    } else {

/*        Use a Level 1 BLAS solve, scaling intermediate results. */

/* 使用 Level 1 BLAS 解法，对中间结果进行缩放 */
    if (xmax > bignum * .5) {

/*
             Scale X so that its components are less than or equal to
             BIGNUM in absolute value.
*/

/* 缩放 X，使得其各分量的绝对值不超过 BIGNUM */
        *scale = bignum * .5 / xmax;
        zdscal_(n, scale, &x[1], &c__1);
        xmax = bignum;
    } else {
        xmax *= 2.;
    }

    if (notran) {

/*           Solve A * x = b */

/* 解方程 A * x = b */
        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Compute x(j) = b(j) / A(j,j), scaling x if necessary. */

/* 计算 x(j) = b(j) / A(j,j)，必要时缩放 x */
        i__3 = j;
        xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j]),
            abs(d__2));
        if (nounit) {
            i__3 = j + j * a_dim1;
            z__1.r = tscal * a[i__3].r, z__1.i = tscal * a[i__3].i;
            tjjs.r = z__1.r, tjjs.i = z__1.i;
        } else {
            tjjs.r = tscal, tjjs.i = 0.;
            if (tscal == 1.) {
            goto L110;
            }
        }
        tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs), abs(
            d__2));
        if (tjj > smlnum) {

/*                    abs(A(j,j)) > SMLNUM: */

            if (tjj < 1.) {
            if (xj > tjj * bignum) {

/*                          Scale x by 1/b(j). */

/* 缩放 x，使得其分量小于或等于 1/b(j) */
                rec = 1. / xj;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
            }
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            i__3 = j;
            xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j])
                , abs(d__2));
        } else if (tjj > 0.) {

/*                    0 < abs(A(j,j)) <= SMLNUM: */

            if (xj > tjj * bignum) {
/*
                         Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
                         to avoid overflow when dividing by A(j,j).
*/
            rec = tjj * bignum / xj;
            if (cnorm[j] > 1.) {

/*
                            Scale by 1/CNORM(j) to avoid overflow when
                            multiplying x(j) times column j.
*/
                rec /= cnorm[j];
            }
            zdscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            i__3 = j;
            xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j])
                , abs(d__2));
        } else {

/*
                      A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                      scale = 0, and compute a solution to A*x = 0.
*/
            i__3 = *n;
            for (i__ = 1; i__ <= i__3; ++i__) {
            i__4 = i__;
            x[i__4].r = 0., x[i__4].i = 0.;
/* L100: */
            }
            i__3 = j;
            x[i__3].r = 1., x[i__3].i = 0.;
            xj = 1.;
            *scale = 0.;
            xmax = 0.;
        }
L110:

/*
                Scale x if necessary to avoid overflow when adding a
                multiple of column j of A.
*/
        if (xj > 1.) {
            rec = 1. / xj;
            if (cnorm[j] > (bignum - xmax) * rec) {

/*                    Scale x by 1/(2*abs(x(j))). */
                rec *= .5;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
            }
        } else if (xj * cnorm[j] > bignum - xmax) {

/*                 Scale x by 1/2. */
            zdscal_(n, &c_b2435, &x[1], &c__1);
            *scale *= .5;
        }

        if (upper) {
            if (j > 1) {

/*
                      Compute the update
                         x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
*/
                i__3 = j - 1;
                i__4 = j;
                z__2.r = -x[i__4].r, z__2.i = -x[i__4].i;
                z__1.r = tscal * z__2.r, z__1.i = tscal * z__2.i;
                zaxpy_(&i__3, &z__1, &a[j * a_dim1 + 1], &c__1, &x[1],
                     &c__1);
                i__3 = j - 1;
                i__ = izamax_(&i__3, &x[1], &c__1);
                i__3 = i__;
                xmax = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(
                    &x[i__]), abs(d__2));
            }
        } else {
            if (j < *n) {

/*
                      Compute the update
                         x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
*/
                i__3 = *n - j;
                i__4 = j;
                z__2.r = -x[i__4].r, z__2.i = -x[i__4].i;
                z__1.r = tscal * z__2.r, z__1.i = tscal * z__2.i;
                zaxpy_(&i__3, &z__1, &a[j + 1 + j * a_dim1], &c__1, &x[j + 1], &c__1);
                i__3 = *n - j;
                i__ = j + izamax_(&i__3, &x[j + 1], &c__1);
                i__3 = i__;
                xmax = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[i__]), abs(d__2));
            }
        }
            i__3 = *n - j;
            i__4 = j;
            z__2.r = -x[i__4].r, z__2.i = -x[i__4].i;
            z__1.r = tscal * z__2.r, z__1.i = tscal * z__2.i;
            zaxpy_(&i__3, &z__1, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);

这段代码实现了向量的线性组合操作，具体为计算 \( x = x + tscal \times (-A(:,j)^T \times x(j+1:)) \)，其中 \( A(:,j) \) 是矩阵 \( A \) 的第 \( j \) 列，\( x \) 是向量，\( tscal \) 是一个标量因子。


            i__3 = *n - j;
            i__ = j + izamax_(&i__3, &x[j + 1], &c__1);
            i__3 = i__;
            xmax = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(
                &x[i__]), abs(d__2));

这段代码计算了 \( x(j+1:) \) 中的最大模，以便后续进行缩放操作。


        }
/* L120: */
        }

这里是一个结束符号，标记着一个循环的结束。


    } else if (lsame_(trans, "T")) {

根据条件判断，如果转置标志 \( trans \) 是 "T"，则执行以下操作。


/*           Solve A**T * x = b */

解释了这部分代码的目标，即解决方程 \( A^T x = b \)。


        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

这段代码开始一个循环，循环变量 \( j \) 的取值范围是从 \( jfirst \) 到 \( jlast \)，步长为 \( jinc \)。


/*
                Compute x(j) = b(j) - sum A(k,j)*x(k).
                                      k<>j
*/

这是一个注释，解释了接下来的代码段计算 \( x(j) = b(j) - \sum_{k \neq j} A(k,j) \times x(k) \)。


        i__3 = j;
        xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j]),
            abs(d__2));

计算向量 \( x \) 的第 \( j \) 个元素的绝对值之和。


        uscal.r = tscal, uscal.i = 0.;
        rec = 1. / max(xmax,1.);

初始化标量 \( uscal \) 和缩放因子 \( rec \)，用于后续操作。


        if (cnorm[j] > (bignum - xj) * rec) {

条件判断，用于检查是否需要对 \( x \) 进行缩放以避免溢出。


            rec *= .5;
            if (nounit) {
            i__3 = j + j * a_dim1;
            z__1.r = tscal * a[i__3].r, z__1.i = tscal * a[i__3]
                .i;
            tjjs.r = z__1.r, tjjs.i = z__1.i;
            } else {
            tjjs.r = tscal, tjjs.i = 0.;
            }

根据条件对缩放因子 \( rec \) 进行调整，并计算 \( A(j,j) \)。


            tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs),
                abs(d__2));

计算复数 \( A(j,j) \) 的模。


            if (tjj > 1.) {

进一步条件判断，确定是否需要对 \( x \) 进行额外的缩放。


            d__1 = 1., d__2 = rec * tjj;
            rec = min(d__1,d__2);

根据 \( A(j,j) \) 的值调整 \( rec \) 的缩放系数。


            zladiv_(&z__1, &uscal, &tjjs);
            uscal.r = z__1.r, uscal.i = z__1.i;
            }
            if (rec < 1.) {
            zdscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
        }

如果满足条件，对向量 \( x \) 进行缩放操作。


        csumj.r = 0., csumj.i = 0.;

初始化复数变量 \( csumj \)。


        if (uscal.r == 1. && uscal.i == 0.) {

条件判断，检查复数缩放因子 \( uscal \) 是否为1。


            if (upper) {
            i__3 = j - 1;
            zdotu_(&z__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                 &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i;
            } else if (j < *n) {
            i__3 = *n - j;
            zdotu_(&z__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i;
            }

根据条件调用不同的复数点积函数进行计算。


        } else {

如果复数缩放因子 \( uscal \) 不为1，则执行以下操作。
/*                 Otherwise, use in-line code for the dot product. */

            if (upper) {
            // 针对上三角部分，计算对角线以下的元素
            i__3 = j - 1;
            for (i__ = 1; i__ <= i__3; ++i__) {
                // 计算复数乘法结果 z__3 = a[i__, j] * uscal
                i__4 = i__ + j * a_dim1;
                z__3.r = a[i__4].r * uscal.r - a[i__4].i *
                    uscal.i, z__3.i = a[i__4].r * uscal.i + a[
                    i__4].i * uscal.r;
                // 计算复数乘法结果 z__2 = z__3 * x[i__]
                i__5 = i__;
                z__2.r = z__3.r * x[i__5].r - z__3.i * x[i__5].i,
                    z__2.i = z__3.r * x[i__5].i + z__3.i * x[
                    i__5].r;
                // 计算复数加法结果 z__1 = csumj + z__2
                z__1.r = csumj.r + z__2.r, z__1.i = csumj.i +
                    z__2.i;
                // 更新 csumj 为 z__1
                csumj.r = z__1.r, csumj.i = z__1.i;
/* L130: */
            }
            } else if (j < *n) {
            // 针对下三角部分，计算对角线以上的元素
            i__3 = *n;
            for (i__ = j + 1; i__ <= i__3; ++i__) {
                // 计算复数乘法结果 z__3 = a[i__, j] * uscal
                i__4 = i__ + j * a_dim1;
                z__3.r = a[i__4].r * uscal.r - a[i__4].i *
                    uscal.i, z__3.i = a[i__4].r * uscal.i + a[
                    i__4].i * uscal.r;
                // 计算复数乘法结果 z__2 = z__3 * x[i__]
                i__5 = i__;
                z__2.r = z__3.r * x[i__5].r - z__3.i * x[i__5].i,
                    z__2.i = z__3.r * x[i__5].i + z__3.i * x[
                    i__5].r;
                // 计算复数加法结果 z__1 = csumj + z__2
                z__1.r = csumj.r + z__2.r, z__1.i = csumj.i +
                    z__2.i;
                // 更新 csumj 为 z__1
                csumj.r = z__1.r, csumj.i = z__1.i;
/* L140: */
            }
            }
        }

        z__1.r = tscal, z__1.i = 0.;
        if (uscal.r == z__1.r && uscal.i == z__1.i) {

/*
                   Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j)
                   was not used to scale the dotproduct.
*/

            i__3 = j;
            i__4 = j;
            // 计算 x(j) = (x(j) - csumj) / A(j,j)
            z__1.r = x[i__4].r - csumj.r, z__1.i = x[i__4].i -
                csumj.i;
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            // 计算 x(j) 的绝对值和虚部的绝对值之和
            i__3 = j;
            xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j])
                , abs(d__2));
            if (nounit) {
            // 如果 A(j,j) 不等于 1，则需要进行额外的乘法操作
            i__3 = j + j * a_dim1;
            z__1.r = tscal * a[i__3].r, z__1.i = tscal * a[i__3]
                .i;
            tjjs.r = z__1.r, tjjs.i = z__1.i;
            } else {
            // 如果 A(j,j) 等于 1，则直接赋值给 tjjs
            tjjs.r = tscal, tjjs.i = 0.;
            if (tscal == 1.) {
                // 如果 tscal 等于 1，则跳转到标签 L160
                goto L160;
            }
            }

/*                    Compute x(j) = x(j) / A(j,j), scaling if necessary. */

            // 计算 A(j,j) 的绝对值和虚部的绝对值之和
            tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs),
                abs(d__2));
            if (tjj > smlnum) {

/*                       abs(A(j,j)) > SMLNUM: */

            if (tjj < 1.) {
                // 如果 abs(A(j,j)) 小于 1，且 x(j) 的绝对值大于 tjj * bignum
                if (xj > tjj * bignum) {
/*                             Scale X by 1/abs(x(j)). */
                rec = 1. / xj;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
                }
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            } else if (tjj > 0.) {

/*                       0 < abs(A(j,j)) <= SMLNUM: */

            if (xj > tjj * bignum) {

/*                          Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM. */

                rec = tjj * bignum / xj;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            } else {

/*
                         A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                         scale = 0 and compute a solution to A**T *x = 0.
*/

            i__3 = *n;
            for (i__ = 1; i__ <= i__3; ++i__) {
                i__4 = i__;
                x[i__4].r = 0., x[i__4].i = 0.;
/* L150: */
            }
            i__3 = j;
            x[i__3].r = 1., x[i__3].i = 0.;
            *scale = 0.;
            xmax = 0.;
            }
L160:
            ;
        } else {

/*
                   Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot
                   product has already been divided by 1/A(j,j).
*/

            i__3 = j;
            zladiv_(&z__2, &x[j], &tjjs);
            z__1.r = z__2.r - csumj.r, z__1.i = z__2.i - csumj.i;
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
        }
/* Computing MAX */
        i__3 = j;
        d__3 = xmax, d__4 = (d__1 = x[i__3].r, abs(d__1)) + (d__2 =
            d_imag(&x[j]), abs(d__2));
        xmax = max(d__3,d__4);
/* L170: */
        }

    } else {

/*           Solve A**H * x = b */

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*
                Compute x(j) = b(j) - sum A(k,j)*x(k).
                                      k<>j
*/

        i__3 = j;
        xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j]),
            abs(d__2));
        uscal.r = tscal, uscal.i = 0.;
        rec = 1. / max(xmax,1.);
        if (cnorm[j] > (bignum - xj) * rec) {

/*                 If x(j) could overflow, scale x by 1/(2*XMAX). */

            rec *= .5;
            if (nounit) {
            d_cnjg(&z__2, &a[j + j * a_dim1]);
            z__1.r = tscal * z__2.r, z__1.i = tscal * z__2.i;
            tjjs.r = z__1.r, tjjs.i = z__1.i;
            } else {
            tjjs.r = tscal, tjjs.i = 0.;
            }
            tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs),
                abs(d__2));
            if (tjj > 1.) {

/*
                         Divide by A(j,j) when scaling x if A(j,j) > 1.

   Computing MIN */
            d__1 = 1., d__2 = rec * tjj;
            rec = min(d__1,d__2);
            zladiv_(&z__1, &uscal, &tjjs);
            uscal.r = z__1.r, uscal.i = z__1.i;


            // 计算用于缩放的值，确保不超过预定义的阈值
            d__1 = 1., d__2 = rec * tjj;
            rec = min(d__1,d__2); // 计算 rec 的值为 min(1, rec * tjj)
            zladiv_(&z__1, &uscal, &tjjs); // 计算 zladiv_(&z__1, &uscal, &tjjs) 并将结果存储在 uscal 中
            uscal.r = z__1.r, uscal.i = z__1.i; // 将 zladiv_ 的结果复制给 uscal


            }
            if (rec < 1.) {
            zdscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
        }


            // 如果 rec 值小于 1，则对向量 x 进行缩放，并更新 scale 和 xmax
            }
            if (rec < 1.) {
            zdscal_(n, &rec, &x[1], &c__1); // 缩放向量 x 的前 n 个元素
            *scale *= rec; // 更新 scale 的值为原值乘以 rec
            xmax *= rec; // 更新 xmax 的值为原值乘以 rec
            }
        }


        csumj.r = 0., csumj.i = 0.;
        if (uscal.r == 1. && uscal.i == 0.) {


        // 初始化 csumj 为复数零
        csumj.r = 0., csumj.i = 0.;
        // 如果 uscal 等于 (1, 0)，表示不需要对 A 中的点积进行缩放
        if (uscal.r == 1. && uscal.i == 0.) {


                   If the scaling needed for A in the dot product is 1,
                   call ZDOTC to perform the dot product.


                   // 如果 A 中点积的缩放为 1，则调用 ZDOTC 执行点积计算。


            if (upper) {
            i__3 = j - 1;
            zdotc_(&z__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                 &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i;
            } else if (j < *n) {
            i__3 = *n - j;
            zdotc_(&z__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i;
            }


            // 如果上三角矩阵标志为真，则使用 ZDOTC 计算点积
            if (upper) {
            // 计算向量 x 与矩阵的前 j-1 列的点积
            i__3 = j - 1;
            zdotc_(&z__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                 &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i; // 将计算结果赋给 csumj
            } else if (j < *n) {
            // 计算向量 x 与矩阵的第 j 列之后的元素的点积
            i__3 = *n - j;
            zdotc_(&z__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);
            csumj.r = z__1.r, csumj.i = z__1.i; // 将计算结果赋给 csumj
            }


        } else {


        // 否则，使用内联代码执行点积计算
        } else {


            if (upper) {
            i__3 = j - 1;
            for (i__ = 1; i__ <= i__3; ++i__) {
                d_cnjg(&z__4, &a[i__ + j * a_dim1]);
                z__3.r = z__4.r * uscal.r - z__4.i * uscal.i,
                    z__3.i = z__4.r * uscal.i + z__4.i *
                    uscal.r;
                i__4 = i__;
                z__2.r = z__3.r * x[i__4].r - z__3.i * x[i__4].i,
                    z__2.i = z__3.r * x[i__4].i + z__3.i * x[
                    i__4].r;
                z__1.r = csumj.r + z__2.r, z__1.i = csumj.i +
                    z__2.i;
                csumj.r = z__1.r, csumj.i = z__1.i;
/* L180: */
            }
            } else if (j < *n) {
            i__3 = *n;
            for (i__ = j + 1; i__ <= i__3; ++i__) {
                d_cnjg(&z__4, &a[i__ + j * a_dim1]);
                z__3.r = z__4.r * uscal.r - z__4.i * uscal.i,
                    z__3.i = z__4.r * uscal.i + z__4.i *
                    uscal.r;
                i__4 = i__;
                z__2.r = z__3.r * x[i__4].r - z__3.i * x[i__4].i,
                    z__2.i = z__3.r * x[i__4].i + z__3.i * x[
                    i__4].r;
                z__1.r = csumj.r + z__2.r, z__1.i = csumj.i +
                    z__2.i;
                csumj.r = z__1.r, csumj.i = z__1.i;
/* L190: */
            }
            }


            // 如果上三角矩阵标志为真，则使用循环计算点积
            if (upper) {
            // 对矩阵的前 j-1 列进行循环
            i__3 = j - 1;
            for (i__ = 1; i__ <= i__3; ++i__) {
                d_cnjg(&z__4, &a[i__ + j * a_dim1]); // 计算 a[i][j] 的共轭
                z__3.r = z__4.r * uscal.r - z__4.i * uscal.i,
                    z__3.i = z__4.r * uscal.i + z__4.i *
                    uscal.r;
                i__4 = i__;
                z__2.r = z__3.r * x[i__4].r - z__3.i * x[i__4].i,
                    z__2.i = z__3.r * x[i__4].i + z__3.i * x[
                    i__4].r;
                z__1.r = csumj.r + z__2.r, z__1.i = csumj.i +
                    z__2.i;
                csumj.r = z__1.r, csumj.i = z__1.i; // 更新 csumj 的值
/* L180: */
            }
            } else if (j < *n) {
            // 对矩阵的第 j 列之后的元素进行循环
            i__3 = *n;
            for (i__ = j + 1; i__ <= i__3; ++i__) {
                d_cnjg(&z__4, &a[i__ + j * a_dim1]); // 计算 a[i][j] 的共轭
                z__3.r = z__4.r * uscal.r - z__4.i * uscal.i,
                    z__3.i = z__4.r * uscal.i + z__4.i *
                    uscal.r;
                i__4 = i__;
                z__2.r = z
/*                    Perform triangular solve for A*x = s*b.
*/
            i__3 = j;
            i__4 = j;
            z__1.r = x[i__4].r - csumj.r, z__1.i = x[i__4].i -
                csumj.i;
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            i__3 = j;
            xj = (d__1 = x[i__3].r, abs(d__1)) + (d__2 = d_imag(&x[j])
                , abs(d__2));
            if (nounit) {
            d_cnjg(&z__2, &a[j + j * a_dim1]);
            z__1.r = tscal * z__2.r, z__1.i = tscal * z__2.i;
            tjjs.r = z__1.r, tjjs.i = z__1.i;
            } else {
            tjjs.r = tscal, tjjs.i = 0.;
            if (tscal == 1.) {
                goto L210;
            }
            }

/*                    Compute x(j) = x(j) / A(j,j), scaling if necessary. */

            tjj = (d__1 = tjjs.r, abs(d__1)) + (d__2 = d_imag(&tjjs),
                abs(d__2));
            if (tjj > smlnum) {

/*                       abs(A(j,j)) > SMLNUM: */

            if (tjj < 1.) {
                if (xj > tjj * bignum) {

/*                             Scale X by 1/abs(x(j)). */

                rec = 1. / xj;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
                }
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            } else if (tjj > 0.) {

/*                       0 < abs(A(j,j)) <= SMLNUM: */

            if (xj > tjj * bignum) {

/*                          Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM. */

                rec = tjj * bignum / xj;
                zdscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
            }
            i__3 = j;
            zladiv_(&z__1, &x[j], &tjjs);
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
            } else {

/*
                         A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                         scale = 0 and compute a solution to A**H *x = 0.
*/

            i__3 = *n;
            for (i__ = 1; i__ <= i__3; ++i__) {
                i__4 = i__;
                x[i__4].r = 0., x[i__4].i = 0.;
/* L200: */
            }
            i__3 = j;
            x[i__3].r = 1., x[i__3].i = 0.;
            *scale = 0.;
            xmax = 0.;
            }
L210:
            ;
        } else {

/*
                   Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot
                   product has already been divided by 1/A(j,j).
*/

            i__3 = j;
            zladiv_(&z__2, &x[j], &tjjs);
            z__1.r = z__2.r - csumj.r, z__1.i = z__2.i - csumj.i;
            x[i__3].r = z__1.r, x[i__3].i = z__1.i;
        }
/* Computing MAX */
        i__3 = j;
        d__3 = xmax, d__4 = (d__1 = x[i__3].r, abs(d__1)) + (d__2 =
            d_imag(&x[j]), abs(d__2));
        xmax = max(d__3,d__4);
/* L220: */
        }
    }
    *scale /= tscal;
    }

/*     Scale the column norms by 1/TSCAL for return. */

    if (tscal != 1.) {
    d__1 = 1. / tscal;
    # 调用 BLAS 库中的 dscal_ 函数，对数组 cnorm 的所有元素进行数乘操作
    dscal_(n, &d__1, &cnorm[1], &c__1);
    # 结束当前函数的执行并返回 0
    }
    return 0;
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
*/

/* Subroutine */ int zlauu2_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1;

    /* Local variables */
    static integer i__;
    static doublereal aii;
    extern logical lsame_(char *, char *);
    extern /* Double Complex */ VOID zdotc_(doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    extern /* Subroutine */ int zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *);
    static logical upper;
    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
        integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
        integer *, doublecomplex *, integer *);

    /* Test the input parameters. */
    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    }



    /*     End of ZLATRS */



} /* zlatrs_ */

/*
    Purpose
    =======
    
    ZLAUU2 computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.
    
    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.
    
    This is the unblocked form of the algorithm, calling Level 2 BLAS.
    
    Arguments
    =========
    
    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
    
    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.
    
    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    
    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value
*/



    /* Function Body */
    
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;



    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    }


These comments annotate each section of the provided Fortran subroutine `zlauu2`, explaining the purpose of the subroutine, its parameters, and the initial parameter checks performed within the routine.
    } else if (*lda < max(1,*n)) {
    # 如果输入的 lda 小于 1 和 n 中的较大者，则设定 info 为 -4
    *info = -4;
    }
    # 如果 info 不等于 0，则调用 xerbla 函数处理错误，返回 0
    if (*info != 0) {
    # 将 info 取负数后传递给 xerbla 函数
    i__1 = -(*info);
    # 调用 xerbla 函数，传递函数名 "ZLAUU2" 和负数的 info 值
    xerbla_("ZLAUU2", &i__1);
    # 返回 0 表示出错处理完成
    return 0;
    }
/*     Quick return if possible */

// 如果 n 为 0，则快速返回
if (*n == 0) {
    return 0;
}

// 检查是否计算上三角矩阵
if (upper) {

/*        Compute the product U * U'. */

// 计算 U * U' 的乘积

// 循环遍历矩阵的每一行
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
    // 获取对角元素 aii
    i__2 = i__ + i__ * a_dim1;
    aii = a[i__2].r;
    
    // 如果当前行 i 小于 n，则执行以下操作
    if (i__ < *n) {
        // 计算非对角元素的内积
        i__2 = i__ + i__ * a_dim1;
        i__3 = *n - i__;
        zdotc_(&z__1, &i__3, &a[i__ + (i__ + 1) * a_dim1], lda, &a[
            i__ + (i__ + 1) * a_dim1], lda);
        d__1 = aii * aii + z__1.r;
        // 更新对角元素的值
        a[i__2].r = d__1, a[i__2].i = 0.;
        
        // 反转非对角元素
        i__2 = *n - i__;
        zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
        
        // 执行矩阵向量乘法
        i__2 = i__ - 1;
        i__3 = *n - i__;
        z__1.r = aii, z__1.i = 0.;
        zgemv_("No transpose", &i__2, &i__3, &c_b57, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            z__1, &a[i__ * a_dim1 + 1], &c__1);
        
        // 反转非对角元素
        i__2 = *n - i__;
        zlacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
    } else {
        // 对角元素的处理
        zdscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
    }
    // 标签 L10
/* L10: */
}

} else {

/*        Compute the product L' * L. */

// 计算 L' * L 的乘积

// 循环遍历矩阵的每一行
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
    // 获取对角元素 aii
    i__2 = i__ + i__ * a_dim1;
    aii = a[i__2].r;
    
    // 如果当前行 i 小于 n，则执行以下操作
    if (i__ < *n) {
        // 计算非对角元素的内积
        i__2 = i__ + i__ * a_dim1;
        i__3 = *n - i__;
        zdotc_(&z__1, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &a[
            i__ + 1 + i__ * a_dim1], &c__1);
        d__1 = aii * aii + z__1.r;
        // 更新对角元素的值
        a[i__2].r = d__1, a[i__2].i = 0.;
        
        // 反转非对角元素
        i__2 = i__ - 1;
        zlacgv_(&i__2, &a[i__ + a_dim1], lda);
        
        // 执行矩阵向量乘法
        i__2 = *n - i__;
        i__3 = i__ - 1;
        z__1.r = aii, z__1.i = 0.;
        zgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            z__1, &a[i__ + a_dim1], lda);
        
        // 反转非对角元素
        i__2 = i__ - 1;
        zlacgv_(&i__2, &a[i__ + a_dim1], lda);
    } else {
        // 对角元素的处理
        zdscal_(&i__, &aii, &a[i__ + a_dim1], lda);
    }
    // 标签 L20
/* L20: */
}
}

// 返回结果
return 0;

/*     End of ZLAUU2 */

} /* zlauu2_ */

/* Subroutine */ int zlauum_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

/* Local variables */
static integer i__, ib, nb;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *), zherk_(char *, char *, integer *,
    integer *, doublereal *, doublecomplex *, integer *, doublereal *,
     doublecomplex *, integer *);
static logical upper;

/* Subroutine zlauum: 计算 Hermitian 上三角矩阵的乘积 */
    extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer *,
         doublecomplex *, integer *),
        zlauu2_(char *, integer *, doublecomplex *, integer *, integer *);
    extern /* Subroutine */ void xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);



    声明外部复杂数矩阵乘法子程序 ztrmm_
        参数: char *, char *, char *, char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *, doublecomplex *, integer *
    声明外部双上三角矩阵更新子程序 zlauu2_
        参数: char *, integer *, doublecomplex *, integer *, integer *
    声明外部异常处理子程序 xerbla_
        参数: char *, integer *
    声明外部整数环境查询函数 ilaenv_
        参数: integer *, char *, char *, integer *, integer *, integer *, integer *, ftnlen, ftnlen
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZLAUUM computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the blocked form of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;               // 设置 A 的第一个维度为 LDA
    a_offset = 1 + a_dim1;       // 计算 A 的偏移量
    a -= a_offset;               // 将 A 的指针移动到正确位置

    /* Function Body */
    *info = 0;                   // 初始化 INFO 为 0
    upper = lsame_(uplo, "U");   // 检查 UPLO 是否为 'U'，返回布尔值给 upper
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 UPLO 不是 'U' 也不是 'L'，将 INFO 设置为 -1
    *info = -1;
    } else if (*n < 0) {         // 如果 N 小于 0，将 INFO 设置为 -2
    *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 LDA 小于 max(1,N)，将 INFO 设置为 -4
    *info = -4;
    }
    if (*info != 0) {            // 如果 INFO 不等于 0，调用 XERBLA 报错并返回
    i__1 = -(*info);
    xerbla_("ZLAUUM", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {               // 如果 N 等于 0，直接返回
    return 0;
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "ZLAUUM", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);              // 根据环境确定块大小

    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code */

    zlauu2_(uplo, n, &a[a_offset], lda, info);  // 调用非块形式的计算函数 ZLAUU2
    } else {

/*        Use blocked code */

    if (upper) {

/*           Compute the product U * U'. */

        i__1 = *n;
        i__2 = nb;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {  // 使用块形式计算 U * U'
/* Computing MIN */
/* 计算最小值 */
        i__3 = nb, i__4 = *n - i__ + 1;
        // 计算当前迭代中 ib 的值，即 nb 和 (*n - i__ + 1) 的较小值
        ib = min(i__3,i__4);
        // 设置一个临时变量 i__3 为 i__ - 1
        i__3 = i__ - 1;
        // 调用 BLAS 库中的 ztrmm 函数，执行右侧矩阵乘法运算
        ztrmm_("Right", "Upper", "Conjugate transpose", "Non-unit", &
            i__3, &ib, &c_b57, &a[i__ + i__ * a_dim1], lda, &a[
            i__ * a_dim1 + 1], lda);
        // 调用 LAPACK 库中的 zlauu2 函数，对上三角矩阵进行 Cholesky 因子分解
        zlauu2_("Upper", &ib, &a[i__ + i__ * a_dim1], lda, info);
        // 如果当前处理的子矩阵没有超出矩阵维度，则继续进行下面的运算
        if (i__ + ib <= *n) {
            // 设置一个临时变量 i__3 为 i__ - 1
            i__3 = i__ - 1;
            // 设置一个临时变量 i__4 为 *n - i__ - ib + 1
            i__4 = *n - i__ - ib + 1;
            // 调用 BLAS 库中的 zgemm 函数，执行矩阵乘法运算
            zgemm_("No transpose", "Conjugate transpose", &i__3, &ib,
                &i__4, &c_b57, &a[(i__ + ib) * a_dim1 + 1], lda, &
                a[i__ + (i__ + ib) * a_dim1], lda, &c_b57, &a[i__
                * a_dim1 + 1], lda);
            // 设置一个临时变量 i__3 为 *n - i__ - ib + 1
            i__3 = *n - i__ - ib + 1;
            // 调用 BLAS 库中的 zherk 函数，进行 Hermitian 矩阵乘法运算
            zherk_("Upper", "No transpose", &ib, &i__3, &c_b1034, &a[
                i__ + (i__ + ib) * a_dim1], lda, &c_b1034, &a[i__
                + i__ * a_dim1], lda);
        }
/* L10: */
/* L10: 标签，用于循环结构的控制 */
        }
    } else {

/*           Compute the product L' * L. */
/* 计算 L' * L 的乘积 */

        // 设置循环的步长为 nb
        i__2 = *n;
        // 设置循环的起始值为 1，步长为 nb
        i__1 = nb;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {
/* Computing MIN */
/* 计算最小值 */
        i__3 = nb, i__4 = *n - i__ + 1;
        // 计算当前迭代中 ib 的值，即 nb 和 (*n - i__ + 1) 的较小值
        ib = min(i__3,i__4);
        // 设置一个临时变量 i__3 为 i__ - 1
        i__3 = i__ - 1;
        // 调用 BLAS 库中的 ztrmm 函数，执行左侧矩阵乘法运算
        ztrmm_("Left", "Lower", "Conjugate transpose", "Non-unit", &
            ib, &i__3, &c_b57, &a[i__ + i__ * a_dim1], lda, &a[
            i__ + a_dim1], lda);
        // 调用 LAPACK 库中的 zlauu2 函数，对下三角矩阵进行 Cholesky 因子分解
        zlauu2_("Lower", &ib, &a[i__ + i__ * a_dim1], lda, info);
        // 如果当前处理的子矩阵没有超出矩阵维度，则继续进行下面的运算
        if (i__ + ib <= *n) {
            // 设置一个临时变量 i__3 为 i__ - 1
            i__3 = i__ - 1;
            // 设置一个临时变量 i__4 为 *n - i__ - ib + 1
            i__4 = *n - i__ - ib + 1;
            // 调用 BLAS 库中的 zgemm 函数，执行矩阵乘法运算
            zgemm_("Conjugate transpose", "No transpose", &ib, &i__3,
                &i__4, &c_b57, &a[i__ + ib + i__ * a_dim1], lda, &
                a[i__ + ib + a_dim1], lda, &c_b57, &a[i__ +
                a_dim1], lda);
            // 设置一个临时变量 i__3 为 *n - i__ - ib + 1
            i__3 = *n - i__ - ib + 1;
            // 调用 BLAS 库中的 zherk 函数，进行 Hermitian 矩阵乘法运算
            zherk_("Lower", "Conjugate transpose", &ib, &i__3, &
                c_b1034, &a[i__ + ib + i__ * a_dim1], lda, &
                c_b1034, &a[i__ + i__ * a_dim1], lda);
        }
/* L20: */
/* L20: 标签，用于循环结构的控制 */
        }
    }
    }

    return 0;

/*     End of ZLAUUM */

} /* zlauum_ */

/* Subroutine */ int zpotf2_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;
    doublecomplex z__1, z__2;

    /* Local variables */
    static integer j;
    static doublereal ajj;
    extern logical lsame_(char *, char *);
    extern /* Double Complex */ VOID zdotc_(doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *);
    extern /* Subroutine */ int zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *);
    static logical upper;
    extern logical disnan_(doublereal *);


这段代码主要是一个复杂的线性代数算法实现，涉及到 Cholesky 分解和矩阵乘法等基本操作。注释部分详细解释了每个函数调用的作用和参数含义，以及循环控制的标签。
    # 外部声明，表明下面的函数或子程序在其他地方定义或声明
    extern /* Subroutine */ int xerbla_(char *, integer *),
        # 调用 BLAS 库中的函数 zdscal_
        zdscal_(integer *, doublereal *, doublecomplex *, integer *),
        # 调用 LAPACK 库中的函数 zlacgv_
        zlacgv_(integer *, doublecomplex *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZPOTF2 computes the Cholesky factorization of a complex Hermitian
    positive definite matrix A.

    The factorization has the form
       A = U' * U ,  if UPLO = 'U', or
       A = L  * L',  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U'*U  or A = L*L'.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;  // 初始化 INFO 为 0，表示成功退出
    upper = lsame_(uplo, "U");  // 检查 UPLO 是否为 'U'，并将结果存储在 upper 变量中
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 UPLO 不是 'U' 也不是 'L'，则设置 INFO 为 -1
    *info = -1;
    } else if (*n < 0) {  // 如果 N 小于 0，则设置 INFO 为 -2
    *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 LDA 小于 max(1, N)，则设置 INFO 为 -4
    *info = -4;
    }
    if (*info != 0) {  // 如果 INFO 不为 0，调用 xerbla_ 报告错误并返回
    i__1 = -(*info);
    xerbla_("ZPOTF2", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {  // 如果 N 等于 0，直接返回
    return 0;
    }

    if (upper) {

/*        Compute the Cholesky factorization A = U'*U. */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/*           Compute U(J,J) and test for non-positive-definiteness. */

        // 计算矩阵A的对角元素U(J,J)，并检测是否非正定性。
        i__2 = j + j * a_dim1;
        // 获取A的第j行第j列元素的实部
        d__1 = a[i__2].r;
        // 计算A的第j列（除去第j行）与其自身的内积，并返回结果到z__2
        i__3 = j - 1;
        zdotc_(&z__2, &i__3, &a[j * a_dim1 + 1], &c__1, &a[j * a_dim1 + 1]
            , &c__1);
        // 计算U(J,J) = A(J,J) - 内积结果的实部，将虚部取反
        z__1.r = d__1 - z__2.r, z__1.i = -z__2.i;
        ajj = z__1.r;
        // 如果U(J,J) <= 0 或者 U(J,J) 是 NaN，则执行以下操作
        if (ajj <= 0. || disnan_(&ajj)) {
        // 将A的第j行第j列元素设为ajj，虚部设为0
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.;
        // 跳转到标签L30
        goto L30;
        }
        // 计算U(J,J)的平方根，并存储回A的第j行第j列元素
        ajj = sqrt(ajj);
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.;

/*           Compute elements J+1:N of row J. */

        // 如果j小于总列数*n，执行以下操作
        if (j < *n) {
        i__2 = j - 1;
        // 对A的第j行（除去第j列）进行共轭处理
        zlacgv_(&i__2, &a[j * a_dim1 + 1], &c__1);
        i__2 = j - 1;
        // 计算A的第j行第j列后续元素与A的第j行后续元素的乘积和，存储到A的第j列后续元素
        i__3 = *n - j;
        z__1.r = -1., z__1.i = -0.;
        zgemv_("Transpose", &i__2, &i__3, &z__1, &a[(j + 1) * a_dim1
            + 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b57, &a[j + (
            j + 1) * a_dim1], lda);
        i__2 = j - 1;
        // 对A的第j行（除去第j列）进行共轭处理
        zlacgv_(&i__2, &a[j * a_dim1 + 1], &c__1);
        i__2 = *n - j;
        // 将A的第j列后续元素除以ajj
        d__1 = 1. / ajj;
        zdscal_(&i__2, &d__1, &a[j + (j + 1) * a_dim1], lda);
        }
/* L10: */
    }
    } else {

/*        Compute the Cholesky factorization A = L*L'. */

    // 计算Cholesky分解 A = L * L'

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {

/*           Compute L(J,J) and test for non-positive-definiteness. */

        // 计算矩阵L的对角元素L(J,J)，并检测是否非正定性。
        i__2 = j + j * a_dim1;
        // 获取A的第j行第j列元素的实部
        d__1 = a[i__2].r;
        i__3 = j - 1;
        // 计算A的第j列（除去第j行）与其自身的内积，并返回结果到z__2
        zdotc_(&z__2, &i__3, &a[j + a_dim1], lda, &a[j + a_dim1], lda);
        // 计算L(J,J) = A(J,J) - 内积结果的实部，将虚部取反
        z__1.r = d__1 - z__2.r, z__1.i = -z__2.i;
        ajj = z__1.r;
        // 如果L(J,J) <= 0 或者 L(J,J) 是 NaN，则执行以下操作
        if (ajj <= 0. || disnan_(&ajj)) {
        // 将A的第j行第j列元素设为ajj，虚部设为0
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.;
        // 跳转到标签L30
        goto L30;
        }
        // 计算L(J,J)的平方根，并存储回A的第j行第j列元素
        ajj = sqrt(ajj);
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.;

/*           Compute elements J+1:N of column J. */

        // 如果j小于总列数*n，执行以下操作
        if (j < *n) {
        i__2 = j - 1;
        // 对A的第j列（除去第j行）进行共轭处理
        zlacgv_(&i__2, &a[j + a_dim1], lda);
        i__2 = *n - j;
        i__3 = j - 1;
        // 计算A的第j列后续元素与A的第j列后续元素的乘积和，存储到A的第j列后续元素
        z__1.r = -1., z__1.i = -0.;
        zgemv_("No transpose", &i__2, &i__3, &z__1, &a[j + 1 + a_dim1]
            , lda, &a[j + a_dim1], lda, &c_b57, &a[j + 1 + j *
            a_dim1], &c__1);
        i__2 = j - 1;
        // 对A的第j列（除去第j行）进行共轭处理
        zlacgv_(&i__2, &a[j + a_dim1], lda);
        i__2 = *n - j;
        // 将A的第j列后续元素除以ajj
        d__1 = 1. / ajj;
        zdscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);
        }
/* L20: */
    }
    }
    // 跳转到标签L40
    goto L40;

L30:
    *info = j;

L40:
    return 0;

/*     End of ZPOTF2 */

} /* zpotf2_ */

/* Subroutine */ int zpotrf_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    doublecomplex z__1;

    /* Local variables */
    static integer j, jb, nb;
    extern logical lsame_(char *, char *);
    # 声明外部函数 zgemm，该函数实现矩阵乘法
    extern /* Subroutine */ int zgemm_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);

    # 声明静态逻辑变量 upper，用于指示矩阵是否为上三角形式
    static logical upper;

    # 声明外部函数 ztrsm，该函数实现矩阵乘法
    extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer *,
         doublecomplex *, integer *);

    # 声明外部函数 zpotf2，该函数执行 Cholesky 分解
    extern /* Subroutine */ int zpotf2_(char *, integer *, doublecomplex *,
        integer *, integer *);

    # 声明外部函数 xerbla，该函数处理错误信息
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明外部函数 ilaenv，该函数返回指定环境参数的值
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZPOTRF computes the Cholesky factorization of a complex Hermitian
    positive definite matrix A.

    The factorization has the form
       A = U**H * U,  if UPLO = 'U', or
       A = L  * L**H,  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the block version of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.

    =====================================================================


       Test the input parameters.
*/
void zpotrf_(const char* uplo, int* n, doublecomplex* a, int* lda, int* info) {
    /* Parameter adjustments */
    int a_dim1 = *lda;
    int a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    bool upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        int i__1 = -(*info);
        xerbla_("ZPOTRF", &i__1);
        return;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return;
    }

    /* Determine the block size for this environment. */
    int nb = ilaenv_(&c__1, "ZPOTRF", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    if (nb <= 1 || nb >= *n) {
        /* Use unblocked code. */
        zpotf2_(uplo, n, &a[a_offset], lda, info);
    } else {
        /* Use blocked code. */
        if (upper) {
            // Blocked code for upper triangle
            // ...
        } else {
            // Blocked code for lower triangle
            // ...
        }
    }
}
/*
           Compute the Cholesky factorization A = U'*U.
*/

/* Loop over blocks of columns */
i__1 = *n;
i__2 = nb;
for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*
        Update and factorize the current diagonal block and test
        for non-positive-definiteness.
*/
/* Determine the size of the current block */
i__3 = nb, i__4 = *n - j + 1;
jb = min(i__3,i__4);

/* Update the upper triangle of A */
i__3 = j - 1;
zherk_("Upper", "Conjugate transpose", &jb, &i__3, &c_b1276, &
    a[j * a_dim1 + 1], lda, &c_b1034, &a[j + j * a_dim1],
    lda);

/* Cholesky factorization of the current block */
zpotf2_("Upper", &jb, &a[j + j * a_dim1], lda, info);
if (*info != 0) {
    goto L30;
}

/* Apply the transformations to the trailing submatrix */
if (j + jb <= *n) {

/* Compute block row */
i__3 = *n - j - jb + 1;
i__4 = j - 1;
z__1.r = -1., z__1.i = -0.;
zgemm_("Conjugate transpose", "No transpose", &jb, &i__3,
    &i__4, &z__1, &a[j * a_dim1 + 1], lda, &a[(j + jb)
     * a_dim1 + 1], lda, &c_b57, &a[j + (j + jb) *
    a_dim1], lda);

/* Solve for the block row */
i__3 = *n - j - jb + 1;
ztrsm_("Left", "Upper", "Conjugate transpose", "Non-unit",
     &jb, &i__3, &c_b57, &a[j + j * a_dim1], lda, &a[
    j + (j + jb) * a_dim1], lda);
}
/* End of block row computation */
/* L10: */
}

} else {

/*
           Compute the Cholesky factorization A = L*L'.
*/

/* Loop over blocks of columns */
i__2 = *n;
i__1 = nb;
for (j = 1; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*
        Update and factorize the current diagonal block and test
        for non-positive-definiteness.
*/
/* Determine the size of the current block */
i__3 = nb, i__4 = *n - j + 1;
jb = min(i__3,i__4);

/* Update the lower triangle of A */
i__3 = j - 1;
zherk_("Lower", "No transpose", &jb, &i__3, &c_b1276, &a[j +
    a_dim1], lda, &c_b1034, &a[j + j * a_dim1], lda);

/* Cholesky factorization of the current block */
zpotf2_("Lower", &jb, &a[j + j * a_dim1], lda, info);
if (*info != 0) {
    goto L30;
}

/* Apply the transformations to the trailing submatrix */
if (j + jb <= *n) {

/* Compute block column */
i__3 = *n - j - jb + 1;
i__4 = j - 1;
z__1.r = -1., z__1.i = -0.;
zgemm_("No transpose", "Conjugate transpose", &i__3, &jb,
    &i__4, &z__1, &a[j + jb + a_dim1], lda, &a[j +
    a_dim1], lda, &c_b57, &a[j + jb + j * a_dim1],
    lda);

/* Solve for the block column */
i__3 = *n - j - jb + 1;
ztrsm_("Right", "Lower", "Conjugate transpose", "Non-unit"
    , &i__3, &jb, &c_b57, &a[j + j * a_dim1], lda, &a[
    j + jb + j * a_dim1], lda);
}
/* End of block column computation */
/* L20: */
}
}

/* Update error flag and return */
L40:
return 0;

/* End of ZPOTRF */
} /* zpotrf_ */

/* Subroutine to compute the inverse of a Hermitian positive definite matrix */
int zpotri_(char *uplo, integer *n, doublecomplex *a,
    integer *lda, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1;

/* Local variables */
    # 外部声明函数 lsame_，接受两个字符型参数并返回逻辑值
    extern logical lsame_(char *, char *);
    # 外部声明函数 xerbla_，接受字符型参数和整型参数，无返回值
    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 外部声明函数 zlauum_，接受字符型参数、整型参数、双复数型数组参数以及两个整型参数，无返回值
    extern /* Subroutine */ int zlauum_(
        char *, integer *, doublecomplex *, integer *, integer *);
    # 外部声明函数 ztrtri_，接受两个字符型参数、整型参数、双复数型数组参数以及两个整型参数，无返回值
    extern /* Subroutine */ int ztrtri_(
        char *, char *, integer *, doublecomplex *, integer *,
        integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZPOTRI computes the inverse of a complex Hermitian positive definite
    matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    computed by ZPOTRF.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H, as computed by
            ZPOTRF.
            On exit, the upper or lower triangle of the (Hermitian)
            inverse of A, overwriting the input factor U or L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.

    =====================================================================


       Test the input parameters.
*/

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;

/* Function Body */
*info = 0;
if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*lda < max(1,*n)) {
*info = -4;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("ZPOTRI", &i__1);
return 0;
}

/* Quick return if possible */

if (*n == 0) {
return 0;
}

/* Invert the triangular Cholesky factor U or L. */

ztrtri_(uplo, "Non-unit", n, &a[a_offset], lda, info);
if (*info > 0) {
return 0;
}

/* Form inv(U)*inv(U)' or inv(L)'*inv(L). */

zlauum_(uplo, n, &a[a_offset], lda, info);

return 0;

/* End of ZPOTRI */

} /* zpotri_ */

/* Subroutine */ int zpotrs_(char *uplo, integer *n, integer *nrhs,
    doublecomplex *a, integer *lda, doublecomplex *b, integer *ldb,
    integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    extern logical lsame_(char *, char *);
    static logical upper;
    extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer *,
         doublecomplex *, integer *),
        xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --

*/

/* Comments:

This block of code defines and implements the LAPACK routines zpotri and zpotrs, used for solving systems of linear equations involving complex Hermitian positive definite matrices. These routines utilize Cholesky factorization for efficient computation.

zpotri:
- Computes the inverse of matrix A using its Cholesky factorization A = U**H * U or A = L * L**H.
- Input parameters:
  - UPLO: Specifies whether the upper or lower triangular part of A is stored.
  - N: Order of matrix A.
  - A: On input, the triangular factor U or L from the Cholesky factorization; on output, the inverse of A.
  - LDA: Leading dimension of A.
  - INFO: Error flag indicating success or failure of computation.

zpotrs:
- Solves a system of linear equations AX = B, where A is a complex Hermitian positive definite matrix.
- Input parameters:
  - UPLO: Specifies whether the upper or lower triangular part of A is stored.
  - N: Order of matrix A.
  - NRHS: Number of right-hand sides.
  - A: The matrix A, assumed to have been factorized by zpotrf.
  - LDA: Leading dimension of A.
  - B: On entry, the right-hand side matrix B; on exit, the solution matrix X.
  - LDB: Leading dimension of B.
  - INFO: Error flag indicating success or failure of computation.

These routines are crucial in numerical computations involving complex matrices, ensuring efficient and accurate solutions to linear systems and inverses of Hermitian positive definite matrices.

*/
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZPOTRS solves a system of linear equations A*X = B with a Hermitian
    positive definite matrix A using the Cholesky factorization
    A = U**H*U or A = L*L**H computed by ZPOTRF.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            指定 A 的存储方式：'U' 表示存储 A 的上三角部分；
                                'L' 表示存储 A 的下三角部分。

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
            A 的阶数 N，必须大于等于 0。

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            右侧矩阵 B 的列数，即方程组的数量，必须大于等于 0。

    A       (input) COMPLEX*16 array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H, as computed by ZPOTRF.
            Cholesky 分解得到的上三角矩阵 U 或下三角矩阵 L。

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            数组 A 的主维度，必须大于等于 max(1, N)。

    B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            在输入时为右侧矩阵 B，在输出时为解矩阵 X。

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            数组 B 的主维度，必须大于等于 max(1, N)。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            返回值：
            = 0: 成功完成
            < 0: 若 INFO = -i，表示第 i 个参数有非法值

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    upper = lsame_(uplo, "U");  // 判断 uplo 是否为 "U"，并赋值给 upper
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 uplo 不是 "U" 也不是 "L"
        *info = -1;  // 设置 info 参数为 -1
    } else if (*n < 0) {  // 如果 n 小于 0
        *info = -2;  // 设置 info 参数为 -2
    } else if (*nrhs < 0) {  // 如果 nrhs 小于 0
        *info = -3;  // 设置 info 参数为 -3
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 max(1, n)
        *info = -5;  // 设置 info 参数为 -5
    } else if (*ldb < max(1,*n)) {  // 如果 ldb 小于 max(1, n)
        *info = -7;  // 设置 info 参数为 -7
    }
    if (*info != 0) {  // 如果 info 不为 0，表示出现错误
        i__1 = -(*info);
        xerbla_("ZPOTRS", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0
    }

    /* Quick return if possible */
    if (*n == 0 || *nrhs == 0) {  // 如果 n 或 nrhs 为 0
        return 0;  // 直接返回 0
    }

    if (upper) {

/*
          Solve A*X = B where A = U'*U.

          Solve U'*X = B, overwriting B with X.
*/

        ztrsm_("Left", "Upper", "Conjugate transpose", "Non-unit", n, nrhs, &
            c_b57, &a[a_offset], lda, &b[b_offset], ldb);

/*        Solve U*X = B, overwriting B with X. */

        ztrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b57, &
            a[a_offset], lda, &b[b_offset], ldb);
    } else {

/*
          Solve A*X = B where A = L*L'.

          Solve L*X = B, overwriting B with X.
*/

        ztrsm_("Left", "Lower", "No transpose", "Non-unit", n, nrhs, &c_b57, &
            a[a_offset], lda, &b[b_offset], ldb);

/*        Solve L'*X = B, overwriting B with X. */

        ztrsm_("Left", "Lower", "Conjugate transpose", "Non-unit", n, nrhs, &
            c_b57, &a[a_offset], lda, &b[b_offset], ldb);
    }

    return 0;

/*     End of ZPOTRS */

} /* zpotrs_ */

/* Subroutine */ int zrot_(integer *n, doublecomplex *cx, integer *incx,
    doublecomplex *cy, integer *incy, doublereal *c__, doublecomplex *s)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublecomplex z__1, z__2, z__3, z__4;

    /* Local variables */
    static integer i__, ix, iy;
    static doublecomplex stemp;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZROT   applies a plane rotation, where the cos (C) is real and the
    sin (S) is complex, and the vectors CX and CY are complex.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements in the vectors CX and CY.

    CX      (input/output) COMPLEX*16 array, dimension (N)
            On input, the vector X.
            On output, CX is overwritten with C*X + S*Y.

    INCX    (input) INTEGER
            The increment between successive values of CY.  INCX <> 0.

    CY      (input/output) COMPLEX*16 array, dimension (N)
            On input, the vector Y.
            On output, CY is overwritten with -CONJG(S)*X + C*Y.

    INCY    (input) INTEGER
            The increment between successive values of CY.  INCX <> 0.

    C       (input) DOUBLE PRECISION
*/


注释部分已添加，按照要求进行了详细解释。
    S       (input) COMPLEX*16
            输入参数 S，类型为复数(COMPLEX*16)。
            C and S define a rotation
               C 和 S 定义了一个旋转变换
               [  C          S  ]
               [ -conjg(S)   C  ]
            where C*C + S*CONJG(S) = 1.0.
            其中 C*C + S*CONJG(S) = 1.0，表明 C 和 S 满足单位圆的旋转矩阵性质。
   =====================================================================
/* Parameter adjustments */
    /* 参数调整 */

    --cy;
    --cx;

    /* Function Body */
    /* 函数主体 */
    if (*n <= 0) {
    /* 如果n小于等于0，返回0 */
    return 0;
    }
    if (*incx == 1 && *incy == 1) {
    /* 如果incx和incy都等于1，跳转到标签L20 */
    goto L20;
    }

/*     Code for unequal increments or equal increments not equal to 1 */
/*     处理不等增量或者增量不等于1的情况 */

    ix = 1;
    iy = 1;
    if (*incx < 0) {
    /* 如果incx小于0 */
    ix = (-(*n) + 1) * *incx + 1;
    }
    if (*incy < 0) {
    /* 如果incy小于0 */
    iy = (-(*n) + 1) * *incy + 1;
    }
    i__1 = *n;
    /* 循环n次 */
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 计算数组索引 */
    i__2 = ix;
    z__2.r = *c__ * cx[i__2].r, z__2.i = *c__ * cx[i__2].i;
    i__3 = iy;
    z__3.r = s->r * cy[i__3].r - s->i * cy[i__3].i, z__3.i = s->r * cy[
        i__3].i + s->i * cy[i__3].r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    stemp.r = z__1.r, stemp.i = z__1.i;
    i__2 = iy;
    i__3 = iy;
    z__2.r = *c__ * cy[i__3].r, z__2.i = *c__ * cy[i__3].i;
    d_cnjg(&z__4, s);
    i__4 = ix;
    z__3.r = z__4.r * cx[i__4].r - z__4.i * cx[i__4].i, z__3.i = z__4.r *
        cx[i__4].i + z__4.i * cx[i__4].r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    cy[i__2].r = z__1.r, cy[i__2].i = z__1.i;
    i__2 = ix;
    cx[i__2].r = stemp.r, cx[i__2].i = stemp.i;
    ix += *incx;
    iy += *incy;
/* L10: */
    }
    /* 返回0 */
    return 0;

/*     Code for both increments equal to 1 */
/*     处理增量均等于1的情况 */

L20:
    i__1 = *n;
    /* 循环n次 */
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 计算数组索引 */
    i__2 = i__;
    z__2.r = *c__ * cx[i__2].r, z__2.i = *c__ * cx[i__2].i;
    i__3 = i__;
    z__3.r = s->r * cy[i__3].r - s->i * cy[i__3].i, z__3.i = s->r * cy[
        i__3].i + s->i * cy[i__3].r;
    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
    stemp.r = z__1.r, stemp.i = z__1.i;
    i__2 = i__;
    i__3 = i__;
    z__2.r = *c__ * cy[i__3].r, z__2.i = *c__ * cy[i__3].i;
    d_cnjg(&z__4, s);
    i__4 = i__;
    z__3.r = z__4.r * cx[i__4].r - z__4.i * cx[i__4].i, z__3.i = z__4.r *
        cx[i__4].i + z__4.i * cx[i__4].r;
    z__1.r = z__2.r - z__3.r, z__1.i = z__2.i - z__3.i;
    cy[i__2].r = z__1.r, cy[i__2].i = z__1.i;
    i__2 = i__;
    cx[i__2].r = stemp.r, cx[i__2].i = stemp.i;
/* L30: */
    }
    /* 返回0 */
    return 0;
} /* zrot_ */

/* Subroutine */ int zstedc_(char *compz, integer *n, doublereal *d__,
    doublereal *e, doublecomplex *z__, integer *ldz, doublecomplex *work,
    integer *lwork, doublereal *rwork, integer *lrwork, integer *iwork,
    integer *liwork, integer *info)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, j, k, m;
    static doublereal p;
    static integer ii, ll, lgn;
    static doublereal eps, tiny;
    extern logical lsame_(char *, char *);
    static integer lwmin, start;
    extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), zlaed0_(integer *, integer *,
        doublereal *, doublereal *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublereal *, integer *, integer *);
    外部函数声明，指定参数和返回类型
    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *),
        dstedc_(char *, integer *,
        doublereal *, doublereal *, doublereal *, integer *, doublereal *,
         integer *, integer *, integer *, integer *),
        dlaset_(
        char *, integer *, integer *, doublereal *, doublereal *,
        doublereal *, integer *),
        xerbla_(char *, integer *);
    
    外部函数声明，指定参数和返回类型
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    静态整数变量声明
    static integer finish;
    
    外部函数声明，指定参数和返回类型
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    
    外部子程序声明，指定参数和返回类型
    extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *,
         integer *);
    
    外部子程序声明，指定参数和返回类型
    extern /* Subroutine */ int zlacrm_(integer *, integer *, doublecomplex *,
        integer *, doublereal *, integer *, doublecomplex *, integer *,
        doublereal *);
    
    静态整数变量声明
    static integer liwmin, icompz;
    
    外部子程序声明，指定参数和返回类型
    extern /* Subroutine */ int dsteqr_(char *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);
    
    外部子程序声明，指定参数和返回类型
    extern /* Subroutine */ int zsteqr_(char *, integer *, doublereal *,
        doublereal *, doublecomplex *, integer *, doublereal *, integer *);
    
    静态双精度实数变量声明
    static doublereal orgnrm;
    
    静态整数变量声明
    static integer lrwmin;
    
    静态逻辑变量声明
    static logical lquery;
    
    静态整数变量声明
    static integer smlsiz;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.
    The eigenvectors of a full or band complex Hermitian matrix can also
    be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
    matrix to tridiagonal form.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See DLAED3 for details.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original Hermitian matrix
                    also.  On entry, Z contains the unitary matrix used
                    to reduce the original matrix to tridiagonal form.

    N       (input) INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.

    Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK.
    #         If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.
    #         If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
    #         Note that for COMPZ = 'V', then if N is less than or
    #         equal to the minimum divide size, usually 25, then LWORK need
    #         only be 1.
    #
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal sizes of the WORK, RWORK and
    #         IWORK arrays, returns these values as the first entries of
    #         the WORK, RWORK and IWORK arrays, and no error message
    #         related to LWORK or LRWORK or LIWORK is issued by XERBLA.
    LWORK   (input) INTEGER

    # RWORK   (workspace/output) DOUBLE PRECISION array,
    #                                        dimension (LRWORK)
    #         On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
    RWORK   (workspace/output) DOUBLE PRECISION array, dimension (LRWORK)

    # LRWORK  (input) INTEGER
    #         The dimension of the array RWORK.
    #         If COMPZ = 'N' or N <= 1, LRWORK must be at least 1.
    #         If COMPZ = 'V' and N > 1, LRWORK must be at least
    #                        1 + 3*N + 2*N*lg N + 3*N**2 ,
    #                        where lg( N ) = smallest integer k such
    #                        that 2**k >= N.
    #         If COMPZ = 'I' and N > 1, LRWORK must be at least
    #                        1 + 4*N + 2*N**2 .
    #         Note that for COMPZ = 'I' or 'V', then if N is less than or
    #         equal to the minimum divide size, usually 25, then LRWORK
    #         need only be max(1,2*(N-1)).
    #
    #         If LRWORK = -1, then a workspace query is assumed; the
    #         routine only calculates the optimal sizes of the WORK, RWORK
    #         and IWORK arrays, returns these values as the first entries
    #         of the WORK, RWORK and IWORK arrays, and no error message
    #         related to LWORK or LRWORK or LIWORK is issued by XERBLA.
    LRWORK  (input) INTEGER

    # IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
    #         On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))

    # LIWORK  (input) INTEGER
    #         The dimension of the array IWORK.
    #         If COMPZ = 'N' or N <= 1, LIWORK must be at least 1.
    #         If COMPZ = 'V' or N > 1,  LIWORK must be at least
    #                                   6 + 6*N + 5*N*lg N.
    #         If COMPZ = 'I' or N > 1,  LIWORK must be at least
    #                                   3 + 5*N .
    #         Note that for COMPZ = 'I' or 'V', then if N is less than or
    #         equal to the minimum divide size, usually 25, then LIWORK
    #         need only be 1.
    #
    #         If LIWORK = -1, then a workspace query is assumed; the
    #         routine only calculates the optimal sizes of the WORK, RWORK
    #         and IWORK arrays, returns these values as the first entries
    #         of the WORK, RWORK and IWORK arrays, and no error message
    #         related to LWORK or LRWORK or LIWORK is issued by XERBLA.
    LIWORK  (input) INTEGER
    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).

    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA

    =====================================================================

    Test the input parameters.
    /* Parameter adjustments */
    --d__;              // 将数组 d__ 调整为指针数组，表示对 d__ 指针数组的调整
    --e;                // 将数组 e 调整为指针数组，表示对 e 指针数组的调整
    z_dim1 = *ldz;      // 设置 z_dim1 为 ldz，表示矩阵 z 的第一维度大小
    z_offset = 1 + z_dim1;  // 计算 z__ 数组的偏移量
    z__ -= z_offset;     // 根据偏移量调整 z__ 数组的起始位置
    --work;             // 将数组 work 调整为指针数组，表示对 work 指针数组的调整
    --rwork;            // 将数组 rwork 调整为指针数组，表示对 rwork 指针数组的调整
    --iwork;            // 将数组 iwork 调整为指针数组，表示对 iwork 指针数组的调整

    /* Function Body */
    *info = 0;          // 将 info 指向的内存位置设置为 0，表示初始化错误信息为 0
    lquery = *lwork == -1 || *lrwork == -1 || *liwork == -1;  // 判断是否为查询模式

    if (lsame_(compz, "N")) {   // 如果 compz 和 "N" 相同，则设置 icompz 为 0
    icompz = 0;
    } else if (lsame_(compz, "V")) {   // 如果 compz 和 "V" 相同，则设置 icompz 为 1
    icompz = 1;
    } else if (lsame_(compz, "I")) {   // 如果 compz 和 "I" 相同，则设置 icompz 为 2
    icompz = 2;
    } else {    // 否则设置 icompz 为 -1，表示 compz 参数错误
    icompz = -1;
    }
    if (icompz < 0) {   // 如果 icompz 小于 0，说明 compz 参数错误，设置 *info 为 -1
    *info = -1;
    } else if (*n < 0) {    // 如果 n 小于 0，设置 *info 为 -2
    *info = -2;
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {    // 如果 ldz 不合法，设置 *info 为 -6
    *info = -6;
    }

    if (*info == 0) {

/*        Compute the workspace requirements */

    smlsiz = ilaenv_(&c__9, "ZSTEDC", " ", &c__0, &c__0, &c__0, &c__0, (
        ftnlen)6, (ftnlen)1);   // 根据调用环境计算所需的工作空间大小
    if (*n <= 1 || icompz == 0) {   // 计算工作空间最小需求
        lwmin = 1;
        liwmin = 1;
        lrwmin = 1;
    } else if (*n <= smlsiz) {  // 如果 n 小于等于 smlsiz，计算工作空间需求
        lwmin = 1;
        liwmin = 1;
        lrwmin = *n - 1 << 1;
    } else if (icompz == 1) {   // 如果 icompz 等于 1，计算工作空间需求
        lgn = (integer) (log((doublereal) (*n)) / log(2.));
        if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;
        }
        if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;
        }
        lwmin = *n * *n;
        i__1 = *n;
        lrwmin = *n * 3 + 1 + (*n << 1) * lgn + i__1 * i__1 * 3;
        liwmin = *n * 6 + 6 + *n * 5 * lgn;
    } else if (icompz == 2) {   // 如果 icompz 等于 2，计算工作空间需求
        lwmin = 1;
        i__1 = *n;
        lrwmin = (*n << 2) + 1 + (i__1 * i__1 << 1);
        liwmin = *n * 5 + 3;
    }
    work[1].r = (doublereal) lwmin, work[1].i = 0.;    // 设置工作数组的实部和虚部大小
    rwork[1] = (doublereal) lrwmin;    // 设置实数工作空间大小
    iwork[1] = liwmin;    // 设置整数工作空间大小

    if (*lwork < lwmin && ! lquery) {   // 如果实际工作空间小于最小需求且非查询模式，则设置 *info 为 -8
        *info = -8;
    } else if (*lrwork < lrwmin && ! lquery) {   // 如果实际实数工作空间小于最小需求且非查询模式，则设置 *info 为 -10
        *info = -10;
    } else if (*liwork < liwmin && ! lquery) {   // 如果实际整数工作空间小于最小需求且非查询模式，则设置 *info 为 -12
        *info = -12;
    }
    }

    if (*info != 0) {   // 如果 *info 不为 0，则调用错误处理函数并返回 0
    i__1 = -(*info);
    xerbla_("ZSTEDC", &i__1);
    return 0;
    } else if (lquery) {   // 如果为查询模式，则直接返回 0
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {  // 如果 n 等于 0，直接返回 0
    return 0;
    }
    if (*n == 1) {  // 如果 n 等于 1
    if (icompz != 0) {  // 如果 icompz 不等于 0，则设置 z__ 第一个元素为 (1, 0)
        i__1 = z_dim1 + 1;
        z__[i__1].r = 1., z__[i__1].i = 0.;
    }
    return 0;   // 返回 0
    }

/*
       If the following conditional clause is removed, then the routine
       will use the Divide and Conquer routine to compute only the
       eigenvalues, which requires (3N + 3N**2) real workspace and
       (2 + 5N + 2N lg(N)) integer workspace.
       Since on many architectures DSTERF is much faster than any other
       algorithm for finding eigenvalues only, it is used here
       as the default. If the conditional clause is removed, then
       information on the size of workspace needs to be changed.

       If COMPZ = 'N', use DSTERF to compute the eigenvalues.
*/

    if (icompz == 0) {   // 如果 icompz 等于 0，使用 DSTERF 计算特征值
    dsterf_(n, &d__[1], &e[1], info);
    goto L70;   // 跳转到标签 L70 处继续执行
    }
/*
   如果 N 小于等于最小的分割大小 smlsiz，则使用另一个求解器解决问题。
*/
if (*n <= smlsiz) {
    /*
       调用 zsteqr_ 函数来解决问题，根据参数的不同，可能包含矩阵的计算和特征值的计算。
       compz: 是否计算特征向量
       n: 矩阵的阶数
       d__: 主对角线上的元素数组
       e: 次对角线上的元素数组
       z__: 用于存储特征向量的复数数组
       ldz: z__ 的第一个维度的长度
       rwork: 工作数组
       info: 返回状态信息，成功为 0
    */
    zsteqr_(compz, n, &d__[1], &e[1], &z__[z_offset], ldz, &rwork[1], info);
} else {
    /*
       如果 compz = 'I'，则直接调用 dstedc_ 函数。
       初始化工作数组 rwork。
    */
    if (icompz == 2) {
        dlaset_("Full", n, n, &c_b328, &c_b1034, &rwork[1], n);
        ll = *n * *n + 1;
        i__1 = *lrwork - ll + 1;
        dstedc_("I", n, &d__[1], &e[1], &rwork[1], n, &rwork[ll], &i__1, &iwork[1], liwork, info);
        /*
           将特征向量从 rwork 转移到 z__ 数组。
           i__: 行索引
           j: 列索引
        */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * z_dim1;
                i__4 = (j - 1) * *n + i__;
                z__[i__3].r = rwork[i__4], z__[i__3].i = 0.;
            }
        }
        goto L70;
    }

    /*
       从现在开始，唯一剩下的选项是处理 compz = 'V'，即 icompz = 1。

       计算矩阵的 1-范数。
    */
    orgnrm = dlanst_("M", n, &d__[1], &e[1]);
    if (orgnrm == 0.) {
        goto L70;
    }

    eps = EPSILON;

    start = 1;

    /*
       开始处理子问题的循环。
    */
L30:
    if (start <= *n) {
        /*
           寻找下一个子对角线条目的位置 finish，
           使得 E(finish) <= TINY 或者如果不存在这样的子对角线，则 finish = N。
           位于 START 和 FINISH 之间的元素构成一个独立的子问题。
        */
        finish = start;
L40:
        if (finish < *n) {
            /*
               计算 TINY 的值。
            */
            tiny = eps * sqrt((d__1 = d__[finish], abs(d__1))) * sqrt((d__2 = d__[finish + 1], abs(d__2)));
            if ((d__1 = e[finish], abs(d__1)) > tiny) {
                ++finish;
                goto L40;
            }
        }

        /*
           确定子问题的大小 m，并解决它。
        */
        m = finish - start + 1;
        if (m > smlsiz) {
            /*
               计算矩阵的 1-范数。
            */
            orgnrm = dlanst_("M", &m, &d__[start], &e[start]);
            /*
               缩放矩阵 d__ 和 e。
            */
            dlascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &m, &c__1, &d__[start], &m, info);
            i__1 = m - 1;
            i__2 = m - 1;
            dlascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &i__1, &c__1, &e[start], &i__2, info);
            /*
               调用 zlaed0_ 来计算特征值。
            */
            zlaed0_(n, &m, &d__[start], &e[start], &z__[start * z_dim1 + 1], ldz, &work[1], n, &rwork[1], &iwork[1], info);
            if (*info > 0) {
                *info = (*info / (m + 1) + start - 1) * (*n + 1) + *info % (m + 1) + start - 1;
                goto L70;
            }

                }
            }
        }
    }
}


这段代码主要是一个条件判断和循环的嵌套结构，用于处理特征值求解中的不同情况和子问题。
/*              Scale back. */

/* 调用 LAPACK 库中的 dlascl 函数，将数组 d__ 中的元素按比例缩放 */
dlascl_("G", &c__0, &c__0, &c_b1034, &orgnrm, &m, &c__1, &d__[
    start], &m, info);

} else {
/* 调用 LAPACK 库中的 dsteqr 函数，计算对称三对角矩阵的特征值和特征向量 */
dsteqr_("I", &m, &d__[start], &e[start], &rwork[1], &m, &
    rwork[m * m + 1], info);
/* 将复数矩阵 z__ 与实数矩阵 rwork 进行乘积，结果存储在 work 中 */
zlacrm_(n, &m, &z__[start * z_dim1 + 1], ldz, &rwork[1], &m, &
    work[1], n, &rwork[m * m + 1]);
/* 将矩阵 work 复制到 z__ 中对应位置 */
zlacpy_("A", n, &m, &work[1], n, &z__[start * z_dim1 + 1],
    ldz);
if (*info > 0) {
    /* 计算错误信息的索引并跳转到 L70 处处理 */
    *info = start * (*n + 1) + finish;
    goto L70;
}
}

start = finish + 1;
goto L30;
}

/*
      endwhile

      If the problem split any number of times, then the eigenvalues
      will not be properly ordered.  Here we permute the eigenvalues
      (and the associated eigenvectors) into ascending order.
*/

if (m != *n) {

/*           Use Selection Sort to minimize swaps of eigenvectors */

/* 使用选择排序算法将特征值及其对应的特征向量按升序排列 */
i__1 = *n;
for (ii = 2; ii <= i__1; ++ii) {
i__ = ii - 1;
k = i__;
p = d__[i__];
i__2 = *n;
for (j = ii; j <= i__2; ++j) {
    if (d__[j] < p) {
    k = j;
    p = d__[j];
    }
/* L50: */
}
if (k != i__) {
    d__[k] = d__[i__];
    d__[i__] = p;
    /* 交换 z__ 中对应列的特征向量 */
    zswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1
        + 1], &c__1);
}
/* L60: */
}
}
}

L70:
/* 初始化工作空间中的第一个元素为 lwmin，rwork 和 iwork 的第一个元素分别为 lrwmin 和 liwmin */
work[1].r = (doublereal) lwmin, work[1].i = 0.;
rwork[1] = (doublereal) lrwmin;
iwork[1] = liwmin;

return 0;

/*     End of ZSTEDC */

} /* zstedc_ */

/* Subroutine */ int zsteqr_(char *compz, integer *n, doublereal *d__,
doublereal *e, doublecomplex *z__, integer *ldz, doublereal *work,
integer *info)
{
/* System generated locals */
integer z_dim1, z_offset, i__1, i__2;
doublereal d__1, d__2;

/* Local variables */
static doublereal b, c__, f, g;
static integer i__, j, k, l, m;
static doublereal p, r__, s;
static integer l1, ii, mm, lm1, mm1, nm1;
static doublereal rt1, rt2, eps;
static integer lsv;
static doublereal tst, eps2;
static integer lend, jtot;
extern /* Subroutine */ int dlae2_(doublereal *, doublereal *, doublereal
*, doublereal *, doublereal *);
extern logical lsame_(char *, char *);
static doublereal anorm;
extern /* Subroutine */ int zlasr_(char *, char *, char *, integer *,
integer *, doublereal *, doublereal *, doublecomplex *, integer *), zswap_(integer *, doublecomplex *,
integer *, doublecomplex *, integer *), dlaev2_(doublereal *,
doublereal *, doublereal *, doublereal *, doublereal *,
doublereal *, doublereal *);
static integer lendm1, lendp1;

static integer iscale;
extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
doublereal *, doublereal *, integer *, integer *, doublereal *,
integer *, integer *);
    # 定义静态变量，存储计算机浮点数的最小值和最大值
    static doublereal safmin;
    static doublereal safmax;
    
    # 外部函数声明：dlartg_, xerbla_, dlanst_, dlasrt_, zlaset_
    extern /* Subroutine */ int dlartg_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *,
        integer *);
    extern /* Subroutine */ int zlaset_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, doublecomplex *, integer *);
    
    # 静态变量声明：lendsv, nmaxit, icompz, ssfmin, ssfmax
    static integer lendsv;
    static integer nmaxit, icompz;
    static doublereal ssfmin;
    static doublereal ssfmax;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the implicit QL or QR method.
    The eigenvectors of a full or band complex Hermitian matrix can also
    be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
    matrix to tridiagonal form.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    Hermitian matrix.  On entry, Z must contain the
                    unitary matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    Z       (input/output) COMPLEX*16 array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).

    WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is unitarily similar to the original
                  matrix.

    =====================================================================


       Test the input parameters.
*/
    /* Parameter adjustments */
    /* 参数调整 */

    --d__;
    --e;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    /* 函数体开始 */

    *info = 0;

    if (lsame_(compz, "N")) {
    /* 检查是否需要计算特征向量 */
    icompz = 0;
    } else if (lsame_(compz, "V")) {
    /* 计算所有特征向量 */
    icompz = 1;
    } else if (lsame_(compz, "I")) {
    /* 计算部分特征向量 */
    icompz = 2;
    } else {
    /* compz 参数错误 */
    icompz = -1;
    }
    if (icompz < 0) {
    /* 如果 icompz 小于 0，设置错误码 */
    *info = -1;
    } else if (*n < 0) {
    /* 如果 n 小于 0，设置错误码 */
    *info = -2;
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {
    /* 检查 ldz 参数是否有效 */
    *info = -6;
    }
    if (*info != 0) {
    /* 如果存在错误，调用错误处理函数并返回 */
    i__1 = -(*info);
    xerbla_("ZSTEQR", &i__1);
    return 0;
    }
/*     Quick return if possible */
// 如果 n 等于 0，则快速返回
if (*n == 0) {
return 0;
}

// 如果 n 等于 1
if (*n == 1) {
// 如果 icompz 等于 2，设置第一个元素为 (1, 0)
if (icompz == 2) {
    i__1 = z_dim1 + 1;
    z__[i__1].r = 1., z__[i__1].i = 0.;
}
// 快速返回
return 0;
}

/*     Determine the unit roundoff and over/underflow thresholds. */
// 计算单位舍入误差和上/下溢出阈值

eps = EPSILON;
/* Computing 2nd power */
// 计算 eps 的平方
d__1 = eps;
eps2 = d__1 * d__1;
safmin = SAFEMINIMUM;
safmax = 1. / safmin;
ssfmax = sqrt(safmax) / 3.;
ssfmin = sqrt(safmin) / eps2;

/*
   Compute the eigenvalues and eigenvectors of the tridiagonal
   matrix.
*/
// 计算三对角矩阵的特征值和特征向量

if (icompz == 2) {
// 如果 icompz 等于 2，初始化 z__ 矩阵为全零矩阵
zlaset_("Full", n, n, &c_b56, &c_b57, &z__[z_offset], ldz);
}

nmaxit = *n * 30;
jtot = 0;

/*
   Determine where the matrix splits and choose QL or QR iteration
   for each block, according to whether top or bottom diagonal
   element is smaller.
*/
// 确定矩阵的分裂点，并根据顶部或底部对角线元素的大小选择 QL 或 QR 迭代

l1 = 1;
nm1 = *n - 1;

L10:
if (l1 > *n) {
goto L160;
}
if (l1 > 1) {
e[l1 - 1] = 0.;
}
if (l1 <= nm1) {
i__1 = nm1;
for (m = l1; m <= i__1; ++m) {
    tst = (d__1 = e[m], abs(d__1));
    if (tst == 0.) {
    goto L30;
    }
    if (tst <= sqrt((d__1 = d__[m], abs(d__1))) * sqrt((d__2 = d__[m
        + 1], abs(d__2))) * eps) {
    e[m] = 0.;
    goto L30;
    }
    /* L20: */
}
}
m = *n;

L30:
l = l1;
lsv = l;
lend = m;
lendsv = lend;
l1 = m + 1;
if (lend == l) {
goto L10;
}

/*     Scale submatrix in rows and columns L to LEND */
// 缩放子矩阵的行和列从 L 到 LEND

i__1 = lend - l + 1;
anorm = dlanst_("I", &i__1, &d__[l], &e[l]);
iscale = 0;
if (anorm == 0.) {
goto L10;
}
if (anorm > ssfmax) {
iscale = 1;
i__1 = lend - l + 1;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n,
    info);
i__1 = lend - l;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n,
    info);
} else if (anorm < ssfmin) {
iscale = 2;
i__1 = lend - l + 1;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n,
    info);
i__1 = lend - l;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n,
    info);
}

/*     Choose between QL and QR iteration */
// 根据 d__ 数组的第 l 和 lend 元素的大小选择 QL 或 QR 迭代方法

if ((d__1 = d__[lend], abs(d__1)) < (d__2 = d__[l], abs(d__2))) {
lend = lsv;
l = lendsv;
}

if (lend > l) {

/*
      QL Iteration

      Look for small subdiagonal element.
*/
// QL 迭代，寻找小的次对角元素

L40:
if (l != lend) {
lendm1 = lend - 1;
i__1 = lendm1;
for (m = l; m <= i__1; ++m) {
/* Computing 2nd power */
d__2 = (d__1 = e[m], abs(d__1));
tst = d__2 * d__2;
if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m
    + 1], abs(d__2)) + safmin) {
    goto L60;
}
/* L50: */
}
}

m = lend;

L60:
if (m < lend) {
e[m] = 0.;
}
p = d__[l];
if (m == l) {
goto L80;
}
/*
          If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
          to compute its eigensystem.
*/
if (m == l + 1) {
    if (icompz > 0) {
        // 使用 DLAEV2 或 SLAEV2 计算二阶子矩阵的特征系统
        dlaev2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2, &c__, &s);
        // 保存旋转参数用于后续计算特征向量
        work[l] = c__;
        work[*n - 1 + l] = s;
        // 应用旋转到 Z 矩阵的部分列
        zlasr_("R", "V", "B", n, &c__2, &work[l], &work[*n - 1 + l], &
            z__[l * z_dim1 + 1], ldz);
    } else {
        // 使用 DLAE2 计算二阶子矩阵的特征值
        dlae2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2);
    }
    // 更新特征值和超对角元素
    d__[l] = rt1;
    d__[l + 1] = rt2;
    e[l] = 0.;
    l += 2;
    if (l <= lend) {
        goto L40;
    }
    goto L140;
}

if (jtot == nmaxit) {
    goto L140;
}
++jtot;

/*        Form shift. */

g = (d__[l + 1] - p) / (e[l] * 2.);
r__ = dlapy2_(&g, &c_b1034);
g = d__[m] - p + e[l] / (g + d_sign(&r__, &g));

s = 1.;
c__ = 1.;
p = 0.;

/*        Inner loop */

mm1 = m - 1;
i__1 = l;
for (i__ = mm1; i__ >= i__1; --i__) {
    f = s * e[i__];
    b = c__ * e[i__];
    // 计算 Givens 旋转
    dlartg_(&g, &f, &c__, &s, &r__);
    if (i__ != m - 1) {
        e[i__ + 1] = r__;
    }
    g = d__[i__ + 1] - p;
    r__ = (d__[i__] - g) * s + c__ * 2. * b;
    p = s * r__;
    d__[i__ + 1] = g + p;
    g = c__ * r__ - b;

    /* 
       如果需要计算特征向量，则保存旋转参数。
       这里的 icompz > 0 表示需要计算特征向量。
    */
    if (icompz > 0) {
        work[i__] = c__;
        work[*n - 1 + i__] = -s;
    }
}

/*        如果需要计算特征向量，则应用保存的旋转。 */
if (icompz > 0) {
    mm = m - l + 1;
    zlasr_("R", "V", "B", n, &mm, &work[l], &work[*n - 1 + l], &z__[l
        * z_dim1 + 1], ldz);
}

d__[l] -= p;
e[l] = g;
goto L40;

/*        Eigenvalue found. */

L80:
d__[l] = p;

++l;
if (l <= lend) {
    goto L40;
}
goto L140;

} else {

/*
          QR Iteration

          Look for small superdiagonal element.
*/
L90:
if (l != lend) {
    lendp1 = lend + 1;
    i__1 = lendp1;
    for (m = l; m >= i__1; --m) {
        // 检查超对角元素是否足够小，以便进行 QR 迭代
        /* Computing 2nd power */
        d__2 = (d__1 = e[m - 1], abs(d__1));
        tst = d__2 * d__2;
        if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m
            - 1], abs(d__2)) + safmin) {
            goto L110;
        }
    }
}

m = lend;

L110:
if (m > lend) {
    e[m - 1] = 0.;
}
p = d__[l];
if (m == l) {
    goto L130;
}

/*
          If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
          to compute its eigensystem.
*/
    # 检查是否当前索引 m 等于 l - 1
    if (m == l - 1) {
        # 如果需要计算特征向量(icompz > 0)，调用 dlaev2_ 计算特征值
        if (icompz > 0) {
            # 调用 dlaev2_ 计算特征值和旋转参数
            dlaev2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2, &c__, &s);
            # 将计算得到的旋转参数 c 和 s 存入 work 数组中
            work[m] = c__;
            work[*n - 1 + m] = s;
            # 使用 zlasr_ 对矩阵 Z 进行右乘旋转变换
            zlasr_("R", "V", "F", n, &c__2, &work[m], &work[*n - 1 + m], &
                z__[(l - 1) * z_dim1 + 1], ldz);
        } else {
            # 调用 dlae2_ 计算特征值，不计算特征向量
            dlae2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2);
        }
        # 更新数组 d__ 中的特征值
        d__[l - 1] = rt1;
        d__[l] = rt2;
        # 将 e 数组中的对角线以下元素置零
        e[l - 1] = 0.;
        # 减小 l 的值，以处理下一个特征值对
        l += -2;
        # 检查 l 是否仍然大于等于 lend，如果是则跳转到标签 L90 处
        if (l >= lend) {
            goto L90;
        }
        # 否则跳转到标签 L140 处
        goto L140;
    }

    # 检查是否达到最大迭代次数 jtot == nmaxit
    if (jtot == nmaxit) {
        # 如果达到最大迭代次数，则跳转到标签 L140 处
        goto L140;
    }
    # 否则增加 jtot 的值，继续迭代
    ++jtot;
/*        Form shift. */
/* 形成位移 */

    g = (d__[l - 1] - p) / (e[l - 1] * 2.);
    r__ = dlapy2_(&g, &c_b1034);
    g = d__[m] - p + e[l - 1] / (g + d_sign(&r__, &g));

    s = 1.;
    c__ = 1.;
    p = 0.;

/*        Inner loop */
/* 内部循环 */

    lm1 = l - 1;
    i__1 = lm1;
    for (i__ = m; i__ <= i__1; ++i__) {
        f = s * e[i__];
        b = c__ * e[i__];
        dlartg_(&g, &f, &c__, &s, &r__);
        if (i__ != m) {
        e[i__ - 1] = r__;
        }
        g = d__[i__] - p;
        r__ = (d__[i__ + 1] - g) * s + c__ * 2. * b;
        p = s * r__;
        d__[i__] = g + p;
        g = c__ * r__ - b;

/*           If eigenvectors are desired, then save rotations. */
/* 如果需要特征向量，则保存旋转 */

        if (icompz > 0) {
        work[i__] = c__;
        work[*n - 1 + i__] = s;
        }

/* L120: */
    }

/*        If eigenvectors are desired, then apply saved rotations. */
/* 如果需要特征向量，则应用保存的旋转 */

    if (icompz > 0) {
        mm = l - m + 1;
        zlasr_("R", "V", "F", n, &mm, &work[m], &work[*n - 1 + m], &z__[m
            * z_dim1 + 1], ldz);
    }

    d__[l] -= p;
    e[lm1] = g;
    goto L90;

/*        Eigenvalue found. */
/* 找到特征值 */

L130:
    d__[l] = p;

    --l;
    if (l >= lend) {
        goto L90;
    }
    goto L140;

    }

/*     Undo scaling if necessary */
/* 必要时取消缩放 */

L140:
    if (iscale == 1) {
    i__1 = lendsv - lsv + 1;
    dlascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv],
        n, info);
    i__1 = lendsv - lsv;
    dlascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &e[lsv], n,
        info);
    } else if (iscale == 2) {
    i__1 = lendsv - lsv + 1;
    dlascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv],
        n, info);
    i__1 = lendsv - lsv;
    dlascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &e[lsv], n,
        info);
    }

/*
       Check for no convergence to an eigenvalue after a total
       of N*MAXIT iterations.
*/
/* 检查在总共 N*MAXIT 次迭代后是否没有收敛到一个特征值 */

    if (jtot == nmaxit) {
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (e[i__] != 0.) {
        ++(*info);
        }
/* L150: */
    }
    return 0;
    }
    goto L10;

/*     Order eigenvalues and eigenvectors. */
/* 对特征值和特征向量排序 */

L160:
    if (icompz == 0) {

/*        Use Quick Sort */
/* 使用快速排序 */

    dlasrt_("I", n, &d__[1], info);

    } else {

/*        Use Selection Sort to minimize swaps of eigenvectors */
/* 使用选择排序来最小化特征向量的交换 */

    i__1 = *n;
    for (ii = 2; ii <= i__1; ++ii) {
        i__ = ii - 1;
        k = i__;
        p = d__[i__];
        i__2 = *n;
        for (j = ii; j <= i__2; ++j) {
        if (d__[j] < p) {
            k = j;
            p = d__[j];
        }
/* L170: */
        }
        if (k != i__) {
        d__[k] = d__[i__];
        d__[i__] = p;
        zswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1 + 1],
             &c__1);
        }
/* L180: */
    }
    }
    return 0;

/*     End of ZSTEQR */
/* ZSTEQR 结束 */

} /* zsteqr_ */

/* Subroutine */ int ztrevc_(char *side, char *howmny, logical *select,
    integer *n, doublecomplex *t, integer *ldt, doublecomplex *vl,
    integer *ldvl, doublecomplex *vr, integer *ldvr, integer *mm, integer
    *m, doublecomplex *work, doublereal *rwork, integer *info)


# 定义一个包含多个输入参数的 Fortran 函数签名

ldvl: integer*，指向左特征向量矩阵的列数的指针
vr: doublecomplex*，指向右特征向量矩阵的数据的指针
ldvr: integer*，指向右特征向量矩阵的列数的指针
mm: integer，指定矩阵的最大维数
m: integer*，指向特征值数组的长度的指针
work: doublecomplex*，指向工作空间数组的指针，用于内部计算
rwork: doublereal*，指向双精度实数工作空间的指针，用于内部计算
info: integer*，返回函数执行状态信息的指针
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
        i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3;
    doublecomplex z__1, z__2;

    /* Local variables */
    static integer i__, j, k, ii, ki, is;  /* 定义整型变量 */
    static doublereal ulp;  /* 机器精度 */
    static logical allv;  /* 是否计算所有的特征向量 */
    static doublereal unfl, ovfl, smin;  /* 最小浮点数、最大浮点数、最小奇异值 */
    static logical over;  /* 是否出现溢出 */
    static doublereal scale;  /* 缩放因子 */
    extern logical lsame_(char *, char *);  /* 外部函数 lsame_ 的声明 */
    static doublereal remax;  /* 最大残差 */
    static logical leftv, bothv;  /* 是否计算左特征向量、同时计算左右特征向量 */
    extern /* Subroutine */ int zgemv_(char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *, doublecomplex *, doublecomplex *, integer *);  /* 外部子程序 zgemv_ 的声明 */
    static logical somev;  /* 是否计算部分特征向量 */
    extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *), dlabad_(doublereal *, doublereal *);  /* 外部子程序 zcopy_, dlabad_ 的声明 */

    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
        integer *, doublereal *, doublecomplex *, integer *);  /* 外部子程序 xerbla_, zdscal_ 的声明 */
    extern integer izamax_(integer *, doublecomplex *, integer *);  /* 外部函数 izamax_ 的声明 */
    static logical rightv;  /* 是否计算右特征向量 */
    extern doublereal dzasum_(integer *, doublecomplex *, integer *);  /* 外部函数 dzasum_ 的声明 */
    static doublereal smlnum;  /* 最小数字 */
    extern /* Subroutine */ int zlatrs_(char *, char *, char *, char *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublereal *, doublereal *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZTREVC computes some or all of the right and/or left eigenvectors of
    a complex upper triangular matrix T.
    Matrices of this type are produced by the Schur factorization of
    a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.

    The right eigenvector x and the left eigenvector y of T corresponding
    to an eigenvalue w are defined by:

                 T*x = w*x,     (y**H)*T = w*(y**H)

    where y**H denotes the conjugate transpose of the vector y.
    The eigenvalues are not input to this routine, but are read directly
    from the diagonal of T.

    This routine returns the matrices X and/or Y of right and left
    eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
    input matrix.  If Q is the unitary factor that reduces a matrix A to
    Schur form T, then Q*X and Q*Y are the matrices of right and left
    eigenvectors of A.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
    ! 输入参数 HOWMNY 控制计算哪些特征向量
    ! 'A': 计算所有右/左特征向量；
    ! 'B': 计算所有右/左特征向量，并使用提供的矩阵 VR 和/或 VL 进行逆变换；
    ! 'S': 根据逻辑数组 SELECT 计算选定的右/左特征向量。
    CHARACTER*1 HOWMNY

    ! 输入参数，逻辑数组，维度为 N，用于指定要计算的特征向量
    ! 当 HOWMNY = 'S' 时使用，SELECT(j) = .TRUE. 表示计算第 j 个特征值对应的特征向量
    LOGICAL SELECT(N)

    ! 输入参数，矩阵 T 的阶数，要求 N >= 0
    INTEGER N

    ! 输入/输出参数，复双精度数组，维度为 (LDT,N)，存储上三角矩阵 T
    COMPLEX*16 T(LDT,N)

    ! 输入参数，数组 T 的第一维度
    INTEGER LDT

    ! 输入/输出参数，复双精度数组，维度为 (LDVL,MM)
    ! SIDE = 'L' 或 'B' 且 HOWMNY = 'B' 时，VL 必须包含 N×N 的矩阵 Q
    ! SIDE = 'L' 时，根据 HOWMNY 的不同返回不同的左特征向量矩阵
    ! SIDE = 'B' 时，根据 HOWMNY 的不同进行逆变换或返回选定的左特征向量
    COMPLEX*16 VL(LDVL,MM)

    ! 输入参数，数组 VL 的第一维度
    INTEGER LDVL

    ! 输入/输出参数，复双精度数组，维度为 (LDVR,MM)
    ! SIDE = 'R' 或 'B' 且 HOWMNY = 'B' 时，VR 必须包含 N×N 的矩阵 Q
    ! SIDE = 'R' 时，根据 HOWMNY 的不同返回不同的右特征向量矩阵
    ! SIDE = 'B' 时，根据 HOWMNY 的不同进行逆变换或返回选定的右特征向量
    COMPLEX*16 VR(LDVR,MM)

    ! 输入参数，数组 VR 的第一维度
    INTEGER LDVR

    ! 输入参数，数组 VL 和 VR 的列数，要求 MM >= M
    INTEGER MM
    M       (output) INTEGER
            实际用于存储特征向量的 VL 和/或 VR 数组的列数。如果 HOWMNY = 'A' 或 'B'，则 M 被设为 N。每个选定的特征向量占据一列。

    WORK    (workspace) COMPLEX*16 array, dimension (2*N)
            工作空间，用于存储复数类型的数组，大小为 2*N。

    RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
            工作空间，用于存储双精度浮点数类型的数组，大小为 N。

    INFO    (output) INTEGER
            输出参数:
            = 0:  成功退出
            < 0:  如果 INFO = -i，则第 i 个参数具有非法值

    Further Details
    ===============

    The algorithm used in this program is basically backward (forward)
    substitution, with scaling to make the code robust against
    possible overflow.

    深入细节
    ===============

    本程序中使用的算法基本上是反向（前向）替换，通过缩放使代码对可能的溢出具有鲁棒性。

    每个特征向量被归一化，使得具有最大幅度的元素的幅度为 1；这里复数（x，y）的幅度被认为是 |x| + |y|。

    =====================================================================


       Decode and test the input parameters
    解码和测试输入参数
    /* Parameter adjustments */
    --select;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;
    --rwork;

    /* Function Body */
    bothv = lsame_(side, "B");
    rightv = lsame_(side, "R") || bothv;
    leftv = lsame_(side, "L") || bothv;

    allv = lsame_(howmny, "A");
    over = lsame_(howmny, "B");
    somev = lsame_(howmny, "S");

    /*
       Set M to the number of columns required to store the selected
       eigenvectors.
    */
    if (somev) {
        *m = 0;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            if (select[j]) {
                ++(*m);
            }
            /* L10: */
        }
    } else {
        *m = *n;
    }

    *info = 0;
    if (! rightv && ! leftv) {
        *info = -1;
    } else if (! allv && ! over && ! somev) {
        *info = -2;
    } else if (*n < 0) {
        *info = -4;
    } else if (*ldt < max(1,*n)) {
        *info = -6;
    } else if (*ldvl < 1 || leftv && *ldvl < *n) {
        *info = -8;
    } else if (*ldvr < 1 || rightv && *ldvr < *n) {
        *info = -10;
    } else if (*mm < *m) {
        *info = -11;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZTREVC", &i__1);
        return 0;
    }

    /* Quick return if possible. */
    if (*n == 0) {
        return 0;
    }

    /* Set the constants to control overflow. */
    unfl = SAFEMINIMUM;
    ovfl = 1. / unfl;
    dlabad_(&unfl, &ovfl);
    ulp = PRECISION;
    smlnum = unfl * (*n / ulp);

    /* Store the diagonal elements of T in working array WORK. */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + *n;
        i__3 = i__ + i__ * t_dim1;
        work[i__2].r = t[i__3].r, work[i__2].i = t[i__3].i;
        /* L20: */
    }

    /*
       Compute 1-norm of each column of strictly upper triangular
       part of T to control overflow in triangular solver.
    */
    rwork[1] = 0.;
    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
        i__2 = j - 1;
        rwork[j] = dzasum_(&i__2, &t[j * t_dim1 + 1], &c__1);
        /* L30: */
    }

    if (rightv) {

        /* Compute right eigenvectors. */

        is = *m;
        for (ki = *n; ki >= 1; --ki) {

            if (somev) {
                if (! select[ki]) {
                    goto L80;
                }
            }
            /* Computing MAX */
            i__1 = ki + ki * t_dim1;
            d__3 = ulp * ((d__1 = t[i__1].r, abs(d__1)) + (d__2 = d_imag(&t[
                ki + ki * t_dim1]), abs(d__2)));
            smin = max(d__3,smlnum);

            work[1].r = 1., work[1].i = 0.;

            /* Form right-hand side. */
            i__1 = ki - 1;
            for (k = 1; k <= i__1; ++k) {
                i__2 = k;
                i__3 = k + ki * t_dim1;
                z__1.r = -t[i__3].r, z__1.i = -t[i__3].i;
                work[i__2].r = z__1.r, work[i__2].i = z__1.i;
                /* L40: */
            }
            /* 
               Solve the triangular system:
               (T(1:KI-1,1:KI-1) - T(KI,KI))*X = SCALE*WORK.
            */
            /* L50: */
L80:
            ;
        }
    }
        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
        i__2 = k + k * t_dim1;
        i__3 = k + k * t_dim1;
        i__4 = ki + ki * t_dim1;
        z__1.r = t[i__3].r - t[i__4].r, z__1.i = t[i__3].i - t[i__4]
            .i;
        t[i__2].r = z__1.r, t[i__2].i = z__1.i;
        i__2 = k + k * t_dim1;
        if ((d__1 = t[i__2].r, abs(d__1)) + (d__2 = d_imag(&t[k + k *
            t_dim1]), abs(d__2)) < smin) {
            i__3 = k + k * t_dim1;
            t[i__3].r = smin, t[i__3].i = 0.;
        }
/* L50: */
        }

```        
        if (ki > 1) {
        i__1 = ki - 1;
        zlatrs_("Upper", "No transpose", "Non-unit", "Y", &i__1, &t[
            t_offset], ldt, &work[1], &scale, &rwork[1], info);
        i__1 = ki;
        work[i__1].r = scale, work[i__1].i = 0.;
        }


/*           Copy the vector x or Q*x to VR and normalize. */
        if (! over) {
        zcopy_(&ki, &work[1], &c__1, &vr[is * vr_dim1 + 1], &c__1);

        ii = izamax_(&ki, &vr[is * vr_dim1 + 1], &c__1);
        i__1 = ii + is * vr_dim1;
        remax = 1. / ((d__1 = vr[i__1].r, abs(d__1)) + (d__2 = d_imag(
            &vr[ii + is * vr_dim1]), abs(d__2)));
        zdscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);

        i__1 = *n;
        for (k = ki + 1; k <= i__1; ++k) {
            i__2 = k + is * vr_dim1;
            vr[i__2].r = 0., vr[i__2].i = 0.;
/* L60: */
        }
        } else {
        if (ki > 1) {
            i__1 = ki - 1;
            z__1.r = scale, z__1.i = 0.;
            zgemv_("N", n, &i__1, &c_b57, &vr[vr_offset], ldvr, &work[
                1], &c__1, &z__1, &vr[ki * vr_dim1 + 1], &c__1);
        }

        ii = izamax_(n, &vr[ki * vr_dim1 + 1], &c__1);
        i__1 = ii + ki * vr_dim1;
        remax = 1. / ((d__1 = vr[i__1].r, abs(d__1)) + (d__2 = d_imag(
            &vr[ii + ki * vr_dim1]), abs(d__2)));
        zdscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
        }


/*           Set back the original diagonal elements of T. */
        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
        i__2 = k + k * t_dim1;
        i__3 = k + *n;
        t[i__2].r = work[i__3].r, t[i__2].i = work[i__3].i;
/* L70: */
        }


        --is;
L80:
        ;
    }
    }


    if (leftv) {

/*        Compute left eigenvectors. */

    is = 1;
    i__1 = *n;
    for (ki = 1; ki <= i__1; ++ki) {

        if (somev) {
        if (! select[ki]) {
            goto L130;
        }
        }
/* Computing MAX */
        i__2 = ki + ki * t_dim1;
        d__3 = ulp * ((d__1 = t[i__2].r, abs(d__1)) + (d__2 = d_imag(&t[
            ki + ki * t_dim1]), abs(d__2)));
        smin = max(d__3,smlnum);

        i__2 = *n;
        work[i__2].r = 1., work[i__2].i = 0.;

/*           Form right-hand side. */

        i__2 = *n;
        for (k = ki + 1; k <= i__2; ++k) {
        i__3 = k;
        d_cnjg(&z__2, &t[ki + k * t_dim1]);
        z__1.r = -z__2.r, z__1.i = -z__2.i;
        work[i__3].r = z__1.r, work[i__3].i = z__1.i;
/* L90: */
        }

/*
             Solve the triangular system:
                (T(KI+1:N,KI+1:N) - T(KI,KI))'*X = SCALE*WORK.
*/

        i__2 = *n;
        // 循环遍历从 ki+1 到 n 的每个 k
        for (k = ki + 1; k <= i__2; ++k) {
            // 计算 T(k, k) - T(ki, ki)
            i__3 = k + k * t_dim1;
            i__4 = k + k * t_dim1;
            i__5 = ki + ki * t_dim1;
            z__1.r = t[i__4].r - t[i__5].r, z__1.i = t[i__4].i - t[i__5]
                .i;
            // 更新 T(k, k)
            t[i__3].r = z__1.r, t[i__3].i = z__1.i;
            // 如果新的 T(k, k) 小于预设的 smin，将其设置为 smin
            i__3 = k + k * t_dim1;
            if ((d__1 = t[i__3].r, abs(d__1)) + (d__2 = d_imag(&t[k + k *
                t_dim1]), abs(d__2)) < smin) {
                i__4 = k + k * t_dim1;
                t[i__4].r = smin, t[i__4].i = 0.;
            }
/* L100: */
        }

        // 如果 ki 小于 n，执行下面的操作
        if (ki < *n) {
            // 调用 zlatrs 函数解上三角系统
            i__2 = *n - ki;
            zlatrs_("Upper", "Conjugate transpose", "Non-unit", "Y", &
                i__2, &t[ki + 1 + (ki + 1) * t_dim1], ldt, &work[ki +
                1], &scale, &rwork[1], info);
            // 将 scale 存储在 work[ki] 中
            i__2 = ki;
            work[i__2].r = scale, work[i__2].i = 0.;
        }

/*           Copy the vector x or Q*x to VL and normalize. */

        // 如果不是 over 模式
        if (! over) {
            // 复制 work[ki] 到 vl[ki+is*vl_dim1]
            i__2 = *n - ki + 1;
            zcopy_(&i__2, &work[ki], &c__1, &vl[ki + is * vl_dim1], &c__1)
                ;

            // 寻找 vl[ki+is*vl_dim1] 中绝对值最大的元素的索引
            i__2 = *n - ki + 1;
            ii = izamax_(&i__2, &vl[ki + is * vl_dim1], &c__1) + ki - 1;
            // 计算归一化因子 remax
            i__2 = ii + is * vl_dim1;
            remax = 1. / ((d__1 = vl[i__2].r, abs(d__1)) + (d__2 = d_imag(
                &vl[ii + is * vl_dim1]), abs(d__2)));
            // 对 vl[ki+is*vl_dim1] 进行归一化
            i__2 = *n - ki + 1;
            zdscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);

            // 将 vl 中 ki-1 之前的元素置零
            i__2 = ki - 1;
            for (k = 1; k <= i__2; ++k) {
                i__3 = k + is * vl_dim1;
                vl[i__3].r = 0., vl[i__3].i = 0.;
/* L110: */
            }
        } else {
            // 如果 ki < n，执行下面的操作
            if (ki < *n) {
                // 计算 Q*work[ki+1]，结果存储在 vl[ki*vl_dim1+1]
                i__2 = *n - ki;
                z__1.r = scale, z__1.i = 0.;
                zgemv_("N", n, &i__2, &c_b57, &vl[(ki + 1) * vl_dim1 + 1],
                     ldvl, &work[ki + 1], &c__1, &z__1, &vl[ki *
                    vl_dim1 + 1], &c__1);
            }

            // 寻找 vl[ki*vl_dim1+1] 中绝对值最大的元素的索引
            ii = izamax_(n, &vl[ki * vl_dim1 + 1], &c__1);
            // 计算归一化因子 remax
            i__2 = ii + ki * vl_dim1;
            remax = 1. / ((d__1 = vl[i__2].r, abs(d__1)) + (d__2 = d_imag(
                &vl[ii + ki * vl_dim1]), abs(d__2)));
            // 对 vl[ki*vl_dim1+1] 进行归一化
            zdscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
        }

/*           Set back the original diagonal elements of T. */

        // 将工作区的内容复制回 T 的对角线元素
        i__2 = *n;
        for (k = ki + 1; k <= i__2; ++k) {
            i__3 = k + k * t_dim1;
            i__4 = k + *n;
            t[i__3].r = work[i__4].r, t[i__3].i = work[i__4].i;
/* L120: */
        }

        // 更新 is 的值
        ++is;
L130:
        ;
    }
    }

    // 返回函数执行成功
    return 0;

/*     End of ZTREVC */

} /* ztrevc_ */

/* Subroutine */ int ztrexc_(char *compq, integer *n, doublecomplex *t,
    integer *ldt, doublecomplex *q, integer *ldq, integer *ifst, integer *
    ilst, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer k, m1, m2, m3;
    # 定义静态变量 cs，用于存储某种浮点数值
    static doublereal cs;
    # 定义静态变量 t11, t22, sn, temp，分别为复数和复数操作中的临时变量
    static doublecomplex t11, t22, sn, temp;
    # 外部声明 zrot_ 子程序，用于执行复数旋转操作
    extern /* Subroutine */ int zrot_(integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublereal *, doublecomplex *);
    # 外部声明 lsame_ 函数，用于比较两个字符是否相同
    extern logical lsame_(char *, char *);
    # 定义静态逻辑变量 wantq，表示是否需要计算 Q 矩阵
    static logical wantq;
    # 外部声明 xerbla_ 子程序，用于处理错误情况
    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 外部声明 zlartg_ 子程序，用于计算 Givens 变换
    extern /* Subroutine */ int zlartg_(
        doublecomplex *, doublecomplex *, doublereal *, doublecomplex *,
        doublecomplex *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZTREXC reorders the Schur factorization of a complex matrix
    A = Q*T*Q**H, so that the diagonal element of T with row index IFST
    is moved to row ILST.

    The Schur form T is reordered by a unitary similarity transformation
    Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
    postmultplying it with Z.

    Arguments
    =========

    COMPQ   (input) CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input/output) COMPLEX*16 array, dimension (LDT,N)
            On entry, the upper triangular matrix T.
            On exit, the reordered upper triangular matrix.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            unitary transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    IFST    (input) INTEGER
    ILST    (input) INTEGER
            Specify the reordering of the diagonal elements of T:
            The element with row index IFST is moved to row ILST by a
            sequence of transpositions between adjacent elements.
            1 <= IFST <= N; 1 <= ILST <= N.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Decode and test the input parameters.
*/
    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;

    /* Function Body */
    *info = 0;  // Initialize INFO to indicate successful exit
    wantq = lsame_(compq, "V");  // Check if COMPQ is 'V'
    if (! lsame_(compq, "N") && ! wantq) {  // Check COMPQ validity
        *info = -1;  // Set INFO if COMPQ is neither 'V' nor 'N'
    } else if (*n < 0) {  // Check N validity
        *info = -2;  // Set INFO if N is less than 0
    } else if (*ldt < max(1,*n)) {  // Check LDT validity
        *info = -4;  // Set INFO if LDT is less than max(1,N)
    } else if (*ldq < 1 || wantq && *ldq < max(1,*n)) {  // Check LDQ validity
        *info = -6;  // Set INFO if LDQ is less than required
    } else if (*ifst < 1 || *ifst > *n) {  // Check IFST validity
        *info = -7;  // Set INFO if IFST is out of valid range
    } else if (*ilst < 1 || *ilst > *n) {  // Check ILST validity
        *info = -8;  // Set INFO if ILST is out of valid range
    }
    if (*info != 0) {  // If any parameter check failed
        i__1 = -(*info);
        xerbla_("ZTREXC", &i__1);  // Call error handler XERBLA
        return 0;  // Return indicating failure
    }

/*     Quick return if possible */

    if (*n == 1 || *ifst == *ilst) {  // If matrix order is 1 or IFST equals ILST
        return 0;  // Return indicating no reordering needed
    }

    if (*ifst < *ilst) {

/*        Move the IFST-th diagonal element forward down the diagonal. */

        m1 = 0;  // Initialize m1 for forward movement
        m2 = -1;  // Initialize m2 for forward movement
        m3 = 1;   // Initialize m3 for forward movement
    } else {
/* Move the IFST-th diagonal element backward up the diagonal. */
m1 = -1;
m2 = 0;
m3 = -1;
}

i__1 = *ilst + m2;
i__2 = m3;
for (k = *ifst + m1; i__2 < 0 ? k >= i__1 : k <= i__1; k += i__2) {

/* Interchange the k-th and (k+1)-th diagonal elements. */
i__3 = k + k * t_dim1;
t11.r = t[i__3].r, t11.i = t[i__3].i;
i__3 = k + 1 + (k + 1) * t_dim1;
t22.r = t[i__3].r, t22.i = t[i__3].i;

/* Determine the transformation to perform the interchange. */
z__1.r = t22.r - t11.r, z__1.i = t22.i - t11.i;
zlartg_(&t[k + (k + 1) * t_dim1], &z__1, &cs, &sn, &temp);

/* Apply transformation to the matrix T. */
if (k + 2 <= *n) {
    i__3 = *n - k - 1;
    zrot_(&i__3, &t[k + (k + 2) * t_dim1], ldt, &t[k + 1 + (k + 2) *
        t_dim1], ldt, &cs, &sn);
}
i__3 = k - 1;
d_cnjg(&z__1, &sn);
zrot_(&i__3, &t[k * t_dim1 + 1], &c__1, &t[(k + 1) * t_dim1 + 1], &
    c__1, &cs, &z__1);

i__3 = k + k * t_dim1;
t[i__3].r = t22.r, t[i__3].i = t22.i;
i__3 = k + 1 + (k + 1) * t_dim1;
t[i__3].r = t11.r, t[i__3].i = t11.i;

if (wantq) {

/* Accumulate transformation in the matrix Q. */
d_cnjg(&z__1, &sn);
zrot_(n, &q[k * q_dim1 + 1], &c__1, &q[(k + 1) * q_dim1 + 1], &
    c__1, &cs, &z__1);
}

/* L10: */
}

return 0;

/* End of ZTREXC */
} /* ztrexc_ */

/* Subroutine */ int ztrti2_(char *uplo, char *diag, integer *n,
    doublecomplex *a, integer *lda, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2;
doublecomplex z__1;

/* Local variables */
static integer j;
static doublecomplex ajj;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
    doublecomplex *, integer *);
static logical upper;
extern /* Subroutine */ int ztrmv_(char *, char *, char *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *);
static logical nounit;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

ZTRTI2 computes the inverse of a complex upper or lower triangular
matrix.

This is the Level 2 BLAS version of the algorithm.

Arguments
=========

UPLO    (input) CHARACTER*1
Specifies whether the matrix A is upper or lower triangular.
= 'U':  Upper triangular
= 'L':  Lower triangular

DIAG    (input) CHARACTER*1
Specifies whether or not the matrix A is unit triangular.
= 'N':  Non-unit triangular
= 'U':  Unit triangular

N       (input) INTEGER
The order of the matrix A.  N >= 0.
    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            输入/输出参数，复数双精度数组，维度为(LDA,N)
            在输入时，三角矩阵A。如果UPLO = 'U'，数组A的前n行前n列包含上三角部分，
            严格下三角部分不被引用。如果UPLO = 'L'，数组A的前n行前n列包含下三角部分，
            严格上三角部分不被引用。如果DIAG = 'U'，则假设对角元素为1，在计算过程中不会被引用。

            在输出时，存储格式相同的原始矩阵的（三角形）逆矩阵。

    LDA     (input) INTEGER
            数组A的主维度。LDA >= max(1,N)。

    INFO    (output) INTEGER
            返回状态信息：
            = 0：计算成功完成
            < 0：如果INFO = -k，第k个参数值非法

    =====================================================================


       Test the input parameters.
    # 参数调整
    a_dim1 = *lda; 
    a_offset = 1 + a_dim1; 
    a -= a_offset;

    # 函数体
    *info = 0; 
    upper = lsame_(uplo, "U"); 
    nounit = lsame_(diag, "N"); 

    # 检查上三角和下三角参数是否有效
    if (! upper && ! lsame_(uplo, "L")) { 
        *info = -1; 
    } else if (! nounit && ! lsame_(diag, "U")) { 
        *info = -2; 
    } else if (*n < 0) { 
        *info = -3; 
    } else if (*lda < max(1,*n)) { 
        *info = -5; 
    } 
    if (*info != 0) { 
        i__1 = -(*info); 
        xerbla_("ZTRTI2", &i__1); 
        return 0; 
    } 
    if (upper) { 
        # 计算上三角矩阵的逆矩阵
        i__1 = *n; 
        for (j = 1; j <= i__1; ++j) { 
            if (nounit) { 
                i__2 = j + j * a_dim1; 
                z_div(&z__1, &c_b57, &a[j + j * a_dim1]); 
                a[i__2].r = z__1.r, a[i__2].i = z__1.i; 
                i__2 = j + j * a_dim1; 
                z__1.r = -a[i__2].r, z__1.i = -a[i__2].i; 
                ajj.r = z__1.r, ajj.i = z__1.i; 
            } else { 
                z__1.r = -1., z__1.i = -0.; 
                ajj.r = z__1.r, ajj.i = z__1.i; 
            } 
            i__2 = j - 1; 
            ztrmv_("Upper", "No transpose", diag, &i__2, &a[a_offset], lda, &a[j * a_dim1 + 1], &c__1); 
            i__2 = j - 1; 
            zscal_(&i__2, &ajj, &a[j * a_dim1 + 1], &c__1); 
        } 
    } else { 
        # 计算下三角矩阵的逆矩阵
        for (j = *n; j >= 1; --j) { 
            if (nounit) { 
                i__1 = j + j * a_dim1; 
                z_div(&z__1, &c_b57, &a[j + j * a_dim1]); 
                a[i__1].r = z__1.r, a[i__1].i = z__1.i; 
                i__1 = j + j * a_dim1; 
                z__1.r = -a[i__1].r, z__1.i = -a[i__1].i; 
                ajj.r = z__1.r, ajj.i = z__1.i; 
            } else { 
                z__1.r = -1., z__1.i = -0.; 
                ajj.r = z__1.r, ajj.i = z__1.i; 
            } 
            if (j < *n) { 
                i__1 = *n - j; 
                ztrmv_("Lower", "No transpose", diag, &i__1, &a[j + 1 + (j + 1) * a_dim1], lda, &a[j + 1 + j * a_dim1], &c__1); 
                i__1 = *n - j; 
                zscal_(&i__1, &ajj, &a[j + 1 + j * a_dim1], &c__1); 
            } 
        } 
    }
    return 0;
}
    # 外部函数声明，声明了四个外部函数 ztrmm_, ztrsm_, ztrti2_, xerbla_
    extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *,
        integer *, integer *, doublecomplex *, doublecomplex *, integer *,
         doublecomplex *, integer *),
        ztrsm_(char *, char *, char *, char *, integer *, integer *,
        doublecomplex *, doublecomplex *, integer *, doublecomplex *,
        integer *), ztrti2_(char *, char *
        , integer *, doublecomplex *, integer *, integer *), xerbla_(char *, integer *);
    
    # 外部函数声明，声明了一个整型函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    # 静态逻辑变量声明，表示是否为单位矩阵
    static logical nounit;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZTRTRI computes the inverse of a complex upper or lower triangular
    matrix A.

    This is the Level 3 BLAS version of the algorithm.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.

    DIAG    (input) CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.

    =====================================================================


       Test the input parameters.
*/



    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    nounit = lsame_(diag, "N");

    // 检查 UPLO 的合法性
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! nounit && ! lsame_(diag, "U")) {
        // 检查 DIAG 的合法性
        *info = -2;
    } else if (*n < 0) {
        // 检查 N 的合法性
        *info = -3;
    } else if (*lda < max(1,*n)) {
        // 检查 LDA 的合法性
        *info = -5;
    }

    // 如果参数有误，调用错误处理程序并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZTRTRI", &i__1);
        return 0;
    }

    /* Quick return if possible */
    // 如果 N 为 0，直接返回
    if (*n == 0) {
        return 0;
    }

    /* Check for singularity if non-unit. */
    // 如果不是单位三角阵，检查是否有零元素在对角线上
    if (nounit) {
        i__1 = *n;
        for (*info = 1; *info <= i__1; ++(*info)) {
            i__2 = *info + *info * a_dim1;
            if (a[i__2].r == 0. && a[i__2].i == 0.) {
                return 0;
            }
            // L10:
        }
        *info = 0;
    }

    /*
       Determine the block size for this environment.

   Writing concatenation
*/
    // 确定适合当前环境的块大小
    i__3[0] = 1, a__1[0] = uplo;
    i__3[1] = 1, a__1[1] = diag;
    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);

将字符串数组 `a__1` 中的内容连接成一个字符串，并存储到字符数组 `ch__1` 中。


    nb = ilaenv_(&c__1, "ZTRTRI", ch__1, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)2);

调用 `ilaenv_` 函数，用于获取与特定环境参数相关的值。传递的参数包括：1 表示矩阵逆的算法类型，"ZTRTRI" 表示要解的问题类型，`ch__1` 是存储问题相关信息的字符数组，`n` 是矩阵的阶数，其它参数是默认值或不需要的参数。


    if (nb <= 1 || nb >= *n) {

检查 `nb` 的值是否小于等于 1 或大于等于 `*n` 的值。
/*        Use unblocked code */

    ztrti2_(uplo, diag, n, &a[a_offset], lda, info);
    } else {

/*        Use blocked code */

    if (upper) {

/*           Compute inverse of upper triangular matrix */

        i__1 = *n;
        i__2 = nb;
        for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
        i__4 = nb, i__5 = *n - j + 1;
        jb = min(i__4,i__5);

/*              Compute rows 1:j-1 of current block column */

        i__4 = j - 1;
        ztrmm_("Left", "Upper", "No transpose", diag, &i__4, &jb, &
            c_b57, &a[a_offset], lda, &a[j * a_dim1 + 1], lda);
        i__4 = j - 1;
        z__1.r = -1., z__1.i = -0.;
        ztrsm_("Right", "Upper", "No transpose", diag, &i__4, &jb, &
            z__1, &a[j + j * a_dim1], lda, &a[j * a_dim1 + 1],
            lda);

/*              Compute inverse of current diagonal block */

        ztrti2_("Upper", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L20: */
        }
    } else {

/*           Compute inverse of lower triangular matrix */

        nn = (*n - 1) / nb * nb + 1;
        i__2 = -nb;
        for (j = nn; i__2 < 0 ? j >= 1 : j <= 1; j += i__2) {
/* Computing MIN */
        i__1 = nb, i__4 = *n - j + 1;
        jb = min(i__1,i__4);
        if (j + jb <= *n) {

/*                 Compute rows j+jb:n of current block column */

            i__1 = *n - j - jb + 1;
            ztrmm_("Left", "Lower", "No transpose", diag, &i__1, &jb,
                &c_b57, &a[j + jb + (j + jb) * a_dim1], lda, &a[j
                + jb + j * a_dim1], lda);
            i__1 = *n - j - jb + 1;
            z__1.r = -1., z__1.i = -0.;
            ztrsm_("Right", "Lower", "No transpose", diag, &i__1, &jb,
                 &z__1, &a[j + j * a_dim1], lda, &a[j + jb + j *
                a_dim1], lda);
        }

/*              Compute inverse of current diagonal block */

        ztrti2_("Lower", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L30: */
        }
    }
    }

    return 0;

/*     End of ZTRTRI */

} /* ztrtri_ */

/* Subroutine */ int zung2r_(integer *m, integer *n, integer *k,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *), zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZUNG2R generates an m by n complex matrix Q with orthonormal columns,

/*     End of ZUNG2R */

} /* zung2r_ */


注释：
    # 测试输入参数的合法性
    # 检查矩阵 Q 的行数 M 必须大于等于 0
    # 检查矩阵 Q 的列数 N 必须大于等于 0，且不超过行数 M
    # 检查元素反射器的数量 K 必须大于等于 0，且不超过列数 N
    # 检查输入矩阵 A 的维度要求，第一维度必须大于等于 max(1, M)
    # 检查输入数组 TAU 的维度必须为 K
    # 工作空间数组 WORK 的维度为 N
    # 输出参数 INFO 用于指示函数的退出状态，0 表示成功退出，负数表示某个参数的值非法
    /* Parameter adjustments */
    // 将数组参数调整为指针形式
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 检查参数 m 是否小于 0
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0 || *n > *m) { // 检查参数 n 是否小于 0 或大于 m
        *info = -2;
    } else if (*k < 0 || *k > *n) { // 检查参数 k 是否小于 0 或大于 n
        *info = -3;
    } else if (*lda < max(1,*m)) { // 检查 lda 是否小于 max(1, m)
        *info = -5;
    }
    // 如果有错误信息，调用错误处理并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNG2R", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 如果 n <= 0，直接返回
    if (*n <= 0) {
        return 0;
    }

/*     Initialise columns k+1:n to columns of the unit matrix */

    // 将第 k+1 到 n 列初始化为单位矩阵的列
    i__1 = *n;
    for (j = *k + 1; j <= i__1; ++j) {
        i__2 = *m;
        for (l = 1; l <= i__2; ++l) {
            i__3 = l + j * a_dim1;
            // 设置矩阵元素为复数零
            a[i__3].r = 0., a[i__3].i = 0.;
/* L10: */
        }
        i__2 = j + j * a_dim1;
        // 设置对角线元素为复数一
        a[i__2].r = 1., a[i__2].i = 0.;
/* L20: */
    }

    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i) to A(i:m,i:n) from the left */

    // 将 H(i) 从左侧应用于 A(i:m,i:n)
    if (i__ < *n) {
        i__1 = i__ + i__ * a_dim1;
        // 设置对角线元素为复数一
        a[i__1].r = 1., a[i__1].i = 0.;
        // 计算 zlarf 所需的参数并调用它
        i__1 = *m - i__ + 1;
        i__2 = *n - i__;
        zlarf_("Left", &i__1, &i__2, &a[i__ + i__ * a_dim1], &c__1, &tau[
            i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
    }
    // 如果 i 小于 m，则继续处理
    if (i__ < *m) {
        i__1 = *m - i__;
        i__2 = i__;
        // 计算 zscal 所需的参数并调用它
        z__1.r = -tau[i__2].r, z__1.i = -tau[i__2].i;
        zscal_(&i__1, &z__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
    }
    i__1 = i__ + i__ * a_dim1;
    i__2 = i__;
    // 计算对角线元素值并赋给 A(i,i)
    z__1.r = 1. - tau[i__2].r, z__1.i = 0. - tau[i__2].i;
    a[i__1].r = z__1.r, a[i__1].i = z__1.i;

/*        Set A(1:i-1,i) to zero */

    // 将 A(1:i-1,i) 设置为零
    i__1 = i__ - 1;
    for (l = 1; l <= i__1; ++l) {
        i__2 = l + i__ * a_dim1;
        // 设置矩阵元素为复数零
        a[i__2].r = 0., a[i__2].i = 0.;
/* L30: */
    }
/* L40: */
    }
    // 返回正常退出
    return 0;

/*     End of ZUNG2R */

} /* zung2r_ */

/* Subroutine */ int zungbr_(char *vect, integer *m, integer *n, integer *k,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, nb, mn;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    static logical wantq;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer lwkopt;
    static logical lquery;
    extern /* Subroutine */ int zunglq_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *), zungqr_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    ! Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
    ! November 2006

    ! Purpose
    ! =======
    ! 
    ! ZUNGBR generates one of the complex unitary matrices Q or P**H
    ! determined by ZGEBRD when reducing a complex matrix A to bidiagonal
    ! form: A = Q * B * P**H. Q and P**H are defined as products of
    ! elementary reflectors H(i) or G(i) respectively.
    ! 
    ! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
    ! is of order M:
    ! if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
    ! columns of Q, where m >= n >= k;
    ! if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
    ! M-by-M matrix.
    ! 
    ! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
    ! is of order N:
    ! if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
    ! rows of P**H, where n >= m >= k;
    ! if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
    ! an N-by-N matrix.
    ! 
    ! Arguments
    ! =========
    ! 
    ! VECT    (input) CHARACTER*1
    !         Specifies whether the matrix Q or the matrix P**H is
    !         required, as defined in the transformation applied by ZGEBRD:
    !         = 'Q':  generate Q;
    !         = 'P':  generate P**H.
    ! 
    ! M       (input) INTEGER
    !         The number of rows of the matrix Q or P**H to be returned.
    !         M >= 0.
    ! 
    ! N       (input) INTEGER
    !         The number of columns of the matrix Q or P**H to be returned.
    !         N >= 0.
    !         If VECT = 'Q', M >= N >= min(M,K);
    !         if VECT = 'P', N >= M >= min(N,K).
    ! 
    ! K       (input) INTEGER
    !         If VECT = 'Q', the number of columns in the original M-by-K
    !         matrix reduced by ZGEBRD.
    !         If VECT = 'P', the number of rows in the original K-by-N
    !         matrix reduced by ZGEBRD.
    !         K >= 0.
    ! 
    ! A       (input/output) COMPLEX*16 array, dimension (LDA,N)
    !         On entry, the vectors which define the elementary reflectors,
    !         as returned by ZGEBRD.
    !         On exit, the M-by-N matrix Q or P**H.
    ! 
    ! LDA     (input) INTEGER
    !         The leading dimension of the array A. LDA >= M.
    ! 
    ! TAU     (input) COMPLEX*16 array, dimension
    !                               (min(M,K)) if VECT = 'Q'
    !                               (min(N,K)) if VECT = 'P'
    !         TAU(i) must contain the scalar factor of the elementary
    !         reflector H(i) or G(i), which determines Q or P**H, as
    !         returned by ZGEBRD in its array argument TAUQ or TAUP.
    ! 
    ! WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK. LWORK >= max(1,min(M,N)).
    #         For optimum performance LWORK >= min(M,N)*NB, where NB
    #         is the optimal blocksize.

    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value

    # =====================================================================

    # Test the input arguments
    /* 参数调整 */
    a_dim1 = *lda;  /* 获取 lda 的值，lda 是第一个维度的长度 */
    a_offset = 1 + a_dim1;  /* 计算 a 的偏移量 */
    a -= a_offset;  /* 调整 a 的起始地址 */
    --tau;  /* 将 tau 指针前移一个位置 */
    --work;  /* 将 work 指针前移一个位置 */

    /* 函数体 */
    *info = 0;  /* 初始化 info 为 0 */
    wantq = lsame_(vect, "Q");  /* 判断 vect 是否与 "Q" 相同，确定是否需要计算 Q */
    mn = min(*m,*n);  /* 计算 m 和 n 中的较小值 */
    lquery = *lwork == -1;  /* 检查是否为查询模式 */

    /* 检查输入参数的有效性 */
    if (! wantq && ! lsame_(vect, "P")) {  /* 如果既不需要计算 Q 也不需要计算 P' */
        *info = -1;  /* 设置错误码为 -1 */
    } else if (*m < 0) {  /* 如果 m 小于 0 */
        *info = -2;  /* 设置错误码为 -2 */
    } else if (*n < 0 || wantq && (*n > *m || *n < min(*m,*k)) || ! wantq && (
        *m > *n || *m < min(*n,*k))) {  /* 检查 m 和 n 的关系以及 k 的有效性 */
        *info = -3;  /* 设置错误码为 -3 */
    } else if (*k < 0) {  /* 如果 k 小于 0 */
        *info = -4;  /* 设置错误码为 -4 */
    } else if (*lda < max(1,*m)) {  /* 如果 lda 小于 1 和 m 中的最大值 */
        *info = -6;  /* 设置错误码为 -6 */
    } else if (*lwork < max(1,mn) && ! lquery) {  /* 如果 lwork 小于最小工作空间大小且非查询模式 */
        *info = -9;  /* 设置错误码为 -9 */
    }

    /* 如果参数检查通过，计算所需的工作空间大小 */
    if (*info == 0) {
        if (wantq) {
            nb = ilaenv_(&c__1, "ZUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (
                ftnlen)1);  /* 根据问题类型调用 ilaenv 计算工作空间大小 */
        } else {
            nb = ilaenv_(&c__1, "ZUNGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (
                ftnlen)1);  /* 根据问题类型调用 ilaenv 计算工作空间大小 */
        }
        lwkopt = max(1,mn) * nb;  /* 计算最优工作空间大小 */
        work[1].r = (doublereal) lwkopt, work[1].i = 0.;  /* 将结果写入 work 数组 */
    }

    /* 处理错误情况 */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNGBR", &i__1);  /* 调用 xerbla 处理错误 */
        return 0;  /* 返回 */
    } else if (lquery) {  /* 如果是查询模式 */
        return 0;  /* 直接返回 */
    }

/*     如果可能，快速返回 */

    if (*m == 0 || *n == 0) {  /* 如果 m 或 n 为 0 */
        work[1].r = 1., work[1].i = 0.;  /* 设置工作空间中的值 */
        return 0;  /* 返回 */
    }

    if (wantq) {

/*
          根据调用 ZGEBRD 函数后减少的 m-by-k 矩阵来形成 Q
*/

        if (*m >= *k) {

/*           如果 m >= k，则假设 m >= n >= k */

            zungqr_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  /* 调用 ZUNGQR 计算 Q 矩阵 */
        } else {

/*
             如果 m < k，则假设 m = n

             将定义反射变换的向量向右移动一列，并将 Q 的第一行和第一列设置为单位矩阵的值
*/

            for (j = *m; j >= 2; --j) {
                i__1 = j * a_dim1 + 1;
                a[i__1].r = 0., a[i__1].i = 0.;  /* 清除第一列的值 */
                i__1 = *m;
                for (i__ = j + 1; i__ <= i__1; ++i__) {
                    i__2 = i__ + j * a_dim1;
                    i__3 = i__ + (j - 1) * a_dim1;
                    a[i__2].r = a[i__3].r, a[i__2].i = a[i__3].i;  /* 向右移动向量 */
                }
            }
            i__1 = a_dim1 + 1;
            a[i__1].r = 1., a[i__1].i = 0.;  /* 设置第一行和第一列为单位矩阵 */
            i__1 = *m;
            for (i__ = 2; i__ <= i__1; ++i__) {
                i__2 = i__ + a_dim1;
                a[i__2].r = 0., a[i__2].i = 0.;  /* 清除其他行和列的值 */
            }
            if (*m > 1) {

/*              形成 Q(2:m,2:m) */

                i__1 = *m - 1;
                i__2 = *m - 1;
                i__3 = *m - 1;
                zungqr_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
                    1], &work[1], lwork, &iinfo);  /* 调用 ZUNGQR 计算 Q 的剩余部分 */
            }
        }
    } else {

/*
          根据调用 ZGEBRD 函数后减少的 k-by-n 矩阵来形成 P'
*/

        if (*k < *n) {

/*           如果 k < n，则假设 k <= m <= n */

            zunglq_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  /* 调用 ZUNGLQ 计算 P' 矩阵 */
        } else {
/*
             If k >= n, assume m = n

             Shift the vectors which define the elementary reflectors one
             row downward, and set the first row and column of P' to
             those of the unit matrix
*/

        i__1 = a_dim1 + 1;
        // 设置P'的第一行和第一列为单位矩阵的对应元素
        a[i__1].r = 1., a[i__1].i = 0.;
        i__1 = *n;
        for (i__ = 2; i__ <= i__1; ++i__) {
        i__2 = i__ + a_dim1;
        // 将定义元素反射器的向量向下移动一行，并将P'的第一行和第一列设置为单位矩阵的对应元素
        a[i__2].r = 0., a[i__2].i = 0.;
/* L40: */
        }
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
        for (i__ = j - 1; i__ >= 2; --i__) {
            i__2 = i__ + j * a_dim1;
            i__3 = i__ - 1 + j * a_dim1;
            // 将定义元素反射器的向量向下移动一行，并将P'的第一行和第一列设置为单位矩阵的对应元素
            a[i__2].r = a[i__3].r, a[i__2].i = a[i__3].i;
/* L50: */
        }
        i__2 = j * a_dim1 + 1;
        // 将定义元素反射器的向量向下移动一行，并将P'的第一行和第一列设置为单位矩阵的对应元素
        a[i__2].r = 0., a[i__2].i = 0.;
/* L60: */
        }
        if (*n > 1) {

/*              Form P'(2:n,2:n) */

        i__1 = *n - 1;
        i__2 = *n - 1;
        i__3 = *n - 1;
        // 生成P'(2:n,2:n)
        zunglq_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
            1], &work[1], lwork, &iinfo);
        }
    }
    }
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    // 返回值0表示成功
    return 0;

/*     End of ZUNGBR */

} /* zungbr_ */

/* Subroutine */ int zunghr_(integer *n, integer *ilo, integer *ihi,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, nb, nh, iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer lwkopt;
    static logical lquery;
    extern /* Subroutine */ int zungqr_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZUNGHR generates a complex unitary matrix Q which is defined as the
    product of IHI-ILO elementary reflectors of order N, as returned by
    ZGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix Q. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of ZGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.


*/
    ! Test the input arguments
    ! 测试输入参数

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by ZGEHRD.
            On exit, the N-by-N unitary matrix Q.
            ! 在输入时，包含 ZGEHRD 返回的基本反射器向量。
            ! 在输出时，存储 N×N 的酉矩阵 Q。

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,N).
            ! 数组 A 的主维度。必须满足 LDA >= max(1,N)。

    TAU     (input) COMPLEX*16 array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEHRD.
            ! TAU(i) 必须包含 ZGEHRD 返回的基本反射器 H(i) 的标量因子。

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            ! 在退出时，如果 INFO = 0，则 WORK(1) 返回最佳 LWORK 值。

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            ! WORK 数组的维度。要求 LWORK >= IHI-ILO 以获得最佳性能。
            ! 对于最佳性能，建议 LWORK >= (IHI-ILO)*NB，其中 NB 是最佳的块大小。
            ! 如果 LWORK = -1，则假定进行工作空间查询；程序只计算 WORK 数组的最佳尺寸，
            ! 并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会生成与 LWORK 相关的错误消息。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            ! 返回状态信息：
            ! = 0：成功完成
            ! < 0：如果 INFO = -i，则第 i 个参数具有非法值
/* Parameter adjustments */
/* 参数调整 */
a_dim1 = *lda;
/* a 的第一维度 */
a_offset = 1 + a_dim1;
/* a 的偏移量 */
a -= a_offset;
/* a 指针向前偏移 */
--tau;
/* tau 指针向前偏移 */
--work;
/* work 指针向前偏移 */

/* Function Body */
/* 函数体 */

*info = 0;
/* 初始化 info 为 0 */
nh = *ihi - *ilo;
/* 计算 nh = ihi - ilo */
lquery = *lwork == -1;
/* 判断是否是查询 lwork 的阶段 */

if (*n < 0) {
/* 如果 n 小于 0 */
*info = -1;
/* 将 info 设置为 -1 */
} else if (*ilo < 1 || *ilo > max(1,*n)) {
/* 或者如果 ilo 不在有效范围内 */
*info = -2;
/* 将 info 设置为 -2 */
} else if (*ihi < min(*ilo,*n) || *ihi > *n) {
/* 或者如果 ihi 不在有效范围内 */
*info = -3;
/* 将 info 设置为 -3 */
} else if (*lda < max(1,*n)) {
/* 或者如果 lda 小于 max(1,n) */
*info = -5;
/* 将 info 设置为 -5 */
} else if (*lwork < max(1,nh) && ! lquery) {
/* 或者如果 lwork 小于 max(1,nh) 且不在查询阶段 */
*info = -8;
/* 将 info 设置为 -8 */
}

if (*info == 0) {
/* 如果 info 仍然为 0 */
nb = ilaenv_(&c__1, "ZUNGQR", " ", &nh, &nh, &nh, &c_n1, (ftnlen)6, (ftnlen)1);
/* 调用 ilaenv 函数获取优化参数 nb */
lwkopt = max(1,nh) * nb;
/* 计算所需的最优 work 数组大小 */
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
/* 设置 work 数组的第一个元素为所需大小 */
}

if (*info != 0) {
/* 如果 info 不为 0 */
i__1 = -(*info);
/* 取 info 的负值 */
xerbla_("ZUNGHR", &i__1);
/* 调用 xerbla 函数报错 */
return 0;
/* 返回 0 */
} else if (lquery) {
/* 或者如果是在查询阶段 */
return 0;
/* 直接返回 0 */
}

/* Quick return if possible */
/* 如果可能，快速返回 */

if (*n == 0) {
/* 如果 n 等于 0 */
work[1].r = 1., work[1].i = 0.;
/* 设置 work 数组的第一个元素为 1 */
return 0;
/* 返回 0 */
}

/*
   Shift the vectors which define the elementary reflectors one
   column to the right, and set the first ilo and the last n-ihi
   rows and columns to those of the unit matrix
*/
/*
   将定义初等反射器的向量向右移动一列，并将第一个 ilo 和最后的 n-ihi
   行和列设置为单位矩阵的值
*/

i__1 = *ilo + 1;
/* 设置循环的起始点 */
for (j = *ihi; j >= i__1; --j) {
/* 循环 j 从 ihi 到 ilo+1 */
    i__2 = j - 1;
    /* 设置循环的结束点 */
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 循环 i 从 1 到 j-1 */
        i__3 = i__ + j * a_dim1;
        /* 计算索引 */
        a[i__3].r = 0., a[i__3].i = 0.;
        /* 设置 a 的值为 0 */
/* L10: */
    }
    /* 设置标签 */
    i__2 = *ihi;
    /* 设置循环的结束点 */
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        /* 循环 i 从 j+1 到 ihi */
        i__3 = i__ + j * a_dim1;
        /* 计算索引 */
        i__4 = i__ + (j - 1) * a_dim1;
        /* 计算索引 */
        a[i__3].r = a[i__4].r, a[i__3].i = a[i__4].i;
        /* 设置 a 的值为上一列的值 */
/* L20: */
    }
    /* 设置标签 */
    i__2 = *n;
    /* 设置循环的结束点 */
    for (i__ = *ihi + 1; i__ <= i__2; ++i__) {
        /* 循环 i 从 ihi+1 到 n */
        i__3 = i__ + j * a_dim1;
        /* 计算索引 */
        a[i__3].r = 0., a[i__3].i = 0.;
        /* 设置 a 的值为 0 */
/* L30: */
    }
    /* 设置标签 */
/* L40: */
}
/* 设置标签 */

i__1 = *ilo;
/* 设置循环的结束点 */
for (j = 1; j <= i__1; ++j) {
    /* 循环 j 从 1 到 ilo */
    i__2 = *n;
    /* 设置循环的结束点 */
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 循环 i 从 1 到 n */
        i__3 = i__ + j * a_dim1;
        /* 计算索引 */
        a[i__3].r = 0., a[i__3].i = 0.;
        /* 设置 a 的值为 0 */
/* L50: */
    }
    /* 设置标签 */
    i__2 = j + j * a_dim1;
    /* 计算索引 */
    a[i__2].r = 1., a[i__2].i = 0.;
    /* 设置 a 的值为单位矩阵的值 */
/* L60: */
}
/* 设置标签 */

i__1 = *n;
/* 设置循环的结束点 */
for (j = *ihi + 1; j <= i__1; ++j) {
    /* 循环 j 从 ihi+1 到 n */
    i__2 = *n;
    /* 设置循环的结束点 */
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 循环 i 从 1 到 n */
        i__3 = i__ + j * a_dim1;
        /* 计算索引 */
        a[i__3].r = 0., a[i__3].i = 0.;
        /* 设置 a 的值为 0 */
/* L70: */
    }
    /* 设置标签 */
    i__2 = j + j * a_dim1;
    /* 计算索引 */
    a[i__2].r = 1., a[i__2].i = 0.;
    /* 设置 a 的值为单位矩阵的值 */
/* L80: */
}
/* 设置标签 */

if (nh > 0) {

/* Generate Q(ilo+1:ihi,ilo+1:ihi) */
/* 生成 Q(ilo+1:ihi,ilo+1:ihi) */

zungqr_(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*ilo], &work[1], lwork, &iinfo);
/* 调用 zungqr 函数生成 Q 矩阵 */
}

work[1].r = (doublereal) lwkopt, work[1].i = 0.;
/* 设置 work 数组的第一个元素为所需大小 */
return 0;

/* End of ZUNGHR */
/* ZUNGHR 的结束 */

} /* zunghr_ */
/* zunghr_ 子程序的结束 */

/* Subroutine */ int zungl2_(integer *m, integer *n, integer *k, doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *work, integer *info)
{
/* 子程序 zungl2_ 的开始 */
/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, i__1, i__2, i__3;
doublecomplex
    extern /* Subroutine */ int zscal_(integer *, doublecomplex *,
        doublecomplex *, integer *), 
        zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), 
        xerbla_(char *, integer *), 
        zlacgv_(integer *, doublecomplex *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
    which is defined as the first m rows of a product of k elementary
    reflectors of order n

          Q  =  H(k)' . . . H(2)' H(1)'

    as returned by ZGELQF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. N >= M.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.

    A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by ZGELQF in the first k rows of its array argument A.
            On exit, the m by n matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    TAU     (input) COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.

    WORK    (workspace) COMPLEX*16 array, dimension (M)

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    =====================================================================


       Test the input arguments
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
    *info = -1;
    } else if (*n < *m) {
    *info = -2;
    } else if (*k < 0 || *k > *m) {
    *info = -3;
    } else if (*lda < max(1,*m)) {
    *info = -5;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZUNGL2", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*m <= 0) {
    return 0;
    }

    if (*k < *m) {

/*        Initialise rows k+1:m to rows of the unit matrix */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (l = *k + 1; l <= i__2; ++l) {
        i__3 = l + j * a_dim1;
        a[i__3].r = 0., a[i__3].i = 0.;
/* L10: */
        }
        if (j > *k && j <= *m) {
        i__2 = j + j * a_dim1;
        a[i__2].r = 1., a[i__2].i = 0.;
        }
/* L20: */
    }
    }

    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i)' to A(i:m,i:n) from the right */

        /* Compute the index for the start of the i-th column in A */
        i__1 = i__ + i__ * a_dim1;

        /* Set the diagonal element of the current column to 1 */
        a[i__1].r = 1., a[i__1].i = 0.;

        /* Apply the transformation to the remaining part of the matrix A */
        if (i__ < *n) {
            i__1 = *m - i__;
            i__2 = *n - i__;
            zlarf_("Right", &i__1, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[i__], &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);
        }
    }
}
    // 检查 i__ 是否小于指针变量 n 指向的值
    if (i__ < *n) {
        // 计算剩余元素数目
        i__1 = *n - i__;
        // 对 a[i__ + (i__ + 1) * a_dim1] 到 a 的末尾进行共轭变换
        zlacgv_(&i__1, &a[i__ + (i__ + 1) * a_dim1], lda);
        
        // 如果 i__ 小于指针变量 m 指向的值
        if (i__ < *m) {
            // 计算索引 i__ + i__ * a_dim1
            i__1 = i__ + i__ * a_dim1;
            // 将 a[i__1] 设置为实部为 1，虚部为 0 的复数
            a[i__1].r = 1., a[i__1].i = 0.;
            
            // 计算两个参数的值
            i__1 = *m - i__;
            i__2 = *n - i__ + 1;
            // 计算 tau[i__] 的共轭
            d_cnjg(&z__1, &tau[i__]);
            // 应用 Householder 变换到 a[i__ + i__ * a_dim1] 到 a[i__ + 1 + i__ * a_dim1]
            zlarf_("Right", &i__1, &i__2, &a[i__ + i__ * a_dim1], lda, &
                z__1, &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
        }
        
        // 计算剩余元素数目
        i__1 = *n - i__;
        // 计算 tau[i__] 的相反数
        i__2 = i__;
        z__1.r = -tau[i__2].r, z__1.i = -tau[i__2].i;
        // 对 a[i__ + (i__ + 1) * a_dim1] 到 a 的末尾应用 z__1 进行缩放
        zscal_(&i__1, &z__1, &a[i__ + (i__ + 1) * a_dim1], lda);
        
        // 对 a[i__ + (i__ + 1) * a_dim1] 到 a 的末尾进行共轭变换
        i__1 = *n - i__;
        zlacgv_(&i__1, &a[i__ + (i__ + 1) * a_dim1], lda);
    }
    
    // 计算索引 i__ + i__ * a_dim1
    i__1 = i__ + i__ * a_dim1;
    // 计算 tau[i__] 的共轭
    d_cnjg(&z__2, &tau[i__]);
    // 计算 z__1 的值
    z__1.r = 1. - z__2.r, z__1.i = 0. - z__2.i;
    // 将 z__1 的值赋给 a[i__1]
    a[i__1].r = z__1.r, a[i__1].i = z__1.i;
/*        Set A(i,1:i-1) to zero */

// 将 A 的第 i 行的前 i-1 列置零
i__1 = i__ - 1;
for (l = 1; l <= i__1; ++l) {
    i__2 = i__ + l * a_dim1;
    a[i__2].r = 0., a[i__2].i = 0.;
/* L30: */
}
/* L40: */
}

/*     End of ZUNGL2 */

} /* zungl2_ */

/* Subroutine */ int zunglq_(integer *m, integer *n, integer *k,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

/* Local variables */
static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
extern /* Subroutine */ int zungl2_(integer *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *), xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
    integer *, integer *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *);
static integer ldwork;
extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *);
static logical lquery;
static integer lwkopt;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
which is defined as the first M rows of a product of K elementary
reflectors of order N

Q  =  H(k)' . . . H(2)' H(1)'

as returned by ZGELQF.

Arguments
=========

M       (input) INTEGER
The number of rows of the matrix Q. M >= 0.

N       (input) INTEGER
The number of columns of the matrix Q. N >= M.

K       (input) INTEGER
The number of elementary reflectors whose product defines the
matrix Q. M >= K >= 0.

A       (input/output) COMPLEX*16 array, dimension (LDA,N)
On entry, the i-th row must contain the vector which defines
the elementary reflector H(i), for i = 1,2,...,k, as returned
by ZGELQF in the first k rows of its array argument A.
On exit, the M-by-N matrix Q.

LDA     (input) INTEGER
The first dimension of the array A. LDA >= max(1,M).

TAU     (input) COMPLEX*16 array, dimension (K)
TAU(i) must contain the scalar factor of the elementary
reflector H(i), as returned by ZGELQF.

WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    // 调用外部函数ilaenv_，获取ZUNGLQ需要的工作空间大小
    nb = ilaenv_(&c__1, "ZUNGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    // 计算工作空间的最优大小
    lwkopt = max(1,*m) * nb;
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    // 检查是否为查询工作空间大小
    lquery = *lwork == -1;
    // 检查输入参数的合法性
    if (*m < 0) {
        *info = -1;
    } else if (*n < *m) {
        *info = -2;
    } else if (*k < 0 || *k > *m) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*lwork < max(1,*m) && ! lquery) {
        *info = -8;
    }
    // 如果有错误，调用错误处理程序并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNGLQ", &i__1);
        return 0;
    } else if (lquery) {
        // 如果是查询工作空间大小，则直接返回
        return 0;
    }

/*     Quick return if possible */

    if (*m <= 0) {
        // 如果m<=0，设置工作空间大小为1并返回
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *m;
    // 计算NB和NX的值以确定使用阻塞还是非阻塞代码
    if (nb > 1 && nb < *k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
        // 调用ilaenv_函数确定阻塞到非阻塞代码的交叉点
        i__1 = 0, i__2 = ilaenv_(&c__3, "ZUNGLQ", " ", m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *k) {

/*           Determine if workspace is large enough for blocked code. */

            ldwork = *m;
            iws = ldwork * nb;
            // 如果工作空间不够用，则减小NB并重新计算最小的NB值
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

                nb = *lwork / ldwork;
                // 调用ilaenv_函数重新计算最小的NB值
/* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "ZUNGLQ", " ", m, n, k, &c_n1,
                     (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*
          Use blocked code after the last block.
          The first kk rows are handled by the block method.
*/

        ki = (*k - nx - 1) / nb * nb;
/* Computing MIN */
        // 计算kk的值，用于阻塞方法处理的行数
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);

/*        Set A(kk+1:m,1:kk) to zero. */

        // 将A(kk+1:m,1:kk)矩阵的元素设置为零
        i__1 = kk;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = kk + 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                a[i__3].r = 0., a[i__3].i = 0.;
            }
        }
    } else {
        kk = 0;
    }

/*     Use unblocked code for the last or only block. */

    // 对于最后一个或唯一的块，使用非阻塞代码
    if (kk < *m) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        // 调用ZUNGL2函数执行非阻塞代码
        zungl2_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &
            tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/*        Use blocked code */

        // 使用阻塞代码
        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
            // 计算ib的值，用于阻塞方法的块大小
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);
            if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

                // 形成块反射器的三角因子
                zungl2_(&ib, m, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__],
                    &work[1], &iinfo);
            }
        }
    }
/* 生成一个 M × N 的复数矩阵 Q，其中列向量是正交的，定义为 M 阶的 K 个初等反射变换 H(1), H(2), ..., H(k) 的前 N 列乘积。
   这些反射变换是由 ZGEQRF 返回的结果。 */

Subroutine zungqr_(integer *m, integer *n, integer *k,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int zung2r_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    static integer lwkopt;
    static logical lquery;

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
    which is defined as the first N columns of a product of K elementary
    reflectors of order M

          Q  =  H(1) H(2) . . . H(k)

    as returned by ZGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.
*/

        i__2 = *n - i__ + 1;
        zlarft_("Forward", "Rowwise", &i__2, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              Apply H' to A(i+ib:m,i:n) from the right */

        i__2 = *m - i__ - ib + 1;
        i__3 = *n - i__ + 1;
        zlarfb_("Right", "Conjugate transpose", "Forward", "Rowwise",
            &i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
            1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[
            ib + 1], &ldwork);
        }

/*           Apply H' to columns i:n of current block */

        i__2 = *n - i__ + 1;
        zungl2_(&ib, &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
            work[1], &iinfo);

/*           Set columns 1:i-1 of current block to zero */

        i__2 = i__ - 1;
        for (j = 1; j <= i__2; ++j) {
        i__3 = i__ + ib - 1;
        for (l = i__; l <= i__3; ++l) {
            i__4 = l + j * a_dim1;
            a[i__4].r = 0., a[i__4].i = 0.;
/* L30: */
        }
/* L40: */
        }
/* L50: */
    }
    }

    work[1].r = (doublereal) iws, work[1].i = 0.;
    return 0;

/*     End of ZUNGLQ */

} /* zunglq_ */

/* Subroutine */ int zungqr_(integer *m, integer *n, integer *k,
    doublecomplex *a, integer *lda, doublecomplex *tau, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int zung2r_(integer *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    static integer lwkopt;
    static logical lquery;
    ! N       (input) INTEGER
    !         The number of columns of the matrix Q. M >= N >= 0.

    ! K       (input) INTEGER
    !         The number of elementary reflectors whose product defines the
    !         matrix Q. N >= K >= 0.

    ! A       (input/output) COMPLEX*16 array, dimension (LDA,N)
    !         On entry, the i-th column must contain the vector which
    !         defines the elementary reflector H(i), for i = 1,2,...,k, as
    !         returned by ZGEQRF in the first k columns of its array
    !         argument A.
    !         On exit, the M-by-N matrix Q.

    ! LDA     (input) INTEGER
    !         The first dimension of the array A. LDA >= max(1,M).

    ! TAU     (input) COMPLEX*16 array, dimension (K)
    !         TAU(i) must contain the scalar factor of the elementary
    !         reflector H(i), as returned by ZGEQRF.

    ! WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    ! LWORK   (input) INTEGER
    !         The dimension of the array WORK. LWORK >= max(1,N).
    !         For optimum performance LWORK >= N*NB, where NB is the
    !         optimal blocksize.
    !
    !         If LWORK = -1, then a workspace query is assumed; the routine
    !         only calculates the optimal size of the WORK array, returns
    !         this value as the first entry of the WORK array, and no error
    !         message related to LWORK is issued by XERBLA.

    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument has an illegal value

    ! =====================================================================

       ! Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    // 根据当前环境调用 ilaenv 函数确定最优的块大小 nb
    nb = ilaenv_(&c__1, "ZUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    // 计算所需的工作空间大小
    lwkopt = max(1,*n) * nb;
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    lquery = *lwork == -1;
    // 检查输入参数的有效性
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0 || *n > *m) {
        *info = -2;
    } else if (*k < 0 || *k > *n) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;
    }
    // 如果有错误信息，调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNGQR", &i__1);
        return 0;
    } else if (lquery) {
        // 如果是查询工作空间大小阶段，直接返回
        return 0;
    }

    /* Quick return if possible */
    // 如果 n <= 0，直接返回
    if (*n <= 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *n;
    // 根据一些条件决定是否使用阻塞或非阻塞的 QR 分解
    if (nb > 1 && nb < *k) {

        /* Determine when to cross over from blocked to unblocked code. */
        // 计算 nx 的值，决定何时从阻塞转为非阻塞代码
        i__1 = 0, i__2 = ilaenv_(&c__3, "ZUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *k) {

            /* Determine if workspace is large enough for blocked code. */
            // 检查工作空间是否足够使用阻塞代码
            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

                /* Not enough workspace to use optimal NB: reduce NB and determine the minimum value of NB. */
                // 工作空间不足以使用最优的块大小 nb，需要减小 nb 并确定最小值
                nb = *lwork / ldwork;
                // 计算最小值 nbmin
                i__1 = 2, i__2 = ilaenv_(&c__2, "ZUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

        /* Use blocked code after the last block. The first kk columns are handled by the block method. */
        // 在最后一个块之后使用阻塞代码，第一部分由块方法处理
        ki = (*k - nx - 1) / nb * nb;
        // 计算 kk 的值
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);

        /* Set A(1:kk,kk+1:n) to zero. */
        // 将 A(1:kk,kk+1:n) 设置为零
        i__1 = *n;
        for (j = kk + 1; j <= i__1; ++j) {
            i__2 = kk;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                a[i__3].r = 0., a[i__3].i = 0.;
            }
        }
    } else {
        kk = 0;
    }

    /* Use unblocked code for the last or only block. */
    // 对于最后一个或唯一的块，使用非阻塞代码
    if (kk < *n) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        zung2r_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

        /* Use blocked code */
        // 使用阻塞代码
        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
            /* Computing MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);
            if (i__ + ib <= *n) {

                /* Form the triangular factor of the block reflector H = H(i) H(i+1) . . . H(i+ib-1) */
                // 形成块反射器的上三角因子
                zlarft_("F", "C", &ib, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &ldwork);
                zlarfb_("Left", "Conjugate transpose", "Forward", "Columnwise", &ib, n, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &work[ib + 1], &ldwork);
            }
        }
    }
/*           Apply H(i) to A(i:m,i+ib:n) from the left */
i__2 = *m - i__ + 1;
i__3 = *n - i__ - ib + 1;
zlarfb_("Left", "No transpose", "Forward", "Columnwise", &
    i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
    1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &
    work[ib + 1], &ldwork);
}

/*           Apply H(i) to rows i:m of current block */
i__2 = *m - i__ + 1;
zung2r_(&i__2, &ib, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
    work[1], &iinfo);

/*           Set rows 1:i-1 of current block to zero */
i__2 = i__ + ib - 1;
for (j = i__; j <= i__2; ++j) {
i__3 = i__ - 1;
for (l = 1; l <= i__3; ++l) {
    i__4 = l + j * a_dim1;
    a[i__4].r = 0., a[i__4].i = 0.;
/* L30: */
}
/* L40: */
}
/* L50: */
}
}

work[1].r = (doublereal) iws, work[1].i = 0.;
return 0;

/*     End of ZUNGQR */

} /* zungqr_ */

/* Subroutine */ int zunm2l_(char *side, char *trans, integer *m, integer *n,
integer *k, doublecomplex *a, integer *lda, doublecomplex *tau,
doublecomplex *c__, integer *ldc, doublecomplex *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
doublecomplex z__1;

/* Local variables */
static integer i__, i1, i2, i3, mi, ni, nq;
static doublecomplex aii;
static logical left;
static doublecomplex taui;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *, doublecomplex *), xerbla_(char *, integer *);
static logical notran;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

ZUNM2L overwrites the general complex m-by-n matrix C with

      Q * C  if SIDE = 'L' and TRANS = 'N', or

      Q'* C  if SIDE = 'L' and TRANS = 'C', or

      C * Q  if SIDE = 'R' and TRANS = 'N', or

      C * Q' if SIDE = 'R' and TRANS = 'C',

where Q is a complex unitary matrix defined as the product of k
elementary reflectors

      Q = H(k) . . . H(2) H(1)

as returned by ZGEQLF. Q is of order m if SIDE = 'L' and of order n
if SIDE = 'R'.

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'L': apply Q or Q' from the Left
        = 'R': apply Q or Q' from the Right

TRANS   (input) CHARACTER*1
        = 'N': apply Q  (No transpose)
        = 'C': apply Q' (Conjugate transpose)
    ! M       (input) INTEGER
    !         The number of rows of the matrix C. M >= 0.

    ! N       (input) INTEGER
    !         The number of columns of the matrix C. N >= 0.

    ! K       (input) INTEGER
    !         The number of elementary reflectors whose product defines
    !         the matrix Q.
    !         If SIDE = 'L', M >= K >= 0;
    !         if SIDE = 'R', N >= K >= 0.

    ! A       (input) COMPLEX*16 array, dimension (LDA,K)
    !         The i-th column must contain the vector which defines the
    !         elementary reflector H(i), for i = 1,2,...,k, as returned by
    !         ZGEQLF in the last k columns of its array argument A.
    !         A is modified by the routine but restored on exit.

    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.
    !         If SIDE = 'L', LDA >= max(1,M);
    !         if SIDE = 'R', LDA >= max(1,N).

    ! TAU     (input) COMPLEX*16 array, dimension (K)
    !         TAU(i) must contain the scalar factor of the elementary
    !         reflector H(i), as returned by ZGEQLF.

    ! C       (input/output) COMPLEX*16 array, dimension (LDC,N)
    !         On entry, the m-by-n matrix C.
    !         On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    ! LDC     (input) INTEGER
    !         The leading dimension of the array C. LDC >= max(1,M).

    ! WORK    (workspace) COMPLEX*16 array, dimension
    !                              (N) if SIDE = 'L',
    !                              (M) if SIDE = 'R'

    ! INFO    (output) INTEGER
    !         = 0: successful exit
    !         < 0: if INFO = -i, the i-th argument had an illegal value

    ! ====================================================================


       ! Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;  // 调整数组 a 的索引，使其从偏移位置开始
    --tau;  // tau 数组的索引减一，从零开始

    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;  // 调整数组 c__ 的索引，使其从偏移位置开始
    --work;  // work 数组的索引减一，从零开始

    /* Function Body */
    *info = 0;  // 初始化 info 参数为零
    left = lsame_(side, "L");  // 判断 side 是否为 'L'，返回逻辑值
    notran = lsame_(trans, "N");  // 判断 trans 是否为 'N'，返回逻辑值

/*     NQ is the order of Q */

    if (left) {
        nq = *m;  // 如果 side 为 'L'，则 nq 等于 m
    } else {
        nq = *n;  // 否则 nq 等于 n
    }

    if (! left && ! lsame_(side, "R")) {  // 如果 side 不是 'L' 且也不是 'R'
        *info = -1;  // 将 info 置为 -1
    } else if (! notran && ! lsame_(trans, "C")) {  // 如果 trans 不是 'N' 且也不是 'C'
        *info = -2;  // 将 info 置为 -2
    } else if (*m < 0) {  // 如果 m 小于零
        *info = -3;  // 将 info 置为 -3
    } else if (*n < 0) {  // 如果 n 小于零
        *info = -4;  // 将 info 置为 -4
    } else if (*k < 0 || *k > nq) {  // 如果 k 小于零或大于 nq
        *info = -5;  // 将 info 置为 -5
    } else if (*lda < max(1,nq)) {  // 如果 lda 小于 1 和 nq 中的较大者
        *info = -7;  // 将 info 置为 -7
    } else if (*ldc < max(1,*m)) {  // 如果 ldc 小于 1 和 m 中的较大者
        *info = -10;  // 将 info 置为 -10
    }

    if (*info != 0) {  // 如果 info 不等于零
        i__1 = -(*info);  // 取 info 的负值
        xerbla_("ZUNM2L", &i__1);  // 调用错误处理程序 xerbla_
        return 0;  // 返回 0
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {  // 如果 m、n 或 k 中有一个为零
        return 0;  // 直接返回 0
    }

    if (left && notran || ! left && ! notran) {  // 如果 side 是 'L' 且 trans 是 'N' 或 side 不是 'L' 且 trans 不是 'N'
        i1 = 1;  // 设置 i1 为 1
        i2 = *k;  // 设置 i2 为 k
        i3 = 1;  // 设置 i3 为 1
    } else {
        i1 = *k;  // 否则设置 i1 为 k
        i2 = 1;  // 设置 i2 为 1
        i3 = -1;  // 设置 i3 为 -1
    }

    if (left) {
        ni = *n;  // 如果 side 是 'L'，则 ni 等于 n
    } else {
        mi = *m;  // 否则设置 mi 为 m
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {  // 循环 i 从 i1 到 i2，步长为 i3
        if (left) {

/*           H(i) or H(i)' is applied to C(1:m-k+i,1:n) */

            mi = *m - *k + i__;  // 计算 mi 的值
        } else {

/*           H(i) or H(i)' is applied to C(1:m,1:n-k+i) */

            ni = *n - *k + i__;  // 计算 ni 的值
        }

/*        Apply H(i) or H(i)' */

        if (notran) {
            i__3 = i__;
            taui.r = tau[i__3].r, taui.i = tau[i__3].i;  // 如果 trans 是 'N'，取出 tau[i__] 的实部和虚部
        } else {
            d_cnjg(&z__1, &tau[i__]);  // 否则取 tau[i__] 的共轭复数
            taui.r = z__1.r, taui.i = z__1.i;  // 将结果赋给 taui
        }
        i__3 = nq - *k + i__ + i__ * a_dim1;
        aii.r = a[i__3].r, aii.i = a[i__3].i;  // 将 a[nq-*k+i][nq-*k+i] 的值保存到 aii 中
        i__3 = nq - *k + i__ + i__ * a_dim1;
        a[i__3].r = 1., a[i__3].i = 0.;  // 将 a[nq-*k+i][nq-*k+i] 置为 (1, 0)
        zlarf_(side, &mi, &ni, &a[i__ * a_dim1 + 1], &c__1, &taui, &c__[
            c_offset], ldc, &work[1]);  // 调用 zlarf_ 函数应用 H(i) 或 H(i)' 到 c__
        i__3 = nq - *k + i__ + i__ * a_dim1;
        a[i__3].r = aii.r, a[i__3].i = aii.i;  // 恢复 a[nq-*k+i][nq-*k+i] 的原始值
/* L10: */
    }
    return 0;

/*     End of ZUNM2L */

} /* zunm2l_ */

/* Subroutine */ int zunm2r_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublecomplex *a, integer *lda, doublecomplex *tau,
    doublecomplex *c__, integer *ldc, doublecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    static doublecomplex aii;
    static logical left;
    static doublecomplex taui;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *);
    static logical notran;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK 是由 University of Tennessee，University of California Berkeley，University of Colorado Denver 和 NAG Ltd. 提供的软件包。
    -- 2006年11月

Purpose
=======

ZUNM2R 用 Q 将一般的复数 m-by-n 矩阵 C 覆写为

      Q * C  if SIDE = 'L' and TRANS = 'N', or

      Q'* C  if SIDE = 'L' and TRANS = 'C', or

      C * Q  if SIDE = 'R' and TRANS = 'N', or

      C * Q' if SIDE = 'R' and TRANS = 'C',

其中 Q 是一个复数单位矩阵，定义为 k 个 elementary reflectors 的乘积

      Q = H(1) H(2) . . . H(k)

由 ZGEQRF 返回。如果 SIDE = 'L'，Q 的阶数为 m；如果 SIDE = 'R'，Q 的阶数为 n。

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'L': 从左侧应用 Q 或 Q'
        = 'R': 从右侧应用 Q 或 Q'

TRANS   (input) CHARACTER*1
        = 'N': 应用 Q  (不转置)
        = 'C': 应用 Q' (共轭转置)

M       (input) INTEGER
        矩阵 C 的行数。M >= 0。

N       (input) INTEGER
        矩阵 C 的列数。N >= 0。
    
K       (input) INTEGER
        定义矩阵 Q 的 k 个 elementary reflectors 的乘积。
        如果 SIDE = 'L'，M >= K >= 0;
        如果 SIDE = 'R'，N >= K >= 0。

A       (input) COMPLEX*16 array, dimension (LDA,K)
        第 i 列必须包含定义 elementary reflector H(i) 的向量，对于 i = 1,2,...,k，如 ZGEQRF 返回的其数组参数 A 的前 k 列。
        A 通过例程进行修改，但在退出时恢复。

LDA     (input) INTEGER
        数组 A 的维数。
        如果 SIDE = 'L'，LDA >= max(1,M);
        如果 SIDE = 'R'，LDA >= max(1,N)。

TAU     (input) COMPLEX*16 array, dimension (K)
        TAU(i) 必须包含 elementary reflector H(i) 的标量因子，如 ZGEQRF 返回。

C       (input/output) COMPLEX*16 array, dimension (LDC,N)
        在进入时，m-by-n 矩阵 C。
        在退出时，C 被 Q*C，Q'*C，C*Q'，C*Q 覆写。

LDC     (input) INTEGER
        数组 C 的维数。LDC >= max(1,M)。

WORK    (workspace) COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

INFO    (output) INTEGER
        = 0: 成功退出
        < 0: 如果 INFO = -i，第 i 个参数的值不合法
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

    /* NQ is the order of Q */
    if (left) {
        nq = *m;
    } else {
        nq = *n;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNM2R", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        return 0;
    }

    if (left && ! notran || ! left && notran) {
        i1 = 1;
        i2 = *k;
        i3 = 1;
    } else {
        i1 = *k;
        i2 = 1;
        i3 = -1;
    }

    if (left) {
        ni = *n;
        jc = 1;
    } else {
        mi = *m;
        ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
        if (left) {

            /* H(i) or H(i)' is applied to C(i:m,1:n) */
            mi = *m - i__ + 1;
            ic = i__;
        } else {

            /* H(i) or H(i)' is applied to C(1:m,i:n) */
            ni = *n - i__ + 1;
            jc = i__;
        }

        /* Apply H(i) or H(i)' */
        if (notran) {
            i__3 = i__;
            taui.r = tau[i__3].r, taui.i = tau[i__3].i;
        } else {
            d_cnjg(&z__1, &tau[i__]);
            taui.r = z__1.r, taui.i = z__1.i;
        }
        i__3 = i__ + i__ * a_dim1;
        aii.r = a[i__3].r, aii.i = a[i__3].i;
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = 1., a[i__3].i = 0.;
        zlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &taui, &c__[ic
            + jc * c_dim1], ldc, &work[1]);
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = aii.r, a[i__3].i = aii.i;
        /* L10: */
    }
    return 0;

    /* End of ZUNM2R */

} /* zunm2r_ */

/* Subroutine */ int zunmbr_(char *vect, char *side, char *trans, integer *m,
    integer *n, integer *k, doublecomplex *a, integer *lda, doublecomplex
    *tau, doublecomplex *c__, integer *ldc, doublecomplex *work, integer *
    lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2];
    char ch__1[2];

    /* Local variables */
    static integer i1, i2, nb, mi, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran, applyq;
    static char transt[1];
    static integer lwkopt;

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

    /* NQ is the order of Q */
    if (left) {
        nq = *m;
    } else {
        nq = *n;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNM2R", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        return 0;
    }

    if (left && ! notran || ! left && notran) {
        i1 = 1;
        i2 = *k;
        i3 = 1;
    } else {
        i1 = *k;
        i2 = 1;
        i3 = -1;
    }

    if (left) {
        ni = *n;
        jc = 1;
    } else {
        mi = *m;
        ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
        if (left) {

            /* H(i) or H(i)' is applied to C(i:m,1:n) */
            mi = *m - i__ + 1;
            ic = i__;
        } else {

            /* H(i) or H(i)' is applied to C(1:m,i:n) */
            ni = *n - i__ + 1;
            jc = i__;
        }

        /* Apply H(i) or H(i)' */
        if (notran) {
            i__3 = i__;
            taui.r = tau[i__3].r, taui.i = tau[i__3].i;
        } else {
            d_cnjg(&z__1, &tau[i__]);
            taui.r = z__1.r, taui.i = z__1.i;
        }
        i__3 = i__ + i__ * a_dim1;
        aii.r = a[i__3].r, aii.i = a[i__3].i;
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = 1., a[i__3].i = 0.;
        zlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &taui, &c__[ic
            + jc * c_dim1], ldc, &work[1]);
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = aii.r, a[i__3].i = aii.i;
        /* L10: */
    }
    return 0;

    /* End of ZUNM2R */

} /* zunm2r_ */


These annotations provide a detailed explanation of each line in the given Fortran subroutine, adhering to the
    static logical lquery;
    extern /* Subroutine */ int zunmlq_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *), zunmqr_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);



    声明静态逻辑变量 lquery，用于存储逻辑值
    声明外部函数 zunmlq_ 和 zunmqr_，它们接受一系列参数并返回整型值
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      P * C          C * P
    TRANS = 'C':      P**H * C       C * P**H

    Here Q and P**H are the unitary matrices determined by ZGEBRD when
    reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
    and P**H are defined as products of elementary reflectors H(i) and
    G(i) respectively.

    Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
    order of the unitary matrix Q or P**H that is applied.

    If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
    if nq >= k, Q = H(1) H(2) . . . H(k);
    if nq < k, Q = H(1) H(2) . . . H(nq-1).

    If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
    if k < nq, P = G(1) G(2) . . . G(k);
    if k >= nq, P = G(1) G(2) . . . G(nq-1).

    Arguments
    =========

    VECT    (input) CHARACTER*1
            = 'Q': apply Q or Q**H;
            = 'P': apply P or P**H.

    SIDE    (input) CHARACTER*1
            = 'L': apply Q, Q**H, P or P**H from the Left;
            = 'R': apply Q, Q**H, P or P**H from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q or P;
            = 'C':  Conjugate transpose, apply Q**H or P**H.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by ZGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by ZGEBRD.
            K >= 0.

    A       (input) COMPLEX*16 array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by ZGEBRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).

    TAU     (input) COMPLEX*16 array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by ZGEBRD in the array argument TAUQ or TAUP.
*/
    ! 测试输入参数的有效性
    ! 测试输入参数的有效性

    IF (LDC.LT.MAX(1,M)) THEN
        ! 如果 LDC 小于 M 的值，报错并返回 -1
        INFO = -1
        RETURN
    END IF

    IF (LWORK.LT.1) THEN
        ! 如果 LWORK 小于 1，报错并返回 -8
        INFO = -8
        RETURN
    END IF

    INFO = 0
    ! 设置 INFO 为 0，表明参数检查通过
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
c_dim1 = *ldc;
c_offset = 1 + c_dim1;
c__ -= c_offset;
--work;

/* Function Body */
*info = 0;
applyq = lsame_(vect, "Q");
left = lsame_(side, "L");
notran = lsame_(trans, "N");
lquery = *lwork == -1;

/* NQ is the order of Q or P and NW is the minimum dimension of WORK */
if (left) {
    nq = *m;
    nw = *n;
} else {
    nq = *n;
    nw = *m;
}
if (*m == 0 || *n == 0) {
    nw = 0;
}
if (! applyq && ! lsame_(vect, "P")) {
    *info = -1;
} else if (! left && ! lsame_(side, "R")) {
    *info = -2;
} else if (! notran && ! lsame_(trans, "C")) {
    *info = -3;
} else if (*m < 0) {
    *info = -4;
} else if (*n < 0) {
    *info = -5;
} else if (*k < 0) {
    *info = -6;
} else /* if(complicated condition) */ {
    /* Computing MAX */
    i__1 = 1, i__2 = min(nq,*k);
    if (applyq && *lda < max(1,nq) || ! applyq && *lda < max(i__1,i__2)) {
        *info = -8;
    } else if (*ldc < max(1,*m)) {
        *info = -11;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -13;
    }
}

if (*info == 0) {
    if (nw > 0) {
        if (applyq) {
            if (left) {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "ZUNMQR", ch__1, &i__1, n, &i__2, &
                             c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "ZUNMQR", ch__1, m, &i__1, &i__2, &
                             c_n1, (ftnlen)6, (ftnlen)2);
            }
        } else {
            if (left) {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "ZUNMLQ", ch__1, &i__1, n, &i__2, &
                             c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "ZUNMLQ", ch__1, m, &i__1, &i__2, &
                             c_n1, (ftnlen)6, (ftnlen)2);
            }
        }
        /* Computing MAX */
        i__1 = 1, i__2 = nw * nb;
        lwkopt = max(i__1,i__2);
    } else {
        lwkopt = 1;
    }
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
}

if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZUNMBR", &i__1);
}
    # 如果条件满足，返回0
    return 0;
    # 否则，如果lquery为真，返回0
    } else if (lquery) {
    # 返回0
    return 0;
    # 结束if-else条件块
    }
/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
    return 0;
    }

    if (applyq) {

/*        Apply Q */

    if (nq >= *k) {

/*           Q was determined by a call to ZGEBRD with nq >= k */

        zunmqr_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], lwork, &iinfo);
    } else if (nq > 1) {

/*           Q was determined by a call to ZGEBRD with nq < k */

        if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
        } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
        }
        i__1 = nq - 1;
        zunmqr_(side, trans, &mi, &ni, &i__1, &a[a_dim1 + 2], lda, &tau[1]
            , &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
    }
    } else {

/*        Apply P */

    if (notran) {
        *(unsigned char *)transt = 'C';
    } else {
        *(unsigned char *)transt = 'N';
    }
    if (nq > *k) {

/*           P was determined by a call to ZGEBRD with nq > k */

        zunmlq_(side, transt, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], lwork, &iinfo);
    } else if (nq > 1) {

/*           P was determined by a call to ZGEBRD with nq <= k */

        if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
        } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
        }
        i__1 = nq - 1;
        zunmlq_(side, transt, &mi, &ni, &i__1, &a[(a_dim1 << 1) + 1], lda,
             &tau[1], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &
            iinfo);
    }
    }
    work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    return 0;

/*     End of ZUNMBR */

} /* zunmbr_ */

/* Subroutine */ int zunmhr_(char *side, char *trans, integer *m, integer *n,
    integer *ilo, integer *ihi, doublecomplex *a, integer *lda,
    doublecomplex *tau, doublecomplex *c__, integer *ldc, doublecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2;
    char ch__1[2];

    /* Local variables */
    static integer i1, i2, nb, mi, nh, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer lwkopt;
    static logical lquery;
    extern /* Subroutine */ int zunmqr_(char *, char *, integer *, integer *,
        integer *, doublecomplex *, integer *, doublecomplex *,
        doublecomplex *, integer *, doublecomplex *, integer *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
    ! ZUNMHR overwrites the general complex M-by-N matrix C with
    !
    !                SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix of order nq, with nq = m if
    ! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    ! IHI-ILO elementary reflectors, as returned by ZGEHRD:
    !
    ! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    !
    ! Arguments
    ! =========
    !
    ! SIDE    (input) CHARACTER*1
    !         = 'L': apply Q or Q**H from the Left;
    !         = 'R': apply Q or Q**H from the Right.
    !
    ! TRANS   (input) CHARACTER*1
    !         = 'N': apply Q  (No transpose)
    !         = 'C': apply Q**H (Conjugate transpose)
    !
    ! M       (input) INTEGER
    !         The number of rows of the matrix C. M >= 0.
    !
    ! N       (input) INTEGER
    !         The number of columns of the matrix C. N >= 0.
    !
    ! ILO     (input) INTEGER
    ! IHI     (input) INTEGER
    !         ILO and IHI must have the same values as in the previous call
    !         of ZGEHRD. Q is equal to the unit matrix except in the
    !         submatrix Q(ilo+1:ihi,ilo+1:ihi).
    !         If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
    !         ILO = 1 and IHI = 0, if M = 0;
    !         if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
    !         ILO = 1 and IHI = 0, if N = 0.
    !
    ! A       (input) COMPLEX*16 array, dimension
    !                              (LDA,M) if SIDE = 'L'
    !                              (LDA,N) if SIDE = 'R'
    !         The vectors which define the elementary reflectors, as
    !         returned by ZGEHRD.
    !
    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.
    !         LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
    !
    ! TAU     (input) COMPLEX*16 array, dimension
    !                              (M-1) if SIDE = 'L'
    !                              (N-1) if SIDE = 'R'
    !         TAU(i) must contain the scalar factor of the elementary
    !         reflector H(i), as returned by ZGEHRD.
    !
    ! C       (input/output) COMPLEX*16 array, dimension (LDC,N)
    !         On entry, the M-by-N matrix C.
    !         On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
    !
    ! LDC     (input) INTEGER
    !         The leading dimension of the array C. LDC >= max(1,M).
    !
    ! WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    # LWORK   (input) INTEGER
    #         WORK 数组的维度。
    #         如果 SIDE = 'L'，则要求 LWORK >= max(1,N);
    #         如果 SIDE = 'R'，则要求 LWORK >= max(1,M)。
    #         为了达到最佳性能，如果 SIDE = 'L'，则建议 LWORK >= N*NB；
    #         如果 SIDE = 'R'，则建议 LWORK >= M*NB，其中 NB 是最佳块大小。
    #
    #         如果 LWORK = -1，则假定为工作空间查询；该例程只计算 WORK 数组的最佳大小，
    #         将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会报告与 LWORK 相关的任何错误消息。

    # INFO    (output) INTEGER
    #         = 0:  成功退出
    #         < 0:  如果 INFO = -i，则第 i 个参数的值非法

    # =====================================================================

    # 测试输入参数的有效性
/* Parameter adjustments */
/*
   Adjusting indices and pointers for array `a`, `tau`, `c__`, and `work`.
   a_dim1 and a_offset are set to handle multi-dimensional array `a`.
   tau is adjusted to point to its starting address.
   c_dim1 and c_offset are set to handle multi-dimensional array `c__`.
   `work` is decremented to point to its starting address.
*/
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    /*
       Initialize `info` to zero to indicate no errors initially.
       Calculate `nh`, the difference between `ihi` and `ilo`.
       Determine if `side` is 'L' or 'R' and store result in `left`.
       Set `lquery` based on whether `lwork` equals -1.
    */
    *info = 0;
    nh = *ihi - *ilo;
    left = lsame_(side, "L");
    lquery = *lwork == -1;

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    /*
       Determine `nq` and `nw` based on the values of `side`, `m`, and `n`.
       `nq` is set to `m` if `left`, otherwise to `n`.
       `nw` is set to `n` if `left`, otherwise to `m`.
       Validate `side` if neither 'L' nor 'R', set `info` to -1.
       Validate `trans` if neither 'N' nor 'C', set `info` to -2.
       Check bounds for `m`, `n`, `ilo`, and `ihi` and set appropriate error codes.
       Validate `lda` and `ldc` based on matrix dimensions.
       Check `lwork` if it is less than required and not a query, set `info` to -13.
    */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }
    if (!left && !lsame_(side, "R")) {
        *info = -1;
    } else if (!lsame_(trans, "N") && !lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*ilo < 1 || *ilo > max(1, nq)) {
        *info = -5;
    } else if (*ihi < min(*ilo, nq) || *ihi > nq) {
        *info = -6;
    } else if (*lda < max(1, nq)) {
        *info = -8;
    } else if (*ldc < max(1, *m)) {
        *info = -11;
    } else if (*lwork < max(1, nw) && !lquery) {
        *info = -13;
    }

    if (*info == 0) {
        /*
           If `side` is 'L', concatenate `side` and `trans` and call `ilaenv_` to get `nb`.
           If `side` is 'R', concatenate `side` and `trans` and call `ilaenv_` to get `nb`.
           Calculate `lwkopt` based on `nb` and minimum dimension `nw`.
           Set `work[1]` to `lwkopt`.
        */
        if (left) {
            i__1[0] = 1, a__1[0] = side;
            i__1[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
            nb = ilaenv_(&c__1, "ZUNMQR", ch__1, &nh, n, &nh, &c_n1, (ftnlen)6, (ftnlen)2);
        } else {
            i__1[0] = 1, a__1[0] = side;
            i__1[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
            nb = ilaenv_(&c__1, "ZUNMQR", ch__1, m, &nh, &nh, &c_n1, (ftnlen)6, (ftnlen)2);
        }
        lwkopt = max(1, nw) * nb;
        work[1].r = (doublereal)lwkopt, work[1].i = 0.;
    }

    if (*info != 0) {
        /*
           If `info` is not zero, set `i__2` to negative of `info` and call `xerbla_`.
           Return from subroutine.
        */
        i__2 = -(*info);
        xerbla_("ZUNMHR", &i__2);
        return 0;
    } else if (lquery) {
        /*
           If `lquery` is true, return from subroutine.
        */
        return 0;
    }

/*     Quick return if possible */

    /*
       If `m`, `n`, or `nh` is zero, set `work[1]` to 1 and return from subroutine.
    */
    if (*m == 0 || *n == 0 || nh == 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    /*
       Determine `mi`, `ni`, `i1`, and `i2` based on `left` and `ilo`.
       Call `zunmqr_` to apply the block reflector to matrix `c__`.
       Set `work[1]` to `lwkopt`.
       Return from subroutine.
    */
    if (left) {
        mi = nh;
        ni = *n;
        i1 = *ilo + 1;
        i2 = 1;
    } else {
        mi = *m;
        ni = nh;
        i1 = 1;
        i2 = *ilo + 1;
    }

    zunmqr_(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &tau[*ilo],
            &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);

    work[1].r = (doublereal)lwkopt, work[1].i = 0.;
    return 0;

/*     End of ZUNMHR */

} /* zunmhr_ */

/* Subroutine */ int zunml2_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublecomplex *a, integer *lda, doublecomplex *tau,
    doublecomplex *c__, integer *ldc, doublecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
    doublecomplex z__1;

    /* Local variables */
    static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    static doublecomplex aii;
    static logical left;
    static doublecomplex taui;
    extern logical lsame_(char *, char *);

    /*
       System-generated local variables and array adjustments.
       Declaring local variables `i`, `i1`, `i2`, `i3`, `ic`, `jc`, `mi`, `ni`, `nq`.
       Declaring `aii` and `taui` as doublecomplex types.
       Externally defined function `lsame_`.
    */
    # 声明外部函数 zlarf_、xerbla_、zlacgv_
    extern /* Subroutine */ int zlarf_(char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *);
    # 声明静态逻辑变量 notran
    static logical notran;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    ZUNML2 overwrites the general complex m-by-n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'C', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'C',

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k)' . . . H(2)' H(1)'

    as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q' (Conjugate transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.

    C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments
*/

/* Parameter adjustments */
a_dim1 = *lda;  // Dimension of A in the first dimension (LDA)
a_offset = 1 + a_dim1;  // Offset for accessing A in 1D indexing
a -= a_offset;  // Adjust A to start at 1,1 (considering Fortran indexing)
--tau;  // Decrement Tau index to start from 1 (considering Fortran indexing)
c_dim1 = *ldc;  // Dimension of C in the first dimension (LDC)
c_offset = 1 + c_dim1;  // Offset for accessing C in 1D indexing
c__ -= c_offset;  // Adjust C to start at 1,1 (considering Fortran indexing)
--work;  // Decrement Work index to start from 1 (considering Fortran indexing)

/* Function Body */
    # 将变量 info 设置为整数 0
    *info = 0;
    # 调用 lsame_ 函数，比较参数 side 是否为字符串 "L"，返回结果给 left
    left = lsame_(side, "L");
    # 调用 lsame_ 函数，比较参数 trans 是否为字符串 "N"，返回结果给 notran
    notran = lsame_(trans, "N");
/*     NQ is the order of Q */

/* 检查左乘标志 */
    if (left) {
/* 如果左乘标志为真，将nq设为m的值 */
    nq = *m;
    } else {
/* 否则将nq设为n的值 */
    nq = *n;
    }
/* 检查输入参数的有效性 */
    if (! left && ! lsame_(side, "R")) {
/* 如果不是左乘且side不是'R'，返回错误码-1 */
    *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
/* 如果不是非转置操作且trans不是'C'，返回错误码-2 */
    *info = -2;
    } else if (*m < 0) {
/* 如果m小于0，返回错误码-3 */
    *info = -3;
    } else if (*n < 0) {
/* 如果n小于0，返回错误码-4 */
    *info = -4;
    } else if (*k < 0 || *k > nq) {
/* 如果k小于0或者大于nq，返回错误码-5 */
    *info = -5;
    } else if (*lda < max(1,*k)) {
/* 如果lda小于1或者k，返回错误码-7 */
    *info = -7;
    } else if (*ldc < max(1,*m)) {
/* 如果ldc小于1或者m，返回错误码-10 */
    *info = -10;
    }
/* 如果info不为0，调用错误处理程序并返回 */
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("ZUNML2", &i__1);
    return 0;
    }

/*     Quick return if possible */

/* 如果m、n或k中有任何一个为0，直接返回 */
    if (*m == 0 || *n == 0 || *k == 0) {
    return 0;
    }

/* 根据left和notran设置i1、i2和i3 */
    if (left && notran || ! left && ! notran) {
    i1 = 1;
    i2 = *k;
    i3 = 1;
    } else {
    i1 = *k;
    i2 = 1;
    i3 = -1;
    }

/* 根据left设置ni和jc，否则设置mi和ic */
    if (left) {
    ni = *n;
    jc = 1;
    } else {
    mi = *m;
    ic = 1;
    }

/* 循环应用Householder变换 */
    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    if (left) {

/*           H(i) or H(i)' is applied to C(i:m,1:n) */

/* 如果是左乘，计算mi和ic */
        mi = *m - i__ + 1;
        ic = i__;
    } else {

/*           H(i) or H(i)' is applied to C(1:m,i:n) */

/* 如果是右乘，计算ni和jc */
        ni = *n - i__ + 1;
        jc = i__;
    }

/*        应用H(i)或H(i)' */

/* 根据notran设置taui */
    if (notran) {
        d_cnjg(&z__1, &tau[i__]);
        taui.r = z__1.r, taui.i = z__1.i;
    } else {
        i__3 = i__;
        taui.r = tau[i__3].r, taui.i = tau[i__3].i;
    }
/* 如果i小于nq，对a进行共轭变换 */
    if (i__ < nq) {
        i__3 = nq - i__;
        zlacgv_(&i__3, &a[i__ + (i__ + 1) * a_dim1], lda);
    }
/* 记录a的当前值到aii，然后设置a的(i,i)元素为1 */
    i__3 = i__ + i__ * a_dim1;
    aii.r = a[i__3].r, aii.i = a[i__3].i;
    i__3 = i__ + i__ * a_dim1;
    a[i__3].r = 1., a[i__3].i = 0.;
/* 调用BLAS函数zlarf，应用Householder矩阵 */
    zlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], lda, &taui, &c__[ic +
        jc * c_dim1], ldc, &work[1]);
/* 恢复a的(i,i)元素的值为aii */
    i__3 = i__ + i__ * a_dim1;
    a[i__3].r = aii.r, a[i__3].i = aii.i;
/* 如果i小于nq，再次对a进行共轭变换 */
    if (i__ < nq) {
        i__3 = nq - i__;
        zlacgv_(&i__3, &a[i__ + (i__ + 1) * a_dim1], lda);
    }
/* L10: */
    }
/* 成功完成函数调用，返回0 */
    return 0;

/*     End of ZUNML2 */

} /* zunml2_ */

/* 子程序：zunmlq_ */
/* 实现了左右乘Householder变换的功能 */
/* Input: side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork, info */
/* Output: c is overwritten by Q*C or Q^H*C or C*Q or C*Q^H, depending on side and trans */
/* Notes: This routine is a part of LAPACK, used for linear algebra computations */
/* Reference: https://www.netlib.org/lapack/explore-html/d2/d8e/zunmlq_8f.html */
    # 外部函数声明，用于获取特定环境参数（通常在不同平台上有不同实现）
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    # 外部子程序声明，用于执行具体的线性代数操作（在其他地方定义的子程序）
    extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
        integer *, integer *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *, doublecomplex *, integer *,
        doublecomplex *, integer *);
    # 静态逻辑变量，指示是否不进行转置操作
    static logical notran;
    # 静态整数变量，用于指定工作数组的维度
    static integer ldwork;
    # 外部子程序声明，用于计算特定类型的矩阵-向量乘积
    extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
        doublecomplex *, integer *, doublecomplex *, doublecomplex *,
        integer *);
    # 静态字符数组，用于指定转置类型
    static char transt[1];
    # 静态整数变量，表示所需的工作空间大小
    static integer lwkopt;
    # 静态逻辑变量，指示是否为查询工作空间大小
    static logical lquery;
/*
    ZUNMLQ -- LAPACK routine (version 3.2)
    LAPACK is a software package provided by Univ. of Tennessee,
    Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.
    November 2006

    Purpose
    =======
    ZUNMLQ overwrites the general complex M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k)' . . . H(2)' H(1)'

    as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.

    C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/

void zunmlq_(const char *SIDE, const char *TRANS, const int *M, const int *N,
             const int *K, complex*16 A, const int *LDA, complex*16 TAU,
             complex*16 C, const int *LDC, complex*16 WORK, const int *LWORK);
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK.
    #         If SIDE = 'L', LWORK >= max(1,N);
    #         if SIDE = 'R', LWORK >= max(1,M).
    #         For optimum performance LWORK >= N*NB if SIDE 'L', and
    #         LWORK >= M*NB if SIDE = 'R', where NB is the optimal
    #         blocksize.
    #
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the WORK array, returns
    #         this value as the first entry of the WORK array, and no error
    #         message related to LWORK is issued by XERBLA.
    #
    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value
    #
    # =====================================================================
    #
    # Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,*k)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        /* Determine the block size. NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "ZUNMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNMLQ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "ZUNMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        zunml2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        if (notran) {
            *(unsigned char *)transt = 'C';
        } else {
            *(unsigned char *)transt = 'N';
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
i__4 = nb, i__5 = *k - i__ + 1;
ib = min(i__4,i__5);

/*
     Form the triangular factor of the block reflector
     H = H(i) H(i+1) . . . H(i+ib-1)
*/

i__4 = nq - i__ + 1;
zlarft_("Forward", "Rowwise", &i__4, &ib, &a[i__ + i__ * a_dim1],
    lda, &tau[i__], t, &c__65);
if (left) {

/* H or H' is applied to C(i:m,1:n) */

mi = *m - i__ + 1;
ic = i__;
} else {

/* H or H' is applied to C(1:m,i:n) */

ni = *n - i__ + 1;
jc = i__;
}

/* Apply H or H' */

zlarfb_(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__
    + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1],
    ldc, &work[1], &ldwork);
/* L10: */
}
}
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
return 0;

/* End of ZUNMLQ */
} /* zunmlq_ */

/* Subroutine */ int zunmql_(char *side, char *trans, integer *m, integer *n,
integer *k, doublecomplex *a, integer *lda, doublecomplex *tau,
doublecomplex *c__, integer *ldc, doublecomplex *work, integer *lwork,
integer *info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
    i__5;
char ch__1[2];

/* Local variables */
static integer i__;
static doublecomplex t[4160]    /* was [65][64] */;
static integer i1, i2, i3, ib, nb, mi, ni, nq, nw, iws;
static logical left;
extern logical lsame_(char *, char *);
static integer nbmin, iinfo;
extern /* Subroutine */ int zunm2l_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
    integer *, integer *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *);
static logical notran;
static integer ldwork;
extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *);
static integer lwkopt;
static logical lquery;

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

Purpose
=======

ZUNMQL overwrites the general complex M-by-N matrix C with

                SIDE = 'L'     SIDE = 'R'
TRANS = 'N':    Q * C          C * Q
TRANS = 'C':    Q**H * C       C * Q**H

where Q is a complex unitary matrix defined as the product of k
*/
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
    """
    # SIDE 参数指定了操作的方向：'L' 表示从左侧应用 Q 或 Q**H；'R' 表示从右侧应用 Q 或 Q**H。

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
    """
    # TRANS 参数指定了操作是否转置：'N' 表示不转置，应用 Q；'C' 表示转置后应用 Q**H。

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    """
    # M 参数指定矩阵 C 的行数，必须大于等于 0。

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    """
    # N 参数指定矩阵 C 的列数，必须大于等于 0。

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
    """
    # K 参数指定了定义矩阵 Q 的初等反射器的数量。
    # 如果 SIDE = 'L'，则要求 M >= K >= 0；
    # 如果 SIDE = 'R'，则要求 N >= K >= 0。

    A       (input) COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
    """
    # A 参数是一个复数数组，维度为 (LDA, K)，存储了由 ZGEQLF 返回的初等反射器 H(i) 的向量。
    # A 的最后 K 列被 ZGEQLF 修改，但在退出时恢复原状。

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
    """
    # LDA 参数指定数组 A 的主维度。
    # 如果 SIDE = 'L'，则要求 LDA >= max(1, M)；
    # 如果 SIDE = 'R'，则要求 LDA >= max(1, N)。

    TAU     (input) COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
    """
    # TAU 参数是一个复数数组，维度为 (K)，存储由 ZGEQLF 返回的初等反射器 H(i) 的标量因子。

    C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
    """
    # C 参数是一个复数数组，维度为 (LDC, N)。
    # 在输入时，存储了一个 M-by-N 的矩阵 C。
    # 在输出时，根据操作类型，C 被 Q*C、Q**H*C、C*Q**H 或 C*Q 覆盖。

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    """
    # LDC 参数指定数组 C 的主维度。
    # 要求 LDC >= max(1, M)。

    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    """
    # WORK 参数是一个复数数组，维度为 (MAX(1, LWORK))，用作工作空间。
    # 在输出时，如果 INFO = 0，WORK(1) 返回最优的 LWORK 大小。

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    """
    # LWORK 参数指定了 WORK 数组的大小。
    # 如果 SIDE = 'L'，要求 LWORK >= max(1, N)；
    # 如果 SIDE = 'R'，要求 LWORK >= max(1, M)。
    # 为了达到最佳性能，建议 LWORK >= N*NB（如果 SIDE = 'L'），或 LWORK >= M*NB（如果 SIDE = 'R'），
    # 其中 NB 是最优块大小。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    """
    # INFO 参数是函数的输出，指示函数的执行状态。
    # 如果 INFO = 0，表示函数成功执行；
    # 如果 INFO < 0，表示第 -INFO 个参数具有非法值。

    =====================================================================


       Test the input arguments
    /* 参数调整 */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* 函数体 */
    *info = 0;
    left = lsame_(side, "L");    // 判断 side 是否为 'L'
    notran = lsame_(trans, "N"); // 判断 trans 是否为 'N'
    lquery = *lwork == -1;       // 判断是否需要查询工作空间大小

/*     NQ is the order of Q and NW is the minimum dimension of WORK */
    // 计算 NQ 和 NW
    if (left) {
        nq = *m;
        nw = max(1,*n);
    } else {
        nq = *n;
        nw = max(1,*m);
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;  // side 参数无效
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;  // trans 参数无效
    } else if (*m < 0) {
        *info = -3;  // m 参数无效
    } else if (*n < 0) {
        *info = -4;  // n 参数无效
    } else if (*k < 0 || *k > nq) {
        *info = -5;  // k 参数无效
    } else if (*lda < max(1,nq)) {
        *info = -7;  // lda 参数无效
    } else if (*ldc < max(1,*m)) {
        *info = -10; // ldc 参数无效
    }

    if (*info == 0) {
        if (*m == 0 || *n == 0) {
            lwkopt = 1;  // 如果 m 或 n 为 0，则工作空间大小为 1
        } else {
            // 计算推荐的工作空间大小
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 64, i__2 = ilaenv_(&c__1, "ZUNMQL", ch__1, m, n, k, &c_n1,
                (ftnlen)6, (ftnlen)2);
            nb = min(i__1,i__2);  // 计算块大小 nb
            lwkopt = nw * nb;     // 计算所需的工作空间大小
        }
        work[1].r = (doublereal) lwkopt, work[1].i = 0.;  // 设置工作空间大小

        if (*lwork < nw && ! lquery) {
            *info = -12;  // lwork 参数过小
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNMQL", &i__1);  // 报错处理
        return 0;
    } else if (lquery) {
        return 0;  // 如果只查询工作空间大小，则直接返回
    }

/*     如果可能的话，快速返回 */
    if (*m == 0 || *n == 0) {
        return 0;  // 如果 m 或 n 为 0，直接返回
    }

    nbmin = 2;  // 设置最小块大小
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;  // 调整块大小 nb
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "ZUNMQL", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);  // 更新最小块大小 nbmin
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {

/*        使用未块化的代码 */
        zunm2l_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);
    } else {

/*        使用块化的代码 */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
        } else {
            mi = *m;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            // 计算当前块的大小 ib
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);
/*
    Form the triangular factor of the block reflector
    H = H(i+ib-1) . . . H(i+1) H(i)
*/
i__4 = nq - *k + i__ + ib - 1;
zlarft_("Backward", "Columnwise", &i__4, &ib, &a[i__ * a_dim1 + 1], lda, &tau[i__], t, &c__65);
if (left) {
    /*
        H or H' is applied to C(1:m-k+i+ib-1,1:n)
    */
    mi = *m - *k + i__ + ib - 1;
} else {
    /*
        H or H' is applied to C(1:m,1:n-k+i+ib-1)
    */
    ni = *n - *k + i__ + ib - 1;
}

/*
    Apply H or H'
*/
zlarfb_(side, trans, "Backward", "Columnwise", &mi, &ni, &ib, &a[i__ * a_dim1 + 1], lda, t, &c__65, &c__[c_offset], ldc, &work[1], &ldwork);
/* L10: */
}
}
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
return 0;

/* End of ZUNMQL */
} /* zunmql_ */

/* Subroutine */ int zunmqr_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublecomplex *a, integer *lda, doublecomplex *tau,
    doublecomplex *c__, integer *ldc, doublecomplex *work, integer *lwork,
    integer *info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
    i__5;
char ch__1[2];

/* Local variables */
static integer i__;
static doublecomplex t[4160]    /* was [65][64] */;
static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
static logical left;
extern logical lsame_(char *, char *);
static integer nbmin, iinfo;
extern /* Subroutine */ int zunm2r_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *,
    integer *, integer *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *, doublecomplex *, integer *,
    doublecomplex *, integer *);
static logical notran;
static integer ldwork;
extern /* Subroutine */ int zlarft_(char *, char *, integer *, integer *,
    doublecomplex *, integer *, doublecomplex *, doublecomplex *,
    integer *);
static integer lwkopt;
static logical lquery;

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
   November 2006

Purpose
=======

ZUNMQR overwrites the general complex M-by-N matrix C with

    SIDE = 'L'     SIDE = 'R'
TRANS = 'N':      Q * C          C * Q
TRANS = 'C':      Q**H * C       C * Q**H

where Q is a complex unitary matrix defined as the product of k
elementary reflectors

    Q = H(1) H(2) . . . H(k)
*/
    # 测试输入参数的有效性
    if m < 0:
        # 如果 M 小于 0，设置 INFO 返回值为 -1 并返回
        info = -1
    elif n < 0:
        # 如果 N 小于 0，设置 INFO 返回值为 -2 并返回
        info = -2
    elif (side != 'L' and side != 'R'):
        # 如果 SIDE 不是 'L' 也不是 'R'，设置 INFO 返回值为 -3 并返回
        info = -3
    elif (trans != 'N' and trans != 'C'):
        # 如果 TRANS 不是 'N' 也不是 'C'，设置 INFO 返回值为 -4 并返回
        info = -4
    elif (side == 'L' and m < k):
        # 如果 SIDE 是 'L' 且 M 小于 K，设置 INFO 返回值为 -6 并返回
        info = -6
    elif (side == 'R' and n < k):
        # 如果 SIDE 是 'R' 且 N 小于 K，设置 INFO 返回值为 -6 并返回
        info = -6
    elif lda < max(1, (m if side == 'L' else n)):
        # 如果 LDA 小于 max(1, M)（如果 SIDE 是 'L'），或小于 max(1, N)（如果 SIDE 是 'R'），设置 INFO 返回值为 -8 并返回
        info = -8
    elif ldc < max(1, m):
        # 如果 LDC 小于 max(1, M)，设置 INFO 返回值为 -10 并返回
        info = -10
    elif lwork < 1 and lwork != -1:
        # 如果 LWORK 小于 1 且不等于 -1，设置 INFO 返回值为 -12 并返回
        info = -12

    # 如果需要进行工作空间查询，设置 WORK[0] 为所需的最优 LWORK 值
    if lwork == -1:
        work[0] = max(1, (n if side == 'L' else m))
    # 如果 INFO 不等于 0，返回 INFO
    elif info != 0:
        return
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        /* Determine the block size. NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "ZUNMQR", ch__1, m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1].r = (doublereal) lwkopt, work[1].i = 0.;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("ZUNMQR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1].r = 1., work[1].i = 0.;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "ZUNMQR", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        zunm2r_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && ! notran || ! left && notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);
/*
    Form the triangular factor of the block reflector
    H = H(i) H(i+1) . . . H(i+ib-1)
*/
i__4 = nq - i__ + 1;
zlarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ *
    a_dim1], lda, &tau[i__], t, &c__65)
    ;

if (left) {
    /*
        H or H' is applied to C(i:m,1:n)
    */
    mi = *m - i__ + 1;
    ic = i__;
} else {
    /*
        H or H' is applied to C(1:m,i:n)
    */
    ni = *n - i__ + 1;
    jc = i__;
}

/*
    Apply H or H'
*/
zlarfb_(side, trans, "Forward", "Columnwise", &mi, &ni, &ib, &a[
    i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc *
    c_dim1], ldc, &work[1], &ldwork);
/* L10: */
}
}
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
return 0;

/* End of ZUNMQR */
} /* zunmqr_ */

/* Subroutine */ int zunmtr_(char *side, char *uplo, char *trans, integer *m,
integer *n, doublecomplex *a, integer *lda, doublecomplex *tau,
doublecomplex *c__, integer *ldc, doublecomplex *work, integer *lwork,
 integer *info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2, i__3;
char ch__1[2];

/* Local variables */
static integer i1, i2, nb, mi, ni, nq, nw;
static logical left;
extern logical lsame_(char *, char *);
static integer iinfo;
static logical upper;
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static integer lwkopt;
static logical lquery;
extern /* Subroutine */ int zunmql_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *, integer *), zunmqr_(char *, char *, integer *, integer *,
    integer *, doublecomplex *, integer *, doublecomplex *,
    doublecomplex *, integer *, doublecomplex *, integer *, integer *);

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

Purpose
=======

ZUNMTR overwrites the general complex M-by-N matrix C with

                SIDE = 'L'     SIDE = 'R'
TRANS = 'N':    Q * C          C * Q
TRANS = 'C':    Q**H * C       C * Q**H

where Q is a complex unitary matrix of order nq, with nq = m if
SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
nq-1 elementary reflectors, as returned by ZHETRD:

if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'L': apply Q or Q**H from the Left;
        = 'R': apply Q or Q**H from the Right.
*/
    UPLO    (input) CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from ZHETRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from ZHETRD.
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    A       (input) COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by ZHETRD.
    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
    TAU     (input) COMPLEX*16 array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZHETRD.
    C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >=M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    =====================================================================
       Test the input arguments
/* Parameter adjustments */
/* 调整参数 */

a_dim1 = *lda;
/* 设置数组 a 的第一维度为 lda */

a_offset = 1 + a_dim1;
/* 计算 a 数组的偏移量 */

a -= a_offset;
/* 将 a 数组指针调整为正确的起始位置 */

--tau;
/* 减少 tau 数组的指针位置 */

c_dim1 = *ldc;
/* 设置数组 c 的第一维度为 ldc */

c_offset = 1 + c_dim1;
/* 计算 c 数组的偏移量 */

c__ -= c_offset;
/* 将 c 数组指针调整为正确的起始位置 */

--work;
/* 减少 work 数组的指针位置 */

/* Function Body */
/* 函数体开始 */

*info = 0;
/* 初始化 info 为 0 */

left = lsame_(side, "L");
/* 检查 side 参数是否为 'L' */

upper = lsame_(uplo, "U");
/* 检查 uplo 参数是否为 'U' */

lquery = *lwork == -1;
/* 检查是否在查询工作空间大小 */

/*     NQ is the order of Q and NW is the minimum dimension of WORK */
/*     NQ 是 Q 的阶数，NW 是 WORK 的最小维度 */

if (left) {
/* 如果 side 参数是 'L' */
nq = *m;
/* 设置 nq 为 m */
nw = *n;
/* 设置 nw 为 n */
} else {
/* 如果 side 参数不是 'L' */
nq = *n;
/* 设置 nq 为 n */
nw = *m;
/* 设置 nw 为 m */
}
if (! left && ! lsame_(side, "R")) {
/* 如果 side 参数既不是 'L' 也不是 'R' */
*info = -1;
/* 设置 info 为 -1 */
} else if (! upper && ! lsame_(uplo, "L")) {
/* 如果 uplo 参数既不是 'U' 也不是 'L' */
*info = -2;
/* 设置 info 为 -2 */
} else if (! lsame_(trans, "N") && ! lsame_(trans,
    "C")) {
/* 如果 trans 参数既不是 'N' 也不是 'C' */
*info = -3;
/* 设置 info 为 -3 */
} else if (*m < 0) {
/* 如果 m 小于 0 */
*info = -4;
/* 设置 info 为 -4 */
} else if (*n < 0) {
/* 如果 n 小于 0 */
*info = -5;
/* 设置 info 为 -5 */
} else if (*lda < max(1,nq)) {
/* 如果 lda 小于 max(1,nq) */
*info = -7;
/* 设置 info 为 -7 */
} else if (*ldc < max(1,*m)) {
/* 如果 ldc 小于 max(1,m) */
*info = -10;
/* 设置 info 为 -10 */
} else if (*lwork < max(1,nw) && ! lquery) {
/* 如果 lwork 小于 max(1,nw) 并且不是查询工作空间大小 */
*info = -12;
/* 设置 info 为 -12 */
}

if (*info == 0) {
/* 如果 info 为 0 */
if (upper) {
/* 如果 uplo 参数是 'U' */
if (left) {
/* 如果 side 参数是 'L' */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 设置 ch__1 为 side 和 trans 拼接而成的字符串 */
i__2 = *m - 1;
/* 设置 i__2 为 m - 1 */
i__3 = *m - 1;
/* 设置 i__3 为 m - 1 */
nb = ilaenv_(&c__1, "ZUNMQL", ch__1, &i__2, n, &i__3, &c_n1, (
    ftnlen)6, (ftnlen)2);
/* 调用 ilaenv 函数获取 nb 的值 */
} else {
/* 如果 side 参数不是 'L' */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 设置 ch__1 为 side 和 trans 拼接而成的字符串 */
i__2 = *n - 1;
/* 设置 i__2 为 n - 1 */
i__3 = *n - 1;
/* 设置 i__3 为 n - 1 */
nb = ilaenv_(&c__1, "ZUNMQL", ch__1, m, &i__2, &i__3, &c_n1, (
    ftnlen)6, (ftnlen)2);
/* 调用 ilaenv 函数获取 nb 的值 */
}
} else {
/* 如果 uplo 参数不是 'U' */
if (left) {
/* 如果 side 参数是 'L' */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 设置 ch__1 为 side 和 trans 拼接而成的字符串 */
i__2 = *m - 1;
/* 设置 i__2 为 m - 1 */
i__3 = *m - 1;
/* 设置 i__3 为 m - 1 */
nb = ilaenv_(&c__1, "ZUNMQR", ch__1, &i__2, n, &i__3, &c_n1, (
    ftnlen)6, (ftnlen)2);
/* 调用 ilaenv 函数获取 nb 的值 */
} else {
/* 如果 side 参数不是 'L' */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 设置 ch__1 为 side 和 trans 拼接而成的字符串 */
i__2 = *n - 1;
/* 设置 i__2 为 n - 1 */
i__3 = *n - 1;
/* 设置 i__3 为 n - 1 */
nb = ilaenv_(&c__1, "ZUNMQR", ch__1, m, &i__2, &i__3, &c_n1, (
    ftnlen)6, (ftnlen)2);
/* 调用 ilaenv 函数获取 nb 的值 */
}
}
lwkopt = max(1,nw) * nb;
/* 计算所需的最佳工作空间大小 */
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
/* 设置 work 数组的第一个元素为计算得到的最佳工作空间大小 */

}

if (*info != 0) {
/* 如果 info 不为 0 */
i__2 = -(*info);
/* 计算 info 的负值 */
xerbla_("ZUNMTR", &i__2);
/* 调用 xerbla 函数 */
return 0;
/* 返回 0 */
} else if (lquery) {
/* 否则，如果在查询工作空间大小 */
return 0;
/* 返回 0 */
}

/*     Quick return if possible */
/*     如果可能的话，快速返回 */

if (*m == 0 || *n == 0 || nq == 1) {
/* 如果 m 或 n 为 0，或者 nq 为 1 */
work[1].r = 1., work[1].i = 0.;
/* 设置 work 数组的第一个元素为 1+0i */
return 0;
/* 返回 0 */
}

if (left) {
/* 如果 side 参数是 'L' */
mi = *m - 1;
/* 设置 mi 为 m - 1 */
ni = *n;
/* 设置 ni 为 n */
} else {
/* 如果 side 参数不是 'L' */
mi = *m;
/* 设置 mi 为 m */
ni = *n - 1;
    zunmql_(side, trans, &mi, &ni, &i__2, &a[(a_dim1 << 1) + 1], lda, &
        tau[1], &c__[c_offset], ldc, &work[1], lwork, &iinfo);

# 调用 LAPACK 函数 zunmql_
调用 LAPACK 库中的 zunmql_ 函数，用于计算 Q 矩阵与另一矩阵的乘积。


    } else {

# 如果条件不满足，则执行以下代码块
当条件不满足时，执行与之相关的代码块。
/*        Q was determined by a call to ZHETRD with UPLO = 'L' */
/*        根据 UPLO = 'L' 调用 ZHETRD 确定了 Q */

if (left) {
    /* 如果 left 为真，则执行以下代码块 */
    i1 = 2;
    /* 设置 i1 为 2 */
    i2 = 1;
    /* 设置 i2 为 1 */
} else {
    /* 如果 left 为假，则执行以下代码块 */
    i1 = 1;
    /* 设置 i1 为 1 */
    i2 = 2;
    /* 设置 i2 为 2 */
}
/* 计算 i__2 的值为 nq - 1 */
i__2 = nq - 1;
/* 调用 zunmqr 函数进行矩阵乘法和QR分解 */
zunmqr_(side, trans, &mi, &ni, &i__2, &a[a_dim1 + 2], lda, &tau[1], &
    c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
/* 将 work[1] 的实部设为 lwkopt，虚部设为 0 */
work[1].r = (doublereal) lwkopt, work[1].i = 0.;
/* 返回 0 */
return 0;

/*     End of ZUNMTR */
/*     ZUNMTR 函数结束 */

} /* zunmtr_ */
/* zunmtr_ 函数结束 */
```