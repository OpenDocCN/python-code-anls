# `.\numpy\numpy\f2py\tests\src\array_from_pyobj\wrapmodule.c`

```py
/*
 * This file was auto-generated with f2py (version:2_1330) and hand edited by
 * Pearu for testing purposes.  Do not edit this file unless you know what you
 * are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include "fortranobject.h"
#include <math.h>

// 定义包裹错误和包裹模块对象
static PyObject *wrap_error;
static PyObject *wrap_module;

/************************************ call ************************************/
// 函数签名文档字符串
static char doc_f2py_rout_wrap_call[] = "\
Function signature:\n\
  arr = call(type_num,dims,intent,obj)\n\
Required arguments:\n"
"  type_num : input int\n"
"  dims : input int-sequence\n"
"  intent : input int\n"
"  obj : input python object\n"
"Return objects:\n"
"  arr : array";
// 包裹函数，调用Fortran函数并返回结果
static PyObject *f2py_rout_wrap_call(PyObject *capi_self,
                                     PyObject *capi_args) {
  PyObject * volatile capi_buildvalue = NULL;
  int type_num = 0;
  int elsize = 0;
  npy_intp *dims = NULL;
  PyObject *dims_capi = Py_None;
  int rank = 0;
  int intent = 0;
  PyArrayObject *capi_arr_tmp = NULL;
  PyObject *arr_capi = Py_None;
  int i;

  // 解析参数元组
  if (!PyArg_ParseTuple(capi_args,"iiOiO|:wrap.call",\
                        &type_num,&elsize,&dims_capi,&intent,&arr_capi))
    return NULL;
  // 获取序列的长度作为数组的维度
  rank = PySequence_Length(dims_capi);
  dims = malloc(rank*sizeof(npy_intp));
  // 遍历序列，获取每个维度的值
  for (i=0;i<rank;++i) {
    PyObject *tmp;
    tmp = PySequence_GetItem(dims_capi, i);
    if (tmp == NULL) {
        goto fail;
    }
    dims[i] = (npy_intp)PyLong_AsLong(tmp);
    Py_DECREF(tmp);
    if (dims[i] == -1 && PyErr_Occurred()) {
        goto fail;
    }
  }
  // 调用ndarray_from_pyobj函数，将Python对象转换为NumPy数组对象
  capi_arr_tmp = ndarray_from_pyobj(type_num,elsize,dims,rank,intent|F2PY_INTENT_OUT,arr_capi,"wrap.call failed");
  if (capi_arr_tmp == NULL) {
    free(dims);
    return NULL;
  }
  // 构建返回值，包含NumPy数组对象
  capi_buildvalue = Py_BuildValue("N",capi_arr_tmp);
  free(dims);
  return capi_buildvalue;

fail:
  free(dims);
  return NULL;
}

/************************************ attrs ************************************/
// 函数签名文档字符串
static char doc_f2py_rout_wrap_attrs[] = "\
Function signature:\n\
  arr = array_attrs(arr)\n\
Required arguments:\n"
"  arr : input array object\n"
"Return objects:\n"
"  data : data address in hex\n"
"  nd : int\n"
"  dimensions : tuple\n"
"  strides : tuple\n"
"  base : python object\n"
"  (kind,type,type_num,elsize,alignment) : 4-tuple\n"
"  flags : int\n"
"  itemsize : int\n"
;
// 包裹函数，返回NumPy数组对象的属性信息
static PyObject *f2py_rout_wrap_attrs(PyObject *capi_self,
                                      PyObject *capi_args) {
  PyObject *arr_capi = Py_None;
  PyArrayObject *arr = NULL;
  PyObject *dimensions = NULL;
  PyObject *strides = NULL;
  char s[100];
  int i;
  memset(s,0,100);
  // 解析参数元组，验证输入参数是否正确
  if (!PyArg_ParseTuple(capi_args,"O!|:wrap.attrs",
                        &PyArray_Type,&arr_capi))
    return NULL;
  // 将Python对象转换为NumPy数组对象
  arr = (PyArrayObject *)arr_capi;
  // 将数据地址转换为十六进制字符串
  sprintf(s,"%p",PyArray_DATA(arr));
  // 创建维度元组和步长元组
  dimensions = PyTuple_New(PyArray_NDIM(arr));
  strides = PyTuple_New(PyArray_NDIM(arr));
  // 遍历数组的维度，获取每个维度和步长
  for (i=0;i<PyArray_NDIM(arr);++i) {
    # 设置元组中的第 i 个元素为 PyArray_DIM(arr, i) 返回的长整型对象
    PyTuple_SetItem(dimensions, i, PyLong_FromLong(PyArray_DIM(arr, i)));
    # 设置元组中的第 i 个元素为 PyArray_STRIDE(arr, i) 返回的长整型对象
    PyTuple_SetItem(strides, i, PyLong_FromLong(PyArray_STRIDE(arr, i)));
  }
  # 构建一个包含多个值的 Python 元组对象，并返回该元组对象
  return Py_BuildValue("siNNO(cciii)ii", s, PyArray_NDIM(arr),
                       dimensions, strides,
                       (PyArray_BASE(arr)==NULL ? Py_None : PyArray_BASE(arr)),
                       PyArray_DESCR(arr)->kind,
                       PyArray_DESCR(arr)->type,
                       PyArray_TYPE(arr),
                       PyArray_ITEMSIZE(arr),
                       PyArray_DESCR(arr)->alignment,
                       PyArray_FLAGS(arr),
                       PyArray_ITEMSIZE(arr));
}

static PyMethodDef f2py_module_methods[] = {
    // 定义 Python 模块中的方法列表，每个条目包含方法名、函数指针、参数类型和文档字符串
    {"call", f2py_rout_wrap_call, METH_VARARGS, doc_f2py_rout_wrap_call},
    {"array_attrs", f2py_rout_wrap_attrs, METH_VARARGS, doc_f2py_rout_wrap_attrs},
    {NULL, NULL}  // 方法列表结束标记
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,  // 初始化 Python 模块定义结构
    "test_array_from_pyobj_ext",  // 模块名称
    NULL,  // 模块文档字符串（此处为NULL）
    -1,    // 模块状态（此处为-1）
    f2py_module_methods,  // 指向模块方法列表的指针
    NULL,  // 模块的全局状态
    NULL,  // 模块的方法定义结构
    NULL,  // 模块的每个方法的文档字符串
    NULL   // 模块的清理函数
};

PyMODINIT_FUNC PyInit_test_array_from_pyobj_ext(void) {
    PyObject *m, *d, *s;
    // 创建 Python 模块对象，并将其赋值给变量 m 和 wrap_module
    m = wrap_module = PyModule_Create(&moduledef);
    // 将 PyFortran_Type 类型设置为 PyType_Type 类型
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    // 导入 NumPy 库
    import_array();
    // 检查是否有异常发生，若有则致命错误
    if (PyErr_Occurred())
        Py_FatalError("can't initialize module wrap (failed to import numpy)");
    // 获取模块的字典对象
    d = PyModule_GetDict(m);
    // 创建包含模块说明的 Unicode 字符串对象，并设置为模块的 __doc__ 属性
    s = PyUnicode_FromString("This module 'wrap' is auto-generated with f2py (version:2_1330).\nFunctions:\n"
                             "  arr = call(type_num,dims,intent,obj)\n"
                             ".");
    PyDict_SetItemString(d, "__doc__", s);
    // 创建 wrap.error 异常并设置到模块的全局字典中
    wrap_error = PyErr_NewException("wrap.error", NULL, NULL);
    Py_DECREF(s);

    // 定义宏 ADDCONST，用于向模块的字典中添加常量
#define ADDCONST(NAME, CONST)              \
    s = PyLong_FromLong(CONST);             \
    PyDict_SetItemString(d, NAME, s);      \

    // 以下代码可能继续定义各种常量，并添加到模块字典中
  // 释放 Python 对象 s 的引用计数
  Py_DECREF(s)

  // 添加常量 "F2PY_INTENT_IN" 到模块中
  ADDCONST("F2PY_INTENT_IN", F2PY_INTENT_IN);
  // 添加常量 "F2PY_INTENT_INOUT" 到模块中
  ADDCONST("F2PY_INTENT_INOUT", F2PY_INTENT_INOUT);
  // 添加常量 "F2PY_INTENT_OUT" 到模块中
  ADDCONST("F2PY_INTENT_OUT", F2PY_INTENT_OUT);
  // 添加常量 "F2PY_INTENT_HIDE" 到模块中
  ADDCONST("F2PY_INTENT_HIDE", F2PY_INTENT_HIDE);
  // 添加常量 "F2PY_INTENT_CACHE" 到模块中
  ADDCONST("F2PY_INTENT_CACHE", F2PY_INTENT_CACHE);
  // 添加常量 "F2PY_INTENT_COPY" 到模块中
  ADDCONST("F2PY_INTENT_COPY", F2PY_INTENT_COPY);
  // 添加常量 "F2PY_INTENT_C" 到模块中
  ADDCONST("F2PY_INTENT_C", F2PY_INTENT_C);
  // 添加常量 "F2PY_OPTIONAL" 到模块中
  ADDCONST("F2PY_OPTIONAL", F2PY_OPTIONAL);
  // 添加常量 "F2PY_INTENT_INPLACE" 到模块中
  ADDCONST("F2PY_INTENT_INPLACE", F2PY_INTENT_INPLACE);
  // 添加常量 "NPY_BOOL" 到模块中
  ADDCONST("NPY_BOOL", NPY_BOOL);
  // 添加常量 "NPY_BYTE" 到模块中
  ADDCONST("NPY_BYTE", NPY_BYTE);
  // 添加常量 "NPY_UBYTE" 到模块中
  ADDCONST("NPY_UBYTE", NPY_UBYTE);
  // 添加常量 "NPY_SHORT" 到模块中
  ADDCONST("NPY_SHORT", NPY_SHORT);
  // 添加常量 "NPY_USHORT" 到模块中
  ADDCONST("NPY_USHORT", NPY_USHORT);
  // 添加常量 "NPY_INT" 到模块中
  ADDCONST("NPY_INT", NPY_INT);
  // 添加常量 "NPY_UINT" 到模块中
  ADDCONST("NPY_UINT", NPY_UINT);
  // 添加常量 "NPY_INTP" 到模块中
  ADDCONST("NPY_INTP", NPY_INTP);
  // 添加常量 "NPY_UINTP" 到模块中
  ADDCONST("NPY_UINTP", NPY_UINTP);
  // 添加常量 "NPY_LONG" 到模块中
  ADDCONST("NPY_LONG", NPY_LONG);
  // 添加常量 "NPY_ULONG" 到模块中
  ADDCONST("NPY_ULONG", NPY_ULONG);
  // 添加常量 "NPY_LONGLONG" 到模块中
  ADDCONST("NPY_LONGLONG", NPY_LONGLONG);
  // 添加常量 "NPY_ULONGLONG" 到模块中
  ADDCONST("NPY_ULONGLONG", NPY_ULONGLONG);
  // 添加常量 "NPY_FLOAT" 到模块中
  ADDCONST("NPY_FLOAT", NPY_FLOAT);
  // 添加常量 "NPY_DOUBLE" 到模块中
  ADDCONST("NPY_DOUBLE", NPY_DOUBLE);
  // 添加常量 "NPY_LONGDOUBLE" 到模块中
  ADDCONST("NPY_LONGDOUBLE", NPY_LONGDOUBLE);
  // 添加常量 "NPY_CFLOAT" 到模块中
  ADDCONST("NPY_CFLOAT", NPY_CFLOAT);
  // 添加常量 "NPY_CDOUBLE" 到模块中
  ADDCONST("NPY_CDOUBLE", NPY_CDOUBLE);
  // 添加常量 "NPY_CLONGDOUBLE" 到模块中
  ADDCONST("NPY_CLONGDOUBLE", NPY_CLONGDOUBLE);
  // 添加常量 "NPY_OBJECT" 到模块中
  ADDCONST("NPY_OBJECT", NPY_OBJECT);
  // 添加常量 "NPY_STRING" 到模块中
  ADDCONST("NPY_STRING", NPY_STRING);
  // 添加常量 "NPY_UNICODE" 到模块中
  ADDCONST("NPY_UNICODE", NPY_UNICODE);
  // 添加常量 "NPY_VOID" 到模块中
  ADDCONST("NPY_VOID", NPY_VOID);
  // 添加常量 "NPY_NTYPES_LEGACY" 到模块中
  ADDCONST("NPY_NTYPES_LEGACY", NPY_NTYPES_LEGACY);
  // 添加常量 "NPY_NOTYPE" 到模块中
  ADDCONST("NPY_NOTYPE", NPY_NOTYPE);
  // 添加常量 "NPY_USERDEF" 到模块中
  ADDCONST("NPY_USERDEF", NPY_USERDEF);

  // 添加常量 "CONTIGUOUS" 到模块中
  ADDCONST("CONTIGUOUS", NPY_ARRAY_C_CONTIGUOUS);
  // 添加常量 "FORTRAN" 到模块中
  ADDCONST("FORTRAN", NPY_ARRAY_F_CONTIGUOUS);
  // 添加常量 "OWNDATA" 到模块中
  ADDCONST("OWNDATA", NPY_ARRAY_OWNDATA);
  // 添加常量 "FORCECAST" 到模块中
  ADDCONST("FORCECAST", NPY_ARRAY_FORCECAST);
  // 添加常量 "ENSURECOPY" 到模块中
  ADDCONST("ENSURECOPY", NPY_ARRAY_ENSURECOPY);
  // 添加常量 "ENSUREARRAY" 到模块中
  ADDCONST("ENSUREARRAY", NPY_ARRAY_ENSUREARRAY);
  // 添加常量 "ALIGNED" 到模块中
  ADDCONST("ALIGNED", NPY_ARRAY_ALIGNED);
  // 添加常量 "WRITEABLE" 到模块中
  ADDCONST("WRITEABLE", NPY_ARRAY_WRITEABLE);
  // 添加常量 "WRITEBACKIFCOPY" 到模块中
  ADDCONST("WRITEBACKIFCOPY", NPY_ARRAY_WRITEBACKIFCOPY);

  // 添加常量 "BEHAVED" 到模块中
  ADDCONST("BEHAVED", NPY_ARRAY_BEHAVED);
  // 添加常量 "BEHAVED_NS" 到模块中
  ADDCONST("BEHAVED_NS", NPY_ARRAY_BEHAVED_NS);
  // 添加常量 "CARRAY" 到模块中
  ADDCONST("CARRAY", NPY_ARRAY_CARRAY);
  // 添加常量 "FARRAY" 到模块中
  ADDCONST("FARRAY", NPY_ARRAY_FARRAY);
  // 添加常量 "CARRAY_RO" 到模块中
  ADDCONST("CARRAY_RO", NPY_ARRAY_CARRAY_RO);
  // 添加常量 "FARRAY_RO" 到模块中
  ADDCONST("FARRAY_RO", NPY_ARRAY_FARRAY_RO);
  // 添加常量 "DEFAULT" 到模块中
  ADDCONST("DEFAULT", NPY_ARRAY_DEFAULT);
  // 添加常量 "UPDATE_ALL" 到模块中
  ADDCONST("UPDATE_ALL", NPY_ARRAY_UPDATE_ALL);
#undef ADDCONST(

取消定义一个名为ADDCONST的宏。在这里，可能是取消定义某个在此之前定义的宏。


  if (PyErr_Occurred())
    Py_FatalError("can't initialize module wrap");

如果Python中发生了错误，调用Py_FatalError函数，程序将无法初始化模块wrap。


#ifdef F2PY_REPORT_ATEXIT
  on_exit(f2py_report_on_exit,(void*)"array_from_pyobj.wrap.call");
#endif

如果已定义了宏F2PY_REPORT_ATEXIT，则在程序退出时调用on_exit函数，传递f2py_report_on_exit函数和字符串"array_from_pyobj.wrap.call"作为参数。


  return m;
}
#ifdef __cplusplus
}
#endif

返回模块对象m并结束当前函数。如果是C++环境，则关闭extern "C"的语言链接规范。
```