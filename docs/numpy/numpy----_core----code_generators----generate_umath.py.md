# `.\numpy\numpy\_core\code_generators\generate_umath.py`

```
"""
Generate the code to build all the internal ufuncs. At the base is the defdict:
a dictionary of Ufunc classes. This is fed to make_code to generate
__umath_generated.c
"""
# 导入必要的库
import os  # 系统操作相关
import re  # 正则表达式模块
import struct  # 解析和打包基于字节的数据结构，如 C 结构体
import sys  # 系统相关的参数和功能
import textwrap  # 文本包装和填充模块
import argparse  # 命令行解析模块

# identity objects
# 定义几个常量和对象
Zero = "PyLong_FromLong(0)"  # 表示整数 0 的 PyLong 对象
One = "PyLong_FromLong(1)"  # 表示整数 1 的 PyLong 对象
True_ = "(Py_INCREF(Py_True), Py_True)"  # 表示布尔值 True 的对象
False_ = "(Py_INCREF(Py_False), Py_False)"  # 表示布尔值 False 的对象
None_ = object()  # 表示 None 的对象
AllOnes = "PyLong_FromLong(-1)"  # 表示整数 -1 的 PyLong 对象
MinusInfinity = 'PyFloat_FromDouble(-NPY_INFINITY)'  # 表示负无穷大的浮点数对象
ReorderableNone = "(Py_INCREF(Py_None), Py_None)"  # 表示可重新排序的 None 对象

class docstrings:
    @staticmethod
    def get(place):
        """
        Returns the C #definition name of docstring according
        to ufunc place. C #definitions are generated by generate_umath_doc.py
        in a separate C header.
        """
        return 'DOC_' + place.upper().replace('.', '_')

# Sentinel value to specify using the full type description in the
# function name
class FullTypeDescr:
    pass

class FuncNameSuffix:
    """Stores the suffix to append when generating functions names.
    """
    def __init__(self, suffix):
        self.suffix = suffix

class TypeDescription:
    """Type signature for a ufunc.

    Attributes
    ----------
    type : str
        Character representing the nominal type.
    func_data : str or None or FullTypeDescr or FuncNameSuffix, optional
        The string representing the expression to insert into the data
        array, if any.
    in_ : str or None, optional
        The typecode(s) of the inputs.
    out : str or None, optional
        The typecode(s) of the outputs.
    astype : dict or None, optional
        If astype['x'] is 'y', uses PyUFunc_x_x_As_y_y/PyUFunc_xx_x_As_yy_y
        instead of PyUFunc_x_x/PyUFunc_xx_x.
    cfunc_alias : str or none, optional
        Appended to inner loop C function name, e.g., FLOAT_{cfunc_alias}. See make_arrays.
        NOTE: it doesn't support 'astype'
    dispatch : str or None, optional
        Dispatch-able source name without its extension '.dispatch.c' that
        contains the definition of ufunc, dispatched at runtime depending on the
        specified targets of the dispatch-able source.
        NOTE: it doesn't support 'astype'
    """
    def __init__(self, type, f=None, in_=None, out=None, astype=None, cfunc_alias=None,
                 dispatch=None):
        self.type = type  # ufunc 的类型标识符
        self.func_data = f  # 插入到数据数组中的表达式字符串，如果有的话
        if astype is None:
            astype = {}
        self.astype_dict = astype  # astype 参数的字典形式
        if in_ is not None:
            in_ = in_.replace('P', type)  # 输入类型的类型码，可能会替换 'P' 为具体类型
        self.in_ = in_
        if out is not None:
            out = out.replace('P', type)  # 输出类型的类型码，可能会替换 'P' 为具体类型
        self.out = out
        self.cfunc_alias = cfunc_alias  # 用于内部循环 C 函数名的附加字符串
        self.dispatch = dispatch  # 可调度的源文件名，不包含 '.dispatch.c' 后缀
    # 定义一个方法用于完成签名设置，接收输入和输出的数量参数 nin 和 nout
    def finish_signature(self, nin, nout):
        # 如果输入数据为空，则使用类型 self.type 复制 nin 次来初始化 self.in_
        if self.in_ is None:
            self.in_ = self.type * nin
        # 断言 self.in_ 的长度必须等于 nin
        assert len(self.in_) == nin
        # 如果输出数据为空，则使用类型 self.type 复制 nout 次来初始化 self.out
        if self.out is None:
            self.out = self.type * nout
        # 断言 self.out 的长度必须等于 nout
        assert len(self.out) == nout
        # 根据 self.type 在 self.astype_dict 中获取对应的数据类型，赋值给 self.astype
        self.astype = self.astype_dict.get(self.type, None)
def TD(types, f=None, astype=None, in_=None, out=None, cfunc_alias=None,
       dispatch=None):
    """
    Generate a TypeDescription instance for each item in types
    """
    # 如果提供了函数 f，则根据 types 和 f 构建函数数据
    if f is not None:
        # 如果 f 是字符串，则使用 build_func_data 函数构建函数数据
        if isinstance(f, str):
            func_data = build_func_data(types, f)
        # 否则，检查 f 的长度是否与 types 相匹配
        elif len(f) != len(types):
            raise ValueError("Number of types and f do not match")
        else:
            func_data = f
    else:
        # 如果未提供 f，则初始化 func_data 为 None
        func_data = (None,) * len(types)
    
    # 如果输入类型 in_ 是字符串，则将其扩展成与 types 相同长度的元组
    if isinstance(in_, str):
        in_ = (in_,) * len(types)
    # 如果 in_ 是 None，则初始化为与 types 相同长度的 None 元组
    elif in_ is None:
        in_ = (None,) * len(types)
    # 否则，检查 in_ 的长度是否与 types 相匹配
    elif len(in_) != len(types):
        raise ValueError("Number of types and inputs do not match")
    
    # 如果输出类型 out 是字符串，则将其扩展成与 types 相同长度的元组
    if isinstance(out, str):
        out = (out,) * len(types)
    # 如果 out 是 None，则初始化为与 types 相同长度的 None 元组
    elif out is None:
        out = (None,) * len(types)
    # 否则，检查 out 的长度是否与 types 相匹配
    elif len(out) != len(types):
        raise ValueError("Number of types and outputs do not match")
    
    # 初始化一个空列表 tds，用于存储 TypeDescription 实例
    tds = []
    for t, fd, i, o in zip(types, func_data, in_, out):
        # 遍历四个列表 types, func_data, in_, out，每次迭代取出一个元素 t, fd, i, o
        # 创建一个空列表 tds 用来存储 TypeDescription 对象
        tds.append(TypeDescription(
            t, f=fd, in_=i, out=o, astype=astype, cfunc_alias=cfunc_alias,
            dispatch=dispt
        ))
    # 返回填充了 TypeDescription 对象的列表 tds
    return tds
class Ufunc:
    """描述一个ufunc。

    Attributes
    ----------
    nin : 输入参数数量
    nout : 输出参数数量
    identity : 两个参数函数的单位元素（比如Zero）
    docstring : ufunc 的文档字符串
    typereso : 类型解析函数，类型为 PyUFunc_TypeResolutionFunc
    type_descriptions : TypeDescription 对象列表
    signature : 通用的ufunc签名（比如用于matmul）
    indexed : 为这些类型字符添加索引循环（ufunc.at）

    """
    def __init__(self, nin, nout, identity, docstring, typereso,
                 *type_descriptions, signature=None, indexed=''):
        self.nin = nin
        self.nout = nout
        if identity is None:
            identity = None_
        self.identity = identity
        self.docstring = docstring
        self.typereso = typereso
        self.type_descriptions = []
        self.signature = signature
        self.indexed = indexed
        for td in type_descriptions:
            self.type_descriptions.extend(td)
        for td in self.type_descriptions:
            td.finish_signature(self.nin, self.nout)

        check_td_order(self.type_descriptions)


# 避免依赖于区域设置的字符串处理实用工具。

import string
UPPER_TABLE = bytes.maketrans(bytes(string.ascii_lowercase, "ascii"),
                              bytes(string.ascii_uppercase, "ascii"))

def english_upper(s):
    """应用英文大小写规则将ASCII字符串转换为全大写。

    这是一个内部实用函数，用于替换对str.upper()的调用，以避免随区域设置更改而改变行为。
    特别是，土耳其语具有拉丁字母"I"的带点和不带点的变体，因此在"tr"区域设置中，
    "i".upper() != "I"。

    Parameters
    ----------
    s : str
        输入的字符串

    Returns
    -------
    uppered : str
        转换为大写后的字符串

    Examples
    --------
    >>> from numpy.lib.utils import english_upper
    >>> s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_'
    >>> english_upper(s)
    'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'
    >>> english_upper('')
    ''
    """
    uppered = s.translate(UPPER_TABLE)
    return uppered


# defdict 中的每个条目都是一个 Ufunc 对象。

# name: [字符集合，用于定义它的字符串，
#        使用函数接口的字符集合，
#        给定数据函数的字符串元组，
#        (输入，输出)或者(输入字符串，输出字符串)指定的字符代码签名，
#        单位元素，
#        文档字符串，
#        输出规范（可选）
#        ]

chartoname = {
    '?': 'bool',
    'b': 'byte',
    'B': 'ubyte',
    'h': 'short',
    'H': 'ushort',
    'i': 'int',
    'I': 'uint',
    'l': 'long',
    'L': 'ulong',
    # 我们有时需要int64，但是没有明显的字符表示它，下面使用k并将其定义为`int64`。
    'k': 'int64',
    'K': 'uint64',
    'q': 'longlong',
    'Q': 'ulonglong',
    'e': 'half',
}
    'f': 'float',
    # 'f' 表示对应的数据类型是浮点数（单精度）
    'd': 'double',
    # 'd' 表示对应的数据类型是双精度浮点数
    'g': 'longdouble',
    # 'g' 表示对应的数据类型是长双精度浮点数
    'F': 'cfloat',
    # 'F' 表示对应的数据类型是复数浮点数（单精度）
    'D': 'cdouble',
    # 'D' 表示对应的数据类型是复数双精度浮点数
    'G': 'clongdouble',
    # 'G' 表示对应的数据类型是复数长双精度浮点数
    'M': 'datetime',
    # 'M' 表示对应的数据类型是日期时间对象
    'm': 'timedelta',
    # 'm' 表示对应的数据类型是时间间隔对象
    'O': 'OBJECT',
    # 'O' 表示对应的数据类型是Python对象
    # '.' is like 'O', but calls a method of the object instead
    # of a function
    'P': 'OBJECT',
    # 'P' 表示对应的数据类型是Python对象，但是调用对象的方法而不是函数
}
# 定义字符串变量，包含不支持的对象和布尔类型字符
no_obj_bool = 'bBhHiIlLqQefdgFDGmM'
# 将不支持的对象字符加上 '?' 构成字符串
noobj = '?' + no_obj_bool
# 包含所有可能类型的字符串
all = '?bBhHiIlLqQefdgFDGOmM'

# 单字符变量赋值
O = 'O'
P = 'P'

# 各种整数类型的字符
ints = 'bBhHiIlLqQ'
# 短整数类型的字符
sints = 'bhilq'
# 无符号整数类型的字符
uints = 'BHILQ'
# 时间类型的字符
times = 'Mm'
# 仅时间差类型的字符
timedeltaonly = 'm'
# 含有 'O' 的整数类型字符
intsO = ints + O
# 含有 '?' 的整数类型字符
bints = '?' + ints
# 含有 '?O' 的整数类型字符
bintsO = bints + O
# 浮点数类型字符
flts = 'efdg'
# 含有 'O' 的浮点数类型字符
fltsO = flts + O
# 含有 'P' 的浮点数类型字符
fltsP = flts + P
# 复数类型字符
cmplx = 'FDG'
# 复数向量类型字符
cmplxvec = 'FD'
# 含有 'O' 的复数类型字符
cmplxO = cmplx + O
# 含有 'P' 的复数类型字符
cmplxP = cmplx + P
# 不精确数值类型字符
inexact = flts + cmplx
# 不精确向量类型字符
inexactvec = 'fd'
# 不含整数类型字符的字符集
noint = inexact + O
# 不含整数类型字符但含 'P' 的字符集
nointP = inexact + P
# 含有 'P' 的所有可能类型字符集
allP = bints + times + flts + cmplxP
# 不含布尔类型但含对象的字符集
nobool_or_obj = noobj[1:]
# 不含布尔类型和日期时间类型的字符集
nobool_or_datetime = noobj[1:-1] + O  # 包括 m - timedelta64
# 整数和浮点数类型的字符集
intflt = ints + flts
# 整数、浮点数和复数类型的字符集
intfltcmplx = ints + flts + cmplx
# 不含复数类型的字符集
nocmplx = bints + times + flts
# 不含复数类型但含有 'O' 的字符集
nocmplxO = nocmplx + O
# 不含复数类型但含有 'P' 的字符集
nocmplxP = nocmplx + P
# 不含时间类型或对象的字符集
notimes_or_obj = bints + inexact
# 不含日期时间类型或对象的字符集
nodatetime_or_obj = bints + inexact
# 不含布尔类型和时间类型或对象的字符集
no_bool_times_obj = ints + inexact

# 找到对应于 int64 的代码
int64 = 'k'
# 找到对应于 uint64 的代码
uint64 = 'K'

# 此字典描述了所有 ufunc 的实现，生成所有函数名称及其对应的 ufunc 签名。
# TD 是一个对象，将字符代码列表扩展为 TypeDescriptions 数组。
defdict = {
    'add':
        Ufunc(2, 1, Zero,
              docstrings.get('numpy._core.umath.add'),
              'PyUFunc_AdditionTypeResolver',
              TD('?', cfunc_alias='logical_or', dispatch=[('loops_logical', '?')]),
              TD(no_bool_times_obj, dispatch=[
                  ('loops_arithm_fp', 'fdFD'),
                  ('loops_autovec', ints),
              ]),
              [TypeDescription('M', FullTypeDescr, 'Mm', 'M'),
               TypeDescription('m', FullTypeDescr, 'mm', 'm'),
               TypeDescription('M', FullTypeDescr, 'mM', 'M'),
              ],
              TD(O, f='PyNumber_Add'),
              indexed=intfltcmplx
              ),
    'subtract':
        Ufunc(2, 1, None,  # Zero is only a unit to the right, not the left
              docstrings.get('numpy._core.umath.subtract'),
              'PyUFunc_SubtractionTypeResolver',
              TD(no_bool_times_obj, dispatch=[
                  ('loops_arithm_fp', 'fdFD'),
                  ('loops_autovec', ints),
              ]),
              [TypeDescription('M', FullTypeDescr, 'Mm', 'M'),
               TypeDescription('m', FullTypeDescr, 'mm', 'm'),
               TypeDescription('M', FullTypeDescr, 'MM', 'm'),
              ],
              TD(O, f='PyNumber_Subtract'),
              indexed=intfltcmplx
              ),
    'multiply':
    # 创建一个通用函数对象，用于执行乘法运算
    Ufunc(2, 1, One,  # 定义函数的基本参数和特性
          docstrings.get('numpy._core.umath.multiply'),  # 获取乘法运算的文档字符串
          'PyUFunc_MultiplicationTypeResolver',  # 指定乘法类型解析器
          TD('?', cfunc_alias='logical_and',  # 定义类型描述符，设置C函数别名为logical_and
             dispatch=[('loops_logical', '?')]),  # 指定分发规则，逻辑运算为布尔值
          TD(no_bool_times_obj, dispatch=[  # 定义无布尔值乘法对象的类型描述符和分发规则
              ('loops_arithm_fp', 'fdFD'),  # 浮点数运算循环
              ('loops_autovec', ints),      # 自动向量化循环
          ]),
          [TypeDescription('m', FullTypeDescr, 'mq', 'm'),  # 描述操作数类型的类型描述符列表
           TypeDescription('m', FullTypeDescr, 'qm', 'm'),
           TypeDescription('m', FullTypeDescr, 'md', 'm'),
           TypeDescription('m', FullTypeDescr, 'dm', 'm'),
          ],
          TD(O, f='PyNumber_Multiply'),  # 定义对象类型描述符，使用PyNumber_Multiply函数
          indexed=intfltcmplx  # 指定索引方式为整数、浮点数和复数
          ),
#'true_divide' : aliased to divide in umathmodule.c:initumath
# 创建名为'true_divide'的'Ufunc'对象
'floor_divide':
    # 创建名为'floor_divide'的'Ufunc'对象，参数为(2, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(2, 1, None, # One is only a unit to the right, not the left
          # 获取'floor_divide'的文档字符串
          docstrings.get('numpy._core.umath.floor_divide'),
          # 获取类别为'PyUFunc_DivisionTypeResolver'的类型解析器
          'PyUFunc_DivisionTypeResolver',
          # 创建类型描述对象，针对整数
          TD(ints, cfunc_alias='divide', dispatch=[('loops_arithmetic', 'bBhHiIlLqQ')]),
          # 创建类型描述对象，针对浮点数
          TD(flts),
          # 创建类型描述对象列表，包括('m', FullTypeDescr, 'mq', 'm'),('m', FullTypeDescr, 'md', 'm'),('m', FullTypeDescr, 'mm', 'q')
          [TypeDescription('m', FullTypeDescr, 'mq', 'm'),
           TypeDescription('m', FullTypeDescr, 'md', 'm'),
           TypeDescription('m', FullTypeDescr, 'mm', 'q'),
          ],
          # 创建类型描述对象，针对任意类型，调用'PyNumber_FloorDivide'函数
          TD(O, f='PyNumber_FloorDivide'),
          # indexed为浮点数和整数
          indexed=flts + ints
          ),
# 创建名为'divide'的'Ufunc'对象
'divide':
    # 创建名为'divide'的'Ufunc'对象，参数为(2, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(2, 1, None, # One is only a unit to the right, not the left
          # 获取'divide'的文档字符串
          docstrings.get('numpy._core.umath.divide'),
          # 获取类别为'PyUFunc_TrueDivisionTypeResolver'的类型解析器
          'PyUFunc_TrueDivisionTypeResolver',
          # 创建类型描述对象，针对浮点数和复数，调用'divide'的别名函数
          TD(flts+cmplx, cfunc_alias='divide', dispatch=[('loops_arithm_fp', 'fd')]),
          # 创建类型描述对象列表，包括('m', FullTypeDescr, 'mq', 'm', cfunc_alias='divide'),('m', FullTypeDescr, 'md', 'm', cfunc_alias='divide'),('m', FullTypeDescr, 'mm', 'd', cfunc_alias='divide')
          [TypeDescription('m', FullTypeDescr, 'mq', 'm', cfunc_alias='divide'),
           TypeDescription('m', FullTypeDescr, 'md', 'm', cfunc_alias='divide'),
           TypeDescription('m', FullTypeDescr, 'mm', 'd', cfunc_alias='divide'),
          ],
          # 创建类型描述对象，针对任意类型，调用'PyNumber_TrueDivide'函数
          TD(O, f='PyNumber_TrueDivide'),
          # indexed为浮点数
          indexed=flts
          ),
# 创建名为'conjugate'的'Ufunc'对象
'conjugate':
    # 创建名为'conjugate'的'Ufunc'对象，参数为(1, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(1, 1, None,
          # 获取'conjugate'的文档字符串
          docstrings.get('numpy._core.umath.conjugate'),
          # 类别为None
          None,
          # 创建类型描述对象，针对整数、浮点数和复数，根据具体情况调用不同的循环函数
          TD(ints+flts+cmplx, dispatch=[
              ('loops_arithm_fp', 'FD'),
              ('loops_autovec', ints),
          ]),
          # 创建类型描述对象，针对任意类型，调用'conjugate'函数
          TD(P, f='conjugate'),
          ),
# 创建名为'fmod'的'Ufunc'对象
'fmod':
    # 创建名为'fmod'的'Ufunc'对象，参数为(2, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(2, 1, None,
          # 获取'fmod'的文档字符串
          docstrings.get('numpy._core.umath.fmod'),
          # 类别为None
          None,
          # 创建类型描述对象，针对整数，调用'loops_modulo'函数
          TD(ints, dispatch=[('loops_modulo', ints)]),
          # 创建类型描述对象，针对浮点数，调用'fmod'函数，将结果转换为浮点数类型
          TD(flts, f='fmod', astype={'e': 'f'}),
          # 创建类型描述对象，针对任意类型，调用'fmod'函数
          TD(P, f='fmod'),
          ),
# 创建名为'square'的'Ufunc'对象
'square':
    # 创建名为'square'的'Ufunc'对象，参数为(1, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(1, 1, None,
          # 获取'square'的文档字符串
          docstrings.get('numpy._core.umath.square'),
          # 类别为None
          None,
          # 创建类型描述对象，针对整数和浮点数，根据具体情况调用不同的循环函数
          TD(ints+inexact, dispatch=[
              ('loops_unary_fp', 'fd'),
              ('loops_arithm_fp', 'FD'),
              ('loops_autovec', ints),
          ]),
          # 创建类型描述对象，针对任意类型，调用'Py_square'函数
          TD(O, f='Py_square'),
          ),
# 创建名为'reciprocal'的'Ufunc'对象
'reciprocal':
    # 创建名为'reciprocal'的'Ufunc'对象，参数为(1, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(1, 1, None,
          # 获取'reciprocal'的文档字符串
          docstrings.get('numpy._core.umath.reciprocal'),
          # 类别为None
          None,
          # 创建类型描述对象，针对整数和浮点数，根据具体情况调用不同的循环函数
          TD(ints+inexact, dispatch=[
              ('loops_unary_fp', 'fd'),
              ('loops_autovec', ints),
          ]),
          # 创建类型描述对象，针对任意类型，调用'Py_reciprocal'函数
          TD(O, f='Py_reciprocal'),
          ),
# 创建名为'_ones_like'的'Ufunc'对象
# 虽然不再被numpy.ones_like使用，但仍被一些内部调用所使用
'_ones_like':
    # 创建名为'_ones_like'的'Ufunc'对象，参数为(1, 1, None)
    # 第一个参数为输入数量，第二个参数为输出数量，第三个参数为None
    Ufunc(1, 1, None,
          # 获取'_ones_like'的文档字符串
          docstrings.get('numpy._core.umath._ones_like'),
          # 获取类别为'PyUFunc_OnesLikeTypeResolver'的类型解析器
          'PyUFunc_OnesLikeTypeResolver',
          # 类别为None对象
          TD(noobj),
          # 创建类型描述对象，针对任意类型，调用'Py_get_one'函数
          TD(O, f='Py_get_one'),
          ),
# 创建名为'power'的'Ufunc'对象
    # 使用 Ufunc 类创建一个函数对象，参数依次为：输入参数数量为2，输出参数数量为1，无特定用途
    # 使用 docstrings.get 方法获取 'numpy._core.umath.power' 对应的文档字符串
    # TD(ints): 使用整数类型的类型描述符
    # TD('e', f='pow', astype={'e': 'f'}): 使用浮点数类型描述符 'e'，将其视为 'f' 类型的幂函数
    # TD('fd', dispatch=[('loops_umath_fp', 'fd')]): 使用双浮点数类型描述符 'fd'，使用 'loops_umath_fp' 分派器进行浮点数计算
    # TD(inexact, f='pow', astype={'e': 'f'}): 使用不精确类型的类型描述符，将其视为 'f' 类型的幂函数
    # TD(O, f='npy_ObjectPower'): 使用对象类型描述符，调用 'npy_ObjectPower' 函数
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.power'),
          None,
          TD(ints),
          TD('e', f='pow', astype={'e': 'f'}),
          TD('fd', dispatch=[('loops_umath_fp', 'fd')]),
          TD(inexact, f='pow', astype={'e': 'f'}),
          TD(O, f='npy_ObjectPower'),
          ),
'float_power':
    # 创建一个名为'float_power'的Ufunc对象，表示浮点数的乘方运算
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.float_power'),  # 使用numpy内部的文档字符串
          None,  # 没有类型解析器
          TD('dgDG', f='pow'),  # 类型描述，表示支持双精度和单精度浮点数的乘方运算
          ),

'absolute':
    # 创建一个名为'absolute'的Ufunc对象，表示取绝对值运算
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.absolute'),  # 使用numpy内部的文档字符串
          'PyUFunc_AbsoluteTypeResolver',  # 使用PyUFunc_AbsoluteTypeResolver类型解析器
          TD(bints+flts+timedeltaonly, dispatch=[
              ('loops_unary_fp', 'fd'),  # 分派到浮点数类型的一元操作循环
              ('loops_logical', '?'),   # 分派到逻辑运算的循环
              ('loops_autovec', ints + 'e'),  # 自动向量化循环
          ]),
          TD(cmplx, dispatch=[('loops_unary_complex', 'FD')],  # 对于复数类型的一元复杂操作循环
             out=('f', 'd', 'g')),  # 输出为单精度、双精度和长双精度浮点数
          TD(O, f='PyNumber_Absolute'),  # 对象的PyNumber_Absolute操作
          ),

'_arg':
    # 创建一个名为'_arg'的Ufunc对象，表示取幅角运算
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath._arg'),  # 使用numpy内部的文档字符串
          None,  # 没有类型解析器
          TD(cmplx, out=('f', 'd', 'g')),  # 对复数类型输出为单精度、双精度和长双精度浮点数
          ),

'negative':
    # 创建一个名为'negative'的Ufunc对象，表示取负运算
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.negative'),  # 使用numpy内部的文档字符串
          'PyUFunc_NegativeTypeResolver',  # 使用PyUFunc_NegativeTypeResolver类型解析器
          TD(ints+flts+timedeltaonly, dispatch=[('loops_unary', ints+'fdg')]),  # 对整数和浮点数的一元操作循环
          TD(cmplx, f='neg'),  # 对复数的负运算
          TD(O, f='PyNumber_Negative'),  # 对象的PyNumber_Negative操作
          ),

'positive':
    # 创建一个名为'positive'的Ufunc对象，表示取正运算
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.positive'),  # 使用numpy内部的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 使用PyUFunc_SimpleUniformOperationTypeResolver类型解析器
          TD(ints+flts+timedeltaonly),  # 对整数、浮点数和时间间隔的操作
          TD(cmplx, f='pos'),  # 对复数的正运算
          TD(O, f='PyNumber_Positive'),  # 对象的PyNumber_Positive操作
          ),

'sign':
    # 创建一个名为'sign'的Ufunc对象，表示符号函数运算
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sign'),  # 使用numpy内部的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 使用PyUFunc_SimpleUniformOperationTypeResolver类型解析器
          TD(nobool_or_datetime, dispatch=[('loops_autovec', ints)]),  # 对于非布尔和日期时间类型的自动向量化循环
          ),

'greater':
    # 创建一个名为'greater'的Ufunc对象，表示大于比较运算
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.greater'),  # 使用numpy内部的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用PyUFunc_SimpleBinaryComparisonTypeResolver类型解析器
          TD(bints, out='?'),  # 对布尔整数类型输出为布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 类型描述，处理64位整数的比较运算
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],  # 类型描述，处理64位无符号整数的比较运算
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 对于非精确和时间类型的比较运算
          TD('O', out='?'),  # 对象类型的比较运算
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 类型描述，处理对象的比较运算
          ),

'greater_equal':
    # 创建一个名为'greater_equal'的Ufunc对象，表示大于等于比较运算
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.greater_equal'),  # 使用numpy内部的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用PyUFunc_SimpleBinaryComparisonTypeResolver类型解析器
          TD(bints, out='?'),  # 对布尔整数类型输出为布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 类型描述，处理64位整数的比较运算
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],  # 类型描述，处理64位无符号整数的比较运算
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 对于非精确和时间类型的比较运算
          TD('O', out='?'),  # 对象类型的比较运算
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 类型描述，处理对象的比较运算
          ),

'less':
    # 创建一个名为'less'的Ufunc对象，表示小于比较运算
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.less'),  # 使用numpy内部的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用PyUFunc_SimpleBinaryComparisonTypeResolver类型解析器
          TD(bints, out='?'),  # 对布尔整数类型输出为布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 类型描述，处理64位整数的比较运算
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],  # 类型描述，处理64位无符号整数的比较运算
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 对于非精确和时间类型的比较运算
          TD('O', out='?'),  # 对象类型的比较运算
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 类型描述，处理对象的比较运算
          ),
'less_equal':
    # 创建一个二元通用函数对象，用于执行小于等于比较操作
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.less_equal'),  # 获取小于等于操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD(bints, out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 输入参数类型描述
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 分派方式描述
          TD('O', out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 输入参数类型描述
          ),
'equal':
    # 创建一个二元通用函数对象，用于执行相等比较操作
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.equal'),  # 获取相等操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD(bints, out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 输入参数类型描述
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 分派方式描述
          TD('O', out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 输入参数类型描述
          ),
'not_equal':
    # 创建一个二元通用函数对象，用于执行不等比较操作
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.not_equal'),  # 获取不等操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD(bints, out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('q', FullTypeDescr, 'qQ', '?'),  # 输入参数类型描述
           TypeDescription('q', FullTypeDescr, 'Qq', '?')],
          TD(inexact+times, out='?', dispatch=[('loops_comparison', bints+'fd')]),  # 分派方式描述
          TD('O', out='?'),  # 输出类型描述，返回布尔值
          [TypeDescription('O', FullTypeDescr, 'OO', 'O')],  # 输入参数类型描述
          ),
'logical_and':
    # 创建一个二元通用函数对象，用于执行逻辑与操作
    Ufunc(2, 1, True_,
          docstrings.get('numpy._core.umath.logical_and'),  # 获取逻辑与操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD(nodatetime_or_obj, out='?', dispatch=[
              ('loops_logical', '?'),  # 逻辑运算循环类型描述
              ('loops_autovec', ints),  # 自动向量化循环类型描述
          ]),
          TD(O, f='npy_ObjectLogicalAnd'),  # 输出类型描述，使用对象逻辑与功能
          ),
'logical_not':
    # 创建一个一元通用函数对象，用于执行逻辑非操作
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.logical_not'),  # 获取逻辑非操作的文档字符串
          None,  # 无类型解析器
          TD(nodatetime_or_obj, out='?', dispatch=[
              ('loops_logical', '?'),  # 逻辑运算循环类型描述
              ('loops_autovec', ints),  # 自动向量化循环类型描述
          ]),
          TD(O, f='npy_ObjectLogicalNot'),  # 输出类型描述，使用对象逻辑非功能
          ),
'logical_or':
    # 创建一个二元通用函数对象，用于执行逻辑或操作
    Ufunc(2, 1, False_,
          docstrings.get('numpy._core.umath.logical_or'),  # 获取逻辑或操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD(nodatetime_or_obj, out='?', dispatch=[
              ('loops_logical', '?'),  # 逻辑运算循环类型描述
              ('loops_autovec', ints),  # 自动向量化循环类型描述
          ]),
          TD(O, f='npy_ObjectLogicalOr'),  # 输出类型描述，使用对象逻辑或功能
          ),
'logical_xor':
    # 创建一个二元通用函数对象，用于执行逻辑异或操作
    Ufunc(2, 1, False_,
          docstrings.get('numpy._core.umath.logical_xor'),  # 获取逻辑异或操作的文档字符串
          'PyUFunc_SimpleBinaryComparisonTypeResolver',  # 使用简单的二元比较类型解析器
          TD('?', out='?', cfunc_alias='not_equal',  # 输出类型描述，返回布尔值，并使用不等函数别名
                           dispatch=[('loops_comparison', '?')]),  # 分派方式描述
          TD(no_bool_times_obj, out='?', dispatch=[
              ('loops_autovec', ints),  # 自动向量化循环类型描述
          ]),
          # TODO: 使用 obj.logical_xor() 似乎几乎没用：
          TD(P, f='logical_xor'),  # 输出类型描述，使用逻辑异或功能
          ),
'maximum':
    # 创建一个二元通用函数对象，用于返回两个数组中对应元素的最大值
    # 调用Ufunc类的构造函数，传入以下参数：
    # 1. 2：操作数数量为2
    # 2. 1：输出一个结果
    # 3. ReorderableNone：不支持重新排序的操作类型
    # 4. docstrings.get('numpy._core.umath.maximum')：获取 'numpy._core.umath.maximum' 的文档字符串
    # 5. 'PyUFunc_SimpleUniformOperationTypeResolver'：指定操作类型解析器为简单统一类型解析器
    # 6. TD('?', cfunc_alias='logical_or', dispatch=[('loops_logical', '?')])：
    #    类型描述对象，操作数类型为布尔型，对应的C函数别名为 'logical_or'，分派到逻辑运算循环
    # 7. TD(no_obj_bool, dispatch=[('loops_minmax', ints+'fdg')])：
    #    类型描述对象，不带对象的布尔型，分派到最小最大值循环，支持整数和浮点数
    # 8. TD(O, f='npy_ObjectMax')：
    #    类型描述对象，对象类型，对应的C函数为 'npy_ObjectMax'
    # indexed=flts + ints：支持浮点数和整数索引
'minimum':
    # 创建一个名为 'minimum' 的 Ufunc 对象，这是一个通用函数对象，用于执行最小值操作
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.minimum'),  # 获取最小值函数的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 类型解析器的标识符
          TD('?', cfunc_alias='logical_and',  # 类型描述符，用于布尔运算的逻辑与
                  dispatch=[('loops_logical', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(no_obj_bool, dispatch=[('loops_minmax', ints+'fdg')]),  # 类型描述符，处理非对象布尔运算和整数/浮点数
          TD(O, f='npy_ObjectMin'),  # 类型描述符，处理对象的最小值操作
          indexed=flts + ints,  # 指定支持的数据类型
          ),

'clip':
    # 创建一个名为 'clip' 的 Ufunc 对象，用于对数组进行截断操作
    Ufunc(3, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.clip'),  # 获取截断函数的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 类型解析器的标识符
          TD(noobj),  # 类型描述符，指定输入参数和输出的类型
          [TypeDescription('O', 'npy_ObjectClip', 'OOO', 'O')]  # 类型描述符列表，处理对象的截断操作
          ),

'fmax':
    # 创建一个名为 'fmax' 的 Ufunc 对象，用于执行浮点数的最大值操作
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.fmax'),  # 获取最大值函数的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 类型解析器的标识符
          TD('?', cfunc_alias='logical_or',  # 类型描述符，用于布尔运算的逻辑或
                  dispatch=[('loops_logical', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(no_obj_bool, dispatch=[('loops_minmax', 'fdg')]),  # 类型描述符，处理非对象布尔运算和浮点数/整数
          TD(O, f='npy_ObjectMax'),  # 类型描述符，处理对象的最大值操作
          indexed=flts + ints,  # 指定支持的数据类型
          ),

'fmin':
    # 创建一个名为 'fmin' 的 Ufunc 对象，用于执行浮点数的最小值操作
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.fmin'),  # 获取最小值函数的文档字符串
          'PyUFunc_SimpleUniformOperationTypeResolver',  # 类型解析器的标识符
          TD('?', cfunc_alias='logical_and',  # 类型描述符，用于布尔运算的逻辑与
                  dispatch=[('loops_logical', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(no_obj_bool, dispatch=[('loops_minmax', 'fdg')]),  # 类型描述符，处理非对象布尔运算和浮点数/整数
          TD(O, f='npy_ObjectMin'),  # 类型描述符，处理对象的最小值操作
          indexed=flts + ints,  # 指定支持的数据类型
          ),

'logaddexp':
    # 创建一个名为 'logaddexp' 的 Ufunc 对象，用于执行对数加法操作
    Ufunc(2, 1, MinusInfinity,  # 设置 Ufunc 对象的特殊标志，如无穷小值
          docstrings.get('numpy._core.umath.logaddexp'),  # 获取对数加法函数的文档字符串
          None,  # 没有指定类型解析器
          TD(flts, f="logaddexp", astype={'e': 'f'})  # 类型描述符，指定输入输出的数据类型和特殊处理
          ),

'logaddexp2':
    # 创建一个名为 'logaddexp2' 的 Ufunc 对象，用于执行以2为底的对数加法操作
    Ufunc(2, 1, MinusInfinity,  # 设置 Ufunc 对象的特殊标志，如无穷小值
          docstrings.get('numpy._core.umath.logaddexp2'),  # 获取对数加法函数的文档字符串
          None,  # 没有指定类型解析器
          TD(flts, f="logaddexp2", astype={'e': 'f'})  # 类型描述符，指定输入输出的数据类型和特殊处理
          ),

'bitwise_and':
    # 创建一个名为 'bitwise_and' 的 Ufunc 对象，用于执行位与操作
    Ufunc(2, 1, AllOnes,  # 设置 Ufunc 对象的特殊标志，如全1值
          docstrings.get('numpy._core.umath.bitwise_and'),  # 获取位与函数的文档字符串
          None,  # 没有指定类型解析器
          TD('?', cfunc_alias='logical_and',  # 类型描述符，用于布尔运算的逻辑与
                  dispatch=[('loops_logical', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(ints, dispatch=[('loops_autovec', ints)]),  # 类型描述符，处理整数类型的自动向量化
          TD(O, f='PyNumber_And'),  # 类型描述符，处理对象的位与操作
          ),

'bitwise_or':
    # 创建一个名为 'bitwise_or' 的 Ufunc 对象，用于执行位或操作
    Ufunc(2, 1, Zero,  # 设置 Ufunc 对象的特殊标志，如零值
          docstrings.get('numpy._core.umath.bitwise_or'),  # 获取位或函数的文档字符串
          None,  # 没有指定类型解析器
          TD('?', cfunc_alias='logical_or',  # 类型描述符，用于布尔运算的逻辑或
                  dispatch=[('loops_logical', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(ints, dispatch=[('loops_autovec', ints)]),  # 类型描述符，处理整数类型的自动向量化
          TD(O, f='PyNumber_Or'),  # 类型描述符，处理对象的位或操作
          ),

'bitwise_xor':
    # 创建一个名为 'bitwise_xor' 的 Ufunc 对象，用于执行位异或操作
    Ufunc(2, 1, Zero,  # 设置 Ufunc 对象的特殊标志，如零值
          docstrings.get('numpy._core.umath.bitwise_xor'),  # 获取位异或函数的文档字符串
          None,  # 没有指定类型解析器
          TD('?', cfunc_alias='not_equal',  # 类型描述符，用于布尔运算的不等操作
                  dispatch=[('loops_comparison', '?')]),  # 分派信息，指定如何处理布尔类型的运算
          TD(ints, dispatch=[('loops_autovec', ints)]),  # 类型描述符，处理整数类型的自动向量化
          TD(O, f='PyNumber_Xor'),  # 类型描述符，处理对象的位异或操作
          ),

'invert':
    # 创建一个名为 'invert' 的 Ufunc 对象，用于执行位反转操作
    Ufunc(1, 1, None,  # 设置 Ufunc 对象的特殊标志，这里没有特殊标志
          docstrings.get('numpy._core.umath.invert'),  # 获取位反转函数的文档字符串
          None,  # 没有指定类型解析器
          TD(ints, f='PyNumber_Invert')  # 类型描述符，处理整数类型的位反转操作
          ),
    # 调用 Ufunc 类的构造函数，传入以下参数：
    Ufunc(1, 1, None,
          # 使用 docstrings 字典获取 'numpy._core.umath.invert' 键对应的文档字符串作为参数
          docstrings.get('numpy._core.umath.invert'),
          # 第五个参数为 None
          None,
          # 使用 TD 类创建对象，参数为一个 '?' 字符串，设置 cfunc_alias 为 'logical_not'，dispatch 属性为 [('loops_logical', '?')]
          TD('?', cfunc_alias='logical_not', dispatch=[('loops_logical', '?')]),
          # 使用 TD 类创建对象，参数为 ints 变量，设置 dispatch 属性为 [('loops_autovec', ints)]
          TD(ints, dispatch=[('loops_autovec', ints)]),
          # 使用 TD 类创建对象，参数为 O 变量，设置 f 属性为 'PyNumber_Invert'
          TD(O, f='PyNumber_Invert'),
          ),
'left_shift':
    # 定义名为 'left_shift' 的 Ufunc 对象，执行位左移操作
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.left_shift'),
          None,
          TD(ints, dispatch=[('loops_autovec', ints)]),
          TD(O, f='PyNumber_Lshift'),
          ),

'right_shift':
    # 定义名为 'right_shift' 的 Ufunc 对象，执行位右移操作
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.right_shift'),
          None,
          TD(ints, dispatch=[('loops_autovec', ints)]),
          TD(O, f='PyNumber_Rshift'),
          ),

'heaviside':
    # 定义名为 'heaviside' 的 Ufunc 对象，计算海维赛德阶跃函数
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.heaviside'),
          None,
          TD(flts, f='heaviside', astype={'e': 'f'}),
          ),

'degrees':
    # 定义名为 'degrees' 的 Ufunc 对象，将角度从弧度转换为度
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.degrees'),
          None,
          TD(fltsP, f='degrees', astype={'e': 'f'}),
          ),

'rad2deg':
    # 定义名为 'rad2deg' 的 Ufunc 对象，将弧度转换为度
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.rad2deg'),
          None,
          TD(fltsP, f='rad2deg', astype={'e': 'f'}),
          ),

'radians':
    # 定义名为 'radians' 的 Ufunc 对象，将角度从度转换为弧度
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.radians'),
          None,
          TD(fltsP, f='radians', astype={'e': 'f'}),
          ),

'deg2rad':
    # 定义名为 'deg2rad' 的 Ufunc 对象，将度转换为弧度
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.deg2rad'),
          None,
          TD(fltsP, f='deg2rad', astype={'e': 'f'}),
          ),

'arccos':
    # 定义名为 'arccos' 的 Ufunc 对象，计算反余弦值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arccos'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='acos', astype={'e': 'f'}),
          TD(P, f='arccos'),
          ),

'arccosh':
    # 定义名为 'arccosh' 的 Ufunc 对象，计算反双曲余弦值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arccosh'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='acosh', astype={'e': 'f'}),
          TD(P, f='arccosh'),
          ),

'arcsin':
    # 定义名为 'arcsin' 的 Ufunc 对象，计算反正弦值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arcsin'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='asin', astype={'e': 'f'}),
          TD(P, f='arcsin'),
          ),

'arcsinh':
    # 定义名为 'arcsinh' 的 Ufunc 对象，计算反双曲正弦值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arcsinh'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='asinh', astype={'e': 'f'}),
          TD(P, f='arcsinh'),
          ),

'arctan':
    # 定义名为 'arctan' 的 Ufunc 对象，计算反正切值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arctan'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='atan', astype={'e': 'f'}),
          TD(P, f='arctan'),
          ),

'arctanh':
    # 定义名为 'arctanh' 的 Ufunc 对象，计算反双曲正切值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arctanh'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='atanh', astype={'e': 'f'}),
          TD(P, f='arctanh'),
          ),

'cos':
    # 定义名为 'cos' 的 Ufunc 对象，计算余弦值
    # 调用 Ufunc 类的构造函数，传入以下参数：
    # - 1: 输入参数个数
    # - 1: 输出参数个数
    # - None: 占位符参数
    # - docstrings.get('numpy._core.umath.cos'): 获取 'numpy._core.umath.cos' 对应的文档字符串
    # - None: 占位符参数
    # - TD('e', dispatch=[('loops_umath_fp', 'e')]): 创建类型描述符 'e'，设置分派信息为 [('loops_umath_fp', 'e')]
    # - TD('f', dispatch=[('loops_trigonometric', 'f')]): 创建类型描述符 'f'，设置分派信息为 [('loops_trigonometric', 'f')]
    # - TD('d', dispatch=[('loops_trigonometric', 'd')]): 创建类型描述符 'd'，设置分派信息为 [('loops_trigonometric', 'd')]
    # - TD('g' + cmplx, f='cos'): 创建类型描述符 'g' + cmplx，并指定 f 参数为 'cos'
    # - TD(P, f='cos'): 创建类型描述符 P，并指定 f 参数为 'cos'
'sin':
    # 创建一个 Ufunc 实例，执行单参数 sin 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sin'),  # 获取 sin 函数的文档字符串
          None,
          TD('e', dispatch=[('loops_umath_fp', 'e')]),  # 对于浮点数类型 'e'，使用 'loops_umath_fp' 循环分派
          TD('f', dispatch=[('loops_trigonometric', 'f')]),  # 对于浮点数类型 'f'，使用 'loops_trigonometric' 循环分派
          TD('d', dispatch=[('loops_trigonometric', 'd')]),  # 对于浮点数类型 'd'，使用 'loops_trigonometric' 循环分派
          TD('g' + cmplx, f='sin'),  # 对于复数类型 'g' + cmplx，执行 sin 函数
          TD(P, f='sin'),  # 使用通用循环分派器执行 sin 函数
          ),
'tan':
    # 创建一个 Ufunc 实例，执行单参数 tan 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.tan'),  # 获取 tan 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='tan', astype={'e': 'f'}),  # 对于 inexact 类型，执行 tan 函数，并将 'e' 转换为 'f'
          TD(P, f='tan'),  # 使用通用循环分派器执行 tan 函数
          ),
'cosh':
    # 创建一个 Ufunc 实例，执行单参数 cosh 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.cosh'),  # 获取 cosh 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='cosh', astype={'e': 'f'}),  # 对于 inexact 类型，执行 cosh 函数，并将 'e' 转换为 'f'
          TD(P, f='cosh'),  # 使用通用循环分派器执行 cosh 函数
          ),
'sinh':
    # 创建一个 Ufunc 实例，执行单参数 sinh 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sinh'),  # 获取 sinh 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='sinh', astype={'e': 'f'}),  # 对于 inexact 类型，执行 sinh 函数，并将 'e' 转换为 'f'
          TD(P, f='sinh'),  # 使用通用循环分派器执行 sinh 函数
          ),
'tanh':
    # 创建一个 Ufunc 实例，执行单参数 tanh 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.tanh'),  # 获取 tanh 函数的文档字符串
          None,
          TD('e', dispatch=[('loops_umath_fp', 'e')]),  # 使用 'loops_umath_fp' 循环分派对应于 'e' 类型的数据
          TD('fd', dispatch=[('loops_hyperbolic', 'fd')]),  # 使用 'loops_hyperbolic' 循环分派对应于 'fd' 类型的数据
          TD(inexact, f='tanh', astype={'e': 'f'}),  # 对于 inexact 类型，执行 tanh 函数，并将 'e' 转换为 'f'
          TD(P, f='tanh'),  # 使用通用循环分派器执行 tanh 函数
          ),
'exp':
    # 创建一个 Ufunc 实例，执行单参数 exp 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.exp'),  # 获取 exp 函数的文档字符串
          None,
          TD('e', dispatch=[('loops_umath_fp', 'e')]),  # 使用 'loops_umath_fp' 循环分派对应于 'e' 类型的数据
          TD('fd', dispatch=[('loops_exponent_log', 'fd')]),  # 使用 'loops_exponent_log' 循环分派对应于 'fd' 类型的数据
          TD('fdg' + cmplx, f='exp'),  # 对于复数类型 'fdg' + cmplx，执行 exp 函数
          TD(P, f='exp'),  # 使用通用循环分派器执行 exp 函数
          ),
'exp2':
    # 创建一个 Ufunc 实例，执行单参数 exp2 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.exp2'),  # 获取 exp2 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='exp2', astype={'e': 'f'}),  # 对于 inexact 类型，执行 exp2 函数，并将 'e' 转换为 'f'
          TD(P, f='exp2'),  # 使用通用循环分派器执行 exp2 函数
          ),
'expm1':
    # 创建一个 Ufunc 实例，执行单参数 expm1 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.expm1'),  # 获取 expm1 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='expm1', astype={'e': 'f'}),  # 对于 inexact 类型，执行 expm1 函数，并将 'e' 转换为 'f'
          TD(P, f='expm1'),  # 使用通用循环分派器执行 expm1 函数
          ),
'log':
    # 创建一个 Ufunc 实例，执行单参数 log 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log'),  # 获取 log 函数的文档字符串
          None,
          TD('e', dispatch=[('loops_umath_fp', 'e')]),  # 使用 'loops_umath_fp' 循环分派对应于 'e' 类型的数据
          TD('fd', dispatch=[('loops_exponent_log', 'fd')]),  # 使用 'loops_exponent_log' 循环分派对应于 'fd' 类型的数据
          TD('fdg' + cmplx, f='log'),  # 对于复数类型 'fdg' + cmplx，执行 log 函数
          TD(P, f='log'),  # 使用通用循环分派器执行 log 函数
          ),
'log2':
    # 创建一个 Ufunc 实例，执行单参数 log2 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log2'),  # 获取 log2 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd' 类型的数据
          TD(inexact, f='log2', astype={'e': 'f'}),  # 对于 inexact 类型，执行 log2 函数，并将 'e' 转换为 'f'
          TD(P, f='log2'),  # 使用通用循环分派器执行 log2 函数
          ),
'log10':
    # 创建一个 Ufunc 实例，执行单参数 log10 函数
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log10'),  # 获取 log10 函数的文档字符串
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),  # 使用 'loops_umath_fp' 循环分派对应于 'efd
    # 调用 Ufunc 类的构造函数，参数依次为：1, 1, None
    # 第四个参数为获取 'numpy._core.umath.log1p' 的文档字符串
    # 第五个参数为 None
    # 第六个参数为 TD 类的实例化对象，使用 'efd' 参数，包括一个名为 'loops_umath_fp' 的调度项，其值为 'efd'
    # 第七个参数为 TD 类的实例化对象，使用 inexact 参数，设置 'f' 为 'log1p'，astype 字段设定为 {'e': 'f'}
    # 第八个参数为 TD 类的实例化对象，使用 P 参数，设置 'f' 为 'log1p'
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log1p'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(inexact, f='log1p', astype={'e': 'f'}),
          TD(P, f='log1p'),
          ),
'sqrt':
    # 创建一个名为'sqrt'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.sqrt，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sqrt'),
          None,
          TD('e', f='sqrt', astype={'e': 'f'}),
          TD(inexactvec, dispatch=[('loops_unary_fp', 'fd')]),
          TD('fdg' + cmplx, f='sqrt'),
          TD(P, f='sqrt'),
          ),

'cbrt':
    # 创建一个名为'cbrt'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.cbrt，分发方式为('loops_umath_fp', 'efd')
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.cbrt'),
          None,
          TD('efd', dispatch=[('loops_umath_fp', 'efd')]),
          TD(flts, f='cbrt', astype={'e': 'f'}),
          TD(P, f='cbrt'),
          ),

'ceil':
    # 创建一个名为'ceil'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.ceil，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.ceil'),
          None,
          TD('e', f='ceil', astype={'e': 'f'}),
          TD(inexactvec, dispatch=[('loops_unary_fp', 'fd')]),
          TD('fdg', f='ceil'),
          TD(O, f='npy_ObjectCeil'),
          ),

'trunc':
    # 创建一个名为'trunc'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.trunc，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.trunc'),
          None,
          TD('e', f='trunc', astype={'e': 'f'}),
          TD(inexactvec, dispatch=[('loops_unary_fp', 'fd')]),
          TD('fdg', f='trunc'),
          TD(O, f='npy_ObjectTrunc'),
          ),

'fabs':
    # 创建一个名为'fabs'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.fabs，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.fabs'),
          None,
          TD(flts, f='fabs', astype={'e': 'f'}),
          TD(P, f='fabs'),
       ),

'floor':
    # 创建一个名为'floor'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.floor，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.floor'),
          None,
          TD('e', f='floor', astype={'e': 'f'}),
          TD(inexactvec, dispatch=[('loops_unary_fp', 'fd')]),
          TD('fdg', f='floor'),
          TD(O, f='npy_ObjectFloor'),
          ),

'rint':
    # 创建一个名为'rint'的通用函数对象，接受1个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.rint，无特殊分发方式
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.rint'),
          None,
          TD('e', f='rint', astype={'e': 'f'}),
          TD(inexactvec, dispatch=[('loops_unary_fp', 'fd')]),
          TD('fdg' + cmplx, f='rint'),
          TD(P, f='rint'),
          ),

'arctan2':
    # 创建一个名为'arctan2'的通用函数对象，接受2个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.arctan2，无特殊分发方式
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.arctan2'),
          None,
          TD('e', f='atan2', astype={'e': 'f'}),
          TD('fd', dispatch=[('loops_umath_fp', 'fd')]),
          TD('g', f='atan2', astype={'e': 'f'}),
          TD(P, f='arctan2'),
          ),

'remainder':
    # 创建一个名为'remainder'的通用函数对象，接受2个参数，返回1个结果，无特定类型，文档字符串来源于numpy._core.umath.remainder，使用'PyUFunc_RemainderTypeResolver'进行类型解析
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.remainder'),
          'PyUFunc_RemainderTypeResolver',
          TD(ints, dispatch=[('loops_modulo', ints)]),
          TD(flts),
          [TypeDescription('m', FullTypeDescr, 'mm', 'm')],
          TD(O, f='PyNumber_Remainder'),
          ),

'divmod':
    # 创建一个名为'divmod'的通用函数对象，接受2个参数，返回2个结果，无特定类型，文档字符串来源于numpy._core.umath.divmod，使用'PyUFunc_DivmodTypeResolver'进行类型解析
    Ufunc(2, 2, None,
          docstrings.get('numpy._core.umath.divmod'),
          'PyUFunc_DivmodTypeResolver',
          TD(ints, dispatch=[('loops_modulo', ints)]),
          TD(flts),
          [TypeDescription('m', FullTypeDescr, 'mm', 'qm')],
          # TD(O, f='PyNumber_Divmod'),  # gh-9730
          ),

'hypot':
    # 创建一个名为'hypot'的通用函数对象，接受2个参数，返回1个结果，无特定类型，文档字符串待补充
    # 调用 Ufunc 类执行一个特定的数学函数（这里是 hypot 函数），使用以下参数：
    # 参数1: 2，指定函数的输入参数个数
    # 参数2: 1，指定函数的输出参数个数
    # 参数3: Zero，指定输出的初始值
    # 参数4: docstrings.get('numpy._core.umath.hypot')，获取 hypot 函数的文档字符串
    # 参数5: None，此处没有提供额外的选项
    # 参数6: TD(flts, f='hypot', astype={'e': 'f'})，类型描述对象，描述输入数据类型和函数名称
    # 参数7: TD(P, f='hypot')，类型描述对象，描述参数和函数名称
    Ufunc(2, 1, Zero,
          docstrings.get('numpy._core.umath.hypot'),
          None,
          TD(flts, f='hypot', astype={'e': 'f'}),
          TD(P, f='hypot'),
          ),
'isnan':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理 NaN 检测
    Ufunc(1, 1, None,
          # 获取关于 isnan 函数的文档字符串
          docstrings.get('numpy._core.umath.isnan'),
          'PyUFunc_IsFiniteTypeResolver',
          # 设置类型描述，指定无对象（noobj），输出为布尔类型（'?'），并根据分发模式选择不同的实现
          TD(noobj, out='?', dispatch=[
              ('loops_unary_fp_le', inexactvec),
              ('loops_autovec', bints),
          ]),
          ),
'isnat':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理 NaT（Not a Time）检测
    Ufunc(1, 1, None,
          # 获取关于 isnat 函数的文档字符串
          docstrings.get('numpy._core.umath.isnat'),
          'PyUFunc_IsNaTTypeResolver',
          # 设置类型描述，指定以 times 为基础，输出为布尔类型（'?'）
          TD(times, out='?'),
          ),
'isinf':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理无穷大检测
    Ufunc(1, 1, None,
          # 获取关于 isinf 函数的文档字符串
          docstrings.get('numpy._core.umath.isinf'),
          'PyUFunc_IsFiniteTypeResolver',
          # 设置类型描述，指定无对象（noobj），输出为布尔类型（'?'），并根据分发模式选择不同的实现
          TD(noobj, out='?', dispatch=[
              ('loops_unary_fp_le', inexactvec),
              ('loops_autovec', bints + 'mM'),
          ]),
          ),
'isfinite':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理有限数检测
    Ufunc(1, 1, None,
          # 获取关于 isfinite 函数的文档字符串
          docstrings.get('numpy._core.umath.isfinite'),
          'PyUFunc_IsFiniteTypeResolver',
          # 设置类型描述，指定无对象（noobj），输出为布尔类型（'?'），并根据分发模式选择不同的实现
          TD(noobj, out='?', dispatch=[
              ('loops_unary_fp_le', inexactvec),
              ('loops_autovec', bints),
          ]),
          ),
'signbit':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理符号位检测
    Ufunc(1, 1, None,
          # 获取关于 signbit 函数的文档字符串
          docstrings.get('numpy._core.umath.signbit'),
          None,
          # 设置类型描述，指定浮点数类型（flts），输出为布尔类型（'?'），并根据分发模式选择不同的实现
          TD(flts, out='?', dispatch=[('loops_unary_fp_le', inexactvec)]),
          ),
'copysign':
    # 创建一个具有两个输入参数和单个输出参数的通用函数对象，处理符号复制
    Ufunc(2, 1, None,
          # 获取关于 copysign 函数的文档字符串
          docstrings.get('numpy._core.umath.copysign'),
          None,
          # 设置类型描述，指定浮点数类型（flts）
          TD(flts),
          ),
'nextafter':
    # 创建一个具有两个输入参数和单个输出参数的通用函数对象，处理浮点数邻近值
    Ufunc(2, 1, None,
          # 获取关于 nextafter 函数的文档字符串
          docstrings.get('numpy._core.umath.nextafter'),
          None,
          # 设置类型描述，指定浮点数类型（flts）
          TD(flts),
          ),
'spacing':
    # 创建一个具有单个输入参数和单个输出参数的通用函数对象，处理浮点数间距
    Ufunc(1, 1, None,
          # 获取关于 spacing 函数的文档字符串
          docstrings.get('numpy._core.umath.spacing'),
          None,
          # 设置类型描述，指定浮点数类型（flts）
          TD(flts),
          ),
'modf':
    # 创建一个具有单个输入参数和两个输出参数的通用函数对象，处理浮点数分解
    Ufunc(1, 2, None,
          # 获取关于 modf 函数的文档字符串
          docstrings.get('numpy._core.umath.modf'),
          None,
          # 设置类型描述，指定浮点数类型（flts）
          TD(flts),
          ),
'ldexp' :
    # 创建一个具有两个输入参数和单个输出参数的通用函数对象，处理指数运算
    Ufunc(2, 1, None,
          # 获取关于 ldexp 函数的文档字符串
          docstrings.get('numpy._core.umath.ldexp'),
          None,
          # 设置类型描述，包含多个可能的输入类型和输出类型组合，具体依赖于浮点数和整数类型的组合
          [TypeDescription('e', None, 'ei', 'e'),
          TypeDescription('f', None, 'fi', 'f', dispatch='loops_exponent_log'),
          TypeDescription('e', FuncNameSuffix('int64'), 'e'+int64, 'e'),
          TypeDescription('f', FuncNameSuffix('int64'), 'f'+int64, 'f'),
          TypeDescription('d', None, 'di', 'd', dispatch='loops_exponent_log'),
          TypeDescription('d', FuncNameSuffix('int64'), 'd'+int64, 'd'),
          TypeDescription('g', None, 'gi', 'g'),
          TypeDescription('g', FuncNameSuffix('int64'), 'g'+int64, 'g'),
          ],
          ),
'frexp' :
    # 创建一个具有单个输入参数和两个输出参数的通用函数对象，处理浮点数分解
    Ufunc(1, 2, None,
          # 获取关于 frexp 函数的文档字符串
          docstrings.get('numpy._core.umath.frexp'),
          None,
          # 设置类型描述，包含多个可能的输入类型和输出类型组合，具体依赖于浮点数和整数类型的组合
          [TypeDescription('e', None, 'e', 'ei'),
          TypeDescription('f', None, 'f', 'fi', dispatch='loops_exponent_log'),
          TypeDescription('d', None, 'd', 'di', dispatch='loops_exponent_log'),
          TypeDescription('g', None, 'g', 'gi'),
          ],
          ),
'gcd' :
    # 创建一个通用函数对象，处理最大公约数计算
    # 使用 Ufunc 类创建一个通用函数对象，并传入多个参数进行初始化
    Ufunc(
        # 第一个参数：通用函数的输入参数数量为 2
        2,
        # 第二个参数：通用函数的输出参数数量为 1
        1,
        # 第三个参数：通用函数的输出参数类型为 Zero
        Zero,
        # 第四个参数：从 docstrings 中获取 numpy._core.umath.gcd 的文档字符串
        docstrings.get('numpy._core.umath.gcd'),
        # 第五个参数：指定类型解析器为 "PyUFunc_SimpleUniformOperationTypeResolver"
        "PyUFunc_SimpleUniformOperationTypeResolver",
        # 第六个参数：输入参数类型描述符为 TD(ints)
        TD(ints),
        # 第七个参数：输出参数类型描述符为 TD('O')，并指定函数 'npy_ObjectGCD'
        TD('O', f='npy_ObjectGCD'),
    )
'lcm' :
    # 创建一个 Ufunc 对象，用于最小公倍数的计算，接受两个参数并返回一个值
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.lcm'),  # 获取 lcm 函数的文档字符串
          "PyUFunc_SimpleUniformOperationTypeResolver",  # 操作类型解析器
          TD(ints),  # 参数类型描述，ints 表示整数
          TD('O', f='npy_ObjectLCM'),  # 输出类型描述，'O' 表示对象类型，使用 npy_ObjectLCM 函数处理
          ),

'bitwise_count':
    # 创建一个 Ufunc 对象，用于按位计数，接受一个参数并返回一个值
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.bitwise_count'),  # 获取 bitwise_count 函数的文档字符串
          None,  # 操作类型解析器为 None
          TD(ints, dispatch=[('loops_autovec', ints)], out='B'),  # 参数类型描述，ints 表示整数，'B' 表示布尔类型
          TD(P, f='bit_count'),  # 输出类型描述，使用 bit_count 函数处理
          ),

'matmul' :
    # 创建一个 Ufunc 对象，用于矩阵乘法，接受两个参数并返回一个值
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.matmul'),  # 获取 matmul 函数的文档字符串
          "PyUFunc_SimpleUniformOperationTypeResolver",  # 操作类型解析器
          TD(notimes_or_obj),  # 参数类型描述，notimes_or_obj 表示非 times 或对象类型
          TD(O),  # 输出类型描述，O 表示对象
          signature='(n?,k),(k,m?)->(n?,m?)',  # 签名描述，表示接受的参数形状和返回的结果形状
          ),

'vecdot':
    # 创建一个 Ufunc 对象，用于向量点乘，接受两个参数并返回一个标量
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.vecdot'),  # 获取 vecdot 函数的文档字符串
          "PyUFunc_SimpleUniformOperationTypeResolver",  # 操作类型解析器
          TD(notimes_or_obj),  # 参数类型描述，notimes_or_obj 表示非 times 或对象类型
          TD(O),  # 输出类型描述，O 表示对象
          signature='(n),(n)->()',  # 签名描述，表示接受的参数形状和返回的结果形状
          ),

'str_len':
    # 创建一个 Ufunc 对象，用于计算字符串长度，接受一个参数并返回一个值
    Ufunc(1, 1, Zero,
          docstrings.get('numpy._core.umath.str_len'),  # 获取 str_len 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isalpha':
    # 创建一个 Ufunc 对象，用于检查字符是否为字母，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isalpha'),  # 获取 isalpha 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isdigit':
    # 创建一个 Ufunc 对象，用于检查字符是否为数字，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isdigit'),  # 获取 isdigit 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isspace':
    # 创建一个 Ufunc 对象，用于检查字符是否为空白字符，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isspace'),  # 获取 isspace 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isalnum':
    # 创建一个 Ufunc 对象，用于检查字符是否为字母或数字，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isalnum'),  # 获取 isalnum 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'islower':
    # 创建一个 Ufunc 对象，用于检查字符是否为小写字母，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.islower'),  # 获取 islower 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isupper':
    # 创建一个 Ufunc 对象，用于检查字符是否为大写字母，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isupper'),  # 获取 isupper 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'istitle':
    # 创建一个 Ufunc 对象，用于检查字符串是否为 titlecased，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.istitle'),  # 获取 istitle 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isdecimal':
    # 创建一个 Ufunc 对象，用于检查字符是否为十进制数字，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isdecimal'),  # 获取 isdecimal 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'isnumeric':
    # 创建一个 Ufunc 对象，用于检查字符是否为数字，接受一个参数并返回一个布尔值
    Ufunc(1, 1, False_,
          docstrings.get('numpy._core.umath.isnumeric'),  # 获取 isnumeric 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'find':
    # 创建一个 Ufunc 对象，用于在字符串中查找子字符串，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath.find'),  # 获取 find 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'rfind':
    # 创建一个 Ufunc 对象，用于在字符串中反向查找子字符串，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath.rfind'),  # 获取 rfind 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'count':
    # 创建一个 Ufunc 对象，用于统计子字符串出现的次数，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath.count'),  # 获取 count 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'index':
    # 创建一个 Ufunc 对象，用于在字符串中查找子字符串的位置，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath.index'),  # 获取 index 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'rindex':
    # 创建一个 Ufunc 对象，用于在字符串中反向查找子字符串的位置，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath.rindex'),  # 获取 rindex 函数的文档字符串
          None,  # 操作类型解析器为 None
          ),

'_replace':
    # 创建一个 Ufunc 对象，用于替换字符串中的子字符串，接受四个参数并返回一个值
    Ufunc(4, 1, None,
          docstrings.get('numpy._core.umath._replace'),  # 获取 _replace 函数的文档字符串
          None,  # 操作类型
    # 调用 Ufunc 类的构造函数，传入参数 4, 1, False, 并设置其 docstrings 属性为 'numpy._core.umath.endswith'
    Ufunc(4, 1, False_,
          docstrings.get('numpy._core.umath.endswith'),
          None,
          ),
{
    '_strip_chars':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._strip_chars'),
              None,
              ),
    # 创建一个名为 _strip_chars 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._strip_chars' 对应的文档字符串作为文档
    '_lstrip_chars':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._lstrip_chars'),
              None,
              ),
    # 创建一个名为 _lstrip_chars 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._lstrip_chars' 对应的文档字符串作为文档
    '_rstrip_chars':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._rstrip_chars'),
              None,
              ),
    # 创建一个名为 _rstrip_chars 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._rstrip_chars' 对应的文档字符串作为文档
    '_strip_whitespace':
        Ufunc(1, 1, None,
              docstrings.get('numpy._core.umath._strip_whitespace'),
              None,
              ),
    # 创建一个名为 _strip_whitespace 的 Ufunc 对象，参数为 (1, 1)
    # 使用 docstrings 中与 'numpy._core.umath._strip_whitespace' 对应的文档字符串作为文档
    '_lstrip_whitespace':
        Ufunc(1, 1, None,
              docstrings.get('numpy._core.umath._lstrip_whitespace'),
              None,
              ),
    # 创建一个名为 _lstrip_whitespace 的 Ufunc 对象，参数为 (1, 1)
    # 使用 docstrings 中与 'numpy._core.umath._lstrip_whitespace' 对应的文档字符串作为文档
    '_rstrip_whitespace':
        Ufunc(1, 1, None,
              docstrings.get('numpy._core.umath._rstrip_whitespace'),
              None,
              ),
    # 创建一个名为 _rstrip_whitespace 的 Ufunc 对象，参数为 (1, 1)
    # 使用 docstrings 中与 'numpy._core.umath._rstrip_whitespace' 对应的文档字符串作为文档
    '_expandtabs_length':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._expandtabs_length'),
              None,
              ),
    # 创建一个名为 _expandtabs_length 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._expandtabs_length' 对应的文档字符串作为文档
    '_expandtabs':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._expandtabs'),
              None,
              ),
    # 创建一个名为 _expandtabs 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._expandtabs' 对应的文档字符串作为文档
    '_center':
        Ufunc(3, 1, None,
              docstrings.get('numpy._core.umath._center'),
              None,
              ),
    # 创建一个名为 _center 的 Ufunc 对象，参数为 (3, 1)
    # 使用 docstrings 中与 'numpy._core.umath._center' 对应的文档字符串作为文档
    '_ljust':
        Ufunc(3, 1, None,
              docstrings.get('numpy._core.umath._ljust'),
              None,
              ),
    # 创建一个名为 _ljust 的 Ufunc 对象，参数为 (3, 1)
    # 使用 docstrings 中与 'numpy._core.umath._ljust' 对应的文档字符串作为文档
    '_rjust':
        Ufunc(3, 1, None,
              docstrings.get('numpy._core.umath._rjust'),
              None,
              ),
    # 创建一个名为 _rjust 的 Ufunc 对象，参数为 (3, 1)
    # 使用 docstrings 中与 'numpy._core.umath._rjust' 对应的文档字符串作为文档
    '_zfill':
        Ufunc(2, 1, None,
              docstrings.get('numpy._core.umath._zfill'),
              None,
              ),
    # 创建一个名为 _zfill 的 Ufunc 对象，参数为 (2, 1)
    # 使用 docstrings 中与 'numpy._core.umath._zfill' 对应的文档字符串作为文档
    '_partition_index':
        Ufunc(3, 3, None,
              docstrings.get('numpy._core.umath._partition_index'),
              None,
              ),
    # 创建一个名为 _partition_index 的 Ufunc 对象，参数为 (3, 3)
    # 使用 docstrings 中与 'numpy._core.umath._partition_index' 对应的文档字符串作为文档
    '_rpartition_index':
        Ufunc(3, 3, None,
              docstrings.get('numpy._core.umath._rpartition_index'),
              None,
              ),
    # 创建一个名为 _rpartition_index 的 Ufunc 对象，参数为 (3, 3)
    # 使用 docstrings 中与 'numpy._core.umath._rpartition_index' 对应的文档字符串作为文档
    '_partition':
        Ufunc(2, 3, None,
              docstrings.get('numpy._core.umath._partition'),
              None,
              ),
    # 创建一个名为 _partition 的 Ufunc 对象，参数为 (2, 3)
    # 使用 docstrings 中与 'numpy._core.umath._partition' 对应的文档字符串作为文档
    '_rpartition':
        Ufunc(2, 3, None,
              docstrings.get('numpy._core.umath._rpartition'),
              None,
              ),
    # 创建一个名为 _rpartition 的 Ufunc 对象，参数为 (2, 3)
    # 使用 docstrings 中与 'numpy._core.umath._rpartition' 对应的文档字符串作为文档
}

def indent(st, spaces):
    # 根据给定的 spaces 数量生成等量的空格作为缩进字符串
    indentation = ' '*spaces
    # 将字符串 st 中的每个换行符替换为缩进字符串加换行符，实现整体缩进
    indented = indentation + st.replace('\n', '\n'+indentation)
    # 使用正则表达式去除缩进后面可能存在的空格，确保格式化的文本没有末尾空白
    indented = re.sub(r' +$', r'', indented)
    return indented

# 定义一个字典，将给定的 (nin, nout) 和 type 元组映射到对应的后缀字符串
arity_lookup = {
    (1, 1): {
        'e': 'e_e',
        'f': 'f_f',
        'd': 'd_d',
        'g': 'g_g',
        'F': 'F_F',
        'D': 'D_D',
        'G': 'G_G',
        'O': 'O_O',
        'P': 'O_O_method',
    },
    (2, 1): {
        'e': 'ee_e',
        'f': 'ff_f',
        'd': 'dd_d',
        'g': 'gg_g',
        'F': 'FF_F',
        'D': 'DD_D',
        'G': 'GG_G',
        'O': 'OO_O',
        'P': 'OO_O_method',
    },
    (3, 1): {
        'O': 'OOO_O',
    }
}
    # functions array contains an entry for every type implemented NULL
    # should be placed where PyUfunc_ style function will be filled in
    # later
    # 初始化空列表用于存储 code1 的代码段
    code1list = []
    # 初始化空列表用于存储 code2 的代码段
    code2list = []
    # 初始化空字典用于存储函数名和函数相关信息的映射关系
    dispdict  = {}
    # 获取已排序的函数名列表
    names = sorted(funcdict.keys())
    # 遍历 dispdict 中的每个函数名和对应的函数列表
    for dname, funcs in dispdict.items():
        # 在 code2list 中添加预处理指令，根据条件编译是否禁用优化
        code2list.append(textwrap.dedent(f"""
            #ifndef NPY_DISABLE_OPTIMIZATION
            #include "{dname}.dispatch.h"
            #endif
        """))
        # 遍历函数列表中的每个函数信息元组，生成相关代码段
        for (ufunc_name, func_idx, cfunc_name, inout) in funcs:
            # 在 code2list 中添加函数调度跟踪信息和调用宏的代码段
            code2list.append(textwrap.dedent(f"""\
                NPY_CPU_DISPATCH_TRACE("{ufunc_name}", "{''.join(inout)}");
                NPY_CPU_DISPATCH_CALL_XB({ufunc_name}_functions[{func_idx}] = {cfunc_name});
            """))
    # 返回 code1list 和 code2list 的字符串形式连接结果
    return "\n".join(code1list), "\n".join(code2list)
# 定义一个函数，根据给定的函数字典生成一组代码字符串列表
def make_ufuncs(funcdict):
    # 初始化一个空的代码字符串列表
    code3list = []
    # 对函数字典的键进行排序，并存储在变量 names 中
    names = sorted(funcdict.keys())
    # 将代码字符串列表中的所有元素连接成一个单独的字符串，并返回结果
    return '\n'.join(code3list)


# 定义一个函数，根据给定的函数字典和文件名生成一段代码字符串
def make_code(funcdict, filename):
    # 调用 make_arrays 函数，返回两个代码字符串 code1 和 code2
    code1, code2 = make_arrays(funcdict)
    # 调用 make_ufuncs 函数，生成代码字符串 code3
    code3 = make_ufuncs(funcdict)
    # 对 code2 和 code3 的每一行进行缩进，缩进量为4个空格
    code2 = indent(code2, 4)
    code3 = indent(code3, 4)
    # 构建包含三重引号的多行字符串，用于生成最终的代码文件内容
    code = textwrap.dedent(r"""

    /** Warning this file is autogenerated!!!

        Please make changes to the code generator program (%s)
    **/
    #include "ufunc_object.h"
    #include "ufunc_type_resolution.h"
    #include "loops.h"
    #include "matmul.h"
    #include "clip.h"
    #include "dtypemeta.h"
    #include "_umath_doc_generated.h"

    %s
    /* Returns a borrowed ref of the second value in the matching info tuple */
    PyObject *
    get_info_no_cast(PyUFuncObject *ufunc, PyArray_DTypeMeta *op_dtype,
                     int ndtypes);

    static int
    InitOperators(PyObject *dictionary) {
        PyObject *f, *identity;

    %s
    %s

        return 0;
    }
    """) % (os.path.basename(filename), code1, code2, code3)
    # 返回生成的代码字符串
    return code


# 主函数，程序入口
def main():
    # 创建一个参数解析器对象
    parser = argparse.ArgumentParser()
    # 添加一个命令行参数选项 '-o' 或 '--outfile'，用于指定输出文件的路径
    parser.add_argument(
        "-o",
        "--outfile",
        type=str,
        help="Path to the output directory"
    )
    # 解析命令行参数
    args = parser.parse_args()

    # 获取当前脚本文件的文件名，存储在变量 filename 中
    filename = __file__
    # 调用 make_code 函数生成代码，并将结果存储在变量 code 中
    code = make_code(defdict, filename)

    # 如果未指定输出文件路径，则默认使用 '__umath_generated.c'
    if not args.outfile:
        # 这是基于 distutils 的构建方式
        outfile = '__umath_generated.c'
    else:
        # 否则，将输出文件路径设置为当前工作目录下的指定路径
        outfile = os.path.join(os.getcwd(), args.outfile)

    # 打开输出文件，以写入模式写入生成的代码
    with open(outfile, 'w') as f:
        f.write(code)


# 当脚本直接执行时，调用主函数 main
if __name__ == "__main__":
    main()
```