# `.\numpy\numpy\linalg\lapack_lite\f2c_s_lapack.c`

```
/*
 * NOTE: This is generated code. Look in numpy/linalg/lapack_lite for
 *       information on remaking this file.
 */
#include "f2c.h"

#ifdef HAVE_CONFIG
#include "config.h"
#else
extern doublereal dlamch_(char *);
#define EPSILON dlamch_("Epsilon")
#define SAFEMINIMUM dlamch_("Safe minimum")
#define PRECISION dlamch_("Precision")
#define BASE dlamch_("Base")
#endif

extern doublereal dlapy2_(doublereal *x, doublereal *y);

/*
f2c knows the exact rules for precedence, and so omits parentheses where not
strictly necessary. Since this is generated code, we don't really care if
it's readable, and we know what is written is correct. So don't warn about
them.
*/
#if defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

/* Table of constant values */
// 常量定义部分

static integer c__9 = 9;  // 定义整数常量 c__9，值为 9
static integer c__0 = 0;  // 定义整数常量 c__0，值为 0
static real c_b15 = 1.f;  // 定义实数常量 c_b15，值为 1.0
static integer c__1 = 1;  // 定义整数常量 c__1，值为 1
static real c_b29 = 0.f;  // 定义实数常量 c_b29，值为 0.0
static doublereal c_b94 = -.125;  // 定义双精度实数常量 c_b94，值为 -0.125
static real c_b151 = -1.f;  // 定义实数常量 c_b151，值为 -1.0
static integer c_n1 = -1;  // 定义整数常量 c_n1，值为 -1
static integer c__3 = 3;  // 定义整数常量 c__3，值为 3
static integer c__2 = 2;  // 定义整数常量 c__2，值为 2
static integer c__65 = 65;  // 定义整数常量 c__65，值为 65
static integer c__6 = 6;  // 定义整数常量 c__6，值为 6
static integer c__12 = 12;  // 定义整数常量 c__12，值为 12
static integer c__49 = 49;  // 定义整数常量 c__49，值为 49
static integer c__4 = 4;  // 定义整数常量 c__4，值为 4
static logical c_false = FALSE_;  // 定义逻辑常量 c_false，值为 FALSE_
static integer c__13 = 13;  // 定义整数常量 c__13，值为 13
static integer c__15 = 15;  // 定义整数常量 c__15，值为 15
static integer c__14 = 14;  // 定义整数常量 c__14，值为 14
static integer c__16 = 16;  // 定义整数常量 c__16，值为 16
static logical c_true = TRUE_;  // 定义逻辑常量 c_true，值为 TRUE_
static real c_b3178 = 2.f;  // 定义实数常量 c_b3178，值为 2.0

/* Subroutine */ int sbdsdc_(char *uplo, char *compq, integer *n, real *d__,
    real *e, real *u, integer *ldu, real *vt, integer *ldvt, real *q,
    integer *iq, real *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j, k;
    static real p, r__;
    static integer z__, ic, ii, kk;
    static real cs;
    static integer is, iu;
    static real sn;
    static integer nm1;
    static real eps;
    static integer ivt, difl, difr, ierr, perm, mlvl, sqre;
    extern logical lsame_(char *, char *);
    static integer iuplo, nsize, start;
    extern /* Subroutine */ int slasr_(char *, char *, char *, integer *,
        integer *, real *, real *, real *, integer *);
    static integer poles;
    extern /* Subroutine */ int slasd0_(integer *, integer *, real *, real *,
        real *, integer *, real *, integer *, integer *, integer *, real *,
        integer *);
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int slasda_(integer *, integer *, integer *,
        integer *, real *, real *, real *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, integer *, integer *,
        integer *, real *, real *, real *, real *, integer *, integer *),
        xerbla_(char *, integer *);



注释：
    ! 声明外部函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 声明外部子例程 slascl_
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);
    ! 声明静态整数变量 givcol
    static integer givcol;
    ! 声明外部子例程 slasdq_
    extern /* Subroutine */ int slasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, real *, real *, real *, integer *, real *
        , integer *, real *, integer *, real *, integer *);
    ! 声明静态整数变量 icompq
    static integer icompq;
    ! 声明外部子例程 slaset_
    extern /* Subroutine */ int slaset_(char *, integer *, integer *, real *,
        real *, real *, integer *);
    ! 声明外部子例程 slartg_
    extern /* Subroutine */ int slartg_(real *, real *, real *
        , real *, real *);
    ! 声明静态实数变量 orgnrm
    static real orgnrm;
    ! 声明静态整数变量 givnum
    static integer givnum;
    ! 声明静态整数变量 givptr, qstart, smlsiz, wstart, smlszp
    static integer givptr, qstart, smlsiz, wstart, smlszp;
/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SBDSDC computes the singular value decomposition (SVD) of a real
    N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
    using a divide and conquer method, where S is a diagonal matrix
    with non-negative diagonal elements (the singular values of B), and
    U and VT are orthogonal matrices of left and right singular vectors,
    respectively. SBDSDC can be used to compute all singular values,
    and optionally, singular vectors or singular vectors in compact form.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See SLASD3 for details.

    The code currently calls SLASDQ if singular values only are desired.
    However, it can be slightly modified to compute singular values
    using the divide and conquer method.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  B is upper bidiagonal.
            = 'L':  B is lower bidiagonal.

    COMPQ   (input) CHARACTER*1
            Specifies whether singular vectors are to be computed
            as follows:
            = 'N':  Compute singular values only;
            = 'P':  Compute singular values and compute singular
                    vectors in compact form;
            = 'I':  Compute singular values and singular vectors.

    N       (input) INTEGER
            The order of the matrix B.  N >= 0.

    D       (input/output) REAL array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the elements of E contain the offdiagonal
            elements of the bidiagonal matrix whose SVD is desired.
            On exit, E has been destroyed.

    U       (output) REAL array, dimension (LDU,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, U contains the left singular vectors
               of the bidiagonal matrix.
            For other values of COMPQ, U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU >= 1.
            If singular vectors are desired, then LDU >= max( 1, N ).

    VT      (output) REAL array, dimension (LDVT,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, VT' contains the right singular
               vectors of the bidiagonal matrix.
            For other values of COMPQ, VT is not referenced.
*/
    ! LDVT (input) INTEGER
    !     The leading dimension of the array VT. LDVT >= 1.
    !     If singular vectors are desired, then LDVT >= max( 1, N ).

    ! Q (output) REAL array, dimension (LDQ)
    !     If COMPQ = 'P', then:
    !        On exit, if INFO = 0, Q and IQ contain the left
    !        and right singular vectors in a compact form,
    !        requiring O(N log N) space instead of 2*N**2.
    !        In particular, Q contains all the REAL data in
    !        LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
    !        words of memory, where SMLSIZ is returned by ILAENV and
    !        is equal to the maximum size of the subproblems at the
    !        bottom of the computation tree (usually about 25).
    !     For other values of COMPQ, Q is not referenced.

    ! IQ (output) INTEGER array, dimension (LDIQ)
    !     If COMPQ = 'P', then:
    !        On exit, if INFO = 0, Q and IQ contain the left
    !        and right singular vectors in a compact form,
    !        requiring O(N log N) space instead of 2*N**2.
    !        In particular, IQ contains all INTEGER data in
    !        LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
    !        words of memory, where SMLSIZ is returned by ILAENV and
    !        is equal to the maximum size of the subproblems at the
    !        bottom of the computation tree (usually about 25).
    !     For other values of COMPQ, IQ is not referenced.

    ! WORK (workspace) REAL array, dimension (MAX(1,LWORK))
    !     If COMPQ = 'N' then LWORK >= (4 * N).
    !     If COMPQ = 'P' then LWORK >= (6 * N).
    !     If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).

    ! IWORK (workspace) INTEGER array, dimension (8*N)

    ! INFO (output) INTEGER
    !     = 0: successful exit.
    !     < 0: if INFO = -i, the i-th argument had an illegal value.
    !     > 0: The algorithm failed to compute a singular value.
    !          The update process of divide and conquer failed.

    ! Further Details
    ! ===============
    ! Based on contributions by
    !    Ming Gu and Huan Ren, Computer Science Division, University of
    !    California at Berkeley, USA
    ! =====================================================================
    ! Changed dimension statement in comment describing E from (N) to
    ! (N-1). Sven, 17 Feb 05.
    ! =====================================================================


       ! Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --e;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --q;
    --iq;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;

    iuplo = 0;
    if (lsame_(uplo, "U")) {
        iuplo = 1;
    }
    if (lsame_(uplo, "L")) {
        iuplo = 2;
    }
    if (lsame_(compq, "N")) {
        icompq = 0;
    } else if (lsame_(compq, "P")) {
        icompq = 1;
    } else if (lsame_(compq, "I")) {
        icompq = 2;
    } else {
        icompq = -1;
    }
    if (iuplo == 0) {
        *info = -1;
    } else if (icompq < 0) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*ldu < 1 || icompq == 2 && *ldu < *n) {
        *info = -7;
    } else if (*ldvt < 1 || icompq == 2 && *ldvt < *n) {
        *info = -9;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SBDSDC", &i__1);
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        return 0;
    }
    smlsiz = ilaenv_(&c__9, "SBDSDC", " ", &c__0, &c__0, &c__0, &c__0, (
        ftnlen)6, (ftnlen)1);
    if (*n == 1) {
        if (icompq == 1) {
            q[1] = r_sign(&c_b15, &d__[1]);
            q[smlsiz * *n + 1] = 1.f;
        } else if (icompq == 2) {
            u[u_dim1 + 1] = r_sign(&c_b15, &d__[1]);
            vt[vt_dim1 + 1] = 1.f;
        }
        d__[1] = dabs(d__[1]);
        return 0;
    }
    nm1 = *n - 1;

/*
       If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left
*/

    wstart = 1;
    qstart = 3;
    if (icompq == 1) {
        scopy_(n, &d__[1], &c__1, &q[1], &c__1);
        i__1 = *n - 1;
        scopy_(&i__1, &e[1], &c__1, &q[*n + 1], &c__1);
    }
    if (iuplo == 2) {
        qstart = 5;
        wstart = (*n << 1) - 1;
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {
            slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);
            d__[i__] = r__;
            e[i__] = sn * d__[i__ + 1];
            d__[i__ + 1] = cs * d__[i__ + 1];
            if (icompq == 1) {
                q[i__ + (*n << 1)] = cs;
                q[i__ + *n * 3] = sn;
            } else if (icompq == 2) {
                work[i__] = cs;
                work[nm1 + i__] = -sn;
            }
        }
    }

/*     If ICOMPQ = 0, use SLASDQ to compute the singular values. */

    if (icompq == 0) {
        slasdq_("U", &c__0, n, &c__0, &c__0, &c__0, &d__[1], &e[1], &vt[
            vt_offset], ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[
            wstart], info);
        goto L40;
    }

/*
       If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver.
*/

    if (*n <= smlsiz) {
        if (icompq == 2) {
            slaset_("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
            slaset_("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
            slasdq_("U", &c__0, n, n, n, &c__0, &d__[1], &e[1], &vt[vt_offset]
                , ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[
                wstart], info);
    } else if (icompq == 1) {
        // 如果 icompq 等于 1，则执行以下操作
        iu = 1;  // 设置 iu 的值为 1
        ivt = iu + *n;  // 计算 ivt 的值为 iu + n
        slaset_("A", n, n, &c_b29, &c_b15, &q[iu + (qstart - 1) * *n], n);
        // 调用 slaset 函数，用 c_b29 和 c_b15 填充 q 数组的子矩阵
        slaset_("A", n, n, &c_b29, &c_b15, &q[ivt + (qstart - 1) * *n], n);
        // 调用 slaset 函数，用 c_b29 和 c_b15 填充 q 数组的子矩阵
        slasdq_("U", &c__0, n, n, n, &c__0, &d__[1], &e[1], &q[ivt + (
            qstart - 1) * *n], n, &q[iu + (qstart - 1) * *n], n, &q[
            iu + (qstart - 1) * *n], n, &work[wstart], info);
        // 调用 slasdq 函数，进行奇异值分解
    }
    goto L40;
    // 跳转到标签 L40 处

    if (icompq == 2) {
        // 如果 icompq 等于 2，则执行以下操作
        slaset_("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
        // 调用 slaset 函数，用 c_b29 和 c_b15 填充 u 数组的子矩阵
        slaset_("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
        // 调用 slaset 函数，用 c_b29 和 c_b15 填充 vt 数组的子矩阵
    }
/*     Scale. */

// 计算数组 d__ 的无穷范数
orgnrm = slanst_("M", n, &d__[1], &e[1]);
// 如果无穷范数为零，则直接返回成功
if (orgnrm == 0.f) {
    return 0;
}
// 将数组 d__ 和 e[] 中的元素按照 orgnrm 进行缩放
slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, &c__1, &d__[1], n, &ierr);
slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &nm1, &c__1, &e[1], &nm1, &ierr);

// 计算机器精度
eps = slamch_("Epsilon");

// 计算分解级别 mlvl
mlvl = (integer) (log((real) (*n) / (real) (smlsiz + 1)) / log(2.f)) + 1;
// 设置 smlszp 为 smlsiz + 1
smlszp = smlsiz + 1;

// 如果需要计算 Q 矩阵
if (icompq == 1) {
    iu = 1;
    ivt = smlsiz + 1;
    difl = ivt + smlszp;
    difr = difl + mlvl;
    z__ = difr + (mlvl << 1);
    ic = z__ + mlvl;
    is = ic + 1;
    poles = is + 1;
    givnum = poles + (mlvl << 1);

    k = 1;
    givptr = 2;
    perm = 3;
    givcol = perm + mlvl;
}

// 对数组 d__ 中的每个元素进行检查，如果小于机器精度 eps，将其设为 eps 的符号值
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
    if ((r__1 = d__[i__], dabs(r__1)) < eps) {
        d__[i__] = r_sign(&eps, &d__[i__]);
    }
    // L20 标签：循环的结束标记
}

// 初始化子问题起始点和 sqre 变量
start = 1;
sqre = 0;

// 处理数组 e 中的元素，寻找子问题进行分解
i__1 = nm1;
for (i__ = 1; i__ <= i__1; ++i__) {
    if ((r__1 = e[i__], dabs(r__1)) < eps || i__ == nm1) {

        /*
          Subproblem found. First determine its size and then
          apply divide and conquer on it.
        */

        if (i__ < nm1) {

            /*        A subproblem with E(I) small for I < NM1. */

            nsize = i__ - start + 1;
        } else if ((r__1 = e[i__], dabs(r__1)) >= eps) {

            /*        A subproblem with E(NM1) not too small but I = NM1. */

            nsize = *n - start + 1;
        } else {

            /*
              A subproblem with E(NM1) small. This implies an
              1-by-1 subproblem at D(N). Solve this 1-by-1 problem
              first.
            */

            nsize = i__ - start + 1;
            // 根据 icompq 的值设定 Q 矩阵中的元素
            if (icompq == 2) {
                u[*n + *n * u_dim1] = r_sign(&c_b15, &d__[*n]);
                vt[*n + *n * vt_dim1] = 1.f;
            } else if (icompq == 1) {
                q[*n + (qstart - 1) * *n] = r_sign(&c_b15, &d__[*n]);
                q[*n + (smlsiz + qstart - 1) * *n] = 1.f;
            }
            d__[*n] = (r__1 = d__[*n], dabs(r__1));
        }
        // 调用不同的子程序进行求解子问题
        if (icompq == 2) {
            slasd0_(&nsize, &sqre, &d__[start], &e[start], &u[start +
                start * u_dim1], ldu, &vt[start + start * vt_dim1],
                ldvt, &smlsiz, &iwork[1], &work[wstart], info);
        } else {
            slasda_(&icompq, &smlsiz, &nsize, &sqre, &d__[start], &e[
                start], &q[start + (iu + qstart - 2) * *n], n, &q[
                start + (ivt + qstart - 2) * *n], &iq[start + k * *n],
                 &q[start + (difl + qstart - 2) * *n], &q[start + (
                difr + qstart - 2) * *n], &q[start + (z__ + qstart -
                2) * *n], &q[start + (poles + qstart - 2) * *n], &iq[
                start + givptr * *n], &iq[start + givcol * *n], n, &
                iq[start + perm * *n], &q[start + (givnum + qstart -
                2) * *n], &q[start + (ic + qstart - 2) * *n], &q[
                start + (is + qstart - 2) * *n], &work[wstart], &
                iwork[1], info);
        }
        // 如果执行子程序出错，则返回失败
        if (*info != 0) {
            return 0;
        }
        start = i__ + 1;
    }
    // L30 标签：循环的结束标记
}
/*     Unscale */

    slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n, &ierr);
L40:

/*     Use Selection Sort to minimize swaps of singular vectors */

    i__1 = *n;
    for (ii = 2; ii <= i__1; ++ii) {
    i__ = ii - 1;
    kk = i__;
    p = d__[i__];
    i__2 = *n;
    for (j = ii; j <= i__2; ++j) {
        if (d__[j] > p) {
        kk = j;
        p = d__[j];
        }
/* L50: */
    }
    if (kk != i__) {
        d__[kk] = d__[i__];
        d__[i__] = p;
        if (icompq == 1) {
        iq[i__] = kk;
        } else if (icompq == 2) {
        sswap_(n, &u[i__ * u_dim1 + 1], &c__1, &u[kk * u_dim1 + 1], &
            c__1);
        sswap_(n, &vt[i__ + vt_dim1], ldvt, &vt[kk + vt_dim1], ldvt);
        }
    } else if (icompq == 1) {
        iq[i__] = i__;
    }
/* L60: */
    }

/*     If ICOMPQ = 1, use IQ(N,1) as the indicator for UPLO */

    if (icompq == 1) {
    if (iuplo == 1) {
        iq[*n] = 1;
    } else {
        iq[*n] = 0;
    }
    }

/*
       If B is lower bidiagonal, update U by those Givens rotations
       which rotated B to be upper bidiagonal
*/

    if (iuplo == 2 && icompq == 2) {
    slasr_("L", "V", "B", n, n, &work[1], &work[*n], &u[u_offset], ldu);
    }

    return 0;

/*     End of SBDSDC */

} /* sbdsdc_ */

/* Subroutine */ int sbdsqr_(char *uplo, integer *n, integer *ncvt, integer *
    nru, integer *ncc, real *d__, real *e, real *vt, integer *ldvt, real *
    u, integer *ldu, real *c__, integer *ldc, real *work, integer *info)
{
    /* System generated locals */
    integer c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2;
    real r__1, r__2, r__3, r__4;
    doublereal d__1;

    /* Local variables */
    static real f, g, h__;
    static integer i__, j, m;
    static real r__, cs;
    static integer ll;
    static real sn, mu;
    static integer nm1, nm12, nm13, lll;
    static real eps, sll, tol, abse;
    static integer idir;
    static real abss;
    static integer oldm;
    static real cosl;
    static integer isub, iter;
    static real unfl, sinl, cosr, smin, smax, sinr;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *), slas2_(real *, real *, real *, real *,
         real *);
    extern logical lsame_(char *, char *);
    static real oldcs;
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
    static integer oldll;
    static real shift, sigmn, oldsn;
    static integer maxit;
    static real sminl;
    extern /* Subroutine */ int slasr_(char *, char *, char *, integer *,
        integer *, real *, real *, real *, integer *);
    static real sigmx;
    static logical lower;
    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *,
        integer *), slasq1_(integer *, real *, real *, real *, integer *),
         slasv2_(real *, real *, real *, real *, real *, real *, real *,
        real *, real *);
    extern doublereal slamch_(char *);



注释：
    # 外部声明一个子例程 xerbla_，该子例程接受一个字符指针和一个整数指针作为参数
    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 静态声明一个实数变量 sminoa
    static real sminoa;
    # 外部声明一个子例程 slartg_，该子例程接受四个实数指针和一个实数指针作为参数
    extern /* Subroutine */ int slartg_(real *, real *, real *, real *, real *);
    # 静态声明一个实数变量 thresh
    static real thresh;
    # 静态声明一个逻辑变量 rotate
    static logical rotate;
    # 静态声明一个实数变量 tolmul
    static real tolmul;
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       January 2007


    Purpose
    =======

    SBDSQR computes the singular values and, optionally, the right and/or
    left singular vectors from the singular value decomposition (SVD) of
    a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
    zero-shift QR algorithm.  The SVD of B has the form

       B = Q * S * P**T

    where S is the diagonal matrix of singular values, Q is an orthogonal
    matrix of left singular vectors, and P is an orthogonal matrix of
    right singular vectors.  If left singular vectors are requested, this
    subroutine actually returns U*Q instead of Q, and, if right singular
    vectors are requested, this subroutine returns P**T*VT instead of
    P**T, for given real input matrices U and VT.  When U and VT are the
    orthogonal matrices that reduce a general matrix A to bidiagonal
    form:  A = U*B*VT, as computed by SGEBRD, then

       A = (U*Q) * S * (P**T*VT)

    is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
    for a given real input matrix C.

    See "Computing  Small Singular Values of Bidiagonal Matrices With
    Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
    LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
    no. 5, pp. 873-912, Sept 1990) and
    "Accurate singular values and differential qd algorithms," by
    B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
    Department, University of California at Berkeley, July 1992
    for a detailed description of the algorithm.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  B is upper bidiagonal;
            = 'L':  B is lower bidiagonal.

    N       (input) INTEGER
            The order of the matrix B.  N >= 0.

    NCVT    (input) INTEGER
            The number of columns of the matrix VT. NCVT >= 0.

    NRU     (input) INTEGER
            The number of rows of the matrix U. NRU >= 0.

    NCC     (input) INTEGER
            The number of columns of the matrix C. NCC >= 0.

    D       (input/output) REAL array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B in decreasing
            order.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the N-1 offdiagonal elements of the bidiagonal
            matrix B.
            On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
            will contain the diagonal and superdiagonal elements of a
            bidiagonal matrix orthogonally equivalent to the one given
            as input.
"""
    # 输入/输出参数，REAL 类型的数组，维度为 (LDVT, NCVT)
    # 在输入时，是一个 N 行 NCVT 列的矩阵 VT。
    # 在输出时，被 P 的转置乘积 P**T * VT 覆盖。
    # 如果 NCVT = 0，则不会被引用。
    VT      (input/output) REAL array, dimension (LDVT, NCVT)

    # 数组 VT 的主维度，即行数。
    # LDVT 必须满足 LDVT >= max(1,N)，如果 NCVT > 0；
    # 如果 NCVT = 0，则要求 LDVT >= 1。
    LDVT    (input) INTEGER

    # 输入/输出参数，REAL 类型的数组，维度为 (LDU, N)
    # 在输入时，是一个 NRU 行 N 列的矩阵 U。
    # 在输出时，被 U 的乘积 U * Q 覆盖。
    # 如果 NRU = 0，则不会被引用。
    U       (input/output) REAL array, dimension (LDU, N)

    # 数组 U 的主维度，即行数。
    # LDVT 必须满足 LDVT >= max(1,NRU)。
    LDU     (input) INTEGER

    # 输入/输出参数，REAL 类型的数组，维度为 (LDC, NCC)
    # 在输入时，是一个 N 行 NCC 列的矩阵 C。
    # 在输出时，被 Q 的转置乘积 Q**T * C 覆盖。
    # 如果 NCC = 0，则不会被引用。
    C       (input/output) REAL array, dimension (LDC, NCC)

    # 数组 C 的主维度，即行数。
    # LDC 必须满足 LDC >= max(1,N)，如果 NCC > 0；
    # 如果 NCC = 0，则要求 LDC >= 1。
    LDC     (input) INTEGER

    # 工作空间数组，REAL 类型，维度为 (4*N)
    WORK    (workspace) REAL array, dimension (4*N)

    # 输出参数，INTEGER 类型
    # 返回的信息：
    # = 0：成功退出
    # < 0：如果 INFO = -i，表示第 i 个参数有非法值
    # > 0：
    #    如果 NCVT = NRU = NCC = 0，
    #       = 1，E 中有正值标记的分裂
    #       = 2，Z 的当前块在内部 while 循环中没有被对角化超过 30*N 次迭代
    #       = 3，外部 while 循环的终止条件未满足（程序创建了超过 N 个未减少的块）
    #    如果 NCVT = NRU = NCC = 0 以外的情况，
    #       算法没有收敛；D 和 E 包含与输入矩阵 B 正交相似的双对角矩阵的元素；
    #       如果 INFO = i，则 E 中的 i 个元素未收敛为零。
    INFO    (output) INTEGER

    # 内部参数
    # REAL 类型，默认值为 max(10,min(100,EPS**(-1/8)))
    # TOLMUL 控制 QR 循环的收敛准则。
    # 如果它是正数，则 TOLMUL*EPS 是计算奇异值的期望相对精度。
    # 如果它是负数，则 abs(TOLMUL*EPS*sigma_max) 是计算奇异值的期望绝对精度
    # （对应于最大奇异值的相对精度 abs(TOLMUL*EPS)）。
    # abs(TOLMUL) 应该在 1 和 1/EPS 之间，并最好在 10（用于快速收敛）和 .1/EPS
    # 之间（用于结果的一些准确性）。
    # 默认是在每个计算的奇异值中失去最小的一八或两个可用的十进制数字（较小的那个）。
    TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))
    # 定义整数 MAXITR，默认值为 6
    # MAXITR 控制算法通过其内部循环的最大次数。如果通过内部循环的次数超过 MAXITR*N**2，
    # 算法将停止（因此无法收敛）。
    MAXITR  INTEGER, default = 6
            MAXITR controls the maximum number of passes of the
            algorithm through its inner loop. The algorithms stops
            (and so fails to converge) if the number of passes
            through the inner loop exceeds MAXITR*N**2.

    =====================================================================

    # 测试输入参数的有效性

       Test the input parameters.
    /* Parameter adjustments */
    --d__;              // 调整数组 d__ 的指针，使其指向正确的位置
    --e;                // 调整数组 e 的指针，使其指向正确的位置
    vt_dim1 = *ldvt;    // 设置 vt_dim1 为 ldvt，用于矩阵 vt 的维度计算
    vt_offset = 1 + vt_dim1;  // 计算 vt 的偏移量
    vt -= vt_offset;    // 调整 vt 的指针，使其指向正确的位置
    u_dim1 = *ldu;      // 设置 u_dim1 为 ldu，用于矩阵 u 的维度计算
    u_offset = 1 + u_dim1;    // 计算 u 的偏移量
    u -= u_offset;      // 调整 u 的指针，使其指向正确的位置
    c_dim1 = *ldc;      // 设置 c_dim1 为 ldc，用于矩阵 c 的维度计算
    c_offset = 1 + c_dim1;    // 计算 c 的偏移量
    c__ -= c_offset;    // 调整 c 的指针，使其指向正确的位置
    --work;             // 调整数组 work 的指针，使其指向正确的位置

    /* Function Body */
    *info = 0;          // 将 info 初始化为 0
    lower = lsame_(uplo, "L");  // 检查 uplo 是否为 "L"，确定 lower 是否为真
    if (! lsame_(uplo, "U") && ! lower) {  // 检查 uplo 是否为 "U" 或 "L"，若不是则设置错误码
        *info = -1;
    } else if (*n < 0) {    // 检查 n 是否小于 0，若是则设置错误码
        *info = -2;
    } else if (*ncvt < 0) { // 检查 ncvt 是否小于 0，若是则设置错误码
        *info = -3;
    } else if (*nru < 0) {  // 检查 nru 是否小于 0，若是则设置错误码
        *info = -4;
    } else if (*ncc < 0) {  // 检查 ncc 是否小于 0，若是则设置错误码
        *info = -5;
    } else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < max(1,*n)) {  // 检查 ldvt 是否符合要求，若不是则设置错误码
        *info = -9;
    } else if (*ldu < max(1,*nru)) {  // 检查 ldu 是否符合要求，若不是则设置错误码
        *info = -11;
    } else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < max(1,*n)) {  // 检查 ldc 是否符合要求，若不是则设置错误码
        *info = -13;
    }
    if (*info != 0) {   // 若存在错误码，则调用错误处理程序并返回
        i__1 = -(*info);
        xerbla_("SBDSQR", &i__1);
        return 0;
    }
    if (*n == 0) {      // 若 n 为 0，直接返回
        return 0;
    }
    if (*n == 1) {      // 若 n 为 1，跳转到标签 L160 处
        goto L160;
    }

/*     ROTATE is true if any singular vectors desired, false otherwise */

    rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;  // 判断是否需要计算奇异向量

/*     If no singular vectors desired, use qd algorithm */

    if (! rotate) {     // 若不需要计算奇异向量，则使用 qd 算法计算奇异值
        slasq1_(n, &d__[1], &e[1], &work[1], info);
        return 0;
    }

    nm1 = *n - 1;       // 计算 n-1
    nm12 = nm1 + nm1;   // 计算 2*(n-1)
    nm13 = nm12 + nm1;  // 计算 3*(n-1)
    idir = 0;           // 初始化方向指示器为 0

/*     Get machine constants */

    eps = slamch_("Epsilon");   // 获取机器精度 epsilon
    unfl = slamch_("Safe minimum");  // 获取最小正数值

/*
       If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left
*/

    if (lower) {    // 若矩阵为下三角双对角，则通过左侧的 Givens 旋转将其变换为上三角双对角
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {
            slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);    // 计算 Givens 旋转参数
            d__[i__] = r__;     // 更新 d
            e[i__] = sn * d__[i__ + 1];  // 更新 e
            d__[i__ + 1] = cs * d__[i__ + 1];   // 更新 d
            work[i__] = cs;     // 存储旋转角度参数
            work[nm1 + i__] = sn;   // 存储旋转角度参数
/* L10: */
        }

/*        Update singular vectors if desired */

        if (*nru > 0) {     // 若需要更新右奇异向量，则进行更新
            slasr_("R", "V", "F", nru, n, &work[1], &work[*n], &u[u_offset], ldu);
        }
        if (*ncc > 0) {     // 若需要更新左奇异向量，则进行更新
            slasr_("L", "V", "F", n, ncc, &work[1], &work[*n], &c__[c_offset], ldc);
        }
    }

/*
       Compute singular values to relative accuracy TOL
       (By setting TOL to be negative, algorithm will compute
       singular values to absolute accuracy ABS(TOL)*norm(input matrix))

   Computing MAX
   Computing MIN
*/
    d__1 = (doublereal) eps;
    r__3 = 100.f, r__4 = pow_dd(&d__1, &c_b94);
    r__1 = 10.f, r__2 = dmin(r__3,r__4);
    tolmul = dmax(r__1,r__2);    // 计算精度参数 tolmul
    tol = tolmul * eps;         // 计算奇异值计算的容许误差

/*     Compute approximate maximum, minimum singular values */

    smax = 0.f;     // 初始化最大奇异值为 0
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
        r__2 = smax, r__3 = (r__1 = d__[i__], dabs(r__1));
        smax = dmax(r__2,r__3);  // 计算最大奇异值
/* L20: */
    }
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
        r__2 = smax, r__3 = (r__1 = e[i__], dabs(r__1));
        smax = dmax(r__2,r__3);  // 计算最大奇异值
/* L30: */
    }
    # 初始化变量 sminl 为浮点数 0.0
    sminl = 0.f;
    # 如果给定的 tol 参数大于或等于 0.0，则执行以下代码块
    if (tol >= 0.f) {
/*        Relative accuracy desired */

/* 初始化最小非零对角元sminoa为第一个对角元的绝对值 */
    sminoa = dabs(d__[1]);
/* 如果第一个对角元为0，则跳转到标签L50 */
    if (sminoa == 0.f) {
        goto L50;
    }
/* 将mu初始化为第一个对角元的绝对值 */
    mu = sminoa;
/* 循环遍历从第二个到最后一个对角元 */
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* 计算mu乘以当前对角元绝对值除以(mu加上前一个副对角元的绝对值) */
        mu = (r__2 = d__[i__], dabs(r__2)) * (mu / (mu + (r__1 = e[i__ -
            1], dabs(r__1))));
/* 更新最小非零对角元sminoa */
        sminoa = dmin(sminoa,mu);
/* 如果最小非零对角元变为0，则跳转到标签L50 */
        if (sminoa == 0.f) {
            goto L50;
        }
/* L40: */
    }
/* 将sminoa除以n的平方根，作为阈值的一个估计 */
L50:
    sminoa /= sqrt((real) (*n));
/* 计算阈值，为相对误差和绝对误差的较大值 */
/* Computing MAX */
    r__1 = tol * sminoa, r__2 = *n * 6 * *n * unfl;
    thresh = dmax(r__1,r__2);
    } else {

/*
          Absolute accuracy desired

   Computing MAX
*/
/* 绝对精度的情况下，计算阈值 */
    r__1 = dabs(tol) * smax, r__2 = *n * 6 * *n * unfl;
    thresh = dmax(r__1,r__2);
    }

/*
       Prepare for main iteration loop for the singular values
       (MAXIT is the maximum number of passes through the inner
       loop permitted before nonconvergence signalled.)
*/

/* 将最大迭代次数设置为6*n*n */
    maxit = *n * 6 * *n;
/* 初始化迭代次数为0 */
    iter = 0;
/* 初始化oldll和oldm为-1 */
    oldll = -1;
    oldm = -1;

/*     M points to last element of unconverged part of matrix */

/* 将m指向未收敛部分的最后一个元素 */
    m = *n;

/*     Begin main iteration loop */

L60:

/*     Check for convergence or exceeding iteration count */

/* 如果m小于等于1，则跳转到标签L160 */
    if (m <= 1) {
    goto L160;
    }
/* 如果迭代次数超过最大迭代次数，则跳转到标签L200 */
    if (iter > maxit) {
    goto L200;
    }

/*     Find diagonal block of matrix to work on */

/* 根据tol的值选择工作的对角块 */
    if (tol < 0.f && (r__1 = d__[m], dabs(r__1)) <= thresh) {
    d__[m] = 0.f;
    }
/* 计算当前对角块的最大和最小对角元的绝对值 */
    smax = (r__1 = d__[m], dabs(r__1));
    smin = smax;
    i__1 = m - 1;
    for (lll = 1; lll <= i__1; ++lll) {
/* 将ll设置为当前处理的对角块的第lll个副对角元 */
    ll = m - lll;
/* 计算当前对角元和副对角元的绝对值 */
    abss = (r__1 = d__[ll], dabs(r__1));
    abse = (r__1 = e[ll], dabs(r__1));
/* 如果tol小于0且当前对角元的绝对值小于阈值，则将其置为0 */
    if (tol < 0.f && abss <= thresh) {
        d__[ll] = 0.f;
    }
/* 如果副对角元的绝对值小于等于阈值，则跳转到标签L80 */
    if (abse <= thresh) {
        goto L80;
    }
/* 更新当前对角块的最小对角元和最大对角元的估计 */
    smin = dmin(smin,abss);
/* Computing MAX */
    r__1 = max(smax,abss);
    smax = dmax(r__1,abse);
/* L70: */
    }
/* 将ll设置为0，标记未分裂的情况 */
    ll = 0;
/* 跳转到标签L90 */
    goto L90;
L80:
/* 将副对角元置为0，因为矩阵分裂 */
    e[ll] = 0.f;

/*     Matrix splits since E(LL) = 0 */

/* 如果ll等于m-1，则表示底部奇异值收敛，返回到循环顶部 */
    if (ll == m - 1) {

/*        Convergence of bottom singular value, return to top of loop */

    --m;
    goto L60;
    }
/* 跳转到标签L90 */
L90:
/* 将ll增加1 */
    ++ll;

/*     E(LL) through E(M-1) are nonzero, E(LL-1) is zero */

/* 如果ll等于m-1，则表示处理2x2块 */
    if (ll == m - 1) {

/*        2 by 2 block, handle separately */

/* 调用slasv2处理2x2块的奇异值分解 */
    slasv2_(&d__[m - 1], &e[m - 1], &d__[m], &sigmn, &sigmx, &sinr, &cosr,
         &sinl, &cosl);
/* 更新对角元和副对角元的值 */
    d__[m - 1] = sigmx;
    e[m - 1] = 0.f;
    d__[m] = sigmn;

/*        Compute singular vectors, if desired */

/* 如果需要计算右奇异向量，则进行旋转 */
    if (*ncvt > 0) {
        srot_(ncvt, &vt[m - 1 + vt_dim1], ldvt, &vt[m + vt_dim1], ldvt, &
            cosr, &sinr);
    }
/* 如果需要计算左奇异向量，则进行旋转 */
    if (*nru > 0) {
        srot_(nru, &u[(m - 1) * u_dim1 + 1], &c__1, &u[m * u_dim1 + 1], &
            c__1, &cosl, &sinl);
    }
/* 如果需要计算C矩阵，则进行旋转 */
    if (*ncc > 0) {
        srot_(ncc, &c__[m - 1 + c_dim1], ldc, &c__[m + c_dim1], ldc, &
            cosl, &sinl);
    }
/* 更新m的值 */
    m += -2;
/* 跳转到标签L60 */
    goto L60;
    }

/*
       If working on new submatrix, choose shift direction
       (from larger end diagonal element towards smaller)
*/

/* 如果当前处理的子矩阵变更，则选择移位方向 */
    if (ll > oldm || m < oldll) {
    # 检查数组 d__ 中索引 ll 处的值与索引 m 处的值的绝对值大小关系
    if ((r__1 = d__[ll], dabs(r__1)) >= (r__2 = d__[m], dabs(r__2))) {
/*           Chase bulge from top (big end) to bottom (small end) */
/* 从顶部（大端）向底部（小端）追逐鼓包 */

        idir = 1;
    } else {

/*           Chase bulge from bottom (big end) to top (small end) */
/* 从底部（大端）向顶部（小端）追逐鼓包 */

        idir = 2;
    }
    }

/*     Apply convergence tests */
/* 应用收敛性测试 */

    if (idir == 1) {

/*
          Run convergence test in forward direction
          First apply standard test to bottom of matrix
*/
/* 在正向方向上运行收敛性测试
   首先对矩阵底部应用标准测试 */

    if ((r__2 = e[m - 1], dabs(r__2)) <= dabs(tol) * (r__1 = d__[m], dabs(
        r__1)) || tol < 0.f && (r__3 = e[m - 1], dabs(r__3)) <=
        thresh) {
        e[m - 1] = 0.f;
        goto L60;
    }

    if (tol >= 0.f) {

/*
             If relative accuracy desired,
             apply convergence criterion forward
*/
/* 如果需要相对精度，
   则向前应用收敛标准 */

        mu = (r__1 = d__[ll], dabs(r__1));
        sminl = mu;
        i__1 = m - 1;
        for (lll = ll; lll <= i__1; ++lll) {
        if ((r__1 = e[lll], dabs(r__1)) <= tol * mu) {
            e[lll] = 0.f;
            goto L60;
        }
        mu = (r__2 = d__[lll + 1], dabs(r__2)) * (mu / (mu + (r__1 =
            e[lll], dabs(r__1))));
        sminl = dmin(sminl,mu);
/* L100: */
        }
    }

    } else {

/*
          Run convergence test in backward direction
          First apply standard test to top of matrix
*/
/* 在反向方向上运行收敛性测试
   首先对矩阵顶部应用标准测试 */

    if ((r__2 = e[ll], dabs(r__2)) <= dabs(tol) * (r__1 = d__[ll], dabs(
        r__1)) || tol < 0.f && (r__3 = e[ll], dabs(r__3)) <= thresh) {
        e[ll] = 0.f;
        goto L60;
    }

    if (tol >= 0.f) {

/*
             If relative accuracy desired,
             apply convergence criterion backward
*/
/* 如果需要相对精度，
   则向后应用收敛标准 */

        mu = (r__1 = d__[m], dabs(r__1));
        sminl = mu;
        i__1 = ll;
        for (lll = m - 1; lll >= i__1; --lll) {
        if ((r__1 = e[lll], dabs(r__1)) <= tol * mu) {
            e[lll] = 0.f;
            goto L60;
        }
        mu = (r__2 = d__[lll], dabs(r__2)) * (mu / (mu + (r__1 = e[
            lll], dabs(r__1))));
        sminl = dmin(sminl,mu);
/* L110: */
        }
    }
    }
    oldll = ll;
    oldm = m;

/*
       Compute shift.  First, test if shifting would ruin relative
       accuracy, and if so set the shift to zero.

   Computing MAX
*/
/* 计算位移。首先，测试位移是否会破坏相对精度，如果会，则将位移设为零。 */

    r__1 = eps, r__2 = tol * .01f;
    if (tol >= 0.f && *n * tol * (sminl / smax) <= dmax(r__1,r__2)) {

/*        Use a zero shift to avoid loss of relative accuracy */
/* 使用零位移以避免相对精度的损失 */

    shift = 0.f;
    } else {

/*        Compute the shift from 2-by-2 block at end of matrix */
/* 从矩阵末尾的 2x2 块计算位移 */

    if (idir == 1) {
        sll = (r__1 = d__[ll], dabs(r__1));
        slas2_(&d__[m - 1], &e[m - 1], &d__[m], &shift, &r__);
    } else {
        sll = (r__1 = d__[m], dabs(r__1));
        slas2_(&d__[ll], &e[ll], &d__[ll + 1], &shift, &r__);
    }

/*        Test if shift negligible, and if so set to zero */

    if (sll > 0.f) {
/* Computing 2nd power */
        r__1 = shift / sll;
        if (r__1 * r__1 < eps) {
        shift = 0.f;
        }
    }
    }

/*     Increment iteration count */
/* 增加迭代计数 */

    iter = iter + m - ll;

/*     If SHIFT = 0, do simplified QR iteration */
/* 如果位移 = 0，则进行简化的 QR 迭代 */
    # 检查变量 shift 是否等于浮点数 0
    if (shift == 0.f) {


    # 检查变量 idir 是否等于整数 1
    if (idir == 1) {
/*
             Chase bulge from top to bottom
             Save cosines and sines for later singular vector updates
*/
cs = 1.f;
oldcs = 1.f;
i__1 = m - 1;
for (i__ = ll; i__ <= i__1; ++i__) {
r__1 = d__[i__] * cs;
slartg_(&r__1, &e[i__], &cs, &sn, &r__);
if (i__ > ll) {
    e[i__ - 1] = oldsn * r__;
}
r__1 = oldcs * r__;
r__2 = d__[i__ + 1] * sn;
slartg_(&r__1, &r__2, &oldcs, &oldsn, &d__[i__]);
work[i__ - ll + 1] = cs;
work[i__ - ll + 1 + nm1] = sn;
work[i__ - ll + 1 + nm12] = oldcs;
work[i__ - ll + 1 + nm13] = oldsn;
/* L120: */
}
h__ = d__[m] * cs;
d__[m] = h__ * oldcs;
e[m - 1] = h__ * oldsn;

/* Update singular vectors */
if (*ncvt > 0) {
i__1 = m - ll + 1;
slasr_("L", "V", "F", &i__1, ncvt, &work[1], &work[*n], &vt[
    ll + vt_dim1], ldvt);
}
if (*nru > 0) {
i__1 = m - ll + 1;
slasr_("R", "V", "F", nru, &i__1, &work[nm12 + 1], &work[nm13
    + 1], &u[ll * u_dim1 + 1], ldu);
}
if (*ncc > 0) {
i__1 = m - ll + 1;
slasr_("L", "V", "F", &i__1, ncc, &work[nm12 + 1], &work[nm13
    + 1], &c__[ll + c_dim1], ldc);
}

/* Test convergence */
if ((r__1 = e[m - 1], dabs(r__1)) <= thresh) {
e[m - 1] = 0.f;
}

} else {

/*
             Chase bulge from bottom to top
             Save cosines and sines for later singular vector updates
*/
cs = 1.f;
oldcs = 1.f;
i__1 = ll + 1;
for (i__ = m; i__ >= i__1; --i__) {
r__1 = d__[i__] * cs;
slartg_(&r__1, &e[i__ - 1], &cs, &sn, &r__);
if (i__ < m) {
    e[i__] = oldsn * r__;
}
r__1 = oldcs * r__;
r__2 = d__[i__ - 1] * sn;
slartg_(&r__1, &r__2, &oldcs, &oldsn, &d__[i__]);
work[i__ - ll] = cs;
work[i__ - ll + nm1] = -sn;
work[i__ - ll + nm12] = oldcs;
work[i__ - ll + nm13] = -oldsn;
/* L130: */
}
h__ = d__[ll] * cs;
d__[ll] = h__ * oldcs;
e[ll] = h__ * oldsn;

/* Update singular vectors */
if (*ncvt > 0) {
i__1 = m - ll + 1;
slasr_("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[
    nm13 + 1], &vt[ll + vt_dim1], ldvt);
}
if (*nru > 0) {
i__1 = m - ll + 1;
slasr_("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll *
     u_dim1 + 1], ldu);
}
if (*ncc > 0) {
i__1 = m - ll + 1;
slasr_("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c__[
    ll + c_dim1], ldc);
}

/* Test convergence */
if ((r__1 = e[ll], dabs(r__1)) <= thresh) {
e[ll] = 0.f;
}
}

} else {

/* Use nonzero shift */
if (idir == 1) {
/*
   Chase bulge from bottom to top
   Save cosines and sines for later singular vector updates
*/
f = ((r__1 = d__[m], dabs(r__1)) - shift) * (r_sign(&c_b15, &d__[m]) + shift / d__[m]);
g = e[m - 1];
i__1 = ll + 1;
for (i__ = m; i__ >= i__1; --i__) {
    slartg_(&f, &g, &cosr, &sinr, &r__);  // 计算 Givens 变换，获取旋转角度和相关参数
    if (i__ < m) {
        e[i__] = r__;  // 更新 E 数组
    }
    f = cosr * d__[i__] + sinr * e[i__ - 1];  // 更新 F 值
    e[i__ - 1] = cosr * e[i__ - 1] - sinr * d__[i__];  // 更新 E 数组
    g = sinr * d__[i__ - 1];  // 更新 G 值
    d__[i__ - 1] = cosr * d__[i__ - 1];  // 更新 D 数组
    slartg_(&f, &g, &cosl, &sinl, &r__);  // 计算另一组 Givens 变换，获取旋转角度和相关参数
    d__[i__] = r__;  // 更新 D 数组
    f = cosl * e[i__ - 1] + sinl * d__[i__ - 1];  // 更新 F 值
    d__[i__ - 1] = cosl * d__[i__ - 1] - sinl * e[i__ - 1];  // 更新 D 数组
    if (i__ > ll + 1) {
        g = sinl * e[i__ - 2];  // 更新 G 值
        e[i__ - 2] = cosl * e[i__ - 2];  // 更新 E 数组
    }
    work[i__ - ll] = cosr;  // 保存 cosr 到 work 数组
    work[i__ - ll + nm1] = -sinr;  // 保存 -sinr 到 work 数组
    work[i__ - ll + nm12] = cosl;  // 保存 cosl 到 work 数组
    work[i__ - ll + nm13] = -sinl;  // 保存 -sinl 到 work 数组
    /* L150: */
}
e[ll] = f;  // 更新 E 数组
/*           Test convergence */

/* 
   检测收敛性
   如果当前位置的e[ll]小于等于预设的阈值thresh，则将其设为0
*/
if ((r__1 = e[ll], dabs(r__1)) <= thresh) {
    e[ll] = 0.f;
}

/*           Update singular vectors if desired */

/*
   如果需要更新奇异向量：
   - 使用slasr函数更新左奇异向量，将工作区域中的数据应用于vt的指定部分
   - 使用slasr函数更新右奇异向量，将工作区域中的数据应用于u的指定部分
   - 使用slasr函数更新中间矩阵，将工作区域中的数据应用于c的指定部分
*/
if (*ncvt > 0) {
    i__1 = m - ll + 1;
    slasr_("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[
        nm13 + 1], &vt[ll + vt_dim1], ldvt);
}
if (*nru > 0) {
    i__1 = m - ll + 1;
    slasr_("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll *
         u_dim1 + 1], ldu);
}
if (*ncc > 0) {
    i__1 = m - ll + 1;
    slasr_("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c__[
        ll + c_dim1], ldc);
}
}

/*     QR iteration finished, go back and check convergence */

/*
   QR迭代完成，返回并检查收敛性
*/
goto L60;

/*     All singular values converged, so make them positive */

L160:
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
if (d__[i__] < 0.f) {
    d__[i__] = -d__[i__];

/*           Change sign of singular vectors, if desired */

/*
   如果需要，改变奇异向量的符号：
   - 使用sscal函数将奇异向量vt的指定部分乘以常数c_b151
*/
if (*ncvt > 0) {
    sscal_(ncvt, &c_b151, &vt[i__ + vt_dim1], ldvt);
}
}
/* L170: */
}

/*
   Sort the singular values into decreasing order (insertion sort on
   singular values, but only one transposition per singular vector)
*/

/*
   将奇异值按降序排序（插入排序，每个奇异向量只进行一次置换）
*/
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {

/*        Scan for smallest D(I) */

/*
   扫描寻找最小的D(I)
*/
isub = 1;
smin = d__[1];
i__2 = *n + 1 - i__;
for (j = 2; j <= i__2; ++j) {
    if (d__[j] <= smin) {
    isub = j;
    smin = d__[j];
    }
/* L180: */
}
if (isub != *n + 1 - i__) {

/*           Swap singular values and vectors */

/*
   交换奇异值和奇异向量：
   - 交换奇异值d中的对应元素
   - 如果需要，交换奇异向量vt中的对应行
   - 如果需要，交换奇异向量u中的对应列
   - 如果需要，交换奇异向量c中的对应行
*/
d__[isub] = d__[*n + 1 - i__];
d__[*n + 1 - i__] = smin;
if (*ncvt > 0) {
    sswap_(ncvt, &vt[isub + vt_dim1], ldvt, &vt[*n + 1 - i__ +
        vt_dim1], ldvt);
}
if (*nru > 0) {
    sswap_(nru, &u[isub * u_dim1 + 1], &c__1, &u[(*n + 1 - i__) *
        u_dim1 + 1], &c__1);
}
if (*ncc > 0) {
    sswap_(ncc, &c__[isub + c_dim1], ldc, &c__[*n + 1 - i__ +
        c_dim1], ldc);
}
}
/* L190: */
}
goto L220;

/*     Maximum number of iterations exceeded, failure to converge */

/*
   超过最大迭代次数，未能收敛
*/
L200:
*info = 0;
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
if (e[i__] != 0.f) {
    ++(*info);
}
/* L210: */
}
L220:
return 0;

/*     End of SBDSQR */

} /* sbdsqr_ */

/* Subroutine */ int sgebak_(char *job, char *side, integer *n, integer *ilo,
integer *ihi, real *scale, integer *m, real *v, integer *ldv, integer
*info)
{
/* System generated locals */
integer v_dim1, v_offset, i__1;

/* Local variables */
static integer i__, k;
static real s;
static integer ii;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
static logical leftv;
    # 外部声明一个名为 sswap_ 的子程序，接受整数、实数数组和整数作为参数
    # 该子程序用于交换两个实数数组的元素
    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *,
        integer *);

    # 外部声明一个名为 xerbla_ 的子程序，接受字符指针和整数作为参数
    # 该子程序用于处理错误信息
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 静态变量声明，类型为逻辑型，用于指示是否使用右特征向量
    static logical rightv;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGEBAK forms the right or left eigenvectors of a real general matrix
    by backward transformation on the computed eigenvectors of the
    balanced matrix output by SGEBAL.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to SGEBAL.

    SIDE    (input) CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.

    N       (input) INTEGER
            The number of rows of the matrix V.  N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            The integers ILO and IHI determined by SGEBAL.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    SCALE   (input) REAL array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by SGEBAL.

    M       (input) INTEGER
            The number of columns of the matrix V.  M >= 0.

    V       (input/output) REAL array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by SHSEIN or STREVC.
            On exit, V is overwritten by the transformed eigenvectors.

    LDV     (input) INTEGER
            The leading dimension of the array V. LDV >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    =====================================================================


       Decode and Test the input parameters
*/
    
    /* Parameter adjustments */
    --scale;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;

    /* Function Body */
    // Determine if we are transforming right eigenvectors
    rightv = lsame_(side, "R");
    // Determine if we are transforming left eigenvectors
    leftv = lsame_(side, "L");

    // Initialize INFO to 0
    *info = 0;
    // Check for valid JOB parameter
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;
    } else if (! rightv && ! leftv) { // Check for valid SIDE parameter
        *info = -2;
    } else if (*n < 0) { // Check for valid N parameter
        *info = -3;
    } else if (*ilo < 1 || *ilo > max(1,*n)) { // Check for valid ILO parameter
        *info = -4;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) { // Check for valid IHI parameter
        *info = -5;
    } else if (*m < 0) { // Check for valid M parameter
        *info = -7;
    } else if (*ldv < max(1,*n)) { // Check for valid LDV parameter
        *info = -9;
    }
    // If INFO is not 0, call error handler and return
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SGEBAK", &i__1);
        return 0;
    }

    /* Quick return if possible */
    // If N is 0, return immediately
    if (*n == 0) {
        return 0;
    }
    // If M is 0, no transformations are needed, return immediately
    if (*m == 0) {
    return 0;
    }


# 如果前面的条件不满足，则直接返回 0，结束函数执行



    if (lsame_(job, "N")) {
    return 0;
    }


# 如果 job 参数为 "N"，则返回 0，结束函数执行



    if (*ilo == *ihi) {
    goto L30;
    }


# 检查 ilo 和 ihi 参数是否相等，如果相等则跳转到标签 L30 处继续执行
/*     Backward balance */

    // 如果 job 是 "S" 或 "B"，执行以下代码块
    if (lsame_(job, "S") || lsame_(job, "B")) {

    // 如果 rightv 为真，执行以下代码块
        if (rightv) {
            // 循环遍历从 *ilo 到 *ihi 的索引 i__
            i__1 = *ihi;
            for (i__ = *ilo; i__ <= i__1; ++i__) {
                // 从 scale 数组中获取比例因子 s
                s = scale[i__];
                // 对 v[i__][1] 开始的列应用比例因子 s
                sscal_(m, &s, &v[i__ + v_dim1], ldv);
    /* L10: */
            }
        }

    // 如果 leftv 为真，执行以下代码块
        if (leftv) {
            // 循环遍历从 *ilo 到 *ihi 的索引 i__
            i__1 = *ihi;
            for (i__ = *ilo; i__ <= i__1; ++i__) {
                // 计算与 scale[i__] 的倒数 s
                s = 1.f / scale[i__];
                // 对 v[i__][1] 开始的列应用比例因子 s
                sscal_(m, &s, &v[i__ + v_dim1], ldv);
    /* L20: */
            }
        }

    }

/*
       Backward permutation

       For  I = ILO-1 step -1 until 1,
                IHI+1 step 1 until N do --
*/

L30:
    // 如果 job 是 "P" 或 "B"，执行以下代码块
    if (lsame_(job, "P") || lsame_(job, "B")) {
        // 如果 rightv 为真，执行以下代码块
        if (rightv) {
            // 循环遍历从 1 到 *n 的索引 ii
            i__1 = *n;
            for (ii = 1; ii <= i__1; ++ii) {
                // 将 ii 赋值给 i__
                i__ = ii;
                // 如果 i__ 在 *ilo 和 *ihi 之间，跳到标签 L40
                if (i__ >= *ilo && i__ <= *ihi) {
                    goto L40;
                }
                // 如果 i__ 小于 *ilo，将 *ilo - ii 赋值给 i__
                if (i__ < *ilo) {
                    i__ = *ilo - ii;
                }
                // 从 scale 数组中获取索引 i__ 处的值赋给 k
                k = scale[i__];
                // 如果 k 等于 i__，跳到标签 L40
                if (k == i__) {
                    goto L40;
                }
                // 交换 v[i__][1] 开始的列与 v[k][1] 开始的列
                sswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L40:
                ;
            }
        }

        // 如果 leftv 为真，执行以下代码块
        if (leftv) {
            // 循环遍历从 1 到 *n 的索引 ii
            i__1 = *n;
            for (ii = 1; ii <= i__1; ++ii) {
                // 将 ii 赋值给 i__
                i__ = ii;
                // 如果 i__ 在 *ilo 和 *ihi 之间，跳到标签 L50
                if (i__ >= *ilo && i__ <= *ihi) {
                    goto L50;
                }
                // 如果 i__ 小于 *ilo，将 *ilo - ii 赋值给 i__
                if (i__ < *ilo) {
                    i__ = *ilo - ii;
                }
                // 从 scale 数组中获取索引 i__ 处的值赋给 k
                k = scale[i__];
                // 如果 k 等于 i__，跳到标签 L50
                if (k == i__) {
                    goto L50;
                }
                // 交换 v[i__][1] 开始的列与 v[k][1] 开始的列
                sswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L50:
                ;
            }
        }
    }

    // 返回值 0，结束 SGEBAL 子程序
    return 0;

/*     End of SGEBAK */

} /* sgebak_ */

/* Subroutine */ int sgebal_(char *job, integer *n, real *a, integer *lda,
    integer *ilo, integer *ihi, real *scale, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    real r__1, r__2;

    /* Local variables */
    static real c__, f, g;
    static integer i__, j, k, l, m;
    static real r__, s, ca, ra;
    static integer ica, ira, iexc;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        sswap_(integer *, real *, integer *, real *, integer *);
    static real sfmin1, sfmin2, sfmax1, sfmax2;
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer isamax_(integer *, real *, integer *);
    extern logical sisnan_(real *);
    static logical noconv;


/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SGEBAL balances a general real matrix A.  This involves, first,
    permuting A by a similarity transformation to isolate eigenvalues
    in the first 1 to ILO-1 and last IHI+1 to N elements on the
    diagonal; and second, applying a diagonal similarity transformation
    to rows and columns ILO to IHI to make the rows and columns as
    close in norm as possible.  Both steps are optional.
    # 对输入参数进行测试
    Balancing may reduce the 1-norm of the matrix, and improve the
    accuracy of the computed eigenvalues and/or eigenvectors.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    ILO     (output) INTEGER
    IHI     (output) INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.

    SCALE   (output) REAL array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The permutations consist of row and column interchanges which put
    the matrix in the form

               ( T1   X   Y  )
       P A P = (  0   B   Z  )
               (  0   0   T2 )

    where T1 and T2 are upper triangular matrices whose eigenvalues lie
    along the diagonal.  The column indices ILO and IHI mark the starting
    and ending columns of the submatrix B. Balancing consists of applying
    a diagonal similarity transformation inv(D) * B * D to make the
    1-norms of each row of B and its corresponding column nearly equal.
    The output matrix is

       ( T1     X*D          Y    )
       (  0  inv(D)*B*D  inv(D)*Z ).
       (  0      0           T2   )

    Information about the permutations P and the diagonal matrix D is
    returned in the vector SCALE.

    This subroutine is based on the EISPACK routine BALANC.

    Modified by Tzu-Yi Chen, Computer Science Division, University of
      California at Berkeley, USA

    =====================================================================


       Test the input parameters
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --scale;

    /* Function Body */
    *info = 0;
    // 检查参数 job 是否合法，job 参数表示平衡计算的模式
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;
    } else if (*n < 0) {
        // 检查 n 是否为负数
        *info = -2;
    } else if (*lda < max(1,*n)) {
        // 检查 lda 是否小于等于 max(1, n)，其中 max 是取最大值函数
        *info = -4;
    }
    // 如果有错误信息，调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SGEBAL", &i__1);
        return 0;
    }

    k = 1;
    l = *n;

    // 如果 n 为零，直接跳转到标签 L210 处
    if (*n == 0) {
        goto L210;
    }

    // 如果 job 为 "N"，初始化 scale 数组为 1.0
    if (lsame_(job, "N")) {
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scale[i__] = 1.f;
            // L10 标签用于循环结束
/* L10: */
        }
        // 直接跳转到标签 L210
        goto L210;
    }

    // 如果 job 为 "S"，直接跳转到标签 L120
    if (lsame_(job, "S")) {
        goto L120;
    }

/*     Permutation to isolate eigenvalues if possible */

    // 跳转到标签 L50
    goto L50;

/*     Row and column exchange. */

L20:
    // 将 scale 数组中的 m 元素设为 j
    scale[m] = (real) j;
    // 如果 j 等于 m，直接跳转到标签 L30
    if (j == m) {
        goto L30;
    }

    // 交换 a 矩阵中 j 行和 m 行的数据
    sswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    // 交换 a 矩阵中 j 列和 m 列的数据
    i__1 = *n - k + 1;
    sswap_(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

L30:
    // 根据 iexc 的值执行不同的操作
    switch (iexc) {
    case 1:  goto L40;
    case 2:  goto L80;
    }

/*     Search for rows isolating an eigenvalue and push them down. */

L40:
    // 如果 l 为 1，直接跳转到标签 L210
    if (l == 1) {
        goto L210;
    }
    // l 减一，向下推动行
    --l;

L50:
    // 寻找隔离特征值的行，并将它们推向下方
    for (j = l; j >= 1; --j) {

        i__1 = l;
        for (i__ = 1; i__ <= i__1; ++i__) {
            // 如果 i 等于 j，直接跳到标签 L60
            if (i__ == j) {
                goto L60;
            }
            // 如果 a 矩阵中 j 行 i 列的元素不为零，跳转到标签 L70
            if (a[j + i__ * a_dim1] != 0.f) {
                goto L70;
            }
L60:
            // 空语句，标记 L60 处
            ;
        }

        // 将 m 设为 l，设置 iexc 为 1，并跳转到标签 L20
        m = l;
        iexc = 1;
        goto L20;
L70:
        // 空语句，标记 L70 处
        ;
    }

    // 跳转到标签 L90
    goto L90;

/*     Search for columns isolating an eigenvalue and push them left. */

L80:
    // k 增加 1
    ++k;

L90:
    // 将 scale 数组中 k 到 l 范围内的元素设为 1.0
    i__1 = l;
    for (j = k; j <= i__1; ++j) {
        scale[j] = 1.f;
/* L130: */
    }

    // 如果 job 为 "P"，直接跳转到标签 L210
    if (lsame_(job, "P")) {
        goto L210;
    }

/*
       Balance the submatrix in rows K to L.

       Iterative loop for norm reduction
*/

    // 计算 sfmin1、sfmax1、sfmin2、sfmax2 的值
    sfmin1 = slamch_("S") / slamch_("P");
    sfmax1 = 1.f / sfmin1;
    sfmin2 = sfmin1 * 2.f;
    sfmax2 = 1.f / sfmin2;
L140:
    // 将 noconv 设为 FALSE_
    noconv = FALSE_;

    // 对行 K 到 L 的子矩阵进行归一化迭代减小范数
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        c__ = 0.f;
        r__ = 0.f;

        i__2 = l;
        for (j = k; j <= i__2; ++j) {
            // 如果 j 等于 i，跳到标签 L150
            if (j == i__) {
                goto L150;
            }
            // 计算 c__ 和 r__ 的值
            c__ += (r__1 = a[j + i__ * a_dim1], dabs(r__1));
            r__ += (r__1 = a[i__ + j * a_dim1], dabs(r__1));
L150:
            // 空语句，标记 L150 处
            ;
        }
        // 找到行 i__ 中绝对值最大的元素的索引
        ica = isamax_(&l, &a[i__ * a_dim1 + 1], &c__1);
        ca = (r__1 = a[ica + i__ * a_dim1], dabs(r__1));
        // 找到列 i__ 中绝对值最大的元素的索引
        i__2 = *n - k + 1;
        ira = isamax_(&i__2, &a[i__ + k * a_dim1], lda);
        ra = (r__1 = a[i__ + (ira + k - 1) * a_dim1], dabs(r__1));
/*        Guard against zero C or R due to underflow. */

if (c__ == 0.f || r__ == 0.f) {
    goto L200;
}
g = r__ / 2.f;
f = 1.f;
s = c__ + r__;
L160:
/* Computing MAX */
r__1 = max(f,c__);
/* Computing MIN */
r__2 = min(r__,g);
if (c__ >= g || dmax(r__1,ca) >= sfmax2 || dmin(r__2,ra) <= sfmin2) {
    goto L170;
}
f *= 2.f;
c__ *= 2.f;
ca *= 2.f;
r__ /= 2.f;
g /= 2.f;
ra /= 2.f;
goto L160;

L170:
g = c__ / 2.f;
L180:
/* Computing MIN */
r__1 = min(f,c__), r__1 = min(r__1,g);
if (g < r__ || dmax(r__,ra) >= sfmax2 || dmin(r__1,ca) <= sfmin2) {
    goto L190;
}
r__1 = c__ + f + ca + r__ + g + ra;
if (sisnan_(&r__1)) {

/*           Exit if NaN to avoid infinite loop */

    *info = -3;
    i__2 = -(*info);
    xerbla_("SGEBAL", &i__2);
    return 0;
}
f /= 2.f;
c__ /= 2.f;
g /= 2.f;
ca /= 2.f;
r__ *= 2.f;
ra *= 2.f;
goto L180;

/*        Now balance. */

L190:
if (c__ + r__ >= s * .95f) {
    goto L200;
}
if (f < 1.f && scale[i__] < 1.f) {
    if (f * scale[i__] <= sfmin1) {
    goto L200;
    }
}
if (f > 1.f && scale[i__] > 1.f) {
    if (scale[i__] >= sfmax1 / f) {
    goto L200;
    }
}
g = 1.f / f;
scale[i__] *= f;
noconv = TRUE_;

i__2 = *n - k + 1;
sscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
sscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
;
}

if (noconv) {
goto L140;
}

L210:
*ilo = k;
*ihi = l;

return 0;

/*     End of SGEBAL */

} /* sgebal_ */

/* Subroutine */ int sgebd2_(integer *m, integer *n, real *a, integer *lda,
real *d__, real *e, real *tauq, real *taup, real *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
static integer i__;
extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
    integer *, real *, real *, integer *, real *), xerbla_(
    char *, integer *), slarfg_(integer *, real *, real *,
    integer *, real *);


注释：


/*        Guard against zero C or R due to underflow. */

// 检查 c__ 或 r__ 是否为零，避免下溢
if (c__ == 0.f || r__ == 0.f) {
    // 如果 c__ 或 r__ 为零，跳转到 L200 标签处
    goto L200;
}
// 初始化 g 为 r__ 的一半，f 为 1，s 为 c__ + r__
g = r__ / 2.f;
f = 1.f;
s = c__ + r__;

L160:
/* Computing MAX */
// 计算 f 和 c__ 的最大值
r__1 = max(f,c__);
/* Computing MIN */
// 计算 r__ 和 g 的最小值
r__2 = min(r__,g);
// 如果 c__ >= g 或者 max(f, ca) >= sfmax2 或者 min(r__, ra) <= sfmin2，则跳转到 L170 标签处
if (c__ >= g || dmax(r__1,ca) >= sfmax2 || dmin(r__2,ra) <= sfmin2) {
    goto L170;
}
// 将 f、c__、ca 各乘以 2，将 r__、g、ra 各除以 2
f *= 2.f;
c__ *= 2.f;
ca *= 2.f;
r__ /= 2.f;
g /= 2.f;
ra /= 2.f;
// 再次跳转到 L160 标签处
goto L160;

L170:
// 将 g 设置为 c__ 的一半
g = c__ / 2.f;

L180:
/* Computing MIN */
// 计算 f、c__ 和 g 的最小值
r__1 = min(f,c__), r__1 = min(r__1,g);
// 如果 g < r__ 或者 max(r__, ra) >= sfmax2 或者 min(r__1, ca) <= sfmin2，则跳转到 L190 标签处
if (g < r__ || dmax(r__,ra) >= sfmax2 || dmin(r__1,ca) <= sfmin2) {
    goto L190;
}
// 计算 c__ + f + ca + r__ + g + ra 的值
r__1 = c__ + f + ca + r__ + g + ra;
// 如果计算结果为 NaN，则执行相应操作避免无限循环
if (sisnan_(&r__1)) {
    *info = -3;
    i__2 = -(*info);
    xerbla_("SGEBAL", &i__2);
    return 0;
}
// 将 f、c__、g 各除以 2，将 ca、r__、ra 各乘以 2
f /= 2.f;
c__ /= 2.f;
g /= 2.f;
ca /= 2.f;
r__ *= 2.f;
ra *= 2.f;
// 再次跳转到 L180 标签处
goto L180;

/*        Now balance. */

L190:
// 如果 c__ + r__ >= s * .95f，则跳转到 L200 标签处
if (c__ + r__ >= s * .95f) {
    goto L200;
}
// 如果 f < 1 且 scale[i__] < 1，则检查是否 f * scale[i__] <= sfmin1，如果是则跳转到 L200 标签处
if (f < 1.f && scale[i__] < 1.f) {
    if (f * scale[i__] <= sfmin1) {
        goto L200;
    }
}
// 如果 f > 1 且 scale[i__] > 1，则检查是否 scale[i__] >= sfmax1 / f，如果是则跳转到 L200 标签处
if (f > 1.f && scale[i__] > 1.f) {
    if (scale[i__] >= sfmax1 / f) {
        goto L200;
    }
}
// 计算 g = 1 / f，并更新 scale[i__]，设置 noconv 为 TRUE_
g = 1.f / f;
scale[i__] *= f;
noconv = TRUE_;

// 执行矩阵操作：对 a[i__+k*a_dim1] 进行缩放操作，使用缩放因子 g
i__2 = *n - k + 1;
sscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
// 执行矩阵操作：对 a[i__*a_dim1+1] 进行缩放操作，使用缩放因子 f
sscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
;
}

// 如果 noconv 为真，则跳转到 L140 标签处
if (noconv) {
    goto L140;
}

L210:
// 将 k 和 l 分别赋值给 *ilo 和 *ihi
*ilo = k;
*ihi = l;

// 返回 0 表示执行成功

/*     End of SGEBAL */

} /* sgebal_ */

/* Subroutine */ int sgebd2_(integer *m, integer *n, real *a, integer *lda,
real *d__, real *e, real *tauq, real *taup, real *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
static integer i__;
// 外部函数声明
extern /* Subroutine */
    ! A       (input/output) REAL array, dimension (LDA,N)
    !         On entry, the m by n general matrix to be reduced.
    !         On exit,
    !         if m >= n, the diagonal and the first superdiagonal are
    !           overwritten with the upper bidiagonal matrix B; the
    !           elements below the diagonal, with the array TAUQ, represent
    !           the orthogonal matrix Q as a product of elementary
    !           reflectors, and the elements above the first superdiagonal,
    !           with the array TAUP, represent the orthogonal matrix P as
    !           a product of elementary reflectors;
    !         if m < n, the diagonal and the first subdiagonal are
    !           overwritten with the lower bidiagonal matrix B; the
    !           elements below the first subdiagonal, with the array TAUQ,
    !           represent the orthogonal matrix Q as a product of
    !           elementary reflectors, and the elements above the diagonal,
    !           with the array TAUP, represent the orthogonal matrix P as
    !           a product of elementary reflectors.
    !         See Further Details.
    
    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(1,M).
    
    ! D       (output) REAL array, dimension (min(M,N))
    !         The diagonal elements of the bidiagonal matrix B:
    !         D(i) = A(i,i).
    
    ! E       (output) REAL array, dimension (min(M,N)-1)
    !         The off-diagonal elements of the bidiagonal matrix B:
    !         if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
    !         if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
    
    ! TAUQ    (output) REAL array dimension (min(M,N))
    !         The scalar factors of the elementary reflectors which
    !         represent the orthogonal matrix Q. See Further Details.
    
    ! TAUP    (output) REAL array, dimension (min(M,N))
    !         The scalar factors of the elementary reflectors which
    !         represent the orthogonal matrix P. See Further Details.
    
    ! WORK    (workspace) REAL array, dimension (max(M,N))
    
    ! INFO    (output) INTEGER
    !         = 0: successful exit.
    !         < 0: if INFO = -i, the i-th argument had an illegal value.
    
    ! Further Details
    ! ===============
    
    ! The matrices Q and P are represented as products of elementary
    ! reflectors:
    
    ! If m >= n,
    
    !    Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
    
    ! Each H(i) and G(i) has the form:
    
    !    H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
    
    ! where tauq and taup are real scalars, and v and u are real vectors;
    ! v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
    ! u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
    ! tauq is stored in TAUQ(i) and taup in TAUP(i).
    
    ! If m < n,
    
    !    Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
    
    ! Each H(i) and G(i) has the form:
    
    !    H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
    
    ! where tauq and taup are real scalars, and v and u are real vectors;
    v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
    u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
    tauq is stored in TAUQ(i) and taup in TAUP(i).


# 将 v 的部分元素置零和一，将余下的元素存储在 A 中的指定位置。
v(1:i) = 0, v(i+1) = 1, 并且 v(i+2:m) 在退出时存储在 A 的 A(i+2:m,i) 中；
u(1:i-1) = 0, u(i) = 1, 并且 u(i+1:n) 在退出时存储在 A 的 A(i,i+1:n) 中；
tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。



    The contents of A on exit are illustrated by the following examples:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
      (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
      (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
      (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
      (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
      (  v1  v2  v3  v4  v5 )

    where d and e denote diagonal and off-diagonal elements of B, vi
    denotes an element of the vector defining H(i), and ui an element of
    the vector defining G(i).


# A 在退出时的内容如下示例所示：

m = 6 和 n = 5 (m > n):                 m = 5 和 n = 6 (m < n):

  (  d   e   u1  u1  u1 )                  (  d   u1  u1  u1  u1  u1 )
  (  v1  d   e   u2  u2 )                  (  e   d   u2  u2  u2  u2 )
  (  v1  v2  d   e   u3 )                  (  v1  e   d   u3  u3  u3 )
  (  v1  v2  v3  d   e  )                  (  v1  v2  e   d   u4  u4 )
  (  v1  v2  v3  v4  d  )                  (  v1  v2  v3  e   d   u5 )
  (  v1  v2  v3  v4  v5 )

其中 d 和 e 表示矩阵 B 的对角线元素和非对角线元素，vi 表示定义 H(i) 的向量元素，ui 表示定义 G(i) 的向量元素。



    =====================================================================


# 分隔线，标记文档的不同部分。
=====================================================================



       Test the input parameters


# 测试输入参数的有效性。
测试输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*m)) {
        *info = -4;
    }
    if (*info < 0) {
        i__1 = -(*info);
        xerbla_("SGEBD2", &i__1);
        return 0;
    }

    if (*m >= *n) {

        /* Reduce to upper bidiagonal form */

        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {

            /* Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

            i__2 = *m - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ *
                a_dim1], &c__1, &tauq[i__]);
            d__[i__] = a[i__ + i__ * a_dim1];
            a[i__ + i__ * a_dim1] = 1.f;

            /* Apply H(i) to A(i:m,i+1:n) from the left */

            if (i__ < *n) {
                i__2 = *m - i__ + 1;
                i__3 = *n - i__;
                slarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &
                    tauq[i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]
                    );
            }
            a[i__ + i__ * a_dim1] = d__[i__];

            if (i__ < *n) {

                /* Generate elementary reflector G(i) to annihilate
                   A(i,i+2:n) */

                i__2 = *n - i__;
                /* Computing MIN */
                i__3 = i__ + 2;
                slarfg_(&i__2, &a[i__ + (i__ + 1) * a_dim1], &a[i__ + min(
                    i__3,*n) * a_dim1], lda, &taup[i__]);
                e[i__] = a[i__ + (i__ + 1) * a_dim1];
                a[i__ + (i__ + 1) * a_dim1] = 1.f;

                /* Apply G(i) to A(i+1:m,i+1:n) from the right */

                i__2 = *m - i__;
                i__3 = *n - i__;
                slarf_("Right", &i__2, &i__3, &a[i__ + (i__ + 1) * a_dim1],
                    lda, &taup[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
                    lda, &work[1]);
                a[i__ + (i__ + 1) * a_dim1] = e[i__];
            } else {
                taup[i__] = 0.f;
            }
        }
    } else {

        /* Reduce to lower bidiagonal form */

        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {

            /* Generate elementary reflector G(i) to annihilate A(i,i+1:n) */

            i__2 = *n - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) *
                a_dim1], lda, &taup[i__]);
            d__[i__] = a[i__ + i__ * a_dim1];
            a[i__ + i__ * a_dim1] = 1.f;

            /* Apply G(i) to A(i+1:m,i:n) from the right */

            if (i__ < *m) {
                i__2 = *m - i__;
                i__3 = *n - i__ + 1;
                slarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &
                    taup[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
            }
            a[i__ + i__ * a_dim1] = d__[i__];

            if (i__ < *m) {

                /* Generate elementary reflector H(i) to annihilate
                   A(i+2:m,i) */

                i__2 = *m - i__;
                /* Computing MIN */
                i__3 = i__ + 2;
                slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) +
                    i__ * a_dim1], &c__1, &tauq[i__]);
                e[i__] = a[i__ + i__ * a_dim1];
                a[i__ + i__ * a_dim1] = 1.f;

                /* Apply H(i) to A(i+1:m,i+1:n) from the left */

                i__2 = *m - i__;
                i__3 = *n - i__;
                slarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1,
                    &tauq[i__], &a[i__ + 1 + (i__ + 1) * a_dim1], lda,
                    &work[1]);
                a[i__ + i__ * a_dim1] = e[i__];
            } else {
                tauq[i__] = 0.f;
            }
        }
    }
/* Computing MIN */
        // 计算下一个索引值
        i__3 = i__ + 2;
        // 对 A 的一列应用 Householder 变换，将其转化为上 Hessenberg 形式
        slarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*m) +
            i__ * a_dim1], &c__1, &tauq[i__]);
        // 保存原始的 a[i+1][i] 到 e[i]，并将 a[i+1][i] 设置为 1
        e[i__] = a[i__ + 1 + i__ * a_dim1];
        a[i__ + 1 + i__ * a_dim1] = 1.f;

/*              Apply H(i) to A(i+1:m,i+1:n) from the left */

        // 计算左乘 Householder 变换 H(i) 到 A 的子矩阵
        i__2 = *m - i__;
        i__3 = *n - i__;
        slarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &
            c__1, &tauq[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
            lda, &work[1]);
        // 恢复 a[i+1][i] 的原始值 e[i]
        a[i__ + 1 + i__ * a_dim1] = e[i__];
        } else {
        // 如果 tauq[i] 为零，设置其值为 0
        tauq[i__] = 0.f;
        }
/* L20: */
    }
    }
    // 返回执行成功的代码
    return 0;

/*     End of SGEBD2 */

} /* sgebd2_ */

/* Subroutine */ int sgebrd_(integer *m, integer *n, real *a, integer *lda,
    real *d__, real *e, real *tauq, real *taup, real *work, integer *
    lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, nb, nx;
    static real ws;
    static integer nbmin, iinfo;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer minmn;
    extern /* Subroutine */ int sgebd2_(integer *, integer *, real *, integer
        *, real *, real *, real *, real *, real *, integer *), slabrd_(
        integer *, integer *, integer *, real *, integer *, real *, real *
        , real *, real *, real *, integer *, real *, integer *), xerbla_(
        char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwrkx, ldwrky, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGEBRD reduces a general real M-by-N matrix A to upper or lower
    bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

    If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns in the matrix A.  N >= 0.
    A       (input/output) REAL array, dimension (LDA,N)
            输入/输出参数，大小为 (LDA,N) 的实数数组。
            On entry, 函数输入参数，包含待减少的 M×N 一般矩阵 A。
            On exit, 如果 m >= n，对角线和第一个超对角线被上三角双对角矩阵 B 覆盖；
              在对角线以下的元素被 TAUQ 数组表示的正交矩阵 Q 表示为一系列初等反射器的乘积；
              在第一个超对角线以上的元素被 TAUP 数组表示的正交矩阵 P 表示为一系列初等反射器的乘积；
            如果 m < n，对角线和第一个次对角线被下三角双对角矩阵 B 覆盖；
              在第一个次对角线以下的元素被 TAUQ 数组表示的正交矩阵 Q 表示为一系列初等反射器的乘积；
              在对角线以上的元素被 TAUP 数组表示的正交矩阵 P 表示为一系列初等反射器的乘积。
            详见 Further Details。

    LDA     (input) INTEGER
            数组 A 的领先维度。要求 LDA >= max(1,M)。

    D       (output) REAL array, dimension (min(M,N))
            双对角矩阵 B 的对角线元素：
            D(i) = A(i,i)。

    E       (output) REAL array, dimension (min(M,N)-1)
            双对角矩阵 B 的非对角线元素：
            如果 m >= n，E(i) = A(i,i+1)，i = 1,2,...,n-1；
            如果 m < n，E(i) = A(i+1,i)，i = 1,2,...,m-1。

    TAUQ    (output) REAL array dimension (min(M,N))
            表示正交矩阵 Q 的初等反射器的标量因子。详见 Further Details。

    TAUP    (output) REAL array, dimension (min(M,N))
            表示正交矩阵 P 的初等反射器的标量因子。详见 Further Details。

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            工作数组，大小为 MAX(1,LWORK) 的实数数组。
            如果 INFO = 0，函数返回时，WORK(1) 返回最优 LWORK。

    LWORK   (input) INTEGER
            数组 WORK 的长度。要求 LWORK >= max(1,M,N)。
            为了获得最佳性能，推荐 LWORK >= (M+N)*NB，其中 NB 是最佳块大小。

            如果 LWORK = -1，则假定为工作空间查询；函数仅计算 WORK 数组的最优大小，
            并将此值作为 WORK 数组的第一个条目返回，不会因 LWORK 相关的错误消息
            调用 XERBLA。

    INFO    (output) INTEGER
            = 0:  成功退出
            < 0:  如果 INFO = -i，第 i 个参数具有非法值。

    Further Details
    ===============

    矩阵 Q 和 P 表示为初等反射器的乘积：

    如果 m >= n，

       Q = H(1) H(2) . . . H(n)  和  P = G(1) G(2) . . . G(n-1)
    Each H(i) and G(i) has the form:
    
       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
    
    where tauq and taup are real scalars, and v and u are real vectors;
    v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
    u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
    tauq is stored in TAUQ(i) and taup in TAUP(i).


# 定义每个 H(i) 和 G(i) 的形式及存储规则
每个 H(i) 和 G(i) 的定义如下：
   H(i) = I - tauq * v * v'  和  G(i) = I - taup * u * u'
其中，tauq 和 taup 是实数标量，v 和 u 是实向量；
对于向量 v，满足 v(1:i-1) = 0, v(i) = 1，在退出时 v(i+1:m) 存储在 A(i+1:m,i) 中；
对于向量 u，满足 u(1:i) = 0, u(i+1) = 1，在退出时 u(i+2:n) 存储在 A(i,i+2:n) 中；
tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。



    If m < n,
    
       Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)


# 根据 m < n 的条件
如果 m < n，
   计算 Q 和 P：
   Q = H(1) H(2) . . . H(m-1)  和  P = G(1) G(2) . . . G(m)



    Each H(i) and G(i) has the form:
    
       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
    
    where tauq and taup are real scalars, and v and u are real vectors;
    v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
    u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
    tauq is stored in TAUQ(i) and taup in TAUP(i).


# 定义每个 H(i) 和 G(i) 的形式及存储规则（进一步补充）
每个 H(i) 和 G(i) 的定义如下：
   H(i) = I - tauq * v * v'  和  G(i) = I - taup * u * u'
其中，tauq 和 taup 是实数标量，v 和 u 是实向量；
对于向量 v，满足 v(1:i) = 0, v(i+1) = 1，在退出时 v(i+2:m) 存储在 A(i+2:m,i) 中；
对于向量 u，满足 u(1:i-1) = 0, u(i) = 1，在退出时 u(i+1:n) 存储在 A(i,i+1:n) 中；
tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。



    The contents of A on exit are illustrated by the following examples:
    
    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
    
      (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
      (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
      (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
      (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
      (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
      (  v1  v2  v3  v4  v5 )


# A 的退出内容示例
在退出时，A 的内容如下所示：
当 m = 6 且 n = 5 (m > n) 时：
   (  d   e   u1  u1  u1 )
   (  v1  d   e   u2  u2 )
   (  v1  v2  d   e   u3 )
   (  v1  v2  v3  d   e  )
   (  v1  v2  v3  v4  d  )
   (  v1  v2  v3  v4  v5 )
当 m = 5 且 n = 6 (m < n) 时：
   (  d   u1  u1  u1  u1  u1 )
   (  e   d   u2  u2  u2  u2 )
   (  v1  e   d   u3  u3  u3 )
   (  v1  v2  e   d   u4  u4 )
   (  v1  v2  v3  e   d   u5 )



    where d and e denote diagonal and off-diagonal elements of B, vi
    denotes an element of the vector defining H(i), and ui an element of
    the vector defining G(i).


# 定义符号 d 和 e
其中，符号 d 和 e 分别表示矩阵 B 的对角线元素和非对角线元素，
vi 表示定义 H(i) 的向量的元素，ui 表示定义 G(i) 的向量的元素。



    =====================================================================
    
    
       Test the input parameters


# 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

/* Computing MAX */
    i__1 = 1, i__2 = ilaenv_(&c__1, "SGEBRD", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = max(i__1,i__2);  // 计算 nb 作为 1 和 ilaenv 计算结果的最大值
    lwkopt = (*m + *n) * nb;  // 计算工作空间的最优大小
    work[1] = (real) lwkopt;  // 将工作空间大小存入 work 数组的第一个位置
    lquery = *lwork == -1;  // 检查是否为查询工作空间大小的情况
    if (*m < 0) {  // 如果 m 小于 0
    *info = -1;  // 将 info 设置为 -1
    } else if (*n < 0) {  // 如果 n 小于 0
    *info = -2;  // 将 info 设置为 -2
    } else if (*lda < max(1,*m)) {  // 如果 lda 小于 1 和 m 中的最大值
    *info = -4;  // 将 info 设置为 -4
    } else /* if(complicated condition) */ {

/* Computing MAX */
    i__1 = max(1,*m);
    if (*lwork < max(i__1,*n) && ! lquery) {  // 如果 lwork 小于 max(1, m) 和 n 的最大值，并且不是查询工作空间大小
        *info = -10;  // 将 info 设置为 -10，表示工作空间不足
    }
    }
    if (*info < 0) {  // 如果 info 小于 0
    i__1 = -(*info);
    xerbla_("SGEBRD", &i__1);  // 调用错误处理函数 xerbla 打印错误信息
    return 0;  // 返回 0 表示执行失败
    } else if (lquery) {  // 如果是查询工作空间大小的情况
    return 0;  // 直接返回，不进行计算
    }

/*     Quick return if possible */

    minmn = min(*m,*n);  // 计算 m 和 n 中较小的值
    if (minmn == 0) {  // 如果 minmn 等于 0
    work[1] = 1.f;  // 将 work 数组的第一个位置设置为 1.0
    return 0;  // 直接返回，不进行计算
    }

    ws = (real) max(*m,*n);  // 计算 m 和 n 中较大的值，并转换为实数类型
    ldwrkx = *m;  // 设置 ldwrkx 为 m
    ldwrky = *n;  // 设置 ldwrky 为 n

    if (nb > 1 && nb < minmn) {

/*
          Set the crossover point NX.

   Computing MAX
*/
    i__1 = nb, i__2 = ilaenv_(&c__3, "SGEBRD", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算 NX 作为 nb 和 ilaenv 计算结果的最大值

/*        Determine when to switch from blocked to unblocked code. */

    if (nx < minmn) {  // 如果 NX 小于 minmn
        ws = (real) ((*m + *n) * nb);  // 更新 ws 的值
        if ((real) (*lwork) < ws) {

/*
                Not enough work space for the optimal NB, consider using
                a smaller block size.
*/

        nbmin = ilaenv_(&c__2, "SGEBRD", " ", m, n, &c_n1, &c_n1, (
            ftnlen)6, (ftnlen)1);  // 计算出最小的块大小 nbmin
        if (*lwork >= (*m + *n) * nbmin) {
            nb = *lwork / (*m + *n);  // 如果当前工作空间足够，将 nb 设置为 lwork / (m + n)
        } else {
            nb = 1;  // 否则将 nb 设置为 1
            nx = minmn;  // 将 nx 设置为 minmn
        }
        }
    }
    } else {
    nx = minmn;  // 如果 nb <= 1 或者 nb >= minmn，则将 nx 设置为 minmn
    }

    i__1 = minmn - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {

/*
          Reduce rows and columns i:i+nb-1 to bidiagonal form and return
          the matrices X and Y which are needed to update the unreduced
          part of the matrix
*/

    i__3 = *m - i__ + 1;
    i__4 = *n - i__ + 1;
    slabrd_(&i__3, &i__4, &nb, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[
        i__], &tauq[i__], &taup[i__], &work[1], &ldwrkx, &work[ldwrkx
        * nb + 1], &ldwrky);

/*
          Update the trailing submatrix A(i+nb:m,i+nb:n), using an update
          of the form  A := A - V*Y' - X*U'
*/

    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    sgemm_("No transpose", "Transpose", &i__3, &i__4, &nb, &c_b151, &a[
        i__ + nb + i__ * a_dim1], lda, &work[ldwrkx * nb + nb + 1], &
        ldwrky, &c_b15, &a[i__ + nb + (i__ + nb) * a_dim1], lda);
    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    # 调用名为sgemm_的函数，进行矩阵乘法运算
    sgemm_("No transpose",              # 第一个矩阵不进行转置操作
           "No transpose",              # 第二个矩阵也不进行转置操作
           &i__3,                        # 第一个矩阵的行数
           &i__4,                        # 第二个矩阵的列数
           &nb,                          # 第一个矩阵的列数（同时也是第二个矩阵的行数）
           &c_b151,                      # 缩放因子
           &work[nb + 1],                # 第一个矩阵的数据存储位置
           &ldwrkx,                      # 第一个矩阵的列数
           &a[i__ + (i__ + nb) * a_dim1], # 第二个矩阵的数据存储位置，起始于第i__行和第i__+nb列
           lda,                          # 第二个矩阵的列数
           &c_b15,                       # 缩放因子
           &a[i__ + nb + (i__ + nb) * a_dim1], # 结果矩阵的数据存储位置，起始于第i__+nb行和第i__+nb列
           lda);                         # 结果矩阵的列数
/*        Copy diagonal and off-diagonal elements of B back into A */

/* 如果 m >= n，则将 B 的对角线和非对角线元素复制回 A */
if (*m >= *n) {
    // 循环遍历从 i 到 i + nb - 1 的列索引 j
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        // 复制 B 的对角线元素 d 到 A 的对应位置
        a[j + j * a_dim1] = d__[j];
        // 复制 B 的非对角线元素 e 到 A 的对应位置
        a[j + (j + 1) * a_dim1] = e[j];
        /* L10: */
    }
} else {
    // 循环遍历从 i 到 i + nb - 1 的列索引 j
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        // 复制 B 的对角线元素 d 到 A 的对应位置
        a[j + j * a_dim1] = d__[j];
        // 复制 B 的非对角线元素 e 到 A 的对应位置（注意索引 j+1）
        a[j + 1 + j * a_dim1] = e[j];
        /* L20: */
    }
}
/* L30: */
}

/*     Use unblocked code to reduce the remainder of the matrix */

// 使用未块化的代码来处理矩阵的剩余部分
i__2 = *m - i__ + 1;
i__1 = *n - i__ + 1;
sgebd2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__], &
    tauq[i__], &taup[i__], &work[1], &iinfo);
// 设置工作数组中的第一个元素为 ws
work[1] = ws;
// 返回 0 表示成功
return 0;

/*     End of SGEBRD */

} /* sgebrd_ */

/* Subroutine */ int sgeev_(char *jobvl, char *jobvr, integer *n, real *a,
    integer *lda, real *wr, real *wi, real *vl, integer *ldvl, real *vr,
    integer *ldvr, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
        i__2, i__3;
    real r__1, r__2;

    /* Local variables */
    static integer i__, k;
    static real r__, cs, sn;
    static integer ihi;
    static real scl;
    static integer ilo;
    static real dum[1], eps;
    static integer ibal;
    static char side[1];
    static real anrm;
    static integer ierr, itau, iwrk, nout;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);
    extern doublereal snrm2_(integer *, real *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
    extern doublereal slapy2_(real *, real *);
    extern /* Subroutine */ int slabad_(real *, real *);
    static logical scalea;
    static real cscale;
    extern /* Subroutine */ int sgebak_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, integer *, integer *), sgebal_(char *, integer *, real *, integer *,
        integer *, integer *, real *, integer *);
    extern doublereal slamch_(char *), slange_(char *, integer *,
        integer *, real *, integer *, real *);
    extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *), xerbla_(char
        *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical select[1];
    static real bignum;
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);
    extern integer isamax_(integer *, real *, integer *);
    ! 外部函数声明，下面列出了四个外部函数：
    ! slacpy_：复制矩阵
    ! slartg_：生成 Givens 变换
    ! sorghr_：生成双重哈密顿正交变换
    ! shseqr_：求解实对称哈密顿矩阵的特征值问题
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *), slartg_(real *, real *,
        real *, real *, real *), sorghr_(integer *, integer *, integer *,
        real *, integer *, real *, real *, integer *, integer *), shseqr_(
        char *, char *, integer *, integer *, integer *, real *, integer *
        , real *, real *, real *, integer *, real *, integer *, integer *);
    
    ! 静态变量声明：
    ! minwrk：最小工作空间大小
    ! maxwrk：最大工作空间大小
    static integer minwrk, maxwrk;
    
    ! 逻辑变量声明：
    ! wantvl：是否计算左特征向量
    ! lquery：是否查询工作空间大小
    ! wantvr：是否计算右特征向量
    static logical wantvl;
    static logical lquery, wantvr;
    
    ! 实数变量声明：
    ! smlnum：定义的小数值，用于浮点运算中的判别
    static real smlnum;
    
    ! 整数变量声明：
    ! hswork：Hessenberg 矩阵的工作空间大小
    static integer hswork;
"""
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    WR      (output) REAL array, dimension (N)
    WI      (output) REAL array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) REAL array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
"""
    # VR 是包含右特征向量的实数数组，维度为 (LDVR, N)
    # 如果 JOBVR = 'V'，则右特征向量 v(j) 依次存储在 VR 的列中，与对应的特征值顺序一致
    # 如果 JOBVR = 'N'，则不使用 VR
    # 如果第 j 个特征值是实数，则 v(j) = VR[:,j]，即 VR 的第 j 列
    # 如果第 j 和 (j+1) 个特征值是复共轭对，则 v(j) = VR[:,j] + i*VR[:,j+1]，v(j+1) = VR[:,j] - i*VR[:,j+1]

    # LDVR 是数组 VR 的主维度。LDVR >= 1；如果 JOBVR = 'V'，则 LDVR >= N

    # WORK 是实数数组，维度为 (MAX(1,LWORK))
    # 在退出时，如果 INFO = 0，则 WORK(1) 返回最优的 LWORK 值

    # LWORK 是数组 WORK 的维度。LWORK >= max(1,3*N)，如果 JOBVL = 'V' 或 JOBVR = 'V'，则 LWORK >= 4*N
    # 为了获得良好的性能，通常需要更大的 LWORK

    # 如果 LWORK = -1，则假定进行工作空间查询；例程仅计算 WORK 数组的最佳大小，
    # 并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会因 LWORK 相关的错误消息而发出

    # INFO 是整数输出。INFO 的含义：
    # = 0:  成功退出
    # < 0:  如果 INFO = -i，第 i 个参数值非法
    # > 0:  如果 INFO = i，QR 算法未能计算所有特征值，且未计算任何特征向量；
    #       WR 和 WI 的第 i+1 到 N 个元素包含已收敛的特征值
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --wr;
    --wi;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    lquery = *lwork == -1;  // 检查是否为查询工作空间的标志
    wantvl = lsame_(jobvl, "V");  // 检查是否需要计算左特征向量
    wantvr = lsame_(jobvr, "V");  // 检查是否需要计算右特征向量

    if (! wantvl && ! lsame_(jobvl, "N")) {
        *info = -1;  // 如果 jobvl 参数不合法，则返回错误码 -1
    } else if (! wantvr && ! lsame_(jobvr, "N")) {
        *info = -2;  // 如果 jobvr 参数不合法，则返回错误码 -2
    } else if (*n < 0) {
        *info = -3;  // 如果 n 参数不合法（负数），则返回错误码 -3
    } else if (*lda < max(1,*n)) {
        *info = -5;  // 如果 lda 参数小于等于 0 或小于 n 的最大值，则返回错误码 -5
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
        *info = -9;  // 如果 ldvl 参数小于等于 0 或者需要计算左特征向量但 ldvl 小于 n，则返回错误码 -9
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
        *info = -11;  // 如果 ldvr 参数小于等于 0 或者需要计算右特征向量但 ldvr 小于 n，则返回错误码 -11
    }

    /*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         NB refers to the optimal block size for the immediately
         following subroutine, as returned by ILAENV.
         HSWORK refers to the workspace preferred by SHSEQR, as
         calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
         the worst case.)
    */

    if (*info == 0) {
        if (*n == 0) {
            minwrk = 1;  // 如果 n 为 0，则最小工作空间为 1
            maxwrk = 1;  // 如果 n 为 0，则最大工作空间为 1
        } else {
            // 计算最大工作空间需求
            maxwrk = (*n << 1) + *n * ilaenv_(&c__1, "SGEHRD", " ", n, &c__1,
                n, &c__0, (ftnlen)6, (ftnlen)1);
            if (wantvl) {
                // 如果需要计算左特征向量，计算最小工作空间需求
                minwrk = *n << 2;
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                    "SORGHR", " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)
                    1);
                maxwrk = max(i__1,i__2);
                // 调用计算左特征向量的子程序 SHSEQR
                shseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
                    1], &vl[vl_offset], ldvl, &work[1], &c_n1, info);
                hswork = work[1];
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
                    n + hswork;
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n << 2;
                maxwrk = max(i__1,i__2);
            } else if (wantvr) {
                // 如果需要计算右特征向量，计算最小工作空间需求
                minwrk = *n << 2;
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                    "SORGHR", " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)
                    1);
                maxwrk = max(i__1,i__2);
                // 调用计算右特征向量的子程序 SHSEQR
                shseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
                    1], &vr[vr_offset], ldvr, &work[1], &c_n1, info);
                hswork = work[1];
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
                    n + hswork;
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n << 2;
                maxwrk = max(i__1,i__2);
            }
        }
    }
/* Computing MAX */
/* 计算最大值 */
        i__1 = maxwrk, i__2 = *n << 2;
        maxwrk = max(i__1,i__2);
/* 更新工作空间的最大值要求 */

        } else {
/* 若不为查询状态 */
        minwrk = *n * 3;
/* 设置工作空间的最小值要求为 3*n */
        shseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
            1], &vr[vr_offset], ldvr, &work[1], &c_n1, info);
/* 调用 LAPACK 函数 shseqr 计算特征值，并返回 Schur 形式 */
        hswork = work[1];
/* 记录 LAPACK 所需工作空间大小 */
/* Computing MAX */
/* 计算最大值 */
        i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
            n + hswork;
        maxwrk = max(i__1,i__2);
/* 更新工作空间的最大值要求 */
        }
        maxwrk = max(maxwrk,minwrk);
/* 取工作空间的最大值和最小值的最大值 */

    }
    work[1] = (real) maxwrk;
/* 将计算得到的最大工作空间大小存入工作数组的第一个位置 */

    if (*lwork < minwrk && ! lquery) {
/* 若提供的工作空间小于最小要求，并且不是查询状态 */
        *info = -13;
/* 返回错误信息 */
    }
    }

    if (*info != 0) {
/* 若返回的信息不为零 */
    i__1 = -(*info);
    xerbla_("SGEEV ", &i__1);
/* 调用 LAPACK 错误处理函数 */
    return 0;
    } else if (lquery) {
/* 若为查询状态 */
    return 0;
    }

/*     Quick return if possible */
/* 快速返回，如果可能 */

    if (*n == 0) {
/* 若矩阵维度为零 */
    return 0;
    }

/*     Get machine constants */
/* 获取机器常数 */

    eps = slamch_("P");
/* 获取精度 eps */
    smlnum = slamch_("S");
/* 获取最小安全数 smlnum */
    bignum = 1.f / smlnum;
/* 计算最大安全数 bignum */
    slabad_(&smlnum, &bignum);
/* 初始化 smlnum 和 bignum */
    smlnum = sqrt(smlnum) / eps;
/* 计算 scaled 小安全数 */
    bignum = 1.f / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */
/* 若 A 的最大元素不在范围 [smlnum, bignum] 内，则进行缩放 */

    anrm = slange_("M", n, n, &a[a_offset], lda, dum);
/* 计算矩阵 A 的最大模 */
    scalea = FALSE_;
/* 初始化缩放标志 */
    if (anrm > 0.f && anrm < smlnum) {
/* 若矩阵 A 的最大模在 smlnum 和 0 之间 */
    scalea = TRUE_;
/* 设置缩放标志 */
    cscale = smlnum;
    } else if (anrm > bignum) {
/* 若矩阵 A 的最大模超出 bignum */
    scalea = TRUE_;
/* 设置缩放标志 */
    cscale = bignum;
    }
    if (scalea) {
/* 若需要进行缩放 */
    slascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
        ierr);
/* 调用 LAPACK 函数 slascl 进行矩阵缩放 */
    }

/*
       Balance the matrix
       (Workspace: need N)
*/
/* 平衡矩阵 */
    ibal = 1;
/* 设置工作空间起始位置 */
    sgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &work[ibal], &ierr);
/* 调用 LAPACK 函数 sgebal 进行矩阵平衡 */

/*
       Reduce to upper Hessenberg form
       (Workspace: need 3*N, prefer 2*N+N*NB)
*/
/* 将矩阵约化为上 Hessenberg 形式 */
    itau = ibal + *n;
/* 计算工作空间起始位置 */
    iwrk = itau + *n;
/* 计算工作空间起始位置 */
    i__1 = *lwork - iwrk + 1;
    sgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
         &ierr);
/* 调用 LAPACK 函数 sgehrd 进行约化 */

    if (wantvl) {

/*
          Want left eigenvectors
          Copy Householder vectors to VL
*/

    *(unsigned char *)side = 'L';
/* 设置左特征向量标志 */
    slacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl)
        ;
/* 复制 Householder 向量到 VL */

/*
          Generate orthogonal matrix in VL
          (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB)
*/

    i__1 = *lwork - iwrk + 1;
    sorghr_(n, &ilo, &ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk],
         &i__1, &ierr);
/* 调用 LAPACK 函数 sorghr 生成正交矩阵 */

/*
          Perform QR iteration, accumulating Schur vectors in VL
          (Workspace: need N+1, prefer N+HSWORK (see comments) )
*/

    iwrk = itau;
/* 更新工作空间起始位置 */
    i__1 = *lwork - iwrk + 1;
    shseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &
        vl[vl_offset], ldvl, &work[iwrk], &i__1, info);
/* 调用 LAPACK 函数 shseqr 进行 QR 迭代 */

    if (wantvr) {

/*
             Want left and right eigenvectors
             Copy Schur vectors to VR
*/

        *(unsigned char *)side = 'B';
/* 设置左右特征向量标志 */
        slacpy_("F", n, n, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr);
/* 复制 Schur 向量到 VR */
    }

    } else if (wantvr) {

/*
          Want right eigenvectors
          Copy Householder vectors to VR
*/

    *(unsigned char *)side = 'R';
/* 设置右特征向量标志 */
    # 调用 LAPACK 库中的 slacpy_ 函数，将矩阵 a 复制到矩阵 vr 中
    slacpy_("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr)
        ;
/*
          Generate orthogonal matrix in VR
          (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB)
*/
    i__1 = *lwork - iwrk + 1;
    sorghr_(n, &ilo, &ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk],
         &i__1, &ierr);

/*
          Perform QR iteration, accumulating Schur vectors in VR
          (Workspace: need N+1, prefer N+HSWORK (see comments) )
*/
    iwrk = itau;
    i__1 = *lwork - iwrk + 1;
    shseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &
        vr[vr_offset], ldvr, &work[iwrk], &i__1, info);

    } else {

/*
          Compute eigenvalues only
          (Workspace: need N+1, prefer N+HSWORK (see comments) )
*/
    iwrk = itau;
    i__1 = *lwork - iwrk + 1;
    shseqr_("E", "N", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &
        vr[vr_offset], ldvr, &work[iwrk], &i__1, info);
    }

/*     If INFO > 0 from SHSEQR, then quit */
    if (*info > 0) {
    goto L50;
    }

    if (wantvl || wantvr) {

/*
          Compute left and/or right eigenvectors
          (Workspace: need 4*N)
*/
    strevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
         &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &ierr);
    }

    if (wantvl) {

/*
          Undo balancing of left eigenvectors
          (Workspace: need N)
*/
    sgebak_("B", "L", n, &ilo, &ihi, &work[ibal], n, &vl[vl_offset], ldvl,
         &ierr);

/*        Normalize left eigenvectors and make largest component real */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (wi[i__] == 0.f) {
        scl = 1.f / snrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
        sscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
        } else if (wi[i__] > 0.f) {
        r__1 = snrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
        r__2 = snrm2_(n, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
        scl = 1.f / slapy2_(&r__1, &r__2);
        sscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
        sscal_(n, &scl, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
        i__2 = *n;
        for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
            r__1 = vl[k + i__ * vl_dim1];
/* Computing 2nd power */
            r__2 = vl[k + (i__ + 1) * vl_dim1];
            work[iwrk + k - 1] = r__1 * r__1 + r__2 * r__2;
/* L10: */
        }
        k = isamax_(n, &work[iwrk], &c__1);
        slartg_(&vl[k + i__ * vl_dim1], &vl[k + (i__ + 1) * vl_dim1],
            &cs, &sn, &r__);
        srot_(n, &vl[i__ * vl_dim1 + 1], &c__1, &vl[(i__ + 1) *
            vl_dim1 + 1], &c__1, &cs, &sn);
        vl[k + (i__ + 1) * vl_dim1] = 0.f;
        }
/* L20: */
    }
    }

    if (wantvr) {

/*
          Undo balancing of right eigenvectors
          (Workspace: need N)
*/
    sgebak_("B", "R", n, &ilo, &ihi, &work[ibal], n, &vr[vr_offset], ldvr,
         &ierr);

/*        Normalize right eigenvectors and make largest component real */
    i__1 = *n;

    sgebak_("B", "R", n, &ilo, &ihi, &work[ibal], n, &vr[vr_offset], ldvr,
         &ierr);

/*        Normalize right eigenvectors and make largest component real */
    i__1 = *n;
    // 对于每个特征值和特征向量对 (i__, wi[i__]):
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 如果特征值为零，将对应的特征向量归一化
        if (wi[i__] == 0.f) {
            // 计算特征向量 vr[i__] 的二范数的倒数作为缩放因子
            scl = 1.f / snrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
            // 使用缩放因子对特征向量 vr[i__] 进行缩放
            sscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
        } else if (wi[i__] > 0.f) {
            // 计算特征向量 vr[i__] 和 vr[i__+1] 的二范数
            r__1 = snrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
            r__2 = snrm2_(n, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
            // 计算二向量的欧几里得范数并取其倒数作为缩放因子
            scl = 1.f / slapy2_(&r__1, &r__2);
            // 使用缩放因子对特征向量 vr[i__] 和 vr[i__+1] 进行缩放
            sscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
            sscal_(n, &scl, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
            // 对于每个分量 k，进行下一步操作
            i__2 = *n;
            for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
r__1 = vr[k + i__ * vr_dim1];
/* Computing 2nd power */
r__2 = vr[k + (i__ + 1) * vr_dim1];
/* 计算向量的平方和，并存储在工作数组中 */
work[iwrk + k - 1] = r__1 * r__1 + r__2 * r__2;
/* L30: */
}
/* 找出工作数组中绝对值最大的元素的索引 */
k = isamax_(n, &work[iwrk], &c__1);
/* 计算 Givens 旋转参数 */
slartg_(&vr[k + i__ * vr_dim1], &vr[k + (i__ + 1) * vr_dim1],
    &cs, &sn, &r__);
/* 应用 Givens 旋转到矩阵的列向量 */
srot_(n, &vr[i__ * vr_dim1 + 1], &c__1, &vr[(i__ + 1) *
    vr_dim1 + 1], &c__1, &cs, &sn);
/* 将一个特定位置的矩阵元素置零 */
vr[k + (i__ + 1) * vr_dim1] = 0.f;
}
/* L40: */
}

/*     Undo scaling if necessary */

L50:
/* 如果需要，撤销矩阵的缩放操作 */
if (scalea) {
i__1 = *n - *info;
/* 计算两个整数的最大值 */
i__3 = *n - *info;
i__2 = max(i__3,1);
/* 对矩阵的某些行进行缩放 */
slascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[*info +
    1], &i__2, &ierr);
i__1 = *n - *info;
/* 计算两个整数的最大值 */
i__3 = *n - *info;
i__2 = max(i__3,1);
/* 对矩阵的某些行进行缩放 */
slascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[*info +
    1], &i__2, &ierr);
if (*info > 0) {
    i__1 = ilo - 1;
    /* 对矩阵的某些行进行缩放 */
    slascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[1],
        n, &ierr);
    i__1 = ilo - 1;
    /* 对矩阵的某些行进行缩放 */
    slascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[1],
        n, &ierr);
}
}

work[1] = (real) maxwrk;
/* 返回执行成功的状态码 */
return 0;

/*     End of SGEEV */

} /* sgeev_ */

/* Subroutine */ int sgehd2_(integer *n, integer *ilo, integer *ihi, real *a,
    integer *lda, real *tau, real *work, integer *info)
{
/* 局部变量声明 */
/* 系统生成的本地变量声明 */
integer a_dim1, a_offset, i__1, i__2, i__3;
/* 本地变量声明 */
static integer i__;
static real aii;
/* 外部子程序声明 */
extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
    integer *, real *, real *, integer *, real *), xerbla_(
    char *, integer *), slarfg_(integer *, real *, real *,
    integer *, real *);

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

Purpose
=======
SGEHD2 reduces a real general matrix A to upper Hessenberg form H by
an orthogonal similarity transformation:  Q' * A * Q = H .

Arguments
=========
N       (input) INTEGER
        The order of the matrix A.  N >= 0.

ILO     (input) INTEGER
IHI     (input) INTEGER
        It is assumed that A is already upper triangular in rows
        and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
        set by a previous call to SGEBAL; otherwise they should be
        set to 1 and N respectively. See Further Details.
        1 <= ILO <= IHI <= max(1,N).
    ! Test the input parameters
    ! 测试输入参数

    IF (N .LT. 0) THEN
        ! 如果 N 小于 0，则返回错误代码
        INFO = -1
        RETURN
    ELSE IF (LDA .LT. MAX(1,N)) THEN
        ! 如果 LDA 小于 max(1,N)，则返回错误代码
        INFO = -2
        RETURN
    ELSE IF (N .EQ. 0) THEN
        ! 如果 N 等于 0，说明没有需要处理的矩阵，直接返回成功
        INFO = 0
        RETURN
    END IF

    INFO = 0
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
    *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
    *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
    *info = -3;
    } else if (*lda < max(1,*n)) {
    *info = -5;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SGEHD2", &i__1);
    return 0;
    }

    i__1 = *ihi - 1;
    for (i__ = *ilo; i__ <= i__1; ++i__) {

/*        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) */

    i__2 = *ihi - i__;
/* Computing MIN */
    i__3 = i__ + 2;
    slarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*n) + i__ *
        a_dim1], &c__1, &tau[i__]);
    aii = a[i__ + 1 + i__ * a_dim1];
    a[i__ + 1 + i__ * a_dim1] = 1.f;

/*        Apply H(i) to A(1:ihi,i+1:ihi) from the right */

    i__2 = *ihi - i__;
    slarf_("Right", ihi, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
        i__], &a[(i__ + 1) * a_dim1 + 1], lda, &work[1]);

/*        Apply H(i) to A(i+1:ihi,i+1:n) from the left */

    i__2 = *ihi - i__;
    i__3 = *n - i__;
    slarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
        i__], &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);

    a[i__ + 1 + i__ * a_dim1] = aii;
/* L10: */
    }

    return 0;

/*     End of SGEHD2 */

} /* sgehd2_ */

/* Subroutine */ int sgehrd_(integer *n, integer *ilo, integer *ihi, real *a,
    integer *lda, real *tau, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j;
    static real t[4160]    /* was [65][64] */;
    static integer ib;
    static real ei;
    static integer nb, nh, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *), strmm_(char *, char *, char *,
         char *, integer *, integer *, real *, real *, integer *, real *,
        integer *), saxpy_(integer *,
        real *, real *, integer *, real *, integer *), sgehd2_(integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        ), slahr2_(integer *, integer *, integer *, real *, integer *,
        real *, real *, integer *, real *, integer *), slarfb_(char *,
        char *, char *, char *, integer *, integer *, integer *, real *,
        integer *, real *, integer *, real *, integer *, real *, integer *
        ), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2.1)                                  --

    SGEHRD computes the reduction of a real general matrix A to upper
    Hessenberg form H by an orthogonal similarity transformation:

       H = U**T * A * U

    where U is an orthogonal matrix. This subroutine is a part of LAPACK
    (Linear Algebra PACKage).

    Parameters:
    - n: The order of the matrix A (input).
    - ilo: The lower index of the submatrix to be reduced (input).
    - ihi: The upper index of the submatrix to be reduced (input).
    - a: Real array, dimension (lda, n).
         On entry, the n-by-n general matrix A.
         On exit, if INFO = 0, the upper Hessenberg matrix H.
    - lda: The leading dimension of the array A (input).
    - tau: Real array, dimension (n-1).
         The scalar factors of the elementary reflectors, as returned by
         SGEHRD.
    - work: Real array, dimension (lwork).
         On exit, if INFO = 0, work[0] returns the optimal lwork.
    - lwork: The length of the array work. lwork >= max(1, 3*n-1).
           For optimal performance, lwork >= (nb + nh)*n,
           where nb is the optimal block size for the blocked
           reduction, and nh is the bandwidth required to reduce
           the matrix to Hessenberg form.
           If lwork = -1, then a workspace query is assumed; the
           routine only calculates the optimal size of the work
           array, returns this value as the first entry of the work
           array, and no error message is issued by XERBLA.
    - info: Integer.
           = 0: successful exit
           < 0: if INFO = -i, the i-th argument had an illegal value.
           > 0: if INFO = i, SGEHRD failed to converge; elements of
                tau[i:n-1] contain the elements of the diagonal and
                subdiagonal of the bidiagonal matrix B in the
                factorization of A, but B itself is not Hermitian.
*/
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --
    
    # LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包。
    # 该注释段描述了 LAPACK 的来源和版本信息。
    
    Purpose
    =======
    
    # 函数目的说明段
    
    SGEHRD reduces a real general matrix A to upper Hessenberg form H by
    an orthogonal similarity transformation:  Q' * A * Q = H .
    
    # SGEHRD 函数将实数一般矩阵 A 通过正交相似变换，减少为上 Hessenberg 形式 H。
    # 此处描述了转换的数学表达式。
    
    Arguments
    =========
    
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    
    # N：矩阵 A 的阶数，要求大于等于零。
    
    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to SGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
    
    # ILO、IHI：A 的上三角部分在 1:ILO-1 和 IHI+1:N 的行和列中已经存在。
    # 这些参数通常由 SGEBAL 的前一次调用设置；如果没有，则应分别设置为 1 和 N。
    # 详细信息请参见进一步的详细说明。
    
    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.
    
    # A：输入时为待减少的 N×N 一般矩阵。
    # 函数执行后，A 的上三角部分和第一个次对角线以下的部分将被上 Hessenberg 矩阵 H 覆盖，
    # 且数组 TAU 中的元素表示正交矩阵 Q，它是一系列初等反射变换的乘积。
    # 详细信息请参见进一步的详细说明。
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    
    # LDA：数组 A 的主维度，要求大于等于 max(1, N)。
    
    TAU     (output) REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
    
    # TAU：初等反射变换的标量因子数组。
    # TAU 的元素 1 到 ILO-1 和 IHI 到 N-1 被设置为零。
    
    WORK    (workspace/output) REAL array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    # WORK：工作空间数组，要求的长度为 LWORK。
    # 如果 INFO = 0，则 WORK(1) 返回最佳 LWORK 值。
    
    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
    
    # LWORK：工作数组 WORK 的长度要求，要求大于等于 max(1, N)。
    # 为了达到最佳性能，建议 LWORK >= N*NB，其中 NB 是最佳的块大小。
    
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    
    # 如果 LWORK = -1，则假定进行工作空间查询；该例程仅计算 WORK 数组的最佳大小，
    # 并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会报告与 LWORK 相关的任何错误消息。
    
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
    
    # INFO：输出参数，指示函数的执行结果。
    # 如果 INFO = 0，则表示成功执行。
    # 如果 INFO = -i，其中 i 表示非法值的参数序号。
    
    Further Details
    ===============
    
    # 进一步的详细说明段
    
    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors
    
       Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    
    # 矩阵 Q 被表示为 (ihi-ilo) 个初等反射变换的乘积。
    
    Each H(i) has the form
    
       H(i) = I - tau * v * v'
    
    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).
    
    # 每个 H(i) 的形式为 I - tau * v * v'，其中 tau 是实数标量，
    # v 是一个实向量，满足 v(1:i) = 0, v(i+1) = 1 和 v(ihi+1:n) = 0；
    # v(i+2:ihi) 在退出时存储在 A(i+2:ihi,i)，tau 存储在 TAU(i) 中。
    
    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:
    
    on entry,                        on exit,
    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This file is a slight modification of LAPACK-3.0's DGEHRD
    subroutine incorporating improvements proposed by Quintana-Orti and
    Van de Geijn (2006). (See DLAHR2.)

    =====================================================================

    检测输入参数的有效性


这段代码主要是对输入参数进行检测，确保它们符合预期的格式和要求。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 变量为 0
    /* Computing MIN */
    i__1 = 64, i__2 = ilaenv_(&c__1, "SGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);  // 计算并选择块大小 nb，使其不超过指定的值
    lwkopt = *n * nb;  // 计算所需的工作区大小
    work[1] = (real) lwkopt;  // 将计算得到的工作区大小存储在 work 数组的第一个位置
    lquery = *lwork == -1;  // 设置查询标志，检查是否只是查询工作区大小
    if (*n < 0) {  // 检查参数是否合法
    *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
    *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
    *info = -3;
    } else if (*lda < max(1,*n)) {
    *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
    *info = -8;
    }
    if (*info != 0) {  // 如果有错误信息，调用错误处理函数并返回
    i__1 = -(*info);
    xerbla_("SGEHRD", &i__1);
    return 0;
    } else if (lquery) {  // 如果只是查询工作区大小，直接返回
    return 0;
    }

/*     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero */

    i__1 = *ilo - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    tau[i__] = 0.f;  // 将 TAU 数组的部分元素设为零
/* L10: */
    }
    i__1 = *n - 1;
    for (i__ = max(1,*ihi); i__ <= i__1; ++i__) {
    tau[i__] = 0.f;  // 将 TAU 数组的部分元素设为零
/* L20: */
    }

/*     Quick return if possible */

    nh = *ihi - *ilo + 1;  // 计算 nh 的值
    if (nh <= 1) {  // 如果 nh 小于等于 1，直接返回
    work[1] = 1.f;
    return 0;
    }

/*
       Determine the block size

   Computing MIN
*/
    i__1 = 64, i__2 = ilaenv_(&c__1, "SGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);  // 重新计算并选择块大小 nb

    nbmin = 2;  // 设置最小的块大小为 2
    iws = 1;  // 初始化工作区大小
    if (nb > 1 && nb < nh) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code)

   Computing MAX
*/
    i__1 = nb, i__2 = ilaenv_(&c__3, "SGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算并选择从块代码切换到非块代码的阈值
    if (nx < nh) {

/*           Determine if workspace is large enough for blocked code */

        iws = *n * nb;  // 计算块代码所需的工作区大小
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code

   Computing MAX
*/
        i__1 = 2, i__2 = ilaenv_(&c__2, "SGEHRD", " ", n, ilo, ihi, &
            c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);  // 确定使用非块代码时的最小块大小
        if (*lwork >= *n * nbmin) {
            nb = *lwork / *n;  // 根据工作区大小确定新的块大小
        } else {
            nb = 1;  // 强制使用非块代码
        }
        }
    }
    }
    ldwork = *n;  // 设置工作数组的维度

    if (nb < nbmin || nb >= nh) {

/*        Use unblocked code below */

    i__ = *ilo;  // 设置起始位置为 ilo

    } else {

/*        Use blocked code */

    i__1 = *ihi - 1 - nx;
    i__2 = nb;
    for (i__ = *ilo; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = nb, i__4 = *ihi - i__;
        ib = min(i__3,i__4);  // 计算当前块的大小

/*
             Reduce columns i:i+ib-1 to Hessenberg form, returning the
             matrices V and T of the block reflector H = I - V*T*V'
             which performs the reduction, and also the matrix Y = A*V*T
/*
        Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
        right, computing  A := A - Y * V'. V(i+ib,ib-1) must be set
        to 1
*/
ei = a[i__ + ib + (i__ + ib - 1) * a_dim1];
a[i__ + ib + (i__ + ib - 1) * a_dim1] = 1.f;
i__3 = *ihi - i__ - ib + 1;
sgemm_("No transpose", "Transpose", ihi, &i__3, &ib, &c_b151, &
    work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &
    c_b15, &a[(i__ + ib) * a_dim1 + 1], lda);
a[i__ + ib + (i__ + ib - 1) * a_dim1] = ei;

/*
        Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
        right
*/
i__3 = ib - 1;
strmm_("Right", "Lower", "Transpose", "Unit", &i__, &i__3, &c_b15,
     &a[i__ + 1 + i__ * a_dim1], lda, &work[1], &ldwork);
i__3 = ib - 2;
for (j = 0; j <= i__3; ++j) {
saxpy_(&i__, &c_b151, &work[ldwork * j + 1], &c__1, &a[(i__ +
    j + 1) * a_dim1 + 1], &c__1);
/* L30: */
}

/*
        Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
        left
*/
i__3 = *ihi - i__;
i__4 = *n - i__ - ib + 1;
slarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
    i__4, &ib, &a[i__ + 1 + i__ * a_dim1], lda, t, &c__65, &a[
    i__ + 1 + (i__ + ib) * a_dim1], lda, &work[1], &ldwork);
/* L40: */
}

/* Use unblocked code to reduce the rest of the matrix */
sgehd2_(n, &i__, ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
work[1] = (real) iws;

return 0;

/* End of SGEHRD */

} /* sgehrd_ */

/* Subroutine */ int sgelq2_(integer *m, integer *n, real *a, integer *lda,
    real *tau, real *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
static integer i__, k;
static real aii;
extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
    integer *, real *, real *, integer *, real *), xerbla_(
    char *, integer *), slarfg_(integer *, real *, real *,
    integer *, real *);
    ! Test the input arguments
    ! 检查输入参数的合法性

    A       (input/output) REAL array, dimension (LDA,N)
    ! On entry, the m by n matrix A.
    ! 在输入时，m行n列的矩阵A
    ! On exit, the elements on and below the diagonal of the array
    ! contain the m by min(m,n) lower trapezoidal matrix L (L is
    ! lower triangular if m <= n); the elements above the diagonal,
    ! with the array TAU, represent the orthogonal matrix Q as a
    ! product of elementary reflectors (see Further Details).
    ! 在输出时，数组A的对角线及以下元素包含m行min(m,n)列的下梯形矩阵L（如果m <= n，则L为下三角矩阵）；
    ! 对角线以上的元素及TAU数组表示正交矩阵Q，其为一系列初等反射器的乘积（详见Further Details）。

    LDA     (input) INTEGER
    ! The leading dimension of the array A.  LDA >= max(1,M).
    ! 数组A的主维度。LDA >= max(1,M)。

    TAU     (output) REAL array, dimension (min(M,N))
    ! The scalar factors of the elementary reflectors (see Further
    ! Details).
    ! 初等反射器的标量因子（详见Further Details）。

    WORK    (workspace) REAL array, dimension (M)
    ! Workspace array for computations.
    ! 用于计算的工作空间数组。

    INFO    (output) INTEGER
    ! = 0: successful exit
    ! < 0: if INFO = -i, the i-th argument had an illegal value
    ! 返回状态：
    ! = 0: 成功退出
    ! < 0: 如果INFO = -i，则第i个参数具有非法值

    Further Details
    ===============
    ! Further Details
    ! 详细说明：

    ! The matrix Q is represented as a product of elementary reflectors

    !    Q = H(k) . . . H(2) H(1), where k = min(m,n).

    ! Each H(i) has the form

    !    H(i) = I - tau * v * v'

    ! where tau is a real scalar, and v is a real vector with
    ! v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
    ! and tau in TAU(i).

    ! 矩阵Q表示为一系列初等反射器的乘积：

    !    Q = H(k) . . . H(2) H(1)，其中 k = min(m,n)。

    ! 每个H(i)的形式为：

    !    H(i) = I - tau * v * v'

    ! 其中tau是实数标量，v是实向量，满足v(1:i-1) = 0和v(i) = 1；
    ! v(i+1:n)在退出时存储在A(i,i+1:n)中，tau存储在TAU(i)中。

    =====================================================================

    ! Test the input arguments
    ! 检查输入参数的合法性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 将错误信息初始化为零
    if (*m < 0) {  // 如果输入参数 m 小于零
        *info = -1;  // 设置错误信息为 -1
    } else if (*n < 0) {  // 如果输入参数 n 小于零
        *info = -2;  // 设置错误信息为 -2
    } else if (*lda < max(1,*m)) {  // 如果 lda 小于 max(1, m)
        *info = -4;  // 设置错误信息为 -4
    }
    if (*info != 0) {  // 如果有错误信息不为零
        i__1 = -(*info);
        xerbla_("SGELQ2", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0
    }

    k = min(*m,*n);  // 计算 k 为 m 和 n 中的较小值

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i,i+1:n) */

        i__2 = *n - i__ + 1;
        /* Computing MIN */
        i__3 = i__ + 1;
        slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) * a_dim1]
            , lda, &tau[i__]);  // 生成元素反射器 H(i)，使得 A(i,i+1:n) 被消除

        if (i__ < *m) {

/*           Apply H(i) to A(i+1:m,i:n) from the right */

            real aii = a[i__ + i__ * a_dim1];  // 保存 A(i,i)
            a[i__ + i__ * a_dim1] = 1.f;  // 设置 A(i,i) 为 1
            i__2 = *m - i__;
            i__3 = *n - i__ + 1;
            slarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[
                i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);  // 应用 H(i) 到 A(i+1:m,i:n) 的右侧
            a[i__ + i__ * a_dim1] = aii;  // 恢复 A(i,i)
        }
/* L10: */
    }
    return 0;

/*     End of SGELQ2 */

} /* sgelq2_ */

/* Subroutine */ int sgelqf_(integer *m, integer *n, real *a, integer *lda,
    real *tau, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int sgelq2_(integer *, integer *, real *, integer
        *, real *, real *, integer *), slarfb_(char *, char *, char *,
        char *, integer *, integer *, integer *, real *, integer *, real *
        , integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGELQF computes an LQ factorization of a real M-by-N matrix A:
    A = L * Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

*/
    ! Test the input arguments
    ! 测试输入参数的合法性

    IF (M.LT.0) THEN
        ! If M is less than 0, set INFO to -1 and return
        ! 如果 M 小于 0，则将 INFO 设为 -1 并返回
        INFO = -1
        RETURN
    ELSE IF (N.LT.0) THEN
        ! If N is less than 0, set INFO to -2 and return
        ! 如果 N 小于 0，则将 INFO 设为 -2 并返回
        INFO = -2
        RETURN
    ELSE IF (LDA.LT.MAX(1,M)) THEN
        ! If LDA is less than max(1,M), set INFO to -3 and return
        ! 如果 LDA 小于 max(1,M)，则将 INFO 设为 -3 并返回
        INFO = -3
        RETURN
    ELSE IF (LWORK.LT.MAX(1,M).AND.LWORK.NE.-1) THEN
        ! If LWORK is less than max(1,M) and not -1, set INFO to -7 and return
        ! 如果 LWORK 小于 max(1,M) 且不等于 -1，则将 INFO 设为 -7 并返回
        INFO = -7
        RETURN
    END IF

    ! Quick return if possible
    ! 如果可能的话，快速返回
    IF (M.EQ.0.OR.N.EQ.0) THEN
        ! If M is 0 or N is 0, set INFO to 0 and return
        ! 如果 M 为 0 或 N 为 0，则将 INFO 设为 0 并返回
        INFO = 0
        RETURN
    END IF

    ! Determine the block size
    ! 确定块大小
    /* Parameter adjustments */
    a_dim1 = *lda;  // a_dim1 是矩阵 A 的第一维度大小，即列数
    a_offset = 1 + a_dim1;  // a_offset 是计算矩阵 A 的起始偏移量
    a -= a_offset;  // 将矩阵 A 指针向前移动到正确的起始位置
    --tau;  // 将向量 tau 指针向前移动到正确的起始位置
    --work;  // 将工作数组 work 的指针向前移动到正确的起始位置

    /* Function Body */
    *info = 0;  // 初始化 info，表示没有错误
    nb = ilaenv_(&c__1, "SGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)
        1);  // 通过 ilaenv 函数获取用于 SGELQF 的块大小
    lwkopt = *m * nb;  // 计算所需的最优工作数组长度
    work[1] = (real) lwkopt;  // 将计算得到的工作数组长度存储到 work 的第一个元素
    lquery = *lwork == -1;  // 检查是否为查询模式，即是否仅查询所需工作空间大小
    if (*m < 0) {  // 检查输入维度 m 是否合法
    *info = -1;
    } else if (*n < 0) {  // 检查输入维度 n 是否合法
    *info = -2;
    } else if (*lda < max(1,*m)) {  // 检查 lda 是否足够大以容纳矩阵 A
    *info = -4;
    } else if (*lwork < max(1,*m) && ! lquery) {  // 检查工作数组长度是否足够大
    *info = -7;
    }
    if (*info != 0) {  // 如果发现错误信息不为 0，则报错
    i__1 = -(*info);
    xerbla_("SGELQF", &i__1);  // 调用 xerbla 函数报告错误信息
    return 0;  // 返回错误代码
    } else if (lquery) {  // 如果是查询模式，则直接返回
    return 0;
    }

/*     Quick return if possible */

    k = min(*m,*n);  // 计算 k 的值，即矩阵 A 的行列数的较小者
    if (k == 0) {  // 如果 k 为 0，则直接返回
    work[1] = 1.f;  // 设置工作数组的第一个元素为 1.0
    return 0;
    }

    nbmin = 2;  // 设置最小的块大小为 2
    nx = 0;  // 初始化交叉点 nx 为 0
    iws = *m;  // 设置初始工作空间大小为 m
    if (nb > 1 && nb < k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "SGELQF", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算交叉点 nx 的值
    if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *m;  // 设置 ldwork 为 m
        iws = ldwork * nb;  // 计算使用块大小 nb 所需的最小工作空间大小
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        nb = *lwork / ldwork;  // 重新计算可以使用的最大块大小
/* Computing MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "SGELQF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);  // 计算最小的块大小
        }
    }
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

    i__1 = k - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = k - i__ + 1;
        ib = min(i__3,nb);  // 计算当前块的大小 ib

/*
             Compute the LQ factorization of the current block
             A(i:i+ib-1,i:n)
*/

        i__3 = *n - i__ + 1;
        sgelq2_(&ib, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);  // 调用 sgelq2 函数进行 LQ 分解
        if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__3 = *n - i__ + 1;
        slarft_("Forward", "Rowwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);  // 调用 slarft 函数计算块反射器 H

/*              Apply H to A(i+ib:m,i:n) from the right */

        i__3 = *m - i__ - ib + 1;
        i__4 = *n - i__ + 1;
        slarfb_("Right", "No transpose", "Forward", "Rowwise", &i__3,
            &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
            ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib +
            1], &ldwork);  // 调用 slarfb 函数应用块反射器 H 到剩余的矩阵部分
        }
/* L10: */
    }
    } else {
    i__ = 1;
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {
    i__2 = *m - i__ + 1;
    i__1 = *n - i__ + 1;
    sgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &iinfo);  // 使用 sgelq2 函数对最后或唯一的块进行 LQ 分解
    }
    sgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    // 调用外部函数 sgelq2_，对指定的矩阵执行 LQ 分解，传入参数为:
    // - 第一维大小 i__2
    // - 第二维大小 i__1
    // - 矩阵 a 中的特定元素地址 &a[i__ + i__ * a_dim1]
    // - 矩阵 a 的 leading dimension lda
    // - 存储结果的 tau 数组的特定位置 &tau[i__]
    // - 临时工作数组 work 的起始位置 &work[1]
    // - 存储返回信息的整数 iinfo

    }
    
    work[1] = (real) iws;
    // 将整数 iws 转换为实数类型，存储到 work 数组的第一个位置

    return 0;
    // 返回整数值 0，表示函数执行完毕且正常结束
/*     End of SGELQF */

} /* sgelqf_ */

/* Subroutine */ int sgelsd_(integer *m, integer *n, integer *nrhs, real *a,
    integer *lda, real *b, integer *ldb, real *s, real *rcond, integer *
    rank, real *work, integer *lwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer ie, il, mm;
    static real eps, anrm, bnrm;
    static integer itau, nlvl, iascl, ibscl;
    static real sfmin;
    static integer minmn, maxmn, itaup, itauq, mnthr, nwork;
    extern /* Subroutine */ int slabad_(real *, real *), sgebrd_(integer *,
        integer *, real *, integer *, real *, real *, real *, real *,
        real *, integer *, integer *);
    extern doublereal slamch_(char *), slange_(char *, integer *,
        integer *, real *, integer *, real *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static real bignum;
    extern /* Subroutine */ int sgelqf_(integer *, integer *, real *, integer
        *, real *, real *, integer *, integer *), slalsd_(char *, integer
        *, integer *, integer *, real *, real *, real *, integer *, real *
        , integer *, real *, integer *, integer *), slascl_(char *
        , integer *, integer *, real *, real *, integer *, integer *,
        real *, integer *, integer *);
    static integer wlalsd;
    extern /* Subroutine */ int sgeqrf_(integer *, integer *, real *, integer
        *, real *, real *, integer *, integer *), slacpy_(char *, integer
        *, integer *, real *, integer *, real *, integer *),
        slaset_(char *, integer *, integer *, real *, real *, real *,
        integer *);
    static integer ldwork;
    extern /* Subroutine */ int sormbr_(char *, char *, char *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , real *, integer *, integer *);
    static integer liwork, minwrk, maxwrk;
    static real smlnum;
    extern /* Subroutine */ int sormlq_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);
    static logical lquery;
    static integer smlsiz;
    extern /* Subroutine */ int sormqr_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);

/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGELSD computes the minimum-norm solution to a real linear least
    squares problem:
        minimize 2-norm(| b - A*x |)
    using the singular value decomposition (SVD) of A. A is an M-by-N
*/
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.


    # 解释：函数处理多个右手边向量和对应的解向量，可以在单次调用中处理。它们被存储在大小为 M×NRHS 的右手边矩阵 B 和大小为 N×NRHS 的解矩阵 X 的列中。


    The problem is solved in three steps:
    (1) Reduce the coefficient matrix A to bidiagonal form with
        Householder transformations, reducing the original problem
        into a "bidiagonal least squares problem" (BLS)
    (2) Solve the BLS using a divide and conquer approach.
    (3) Apply back all the Householder tranformations to solve
        the original least squares problem.


    # 解释：问题通过三个步骤解决：
    # (1) 使用 Householder 变换将系数矩阵 A 缩减为双对角形式，从而将原始问题转化为“双对角最小二乘问题”（BLS）。
    # (2) 使用分而治之的方法解决 BLS 问题。
    # (3) 应用所有的 Householder 变换来解决原始的最小二乘问题。


    The effective rank of A is determined by treating as zero those
    singular values which are less than RCOND times the largest singular
    value.


    # 解释：通过将小于 RCOND 倍最大奇异值的奇异值视为零来确定 A 的有效秩。


    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.


    # 解释：分而治之算法对浮点运算的假设非常温和。它适用于具有加/减法保护位的机器，或者在没有加/减法保护位的二进制机器上（例如 Cray X-MP、Cray Y-MP、Cray C-90 或 Cray-2）。它可能在没有加/减法保护位的十六进制或十进制机器上失败，但我们目前未发现这种情况。


    Arguments
    =========

    M       (input) INTEGER
            The number of rows of A. M >= 0.

    N       (input) INTEGER
            The number of columns of A. N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrices B and X. NRHS >= 0.

    A       (input) REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) REAL array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, B is overwritten by the N-by-NRHS solution
            matrix X.  If m >= n and RANK = n, the residual
            sum-of-squares for the solution in the i-th column is given
            by the sum of squares of elements n+1:m in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,max(M,N)).

    S       (output) REAL array, dimension (min(M,N))
            The singular values of A in decreasing order.
            The condition number of A in the 2-norm = S(1)/S(min(m,n)).

    RCOND   (input) REAL
            RCOND is used to determine the effective rank of A.
            Singular values S(i) <= RCOND*S(1) are treated as zero.
            If RCOND < 0, machine precision is used instead.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the number of singular values
            which are greater than RCOND*S(1).

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.


    # 解释：参数说明如下：
    # M：矩阵 A 的行数，必须大于等于 0。
    # N：矩阵 A 的列数，必须大于等于 0。
    # NRHS：右手边的数量，即矩阵 B 和 X 的列数。必须大于等于 0。
    # A：输入的实数数组，维度为 (LDA, N)，在输入时是 M×N 的矩阵 A，在退出时被破坏。
    # LDA：数组 A 的领导维度，必须大于等于 max(1, M)。
    # B：输入/输出的实数数组，维度为 (LDB, NRHS)，在输入时是 M×NRHS 的右手边矩阵 B，在退出时被 N×NRHS 的解矩阵 X 覆盖。如果 m >= n 并且 RANK = n，则解的第 i 列的残差平方和由该列中 n+1:m 元素的平方和给出。
    # LDB：数组 B 的领导维度，必须大于等于 max(1, max(M, N))。
    # S：输出的实数数组，维度为 min(M, N)，按降序排列的 A 的奇异值。A 的 2-范数的条件数为 S(1)/S(min(m,n))。
    # RCOND：用于确定 A 的有效秩的阈值。奇异值 S(i) <= RCOND*S(1) 视为零。如果 RCOND < 0，则使用机器精度。
    # RANK：输出的整数，A 的有效秩，即大于 RCOND*S(1) 的奇异值的数量。
    # WORK：工作空间/输出的实数数组，维度为 MAX(1, LWORK)，如果 INFO = 0，则 WORK(1) 返回最优 LWORK。
    # 输入参数 LWORK（输入）整数
    # WORK 数组的维度。LWORK 必须至少为 1。
    # 所需的工作空间的确切最小量取决于 M、N 和 NRHS。
    # 只要 LWORK 至少为 12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2，
    # 当 M 大于或等于 N 时，
    # 或者为 12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2，
    # 当 M 小于 N 时，代码将正确执行。
    # SMLSIZ 由 ILAENV 返回，通常为子问题在计算树底部的最大大小（通常约为 25），
    # NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )。
    # 为了获得良好的性能，LWORK 通常应该更大。
    # 如果 LWORK = -1，则假定进行工作区查询；例程仅计算 WORK 数组的最佳大小和
    # IWORK 数组的最小大小，并将这些值作为 WORK 和 IWORK 数组的第一个条目返回，
    # 并且 XERBLA 不会发出与 LWORK 相关的任何错误消息。

    # IWORK（工作空间）整数数组，维度为 (MAX(1,LIWORK))
    # LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN)，其中 MINMN = MIN( M,N )。
    # 在退出时，如果 INFO = 0，则 IWORK(1) 返回最小的 LIWORK。

    # INFO（输出）整数
    # = 0：成功退出
    # < 0：如果 INFO = -i，则第 i 个参数具有非法值。
    # > 0：用于计算奇异值分解的算法未收敛；
    # 如果 INFO = i，则一个中间的双对角形式的 i 非对角元素未收敛为零。

    # 进一步细节
    # 基于以下贡献
    #    Ming Gu 和 Ren-Cang Li，加利福尼亚大学伯克利分校，美国
    #    Osni Marques，LBNL/NERSC，美国

    # 测试输入参数。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;  // 将数组 a 调整为以 a_offset 为起始位置的一维数组
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;  // 将数组 b 调整为以 b_offset 为起始位置的一维数组
    --s;  // 将指针 s 指向的值减一
    --work;  // 将指针 work 指向的值减一
    --iwork;  // 将指针 iwork 指向的值减一

    /* Function Body */
    *info = 0;  // 初始化 info 指向的值为 0
    minmn = min(*m,*n);  // 计算 m 和 n 的最小值并赋给 minmn
    maxmn = max(*m,*n);  // 计算 m 和 n 的最大值并赋给 maxmn
    lquery = *lwork == -1;  // 检查是否查询工作空间大小

    if (*m < 0) {  // 检查 m 的值是否小于 0
        *info = -1;  // 若是，设置 info 指向的值为 -1
    } else if (*n < 0) {  // 检查 n 的值是否小于 0
        *info = -2;  // 若是，设置 info 指向的值为 -2
    } else if (*nrhs < 0) {  // 检查 nrhs 的值是否小于 0
        *info = -3;  // 若是，设置 info 指向的值为 -3
    } else if (*lda < max(1,*m)) {  // 检查 lda 的值是否小于 max(1, m)
        *info = -5;  // 若是，设置 info 指向的值为 -5
    } else if (*ldb < max(1,maxmn)) {  // 检查 ldb 的值是否小于 max(1, maxmn)
        *info = -7;  // 若是，设置 info 指向的值为 -7
    }

    /*
       Compute workspace.
       (Note: Comments in the code beginning "Workspace:" describe the
       minimal amount of workspace needed at that point in the code,
       as well as the preferred amount for good performance.
       NB refers to the optimal block size for the immediately
       following subroutine, as returned by ILAENV.)
    */

    if (*info == 0) {  // 若 info 指向的值为 0，表示输入参数正确
        minwrk = 1;  // 初始化 minwrk 为 1
        maxwrk = 1;  // 初始化 maxwrk 为 1
        liwork = 1;  // 初始化 liwork 为 1
        if (minmn > 0) {  // 如果 minmn 大于 0
            smlsiz = ilaenv_(&c__9, "SGELSD", " ", &c__0, &c__0, &c__0, &c__0,
                 (ftnlen)6, (ftnlen)1);  // 调用 ilaenv_ 函数获取 smlsiz 值
            mnthr = ilaenv_(&c__6, "SGELSD", " ", m, n, nrhs, &c_n1, (ftnlen)
                6, (ftnlen)1);  // 调用 ilaenv_ 函数获取 mnthr 值
            /* Computing MAX */
            i__1 = (integer) (log((real) minmn / (real) (smlsiz + 1)) / log(
                2.f)) + 1;  // 计算 nlvl 的值
            nlvl = max(i__1,0);  // nlvl 取 i__1 和 0 中较大的值
            liwork = minmn * 3 * nlvl + minmn * 11;  // 计算 liwork 的值
            mm = *m;  // 将 m 的值赋给 mm
            if (*m >= *n && *m >= mnthr) {  // 如果 m 大于等于 n 并且 m 大于等于 mnthr

                /*
                    Path 1a - overdetermined, with many more rows than
                              columns.
                */

                mm = *n;  // 将 n 的值赋给 mm
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + *n * ilaenv_(&c__1, "SGEQRF",
                    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + *nrhs * ilaenv_(&c__1, "SORMQR",
                    "LT", m, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)2);  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
            }
            if (*m >= *n) {  // 如果 m 大于等于 n

                /*
                    Path 1 - overdetermined or exactly determined.

                   Computing MAX
                */
                i__1 = maxwrk, i__2 = *n * 3 + (mm + *n) * ilaenv_(&c__1,
                    "SGEBRD", " ", &mm, n, &c_n1, &c_n1, (ftnlen)6, (
                    ftnlen)1);  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n * 3 + *nrhs * ilaenv_(&c__1, "SORMBR"
                    , "QLT", &mm, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n * 3 + (*n - 1) * ilaenv_(&c__1,
                    "SORMBR", "PLN", n, nrhs, n, &c_n1, (ftnlen)6, (
                    ftnlen)3);  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
                /* Computing 2nd power */
                i__1 = smlsiz + 1;  // 计算 smlsiz + 1 的平方
                wlalsd = *n * 9 + (*n << 1) * smlsiz + (*n << 3) * nlvl + *n *
                     *nrhs + i__1 * i__1;  // 计算 wlalsd 的值
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n * 3 + wlalsd;  // 计算 maxwrk 的值
                maxwrk = max(i__1,i__2);  // 取 i__1 和 i__2 中较大的值
            }
        }
    }
/* Computing MAX */
        i__1 = *n * 3 + mm, i__2 = *n * 3 + *nrhs, i__1 = max(i__1,
            i__2), i__2 = *n * 3 + wlalsd;
        minwrk = max(i__1,i__2);
        }
        if (*n > *m) {
/* Computing 2nd power */
        i__1 = smlsiz + 1;
        wlalsd = *m * 9 + (*m << 1) * smlsiz + (*m << 3) * nlvl + *m *
             *nrhs + i__1 * i__1;
        if (*n >= mnthr) {

/*
                   Path 2a - underdetermined, with many more columns
                             than rows.
*/

            maxwrk = *m + *m * ilaenv_(&c__1, "SGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m << 1) *
                ilaenv_(&c__1, "SGEBRD", " ", m, m, &c_n1, &c_n1,
                (ftnlen)6, (ftnlen)1);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *nrhs *
                ilaenv_(&c__1, "SORMBR", "QLT", m, nrhs, m, &c_n1,
                 (ftnlen)6, (ftnlen)3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m - 1) *
                ilaenv_(&c__1, "SORMBR", "PLN", m, nrhs, m, &c_n1,
                 (ftnlen)6, (ftnlen)3);
            maxwrk = max(i__1,i__2);
            if (*nrhs > 1) {
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + *m + *m * *nrhs;
            maxwrk = max(i__1,i__2);
            } else {
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 1);
            maxwrk = max(i__1,i__2);
            }
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m + *nrhs * ilaenv_(&c__1, "SORMLQ"
                , "LT", n, nrhs, m, &c_n1, (ftnlen)6, (ftnlen)2);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + wlalsd;
            maxwrk = max(i__1,i__2);
/*
       XXX: Ensure the Path 2a case below is triggered.  The workspace
       calculation should use queries for all routines eventually.
   Computing MAX
   Computing MAX
*/
            i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4),
                i__3 = max(i__3,*nrhs), i__4 = *n - *m * 3;
            i__1 = maxwrk, i__2 = (*m << 2) + *m * *m + max(i__3,i__4)
                ;
            maxwrk = max(i__1,i__2);
        } else {

/*                 Path 2 - remaining underdetermined cases. */

            maxwrk = *m * 3 + (*n + *m) * ilaenv_(&c__1, "SGEBRD",
                " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * 3 + *nrhs * ilaenv_(&c__1,
                "SORMBR", "QLT", m, nrhs, n, &c_n1, (ftnlen)6, (
                ftnlen)3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
            i__1 = maxwrk, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORM"
                "BR", "PLN", n, nrhs, m, &c_n1, (ftnlen)6, (ftnlen)
                3);
            maxwrk = max(i__1,i__2);
/* Computing MAX */
i__1 = maxwrk, i__2 = *m * 3 + wlalsd;
maxwrk = max(i__1,i__2);

计算最大工作空间大小，取 `maxwrk` 和 `*m * 3 + wlalsd` 的最大值。


/* Computing MAX */
i__1 = *m * 3 + *nrhs, i__2 = *m * 3 + *m, i__1 = max(i__1,
    i__2), i__2 = *m * 3 + wlalsd;
minwrk = max(i__1,i__2);

计算最小工作空间大小，取 `(*m * 3 + *nrhs)` 和 `(*m * 3 + *m)` 的最大值，再和 `(*m * 3 + wlalsd)` 的最大值取最大值。


minwrk = min(minwrk,maxwrk);

将 `minwrk` 设置为 `minwrk` 和 `maxwrk` 中的最小值。


work[1] = (real) maxwrk;
iwork[1] = liwork;

将工作数组 `work` 的第一个元素设置为 `maxwrk` 的实数值，将整数工作数组 `iwork` 的第一个元素设置为 `liwork`。


if (*lwork < minwrk && ! lquery) {
    *info = -12;
}

如果传入的工作空间大小 `*lwork` 小于 `minwrk` 并且不是查询模式 `lquery`，则将 `*info` 设置为 `-12`，表示工作空间不足。


if (*info != 0) {
i__1 = -(*info);
xerbla_("SGELSD", &i__1);
return 0;
} else if (lquery) {
return 0;
}

如果 `*info` 不等于 `0`，则调用错误处理函数 `xerbla_`，并返回 `0`；如果是查询模式 `lquery`，则直接返回 `0`。


/*     Quick return if possible. */
if (*m == 0 || *n == 0) {
*rank = 0;
return 0;
}

如果输入的矩阵维度 `*m` 或 `*n` 为 `0`，则直接将 `*rank` 设置为 `0` 并返回 `0`。


/*     Get machine parameters. */
eps = slamch_("P");
sfmin = slamch_("S");
smlnum = sfmin / eps;
bignum = 1.f / smlnum;
slabad_(&smlnum, &bignum);

获取机器参数：机器精度 `eps`、最小安全数 `sfmin`，并根据它们计算 `smlnum` 和 `bignum`，然后调用 `slabad_` 函数。


/*     Scale A if max entry outside range [SMLNUM,BIGNUM]. */
anrm = slange_("M", m, n, &a[a_offset], lda, &work[1]);
iascl = 0;
if (anrm > 0.f && anrm < smlnum) {

计算矩阵 `A` 的范数 `anrm`，如果 `anrm` 大于 `0` 且小于 `smlnum`，则对矩阵 `A` 进行缩放处理。


/*        Scale matrix norm up to SMLNUM. */
slascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda,
    info);
iascl = 1;

将矩阵 `A` 的范数缩放至 `smlnum`，并将 `iascl` 标记为 `1`。


} else if (anrm > bignum) {
/*        Scale matrix norm down to BIGNUM. */
slascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda,
    info);
iascl = 2;

如果 `anrm` 大于 `bignum`，则将矩阵 `A` 的范数缩放至 `bignum`，并将 `iascl` 标记为 `2`。


} else if (anrm == 0.f) {
/*        Matrix all zero. Return zero solution. */
i__1 = max(*m,*n);
slaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[b_offset], ldb);
slaset_("F", &minmn, &c__1, &c_b29, &c_b29, &s[1], &c__1);
*rank = 0;
goto L10;
}

如果矩阵 `A` 是全零矩阵，则设置解为零，清空矩阵 `B` 和向量 `s`，将 `*rank` 设置为 `0`，并跳转到标签 `L10`。


/*     Scale B if max entry outside range [SMLNUM,BIGNUM]. */
bnrm = slange_("M", m, nrhs, &b[b_offset], ldb, &work[1]);
ibscl = 0;
if (bnrm > 0.f && bnrm < smlnum) {

计算矩阵 `B` 的范数 `bnrm`，如果 `bnrm` 大于 `0` 且小于 `smlnum`，则对矩阵 `B` 进行缩放处理。


/*        Scale matrix norm up to SMLNUM. */
slascl_("G", &c__0, &c__0, &bnrm, &smlnum, m, nrhs, &b[b_offset], ldb,
     info);
ibscl = 1;

将矩阵 `B` 的范数缩放至 `smlnum`，并将 `ibscl` 标记为 `1`。


} else if (bnrm > bignum) {
/*        Scale matrix norm down to BIGNUM. */
slascl_("G", &c__0, &c__0, &bnrm, &bignum, m, nrhs, &b[b_offset], ldb,
     info);
ibscl = 2;

如果 `bnrm` 大于 `bignum`，则将矩阵 `B` 的范数缩放至 `bignum`，并将 `ibscl` 标记为 `2`。


/*     If M < N make sure certain entries of B are zero. */
if (*m < *n) {
i__1 = *n - *m;
slaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[*m + 1 + b_dim1], ldb);
}

如果 `*m < *n`，则确保矩阵 `B` 的部分条目为零。


/*     Overdetermined case. */
if (*m >= *n) {

如果 `*m >= *n`，表示是超定或者完全确定的情况。


/*        Path 1 - overdetermined or exactly determined. */
mm = *m;
if (*m >= mnthr) {

路径 1 - 超定或者完全确定的情况，设置 `mm` 为 `*m`，如果 `*m >= mnthr`。


/*           Path 1a - overdetermined, with many more rows than columns. */
mm = *n;
itau = 1;
nwork = itau + *n;

路径 1a - 超定情况，行数远大于列数。设置 `mm` 为 `*n`，初始化工作数组起始索引 `itau` 和 `nwork`。


/*
    Compute A=Q*R.
    (Workspace: need 2*N, prefer N+N*NB)
*/
i__1 = *lwork - nwork + 1;
sgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
        info);

计算 `A=Q*R`，使用 `sgeqrf_` 函数进行 QR 分解。


/*
    Multiply B by transpose(Q).
    (Workspace: need N+NRHS, prefer N+NRHS*NB)
*/

将矩阵 `B` 乘以 `Q` 的转置，使用工作数组进行存储和计算。
/*
        i__1 = *lwork - nwork + 1;
        sormqr_("L", "T", m, nrhs, n, &a[a_offset], lda, &work[itau], &b[
            b_offset], ldb, &work[nwork], &i__1, info);
*/
// 使用 SORMQR 函数对矩阵进行乘法运算，这里是左乘转置矩阵 Q。
// 输入参数 m 表示矩阵 A 的行数，nrhs 表示右侧矩阵 B 的列数，n 表示矩阵 A 的列数。
// a 是主要矩阵 A，lda 是 a 数组的第一个维度的长度。
// work 是工作数组，其中 itau 指向一个长度为 n 的向量，nwork 指向的是后续的工作空间。
// 返回结果存储在 b 中，ldb 是 b 数组的第一个维度的长度。

/*
           Zero out below R. 
*/
// 将 R 矩阵的主对角线以下的元素置零。

/*
        if (*n > 1) {
        i__1 = *n - 1;
        i__2 = *n - 1;
        slaset_("L", &i__1, &i__2, &c_b29, &c_b29, &a[a_dim1 + 2],
            lda);
        }
*/
// 如果 n 大于 1，则使用 SLASET 函数将矩阵 A 的下三角（L）置零。
// 参数 c_b29 是一个常量，a 是矩阵 A，a_dim1 是 a 数组的第一个维度的长度。

    }

    ie = 1;
    itauq = ie + *n;
    itaup = itauq + *n;
    nwork = itaup + *n;

/*
          Bidiagonalize R in A.
          (Workspace: need 3*N+MM, prefer 3*N+(MM+N)*NB)
*/
// 对矩阵 A 中的 R 进行双对角化处理。
// 输入参数 mm 是 a 数组的行数，n 是 a 数组的列数。
// s 数组存储双对角化过程中的奇异值，work 数组中的各个工作区域分别用于存储不同计算步骤的中间结果。

/*
          Multiply B by transpose of left bidiagonalizing vectors of R.
          (Workspace: need 3*N+NRHS, prefer 3*N+NRHS*NB)
*/
// 将矩阵 B 乘以 R 左边双对角化向量的转置。
// 输入参数 mm 是 a 数组的行数，nrhs 是 b 数组的列数，n 是 a 数组的列数。
// a 是主要矩阵 A，work 数组中的各个工作区域用于存储不同计算步骤的中间结果。

/*        
        Solve the bidiagonal least squares problem.
*/
// 解决双对角最小二乘问题。
// 输入参数 smlsiz 是一个常量，n 是 a 数组的列数，nrhs 是 b 数组的列数。
// s 数组存储双对角化过程中的奇异值，work 数组中的各个工作区域用于存储不同计算步骤的中间结果。

/*
        Multiply B by right bidiagonalizing vectors of R.
*/
// 将矩阵 B 乘以 R 右边双对角化向量。
// 输入参数 n 是 a 数组的列数，nrhs 是 b 数组的列数，n 是 a 数组的列数。
// a 是主要矩阵 A，work 数组中的各个工作区域用于存储不同计算步骤的中间结果。

    } else /* if(complicated condition) */ {
/* Computing MAX */
// 计算 MAX 函数的结果。
// i__1 和 i__2 是用于存储计算结果的整型变量。

/*
          Path 2a - underdetermined, with many more columns than rows
          and sufficient workspace for an efficient algorithm.
*/
// 在工作空间充足的情况下，处理列比行多得多的欠定情况。
// 输入参数 mnthr 是一个常量，*lwork 是工作空间的长度，*m 和 *n 是数组的维度参数。
// wlalsd 是一个常量，用于指定所需的工作空间大小。

/*
          Compute A=L*Q.
          (Workspace: need 2*M, prefer M+M*NB)
*/
// 计算 A 矩阵的 LQ 分解。
// 输入参数 m 是矩阵 A 的行数，n 是矩阵 A 的列数。
// a 是主要矩阵 A，lda 是 a 数组的第一个维度的长度。
// work 是工作数组，其中 itau 指向一个长度为 n 的向量，nwork 指向的是后续的工作空间。

/*        
        Copy L to WORK(IL), zeroing out above its diagonal.
*/
// 复制 L 矩阵到工作区域，并将其主对角线以上的元素置零。
// 输入参数 m 是矩阵 A 的行数，ldwork 是工作数组的维度参数。
// a 是主要矩阵 A，work 是工作数组，il 是工作区域的起始位置。
/*
          Bidiagonalize L in WORK(IL).
          (Workspace: need M*M+5*M, prefer M*M+4*M+2*M*NB)
*/
        i__1 = *lwork - nwork + 1;
        sgebrd_(m, m, &work[il], &ldwork, &s[1], &work[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, info);

/*
          Multiply B by transpose of left bidiagonalizing vectors of L.
          (Workspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
*/
        i__1 = *lwork - nwork + 1;
        sormbr_("Q", "L", "T", m, nrhs, m, &work[il], &ldwork, &work[itauq], &b[b_offset], ldb, &work[nwork], &i__1, info);

/*        Solve the bidiagonal least squares problem. */
        slalsd_("U", &smlsiz, m, nrhs, &s[1], &work[ie], &b[b_offset], ldb, rcond, rank, &work[nwork], &iwork[1], info);
        if (*info != 0) {
            goto L10;
        }

/*        Multiply B by right bidiagonalizing vectors of L. */
        i__1 = *lwork - nwork + 1;
        sormbr_("P", "L", "N", m, nrhs, m, &work[il], &ldwork, &work[itaup], &b[b_offset], ldb, &work[nwork], &i__1, info);

/*        Zero out below first M rows of B. */
        i__1 = *n - *m;
        slaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[*m + 1 + b_dim1], ldb);
        nwork = itau + *m;

/*
          Multiply transpose(Q) by B.
          (Workspace: need M+NRHS, prefer M+NRHS*NB)
*/
        i__1 = *lwork - nwork + 1;
        sormlq_("L", "T", n, nrhs, m, &a[a_offset], lda, &work[itau], &b[b_offset], ldb, &work[nwork], &i__1, info);

    } else {

/*        Path 2 - remaining underdetermined cases. */
        ie = 1;
        itauq = ie + *m;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
          Bidiagonalize A.
          (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*/
        i__1 = *lwork - nwork + 1;
        sgebrd_(m, n, &a[a_offset], lda, &s[1], &work[ie], &work[itauq], &work[itaup], &work[nwork], &i__1, info);

/*
          Multiply B by transpose of left bidiagonalizing vectors.
          (Workspace: need 3*M+NRHS, prefer 3*M+NRHS*NB)
*/
        i__1 = *lwork - nwork + 1;
        sormbr_("Q", "L", "T", m, nrhs, n, &a[a_offset], lda, &work[itauq], &b[b_offset], ldb, &work[nwork], &i__1, info);

/*        Solve the bidiagonal least squares problem. */
        slalsd_("L", &smlsiz, m, nrhs, &s[1], &work[ie], &b[b_offset], ldb, rcond, rank, &work[nwork], &iwork[1], info);
        if (*info != 0) {
            goto L10;
        }

/*        Multiply B by right bidiagonalizing vectors of A. */
        i__1 = *lwork - nwork + 1;
        sormbr_("P", "L", "N", n, nrhs, m, &a[a_offset], lda, &work[itaup], &b[b_offset], ldb, &work[nwork], &i__1, info);

    }
    }

/*     Undo scaling. */

    if (iascl == 1) {
        slascl_("G", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb, info);
        slascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &minmn, info);
    }
    } else if (iascl == 2) {
        # 如果iascl为2，则进行以下操作：
        # 调用slascl函数，用于矩阵缩放：
        # "G" 表示将矩阵缩放到给定的范围内。
        # &c__0, &c__0 表示不对行和列的缩放因子做进一步的缩放。
        # &anrm 是缩放的因子，&bignum 是一个大数，通常用于缩放的比较。
        # n 和 nrhs 分别是矩阵b的维度和右侧向量的数量。
        # &b[b_offset], ldb 表示矩阵b和其leading dimension。
        # info 是一个输出参数，用于存储操作的状态。
        slascl_("G", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb,
             info);
        # 调用slascl函数，用于矩阵缩放：
        # "G" 表示将矩阵缩放到给定的范围内。
        # &c__0, &c__0 表示不对行和列的缩放因子做进一步的缩放。
        # &bignum 是缩放的因子，&anrm 是一个小数，通常用于缩放的比较。
        # &minmn 和 &c__1 表示向量s的长度和其stride。
        # &s[1], &minmn 是要缩放的向量和其长度。
        # info 是一个输出参数，用于存储操作的状态。
        slascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
            minmn, info);
    }
    if (ibscl == 1) {
        # 如果ibscl为1，则进行以下操作：
        # 调用slascl函数，用于矩阵缩放：
        # "G" 表示将矩阵缩放到给定的范围内。
        # &c__0, &c__0 表示不对行和列的缩放因子做进一步的缩放。
        # &smlnum 是缩放的因子，&bnrm 是一个大数，通常用于缩放的比较。
        # n 和 nrhs 分别是矩阵b的维度和右侧向量的数量。
        # &b[b_offset], ldb 表示矩阵b和其leading dimension。
        # info 是一个输出参数，用于存储操作的状态。
        slascl_("G", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb,
             info);
    } else if (ibscl == 2) {
        # 如果ibscl为2，则进行以下操作：
        # 调用slascl函数，用于矩阵缩放：
        # "G" 表示将矩阵缩放到给定的范围内。
        # &c__0, &c__0 表示不对行和列的缩放因子做进一步的缩放。
        # &bignum 是缩放的因子，&bnrm 是一个大数，通常用于缩放的比较。
        # n 和 nrhs 分别是矩阵b的维度和右侧向量的数量。
        # &b[b_offset], ldb 表示矩阵b和其leading dimension。
        # info 是一个输出参数，用于存储操作的状态。
        slascl_("G", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb,
             info);
    }
/*     End of SGELSD */

} /* sgelsd_ */

/* Subroutine */ int sgeqr2_(integer *m, integer *n, real *a, integer *lda,
    real *tau, real *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k;
    static real aii;
    extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
        integer *, real *, real *, integer *, real *), xerbla_(
        char *, integer *), slarfg_(integer *, real *, real *,
        integer *, real *);

    /*
        -- LAPACK routine (version 3.2.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
        June 2010

        Purpose
        =======

        SGEQR2 computes a QR factorization of a real m by n matrix A:
        A = Q * R.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A.  M >= 0.

        N       (input) INTEGER
                The number of columns of the matrix A.  N >= 0.

        A       (input/output) REAL array, dimension (LDA,N)
                On entry, the m by n matrix A.
                On exit, the elements on and above the diagonal of the array
                contain the min(m,n) by n upper trapezoidal matrix R (R is
                upper triangular if m >= n); the elements below the diagonal,
                with the array TAU, represent the orthogonal matrix Q as a
                product of elementary reflectors (see Further Details).

        LDA     (input) INTEGER
                The leading dimension of the array A.  LDA >= max(1,M).

        TAU     (output) REAL array, dimension (min(M,N))
                The scalar factors of the elementary reflectors (see Further
                Details).

        WORK    (workspace) REAL array, dimension (N)

        INFO    (output) INTEGER
                = 0: successful exit
                < 0: if INFO = -i, the i-th argument had an illegal value

        Further Details
        ===============

        The matrix Q is represented as a product of elementary reflectors

        Q = H(1) H(2) . . . H(k), where k = min(m,n).

        Each H(i) has the form

        H(i) = I - tau * v * v'

        where tau is a real scalar, and v is a real vector with
        v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
        and tau in TAU(i).

        =====================================================================

        Test the input arguments
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*m)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SGEQR2", &i__1);
        return 0;
    }

    k = min(*m,*n);

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {


注释完成。
/*        Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

/* 计算要生成的反射器 H(i) 的尺寸，使其能够将 A(i+1:m, i) 化为零向量 */
i__2 = *m - i__ + 1;
/* 计算 i+1 和 *m 中的较小值 */
i__3 = i__ + 1;
/* 调用 LAPACK 函数 slarfg_ 生成反射器 H(i)，将 A(i+1:m,i) 化为零向量，并返回生成的 Householder 系数 tau[i] */
slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ * a_dim1]
    , &c__1, &tau[i__]);
if (i__ < *n) {

/*           Apply H(i) to A(i:m,i+1:n) from the left */

/* 获取 A(i,i) 的值，准备在应用 H(i) 之后恢复 */
aii = a[i__ + i__ * a_dim1];
/* 将 A(i,i) 设置为单位矩阵的元素值 1 */
a[i__ + i__ * a_dim1] = 1.f;
/* 计算应用 H(i) 后剩余部分的维度 */
i__2 = *m - i__ + 1;
i__3 = *n - i__;
/* 调用 LAPACK 函数 slarf_，将反射器 H(i) 应用到 A(i:m,i+1:n) 的左侧 */
slarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &tau[
    i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
/* 恢复 A(i,i) 的原始值 */
a[i__ + i__ * a_dim1] = aii;
}
/* L10: */
}
return 0;

/*     End of SGEQR2 */

} /* sgeqr2_ */

/* Subroutine */ int sgeqrf_(integer *m, integer *n, real *a, integer *lda,
real *tau, real *work, integer *lwork, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

/* Local variables */
static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
extern /* Subroutine */ int sgeqr2_(integer *, integer *, real *, integer
    *, real *, real *, integer *), slarfb_(char *, char *, char *,
    char *, integer *, integer *, integer *, real *, integer *, real *
    , integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
    real *, integer *, real *, real *, integer *);
static integer ldwork, lwkopt;
static logical lquery;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

SGEQRF computes a QR factorization of a real M-by-N matrix A:
A = Q * R.

Arguments
=========

M       (input) INTEGER
The number of rows of the matrix A.  M >= 0.

N       (input) INTEGER
The number of columns of the matrix A.  N >= 0.

A       (input/output) REAL array, dimension (LDA,N)
On entry, the M-by-N matrix A.
On exit, the elements on and above the diagonal of the array
contain the min(M,N)-by-N upper trapezoidal matrix R (R is
upper triangular if m >= n); the elements below the diagonal,
with the array TAU, represent the orthogonal matrix Q as a
product of min(m,n) elementary reflectors (see Further
Details).

LDA     (input) INTEGER
The leading dimension of the array A.  LDA >= max(1,M).

TAU     (output) REAL array, dimension (min(M,N))
The scalar factors of the elementary reflectors (see Further
Details).
*/
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

工作空间数组，用于存储算法运行中需要的数据。如果函数成功执行（INFO = 0），则WORK(1)返回最优的LWORK值。


    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

LWORK是WORK数组的维度，用于指定工作空间的大小。要求LWORK至少为1且不小于N。为了达到最佳性能，建议LWORK至少为N乘以NB，其中NB是最佳的块大小。

如果LWORK = -1，则假定是对工作空间的查询；函数只计算WORK数组的最优大小，并将此值作为WORK数组的第一个条目返回。此时，XERBLA不会发出与LWORK相关的任何错误消息。


    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

INFO是函数的输出参数，用于指示函数的执行状态：
- INFO = 0：成功执行。
- INFO < 0：表示第-i个参数存在非法值。


    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).

    =====================================================================

进一步细节：
- 矩阵Q被表示为一系列初等反射器的乘积。
- Q = H(1) H(2) ... H(k)，其中k = min(m,n)。
- 每个H(i)的形式为H(i) = I - tau * v * v'，其中tau是实数标量，v是实向量，满足v(1:i-1) = 0和v(i) = 1；v(i+1:m)在退出时存储在A(i+1:m,i)中，tau存储在TAU(i)中。

这些细节描述了矩阵Q的具体构造方式。


       Test the input arguments

检查输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "SGEQRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    lwkopt = *n * nb;
    work[1] = (real) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*m)) {
        *info = -4;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -7;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SGEQRF", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    k = min(*m,*n);
    if (k == 0) {
        work[1] = 1.f;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *n;
    if (nb > 1 && nb < k) {

        /*
              Determine when to cross over from blocked to unblocked code.

       Computing MAX
        */
        i__1 = 0, i__2 = ilaenv_(&c__3, "SGEQRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < k) {

            /* Determine if workspace is large enough for blocked code. */

            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

                /*
                    Not enough workspace to use optimal NB: reduce NB and
                    determine the minimum value of NB.
                */

                nb = *lwork / ldwork;
                /* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "SGEQRF", " ", m, n, &c_n1, &
                    c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < k && nx < k) {

        /* Use blocked code initially */

        i__1 = k - nx;
        i__2 = nb;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__3 = k - i__ + 1;
            ib = min(i__3,nb);

            /*
                 Compute the QR factorization of the current block
                 A(i:m,i:i+ib-1)
            */

            i__3 = *m - i__ + 1;
            sgeqr2_(&i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &iinfo);
            if (i__ + ib <= *n) {

                /*
                    Form the triangular factor of the block reflector
                    H = H(i) H(i+1) . . . H(i+ib-1)
                */

                i__3 = *m - i__ + 1;
                slarft_("Forward", "Columnwise", &i__3, &ib, &a[i__ + i__ *
                    a_dim1], lda, &tau[i__], &work[1], &ldwork);

                /* Apply H' to A(i:m,i+ib:n) from the left */

                i__3 = *m - i__ + 1;
                i__4 = *n - i__ - ib + 1;
                slarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
                    i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
                    ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &work[ib
                    + 1], &ldwork);
            }
            /* L10: */
        }
    } else {
        i__ = 1;
    }

    /* Use unblocked code to factor the last or only block. */

    if (i__ <= k) {
        i__2 = *m - i__ + 1;
        i__1 = *n - i__ + 1;
    # 调用 LAPACK 库函数 sgeqr2_，对矩阵 a 中的特定子区域进行 QR 分解
    sgeqr2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    # 结束 for 循环的代码块，对矩阵的每一列进行 QR 分解
    }
    
    # 将工作数组 work 的第一个元素设为整数 iws 的实数值
    work[1] = (real) iws;
    # 返回整数值 0，表示函数执行成功
    return 0;
/* Subroutine */ int sgesdd_(char *jobz, integer *m, integer *n, real *a,
    integer *lda, real *s, real *u, integer *ldu, real *vt, integer *ldvt,
     real *work, integer *lwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2, i__3;

    /* Local variables */
    static integer i__, ie, il, ir, iu, blk;
    static real dum[1], eps;
    static integer ivt, iscl;
    static real anrm;
    static integer idum[1], ierr, itau;
    extern logical lsame_(char *, char *);
    static integer chunk;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer minmn, wrkbl, itaup, itauq, mnthr;
    static logical wntqa;
    static integer nwork;
    static logical wntqn, wntqo, wntqs;
    static integer bdspac;
    extern /* Subroutine */ int sbdsdc_(char *, char *, integer *, real *,
        real *, real *, integer *, real *, integer *, real *, integer *,
        real *, integer *, integer *), sgebrd_(integer *,
        integer *, real *, integer *, real *, real *, real *, real *,
        real *, integer *, integer *);
    extern doublereal slamch_(char *), slange_(char *, integer *,
        integer *, real *, integer *, real *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static real bignum;
    extern /* Subroutine */ int sgelqf_(integer *, integer *, real *, integer
        *, real *, real *, integer *, integer *), slascl_(char *, integer
        *, integer *, real *, real *, integer *, integer *, real *,
        integer *, integer *), sgeqrf_(integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *), slacpy_(char
        *, integer *, integer *, real *, integer *, real *, integer *), slaset_(char *, integer *, integer *, real *, real *,
        real *, integer *);
    static integer ldwrkl;
    extern /* Subroutine */ int sormbr_(char *, char *, char *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , real *, integer *, integer *);
    static integer ldwrkr, minwrk, ldwrku, maxwrk;
    extern /* Subroutine */ int sorglq_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *);
    static integer ldwkvt;
    static real smlnum;
    static logical wntqas;
    extern /* Subroutine */ int sorgqr_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *);
    static logical lquery;

    /* Initialize variables and constants */
    /* Constants for controlling computation */
    eps = slamch_("Epsilon");  // 计算机中的浮点精度
    smlnum = slamch_("Safe minimum");  // 安全最小值
    bignum = 1. / smlnum;  // 安全最大值

    /* Test the input parameters */
    ierr = 0;  // 错误码初始化为0

    /* Quick return if possible */
    if (*m == 0 || *n == 0) {  // 如果 m 或 n 为零，直接返回
        return 0;
    }

    /* Further setup */
    minmn = min(*m,*n);  // m 和 n 中的较小值
    ie = 1;  // 索引 ie 初始化为 1
    il = ie + *m;  // il 是 ie + m
    ir = il + *m;  // ir 是 il + m
    iu = ir + minmn;  // iu 是 ir + minmn
    ivt = iu + minmn;  // ivt 是 iu + minmn

    /* Compute workspace requirements */
    mnthr = ilaenv_(&6, "SGESDD", jobz, m, n, &dummy, &dummy, (ftnlen)6, 1);  // 估算工作空间需求
    wntqa = lsame_(jobz, "A");  // jobz 是否为 "A"
    wntqs = lsame_(jobz, "S");  // jobz 是否为 "S"
    wntqo = lsame_(jobz, "O");  // jobz 是否为 "O"
    wntqas = wntqa || wntqs;  // 是否要计算全奇异值
    wntqn = lsame_(jobz, "N");  // jobz 是否为 "N"
    lquery = *lwork == -1 || *lwork == -2;  // 是否为查询工作空间大小

    if (*m >= *n && *m > 1 && *n > 1 && !wntqn) {
        /* Full bidiagonal SVD, M >= N */
        /* Determine block size and minimum workspace */
        blk = 1;  // 块大小初始化为 1
        wrkbl = max(1, *n * 11);  // 最小工作空间大小
        maxwrk = *lwork;  // 最大工作空间大小

        /* Bidiagonal SVD with TGS, e.g., DQDS */
        /* Transform to bidiagonal form and compute singular values only */
        sgebrd_(m, n, a, lda, s, dum, dum, dum, dum, &dummy, &ierr);  // Bidiagonal 分解
        if (*lwork >= *n * *n + max(*n * 5, wrkbl)) {
            /* Compute singular values to high relative accuracy */
            sbdsdc_("U", "N", n, s, dum, dum, n, dum, n, dum, &ierr, idum,
                idum);  // 计算奇异值
        } else {
            /* Use Divide and Conquer SVD Algorithm */
            nwork = *n * 3;  // 分治 SVD 算法的工作空间大小
            if (*lwork >= nwork + max(*n * 5, wrkbl)) {
                /* Chunked Divide and Conquer SVD */
                chunk = (*lwork - max(*n * 5, wrkbl)) / *n;  // 分块 SVD
                sbdsdc_("U", "I", n, s, dum, dum, n, dum, n, dum, &ierr,
                    idum, idum);  // 计算奇异值
            } else {
                /* Unblocked Divide and Conquer SVD */
                sbdsdc_("U", "A", n, s, dum, dum, n, dum, n, dum, &ierr,
                    idum, idum);  // 计算奇异值
            }
        }

        /* If eigenvectors desired, compute them from Jacobi rotations */
        if (wntqas) {
            /* Initialize singular vectors to Identity matrix */
            slaset_("Full", n, n, 0., 1., u, ldu);  // 初始化矩阵 U

            /* Apply Jacobi rotations */
            if (*lwork >= *n * *n + max(*n * 5, wrkbl)) {
                /* Use faster Jacobi rotations */
                sorgbr_("Q", n, n, n, a, lda, dum, dum, idum, &ierr);  // 计算左奇异向量
                sorgbr_("P", n, n, n, a, lda, dum, dum, idum, &ierr);  // 计算右奇异向量
            } else {
                /* Slow Jacobi rotations */
                ldwkvt = *n;  // 工作空间大小
                sorglq_(n, n, n, a, lda, dum, dum, idum, &ierr);  // 计算左奇异向量
                sorgqr_(n, n, n, a, lda, dum, dum, idum, &ierr);  // 计算右奇异向量
            }
        }

        /* Set INFO and optimal workspace size */
        *info = ierr;  // 错误码
        minwrk = max(*n * 5, wrkbl);  // 最小工作空间大小
        if (*lwork == -1) {
            /* Query optimal workspace size */
            work[1] = minwrk;  // 返回最小工作空间大小
        } else if (*lwork == -
    -- LAPACK driver routine (version 3.2.1)                                  --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       March 2009

# 定义 SGESDD 函数，用于计算实数矩阵 A 的奇异值分解 (SVD)
# 可选地计算左右奇异向量。若要计算奇异向量，使用分而治之算法。
def SGESDD(JOBZ, M, N):
    # Purpose
    # =======
    
    # SGESDD 计算实数 MxN 矩阵 A 的奇异值分解 (SVD)
    # 返回 A = U * SIGMA * transpose(V)
    # 其中 SIGMA 是一个 MxN 矩阵，除了其 min(m,n) 对角线元素外全为零，
    # U 是一个 MxM 正交矩阵，V 是一个 NxN 正交矩阵。
    # SIGMA 的对角元素是 A 的奇异值，它们是实数且非负，并按降序返回。
    # U 和 V 的前 min(m,n) 列分别是 A 的左奇异向量和右奇异向量。
    
    # Note
    # ====
    
    # 这个算法对浮点运算的要求非常宽松。它可以在带有保护位的加/减运算机器上运行，
    # 也可以在没有保护位但像 Cray X-MP、Cray Y-MP、Cray C-90 或 Cray-2 那样进行减法的二进制机器上运行。
    # 但是在没有保护位的十六进制或十进制机器上可能会失败，尽管我们不知道有这样的机器存在。

    # Arguments
    # =========
    
    # JOBZ    (input) CHARACTER*1
    #         指定计算矩阵 U 的全部或部分选项:
    #         = 'A':  返回 U 的全部 M 列和 V 的全部 N 行在数组 U 和 VT 中;
    #         = 'S':  返回 U 的前 min(M,N) 列和 V 的前 min(M,N) 行在数组 U 和 VT 中;
    #         = 'O':  如果 M >= N，则在数组 A 上覆盖 U 的前 N 列并返回 V 的全部行在数组 VT 中;
    #                 否则在数组 U 中返回所有列，并在数组 A 上覆盖 V 的前 M 行;
    #         = 'N':  不计算 U 的列或 V 的行。

    # M       (input) INTEGER
    #         输入矩阵 A 的行数。M >= 0.

    # N       (input) INTEGER
    #         输入矩阵 A 的列数。N >= 0.
    A       (input/output) REAL array, dimension (LDA,N)
            ! On entry, the M-by-N matrix A.
            ! On exit,
            ! if JOBZ = 'O',  A is overwritten with the first N columns
            !                     of U (the left singular vectors, stored
            !                     columnwise) if M >= N;
            !                     A is overwritten with the first M rows
            !                     of V**T (the right singular vectors, stored
            !                     rowwise) otherwise.
            ! if JOBZ .ne. 'O', the contents of A are destroyed.

    LDA     (input) INTEGER
            ! The leading dimension of the array A.  LDA >= max(1,M).

    S       (output) REAL array, dimension (min(M,N))
            ! The singular values of A, sorted so that S(i) >= S(i+1).

    U       (output) REAL array, dimension (LDU,UCOL)
            ! UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
            ! UCOL = min(M,N) if JOBZ = 'S'.
            ! If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
            ! orthogonal matrix U;
            ! if JOBZ = 'S', U contains the first min(M,N) columns of U
            ! (the left singular vectors, stored columnwise);
            ! if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.

    LDU     (input) INTEGER
            ! The leading dimension of the array U.  LDU >= 1; if
            ! JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.

    VT      (output) REAL array, dimension (LDVT,N)
            ! If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            ! N-by-N orthogonal matrix V**T;
            ! if JOBZ = 'S', VT contains the first min(M,N) rows of
            ! V**T (the right singular vectors, stored rowwise);
            ! if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.

    LDVT    (input) INTEGER
            ! The leading dimension of the array VT.  LDVT >= 1; if
            ! JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            ! if JOBZ = 'S', LDVT >= min(M,N).

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            ! On exit, if INFO = 0, WORK(1) returns the optimal LWORK;

    LWORK   (input) INTEGER
            ! The dimension of the array WORK. LWORK >= 1.
            ! If JOBZ = 'N',
            !   LWORK >= 3*min(M,N) + max(max(M,N),6*min(M,N)).
            ! If JOBZ = 'O',
            !   LWORK >= 3*min(M,N) +
            !            max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
            ! If JOBZ = 'S' or 'A'
            !   LWORK >= 3*min(M,N) +
            !            max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
            ! For good performance, LWORK should generally be larger.
            ! If LWORK = -1 but other input arguments are legal, WORK(1)
            ! returns the optimal LWORK.

    IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
    # INFO    (output) INTEGER
    #         = 0:  successful exit.
    #         < 0:  if INFO = -i, the i-th argument had an illegal value.
    #         > 0:  SBDSDC did not converge, updating process failed.
    #
    # 这部分注释说明了变量 INFO 的含义和可能的取值：
    # - INFO = 0 表示程序成功退出。
    # - INFO < 0 表示第 i 个参数具有非法值，其中 i 是负数的绝对值。
    # - INFO > 0 表示 SBDSDC 算法未收敛，更新过程失败。

    # Further Details
    # ===============
    #
    # 基于以下贡献而来
    # Ming Gu 和 Huan Ren，加利福尼亚大学伯克利分校计算机科学系，美国
    #
    # 这部分说明了此算法的进一步细节和基础贡献者信息。

    # =====================================================================
    #
    # 这是一个分隔线，标志着文档的一个章节或重要部分的结束和新部分的开始。

    # Test the input arguments
    #
    # 测试输入参数的有效性和正确性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --s;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;
    minmn = min(*m,*n);
    wntqa = lsame_(jobz, "A");
    wntqs = lsame_(jobz, "S");
    wntqas = wntqa || wntqs;
    wntqo = lsame_(jobz, "O");
    wntqn = lsame_(jobz, "N");
    lquery = *lwork == -1;

    if (! (wntqa || wntqs || wntqo || wntqn)) {
        *info = -1;  // 若 JOBZ 参数不是 'A', 'S', 'O', 'N' 中的任何一个，则置错误码为 -1
    } else if (*m < 0) {
        *info = -2;  // 若 m 参数小于 0，则置错误码为 -2
    } else if (*n < 0) {
        *info = -3;  // 若 n 参数小于 0，则置错误码为 -3
    } else if (*lda < max(1,*m)) {
        *info = -5;  // 若 lda 参数小于 max(1, m)，则置错误码为 -5
    } else if (*ldu < 1 || wntqas && *ldu < *m || wntqo && *m < *n && *ldu < *m) {
        *info = -8;  // 若 ldu 参数小于 1 或者 (wntqas 为真且 ldu 小于 m) 或者 (wntqo 为真且 m 小于 n 且 ldu 小于 m)，则置错误码为 -8
    } else if (*ldvt < 1 || wntqa && *ldvt < *n || wntqs && *ldvt < minmn || wntqo && *m >= *n && *ldvt < *n) {
        *info = -10;  // 若 ldvt 参数小于 1 或者 (wntqa 为真且 ldvt 小于 n) 或者 (wntqs 为真且 ldvt 小于 minmn) 或者 (wntqo 为真且 m 大于等于 n 且 ldvt 小于 n)，则置错误码为 -10
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         NB refers to the optimal block size for the immediately
         following subroutine, as returned by ILAENV.)
*/

    if (*info == 0) {
        minwrk = 1;
        maxwrk = 1;
        if (*m >= *n && minmn > 0) {

/*           Compute space needed for SBDSDC */

            mnthr = (integer) (minmn * 11.f / 6.f);
            if (wntqn) {
                bdspac = *n * 7;  // 如果 JOBZ 为 'N'，计算 SBDSDC 所需空间
            } else {
                bdspac = *n * 3 * *n + (*n << 2);  // 否则，计算另一种情况下的空间需求
            }
            if (*m >= mnthr) {
                if (wntqn) {

/*                 Path 1 (M much larger than N, JOBZ='N') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "SGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算第一种情况下所需工作空间
/* Computing MAX */
                    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                        "SGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                        ftnlen)1);  // 计算最大所需工作空间
                    wrkbl = max(i__1,i__2);
/* Computing MAX */
                    i__1 = wrkbl, i__2 = bdspac + *n;
                    maxwrk = max(i__1,i__2);  // 确定最大工作空间
                    minwrk = bdspac + *n;  // 确定最小工作空间
                } else if (wntqo) {

/*                 Path 2 (M much larger than N, JOBZ='O') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "SGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算第二种情况下所需工作空间
/* Computing MAX */
                    i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "SORGQR",
                        " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
                    wrkbl = max(i__1,i__2);
/* Computing MAX */
                    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                        "SGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                        ftnlen)1);
                    wrkbl = max(i__1,i__2);  // 确定最大工作空间
/* Computing MAX */
计算最大值

    /* 计算工作空间大小 */
    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    /* 计算工作空间大小 */
    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    /* 计算工作空间大小 */
    i__1 = wrkbl, i__2 = bdspac + *n * 3;
    wrkbl = max(i__1,i__2);

/* 设置最大工作空间大小 */
    maxwrk = wrkbl + (*n << 1) * *n;

/* 设置最小工作空间大小 */
    minwrk = bdspac + (*n << 1) * *n + *n * 3;

} else if (wntqs) {

/* Path 3 (M much larger than N, JOBZ='S') */

    /* 计算工作空间大小 */
    wrkbl = *n + *n * ilaenv_(&c__1, "SGEQRF", " ", m, n, &
        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "SORGQR",
        " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
        "SGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = bdspac + *n * 3;
    wrkbl = max(i__1,i__2);

/* 设置最大工作空间大小 */
    maxwrk = wrkbl + *n * *n;

/* 设置最小工作空间大小 */
    minwrk = bdspac + *n * *n + *n * 3;

} else if (wntqa) {

/* Path 4 (M much larger than N, JOBZ='A') */

    /* 计算工作空间大小 */
    wrkbl = *n + *n * ilaenv_(&c__1, "SGEQRF", " ", m, n, &
        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n + *m * ilaenv_(&c__1, "SORGQR",
        " ", m, m, n, &c_n1, (ftnlen)6, (ftnlen)1);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
        "SGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);

/* Computing MAX */
计算最大值

    i__1 = wrkbl, i__2 = bdspac + *n * 3;
    wrkbl = max(i__1,i__2);

/* 设置最大工作空间大小 */
    maxwrk = wrkbl + *n * *n;

/* 设置最小工作空间大小 */
    minwrk = bdspac + *n * *n + *n * 3;

}
/*              Path 5 (M at least N, but not much larger) */

        wrkbl = *n * 3 + (*m + *n) * ilaenv_(&c__1, "SGEBRD", " ", m,
            n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        // 计算需要的工作空间大小，基于特定函数和参数调用的结果
        if (wntqn) {
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = bdspac + *n * 3;
            maxwrk = max(i__1,i__2);
            // 计算工作空间的最小需求
            minwrk = *n * 3 + max(*m,bdspac);
        } else if (wntqo) {
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
                , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = bdspac + *n * 3;
            wrkbl = max(i__1,i__2);
            // 计算工作空间的最大需求
            maxwrk = wrkbl + *m * *n;
/* Computing MAX */
            // 计算工作空间的最小需求
            i__1 = *m, i__2 = *n * *n + bdspac;
            minwrk = *n * 3 + max(i__1,i__2);
        } else if (wntqs) {
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
                , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = bdspac + *n * 3;
            maxwrk = max(i__1,i__2);
            // 计算工作空间的最小需求
            minwrk = *n * 3 + max(*m,bdspac);
        } else if (wntqa) {
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "SORMBR"
                , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = maxwrk, i__2 = bdspac + *n * 3;
            maxwrk = max(i__1,i__2);
            // 计算工作空间的最小需求
            minwrk = *n * 3 + max(*m,bdspac);
        }
        }
    } else if (minmn > 0) {

/*           Compute space needed for SBDSDC */

        // 计算 SBDSDC 所需的空间
        mnthr = (integer) (minmn * 11.f / 6.f);
        if (wntqn) {
        // 根据条件计算 bdspac
        bdspac = *m * 7;
        } else {
        // 根据条件计算 bdspac
        bdspac = *m * 3 * *m + (*m << 2);
        }
        if (*n >= mnthr) {
        if (wntqn) {

/*                 Path 1t (N much larger than M, JOBZ='N') */

            // 根据条件计算 wrkbl
            wrkbl = *m + *m * ilaenv_(&c__1, "SGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            // 根据条件选择工作空间的最大值
            i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
                "SGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
            wrkbl = max(i__1,i__2);
            /* Computing MAX */
            // 计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = bdspac + *m;
            maxwrk = max(i__1,i__2);
            // 计算最小工作空间大小
            minwrk = bdspac + *m;
        } else if (wntqo) {

/*                 Path 2t (N much larger than M, JOBZ='O') */

            // 计算 SGELQF 所需工作空间大小
            wrkbl = *m + *m * ilaenv_(&c__1, "SGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "SORGLQ",
                " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
                "SGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            wrkbl = max(i__1,i__2);
            // 计算最大工作空间大小
            maxwrk = wrkbl + (*m << 1) * *m;
            // 计算最小工作空间大小
            minwrk = bdspac + (*m << 1) * *m + *m * 3;
        } else if (wntqs) {

/*                 Path 3t (N much larger than M, JOBZ='S') */

            // 计算 SGELQF 所需工作空间大小
            wrkbl = *m + *m * ilaenv_(&c__1, "SGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "SORGLQ",
                " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
                "SGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            wrkbl = max(i__1,i__2);
            // 计算最大工作空间大小
            maxwrk = wrkbl + *m * *m;
            // 计算最小工作空间大小
            minwrk = bdspac + *m * *m + *m * 3;
        } else if (wntqa) {

/*                 Path 4t (N much larger than M, JOBZ='A') */

            // 计算 SGELQF 所需工作空间大小
            wrkbl = *m + *m * ilaenv_(&c__1, "SGELQF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
            // 组合计算最大值，用于确定工作空间大小
            i__1 = wrkbl, i__2 = *m + *n * ilaenv_(&c__1, "SORGLQ",
                " ", n, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
                "SGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            wrkbl = max(i__1,i__2);
            maxwrk = wrkbl + *m * *m;
            minwrk = bdspac + *m * *m + *m * 3;
        }
        } else {

/*              Path 5t (N greater than M, but not much larger) */

        // 计算最大工作空间大小
        wrkbl = *m * 3 + (*m + *n) * ilaenv_(&c__1, "SGEBRD", " ", m,
            n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        if (wntqn) {
/* Computing MAX */
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            maxwrk = max(i__1,i__2);
            minwrk = *m * 3 + max(*n,bdspac);
        } else if (wntqo) {
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            wrkbl = max(i__1,i__2);
            maxwrk = wrkbl + *m * *n;
/* Computing MAX */
            i__1 = *n, i__2 = *m * *m + bdspac;
            minwrk = *m * 3 + max(i__1,i__2);
        } else if (wntqs) {
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            maxwrk = max(i__1,i__2);
            minwrk = *m * 3 + max(*n,bdspac);
        } else if (wntqa) {
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "SORMBR"
                , "PRT", n, n, m, &c_n1, (ftnlen)6, (ftnlen)3);
            wrkbl = max(i__1,i__2);
/* Computing MAX */
            i__1 = wrkbl, i__2 = bdspac + *m * 3;
            maxwrk = max(i__1,i__2);
            minwrk = *m * 3 + max(*n,bdspac);
        }
        }
    }
    maxwrk = max(maxwrk,minwrk);
    work[1] = (real) maxwrk;

    // 检查传入的工作数组长度是否小于最小所需工作数组长度，并且不是在查询模式下
    if (*lwork < minwrk && ! lquery) {
        // 设置错误信息为-12，表示工作数组长度不足
        *info = -12;
    }
    }

    // 如果返回的信息不为0，表示有错误发生
    if (*info != 0) {
        // 调用错误处理函数 xerbla_，传入错误信息的负值
        i__1 = -(*info);
        xerbla_("SGESDD", &i__1);
        // 返回0，表示出现错误
        return 0;
    } else if (lquery) {
        // 如果处于查询模式，直接返回0
        return 0;
    }
/*     Quick return if possible */

    // 如果 m 或者 n 为零，则快速返回
    if (*m == 0 || *n == 0) {
    return 0;
    }

/*     Get machine constants */

    // 获取机器常数
    eps = slamch_("P");
    smlnum = sqrt(slamch_("S")) / eps;
    bignum = 1.f / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    // 计算矩阵 A 的范数 anrm
    anrm = slange_("M", m, n, &a[a_offset], lda, dum);
    iscl = 0;
    // 如果 anrm 大于 0 且小于 smlnum，则对 A 进行缩放
    if (anrm > 0.f && anrm < smlnum) {
    iscl = 1;
    // 调用 slascl 函数对 A 进行缩放
    slascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, &
        ierr);
    } else if (anrm > bignum) {
    iscl = 1;
    // 调用 slascl 函数对 A 进行缩放
    slascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, &
        ierr);
    }

    if (*m >= *n) {

/*
          A has at least as many rows as columns. If A has sufficiently
          more rows than columns, first reduce using the QR
          decomposition (if sufficient workspace available)
*/

    // 如果 A 的行数大于等于列数
    if (*m >= mnthr) {

        if (wntqn) {

/*
                Path 1 (M much larger than N, JOBZ='N')
                No singular vectors to be computed
*/

        itau = 1;
        // 设置工作空间的起始位置
        nwork = itau + *n;

/*
                Compute A=Q*R
                (Workspace: need 2*N, prefer N+N*NB)
*/

        // 执行 QR 分解
        i__1 = *lwork - nwork + 1;
        sgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);

/*              Zero out below R */

        // 将 R 的下三角部分置零
        i__1 = *n - 1;
        i__2 = *n - 1;
        slaset_("L", &i__1, &i__2, &c_b29, &c_b29, &a[a_dim1 + 2],
            lda);
        ie = 1;
        itauq = ie + *n;
        itaup = itauq + *n;
        nwork = itaup + *n;

/*
                Bidiagonalize R in A
                (Workspace: need 4*N, prefer 3*N+2*N*NB)
*/

        // 对 R 进行双对角化
        i__1 = *lwork - nwork + 1;
        sgebrd_(n, n, &a[a_offset], lda, &s[1], &work[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);
        nwork = ie + *n;

/*
                Perform bidiagonal SVD, computing singular values only
                (Workspace: need N+BDSPAC)
*/

        // 执行双对角奇异值分解，仅计算奇异值
        sbdsdc_("U", "N", n, &s[1], &work[ie], dum, &c__1, dum, &c__1,
             dum, idum, &work[nwork], &iwork[1], info);

        } else if (wntqo) {

/*
                Path 2 (M much larger than N, JOBZ = 'O')
                N left singular vectors to be overwritten on A and
                N right singular vectors to be computed in VT
*/

        ir = 1;

/*              WORK(IR) is LDWRKR by N */

        // 设置工作空间的起始位置和大小
        if (*lwork >= *lda * *n + *n * *n + *n * 3 + bdspac) {
            ldwrkr = *lda;
        } else {
            ldwrkr = (*lwork - *n * *n - *n * 3 - bdspac) / *n;
        }
        itau = ir + ldwrkr * *n;
        nwork = itau + *n;

/*
                Compute A=Q*R
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/

        // 执行 QR 分解
        i__1 = *lwork - nwork + 1;
        sgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);
/*              将 R 复制到 WORK(IR)，下面部分清零 */

slacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
/* 使用 LAPACK 函数 slacpy 将上三角矩阵 U 部分复制到工作区域 WORK(IR)，ldwrkr 是工作区的 leading dimension */

i__1 = *n - 1;
i__2 = *n - 1;
slaset_("L", &i__1, &i__2, &c_b29, &c_b29, &work[ir + 1], &ldwrkr);
/* 使用 LAPACK 函数 slaset 将下三角矩阵 L 部分清零 */

/*
                在 A 中生成 Q
                (工作区域：需要 N*N+2*N，最好 N*N+N+N*NB)
*/

i__1 = *lwork - nwork + 1;
sorgqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
        &i__1, &ierr);
/* 使用 LAPACK 函数 sorgqr 生成正交矩阵 Q，并存储在 A 中 */

ie = itau;
itauq = ie + *n;
itaup = itauq + *n;
nwork = itaup + *n;

/*
                将 R 在 VT 中进行奇异双对角化，并将结果复制到 WORK(IR)
                (工作区域：需要 N*N+4*N，最好 N*N+3*N+2*N*NB)
*/

i__1 = *lwork - nwork + 1;
sgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &work[ie], &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);
/* 使用 LAPACK 函数 sgebrd 对矩阵 R 进行奇异双对角化，将结果存储在 VT 中，并复制到 WORK(IR) */

/*              WORK(IU) 是一个 N × N 的矩阵 */

iu = nwork;
nwork = iu + *n * *n;

/*
                执行奇异双对角 SVD，计算 R 的左奇异向量存储在 WORK(IU) 中，
                计算 R 的右奇异向量存储在 VT 中
                (工作区域：需要 N+N*N+BDSPAC)
*/

sbdsdc_("U", "I", n, &s[1], &work[ie], &work[iu], n, &vt[vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1], info);
/* 使用 LAPACK 函数 sbdsdc 执行奇异双对角分解，计算 R 的奇异向量 */

/*
                使用 R 的左奇异向量覆盖 WORK(IU)
                使用 R 的右奇异向量覆盖 VT
                (工作区域：需要 2*N*N+3*N，最好 2*N*N+2*N+N*NB)
*/

i__1 = *lwork - nwork + 1;
sormbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[itauq], &work[iu], n, &work[nwork], &i__1, &ierr);
/* 使用 LAPACK 函数 sormbr 生成或应用 Q 矩阵，并存储在 WORK(IU) 中 */

i__1 = *lwork - nwork + 1;
sormbr_("P", "R", "T", n, n, n, &work[ir], &ldwrkr, &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);
/* 使用 LAPACK 函数 sormbr 生成或应用 P 矩阵，并存储在 VT 中 */

/*
                将 A 中的 Q 矩阵与 R 的左奇异向量相乘，将结果存储在 WORK(IR) 中，并复制回 A
                (工作区域：需要 2*N*N，最好 N*N+M*N)
*/

i__1 = *m;
i__2 = ldwrkr;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    /* 计算每次循环的块大小 */
    i__3 = *m - i__ + 1;
    chunk = min(i__3,ldwrkr);
    /* 使用 BLAS 函数 sgemm 计算矩阵乘法 */
    sgemm_("N", "N", &chunk, n, n, &c_b15, &a[i__ + a_dim1], lda, &work[iu], n, &c_b29, &work[ir], &ldwrkr);
    /* 使用 LAPACK 函数 slacpy 将结果复制回 A */
    slacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ + a_dim1], lda);
    /* L10: */
}

} else if (wntqs) {

/*
                Path 3 (M 远大于 N，JOBZ='S')
                在 U 中计算 N 个左奇异向量，
                在 VT 中计算 N 个右奇异向量
*/

ir = 1;

/*              WORK(IR) 是一个 N × N 的矩阵 */

ldwrkr = *n;
itau = ir + ldwrkr * *n;
nwork = itau + *n;
/*
                Compute A=Q*R
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
i__2 = *lwork - nwork + 1;
sgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__2, &ierr);

/*              Copy R to WORK(IR), zeroing out below it */
slacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
i__2 = *n - 1;
i__1 = *n - 1;
slaset_("L", &i__2, &i__1, &c_b29, &c_b29, &work[ir + 1], &
    ldwrkr);

/*
                Generate Q in A
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
i__2 = *lwork - nwork + 1;
sorgqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__2, &ierr);
ie = itau;
itauq = ie + *n;
itaup = itauq + *n;
nwork = itaup + *n;

/*
                Bidiagonalize R in WORK(IR)
                (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*/
i__2 = *lwork - nwork + 1;
sgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__2, &ierr);

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagoal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need N+BDSPAC)
*/
sbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
    vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
    info);

/*
                Overwrite U by left singular vectors of R and VT
                by right singular vectors of R
                (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
*/
i__2 = *lwork - nwork + 1;
sormbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

i__2 = *lwork - nwork + 1;
sormbr_("P", "R", "T", n, n, n, &work[ir], &ldwrkr, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

/*
                Multiply Q in A by left singular vectors of R in
                WORK(IR), storing result in U
                (Workspace: need N*N)
*/
slacpy_("F", n, n, &u[u_offset], ldu, &work[ir], &ldwrkr);
sgemm_("N", "N", m, n, n, &c_b15, &a[a_offset], lda, &work[ir]
    , &ldwrkr, &c_b29, &u[u_offset], ldu);

} else if (wntqa) {

/*
                Path 4 (M much larger than N, JOBZ='A')
                M left singular vectors to be computed in U and
                N right singular vectors to be computed in VT
*/
iu = 1;

/*              WORK(IU) is N by N */
ldwrku = *n;
itau = iu + ldwrku * *n;
nwork = itau + *n;

/*
                Compute A=Q*R, copying result to U
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
/*
        i__2 = *lwork - nwork + 1;
        sgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);
        slacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
*/
        // 对矩阵 A 进行 QR 分解，生成的 Q 存储在 U 中
        // 使用 GEQRF 函数进行 QR 分解，工作区间为 work[itau] 到 work[nwork]
        // 将 A 的左部分复制到 U，工作区间为 work[nwork] 到 *lwork - nwork + 1

/*
                Generate Q in U
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
        // 生成矩阵 Q，并存储在 U 中
        // 使用 SORGQR 函数生成 Q，工作区间为 work[itau] 到 work[nwork]
        // U 的维度是 m × m，n 是 Q 的列数

/*              Produce R in A, zeroing out other entries */
        // 在 A 中生成上三角矩阵 R，并将其他元素置零
        // 使用 SLASET 函数将 A 的下三角部分（非对角线部分）置零

/*
                Bidiagonalize R in A
                (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*/
        // 对 A 进行双对角化处理
        // 使用 SGEBRD 函数进行双对角化，工作区间为 work[ie] 到 work[nwork]

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in WORK(IU) and computing right
                singular vectors of bidiagonal matrix in VT
                (Workspace: need N+N*N+BDSPAC)
*/
        // 对双对角矩阵进行奇异值分解（SVD）
        // 使用 SBSDC 函数进行奇异值分解，计算左奇异向量存储在 WORK(IU) 中，右奇异向量存储在 VT 中

/*
                Overwrite WORK(IU) by left singular vectors of R and VT
                by right singular vectors of R
                (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
*/
        // 使用 SORMBR 函数，通过 R 的左奇异向量覆盖 WORK(IU)，通过 R 的右奇异向量覆盖 VT

/*
                Multiply Q in U by left singular vectors of R in
                WORK(IU), storing result in A
                (Workspace: need N*N)
*/
        // 将 U 中的 Q 乘以 WORK(IU) 中的 R 的左奇异向量，结果存储在 A 中
        // 使用 SGEMM 函数进行矩阵乘法

/*              Copy left singular vectors of A from A to U */
        // 将 A 中的左奇异向量复制到 U 中
        // 使用 SLACPY 函数进行复制操作

/*

             M .LT. MNTHR

             Path 5 (M at least N, but not much larger)
             Reduce to bidiagonal form without QR decomposition
*/

        // 当 M 小于 MNTHR 时，采用双对角化方式而不进行 QR 分解的路径
        // 使用 SGEBRD 函数对 A 进行双对角化处理
/*
    执行双对角奇异值分解（SVD），仅计算奇异值
    （工作空间要求：需要 N+BDSPAC）
*/
sbdsdc_("U", "N", n, &s[1], &work[ie], dum, &c__1, dum, &c__1,
         dum, idum, &work[nwork], &iwork[1], info);
} else if (wntqo) {
iu = nwork;
if (*lwork >= *m * *n + *n * 3 + bdspac) {

    /* WORK( IU ) 是 M 行 N 列 */

    ldwrku = *m;
    nwork = iu + ldwrku * *n;
    slaset_("F", m, n, &c_b29, &c_b29, &work[iu], &ldwrku);
} else {

    /* WORK( IU ) 是 N 行 N 列 */

    ldwrku = *n;
    nwork = iu + ldwrku * *n;

    /* WORK(IR) 是 LDWRKR 行 N 列 */

    ir = nwork;
    ldwrkr = (*lwork - *n * *n - *n * 3) / *n;
}
nwork = iu + ldwrku * *n;

/*
    执行双对角奇异值分解，计算双对角矩阵的左奇异向量存储在 WORK(IU) 中，
    右奇异向量存储在 VT 中
    （工作空间要求：需要 N+N*N+BDSPAC）
*/
sbdsdc_("U", "I", n, &s[1], &work[ie], &work[iu], &ldwrku, &
    vt[vt_offset], ldvt, dum, idum, &work[nwork], &iwork[
    1], info);

/*
    用 A 的右奇异向量覆盖 VT
    （工作空间要求：需要 N*N+2*N，更倾向于 N*N+N+N*NB）
*/
i__2 = *lwork - nwork + 1;
sormbr_("P", "R", "T", n, n, n, &a[a_offset], lda, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

if (*lwork >= *m * *n + *n * 3 + bdspac) {

    /*
       用 A 的左奇异向量覆盖 WORK(IU)
       （工作空间要求：需要 N*N+2*N，更倾向于 N*N+N+N*NB）
    */
    i__2 = *lwork - nwork + 1;
    sormbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
        itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &
        ierr);

    /* 将 A 的左奇异向量从 WORK(IU) 复制到 A */
    slacpy_("F", m, n, &work[iu], &ldwrku, &a[a_offset], lda);
} else {

    /*
       在 A 中生成 Q
       （工作空间要求：需要 N*N+2*N，更倾向于 N*N+N+N*NB）
    */
    i__2 = *lwork - nwork + 1;
    sorgbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &
        work[nwork], &i__2, &ierr);

    /*
       将 A 中的 Q 乘以 WORK(IU) 中的双对角矩阵的左奇异向量，
       结果存储在 WORK(IR) 中，并复制到 A
       （工作空间要求：需要 2*N*N，更倾向于 N*N+M*N）
    */
    i__2 = *m;
    i__1 = ldwrkr;
    for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
         i__1) {
/* Computing MIN */
            i__3 = *m - i__ + 1;
            chunk = min(i__3,ldwrkr);
            sgemm_("N", "N", &chunk, n, n, &c_b15, &a[i__ +
                a_dim1], lda, &work[iu], &ldwrku, &c_b29, &
                work[ir], &ldwrkr);
            slacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ +
                a_dim1], lda);
/* L20: */
            }
        }

        } else if (wntqs) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need N+BDSPAC)
*/

        slaset_("F", m, n, &c_b29, &c_b29, &u[u_offset], ldu);
        sbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*
                Overwrite U by left singular vectors of A and VT
                by right singular vectors of A
                (Workspace: need 3*N, prefer 2*N+N*NB)
*/

        i__1 = *lwork - nwork + 1;
        sormbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        i__1 = *lwork - nwork + 1;
        sormbr_("P", "R", "T", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        } else if (wntqa) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need N+BDSPAC)
*/

        slaset_("F", m, m, &c_b29, &c_b29, &u[u_offset], ldu);
        sbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*              Set the right corner of U to identity matrix */

        if (*m > *n) {
            i__1 = *m - *n;
            i__2 = *m - *n;
            slaset_("F", &i__1, &i__2, &c_b29, &c_b15, &u[*n + 1 + (*
                n + 1) * u_dim1], ldu);
        }

/*
                Overwrite U by left singular vectors of A and VT
                by right singular vectors of A
                (Workspace: need N*N+2*N+M, prefer N*N+2*N+M*NB)
*/

        i__1 = *lwork - nwork + 1;
        sormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        i__1 = *lwork - nwork + 1;
        sormbr_("P", "R", "T", n, n, m, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        }

    }

    } else {

/*
          A has more columns than rows. If A has sufficiently more
          columns than rows, first reduce using the LQ decomposition (if
          sufficient workspace available)
*/

    if (*n >= mnthr) {

        if (wntqn) {

/*
                Perform LQ decomposition, computing left orthogonal matrix
                of A in U and computing right orthogonal matrix of A
                in VT
                (Workspace: need M+M*M)
*/
/*
        Path 1t (N much larger than M, JOBZ='N')
        No singular vectors to be computed
*/

// 设置 itau 的初始值为 1，用于存储工作空间中的偏移量
itau = 1;
// 计算所需工作空间的大小，包括 itau 和 *m 的存储空间
nwork = itau + *m;

/*
        Compute A=L*Q
        (Workspace: need 2*M, prefer M+M*NB)
*/

// 计算 LQ 分解，将结果存储在 A 中
i__1 = *lwork - nwork + 1;
sgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__1, &ierr);

/*      
        Zero out above L
*/

// 将 L 的上三角部分置零
i__1 = *m - 1;
i__2 = *m - 1;
slaset_("U", &i__1, &i__2, &c_b29, &c_b29, &a[(a_dim1 << 1) +
    1], lda);
// 初始化 ie 为 1，用于存储工作空间中的偏移量
ie = 1;
// 设置 itauq 和 itaup 的初始值，用于存储工作空间中的偏移量
itauq = ie + *m;
itaup = itauq + *m;
// 更新 nwork，用于存储工作空间中的偏移量
nwork = itaup + *m;

/*
        Bidiagonalize L in A
        (Workspace: need 4*M, prefer 3*M+2*M*NB)
*/

// 对 A 中的 L 进行双对角化处理
i__1 = *lwork - nwork + 1;
sgebrd_(m, m, &a[a_offset], lda, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__1, &ierr);
// 更新 nwork，用于存储工作空间中的偏移量
nwork = ie + *m;

/*
        Perform bidiagonal SVD, computing singular values only
        (Workspace: need M+BDSPAC)
*/

// 执行双对角奇异值分解，仅计算奇异值
sbdsdc_("U", "N", m, &s[1], &work[ie], dum, &c__1, dum, &c__1,
     dum, idum, &work[nwork], &iwork[1], info);

} else if (wntqo) {

/*
        Path 2t (N much larger than M, JOBZ='O')
        M right singular vectors to be overwritten on A and
        M left singular vectors to be computed in U
*/

// 设置 ivt 的初始值为 1，用于存储右奇异向量的存储空间
ivt = 1;

/*      
        IVT is M by M
*/

// 计算 il 的位置，用于存储工作空间中 L 的复制
il = ivt + *m * *m;
// 根据工作空间的可用大小来设置 ldwrkl 和 chunk 的值
if (*lwork >= *m * *n + *m * *m + *m * 3 + bdspac) {

/*             
        WORK(IL) is M by N
*/

// 当工作空间足够大时，设置 ldwrkl 和 chunk 的值
ldwrkl = *m;
chunk = *n;
} else {
// 当工作空间不足时，重新计算 ldwrkl 和 chunk 的值
ldwrkl = *m;
chunk = (*lwork - *m * *m) / *m;
}
// 设置 itau 的初始值，用于存储工作空间中的偏移量
itau = il + ldwrkl * *m;
// 更新 nwork，用于存储工作空间中的偏移量
nwork = itau + *m;

/*
        Compute A=L*Q
        (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

// 计算 LQ 分解，将结果存储在 A 中
i__1 = *lwork - nwork + 1;
sgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__1, &ierr);

/*      
        Copy L to WORK(IL), zeroing about above it
*/

// 将 L 复制到 WORK(IL)，同时将其上方置零
slacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
i__1 = *m - 1;
i__2 = *m - 1;
slaset_("U", &i__1, &i__2, &c_b29, &c_b29, &work[il + ldwrkl],
     &ldwrkl);

/*
        Generate Q in A
        (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

// 生成 Q 矩阵，并存储在 A 中
i__1 = *lwork - nwork + 1;
sorglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__1, &ierr);
// 更新 ie 的值，用于存储工作空间中的偏移量
ie = itau;
// 设置 itauq 和 itaup 的初始值，用于存储工作空间中的偏移量
itauq = ie + *m;
itaup = itauq + *m;
// 更新 nwork，用于存储工作空间中的偏移量
nwork = itaup + *m;

/*
        Bidiagonalize L in WORK(IL)
        (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*/

// 对 WORK(IL) 中的 L 进行双对角化处理
i__1 = *lwork - nwork + 1;
sgebrd_(m, m, &work[il], &ldwrkl, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__1, &ierr);
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U, and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M+M*M+BDSPAC)
*/

sbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
    work[ivt], m, dum, idum, &work[nwork], &iwork[1],
    info);

/*
                Overwrite U by left singular vectors of L and WORK(IVT)
                by right singular vectors of L
                (Workspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
*/

i__1 = *lwork - nwork + 1;
sormbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
i__1 = *lwork - nwork + 1;
sormbr_("P", "R", "T", m, m, m, &work[il], &ldwrkl, &work[
    itaup], &work[ivt], m, &work[nwork], &i__1, &ierr);

/*
                Multiply right singular vectors of L in WORK(IVT) by Q
                in A, storing result in WORK(IL) and copying to A
                (Workspace: need 2*M*M, prefer M*M+M*N)
*/

i__1 = *n;
i__2 = chunk;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
    i__2) {
    /* Computing MIN */
    i__3 = *n - i__ + 1;
    blk = min(i__3,chunk);
    sgemm_("N", "N", m, &blk, m, &c_b15, &work[ivt], m, &a[
        i__ * a_dim1 + 1], lda, &c_b29, &work[il], &
        ldwrkl);
    slacpy_("F", m, &blk, &work[il], &ldwrkl, &a[i__ * a_dim1
        + 1], lda);
    /* L30: */
}

} else if (wntqs) {

/*
                Path 3t (N much larger than M, JOBZ='S')
                M right singular vectors to be computed in VT and
                M left singular vectors to be computed in U
*/

il = 1;

/*              WORK(IL) is M by M */

ldwrkl = *m;
itau = il + ldwrkl * *m;
nwork = itau + *m;

/*
                Compute A=L*Q
                (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

i__2 = *lwork - nwork + 1;
sgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__2, &ierr);

/*              Copy L to WORK(IL), zeroing out above it */

slacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
i__2 = *m - 1;
i__1 = *m - 1;
slaset_("U", &i__2, &i__1, &c_b29, &c_b29, &work[il + ldwrkl],
     &ldwrkl);

/*
                Generate Q in A
                (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

i__2 = *lwork - nwork + 1;
sorglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__2, &ierr);
ie = itau;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
                Bidiagonalize L in WORK(IU), copying result to U
                (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*/
/*
        i__2 = *lwork - nwork + 1;
        sgebrd_(m, m, &work[il], &ldwrkl, &s[1], &work[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
*/
        // 对矩阵进行双对角化分解，使用 sgebrd 函数
        // 输入参数:
        //   - m: 矩阵的行数和列数
        //   - &work[il]: 输入矩阵的起始地址
        //   - &ldwrkl: 左工作矩阵的列数
        //   - &s[1]: 存储双对角矩阵的对角元素
        //   - &work[ie]: 存储双对角矩阵的超对角元素
        //   - &work[itauq], &work[itaup]: 存储用于生成矩阵 Q 的数据
        //   - &work[nwork]: 工作空间
        //   - &i__2: 工作空间的长度
        // 输出参数:
        //   - &s[1]: 更新为双对角矩阵的对角元素
        //   - &work[ie]: 更新为双对角矩阵的超对角元素
        //   - &work[itauq], &work[itaup]: 存储用于生成矩阵 Q 的数据更新
        //   - ierr: 函数执行状态指示符

/*
        sbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);
*/
        // 执行双对角奇异值分解 (SVD)，计算双对角矩阵的左奇异向量存储在 U 中，
        // 右奇异向量存储在 VT 中，使用 sbdsdc 函数
        // 输入参数:
        //   - "U", "I": 指定计算左奇异向量和指示只计算精确奇异值
        //   - m: 矩阵的行数和列数
        //   - &s[1]: 双对角矩阵的对角元素
        //   - &work[ie]: 双对角矩阵的超对角元素
        //   - &u[u_offset], &vt[vt_offset]: 存储左奇异向量和右奇异向量的矩阵
        //   - ldu, ldvt: U 和 VT 的列数
        //   - dum, idum: 临时变量
        //   - &work[nwork]: 工作空间
        //   - &iwork[1]: 存储整数工作空间
        // 输出参数:
        //   - &u[u_offset]: 更新为左奇异向量
        //   - &vt[vt_offset]: 更新为右奇异向量
        //   - info: 函数执行状态指示符

/*
        sormbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
        sormbr_("P", "R", "T", m, m, m, &work[il], &ldwrkl, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);
*/
        // 根据存储在 work[il] 中的数据生成矩阵 Q 和 P，使用 sormbr 函数
        // 输入参数:
        //   - "Q", "P": 指定生成的矩阵类型
        //   - "L", "R", "N", "T": 控制操作的方向和转置选项
        //   - m: 矩阵的行数和列数
        //   - &work[il]: 存储生成矩阵的数据
        //   - &ldwrkl: 左工作矩阵的列数
        //   - &work[itauq], &work[itaup]: 存储用于生成矩阵 Q 和 P 的数据
        //   - &u[u_offset], &vt[vt_offset]: 存储左奇异向量和右奇异向量的矩阵
        //   - ldu, ldvt: U 和 VT 的列数
        //   - &work[nwork]: 工作空间
        //   - &i__2: 工作空间的长度
        // 输出参数:
        //   - &u[u_offset]: 更新为左奇异向量
        //   - &vt[vt_offset]: 更新为右奇异向量
        //   - ierr: 函数执行状态指示符

/*
        slacpy_("F", m, m, &vt[vt_offset], ldvt, &work[il], &ldwrkl);
        sgemm_("N", "N", m, n, m, &c_b15, &work[il], &ldwrkl, &a[
            a_offset], lda, &c_b29, &vt[vt_offset], ldvt);
*/
        // 计算矩阵乘法，将生成的右奇异向量与矩阵 A 相乘，结果存储在 VT 中，使用 sgemm 函数
        // 输入参数:
        //   - "N", "N": 指定矩阵 A 和 work[il] 不进行转置
        //   - m, n: 矩阵的行数和列数
        //   - &c_b15: 标量乘法因子
        //   - &work[il], &a[a_offset]: 参与乘法的矩阵
        //   - &ldwrkl, lda: 左工作矩阵和矩阵 A 的列数
        //   - &vt[vt_offset]: 存储乘法结果的矩阵
        //   - ldvt: VT 的列数
        //   - &c_b29: 标量乘法因子
        // 输出参数:
        //   - &vt[vt_offset]: 更新为乘法结果

/*
        } else if (wntqa) {
*/
        // 如果 wntqa 为真，则执行以下代码块，否则跳过
        // wntqa 控制路径选择的逻辑条件

/*
        i__2 = *lwork - nwork + 1;
        sgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);
*/
        // 对矩阵 A 进行 LQ 分解，使用 sgelqf 函数
        // 输入参数:
        //   - m, n: 矩阵 A 的行数和列数
        //   - &a[a_offset]: 输入矩阵 A 的起始地址
        //   - lda: 矩阵 A 的列数
        //   - &work[itau], &work[nwork]: 存储分解过程中的中间数据
        //   - &i__2: 工作空间的长度
        // 输出参数:
        //   - &a[a_offset]: 更新为矩阵 L

/*
        sorglq_(n, n, m, &vt[vt_offset], ldvt, &work[itau], &work[
            nwork], &i__2, &ierr);
*/
        // 使用 sorglq 函数生成矩阵 Q，存储在 VT 中
        // 输入参数:
        //   - n, n: 生成矩阵的行数和列数
        //   - m: 矩阵 A 的行数和列数
        //   - &vt[vt_offset]: 存储生成矩阵的地址
        //   - ldvt: VT 的列数
        //   - &work[itau], &work[nwork]: 存储生成矩阵 Q 过程中的中间数据
        //   - &i__2: 工作空间的长度
        // 输出参数
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M+M*M+BDSPAC)
*/
sbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
    work[ivt], &ldwkvt, dum, idum, &work[nwork], &iwork[1]
    , info);

/*
                Overwrite U by left singular vectors of L and WORK(IVT)
                by right singular vectors of L
                (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
*/
i__2 = *lwork - nwork + 1;
sormbr_("Q", "L", "N", m, m, m, &a[a_offset], lda, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
i__2 = *lwork - nwork + 1;
sormbr_("P", "R", "T", m, m, m, &a[a_offset], lda, &work[
    itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &
    ierr);

/*
                Multiply right singular vectors of L in WORK(IVT) by
                Q in VT, storing result in A
                (Workspace: need M*M)
*/
sgemm_("N", "N", m, n, m, &c_b15, &work[ivt], &ldwkvt, &vt[
    vt_offset], ldvt, &c_b29, &a[a_offset], lda);

/*
                Copy right singular vectors of A from A to VT
*/
slacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

}

} else {

/*
             N .LT. MNTHR

             Path 5t (N greater than M, but not much larger)
             Reduce to bidiagonal form without LQ decomposition
*/

ie = 1;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
             Bidiagonalize A
             (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*/
i__2 = *lwork - nwork + 1;
sgebrd_(m, n, &a[a_offset], lda, &s[1], &work[ie], &work[itauq], &
    work[itaup], &work[nwork], &i__2, &ierr);
if (wntqn) {

/*
                Perform bidiagonal SVD, only computing singular values
                (Workspace: need M+BDSPAC)
*/
sbdsdc_("L", "N", m, &s[1], &work[ie], dum, &c__1, dum, &c__1,
     dum, idum, &work[nwork], &iwork[1], info);
} else if (wntqo) {
ldwkvt = *m;
ivt = nwork;
if (*lwork >= *m * *n + *m * 3 + bdspac) {

/*                 WORK( IVT ) is M by N */
slaset_("F", m, n, &c_b29, &c_b29, &work[ivt], &ldwkvt);
nwork = ivt + ldwkvt * *n;
} else {

/*                 WORK( IVT ) is M by M */
nwork = ivt + ldwkvt * *m;
il = nwork;

/*                 WORK(IL) is M by CHUNK */
chunk = (*lwork - *m * *m - *m * 3) / *m;
}

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M*M+BDSPAC)
*/
/*

        sbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
            work[ivt], &ldwkvt, dum, idum, &work[nwork], &iwork[1]
            , info);

/*
                Overwrite U by left singular vectors of A
                (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

这段代码使用 LAPACK 函数 `sbdsdc` 对一个双对角矩阵进行奇异值分解，计算左奇异向量并存储在矩阵 U 中。


        i__2 = *lwork - nwork + 1;
        sormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

这段代码利用 LAPACK 函数 `sormbr`，基于之前的分解结果，计算并存储矩阵 A 的左奇异向量到矩阵 U 中。


        if (*lwork >= *m * *n + *m * 3 + bdspac) {

/*
                   Overwrite WORK(IVT) by left singular vectors of A
                   (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

这个条件块检查工作空间是否足够大，如果足够大，利用 LAPACK 函数 `sormbr` 计算并存储矩阵 A 的左奇异向量到工作数组 `work[ivt]` 中。


            i__2 = *lwork - nwork + 1;
            sormbr_("P", "R", "T", m, n, m, &a[a_offset], lda, &work[
                itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2,
                &ierr);

/*                 Copy right singular vectors of A from WORK(IVT) to A */

            slacpy_("F", m, n, &work[ivt], &ldwkvt, &a[a_offset], lda);

这段代码根据之前计算得到的右奇异向量（存储在 `work[ivt]` 中），将其复制回矩阵 A。


        } else {

/*
                   Generate P**T in A
                   (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/

如果工作空间不够大，这个条件块生成矩阵 A 的转置 P**T，利用 LAPACK 函数 `sorgbr`。


            i__2 = *lwork - nwork + 1;
            sorgbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &
                work[nwork], &i__2, &ierr);

这段代码计算并存储矩阵 A 的转置 P**T。


            i__2 = *n;
            i__1 = chunk;
            for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
                 i__1) {
/* Computing MIN */
            i__3 = *n - i__ + 1;
            blk = min(i__3,chunk);
            sgemm_("N", "N", m, &blk, m, &c_b15, &work[ivt], &
                ldwkvt, &a[i__ * a_dim1 + 1], lda, &c_b29, &
                work[il], m);
            slacpy_("F", m, &blk, &work[il], m, &a[i__ * a_dim1 +
                1], lda);
/* L40: */
            }

这个循环用 LAPACK 函数 `sgemm` 计算矩阵乘积，并将结果复制回矩阵 A。


        } else if (wntqs) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need M+BDSPAC)
*/

这段代码执行双对角奇异值分解（SVD），计算双对角矩阵的左奇异向量存储在矩阵 U 中，右奇异向量存储在矩阵 VT 中。


        slaset_("F", m, n, &c_b29, &c_b29, &vt[vt_offset], ldvt);
        sbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

这段代码使用 LAPACK 函数 `slaset` 和 `sbdsdc` 完成双对角 SVD 的计算。


/*
                Overwrite U by left singular vectors of A and VT
                by right singular vectors of A
                (Workspace: need 3*M, prefer 2*M+M*NB)
*/

这个条件块根据之前的 SVD 结果，用 LAPACK 函数 `sormbr` 计算并存储矩阵 A 的左奇异向量到 U 中，右奇异向量到 VT 中。
/* Subroutine */ int sgesv_(integer *n, integer *nrhs, real *a, integer *lda,
    integer *ipiv, real *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    extern /* Subroutine */ int xerbla_(char *, integer *), sgetrf_(
        integer *, integer *, real *, integer *, integer *, integer *),
        sgetrs_(char *, integer *, integer *, real *, integer *, integer *
        , real *, integer *, integer *);


/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGESV computes the solution to a real system of linear equations
       A * X = B,
*/

    /* Declarations */

    /* Parameters */
    /* Table of constant values */
    static real c_b29 = 0.f;
    static real c_b15 = 1.f;

    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static real dum[1];
    static integer idum[1], ierr;
    static real work[1];
    static integer nwork;
    static real smlnum, bignum;
    static integer minmn;
    static real anrm;
    static logical wntqa;

    /* Function Body */

    if (*n == 0 || *nrhs == 0) {
        *info = 0;
        return 0;
    }

    /* Test the input parameters. */

    *info = 0;

    if (*n < 0) {
        *info = -1;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*ldb < max(1,*n)) {
        *info = -7;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SGESV ", &i__1);
        return 0;
    }

/*
    Quick return if possible
*/

    if (*n == 0) {
        return 0;
    }

/*     Determine the block size for this environment. */

    wntqa = lsame_(jobq, "Q");
    nwork = *lwork - nwork + 1;
    sormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
        itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
    sormbr_("P", "R", "T", m, n, m, &a[a_offset], lda, &work[
        itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
        ierr);

    if (wntqa) {

/*
        Perform bidiagonal SVD, computing left singular vectors
        of bidiagonal matrix in U and computing right singular
        vectors of bidiagonal matrix in VT
        (Workspace: need M+BDSPAC)
*/

        slaset_("F", n, n, &c_b29, &c_b29, &vt[vt_offset], ldvt);
        sbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*      Set the right corner of VT to identity matrix */

        if (*n > *m) {
            i__1 = *n - *m;
            i__2 = *n - *m;
            slaset_("F", &i__1, &i__2, &c_b29, &c_b15, &vt[*m + 1 + (*
                m + 1) * vt_dim1], ldvt);
        }

/*
        Overwrite U by left singular vectors of A and VT
        by right singular vectors of A
        (Workspace: need 2*M+N, prefer 2*M+N*NB)
*/

        sormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        sormbr_("P", "R", "T", n, n, m, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
    }

}

/*     Undo scaling if necessary */

if (iscl == 1) {
if (anrm > bignum) {
    slascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
        minmn, &ierr);
}
if (anrm < smlnum) {
    slascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &
        minmn, &ierr);
}
}

/*     Return optimal workspace in WORK(1) */

work[1] = (real) maxwrk;

return 0;

/*     End of SGESDD */

} /* sgesdd_ */


注释：
    # 测试输入参数的合法性，确保参数的值符合预期要求
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    if (*n < 0) {  // 检查参数 n 是否小于 0
    *info = -1;  // 如果是，设置 info 为 -1
    } else if (*nrhs < 0) {  // 检查参数 nrhs 是否小于 0
    *info = -2;  // 如果是，设置 info 为 -2
    } else if (*lda < max(1,*n)) {  // 检查参数 lda 是否小于 max(1, n)
    *info = -4;  // 如果是，设置 info 为 -4
    } else if (*ldb < max(1,*n)) {  // 检查参数 ldb 是否小于 max(1, n)
    *info = -7;  // 如果是，设置 info 为 -7
    }
    if (*info != 0) {  // 如果 info 不等于 0，则表示参数错误
    i__1 = -(*info);
    xerbla_("SGESV ", &i__1);  // 调用错误处理函数 xerbla_
    return 0;  // 返回 0，结束函数
    }

/*     Compute the LU factorization of A. */

    sgetrf_(n, n, &a[a_offset], lda, &ipiv[1], info);  // 计算矩阵 A 的 LU 分解

    if (*info == 0) {  // 如果 info 为 0，表示 LU 分解成功

/*        Solve the system A*X = B, overwriting B with X. */

    sgetrs_("No transpose", n, nrhs, &a[a_offset], lda, &ipiv[1], &b[
        b_offset], ldb, info);  // 解线性方程组 A*X = B
    }

    return 0;

/*     End of SGESV */

} /* sgesv_ */

/* Subroutine */ int sgetf2_(integer *m, integer *n, real *a, integer *lda,
    integer *ipiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    real r__1;

    /* Local variables */
    static integer i__, j, jp;
    extern /* Subroutine */ int sger_(integer *, integer *, real *, real *,
        integer *, real *, integer *, real *, integer *), sscal_(integer *
        , real *, real *, integer *);
    static real sfmin;
    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *,
        integer *);
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer isamax_(integer *, real *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGETF2 computes an LU factorization of a general m-by-n matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 2 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
    # INFO 是一个整数参数，表示函数的返回状态：
    # = 0: 成功退出
    # < 0: 如果 INFO = -k，表示第 k 个参数有非法值
    # > 0: 如果 INFO = k，表示矩阵分解过程中第 k 行、第 k 列的元素 U(k,k) 恰好为零。
    #      分解已完成，但因为矩阵 U 是奇异的，如果用它来解方程组会出现除以零的情况。

    =====================================================================

    # 测试输入参数的合法性。
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--ipiv;

// 参数调整：设置矩阵A的维度和偏移量，将指针a和ipiv向前移动，以便正确访问数组元素。

/* Function Body */
*info = 0;
if (*m < 0) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*lda < max(1,*m)) {
*info = -4;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("SGETF2", &i__1);
return 0;
}

// 设置info为0，检查m、n和lda的值是否满足要求，不满足时设置相应的错误码并调用xerbla处理。
// 如果info非零，说明有错误发生，返回0。

/* Quick return if possible */
if (*m == 0 || *n == 0) {
return 0;
}

// 如果m或者n为0，直接返回，不进行计算。

/* Compute machine safe minimum */
sfmin = slamch_("S");

// 计算机器精度安全下界，存储在sfmin中。

i__1 = min(*m,*n);
for (j = 1; j <= i__1; ++j) {

// 对于行数m和列数n的最小值开始循环，执行高斯消元的主要循环。

/* Find pivot and test for singularity. */
i__2 = *m - j + 1;
jp = j - 1 + isamax_(&i__2, &a[j + j * a_dim1], &c__1);
ipiv[j] = jp;
if (a[jp + j * a_dim1] != 0.f) {

// 找到主元并检测是否为奇异。

/* Apply the interchange to columns 1:N. */
if (jp != j) {
sswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);
}

// 对列1到N应用交换操作，保证主元在对角线上。

/* Compute elements J+1:M of J-th column. */
if (j < *m) {
if ((r__1 = a[j + j * a_dim1], dabs(r__1)) >= sfmin) {
i__2 = *m - j;
r__1 = 1.f / a[j + j * a_dim1];
sscal_(&i__2, &r__1, &a[j + 1 + j * a_dim1], &c__1);
} else {
i__2 = *m - j;
for (i__ = 1; i__ <= i__2; ++i__) {
a[j + i__ + j * a_dim1] /= a[j + j * a_dim1];
}
}
}

// 计算第J列的J+1到M元素，进行归一化操作以确保数值稳定性。

} else if (*info == 0) {
*info = j;
}

// 如果主元为零且没有之前的错误信息，记录此处的列号J为错误信息。

if (j < min(*m,*n)) {

// 如果J小于m和n的最小值，更新尾部子矩阵。

i__2 = *m - j;
i__3 = *n - j;
sger_(&i__2, &i__3, &c_b151, &a[j + 1 + j * a_dim1], &c__1, &a[j
+ (j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1],
lda);
}
/* L10: */
}
return 0;

// 主循环结束，返回0表示成功执行。

/* End of SGETF2 */
} /* sgetf2_ */

// SGETF2过程结束

/* Subroutine */ int sgetrf_(integer *m, integer *n, real *a, integer *lda,
integer *ipiv, integer *info)
{

// 进入sgetrf_子程序，对m行n列的实数矩阵a进行LU分解。

/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;

// 系统生成的本地变量声明，包括矩阵a的维度信息。

/* Local variables */
static integer i__, j, jb, nb, iinfo;
extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
integer *, real *, real *, integer *, real *, integer *, real *,
real *, integer *), strsm_(char *, char *, char *,
char *, integer *, integer *, real *, real *, integer *, real *,
integer *), sgetf2_(integer *,
integer *, real *, integer *, integer *, integer *), xerbla_(char
*, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int slaswp_(integer *, real *, integer *, integer
*, integer *, integer *, integer *);

// 声明局部变量和外部子程序，用于后续的矩阵运算和异常处理。

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006

// LAPACK例程的版本信息和提供者说明。

// 这些注释可以帮助理解代码中每个步骤的目的和实现方法，有助于程序员更好地理解和维护代码。
    =======

    SGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.

    =====================================================================


       Test the input parameters.


注释：
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

参数调整：


    /* Function Body */
    *info = 0;
    if (*m < 0) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*lda < max(1,*m)) {
    *info = -4;
    }

函数体：


    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SGETRF", &i__1);
    return 0;
    }

如果出错返回：


/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
    return 0;
    }

如果快速返回：


/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "SGETRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)
        1);
    if (nb <= 1 || nb >= min(*m,*n)) {

确定环境的块大小：


/*        Use unblocked code. */

    sgetf2_(m, n, &a[a_offset], lda, &ipiv[1], info);
    } else {

使用未块化代码：


/*        Use blocked code. */

    i__1 = min(*m,*n);
    i__2 = nb;
    for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
        i__3 = min(*m,*n) - j + 1;
        jb = min(i__3,nb);

/*
             Factor diagonal and subdiagonal blocks and test for exact
             singularity.
*/

        i__3 = *m - j + 1;
        sgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);

/*           Adjust INFO and the pivot indices. */

        if (*info == 0 && iinfo > 0) {
        *info = iinfo + j - 1;
        }
/* Computing MIN */
        i__4 = *m, i__5 = j + jb - 1;
        i__3 = min(i__4,i__5);
        for (i__ = j; i__ <= i__3; ++i__) {
        ipiv[i__] = j - 1 + ipiv[i__];
/* L10: */
        }

使用块化代码：


/*           Apply interchanges to columns 1:J-1. */

        i__3 = j - 1;
        i__4 = j + jb - 1;
        slaswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);

        if (j + jb <= *n) {

/*              Apply interchanges to columns J+JB:N. */

        i__3 = *n - j - jb + 1;
        i__4 = j + jb - 1;
        slaswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
            ipiv[1], &c__1);

/*              Compute block row of U. */

        i__3 = *n - j - jb + 1;
        strsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
            c_b15, &a[j + j * a_dim1], lda, &a[j + (j + jb) *
            a_dim1], lda);
        if (j + jb <= *m) {

/*                 Update trailing submatrix. */

            i__3 = *m - j - jb + 1;
            i__4 = *n - j - jb + 1;
            sgemm_("No transpose", "No transpose", &i__3, &i__4, &jb,
                &c_b151, &a[j + jb + j * a_dim1], lda, &a[j + (j
                + jb) * a_dim1], lda, &c_b15, &a[j + jb + (j + jb)
                 * a_dim1], lda);
        }
        }
/* L20: */
    }
    }
    return 0;

/*     End of SGETRF */

} /* sgetrf_ */

/* Subroutine */ int sgetrs_(char *trans, integer *n, integer *nrhs, real *a,
    integer *lda, integer *ipiv, real *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    extern logical lsame_(char *, char *);
    # 声明外部子程序 `strsm_` 和 `xerbla_`，它们的参数类型和顺序如下：
    # - `char *`: 字符串指针（传递字符参数）
    # - `integer *`: 整数指针（传递整数参数）
    # - `real *`: 实数指针（传递实数参数）
    # 具体说明如下：
    # - `strsm_`: 执行矩阵除法，参数包括矩阵类型、矩阵转置类型、三角矩阵类型等。
    # - `xerbla_`: 处理错误信息，参数包括错误信息字符串和错误代码。
    extern /* Subroutine */ int strsm_(char *, char *, char *, char *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        ), xerbla_(char *, integer *);

    # 声明静态逻辑变量 `notran`，用于表示逻辑状态
    static logical notran;

    # 声明外部子程序 `slaswp_`，它的参数类型和顺序如下：
    # - `integer *`: 整数指针（传递整数参数）
    # - `real *`: 实数指针（传递实数参数）
    # 具体说明如下：
    # - `slaswp_`: 执行矩阵列交换，参数包括矩阵维度、需要交换的列索引等。
    extern /* Subroutine */ int slaswp_(integer *, real *, integer *, integer
        *, integer *, integer *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SGETRS solves a system of linear equations
       A * X = B  or  A' * X = B
    with a general N-by-N matrix A using the LU factorization computed
    by SGETRF.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A'* X = B  (Transpose)
            = 'C':  A'* X = B  (Conjugate transpose = Transpose)

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input) REAL array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by SGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from SGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    notran = lsame_(trans, "N");
    if (! notran && ! lsame_(trans, "T") && ! lsame_(
        trans, "C")) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*nrhs < 0) {
    *info = -3;
    } else if (*lda < max(1,*n)) {
    *info = -5;
    } else if (*ldb < max(1,*n)) {
    *info = -8;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SGETRS", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {
    return 0;
    }

    if (notran) {

/*
          Solve A * X = B.

          Apply row interchanges to the right hand sides.
*/

    slaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c__1);

/*        Solve L*X = B, overwriting B with X. */

    strsm_("Left", "Lower", "No transpose", "Unit", n, nrhs, &c_b15, &a[
        a_offset], lda, &b[b_offset], ldb);

/*        Solve U*X = B, overwriting B with X. */
    strsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b15, &a[
        a_offset], lda, &b[b_offset], ldb);
    strsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b15, &
        a[a_offset], lda, &b[b_offset], ldb);
    # 调用外部函数 `strsm_`，执行矩阵运算，解方程 Left * Upper = b，其中参数含义依次为：
    # - "Left": 左侧矩阵为 a
    # - "Upper": 上三角矩阵
    # - "No transpose": 不对矩阵进行转置操作
    # - "Non-unit": 非单位对角线元素
    # - n: 矩阵维度
    # - nrhs: 右侧矩阵 b 的列数
    # - &c_b15: 缩放因子
    # - &a[a_offset]: 左侧矩阵 a 的起始地址
    # - lda: 左侧矩阵 a 的列步长
    # - &b[b_offset]: 右侧矩阵 b 的起始地址
    # - ldb: 右侧矩阵 b 的列步长
    } else {
/*
          Solve A' * X = B.

          Solve U'*X = B, overwriting B with X.
*/
strsm_("Left", "Upper", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);
/*
        Solve L'*X = B, overwriting B with X.
*/
strsm_("Left", "Lower", "Transpose", "Unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);
/*
        Apply row interchanges to the solution vectors.
*/
slaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c_n1);
}

return 0;

/*     End of SGETRS */

} /* sgetrs_ */

/* Subroutine */ int shseqr_(char *job, char *compz, integer *n, integer *ilo,
     integer *ihi, real *h__, integer *ldh, real *wr, real *wi, real *z__,
     integer *ldz, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2[2], i__3;
    real r__1;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static real hl[2401]    /* was [49][49] */;
    static integer kbot, nmin;
    extern logical lsame_(char *, char *);
    static logical initz;
    static real workl[49];
    static logical wantt, wantz;
    extern /* Subroutine */ int slaqr0_(logical *, logical *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , integer *, real *, integer *, real *, integer *, integer *),
        xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slahqr_(logical *, logical *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , integer *, real *, integer *, integer *), slacpy_(char *,
        integer *, integer *, real *, integer *, real *, integer *), slaset_(char *, integer *, integer *, real *, real *,
        real *, integer *);
    static logical lquery;


/*
*/

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    wantt = lsame_(job, "S");
    initz = lsame_(compz, "I");
    wantz = initz || lsame_(compz, "V");
    work[1] = (real) max(1,*n);
    lquery = *lwork == -1;

    *info = 0;
    if (! lsame_(job, "E") && ! wantt) {
    *info = -1;
    } else if (! lsame_(compz, "N") && ! wantz) {
    *info = -2;
    } else if (*n < 0) {
    *info = -3;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
    *info = -4;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
    *info = -5;
    } else if (*ldh < max(1,*n)) {
    *info = -7;
    } else if (*ldz < 1 || wantz && *ldz < max(1,*n)) {
    *info = -11;
    } else if (*lwork < max(1,*n) && ! lquery) {
    *info = -13;
    }

    if (*info != 0) {

/*        ==== Quick return in case of invalid argument. ==== */

    i__1 = -(*info);
    xerbla_("SHSEQR", &i__1);
    # 调用 xerbla_ 函数，传递字符串 "SHSEQR" 和指向 i__1 的指针作为参数

    return 0;
    # 返回整数值 0，函数执行完毕并正常退出

    } else if (*n == 0) {
    # 如果传入的指针 *n 所指向的值为 0，则执行以下操作
/*        ==== Quick return in case N = 0; nothing to do. ==== */
return 0;



    } else if (lquery) {
/*        ==== Quick return in case of a workspace query ==== */
slaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &wi[
    1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
/*
      ==== Ensure reported workspace size is backward-compatible with
      .    previous LAPACK versions. ====
Computing MAX
*/
r__1 = (real) max(1,*n);
work[1] = dmax(r__1,work[1]);
return 0;



    } else {
/*        ==== copy eigenvalues isolated by SGEBAL ==== */
i__1 = *ilo - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.f;
/* L10: */
}
i__1 = *n;
for (i__ = *ihi + 1; i__ <= i__1; ++i__) {
    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.f;
/* L20: */
}
/*        ==== Initialize Z, if requested ==== */
if (initz) {
    slaset_("A", n, n, &c_b29, &c_b15, &z__[z_offset], ldz)
        ;
}
/*        ==== Quick return if possible ==== */
if (*ilo == *ihi) {
    wr[*ilo] = h__[*ilo + *ilo * h_dim1];
    wi[*ilo] = 0.f;
    return 0;
}
/*
      ==== SLAHQR/SLAQR0 crossover point ====
Writing concatenation
*/
i__2[0] = 1, a__1[0] = job;
i__2[1] = 1, a__1[1] = compz;
s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);
nmin = ilaenv_(&c__12, "SHSEQR", ch__1, n, ilo, ihi, lwork, (ftnlen)6,
     (ftnlen)2);
nmin = max(11,nmin);
/*        ==== SLAQR0 for big matrices; SLAHQR for small ones ==== */
if (*n > nmin) {
    slaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
        &wi[1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork,
        info);
} else {
/*           ==== Small matrix ==== */
slahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
    &wi[1], ilo, ihi, &z__[z_offset], ldz, info);
if (*info > 0) {
/*
        ==== A rare SLAHQR failure!  SLAQR0 sometimes succeeds
        .    when SLAHQR fails. ====
*/
kbot = *info;
if (*n >= 49) {
/*
           ==== Larger matrices have enough subdiagonal scratch
           .    space to call SLAQR0 directly. ====
*/
slaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset],
    ldh, &wr[1], &wi[1], ilo, ihi, &z__[z_offset],
    ldz, &work[1], lwork, info);
} else {
/*
           ==== Tiny matrices don't have enough subdiagonal
           .    scratch space to benefit from SLAQR0.  Hence,
           .    tiny matrices must be copied into a larger
           .    array before calling SLAQR0. ====
*/
/* Subroutine */ int slabad_(real *small, real *large)
{

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLABAD takes as input the values computed by SLAMCH for underflow and
    overflow, and returns the square root of each of these values if the
    log of LARGE is sufficiently large.  This subroutine is intended to
    identify machines with a large exponent range, such as the Crays, and
    redefine the underflow and overflow limits to be the square roots of
    the values computed by SLAMCH.  This subroutine is needed because
    SLAMCH does not compensate for poor arithmetic in the upper half of
    the exponent range, as is found on a Cray.

    Arguments
    =========

    SMALL   (input/output) REAL
            On entry, the underflow threshold as computed by SLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of SMALL, otherwise unchanged.
*/

/*
   Computing MAX
*/
    r__1 = (real) max(1,*n);
    // 计算工作空间大小的最大值，确保与旧版 LAPACK 兼容
    work[1] = dmax(r__1,work[1]);
    }

/*     ==== End of SHSEQR ==== */

    return 0;
} /* shseqr_ */

logical sisnan_(real *sin__)
{
    /* System generated locals */
    logical ret_val;

    /* Local variables */
    extern logical slaisnan_(real *, real *);

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    SISNAN returns .TRUE. if its argument is NaN, and .FALSE.
    otherwise.  To be replaced by the Fortran 2003 intrinsic in the
    future.

    Arguments
    =========

    SIN     (input) REAL
            Input to test for NaN.

    =====================================================================
*/

    ret_val = slaisnan_(sin__, sin__);
    // 调用底层函数 slaisnan_ 检测输入是否为 NaN，并返回逻辑值
    return ret_val;
} /* sisnan_ */


这段代码是 Fortran 的 LAPACK 库中的两个子程序 `slabad_` 和 `sisnan_` 的部分实现。
    # 定义一个变量LARGE，表示输入/输出的实数
    # 在输入时，它表示由SLAMCH计算得出的溢出阈值
    # 在输出时，如果LOG10(LARGE)足够大，将会是LARGE的平方根，否则保持不变
    LARGE   (input/output) REAL

    # 如果看起来我们正在使用Cray超级计算机，执行以下操作：
    # 对于避免溢出和下溢问题，分别取SMALL和LARGE的平方根。
    # 这种策略是为了调整在Cray上可能遇到的数值计算问题。
    If it looks like we're on a Cray, take the square root of
    SMALL and LARGE to avoid overflow and underflow problems.
    if (r_lg10(large) > 2e3f) {
    // 如果 large 的以 10 为底的对数大于 2000，则进行以下操作
    *small = sqrt(*small);
    // 计算 small 的平方根，并更新 small 的值
    *large = sqrt(*large);
    // 计算 large 的平方根，并更新 large 的值
    }

    return 0;

/*     End of SLABAD */

} /* slabad_ */

/* Subroutine */ int slabrd_(integer *m, integer *n, integer *nb, real *a,
    integer *lda, real *d__, real *e, real *tauq, real *taup, real *x,
    integer *ldx, real *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2,
        i__3;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        sgemv_(char *, integer *, integer *, real *, real *, integer *,
        real *, integer *, real *, real *, integer *), slarfg_(
        integer *, real *, real *, integer *, real *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    SLABRD reduces the first NB rows and columns of a real general
    m by n matrix A to upper or lower bidiagonal form by an orthogonal
    transformation Q' * A * P, and returns the matrices X and Y which
    are needed to apply the transformation to the unreduced part of A.

    If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
    bidiagonal form.

    This is an auxiliary routine called by SGEBRD

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.

    N       (input) INTEGER
            The number of columns in the matrix A.

    NB      (input) INTEGER
            The number of leading rows and columns of A to be reduced.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the orthogonal matrix P as a product
              of elementary reflectors.
            If m < n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).


注释：
    D       (output) REAL array, dimension (NB)
            # 存储矩阵的第一个 NB 行和列的对角线元素，D(i) = A(i,i)。

    E       (output) REAL array, dimension (NB)
            # 存储矩阵的第一个 NB 行和列的非对角线元素。

    TAUQ    (output) REAL array dimension (NB)
            # 存储用于表示正交矩阵 Q 的初等反射器的标量因子。详见 Further Details。

    TAUP    (output) REAL array, dimension (NB)
            # 存储用于表示正交矩阵 P 的初等反射器的标量因子。详见 Further Details。

    X       (output) REAL array, dimension (LDX,NB)
            # 存储大小为 m-by-nb 的矩阵 X，用于更新矩阵 A 的未约化部分。

    LDX     (input) INTEGER
            # 数组 X 的主维度。LDX >= M。

    Y       (output) REAL array, dimension (LDY,NB)
            # 存储大小为 n-by-nb 的矩阵 Y，用于更新矩阵 A 的未约化部分。

    LDY     (input) INTEGER
            # 数组 Y 的主维度。LDY >= N。

    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

       Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)

    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are real scalars, and v and u are real vectors.

    If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
    A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
    A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    The elements of the vectors v and u together form the m-by-nb matrix
    V and the nb-by-n matrix U' which are needed, with X and Y, to apply
    the transformation to the unreduced part of the matrix, using a block
    update of the form:  A := A - V*Y' - X*U'.

    The contents of A on exit are illustrated by the following examples
    with nb = 2:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
      (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
      (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )

    where a denotes an element of the original matrix which is unchanged,
    vi denotes an element of the vector defining H(i), and ui an element
    of the vector defining G(i).
    =====================================================================
    # 如果条件成立，立即返回
    /* 调整参数 */
    a_dim1 = *lda;                  // 获取矩阵A的第一维度
    a_offset = 1 + a_dim1;          // 计算矩阵A的偏移量
    a -= a_offset;                  // 调整矩阵A的起始地址
    --d__;                          // 调整向量d的起始地址
    --e;                            // 调整向量e的起始地址
    --tauq;                         // 调整向量tauq的起始地址
    --taup;                         // 调整向量taup的起始地址
    x_dim1 = *ldx;                  // 获取矩阵X的第一维度
    x_offset = 1 + x_dim1;          // 计算矩阵X的偏移量
    x -= x_offset;                  // 调整矩阵X的起始地址
    y_dim1 = *ldy;                  // 获取矩阵Y的第一维度
    y_offset = 1 + y_dim1;          // 计算矩阵Y的偏移量
    y -= y_offset;                  // 调整矩阵Y的起始地址

    /* 函数体 */
    if (*m <= 0 || *n <= 0) {       // 检查m和n的值是否为非正数，如果是，则返回0
        return 0;
    }

    if (*m >= *n) {                 // 如果m大于等于n，则执行下面的操作

/*        将矩阵A化为上（右）角双对角形式 */

    i__1 = *nb;                     // 循环次数设为nb
    for (i__ = 1; i__ <= i__1; ++i__) {  // 开始循环，i从1到nb

/*           更新A(i:m,i) */

        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = i__ - 1;             // 计算矩阵的宽度
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + a_dim1],
            lda, &y[i__ + y_dim1], ldy, &c_b15, &a[i__ + i__ * a_dim1]
            , &c__1);               // 矩阵乘法运算，更新A(i:m,i)
        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = i__ - 1;             // 计算矩阵的宽度
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + x_dim1],
            ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b15, &a[i__ + i__ *
            a_dim1], &c__1);        // 矩阵乘法运算，更新A(i:m,i)

/*           生成反射Q(i)，使得A(i+1:m,i)为零 */

        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = min(i__ + 1,*m) + i__ * a_dim1;  // 计算偏移量
        slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ *
            a_dim1], &c__1, &tauq[i__]);  // 计算反射系数tauq[i__]
        d__[i__] = a[i__ + i__ * a_dim1];  // 存储对角元素到向量d
        if (i__ < *n) {             // 如果i小于n

        a[i__ + i__ * a_dim1] = 1.f;  // 将对角元素设置为1

/*              计算Y(i+1:n,i) */

        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = *n - i__;            // 计算矩阵的宽度
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + (i__ + 1) *
             a_dim1], lda, &a[i__ + i__ * a_dim1], &c__1, &c_b29,
            &y[i__ + 1 + i__ * y_dim1], &c__1);  // 矩阵乘法运算，计算Y(i+1:n,i)
        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = i__ - 1;             // 计算矩阵的宽度
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + a_dim1],
            lda, &a[i__ + i__ * a_dim1], &c__1, &c_b29, &y[i__ *
            y_dim1 + 1], &c__1);    // 矩阵乘法运算，计算Y(1:i-1,i)
        i__2 = *n - i__;            // 计算向量的长度
        i__3 = i__ - 1;             // 计算矩阵的宽度
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b15, &y[
            i__ + 1 + i__ * y_dim1], &c__1);  // 矩阵乘法运算，计算Y(i+1:n,i)
        i__2 = *m - i__ + 1;        // 计算向量的长度
        i__3 = i__ - 1;             // 计算矩阵的宽度
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &x[i__ + x_dim1],
            ldx, &a[i__ + i__ * a_dim1], &c__1, &c_b29, &y[i__ *
            y_dim1 + 1], &c__1);    // 矩阵乘法运算，计算Y(1:i-1,i)
        i__2 = i__ - 1;             // 计算向量的长度
        i__3 = *n - i__;            // 计算矩阵的宽度
        sgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1) *
            a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &c_b15,
             &y[i__ + 1 + i__ * y_dim1], &c__1);  // 矩阵乘法运算，计算Y(i+1:n,i)
        i__2 = *n - i__;            // 计算向量的长度
        sscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);  // 向量乘法运算，乘以tauq[i__]
/*           Update A(i,i+1:n) */

        // 计算列数
        i__2 = *n - i__;
        // 执行矩阵向量乘法，更新A的一部分
        sgemv_("No transpose", &i__2, &i__, &c_b151, &y[i__ + 1 +
            y_dim1], ldy, &a[i__ + a_dim1], lda, &c_b15, &a[i__ +
            (i__ + 1) * a_dim1], lda);
        // 计算行数和列数
        i__2 = i__ - 1;
        i__3 = *n - i__;
        // 执行矩阵向量乘法，更新A的另一部分
        sgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1) *
            a_dim1 + 1], lda, &x[i__ + x_dim1], ldx, &c_b15, &a[
            i__ + (i__ + 1) * a_dim1], lda);

/*           Generate reflection P(i) to annihilate A(i,i+2:n) */

        // 计算需要反射的元素数目
        i__2 = *n - i__;
        // 执行反射操作，将A的一部分归零
        slarfg_(&i__2, &a[i__ + (i__ + 1) * a_dim1], &a[i__ + min(
            i__3,*n) * a_dim1], lda, &taup[i__]);
        // 存储反射系数到e数组
        e[i__] = a[i__ + (i__ + 1) * a_dim1];
        // 将A的第一个反射元素设为1
        a[i__ + (i__ + 1) * a_dim1] = 1.f;

/*           Compute X(i+1:m,i) */

        // 计算行数
        i__2 = *m - i__;
        // 计算列数
        i__3 = *n - i__;
        // 执行矩阵向量乘法，计算X的一部分
        sgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + (
            i__ + 1) * a_dim1], lda, &a[i__ + (i__ + 1) * a_dim1],
             lda, &c_b29, &x[i__ + 1 + i__ * x_dim1], &c__1);
        // 计算列数
        i__2 = *n - i__;
        // 执行矩阵向量乘法，计算X的另一部分
        sgemv_("Transpose", &i__2, &i__, &c_b15, &y[i__ + 1 + y_dim1],
             ldy, &a[i__ + (i__ + 1) * a_dim1], lda, &c_b29, &x[
            i__ * x_dim1 + 1], &c__1);
        // 计算行数
        i__2 = *m - i__;
        // 执行矩阵向量乘法，计算X的另一部分
        sgemv_("No transpose", &i__2, &i__, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
        // 计算行数和列数
        i__2 = i__ - 1;
        i__3 = *n - i__;
        // 执行矩阵向量乘法，计算X的一部分
        sgemv_("No transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            c_b29, &x[i__ * x_dim1 + 1], &c__1);
        // 计算行数
        i__2 = *m - i__;
        // 计算列数
        i__3 = i__ - 1;
        // 执行矩阵向量乘法，计算X的另一部分
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
        // 计算行数
        i__2 = *m - i__;
        // 对X的一部分进行比例缩放
        sscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);
        }
/* L10: */
    }
    } else {

/*        Reduce to lower bidiagonal form */

    // 循环处理每个小块
    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*           Update A(i,i:n) */

        // 计算列数
        i__2 = *n - i__ + 1;
        // 执行矩阵向量乘法，更新A的一部分
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &y[i__ + y_dim1],
            ldy, &a[i__ + a_dim1], lda, &c_b15, &a[i__ + i__ * a_dim1]
            , lda);
        // 计算行数和列数
        i__2 = i__ - 1;
        i__3 = *n - i__ + 1;
        // 执行矩阵向量乘法，更新A的另一部分
        sgemv_("Transpose", &i__2, &i__3, &c_b151, &a[i__ * a_dim1 + 1],
            lda, &x[i__ + x_dim1], ldx, &c_b15, &a[i__ + i__ * a_dim1]
            , lda);

/*           Generate reflection P(i) to annihilate A(i,i+1:n) */

        // 计算需要反射的元素数目
        i__2 = *n - i__ + 1;
/* Computing MIN */
/* 计算最小值 */
        i__3 = i__ + 1;  /* 计算 i + 1 */
        slarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) *
            a_dim1], lda, &taup[i__]);  /* 对 a[i + i*a_dim1] 到 a[i + min(i+1, *n)*a_dim1] 进行 Householder 变换，并存储结果到 taup[i] */

        d__[i__] = a[i__ + i__ * a_dim1];  /* 将 a[i + i*a_dim1] 的值存入 d[i] */
        if (i__ < *m) {
        a[i__ + i__ * a_dim1] = 1.f;  /* 如果 i < *m，则将 a[i + i*a_dim1] 设置为 1.0 */

/*              Compute X(i+1:m,i) */
/*              计算 X(i+1:m,i) */

        i__2 = *m - i__;  /* 计算 *m - i */
        i__3 = *n - i__ + 1;  /* 计算 *n - i + 1 */
        sgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + i__
            * a_dim1], lda, &a[i__ + i__ * a_dim1], lda, &c_b29, &
            x[i__ + 1 + i__ * x_dim1], &c__1);  /* 使用矩阵向量乘法计算 X(i+1:m,i)，结果存储到 x[i+1+i*x_dim1] */

        i__2 = *n - i__ + 1;  /* 计算 *n - i + 1 */
        i__3 = i__ - 1;  /* 计算 i - 1 */
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &y[i__ + y_dim1],
            ldy, &a[i__ + i__ * a_dim1], lda, &c_b29, &x[i__ *
            x_dim1 + 1], &c__1);  /* 使用矩阵向量乘法计算 X(i+1:m,i) 的一部分，结果存储到 x[i*x_dim1+1] */

        i__2 = *m - i__;  /* 计算 *m - i */
        i__3 = i__ - 1;  /* 计算 i - 1 */
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);  /* 使用矩阵向量乘法计算 X(i+1:m,i) 的一部分，结果存储到 x[i+1+i*x_dim1] */

        i__2 = i__ - 1;  /* 计算 i - 1 */
        i__3 = *n - i__ + 1;  /* 计算 *n - i + 1 */
        sgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ * a_dim1
            + 1], lda, &a[i__ + i__ * a_dim1], lda, &c_b29, &x[
            i__ * x_dim1 + 1], &c__1);  /* 使用矩阵向量乘法计算 X(i+1:m,i) 的一部分，结果存储到 x[i*x_dim1+1] */

        i__2 = *m - i__;  /* 计算 *m - i */
        i__3 = i__ - 1;  /* 计算 i - 1 */
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);  /* 使用矩阵向量乘法计算 X(i+1:m,i) 的一部分，结果存储到 x[i+1+i*x_dim1] */

        i__2 = *m - i__;  /* 计算 *m - i */
        sscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);  /* 对 x[i+1+i*x_dim1] 进行标量乘法 */

/*              Update A(i+1:m,i) */
/*              更新 A(i+1:m,i) */

        i__2 = *m - i__;  /* 计算 *m - i */
        i__3 = i__ - 1;  /* 计算 i - 1 */
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &y[i__ + y_dim1], ldy, &c_b15, &a[i__ +
            1 + i__ * a_dim1], &c__1);  /* 使用矩阵向量乘法更新 A(i+1:m,i)，结果存储到 a[i+1+i*a_dim1] */

        i__2 = *m - i__;  /* 计算 *m - i */
        sgemv_("No transpose", &i__2, &i__, &c_b151, &x[i__ + 1 +
            x_dim1], ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b15, &a[
            i__ + 1 + i__ * a_dim1], &c__1);  /* 使用矩阵向量乘法更新 A(i+1:m,i)，结果存储到 a[i+1+i*a_dim1] */

/*              Generate reflection Q(i) to annihilate A(i+2:m,i) */
/*              生成反射变换 Q(i)，将 A(i+2:m,i) 化为零 */

        i__2 = *m - i__;  /* 计算 *m - i */
/* Computing MIN */
        i__3 = i__ + 2;  /* 计算 i + 2 */
        slarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*m) +
            i__ * a_dim1], &c__1, &tauq[i__]);  /* 对 a[i+1+i*a_dim1] 到 a[min(i+2,*m)+i*a_dim1] 进行 Householder 变换，并存储结果到 tauq[i] */

        e[i__] = a[i__ + 1 + i__ * a_dim1];  /* 将 a[i+1+i*a_dim1] 的值存入 e[i] */
        a[i__ + 1 + i__ * a_dim1] = 1.f;  /* 将 a[i+1+i*a_dim1] 设置为 1.0 */
/*              Compute Y(i+1:n,i) */

/* 计算 Y(i+1:n,i) */

        i__2 = *m - i__;
/* 计算矩阵 A 的行数减去当前行数 i 之后的结果 */
        i__3 = *n - i__;
/* 计算矩阵 A 的列数减去当前列数 i 之后的结果 */
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + (i__ +
            1) * a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1,
            &c_b29, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 使用 BLAS 库中的 sgemv 函数，对矩阵 A 的一部分进行矩阵向量乘法运算 */

        i__2 = *m - i__;
/* 计算矩阵 A 的行数减去当前行数 i 之后的结果 */
        i__3 = i__ - 1;
/* 计算当前列数 i 减去 1 的结果 */
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + a_dim1]
            , lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &y[
            i__ * y_dim1 + 1], &c__1);
/* 使用 BLAS 库中的 sgemv 函数，对矩阵 A 的一部分进行矩阵向量乘法运算 */

        i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列数 i 之后的结果 */
        i__3 = i__ - 1;
/* 计算当前列数 i 减去 1 的结果 */
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b15, &y[
            i__ + 1 + i__ * y_dim1], &c__1);
/* 使用 BLAS 库中的 sgemv 函数，对矩阵 Y 的一部分进行矩阵向量乘法运算 */

        i__2 = *m - i__;
/* 计算矩阵 A 的行数减去当前行数 i 之后的结果 */
        sgemv_("Transpose", &i__2, &i__, &c_b15, &x[i__ + 1 + x_dim1],
             ldx, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &y[
            i__ * y_dim1 + 1], &c__1);
/* 使用 BLAS 库中的 sgemv 函数，对矩阵 X 的一部分进行矩阵向量乘法运算 */

        i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列数 i 之后的结果 */
        sgemv_("Transpose", &i__, &i__2, &c_b151, &a[(i__ + 1) *
            a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &c_b15,
             &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 使用 BLAS 库中的 sgemv 函数，对矩阵 A 的一部分进行矩阵向量乘法运算 */

        i__2 = *n - i__;
/* 计算矩阵 Y 的列数减去当前列数 i 之后的结果 */
        sscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 使用 BLAS 库中的 sscal 函数，对矩阵 Y 的一部分进行标量乘法运算 */
        }
/* L20: */
    }
/* 结束循环 */
    }
/* 结束循环 */
    return 0;
/* 返回值为 0，表示正常运行 */

/*     End of SLABRD */

} /* slabrd_ */

/* Subroutine */ int slacpy_(char *uplo, integer *m, integer *n, real *a,
    integer *lda, real *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);
/* 外部函数声明 */

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLACPY copies all or part of a two-dimensional matrix A to another
    matrix B.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input) REAL array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (output) REAL array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
*/
    # 定义一个名为 bubble_sort 的函数，用于实现冒泡排序算法
    def bubble_sort(arr):
        # 获取列表的长度
        n = len(arr)
        # 外层循环，控制比较的轮数，总共需要 n-1 轮
        for i in range(n-1):
            # 内层循环，每轮比较相邻的元素并进行交换，最大的元素逐步移动到末尾
            for j in range(0, n-i-1):
                # 如果前一个元素大于后一个元素，则交换它们
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]
        # 排序完成后返回排序后的列表
        return arr
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    if (lsame_(uplo, "U")) {
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L10: */
        }
/* L20: */
    }
    } else if (lsame_(uplo, "L")) {
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = j; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L30: */
        }
/* L40: */
    }
    } else {
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L50: */
        }
/* L60: */
    }
    }
    return 0;

/*     End of SLACPY */

} /* slacpy_ */

/* Subroutine */ int sladiv_(real *a, real *b, real *c__, real *d__, real *p,
    real *q)
{
    static real e, f;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLADIV performs complex division in  real arithmetic

                          a + i*b
               p + i*q = ---------
                          c + i*d

    The algorithm is due to Robert L. Smith and can be found
    in D. Knuth, The art of Computer Programming, Vol.2, p.195

    Arguments
    =========

    A       (input) REAL
    B       (input) REAL
    C       (input) REAL
    D       (input) REAL
            The scalars a, b, c, and d in the above expression.

    P       (output) REAL
    Q       (output) REAL
            The scalars p and q in the above expression.

    =====================================================================
*/


    if (dabs(*d__) < dabs(*c__)) {
    e = *d__ / *c__;
    f = *c__ + *d__ * e;
    *p = (*a + *b * e) / f;
    *q = (*b - *a * e) / f;
    } else {
    e = *c__ / *d__;
    f = *d__ + *c__ * e;
    *p = (*b + *a * e) / f;
    *q = (-(*a) + *b * e) / f;
    }

    return 0;

/*     End of SLADIV */

} /* sladiv_ */

/* Subroutine */ int slae2_(real *a, real *b, real *c__, real *rt1, real *rt2)
{
    /* System generated locals */
    real r__1;

    /* Local variables */
    static real ab, df, tb, sm, rt, adf, acmn, acmx;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
       [  A   B  ]
       [  B   C  ].
    On return, RT1 is the eigenvalue of larger absolute value, and RT2
    is the eigenvalue of smaller absolute value.


    Arguments
    =========

    A       (input) REAL
            The (1,1) element of the 2x2 matrix.

    B       (input) REAL
            The (1,2) and (2,1) elements of the 2x2 matrix.

    C       (input) REAL
            The (2,2) element of the 2x2 matrix.

    RT1     (output) REAL
            The eigenvalue of larger absolute value.

    RT2     (output) REAL
            The eigenvalue of smaller absolute value.

    =====================================================================
*/
    Arguments
    =========

    A       (input) REAL
            The (1,1) element of the 2-by-2 matrix.

    B       (input) REAL
            The (1,2) and (2,1) elements of the 2-by-2 matrix.

    C       (input) REAL
            The (2,2) element of the 2-by-2 matrix.

    RT1     (output) REAL
            The eigenvalue of larger absolute value.

    RT2     (output) REAL
            The eigenvalue of smaller absolute value.

    Further Details
    ===============

    RT1 is accurate to a few ulps barring over/underflow.

    RT2 may be inaccurate if there is massive cancellation in the
    determinant A*C-B*B; higher precision or correctly rounded or
    correctly truncated arithmetic would be needed to compute RT2
    accurately in all cases.

    Overflow is possible only if RT1 is within a factor of 5 of overflow.
    Underflow is harmless if the input data is 0 or exceeds
       underflow_threshold / macheps.

   =====================================================================
/*
    sm = *a + *c__;
    计算两个指针所指向的值的和
*/
    df = *a - *c__;
    // 计算两个指针所指向的值的差
    adf = dabs(df);
    /*
        计算绝对值
        dabs 是一个函数或宏，用于计算浮点数的绝对值
    */
    tb = *b + *b;
    // 计算指针 b 所指向值的两倍
    ab = dabs(tb);
    // 计算绝对值
    if (dabs(*a) > dabs(*c__)) {
        acmx = *a;
        acmn = *c__;
    } else {
        acmx = *c__;
        acmn = *a;
    }
    /*
        比较指针 a 和 c 所指向的值的绝对值大小，并赋值给 acmx 和 acmn
    */
    if (adf > ab) {
        /*
            计算平方和的平方根乘以 adf
            rt 是结果，用于存储计算后的值
        */
        r__1 = ab / adf;
        rt = adf * sqrt(r__1 * r__1 + 1.f);
    } else if (adf < ab) {
        /*
            计算平方和的平方根乘以 ab
            rt 是结果，用于存储计算后的值
        */
        r__1 = adf / ab;
        rt = ab * sqrt(r__1 * r__1 + 1.f);
    } else {
        /*
            处理 adf 和 ab 都为 0 的情况
            计算平方根乘以 2.f
        */
        rt = ab * sqrt(2.f);
    }
    /*
        根据 sm 的值判断分支
    */
    if (sm < 0.f) {
        *rt1 = (sm - rt) * .5f;

        /*
            执行顺序很重要。
            为了得到完全精确的较小特征值，
            下一行需要在更高的精度下执行。
        */
        *rt2 = acmx / *rt1 * acmn - *b / *rt1 * *b;
    } else if (sm > 0.f) {
        *rt1 = (sm + rt) * .5f;

        /*
            执行顺序很重要。
            为了得到完全精确的较小特征值，
            下一行需要在更高的精度下执行。
        */
        *rt2 = acmx / *rt1 * acmn - *b / *rt1 * *b;
    } else {
        /*
            处理 sm 等于 0 的情况
        */
        *rt1 = rt * .5f;
        *rt2 = rt * -.5f;
    }
    return 0;

    /*     
        SLAE2 的结束
    */

} /* slae2_ */

/*
    Subroutine slaed0 的开始
    参数说明：
    icompq: 控制是否计算 Q
    qsiz: Q 的维度
    n: 矩阵的阶数
    d__: 长度为 n 的数组，存储矩阵的对角元素
    e: 长度为 n-1 的数组，存储矩阵的次对角元素
    q: 长度为 ldq*qsiz 的数组，存储计算 Q 的结果
    ldq: Q 的列数
    qstore: 长度为 ldqs*qsiz 的数组，存储 Q 的副本
    ldqs: Qstore 的列数
    work: 工作空间，长度为 4*n
    iwork: 工作空间，长度为 3*n
    info: 返回状态信息
*/

/* 
    System generated locals
*/
    integer q_dim1, q_offset, qstore_dim1, qstore_offset, i__1, i__2;
    real r__1;

/* 
    Local variables
*/
    static integer i__, j, k, iq, lgn, msd2, smm1, spm1, spm2;
    static real temp;
    static integer curr;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer iperm, indxq, iwrem;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    static integer iqptr, tlvls;
    extern /* Subroutine */ int slaed1_(integer *, real *, real *, integer *,
        integer *, real *, integer *, real *, integer *, integer *),
        slaed7_(integer *, integer *, integer *, integer *, integer *,
        integer *, real *, real *, integer *, integer *, real *, integer *
        , real *, integer *, integer *, integer *, integer *, integer *,
        real *, real *, integer *, integer *);
    static integer igivcl;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer igivnm, submat;
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *);
    static integer curprb, subpbs, igivpt, curlvl, matsiz, iprmpt, smlsiz;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======
    SLAED0 computes all eigenvalues and corresponding eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.

    Arguments
    =========
    
    ICOMPQ  (input) INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                  matrix.
                  根据此参数的值决定 SLAED0 的行为，0 为仅计算特征值，1 为同时计算特征向量，
                  2 为同时计算特征值和特征向量。

    QSIZ   (input) INTEGER
           The dimension of the orthogonal matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
           用于将原始矩阵转化为三对角形式的正交矩阵的维度。若 ICOMPQ = 1，则 QSIZ >= N。

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.
           对称三对角矩阵的维度。N >= 0。

    D      (input/output) REAL array, dimension (N)
           On entry, the main diagonal of the tridiagonal matrix.
           On exit, its eigenvalues.
           输入时为三对角矩阵的主对角线。输出时为其特征值。

    E      (input) REAL array, dimension (N-1)
           The off-diagonal elements of the tridiagonal matrix.
           On exit, E has been destroyed.
           三对角矩阵的非对角元素。计算后会被破坏。

    Q      (input/output) REAL array, dimension (LDQ, N)
           On entry, Q must contain an N-by-N orthogonal matrix.
           If ICOMPQ = 0    Q is not referenced.
           If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                            orthogonal matrix used to reduce the full
                            matrix to tridiagonal form corresponding to
                            the subset of the full matrix which is being
                            decomposed at this time.
           If ICOMPQ = 2    On entry, Q will be the identity matrix.
                            On exit, Q contains the eigenvectors of the
                            tridiagonal matrix.
           输入时，Q 必须包含一个 N×N 的正交矩阵。
           若 ICOMPQ = 0，则不引用 Q。
           若 ICOMPQ = 1，则在输入时，Q 是用于将完整矩阵转化为三对角形式的正交矩阵的一部分，对应于当前分解的完整矩阵的子集。
           若 ICOMPQ = 2，则在输入时，Q 将是单位矩阵。在输出时，Q 包含三对角矩阵的特征向量。

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  If eigenvectors are
           desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
           数组 Q 的领先维度。若需要特征向量，则 LDQ >= max(1,N)。总之，LDQ >= 1。

    QSTORE (workspace) REAL array, dimension (LDQS, N)
           Referenced only when ICOMPQ = 1.  Used to store parts of
           the eigenvector matrix when the updating matrix multiplies
           take place.
           仅在 ICOMPQ = 1 时引用。用于存储更新矩阵乘法进行时的特征向量矩阵的部分内容。

    LDQS   (input) INTEGER
           The leading dimension of the array QSTORE.  If ICOMPQ = 1,
           then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
           数组 QSTORE 的领先维度。若 ICOMPQ = 1，则 LDQS >= max(1,N)。总之，LDQS >= 1。

    WORK   (workspace) REAL array,
           If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                       1 + 3*N + 2*N*lg N + 2*N**2
                       ( lg( N ) = smallest integer k
                                   such that 2^k >= N )
           If ICOMPQ = 2, the dimension of WORK must be at least
                       4*N + N**2.
           若 ICOMPQ = 0 或 1，则 WORK 的维度至少为 1 + 3*N + 2*N*lg N + 2*N**2，
           其中 lg( N ) 是最小整数 k，使得 2^k >= N 。
           若 ICOMPQ = 2，则 WORK 的维度至少为 4*N + N**2。
    # IWORK (工作空间) 是一个整数数组，
    # 如果 ICOMPQ = 0 或 1，则 IWORK 的维度至少应为
    # 6 + 6*N + 5*N*lg N。
    # （其中 lg(N) 是使得 2^k >= N 的最小整数 k）
    # 如果 ICOMPQ = 2，则 IWORK 的维度至少应为
    # 3 + 5*N。

    # INFO (输出) 是一个整数，
    # = 0 表示成功完成。
    # < 0 表示如果 INFO = -i，则第 i 个参数具有非法值。
    # > 0 表示算法在处理子矩阵时未能计算特征值，
    # 这些子矩阵位于 INFO/(N+1) 到 mod(INFO,N+1) 的行和列之间。

    # 进一步细节说明
    # ===============

    # 基于以下贡献而成
    # Jeff Rutter, 美国加州大学伯克利分校，计算机科学系

    # =====================================================================

    # 测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;                      // 调整参数数组d__
    --e;                        // 调整参数数组e
    q_dim1 = *ldq;              // 设置q数组的第一维度大小
    q_offset = 1 + q_dim1;      // 计算q数组的偏移量
    q -= q_offset;              // 调整q数组指针以便正确访问数据
    qstore_dim1 = *ldqs;        // 设置qstore数组的第一维度大小
    qstore_offset = 1 + qstore_dim1;   // 计算qstore数组的偏移量
    qstore -= qstore_offset;    // 调整qstore数组指针以便正确访问数据
    --work;                     // 调整工作数组的指针
    --iwork;                    // 调整iwork数组的指针

    /* Function Body */
    *info = 0;                  // 初始化info变量为0

    if (*icompq < 0 || *icompq > 2) {  // 检查icompq的取值范围
    *info = -1;                 // 设置info为-1，表示参数错误
    } else if (*icompq == 1 && *qsiz < max(0,*n)) {   // 检查icompq为1时的额外条件
    *info = -2;                 // 设置info为-2，表示参数错误
    } else if (*n < 0) {        // 检查n的取值范围
    *info = -3;                 // 设置info为-3，表示参数错误
    } else if (*ldq < max(1,*n)) {  // 检查ldq的取值范围
    *info = -7;                 // 设置info为-7，表示参数错误
    } else if (*ldqs < max(1,*n)) { // 检查ldqs的取值范围
    *info = -9;                 // 设置info为-9，表示参数错误
    }
    if (*info != 0) {           // 如果info不为0，即有错误发生
    i__1 = -(*info);            // 计算错误代码的负值
    xerbla_("SLAED0", &i__1);    // 调用错误处理函数xerbla_
    return 0;                   // 返回0表示异常终止
    }

/*     Quick return if possible */

    if (*n == 0) {              // 如果n为0，直接返回
    return 0;                   // 返回0表示正常终止
    }

    smlsiz = ilaenv_(&c__9, "SLAED0", " ", &c__0, &c__0, &c__0, &c__0, (
        ftnlen)6, (ftnlen)1);   // 调用ilaenv_函数获取smlsiz的值

/*
       Determine the size and placement of the submatrices, and save in
       the leading elements of IWORK.
*/

    iwork[1] = *n;              // 设置iwork数组的第一个元素为n
    subpbs = 1;                 // 初始化子问题数为1
    tlvls = 0;                  // 初始化递归层数为0
L10:
    if (iwork[subpbs] > smlsiz) {   // 如果当前子问题的大小大于smlsiz
    for (j = subpbs; j >= 1; --j) { // 反向遍历当前的所有子问题
        iwork[j * 2] = (iwork[j] + 1) / 2;    // 计算新的子问题大小
        iwork[(j << 1) - 1] = iwork[j] / 2;   // 计算新的子问题大小
/* L20: */
    }
    ++tlvls;                    // 层数加一
    subpbs <<= 1;               // 子问题数乘以2
    goto L10;                   // 继续处理子问题的大小
    }
    i__1 = subpbs;
    for (j = 2; j <= i__1; ++j) {
    iwork[j] += iwork[j - 1];   // 累加计算每个子问题的末尾位置
/* L30: */
    }

/*
       Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
       using rank-1 modifications (cuts).
*/

    spm1 = subpbs - 1;          // 计算spm1为子问题数减1
    i__1 = spm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    submat = iwork[i__] + 1;    // 计算当前子矩阵的起始位置
    smm1 = submat - 1;          // 计算当前子矩阵前一个位置
    d__[smm1] -= (r__1 = e[smm1], dabs(r__1));   // 更新对角元素
    d__[submat] -= (r__1 = e[smm1], dabs(r__1)); // 更新对角元素
/* L40: */
    }

    indxq = (*n << 2) + 3;      // 计算indxq的值
    if (*icompq != 2) {

/*
          Set up workspaces for eigenvalues only/accumulate new vectors
          routine
*/

    temp = log((real) (*n)) / log(2.f); // 计算log2(n)
    lgn = (integer) temp;       // 将log2(n)转换为整数
    if (pow_ii(&c__2, &lgn) < *n) {     // 计算2^lgn，检查是否小于n
        ++lgn;                  // 如果小于n，lgn加一
    }
    if (pow_ii(&c__2, &lgn) < *n) {     // 再次检查2^lgn是否小于n
        ++lgn;                  // 如果小于n，lgn再加一
    }
    iprmpt = indxq + *n + 1;    // 计算iprmpt的值
    iperm = iprmpt + *n * lgn;  // 计算iperm的值
    iqptr = iperm + *n * lgn;   // 计算iqptr的值
    igivpt = iqptr + *n + 2;    // 计算igivpt的值
    igivcl = igivpt + *n * lgn; // 计算igivcl的值

    igivnm = 1;                 // 初始化igivnm为1
    iq = igivnm + (*n << 1) * lgn;      // 计算iq的值
/* Computing 2nd power */
    i__1 = *n;
    iwrem = iq + i__1 * i__1 + 1;       // 计算iwrem的值

/*        Initialize pointers */

    i__1 = subpbs;
    for (i__ = 0; i__ <= i__1; ++i__) { // 初始化iprmpt和igivpt数组
        iwork[iprmpt + i__] = 1;
        iwork[igivpt + i__] = 1;
/* L50: */
    }
    iwork[iqptr] = 1;           // 初始化iqptr数组
    }

/*
       Solve each submatrix eigenproblem at the bottom of the divide and
       conquer tree.
*/

    curr = 0;                   // 初始化curr为0
    i__1 = spm1;
    for (i__ = 0; i__ <= i__1; ++i__) {  // 遍历每个子矩阵的求解问题
    if (i__ == 0) {             // 第一个子矩阵的处理
        submat = 1;             // 设置当前子矩阵的起始位置
        matsiz = iwork[1];      // 设置当前子矩阵的大小
    } else {
        submat = iwork[i__] + 1;    // 设置当前子矩阵的起始位置
        matsiz = iwork[i__ + 1] - iwork[i__];   // 设置当前子矩阵的大小
    }
    // 如果 icompq 的值为 2，则调用 SSTEQR 函数计算特定子矩阵的特征值和特征向量
    if (*icompq == 2) {
        ssteqr_("I", &matsiz, &d__[submat], &e[submat], &q[submat +
            submat * q_dim1], ldq, &work[1], info);
        // 如果返回的 info 不为 0，则跳转到标签 L130 处处理错误情况
        if (*info != 0) {
        goto L130;
        }
    } else {
        // 否则，调用 SSTEQR 函数计算特定子矩阵的特征值，但只返回计算结果在 work 数组中
        ssteqr_("I", &matsiz, &d__[submat], &e[submat], &work[iq - 1 +
            iwork[iqptr + curr]], &matsiz, &work[1], info);
        // 如果返回的 info 不为 0，则跳转到标签 L130 处处理错误情况
        if (*info != 0) {
        goto L130;
        }
        // 如果 icompq 的值为 1，则调用 SGEMM 函数计算 Q 矩阵的乘积
        if (*icompq == 1) {
        sgemm_("N", "N", qsiz, &matsiz, &matsiz, &c_b15, &q[submat *
            q_dim1 + 1], ldq, &work[iq - 1 + iwork[iqptr + curr]],
             &matsiz, &c_b29, &qstore[submat * qstore_dim1 + 1],
            ldqs);
        }
    }
/* 计算平方 */
        i__2 = matsiz;
        iwork[iqptr + curr + 1] = iwork[iqptr + curr] + i__2 * i__2;
        ++curr;
    }
    k = 1;
    i__2 = iwork[i__ + 1];
    for (j = submat; j <= i__2; ++j) {
        iwork[indxq + j] = k;
        ++k;
/* L60: */
    }
/* L70: */
    }

/*
       逐步合并相邻子矩阵的特征系统
       到对应较大矩阵的特征系统。

       while ( SUBPBS > 1 )
*/

    curlvl = 1;
L80:
    if (subpbs > 1) {
    spm2 = subpbs - 2;
    i__1 = spm2;
    for (i__ = 0; i__ <= i__1; i__ += 2) {
        if (i__ == 0) {
        submat = 1;
        matsiz = iwork[2];
        msd2 = iwork[1];
        curprb = 0;
        } else {
        submat = iwork[i__] + 1;
        matsiz = iwork[i__ + 2] - iwork[i__];
        msd2 = matsiz / 2;
        ++curprb;
        }

/*
       合并较低阶特征系统（大小为 MSD2 和 MATSIZ - MSD2）
       到大小为 MATSIZ 的特征系统。
       SLAED1 仅用于三对角矩阵的完整特征系统。
       SLAED7 处理仅需要特征值或特征值和特征向量的完整对称矩阵（已约化为三对角形式）的情况。
*/

        if (*icompq == 2) {
        slaed1_(&matsiz, &d__[submat], &q[submat + submat * q_dim1],
            ldq, &iwork[indxq + submat], &e[submat + msd2 - 1], &
            msd2, &work[1], &iwork[subpbs + 1], info);
        } else {
        slaed7_(icompq, &matsiz, qsiz, &tlvls, &curlvl, &curprb, &d__[
            submat], &qstore[submat * qstore_dim1 + 1], ldqs, &
            iwork[indxq + submat], &e[submat + msd2 - 1], &msd2, &
            work[iq], &iwork[iqptr], &iwork[iprmpt], &iwork[iperm]
            , &iwork[igivpt], &iwork[igivcl], &work[igivnm], &
            work[iwrem], &iwork[subpbs + 1], info);
        }
        if (*info != 0) {
        goto L130;
        }
        iwork[i__ / 2 + 1] = iwork[i__ + 2];
/* L90: */
    }
    subpbs /= 2;
    ++curlvl;
    goto L80;
    }

/*
       结束 while

       重新合并在最终合并步骤中被消除的特征值/向量。
*/

    if (*icompq == 1) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
        scopy_(qsiz, &qstore[j * qstore_dim1 + 1], &c__1, &q[i__ * q_dim1
            + 1], &c__1);
/* L100: */
    }
    scopy_(n, &work[1], &c__1, &d__[1], &c__1);
    } else if (*icompq == 2) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
        scopy_(n, &q[j * q_dim1 + 1], &c__1, &work[*n * i__ + 1], &c__1);
/* L110: */
    }
    scopy_(n, &work[1], &c__1, &d__[1], &c__1);
    slacpy_("A", n, n, &work[*n + 1], n, &q[q_offset], ldq);
    } else {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
/* L120: */
    }
    scopy_(n, &work[1], &c__1, &d__[1], &c__1);
    }
    // 跳转到标签 L140 处执行代码
    goto L140;
L130:
    *info = submat * (*n + 1) + submat + matsiz - 1;


L140:
    return 0;


/*     End of SLAED0 */


} /* slaed0_ */

/* Subroutine */ int slaed1_(integer *n, real *d__, real *q, integer *ldq,
    integer *indxq, real *rho, integer *cutpnt, real *work, integer *
    iwork, integer *info)
{


    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;


    /* Local variables */
    static integer i__, k, n1, n2, is, iw, iz, iq2, cpp1, indx, indxc, indxp;


    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slaed2_(integer *, integer *, integer *, real *, real
        *, integer *, integer *, real *, real *, real *, real *, real *,
        integer *, integer *, integer *, integer *, integer *);


    static integer idlmda;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static integer coltyp;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
*/


    Purpose
    =======


    SLAED1 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix.  This
    routine is used only for the eigenproblem which requires all
    eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
    the case in which eigenvalues only or eigenvalues and eigenvectors
    of a full symmetric matrix (which was reduced to tridiagonal form)
    are desired.

      T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)

       where Z = Q'u, u is a vector of length N with ones in the
       CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

       The eigenvectors of the original matrix are stored in Q, and the
       eigenvalues are in D.  The algorithm consists of three stages:

          The first stage consists of deflating the size of the problem
          when there are multiple eigenvalues or if there is a zero in
          the Z vector.  For each such occurence the dimension of the
          secular equation problem is reduced by one.  This stage is
          performed by the routine SLAED2.

          The second stage consists of calculating the updated
          eigenvalues. This is done by finding the roots of the secular
          equation via the routine SLAED4 (as called by SLAED3).
          This routine also calculates the eigenvectors of the current
          problem.

          The final stage consists of computing the updated eigenvectors
          directly using the updated eigenvalues.  The eigenvectors for
          the current problem are multiplied with the eigenvectors from
          the overall problem.

Explanation:


      T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)

计算修正后的特征值问题的公式，其中包括输入矩阵的特征向量和特征值，通过一个修正项 RHO * Z*Z' 进行修正，得到修正后的特征向量和特征值。


       where Z = Q'u, u is a vector of length N with ones in the
       CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

定义了向量 Z，它是矩阵 Q 的某个列向量 u 的乘积，u 是一个长度为 N 的向量，在索引 CUTPNT 和 CUTPNT + 1 处有值为 1，其他位置为 0。


       The eigenvectors of the original matrix are stored in Q, and the
       eigenvalues are in D.  The algorithm consists of three stages:

说明了输入矩阵的特征向量存储在 Q 中，特征值存储在 D 中，并描述了算法分为三个阶段的过程。


          The first stage consists of deflating the size of the problem
          when there are multiple eigenvalues or if there is a zero in
          the Z vector.  For each such occurence the dimension of the
          secular equation problem is reduced by one.  This stage is
          performed by the routine SLAED2.

第一阶段的任务是在出现多个特征值或 Z 向量中有零元素时，减小问题的规模。每次出现这种情况时，通过 SLAED2 程序将世俗方程问题的维度减少一维。


          The second stage consists of calculating the updated
          eigenvalues. This is done by finding the roots of the secular
          equation via the routine SLAED4 (as called by SLAED3).
          This routine also calculates the eigenvectors of the current
          problem.

第二阶段是计算更新后的特征值。通过 SLAED3 调用 SLAED4 程序找到世俗方程的根，从而计算出当前问题的特征向量。


          The final stage consists of computing the updated eigenvectors
          directly using the updated eigenvalues.  The eigenvectors for
          the current problem are multiplied with the eigenvectors from
          the overall problem.

最后阶段是直接使用更新后的特征值计算更新后的特征向量，当前问题的特征向量与整体问题的特征向量相乘。



    Arguments
    =========

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D      (input/output) REAL array, dimension (N)
           On entry, the eigenvalues of the rank-1-perturbed matrix.
           On exit, the eigenvalues of the repaired matrix.

    Q      (input/output) REAL array, dimension (LDQ,N)
           On entry, the eigenvectors of the rank-1-perturbed matrix.
           On exit, the eigenvectors of the repaired tridiagonal matrix.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    INDXQ  (input/output) INTEGER array, dimension (N)
           On entry, the permutation which separately sorts the two
           subproblems in D into ascending order.
           On exit, the permutation which will reintegrate the
           subproblems back into sorted order,
           i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.

    RHO    (input) REAL
           The subdiagonal entry used to create the rank-1 modification.

    CUTPNT (input) INTEGER
           The location of the last eigenvalue in the leading sub-matrix.
           min(1,N) <= CUTPNT <= N/2.

    WORK   (workspace) REAL array, dimension (4*N + N**2)

    IWORK  (workspace) INTEGER array, dimension (4*N)

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge

    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA
    Modified by Francoise Tisseur, University of Tennessee.

Explanation:


    Arguments
    =========

这段说明了下面列出的是函数的输入参数列表。


    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

N 是对称三对角矩阵的维数，必须大于等于 0。


    D      (input/output) REAL array, dimension (N)
           On entry, the eigenvalues of the rank-1-perturbed matrix.
           On exit, the eigenvalues of the repaired matrix.

D 是一个实数数组，它在输入时是一个被扰动的秩为 1 的矩阵的特征值，输出时是修复后的矩阵的特征值。


    Q      (input/output) REAL array, dimension (LDQ,N)
           On entry, the eigenvectors of the rank-1-perturbed matrix.
           On exit, the eigenvectors of the repaired tridiagonal matrix.

Q 是一个实数数组，它在输入时是一个被扰动的秩为 1 的矩阵的特征向量，输出时是修复后的三对角矩阵的特征向量。


    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

LDQ 是数组 Q 的主维度，必须大于等于 1 和 N 中的最大值。


    INDXQ  (input/output) INTEGER array, dimension (N)
           On entry, the permutation which separately sorts the two
           subproblems in D into ascending order.
           On exit, the permutation which will reintegrate the
           subproblems back into sorted order,
           i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.

INDXQ 是一个整数数组，在输入时它是将 D 中的两个子问题分别排序为升序的排列顺序。在输出时，它是将子问题重新整合成排序顺序的排列。


    RHO    (input) REAL
           The subdiagonal entry used to create the rank-1 modification.

RHO 是用于创建秩为 1 修改的次对角线条目。


    CUTPNT (input) INTEGER
           The location of the last eigenvalue in the leading sub-matrix.
           min(1,N) <= CUTPNT <= N/2.

CUTPNT 是主子矩阵中最后一个特征值的位置，必须满足 min(1,N) <= CUTPNT <= N/2。


    WORK   (workspace) REAL array, dimension
    =====================================================================
    # 分隔线注释，用于标记代码的不同部分或者功能区域
       Test the input parameters.
    # 测试输入参数的有效性或者其他特定的功能注释
    /* Parameter adjustments */
    --d__;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --indxq;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;

    if (*n < 0) {
        *info = -1;
    } else if (*ldq < max(1,*n)) {
        *info = -4;
    } else /* if(complicated condition) */ {
        /* Computing MIN */
        i__1 = 1, i__2 = *n / 2;
        if (min(i__1,i__2) > *cutpnt || *n / 2 < *cutpnt) {
            *info = -7;
        }
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLAED1", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /*
       The following values are integer pointers which indicate
       the portion of the workspace
       used by a particular array in SLAED2 and SLAED3.
    */
    iz = 1;
    idlmda = iz + *n;
    iw = idlmda + *n;
    iq2 = iw + *n;

    indx = 1;
    indxc = indx + *n;
    coltyp = indxc + *n;
    indxp = coltyp + *n;

    /*
       Form the z-vector which consists of the last row of Q_1 and the
       first row of Q_2.
    */
    scopy_(cutpnt, &q[*cutpnt + q_dim1], ldq, &work[iz], &c__1);
    cpp1 = *cutpnt + 1;
    i__1 = *n - *cutpnt;
    scopy_(&i__1, &q[cpp1 + cpp1 * q_dim1], ldq, &work[iz + *cutpnt], &c__1);

    /* Deflate eigenvalues. */
    slaed2_(&k, n, cutpnt, &d__[1], &q[q_offset], ldq, &indxq[1], rho, &work[
        iz], &work[idlmda], &work[iw], &work[iq2], &iwork[indx], &iwork[
        indxc], &iwork[indxp], &iwork[coltyp], info);

    if (*info != 0) {
        goto L20;
    }

    /* Solve Secular Equation. */
    if (k != 0) {
        is = (iwork[coltyp] + iwork[coltyp + 1]) * *cutpnt + (iwork[coltyp +
            1] + iwork[coltyp + 2]) * (*n - *cutpnt) + iq2;
        slaed3_(&k, n, cutpnt, &d__[1], &q[q_offset], ldq, rho, &work[idlmda],
             &work[iq2], &iwork[indxc], &iwork[coltyp], &work[iw], &work[
            is], info);
        if (*info != 0) {
            goto L20;
        }

        /* Prepare the INDXQ sorting permutation. */
        n1 = k;
        n2 = *n - k;
        slamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &indxq[1]);
    } else {
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            indxq[i__] = i__;
        }
    }

L20:
    return 0;

    /* End of SLAED1 */
} /* slaed1_ */

/* Subroutine */ int slaed2_(integer *k, integer *n, integer *n1, real *d__,
    real *q, integer *ldq, integer *indxq, real *rho, real *z__, real *
    dlamda, real *w, real *q2, integer *indx, integer *indxc, integer *
    indxp, integer *coltyp, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;
    real r__1, r__2, r__3, r__4;

    /* Local variables */
    static real c__;
    static integer i__, j;
    static real s, t;
    static integer k2, n2, ct, nj, pj, js, iq1, iq2, n1p1;
    static real eps, tau, tol;
    static integer psm[4], imax, jmax, ctot[4];


Explanation:
- The code provided includes a subroutine `slaed1_` and another subroutine `slaed2_`. 
- `slaed1_` initializes parameters, performs checks on input values, forms vectors, and calls other subroutines.
- `slaed2_` appears to perform calculations related to eigenvalue deflation based on the context provided.
    # 外部函数声明：进行向量操作和数学计算的子程序声明
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *),
        sscal_(integer *, real *, real *, integer *),
        scopy_(integer *, real *, integer *, real *, integer *);
    
    # 外部函数声明：进行数学计算的子程序声明
    extern doublereal slapy2_(real *, real *),
        slamch_(char *);
    
    # 外部函数声明：处理错误的子程序声明
    extern /* Subroutine */ int xerbla_(char *, integer *);
    
    # 外部函数声明：进行向量操作的子程序声明
    extern integer isamax_(integer *, real *, integer *);
    
    # 外部函数声明：排序子程序声明
    extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer
        *, integer *, integer *);
    
    # 外部函数声明：复制矩阵子程序声明
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *,
        real *, integer *, real *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAED2 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny entry in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    K      (output) INTEGER
           The number of non-deflated eigenvalues, and the order of the
           related secular equation. 0 <= K <=N.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    N1     (input) INTEGER
           The location of the last eigenvalue in the leading sub-matrix.
           min(1,N) <= N1 <= N/2.

    D      (input/output) REAL array, dimension (N)
           On entry, D contains the eigenvalues of the two submatrices to
           be combined.
           On exit, D contains the trailing (N-K) updated eigenvalues
           (those which were deflated) sorted into increasing order.

    Q      (input/output) REAL array, dimension (LDQ, N)
           On entry, Q contains the eigenvectors of two submatrices in
           the two square blocks with corners at (1,1), (N1,N1)
           and (N1+1, N1+1), (N,N).
           On exit, Q contains the trailing (N-K) updated eigenvectors
           (those which were deflated) in its last N-K columns.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    INDXQ  (input/output) INTEGER array, dimension (N)
           The permutation which separately sorts the two sub-problems
           in D into ascending order.  Note that elements in the second
           half of this permutation must first have N1 added to their
           values. Destroyed on exit.

    RHO    (input/output) REAL
           On entry, the off-diagonal element associated with the rank-1
           cut which originally split the two submatrices which are now
           being recombined.
           On exit, RHO has been modified to the value required by
           SLAED3.

    Z      (input) REAL array, dimension (N)
           On entry, Z contains the updating vector (the last
           row of the first sub-eigenvector matrix and the first row of
           the second sub-eigenvector matrix).
           On exit, the contents of Z have been destroyed by the updating
           process.

    DLAMDA (output) REAL array, dimension (N)
           A copy of the first K eigenvalues which will be used by
           SLAED3 to form the secular equation.
*/
    # 输出参数，实数数组，维度为N，包含最终经过缩减处理的前k个z向量值，将传递给SLAED3函数。
    W      (output) REAL array, dimension (N)
           The first k values of the final deflation-altered z-vector
           which will be passed to SLAED3.

    # 输出参数，实数数组，维度为N1**2 + (N-N1)**2，包含前K个特征向量的副本，将用于SLAED3中的矩阵乘法（SGEMM）以求解新的特征向量。
    Q2     (output) REAL array, dimension (N1**2+(N-N1)**2)
           A copy of the first K eigenvectors which will be used by
           SLAED3 in a matrix multiply (SGEMM) to solve for the new
           eigenvectors.

    # 工作空间，整数数组，维度为N，用于对DLAMDA的内容进行升序排序的排列。
    INDX   (workspace) INTEGER array, dimension (N)
           The permutation used to sort the contents of DLAMDA into
           ascending order.

    # 输出参数，整数数组，维度为N，用于将缩减后的Q矩阵的列排列成三组：第一组仅包含N1及以上的非零元素，第二组仅包含N1以下的非零元素，第三组密集。
    INDXC  (output) INTEGER array, dimension (N)
           The permutation used to arrange the columns of the deflated
           Q matrix into three groups:  the first group contains non-zero
           elements only at and above N1, the second contains
           non-zero elements only below N1, and the third is dense.

    # 工作空间，整数数组，维度为N，用于将缩减后的D值放置到数组末尾。INDXP(1:K)指向未缩减的D值，INDXP(K+1:N)指向缩减后的特征值。
    INDXP  (workspace) INTEGER array, dimension (N)
           The permutation used to place deflated values of D at the end
           of the array.  INDXP(1:K) points to the nondeflated D-values
           and INDXP(K+1:N) points to the deflated eigenvalues.

    # 工作空间/输出参数，整数数组，维度为N，标记Q2矩阵中每一列的类型：
    # 1：仅在上半部分非零；
    # 2：密集；
    # 3：仅在下半部分非零；
    # 4：缩减。
    # 在退出时，COLTYP(i)是类型为i的列的数量，仅i=1到4。
    COLTYP (workspace/output) INTEGER array, dimension (N)
           During execution, a label which will indicate which of the
           following types a column in the Q2 matrix is:
           1 : non-zero in the upper half only;
           2 : dense;
           3 : non-zero in the lower half only;
           4 : deflated.
           On exit, COLTYP(i) is the number of columns of type i,
           for i=1 to 4 only.

    # 输出参数，整数，表示函数的退出状态：
    # = 0：成功退出。
    # < 0：如果INFO = -i，表示第i个参数具有非法值。
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步细节
    # 根据以下贡献编写：
    # Jeff Rutter，加利福尼亚大学伯克利分校计算机科学部，美国
    # 由Francoise Tisseur修改，田纳西大学。
    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA
    Modified by Francoise Tisseur, University of Tennessee.

    # 测试输入参数。
    =====================================================================
       Test the input parameters.
    /* Parameter adjustments */
    --d__;                              // 调整参数 d__
    q_dim1 = *ldq;                      // 设置 Q 的第一维大小
    q_offset = 1 + q_dim1;              // 计算 Q 的偏移量
    q -= q_offset;                      // 调整 Q 的起始地址
    --indxq;                            // 调整参数 indxq
    --z__;                              // 调整参数 z__
    --dlamda;                           // 调整参数 dlamda
    --w;                                // 调整参数 w
    --q2;                               // 调整参数 q2
    --indx;                             // 调整参数 indx
    --indxc;                            // 调整参数 indxc
    --indxp;                            // 调整参数 indxp
    --coltyp;                           // 调整参数 coltyp

    /* Function Body */
    *info = 0;                          // 初始化 info 为 0

    if (*n < 0) {                       // 如果 n 小于 0
        *info = -2;                     // 将 info 设置为 -2
    } else if (*ldq < max(1,*n)) {      // 或者如果 ldq 小于 1 和 n 中的最大值
        *info = -6;                     // 将 info 设置为 -6
    } else /* if(complicated condition) */ {
        /* Computing MIN */             // 计算最小值
        i__1 = 1, i__2 = *n / 2;
        if (min(i__1,i__2) > *n1 || *n / 2 < *n1) {
            *info = -3;                 // 将 info 设置为 -3
        }
    }
    if (*info != 0) {                   // 如果 info 不为 0
        i__1 = -(*info);                // 取 info 的相反数
        xerbla_("SLAED2", &i__1);        // 调用错误处理函数 xerbla_
        return 0;                       // 返回
    }

/*     Quick return if possible */

    if (*n == 0) {                      // 如果 n 等于 0
        return 0;                       // 直接返回
    }

    n2 = *n - *n1;                      // 计算 n2
    n1p1 = *n1 + 1;                     // 计算 n1p1

    if (*rho < 0.f) {                   // 如果 rho 小于 0
        sscal_(&n2, &c_b151, &z__[n1p1], &c__1);  // 对 z__ 的一部分进行比例缩放
    }

/*
       Normalize z so that norm(z) = 1.  Since z is the concatenation of
       two normalized vectors, norm2(z) = sqrt(2).
*/

    t = 1.f / sqrt(2.f);                // 计算缩放系数 t
    sscal_(n, &t, &z__[1], &c__1);       // 对 z__ 进行归一化处理

/*     RHO = ABS( norm(z)**2 * RHO ) */

    *rho = (r__1 = *rho * 2.f, dabs(r__1));  // 更新 rho 的值

/*     Sort the eigenvalues into increasing order */

    i__1 = *n;
    for (i__ = n1p1; i__ <= i__1; ++i__) {
        indxq[i__] += *n1;              // 调整 indxq 数组的值
/* L10: */
    }

/*     re-integrate the deflated parts from the last pass */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dlamda[i__] = d__[indxq[i__]]; // 重新整合 dlamda 数组
/* L20: */
    }
    slamrg_(n1, &n2, &dlamda[1], &c__1, &c__1, &indxc[1]);  // 调用排序函数 slamrg_
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        indx[i__] = indxq[indxc[i__]]; // 更新 indx 数组
/* L30: */
    }

/*     Calculate the allowable deflation tolerance */

    imax = isamax_(n, &z__[1], &c__1);   // 计算 z__ 中绝对值最大元素的索引
    jmax = isamax_(n, &d__[1], &c__1);   // 计算 d__ 中绝对值最大元素的索引
    eps = slamch_("Epsilon");            // 获取机器精度
/* Computing MAX */                      // 计算最大值
    r__3 = (r__1 = d__[jmax], dabs(r__1)), r__4 = (r__2 = z__[imax], dabs(
        r__2));
    tol = eps * 8.f * dmax(r__3,r__4);   // 计算容许的缩小公差

/*
       If the rank-1 modifier is small enough, no more needs to be done
       except to reorganize Q so that its columns correspond with the
       elements in D.
*/

    if (*rho * (r__1 = z__[imax], dabs(r__1)) <= tol) {  // 如果条件满足
        *k = 0;                         // 设置 k 为 0
        iq2 = 1;                        // 初始化 iq2
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {   // 循环处理
            i__ = indx[j];              // 获取 indx 数组的值
            scopy_(n, &q[i__ * q_dim1 + 1], &c__1, &q2[iq2], &c__1);  // 复制 q 的一部分到 q2
            dlamda[j] = d__[i__];       // 更新 dlamda 数组
            iq2 += *n;                  // 更新 iq2
/* L40: */
        }
        slacpy_("A", n, n, &q2[1], n, &q[q_offset], ldq);  // 复制 q2 到 q
        scopy_(n, &dlamda[1], &c__1, &d__[1], &c__1);      // 复制 dlamda 到 d
        goto L190;                      // 跳转到标签 L190
    }

/*
       If there are multiple eigenvalues then the problem deflates.  Here
       the number of equal eigenvalues are found.  As each equal
       eigenvalue is found, an elementary reflector is computed to rotate
       the corresponding eigensubspace so that the corresponding
       components of Z are zero in this new basis.
*/

    i__1 = *n1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        coltyp[i__] = 1;                // 设置 coltyp 数组的值为 1
/* L50: */
    }
    i__1 = *n;
    for (i__ = n1p1; i__ <= i__1; ++i__) {
        coltyp[i__] = 3;                // 设置 coltyp 数组的值为 3
/* L60: */
    }
    *k = 0;

# 设置指针 k 所指向的值为 0

    k2 = *n + 1;

# 将 k2 的值设置为指针 n 所指向的值加 1

    i__1 = *n;

# 将变量 i__1 设置为指针 n 所指向的值

    for (j = 1; j <= i__1; ++j) {

# 循环：从 j = 1 开始，直到 j <= i__1，每次增加 j 的值

    nj = indx[j];

# 将 nj 的值设置为数组 indx 的第 j 个元素的值

    if (*rho * (r__1 = z__[nj], dabs(r__1)) <= tol) {

# 如果指针 rho 所指向的值乘以 z__ 数组中索引为 nj 的元素的绝对值小于或等于 tol，则执行以下操作：
/*           Deflate due to small z component. */

/* 减少 k2 的值，表示将某个列排除在外 */
--k2;
/* 将当前列的类型设为 4 */
coltyp[nj] = 4;
/* 记录排除的列在 indxp 数组中的位置 */
indxp[k2] = nj;
/* 如果当前列是最后一列，跳转到结束标签 L100 */
if (j == *n) {
goto L100;
}
} else {
/* 记录上一个列的位置 */
pj = nj;
/* 转到标签 L80 继续处理下一列 */
goto L80;
}
/* L70: */
}
L80:
/* 增加列的索引 */
++j;
/* 获取下一列的索引 */
nj = indx[j];
/* 如果超过总列数，跳转到结束标签 L100 */
if (j > *n) {
goto L100;
}
/* 如果当前列的 z 值的绝对值小于等于给定的容差值 tol */
if (*rho * (r__1 = z__[nj], dabs(r__1)) <= tol) {

/*        Deflate due to small z component. */

/* 减少 k2 的值，表示将某个列排除在外 */
--k2;
/* 将当前列的类型设为 4 */
coltyp[nj] = 4;
/* 记录排除的列在 indxp 数组中的位置 */
indxp[k2] = nj;
} else {

/*        Check if eigenvalues are close enough to allow deflation. */

/* 获取两个特征值，用于判断是否可以进行排除 */
s = z__[pj];
c__ = z__[nj];

/*
          Find sqrt(a**2+b**2) without overflow or
          destructive underflow.
*/

/* 计算 sqrt(a**2+b**2)，避免溢出或破坏性下溢 */
tau = slapy2_(&c__, &s);
/* 计算特征值之间的差 */
t = d__[nj] - d__[pj];
/* 对 c__ 和 s 进行归一化处理 */
c__ /= tau;
s = -s / tau;
/* 如果 t * c__ * s 的绝对值小于等于给定的容差值 tol */
if ((r__1 = t * c__ * s, dabs(r__1)) <= tol) {

/*           Deflation is possible. */

/* 对特征值进行更新 */
z__[nj] = tau;
z__[pj] = 0.f;
/* 如果两列的类型不同，将当前列的类型设为 2 */
if (coltyp[nj] != coltyp[pj]) {
coltyp[nj] = 2;
}
/* 将上一个列的类型设为 4 */
coltyp[pj] = 4;
/* 对 Q 矩阵进行旋转 */
srot_(n, &q[pj * q_dim1 + 1], &c__1, &q[nj * q_dim1 + 1], &c__1, &
c__, &s);
/* 计算 c__ 和 s 的平方 */
/* Computing 2nd power */
r__1 = c__;
/* Computing 2nd power */
r__2 = s;
t = d__[pj] * (r__1 * r__1) + d__[nj] * (r__2 * r__2);
/* Computing 2nd power */
r__1 = s;
/* Computing 2nd power */
r__2 = c__;
d__[nj] = d__[pj] * (r__1 * r__1) + d__[nj] * (r__2 * r__2);
d__[pj] = t;
/* 减少 k2 的值 */
--k2;
/* 初始化循环变量 */
i__ = 1;
L90:
/* 如果 k2 + i__ 小于等于总列数 */
if (k2 + i__ <= *n) {
/* 如果当前列的特征值小于下一个列的特征值 */
if (d__[pj] < d__[indxp[k2 + i__]]) {
/* 交换列的位置 */
indxp[k2 + i__ - 1] = indxp[k2 + i__];
indxp[k2 + i__] = pj;
/* 增加循环变量并继续循环 */
++i__;
goto L90;
} else {
/* 否则直接记录当前列的位置 */
indxp[k2 + i__ - 1] = pj;
}
} else {
/* 记录当前列的位置 */
indxp[k2 + i__ - 1] = pj;
}
/* 记录上一个列的位置 */
pj = nj;
} else {
/* 如果不满足排除条件，增加 k 的值 */
++(*k);
/* 记录特征值和 z 值 */
dlamda[*k] = d__[pj];
w[*k] = z__[pj];
indxp[*k] = pj;
/* 记录上一个列的位置 */
pj = nj;
}
}
/* 转到标签 L80 继续处理下一列 */
goto L80;
L100:

/*     Record the last eigenvalue. */

/* 增加 k 的值 */
++(*k);
/* 记录最后一个特征值和 z 值 */
dlamda[*k] = d__[pj];
w[*k] = z__[pj];
indxp[*k] = pj;

/*
       Count up the total number of the various types of columns, then
       form a permutation which positions the four column types into
       four uniform groups (although one or more of these groups may be
       empty).
*/

/* 统计每种列的总数 */
for (j = 1; j <= 4; ++j) {
/* 初始化列的计数器 */
ctot[j - 1] = 0;
/* L110: */
}
/* 计算每种列的数量 */
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
/* 获取列的类型 */
ct = coltyp[j];
/* 增加相应类型列的计数 */
++ctot[ct - 1];
/* L120: */
}

/*     PSM(*) = Position in SubMatrix (of types 1 through 4) */

/* 设置子矩阵的位置信息 */
psm[0] = 1;
psm[1] = ctot[0] + 1;
psm[2] = psm[1] + ctot[1];
psm[3] = psm[2] + ctot[2];
/* 计算剩余列数 */
*k = *n - ctot[3];

/*
       Fill out the INDXC array so that the permutation which it induces
       will place all type-1 columns first, all type-2 columns next,
       then all type-3's, and finally all type-4's.
*/

/* 填充 INDXC 数组，确保各种列类型依次排列 */
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
/* 获取排列后的列索引 */
js = indxp[j];
/* 获取列的类型 */
ct = coltyp[js];
    indx[psm[ct - 1]] = js;
    # 将数组 indx 中索引为 psm[ct - 1] 的位置赋值为 js

    indxc[psm[ct - 1]] = j;
    # 将数组 indxc 中索引为 psm[ct - 1] 的位置赋值为 j

    ++psm[ct - 1];
    # 将数组 psm 中索引为 ct - 1 的位置的值增加 1
/*
       Sort the eigenvalues and corresponding eigenvectors into DLAMDA
       and Q2 respectively.  The eigenvalues/vectors which were not
       deflated go into the first K slots of DLAMDA and Q2 respectively,
       while those which were deflated go into the last N - K slots.
*/

    i__ = 1;  // 初始化索引 i__
    iq1 = 1;  // 初始化 Q2 的索引起始位置
    iq2 = (ctot[0] + ctot[1]) * *n1 + 1;  // 计算 Q2 中第二部分的起始索引位置
    i__1 = ctot[0];  // 设置循环次数为 ctot[0]
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];  // 获取当前索引对应的 indx 中的值
    scopy_(n1, &q[js * q_dim1 + 1], &c__1, &q2[iq1], &c__1);  // 复制 Q 中的向量到 Q2
    z__[i__] = d__[js];  // 将特征值复制到 z__ 数组中
    ++i__;  // 增加索引 i__
    iq1 += *n1;  // 更新 Q2 的索引位置
/* L140: */
    }

    i__1 = ctot[1];  // 设置循环次数为 ctot[1]
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];  // 获取当前索引对应的 indx 中的值
    scopy_(n1, &q[js * q_dim1 + 1], &c__1, &q2[iq1], &c__1);  // 复制 Q 中的向量到 Q2
    scopy_(&n2, &q[*n1 + 1 + js * q_dim1], &c__1, &q2[iq2], &c__1);  // 复制 Q 中的向量到 Q2
    z__[i__] = d__[js];  // 将特征值复制到 z__ 数组中
    ++i__;  // 增加索引 i__
    iq1 += *n1;  // 更新 Q2 的第一部分的索引位置
    iq2 += n2;  // 更新 Q2 的第二部分的索引位置
/* L150: */
    }

    i__1 = ctot[2];  // 设置循环次数为 ctot[2]
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];  // 获取当前索引对应的 indx 中的值
    scopy_(&n2, &q[*n1 + 1 + js * q_dim1], &c__1, &q2[iq2], &c__1);  // 复制 Q 中的向量到 Q2
    z__[i__] = d__[js];  // 将特征值复制到 z__ 数组中
    ++i__;  // 增加索引 i__
    iq2 += n2;  // 更新 Q2 的第二部分的索引位置
/* L160: */
    }

    iq1 = iq2;  // 将 Q2 的索引位置更新为最后一部分的起始位置
    i__1 = ctot[3];  // 设置循环次数为 ctot[3]
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];  // 获取当前索引对应的 indx 中的值
    scopy_(n, &q[js * q_dim1 + 1], &c__1, &q2[iq2], &c__1);  // 复制 Q 中的向量到 Q2
    iq2 += *n;  // 更新 Q2 的索引位置
    z__[i__] = d__[js];  // 将特征值复制到 z__ 数组中
    ++i__;  // 增加索引 i__
/* L170: */
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

    slacpy_("A", n, &ctot[3], &q2[iq1], n, &q[(*k + 1) * q_dim1 + 1], ldq);  // 复制 Q2 的后部分到 Q
    i__1 = *n - *k;  // 计算要复制的特征值的数量
    scopy_(&i__1, &z__[*k + 1], &c__1, &d__[*k + 1], &c__1);  // 复制特征值到 D 数组中

/*     Copy CTOT into COLTYP for referencing in SLAED3. */

    for (j = 1; j <= 4; ++j) {
    coltyp[j] = ctot[j - 1];  // 将 ctot 数组的值复制到 coltyp 数组中
/* L180: */
    }

L190:
    return 0;  // 返回 0，结束函数

/*     End of SLAED2 */

} /* slaed2_ */

/* Subroutine */ int slaed3_(integer *k, integer *n, integer *n1, real *d__,
    real *q, integer *ldq, real *rho, real *dlamda, real *q2, integer *
    indx, integer *ctot, real *w, real *s, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j, n2, n12, ii, n23, iq2;
    static real temp;
    extern doublereal snrm2_(integer *, real *, integer *);
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *), scopy_(integer *, real *,
        integer *, real *, integer *), slaed4_(integer *, integer *, real
        *, real *, real *, real *, real *, integer *);
    extern doublereal slamc3_(real *, real *);
    extern /* Subroutine */ int xerbla_(char *, integer *), slacpy_(
        char *, integer *, integer *, real *, integer *, real *, integer *
        ), slaset_(char *, integer *, integer *, real *, real *,
        real *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
*/


注释已按照要求添加到每行代码的上方，以解释其作用和功能。
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    SLAED3 finds the roots of the secular equation, as defined by the
    values in D, W, and RHO, between 1 and K.  It makes the
    appropriate calls to SLAED4 and then updates the eigenvectors by
    multiplying the matrix of eigenvectors of the pair of eigensystems
    being combined by the matrix of eigenvectors of the K-by-K system
    which is solved here.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    K       (input) INTEGER
            The number of terms in the rational function to be solved by
            SLAED4.  K >= 0.

    N       (input) INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (deflation may result in N>K).

    N1      (input) INTEGER
            The location of the last eigenvalue in the leading submatrix.
            min(1,N) <= N1 <= N/2.

    D       (output) REAL array, dimension (N)
            D(I) contains the updated eigenvalues for
            1 <= I <= K.

    Q       (output) REAL array, dimension (LDQ,N)
            Initially the first K columns are used as workspace.
            On output the columns 1 to K contain
            the updated eigenvectors.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    RHO     (input) REAL
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.

    DLAMDA  (input/output) REAL array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation. May be changed on output by
            having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
            Cray-2, or Cray C-90, as described above.

    Q2      (input) REAL array, dimension (LDQ2, N)
            The first K columns of this matrix contain the non-deflated
            eigenvectors for the split problem.

    INDX    (input) INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups (see SLAED2).
            The rows of the eigenvectors found by SLAED4 must be likewise
            permuted before the matrix multiply can take place.

    CTOT    (input) INTEGER array, dimension (4)
            A count of the total number of the various types of columns
            in Q, as described in INDX.  The fourth column type is any
            column which has been deflated.
    # W (input/output) REAL array, dimension (K)
    # The first K elements of this array contain the components
    # of the deflation-adjusted updating vector. Destroyed on
    # output.

    # S (workspace) REAL array, dimension (N1 + 1)*K
    # Will contain the eigenvectors of the repaired matrix which
    # will be multiplied by the previously accumulated eigenvectors
    # to update the system.

    # LDS (input) INTEGER
    # The leading dimension of S.  LDS >= max(1,K).

    # INFO (output) INTEGER
    # = 0:  successful exit.
    # < 0:  if INFO = -i, the i-th argument had an illegal value.
    # > 0:  if INFO = 1, an eigenvalue did not converge

    # Further Details
    # ===============

    # Based on contributions by
    # Jeff Rutter, Computer Science Division, University of California
    # at Berkeley, USA
    # Modified by Francoise Tisseur, University of Tennessee.

    # =====================================================================

    # Test the input parameters.
/* Parameter adjustments */
--d__;                          // 调整数组 d__，这是一个一维数组
q_dim1 = *ldq;                  // 记录 Q 的第一维大小为 ldq
q_offset = 1 + q_dim1;          // Q 数组的偏移量
q -= q_offset;                  // 调整 Q 数组的起始地址
--dlamda;                       // 调整数组 dlamda，这是一个一维数组
--q2;                           // 调整数组 q2，这是一个一维数组
--indx;                         // 调整数组 indx，这是一个一维数组
--ctot;                         // 调整数组 ctot，这是一个一维数组
--w;                            // 调整数组 w，这是一个一维数组
--s;                            // 调整数组 s，这是一个一维数组

/* Function Body */
*info = 0;                      // 初始化 info 参数为 0

if (*k < 0) {                   // 检查 k 的值是否小于 0
*info = -1;                     // 如果是，将 info 设为 -1
} else if (*n < *k) {           // 否则检查 n 是否小于 k
*info = -2;                     // 如果是，将 info 设为 -2
} else if (*ldq < max(1,*n)) {  // 再检查 ldq 是否小于 max(1,n)
*info = -6;                     // 如果是，将 info 设为 -6
}
if (*info != 0) {               // 如果 info 不等于 0
i__1 = -(*info);                // 将 -info 赋给 i__1
xerbla_("SLAED3", &i__1);       // 调用 xerbla 函数处理异常情况
return 0;                       // 返回 0
}

/* Quick return if possible */

if (*k == 0) {                  // 如果 k 等于 0，直接返回
return 0;                       // 返回 0
}

/*
   Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
   be computed with high relative accuracy (barring over/underflow).
   This is a problem on machines without a guard digit in
   add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
   The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
   which on any of these machines zeros out the bottommost
   bit of DLAMDA(I) if it is 1; this makes the subsequent
   subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
   occurs. On binary machines with a guard digit (almost all
   machines) it does not change DLAMDA(I) at all. On hexadecimal
   and decimal machines with a guard digit, it slightly
   changes the bottommost bits of DLAMDA(I). It does not account
   for hexadecimal or decimal machines without guard digits
   (we know of none). We use a subroutine call to compute
   2*DLAMBDA(I) to prevent optimizing compilers from eliminating
   this code.
*/

i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
dlamda[i__] = slamc3_(&dlamda[i__], &dlamda[i__]) - dlamda[i__];
/* L10: */
}

i__1 = *k;
for (j = 1; j <= i__1; ++j) {
slaed4_(k, &j, &dlamda[1], &w[1], &q[j * q_dim1 + 1], rho, &d__[j],
    info);

/* If the zero finder fails, the computation is terminated. */

if (*info != 0) {
goto L120;
}
/* L20: */
}

if (*k == 1) {
goto L110;
}
if (*k == 2) {
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    w[1] = q[j * q_dim1 + 1];
    w[2] = q[j * q_dim1 + 2];
    ii = indx[1];
    q[j * q_dim1 + 1] = w[ii];
    ii = indx[2];
    q[j * q_dim1 + 2] = w[ii];
/* L30: */
}
goto L110;
}

/* Compute updated W. */

scopy_(k, &w[1], &c__1, &s[1], &c__1);

/* Initialize W(I) = Q(I,I) */

i__1 = *ldq + 1;
scopy_(k, &q[q_offset], &i__1, &w[1], &c__1);
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
i__2 = j - 1;
for (i__ = 1; i__ <= i__2; ++i__) {
    w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
/* L40: */
}
i__2 = *k;
for (i__ = j + 1; i__ <= i__2; ++i__) {
    w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
/* L50: */
}
/* L60: */
}
i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
r__1 = sqrt(-w[i__]);
w[i__] = r_sign(&r__1, &s[i__]);
/* L70: */
}
/*     Compute eigenvectors of the modified rank-1 modification. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        s[i__] = w[i__] / q[i__ + j * q_dim1];
/* L80: */
    }
    temp = snrm2_(k, &s[1], &c__1);
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        ii = indx[i__];
        q[i__ + j * q_dim1] = s[ii] / temp;
/* L90: */
    }
/* L100: */
    }

/*     Compute the updated eigenvectors. */

L110:

    n2 = *n - *n1;
    n12 = ctot[1] + ctot[2];
    n23 = ctot[2] + ctot[3];

    slacpy_("A", &n23, k, &q[ctot[1] + 1 + q_dim1], ldq, &s[1], &n23);
    iq2 = *n1 * n12 + 1;
    if (n23 != 0) {
    sgemm_("N", "N", &n2, k, &n23, &c_b15, &q2[iq2], &n2, &s[1], &n23, &
        c_b29, &q[*n1 + 1 + q_dim1], ldq);
    } else {
    slaset_("A", &n2, k, &c_b29, &c_b29, &q[*n1 + 1 + q_dim1], ldq);
    }

    slacpy_("A", &n12, k, &q[q_offset], ldq, &s[1], &n12);
    if (n12 != 0) {
    sgemm_("N", "N", n1, k, &n12, &c_b15, &q2[1], n1, &s[1], &n12, &c_b29,
         &q[q_offset], ldq);
    } else {
    slaset_("A", n1, k, &c_b29, &c_b29, &q[q_dim1 + 1], ldq);
    }


L120:
    return 0;

/*     End of SLAED3 */

} /* slaed3_ */

/* Subroutine */ int slaed4_(integer *n, integer *i__, real *d__, real *z__,
    real *delta, real *rho, real *dlam, integer *info)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Local variables */
    static real a, b, c__;
    static integer j;
    static real w;
    static integer ii;
    static real dw, zz[3];
    static integer ip1;
    static real del, eta, phi, eps, tau, psi;
    static integer iim1, iip1;
    static real dphi, dpsi;
    static integer iter;
    static real temp, prew, temp1, dltlb, dltub, midpt;
    static integer niter;
    static logical swtch;
    extern /* Subroutine */ int slaed5_(integer *, real *, real *, real *,
        real *, real *), slaed6_(integer *, logical *, real *, real *,
        real *, real *, real *, integer *);
    static logical swtch3;
    extern doublereal slamch_(char *);
    static logical orgati;
    static real erretm, rhoinv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    This subroutine computes the I-th updated eigenvalue of a symmetric
    rank-one modification to a diagonal matrix whose elements are
    given in the array d, and that

               D(i) < D(j)  for  i < j

    and that RHO > 0.  This is arranged by the calling routine, and is
    no loss in generality.  The rank-one modified system is thus

               diag( D )  +  RHO *  Z * Z_transpose.

    where we assume the Euclidean norm of Z is 1.

    The method consists of approximating the rational functions in the
    secular equation by simpler interpolating rational functions.

    Arguments
    # 参数 N：所有数组的长度
           这个参数表示所有相关数组的长度，包括 D、Z 和 DELTA 等。

    # 参数 I：要计算的特征值的索引
           表示要计算的特征值在数组 D 中的索引，满足 1 <= I <= N。

    # 参数 D：实数数组，维度为 (N)
           原始特征值数组，假设这些特征值已经按顺序排列，即 D(I) < D(J) 对于所有 I < J 成立。

    # 参数 Z：实数数组，维度为 (N)
           更新向量的分量。

    # 输出参数 DELTA：实数数组，维度为 (N)
           如果 N > 2，则 DELTA 的第 j 个分量包含 (D(j) - lambda_I)，其中 lambda_I 是第 I 个更新后的特征值。
           如果 N = 1，则 DELTA(1) = 1。如果 N = 2，请参考 SLAED5 获取详细信息。
           向量 DELTA 包含了构造特征向量所需的信息，由 SLAED3 和 SLAED9 使用。

    # 参数 RHO：实数
           对称更新公式中的标量。

    # 输出参数 DLAM：实数
           计算得到的 lambda_I，即第 I 个更新后的特征值。

    # 输出参数 INFO：整数
           返回状态信息：
           - 0: 成功退出
           - > 0: 如果 INFO = 1，表示更新过程失败。

    # 内部参数

    # 逻辑变量 ORGATI（是否以 i 为起点？）
           用于区分是以 D(i) 还是 D(i+1) 作为起点。

              ORGATI = .true.    表示以 i 为起点
              ORGATI = .false.   表示以 i+1 为起点

    # 逻辑变量 SWTCH3（是否处理三个极点？）
           用于标记是否正在处理三个极点的情况。

    # 内部参数 MAXIT
           每个特征值允许的最大迭代次数。

    # 更多细节

    # 基于以下贡献
           来自 Ren-Cang Li，加州大学伯克利分校计算机科学系，美国

    =====================================================================

       由于该例程在内部循环中被调用，因此没有参数检查。

       对于 N=1 和 N=2，进行快速返回。
    /*
        Parameter adjustments
    */
    --delta;
    --z__;
    --d__;

    /*
        Function Body
    */
    *info = 0;
    if (*n == 1) {

        /*
            Presumably, I=1 upon entry
        */

        *dlam = d__[1] + *rho * z__[1] * z__[1];
        delta[1] = 1.f;
        return 0;
    }
    if (*n == 2) {
        slaed5_(i__, &d__[1], &z__[1], &delta[1], rho, dlam);
        return 0;
    }

    /*
        Compute machine epsilon
    */

    eps = slamch_("Epsilon");
    rhoinv = 1.f / *rho;

    /*
        The case I = N
    */

    if (*i__ == *n) {

        /*
            Initialize some basic variables
        */

        ii = *n - 1;
        niter = 1;

        /*
            Calculate initial guess
        */

        midpt = *rho / 2.f;

        /*
            If ||Z||_2 is not one, then TEMP should be set to
            RHO * ||Z||_2^2 / TWO
        */

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            delta[j] = d__[j] - d__[*i__] - midpt;
        }

        psi = 0.f;
        i__1 = *n - 2;
        for (j = 1; j <= i__1; ++j) {
            psi += z__[j] * z__[j] / delta[j];
        }

        c__ = rhoinv + psi;
        w = c__ + z__[ii] * z__[ii] / delta[ii] + z__[*n] * z__[*n] / delta[*n];

        if (w <= 0.f) {
            temp = z__[*n - 1] * z__[*n - 1] / (d__[*n] - d__[*n - 1] + *rho)
                   + z__[*n] * z__[*n] / *rho;
            if (c__ <= temp) {
                tau = *rho;
            } else {
                del = d__[*n] - d__[*n - 1];
                a = -c__ * del + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];
                b = z__[*n] * z__[*n] * del;
                if (a < 0.f) {
                    tau = b * 2.f / (sqrt(a * a + b * 4.f * c__) - a);
                } else {
                    tau = (a + sqrt(a * a + b * 4.f * c__)) / (c__ * 2.f);
                }
            }

            /*
                It can be proved that
                D(N)+RHO/2 <= LAMBDA(N) < D(N)+TAU <= D(N)+RHO
            */

            dltlb = midpt;
            dltub = *rho;
        } else {
            del = d__[*n] - d__[*n - 1];
            a = -c__ * del + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];
            b = z__[*n] * z__[*n] * del;
            if (a < 0.f) {
                tau = b * 2.f / (sqrt(a * a + b * 4.f * c__) - a);
            } else {
                tau = (a + sqrt(a * a + b * 4.f * c__)) / (c__ * 2.f);
            }

            /*
                It can be proved that
                D(N) < D(N)+TAU < LAMBDA(N) < D(N)+RHO/2
            */

            dltlb = 0.f;
            dltub = midpt;
        }

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            delta[j] = d__[j] - d__[*i__] - tau;
        }

        /*
            Evaluate PSI and the derivative DPSI
        */

        dpsi = 0.f;
        psi = 0.f;
        erretm = 0.f;
        i__1 = ii;
        for (j = 1; j <= i__1; ++j) {
            temp = z__[j] / delta[j];
            psi += z__[j] * temp;
            dpsi += temp * temp;
            erretm += psi;
        }
        erretm = dabs(erretm);

        /*
            Evaluate PHI and the derivative DPHI
        */

        temp = z__[*n] / delta[*n];
        phi = z__[*n] * temp;
        dphi = temp * temp;
        erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) * (dpsi + dphi);

        w = rhoinv + phi + psi;

        /*
            Test for convergence
        */

            Test for convergence
        */
    # 如果绝对值小于等于 eps 乘以 erretm，执行以下操作
    if (dabs(w) <= eps * erretm) {
        # 将 *dlam 设置为 d__[*i__] 加上 tau
        *dlam = d__[*i__] + tau;
        # 跳转到标签 L250 处
        goto L250;
    }

    # 如果 w 小于等于 0，执行以下操作
    if (w <= 0.f) {
        # 将 dltlb 更新为 dltlb 和 tau 中的较大值
        dltlb = dmax(dltlb,tau);
    } else {
        # 将 dltub 更新为 dltub 和 tau 中的较小值
        dltub = dmin(dltub,tau);
    }
/*        Calculate the new step */

/* 增加迭代计数器 */
++niter;
/* 计算 c__ 值 */
c__ = w - delta[*n - 1] * dpsi - delta[*n] * dphi;
/* 计算 a 值 */
a = (delta[*n - 1] + delta[*n]) * w - delta[*n - 1] * delta[*n] * (
    dpsi + dphi);
/* 计算 b 值 */
b = delta[*n - 1] * delta[*n] * w;
/* 如果 c__ 小于 0，则取其绝对值 */
if (c__ < 0.f) {
    c__ = dabs(c__);
}
/* 根据 c__ 的值分支选择计算 eta */
if (c__ == 0.f) {
    /* 当 c__ 等于 0 时，计算 eta */
    eta = dltub - tau;
} else if (a >= 0.f) {
    /* 当 a 大于等于 0 时，计算 eta */
    eta = (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) / (
        c__ * 2.f);
} else {
    /* 当 a 小于 0 时，计算 eta */
    eta = b * 2.f / (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(
        r__1))));
}

/*
    Note, eta should be positive if w is negative, and
    eta should be negative otherwise. However,
    if for some reason caused by roundoff, eta*w > 0,
    we simply use one Newton step instead. This way
    will guarantee eta*w < 0.
*/

/* 根据 w 和 eta 的符号决定是否进行修正 */
if (w * eta > 0.f) {
    eta = -w / (dpsi + dphi);
}
/* 计算 temp */
temp = tau + eta;
/* 检查 temp 是否在界限内，否则调整 eta */
if (temp > dltub || temp < dltlb) {
    if (w < 0.f) {
        eta = (dltub - tau) / 2.f;
    } else {
        eta = (dltlb - tau) / 2.f;
    }
}
/* 更新 delta 数组 */
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    delta[j] -= eta;
/* L50: */
}

tau += eta;

/*        Evaluate PSI and the derivative DPSI */

/* 初始化 psi、dpsi 和 erretm */
dpsi = 0.f;
psi = 0.f;
erretm = 0.f;
/* 计算 psi、dpsi 和 erretm */
i__1 = ii;
for (j = 1; j <= i__1; ++j) {
    temp = z__[j] / delta[j];
    psi += z__[j] * temp;
    dpsi += temp * temp;
    erretm += psi;
/* L60: */
}
erretm = dabs(erretm);

/*        Evaluate PHI and the derivative DPHI */

/* 计算 phi 和 dphi */
temp = z__[*n] / delta[*n];
phi = z__[*n] * temp;
dphi = temp * temp;
/* 更新 erretm */
erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) * (
    dpsi + dphi);

w = rhoinv + phi + psi;

/*        Main loop to update the values of the array   DELTA */

iter = niter + 1;

for (niter = iter; niter <= 30; ++niter) {

/*           Test for convergence */

/* 检查收敛性 */
if (dabs(w) <= eps * erretm) {
    *dlam = d__[*i__] + tau;
    goto L250;
}

/* 根据 w 的符号更新界限 */
if (w <= 0.f) {
    dltlb = dmax(dltlb,tau);
} else {
    dltub = dmin(dltub,tau);
}

/*           Calculate the new step */

/* 重新计算 c__、a 和 b */
c__ = w - delta[*n - 1] * dpsi - delta[*n] * dphi;
a = (delta[*n - 1] + delta[*n]) * w - delta[*n - 1] * delta[*n] *
    (dpsi + dphi);
b = delta[*n - 1] * delta[*n] * w;
if (a >= 0.f) {
    eta = (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
         (c__ * 2.f);
} else {
    eta = b * 2.f / (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(
        r__1))));
}
/*
             如果 w * eta > 0.f，则意味着 eta 应该为负值，因为 w 是负数，
             否则 eta 应为正值。然而，如果由于舍入误差导致 eta * w > 0，
             我们只需执行一步牛顿迭代。这样可以确保 eta * w < 0。
*/
        if (w * eta > 0.f) {
            eta = -w / (dpsi + dphi);
        }
        temp = tau + eta;
        // 如果 temp 超出了上界 dltub 或者下界 dltlb
        if (temp > dltub || temp < dltlb) {
            // 如果 w 是负数
            if (w < 0.f) {
                eta = (dltub - tau) / 2.f;
            } else {
                eta = (dltlb - tau) / 2.f;
            }
        }
        // 对于数组 delta 中的每个元素进行更新
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            delta[j] -= eta;
/* L70: */
        }

        tau += eta;

/*           计算 PSI 及其导数 DPSI */

        dpsi = 0.f;
        psi = 0.f;
        erretm = 0.f;
        i__1 = ii;
        for (j = 1; j <= i__1; ++j) {
            temp = z__[j] / delta[j];
            psi += z__[j] * temp;
            dpsi += temp * temp;
            erretm += psi;
/* L80: */
        }
        erretm = dabs(erretm);

/*           计算 PHI 及其导数 DPHI */

        temp = z__[*n] / delta[*n];
        phi = z__[*n] * temp;
        dphi = temp * temp;
        erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) *
            (dpsi + dphi);

        w = rhoinv + phi + psi;
/* L90: */
    }

/*        返回 INFO = 1，NITER = MAXIT，表示未收敛 */

    *info = 1;
    *dlam = d__[*i__] + tau;
    goto L250;

/*        处理 I = N 的情况 */

    } else {

/*        处理 I < N 的情况 */

    niter = 1;
    ip1 = *i__ + 1;

/*        计算初始猜测 */

    del = d__[ip1] - d__[*i__];
    midpt = del / 2.f;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        delta[j] = d__[j] - d__[*i__] - midpt;
/* L100: */
    }

    psi = 0.f;
    i__1 = *i__ - 1;
    for (j = 1; j <= i__1; ++j) {
        psi += z__[j] * z__[j] / delta[j];
/* L110: */
    }

    phi = 0.f;
    i__1 = *i__ + 2;
    for (j = *n; j >= i__1; --j) {
        phi += z__[j] * z__[j] / delta[j];
/* L120: */
    }
    c__ = rhoinv + psi + phi;
    w = c__ + z__[*i__] * z__[*i__] / delta[*i__] + z__[ip1] * z__[ip1] /
        delta[ip1];

    if (w > 0.f) {

/*
             d(i) < 第 i 个特征值 < (d(i)+d(i+1))/2

             我们选择 d(i) 作为原点。
*/

        orgati = TRUE_;
        a = c__ * del + z__[*i__] * z__[*i__] + z__[ip1] * z__[ip1];
        b = z__[*i__] * z__[*i__] * del;
        if (a > 0.f) {
            tau = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(
                r__1))));
        } else {
            tau = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
                 (c__ * 2.f);
        }
        dltlb = 0.f;
        dltub = midpt;
    } else {

/*
             (d(i)+d(i+1))/2 <= 第 i 个特征值 < d(i+1)

             我们选择 d(i+1) 作为原点。
*/
        orgati = FALSE_;
        // 初始化orgati为FALSE，表示orgati变量为假
        a = c__ * del - z__[*i__] * z__[*i__] - z__[ip1] * z__[ip1];
        // 计算a的值，用于后续的计算
        b = z__[ip1] * z__[ip1] * del;
        // 计算b的值，用于后续的计算
        if (a < 0.f) {
        // 如果a小于0
        tau = b * 2.f / (a - sqrt((r__1 = a * a + b * 4.f * c__, dabs(
            r__1))));
        // 根据a和b的值计算tau值
        } else {
        // 如果a不小于0
        tau = -(a + sqrt((r__1 = a * a + b * 4.f * c__, dabs(r__1))))
            / (c__ * 2.f);
        // 根据a和b的值计算tau值
        }
        dltlb = -midpt;
        // 初始化dltlb为-midpt
        dltub = 0.f;
        // 初始化dltub为0
    }

    if (orgati) {
        // 如果orgati为真
        i__1 = *n;
        // 设置i__1为*n
        for (j = 1; j <= i__1; ++j) {
        // 循环，j从1到i__1
        delta[j] = d__[j] - d__[*i__] - tau;
        // 计算delta[j]的值
/* L130: */
        }
    } else {
        // 如果orgati为假
        i__1 = *n;
        // 设置i__1为*n
        for (j = 1; j <= i__1; ++j) {
        // 循环，j从1到i__1
        delta[j] = d__[j] - d__[ip1] - tau;
        // 计算delta[j]的值
/* L140: */
        }
    }
    if (orgati) {
        // 如果orgati为真
        ii = *i__;
        // 设置ii为*i__
    } else {
        // 如果orgati为假
        ii = *i__ + 1;
        // 设置ii为*i__ + 1
    }
    iim1 = ii - 1;
    // 设置iim1为ii - 1
    iip1 = ii + 1;

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.f;
    // 初始化dpsi为0
    psi = 0.f;
    // 初始化psi为0
    erretm = 0.f;
    // 初始化erretm为0
    i__1 = iim1;
    // 设置i__1为iim1
    for (j = 1; j <= i__1; ++j) {
    // 循环，j从1到i__1
        temp = z__[j] / delta[j];
        // 计算temp的值
        psi += z__[j] * temp;
        // 更新psi的值
        dpsi += temp * temp;
        // 更新dpsi的值
        erretm += psi;
/* L150: */
    }
    erretm = dabs(erretm);

/*        Evaluate PHI and the derivative DPHI */

    dphi = 0.f;
    // 初始化dphi为0
    phi = 0.f;
    // 初始化phi为0
    i__1 = iip1;
    // 设置i__1为iip1
    for (j = *n; j >= i__1; --j) {
    // 循环，j从*n递减到i__1
        temp = z__[j] / delta[j];
        // 计算temp的值
        phi += z__[j] * temp;
        // 更新phi的值
        dphi += temp * temp;
        // 更新dphi的值
        erretm += phi;
/* L160: */
    }

    w = rhoinv + phi + psi;

/*
          W is the value of the secular function with
          its ii-th element removed.
*/

    swtch3 = FALSE_;
    // 初始化swtch3为FALSE
    if (orgati) {
        // 如果orgati为真
        if (w < 0.f) {
        // 如果w小于0
        swtch3 = TRUE_;
        // 设置swtch3为TRUE
        }
    } else {
        // 如果orgati为假
        if (w > 0.f) {
        // 如果w大于0
        swtch3 = TRUE_;
        // 设置swtch3为TRUE
        }
    }
    if (ii == 1 || ii == *n) {
        // 如果ii等于1或ii等于*n
        swtch3 = FALSE_;
        // 设置swtch3为FALSE
    }

    temp = z__[ii] / delta[ii];
    // 计算temp的值
    dw = dpsi + dphi + temp * temp;
    // 计算dw的值
    temp = z__[ii] * temp;
    // 计算temp的值
    w += temp;
    // 更新w的值
    erretm = (phi - psi) * 8.f + erretm + rhoinv * 2.f + dabs(temp) * 3.f
        + dabs(tau) * dw;

/*        Test for convergence */

    if (dabs(w) <= eps * erretm) {
        // 如果|w|小于等于eps * erretm
        if (orgati) {
        // 如果orgati为真
        *dlam = d__[*i__] + tau;
        // 更新*dlam的值
        } else {
        // 如果orgati为假
        *dlam = d__[ip1] + tau;
        // 更新*dlam的值
        }
        goto L250;
        // 跳转到标签L250处
    }

    if (w <= 0.f) {
        // 如果w小于等于0
        dltlb = dmax(dltlb,tau);
        // 更新dltlb的值
    } else {
        // 如果w大于0
        dltub = dmin(dltub,tau);
        // 更新dltub的值
    }

/*        Calculate the new step */

    ++niter;
    // niter加1
    if (! swtch3) {
        // 如果swtch3为FALSE
        if (orgati) {
/* Computing 2nd power */
        r__1 = z__[*i__] / delta[*i__];
        // 计算r__1的值
        c__ = w - delta[ip1] * dw - (d__[*i__] - d__[ip1]) * (r__1 *
            r__1);
        // 更新c__的值
        } else {

/* Computing 2nd power */
        r__1 = z__[*i__] / delta[*i__];
        // 计算z__[*i__] / delta[*i__]的平方，并赋给r__1
        c__ = w - delta[ip1] * dw - (d__[*i__] - d__[ip1]) * (r__1 *
            r__1);
        // 计算c__的值
        }
/* 计算二次幂 */
        r__1 = z__[ip1] / delta[ip1];
        c__ = w - delta[*i__] * dw - (d__[ip1] - d__[*i__]) * (r__1 *
            r__1);
        }
        a = (delta[*i__] + delta[ip1]) * w - delta[*i__] * delta[ip1] *
            dw;
        b = delta[*i__] * delta[ip1] * w;
        if (c__ == 0.f) {
        if (a == 0.f) {
            if (orgati) {
            a = z__[*i__] * z__[*i__] + delta[ip1] * delta[ip1] *
                (dpsi + dphi);
            } else {
            a = z__[ip1] * z__[ip1] + delta[*i__] * delta[*i__] *
                (dpsi + dphi);
            }
        }
        eta = b / a;
        } else if (a <= 0.f) {
        eta = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
             (c__ * 2.f);
        } else {
        eta = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(
            r__1))));
        }
    } else {

/*           使用三个最相关的极点进行插值 */

        temp = rhoinv + psi + phi;
        if (orgati) {
        temp1 = z__[iim1] / delta[iim1];
        temp1 *= temp1;
        c__ = temp - delta[iip1] * (dpsi + dphi) - (d__[iim1] - d__[
            iip1]) * temp1;
        zz[0] = z__[iim1] * z__[iim1];
        zz[2] = delta[iip1] * delta[iip1] * (dpsi - temp1 + dphi);
        } else {
        temp1 = z__[iip1] / delta[iip1];
        temp1 *= temp1;
        c__ = temp - delta[iim1] * (dpsi + dphi) - (d__[iip1] - d__[
            iim1]) * temp1;
        zz[0] = delta[iim1] * delta[iim1] * (dpsi + (dphi - temp1));
        zz[2] = z__[iip1] * z__[iip1];
        }
        zz[1] = z__[ii] * z__[ii];
        slaed6_(&niter, &orgati, &c__, &delta[iim1], zz, &w, &eta, info);
        if (*info != 0) {
        goto L250;
        }
    }

/*
          注意，如果 w 为负，eta 应该为正；如果 w 为正，eta 应该为负。然而，
          如果由于舍入误差的原因，eta * w > 0，
          我们只需使用一个牛顿步骤。这样可以保证 eta * w < 0。
*/

    if (w * eta >= 0.f) {
        eta = -w / dw;
    }
    temp = tau + eta;
    if (temp > dltub || temp < dltlb) {
        if (w < 0.f) {
        eta = (dltub - tau) / 2.f;
        } else {
        eta = (dltlb - tau) / 2.f;
        }
    }

    prew = w;

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        delta[j] -= eta;
/* L180: */
    }

/*        计算 PSI 和其导数 DPSI */

    dpsi = 0.f;
    psi = 0.f;
    erretm = 0.f;
    i__1 = iim1;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / delta[j];
        psi += z__[j] * temp;
        dpsi += temp * temp;
        erretm += psi;
/* L190: */
    }
    erretm = dabs(erretm);

/*        计算 PHI 和其导数 DPHI */

    dphi = 0.f;
    phi = 0.f;
    i__1 = iip1;
    for (j = *n; j >= i__1; --j) {
        temp = z__[j] / delta[j];
        phi += z__[j] * temp;
        dphi += temp * temp;
        erretm += phi;
/* L200: */
    }

    temp = z__[ii] / delta[ii];
    dw = dpsi + dphi + temp * temp;
    # 计算 dw，包括 dpsi、dphi 和 temp 的平方
    temp = z__[ii] * temp;
    # 更新 temp，乘以 z__[ii]
    w = rhoinv + phi + psi + temp;
    # 计算 w，包括 rhoinv、phi、psi 和 temp
    erretm = (phi - psi) * 8.f + erretm + rhoinv * 2.f + dabs(temp) * 3.f
        + (r__1 = tau + eta, dabs(r__1)) * dw;
    # 更新 erretm，包括多个加权项和绝对值计算

    swtch = FALSE_;
    # 初始化 swtch 为假
    if (orgati) {
        # 如果 orgati 为真
        if (-w > dabs(prew) / 10.f) {
        # 检查 -w 是否大于 prew 绝对值的十分之一
        swtch = TRUE_;
        # 如果是，则设置 swtch 为真
        }
    } else {
        # 如果 orgati 为假
        if (w > dabs(prew) / 10.f) {
        # 检查 w 是否大于 prew 绝对值的十分之一
        swtch = TRUE_;
        # 如果是，则设置 swtch 为真
        }
    }

    tau += eta;
    # 更新 tau，加上 eta
/*        Main loop to update the values of the array   DELTA */

iter = niter + 1;
// 将 iter 设置为 niter + 1，用于循环迭代

for (niter = iter; niter <= 30; ++niter) {
// 使用 niter 进行循环，从 iter 开始到 30 结束，每次增加 1

/*           Test for convergence */
// 检测收敛性

if (dabs(w) <= eps * erretm) {
// 如果 w 的绝对值小于等于 eps 与 erretm 的乘积

if (orgati) {
*dlam = d__[*i__] + tau;
} else {
*dlam = d__[ip1] + tau;
}
// 如果 orgati 为真，则将 d__[*i__] 或 d__[ip1] 加上 tau 赋给 *dlam，然后跳转到 L250
goto L250;
}

if (w <= 0.f) {
dltlb = dmax(dltlb,tau);
} else {
dltub = dmin(dltub,tau);
}
// 如果 w 小于等于 0，则更新 dltlb 为 dltlb 和 tau 中的较大值；否则更新 dltub 为 dltub 和 tau 中的较小值

/*           Calculate the new step */

if (! swtch3) {
if (! swtch) {
if (orgati) {
/* Computing 2nd power */
r__1 = z__[*i__] / delta[*i__];
c__ = w - delta[ip1] * dw - (d__[*i__] - d__[ip1]) * (
r__1 * r__1);
} else {
/* Computing 2nd power */
r__1 = z__[ip1] / delta[ip1];
c__ = w - delta[*i__] * dw - (d__[ip1] - d__[*i__]) *
(r__1 * r__1);
}
} else {
temp = z__[ii] / delta[ii];
if (orgati) {
dpsi += temp * temp;
} else {
dphi += temp * temp;
}
c__ = w - delta[*i__] * dpsi - delta[ip1] * dphi;
}
a = (delta[*i__] + delta[ip1]) * w - delta[*i__] * delta[ip1]
* dw;
b = delta[*i__] * delta[ip1] * w;
if (c__ == 0.f) {
if (a == 0.f) {
if (! swtch) {
if (orgati) {
a = z__[*i__] * z__[*i__] + delta[ip1] *
delta[ip1] * (dpsi + dphi);
} else {
a = z__[ip1] * z__[ip1] + delta[*i__] * delta[
*i__] * (dpsi + dphi);
}
} else {
a = delta[*i__] * delta[*i__] * dpsi + delta[ip1]
* delta[ip1] * dphi;
}
eta = b / a;
} else if (a <= 0.f) {
eta = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1))
)) / (c__ * 2.f);
} else {
eta = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__,
dabs(r__1))));
}
} else {


注释：
/*
   Interpolation using THREE most relevant poles

   This section performs interpolation using three relevant poles
   based on certain conditions. It calculates various values like `c__`,
   `zz[0]`, and `zz[2]` based on conditions `swtch` and `orgati`.

   Explanation of variables:
   - temp: Combined value of rhoinv, psi, and phi.
   - c__: Interpolated value based on conditions.
   - zz[0], zz[2]: Arrays storing interpolated values.
   - temp1: Temporary variable used in calculations.
   - slaed6_(): External function call for further processing.

   If *info != 0 after slaed6_(), control goes to L250.

   Note on eta adjustment:
   If w * eta >= 0.f, adjusts eta to ensure eta * w < 0.f for stability.

   Further adjustments to delta[j] and tau based on conditions.

   Calculation of psi, dpsi, phi, dphi, dw, w, and erretm based on
   various loops and conditions.

   Additional logic to potentially switch values based on swtch condition.

   The loop continues until the end condition is met.

   Upon exiting the loop, *info is set to 1, indicating non-convergence
   after MAXIT iterations.
*/

/*        Return with INFO = 1, NITER = MAXIT and not converged */

*info = 1;
    # 如果条件 orgati 为真，则执行以下操作
    if (orgati) {
        # 将 d__[i__] 的值加上 tau 赋给 *dlam
        *dlam = d__[*i__] + tau;
    } else {
        # 否则，将 d__[ip1] 的值加上 tau 赋给 *dlam
        *dlam = d__[ip1] + tau;
    }
    
    # 结束条件判断语句的大括号
    }
/* 返回值为 0，标志着 slaed4_ 子程序的结束 */
L250:
    return 0;

/*     End of SLAED4 */

} /* slaed4_ */

/* Subroutine */ int slaed5_(integer *i__, real *d__, real *z__, real *delta,
    real *rho, real *dlam)
{
    /* System generated locals */
    real r__1;

    /* Local variables */
    static real b, c__, w, del, tau, temp;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    This subroutine computes the I-th eigenvalue of a symmetric rank-one
    modification of a 2-by-2 diagonal matrix

               diag( D )  +  RHO *  Z * transpose(Z) .

    The diagonal elements in the array D are assumed to satisfy

               D(i) < D(j)  for  i < j .

    We also assume RHO > 0 and that the Euclidean norm of the vector
    Z is one.

    Arguments
    =========

    I      (input) INTEGER
           The index of the eigenvalue to be computed.  I = 1 or I = 2.

    D      (input) REAL array, dimension (2)
           The original eigenvalues.  We assume D(1) < D(2).

    Z      (input) REAL array, dimension (2)
           The components of the updating vector.

    DELTA  (output) REAL array, dimension (2)
           The vector DELTA contains the information necessary
           to construct the eigenvectors.

    RHO    (input) REAL
           The scalar in the symmetric updating formula.

    DLAM   (output) REAL
           The computed lambda_I, the I-th updated eigenvalue.

    Further Details
    ===============

    Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA

    =====================================================================
*/


    /* Parameter adjustments */
    --delta;
    --z__;
    --d__;

    /* Function Body */
    /* 计算 D(2) - D(1) 的差值 */
    del = d__[2] - d__[1];
    if (*i__ == 1) {
        /* 当 I = 1 时执行以下计算 */
        /* 计算 w */
        w = *rho * 2.f * (z__[2] * z__[2] - z__[1] * z__[1]) / del + 1.f;
        if (w > 0.f) {
            /* 如果 w > 0，执行以下操作 */
            /* 计算 b 和 c */
            b = del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[1] * z__[1] * del;

            /* 计算 tau */
            tau = c__ * 2.f / (b + sqrt((r__1 = b * b - c__ * 4.f, dabs(r__1))));

            /* 计算更新后的 eigenvalue */
            *dlam = d__[1] + tau;

            /* 计算 delta 向量的元素 */
            delta[1] = -z__[1] / tau;
            delta[2] = z__[2] / (del - tau);
        } else {
            /* 如果 w <= 0，执行以下操作 */
            /* 计算 b 和 c */
            b = -del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[2] * z__[2] * del;

            if (b > 0.f) {
                /* 如果 b > 0，计算 tau */
                tau = c__ * -2.f / (b + sqrt(b * b + c__ * 4.f));
            } else {
                /* 如果 b <= 0，计算 tau */
                tau = (b - sqrt(b * b + c__ * 4.f)) / 2.f;
            }

            /* 计算更新后的 eigenvalue */
            *dlam = d__[2] + tau;

            /* 计算 delta 向量的元素 */
            delta[1] = -z__[1] / (del + tau);
            delta[2] = -z__[2] / tau;
        }

        /* 归一化 delta 向量 */
        temp = sqrt(delta[1] * delta[1] + delta[2] * delta[2]);
        delta[1] /= temp;
        delta[2] /= temp;
    } else {

/*     Now I=2 */

        /* 当 I = 2 时执行以下计算 */
        /* 计算 b 和 c */
        b = -del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
        c__ = *rho * z__[2] * z__[2] * del;
    // 如果 b 大于 0，则计算 tau 作为 b 和 sqrt(b * b + c__ * 4.f) 之和的一半
    if (b > 0.f) {
        tau = (b + sqrt(b * b + c__ * 4.f)) / 2.f;
    } else {
        // 如果 b 不大于 0，则计算 tau 作为 c__ * 2.f 除以 (-b + sqrt(b * b + c__ * 4.f)) 的结果
        tau = c__ * 2.f / (-b + sqrt(b * b + c__ * 4.f));
    }
    // 将 d__[2] 和 tau 相加的结果赋值给 dlam
    *dlam = d__[2] + tau;
    // 计算 delta[1]，其中 z__[1] 除以 (del + tau) 的结果的相反数
    delta[1] = -z__[1] / (del + tau);
    // 计算 delta[2]，其中 z__[2] 除以 tau 的结果的相反数
    delta[2] = -z__[2] / tau;
    // 计算 temp 作为 delta[1] 和 delta[2] 的平方根
    temp = sqrt(delta[1] * delta[1] + delta[2] * delta[2]);
    // 将 delta[1] 除以 temp，即将 delta 向量单位化
    delta[1] /= temp;
    // 将 delta[2] 除以 temp，即将 delta 向量单位化
    delta[2] /= temp;
    // 函数执行完毕，返回值为 0
    return 0;
/*     End OF SLAED5 */

} /* slaed5_ */

/* Subroutine */ int slaed6_(integer *kniter, logical *orgati, real *rho,
    real *d__, real *z__, real *finit, real *tau, integer *info)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2, r__3, r__4;

    /* Local variables */
    static real a, b, c__, f;
    static integer i__;
    static real fc, df, ddf, lbd, eta, ubd, eps, base;
    static integer iter;
    static real temp, temp1, temp2, temp3, temp4;
    static logical scale;
    static integer niter;
    static real small1, small2, sminv1, sminv2, dscale[3], sclfac;
    extern doublereal slamch_(char *);
    static real zscale[3], erretm, sclinv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       February 2007


    Purpose
    =======

    SLAED6 computes the positive or negative root (closest to the origin)
    of
                     z(1)        z(2)        z(3)
    f(x) =   rho + --------- + ---------- + ---------
                    d(1)-x      d(2)-x      d(3)-x

    It is assumed that

          if ORGATI = .true. the root is between d(2) and d(3);
          otherwise it is between d(1) and d(2)

    This routine will be called by SLAED4 when necessary. In most cases,
    the root sought is the smallest in magnitude, though it might not be
    in some extremely rare situations.

    Arguments
    =========

    KNITER       (input) INTEGER
                 Refer to SLAED4 for its significance.

    ORGATI       (input) LOGICAL
                 If ORGATI is true, the needed root is between d(2) and
                 d(3); otherwise it is between d(1) and d(2).  See
                 SLAED4 for further details.

    RHO          (input) REAL
                 Refer to the equation f(x) above.

    D            (input) REAL array, dimension (3)
                 D satisfies d(1) < d(2) < d(3).

    Z            (input) REAL array, dimension (3)
                 Each of the elements in z must be positive.

    FINIT        (input) REAL
                 The value of f at 0. It is more accurate than the one
                 evaluated inside this routine (if someone wants to do
                 so).

    TAU          (output) REAL
                 The root of the equation f(x).

    INFO         (output) INTEGER
                 = 0: successful exit
                 > 0: if INFO = 1, failure to converge

    Further Details
    ===============

    30/06/99: Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA

    10/02/03: This version has a few statements commented out for thread safety
       (machine parameters are computed on each entry). SJH.

    05/10/06: Modified from a new version of Ren-Cang Li, use
       Gragg-Thornton-Warner cubic convergent scheme for better stability.


    SLAED6:

    SLAED6 computes the root of a cubic equation of the form:

      f(x) = rho + z(1)/(d(1)-x) + z(2)/(d(2)-x) + z(3)/(d(3)-x)

    This subroutine determines whether the root is between d(2) and d(3)
    or between d(1) and d(2) based on the input ORGATI.

    It uses the Gragg-Thornton-Warner cubic convergent scheme for stability
    and accuracy. The root computed is the one closest to the origin in
    magnitude.

    Parameters
    ----------
    kniter : INTEGER
        Number of iterations performed (used by SLAED4).
    orgati : LOGICAL
        Flag indicating the interval in which the root is sought.
    rho : REAL
        Constant term in the cubic equation.
    d : REAL array, dimension (3)
        Array containing the sorted eigenvalues of the tridiagonal matrix.
    z : REAL array, dimension (3)
        Array containing positive weights.
    finit : REAL
        Initial value of f(x) at 0.
    tau : REAL
        Computed root of the cubic equation f(x).
    info : INTEGER
        Error flag:
          - 0 : Successful exit.
          - 1 : Failure to converge.

    Returns
    -------
    None

    References
    ----------
    LAPACK Version 3.2, LAPACK Working Note 150, University of Tennessee,
    University of California Berkeley, University of Colorado Denver, NAG Ltd.,
    February 2007.

    Notes
    -----
    This routine is based on contributions by Ren-Cang Li, University of
    California at Berkeley, and includes modifications for stability and
    efficiency by the LAPACK team.

*/
    # 定义一个名为 count_digits 的函数，接收一个整数参数 num
    def count_digits(num):
        # 将整数 num 转换为字符串，然后使用 len() 函数获取字符串长度，即数字的位数
        num_str = str(num)
        num_digits = len(num_str)
        
        # 如果 num 是负数，则数字位数减一，因为负号占据了一位
        if num < 0:
            num_digits -= 1
        
        # 返回计算得到的数字位数
        return num_digits
    /* Parameter adjustments */
    --z__;
    --d__;

    /* Function Body */
    *info = 0;

    if (*orgati) {
        // 如果 orgati 为真，设置 lbd 和 ubd 为数组 d__ 中的第三个和第四个元素
        lbd = d__[2];
        ubd = d__[3];
    } else {
        // 如果 orgati 为假，设置 lbd 和 ubd 为数组 d__ 中的第一个和第二个元素
        lbd = d__[1];
        ubd = d__[2];
    }
    if (*finit < 0.f) {
        // 如果 finit 小于零，设置 lbd 为零
        lbd = 0.f;
    } else {
        // 否则，设置 ubd 为零
        ubd = 0.f;
    }

    niter = 1;
    *tau = 0.f;
    if (*kniter == 2) {
        if (*orgati) {
            // 如果 orgati 为真，计算临时变量 temp
            temp = (d__[3] - d__[2]) / 2.f;
            c__ = *rho + z__[1] / (d__[1] - d__[2] - temp);
            a = c__ * (d__[2] + d__[3]) + z__[2] + z__[3];
            b = c__ * d__[2] * d__[3] + z__[2] * d__[3] + z__[3] * d__[2];
        } else {
            // 如果 orgati 为假，计算临时变量 temp
            temp = (d__[1] - d__[2]) / 2.f;
            c__ = *rho + z__[3] / (d__[3] - d__[2] - temp);
            a = c__ * (d__[1] + d__[2]) + z__[1] + z__[2];
            b = c__ * d__[1] * d__[2] + z__[1] * d__[2] + z__[2] * d__[1];
        }
        /* Computing MAX */
        r__1 = fabs(a), r__2 = fabs(b), r__1 = max(r__1,r__2), r__2 = fabs(c__);
        temp = dmax(r__1,r__2);
        a /= temp;
        b /= temp;
        c__ /= temp;
        if (c__ == 0.f) {
            *tau = b / a;
        } else if (a <= 0.f) {
            *tau = (a - sqrt((r__1 = a * a - b * 4.f * c__, fabs(r__1)))) / (c__ * 2.f);
        } else {
            *tau = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, fabs(r__1))));
        }
        if (*tau < lbd || *tau > ubd) {
            *tau = (lbd + ubd) / 2.f;
        }
        if (d__[1] == *tau || d__[2] == *tau || d__[3] == *tau) {
            *tau = 0.f;
        } else {
            temp = *finit + *tau * z__[1] / (d__[1] * (d__[1] - *tau)) + *tau * z__[2] / (d__[2] * (d__[2] - *tau)) + *tau * z__[3] / (d__[3] * (d__[3] - *tau));
            if (temp <= 0.f) {
                lbd = *tau;
            } else {
                ubd = *tau;
            }
            if (fabs(*finit) <= fabs(temp)) {
                *tau = 0.f;
            }
        }
    }

    /*
           get machine parameters for possible scaling to avoid overflow

           modified by Sven: parameters SMALL1, SMINV1, SMALL2,
           SMINV2, EPS are not SAVEd anymore between one call to the
           others but recomputed at each call
    */

    eps = slamch_("Epsilon");
    base = slamch_("Base");
    i__1 = (integer) (log(slamch_("SafMin")) / log(base) / 3.f);
    small1 = pow_ri(&base, &i__1);
    sminv1 = 1.f / small1;
    small2 = small1 * small1;
    sminv2 = sminv1 * sminv1;

    /*
           Determine if scaling of inputs necessary to avoid overflow
           when computing 1/TEMP**3
    */

    if (*orgati) {
        /* Computing MIN */
        r__3 = fabs(d__[2] - *tau), r__4 = fabs(d__[3] - *tau);
        temp = dmin(r__3,r__4);
    } else {
        /* Computing MIN */
        r__3 = fabs(d__[1] - *tau), r__4 = fabs(d__[2] - *tau);
        temp = dmin(r__3,r__4);
    }
    scale = FALSE_;
    if (temp <= small1) {
        scale = TRUE_;
        if (temp <= small2) {

            /* Scale up by power of radix nearest 1/SAFMIN**(2/3) */

            sclfac = sminv2;
            sclinv = small2;
        } else {

            /* Scale up by power of radix nearest 1/SAFMIN**(1/2) */
            sclfac = sminv1;
            sclinv = small1;
        }
    } else {
        // 如果 temp 大于 small1，则不需要缩放
        scale = FALSE_;
    }
/*        Scale up by power of radix nearest 1/SAFMIN**(1/3) */
/*        根据与 SAFMIN 的比例调整缩放因子 */

sclfac = sminv1;
sclinv = small1;
}

/*        Scaling up safe because D, Z, TAU scaled elsewhere to be O(1) */
/*        缩放是安全的，因为 D、Z 和 TAU 已经在其他地方被缩放到 O(1) */

for (i__ = 1; i__ <= 3; ++i__) {
    dscale[i__ - 1] = d__[i__] * sclfac;
    zscale[i__ - 1] = z__[i__] * sclfac;
/* L10: */
}
*tau *= sclfac;
lbd *= sclfac;
ubd *= sclfac;
} else {

/*        Copy D and Z to DSCALE and ZSCALE */
/*        将 D 和 Z 复制到 DSCALE 和 ZSCALE */

for (i__ = 1; i__ <= 3; ++i__) {
    dscale[i__ - 1] = d__[i__];
    zscale[i__ - 1] = z__[i__];
/* L20: */
}
}

fc = 0.f;
df = 0.f;
ddf = 0.f;
for (i__ = 1; i__ <= 3; ++i__) {
temp = 1.f / (dscale[i__ - 1] - *tau);
temp1 = zscale[i__ - 1] * temp;
temp2 = temp1 * temp;
temp3 = temp2 * temp;
fc += temp1 / dscale[i__ - 1];
df += temp2;
ddf += temp3;
/* L30: */
}
f = *finit + *tau * fc;

if (dabs(f) <= 0.f) {
goto L60;
}
if (f <= 0.f) {
lbd = *tau;
} else {
ubd = *tau;
}

/*
      Iteration begins -- Use Gragg-Thornton-Warner cubic convergent
                          scheme

   It is not hard to see that

         1) Iterations will go up monotonically
            if FINIT < 0;

         2) Iterations will go down monotonically
            if FINIT > 0.
*/
/*      迭代开始 -- 使用 Gragg-Thornton-Warner 三次收敛方案 */
/*      可以看出： */
/*         1) 如果 FINIT < 0，迭代会单调增加； */
/*         2) 如果 FINIT > 0，迭代会单调减少。 */

iter = niter + 1;

for (niter = iter; niter <= 40; ++niter) {

if (*orgati) {
    temp1 = dscale[1] - *tau;
    temp2 = dscale[2] - *tau;
} else {
    temp1 = dscale[0] - *tau;
    temp2 = dscale[1] - *tau;
}
a = (temp1 + temp2) * f - temp1 * temp2 * df;
b = temp1 * temp2 * f;
c__ = f - (temp1 + temp2) * df + temp1 * temp2 * ddf;
/* Computing MAX */
r__1 = dabs(a), r__2 = dabs(b), r__1 = max(r__1,r__2), r__2 = dabs(
    c__);
temp = dmax(r__1,r__2);
a /= temp;
b /= temp;
c__ /= temp;
if (c__ == 0.f) {
    eta = b / a;
} else if (a <= 0.f) {
    eta = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) / (
        c__ * 2.f);
} else {
    eta = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(
        r__1))));
}
if (f * eta >= 0.f) {
    eta = -f / df;
}

*tau += eta;
if (*tau < lbd || *tau > ubd) {
    *tau = (lbd + ubd) / 2.f;
}

fc = 0.f;
erretm = 0.f;
df = 0.f;
ddf = 0.f;
for (i__ = 1; i__ <= 3; ++i__) {
    temp = 1.f / (dscale[i__ - 1] - *tau);
    temp1 = zscale[i__ - 1] * temp;
    temp2 = temp1 * temp;
    temp3 = temp2 * temp;
    temp4 = temp1 / dscale[i__ - 1];
    fc += temp4;
    erretm += dabs(temp4);
    df += temp2;
    ddf += temp3;
/* L40: */
}
f = *finit + *tau * fc;
erretm = (dabs(*finit) + dabs(*tau) * erretm) * 8.f + dabs(*tau) * df;
if (dabs(f) <= eps * erretm) {
    goto L60;
}
if (f <= 0.f) {
    lbd = *tau;
} else {
    ubd = *tau;
}
/* L50: */
    }
    // 将指针 info 指向的变量赋值为 1
    *info = 1;
L60:
    /* Undo scaling */
    if (scale) {
        *tau *= sclinv;
    }
    return 0;

} /* slaed6_ */

/* Subroutine */ int slaed7_(integer *icompq, integer *n, integer *qsiz,
    integer *tlvls, integer *curlvl, integer *curpbm, real *d__, real *q,
    integer *ldq, integer *indxq, real *rho, integer *cutpnt, real *
    qstore, integer *qptr, integer *prmptr, integer *perm, integer *
    givptr, integer *givcol, real *givnum, real *work, integer *iwork,
    integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;

    /* Local variables */
    static integer i__, k, n1, n2, is, iw, iz, iq2, ptr, ldq2, indx, curr,
        indxc;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer indxp;
    extern /* Subroutine */ int slaed8_(integer *, integer *, integer *,
        integer *, real *, real *, integer *, integer *, real *, integer *
        , real *, real *, real *, integer *, real *, integer *, integer *,
         integer *, real *, integer *, integer *, integer *), slaed9_(
        integer *, integer *, integer *, integer *, real *, real *,
        integer *, real *, real *, real *, real *, integer *, integer *);
    static integer idlmda;
    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
        integer *, integer *, real *, integer *, integer *, integer *);
    static integer coltyp;

    /*
        -- LAPACK routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006

        Purpose
        =======

        SLAED7 computes the updated eigensystem of a diagonal
        matrix after modification by a rank-one symmetric matrix. This
        routine is used only for the eigenproblem which requires all
        eigenvalues and optionally eigenvectors of a dense symmetric matrix
        that has been reduced to tridiagonal form.  SLAED1 handles
        the case in which all eigenvalues and eigenvectors of a symmetric
    */
    # 定义一个过程，修复受到单个特征向量扰动的对称三对角矩阵的特征值和特征向量。
    #
    # 修复的方法是通过对称三对角矩阵的特征值进行分析，结合特定的向量 Z 来调整矩阵。
    # 结果是更新后的特征值存储在 D 中，更新后的特征向量存储在 Q 中。
    #
    # 参数
    # ======
    #
    # ICOMPQ  (输入) 整数
    #         = 0: 仅计算特征值。
    #         = 1: 计算原始密集对称矩阵的特征向量。输入时，Q 包含用于将原始矩阵
    #              缩减为三对角形式的正交矩阵。
    #
    # N      (输入) 整数
    #        对称三对角矩阵的维度。N >= 0。
    #
    # QSIZ   (输入) 整数
    #        用于将完整矩阵缩减为三对角形式的正交矩阵的维度。如果 ICOMPQ = 1，则 QSIZ >= N。
    #
    # TLVLS  (输入) 整数
    #        整体分治树中的合并级别总数。
    #
    # CURLVL (输入) 整数
    #        整体合并过程中的当前级别，0 <= CURLVL <= TLVLS。
    #
    # CURPBM (输入) 整数
    #        整体合并过程中当前级别的当前问题（从左上到右下计数）。
    #
    # D      (输入/输出) 实数数组，维度为 (N)
    #        输入时，被扰动矩阵的特征值。输出时，修复后矩阵的特征值。
    #
    # Q      (输入/输出) 实数数组，维度为 (LDQ, N)
    #        输入时，被扰动矩阵的特征向量。输出时，修复后三对角矩阵的特征向量。
    #
    # LDQ    (输入) 整数
    #        数组 Q 的主维度。LDQ >= max(1, N)。
    #
    # INDXQ  (输出) 整数数组，维度为 (N)
    #        排列，用于将刚解决的子问题重新整合为排序顺序，即 D( INDXQ( I = 1, N ) )
    #        将按升序排列。
    # RHO 是一个实数，表示用来创建秩-1修改的次对角线元素。

    # CUTPNT 是一个整数，表示前导子矩阵中最后一个特征值的位置。
    # min(1, N) <= CUTPNT <= N，确保其在合理范围内。

    # QSTORE 是一个实数数组，维度为 (N**2+1)，用来存储在分治过程中遇到的子矩阵的特征向量，紧凑存储。
    # QPTR 是一个整数数组，维度为 (N+2)，用来存储指向 QSTORE 中子矩阵起始位置的索引。
    # QPTR 的子矩阵从分治树的左下角开始编号，从左到右，从底部到顶部。

    # PRMPTR 是一个整数数组，维度为 (N lg N)，包含指针列表，指示 PERM 中存储每个层级的排列的位置。
    # PRMPTR(i+1) - PRMPTR(i) 指示排列的大小，也是非缩小问题的大小。

    # PERM 是一个整数数组，维度为 (N lg N)，包含需要应用到每个特征块的排列（通过缩小和排序获得）。

    # GIVPTR 是一个整数数组，维度为 (N lg N)，包含指针列表，指示 GIVCOL 中存储每个层级的 Givens 旋转的位置。
    # GIVPTR(i+1) - GIVPTR(i) 指示 Givens 旋转的数量。

    # GIVCOL 是一个整数数组，维度为 (2, N lg N)，每一对数字表示参与 Givens 旋转的两列。

    # GIVNUM 是一个实数数组，维度为 (2, N lg N)，每个数字表示相应 Givens 旋转中要使用的 S 值。

    # WORK 是一个实数数组，维度为 (3*N + QSIZ*N)，用作工作空间。

    # IWORK 是一个整数数组，维度为 (4*N)，用作工作空间。

    # INFO 是一个整数，输出参数：
    #   = 0: 成功退出。
    #   < 0: 如果 INFO = -i，则第 i 个参数的值非法。
    #   > 0: 如果 INFO = 1，则某个特征值未收敛。

    # 进一步详情：
    # 根据 Jeff Rutter 在加州大学伯克利分校的计算机科学部门的贡献。

    # 测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;                              // 调整参数 d__ 指针
    q_dim1 = *ldq;                      // 设置 Q 数组第一维度
    q_offset = 1 + q_dim1;              // 计算 Q 数组的偏移量
    q -= q_offset;                      // 调整 Q 数组指针
    --indxq;                            // 调整 indxq 数组指针
    --qstore;                           // 调整 qstore 数组指针
    --qptr;                             // 调整 qptr 数组指针
    --prmptr;                           // 调整 prmptr 数组指针
    --perm;                             // 调整 perm 数组指针
    --givptr;                           // 调整 givptr 数组指针
    givcol -= 3;                        // 调整 givcol 数组指针
    givnum -= 3;                        // 调整 givnum 数组指针
    --work;                             // 调整 work 数组指针
    --iwork;                            // 调整 iwork 数组指针

    /* Function Body */
    *info = 0;                          // 初始化 info 为 0

    if (*icompq < 0 || *icompq > 1) {   // 检查 icompq 的值是否合法
        *info = -1;
    } else if (*n < 0) {                // 检查 n 是否合法
        *info = -2;
    } else if (*icompq == 1 && *qsiz < *n) {  // 检查在 icompq 为 1 时 qsiz 的合法性
        *info = -4;
    } else if (*ldq < max(1,*n)) {      // 检查 ldq 的合法性
        *info = -9;
    } else if (min(1,*n) > *cutpnt || *n < *cutpnt) {  // 检查 cutpnt 的合法性
        *info = -12;
    }
    if (*info != 0) {                   // 如果出现错误，调用错误处理函数 xerbla_
        i__1 = -(*info);
        xerbla_("SLAED7", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {                      // 如果 n 为 0，直接返回
        return 0;
    }

    /*
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in SLAED8 and SLAED9.
    */

    if (*icompq == 1) {                 // 根据 icompq 的值设置 ldq2
        ldq2 = *qsiz;
    } else {
        ldq2 = *n;
    }

    iz = 1;                             // 设置 iz 指针位置
    idlmda = iz + *n;                   // 设置 idlmda 指针位置
    iw = idlmda + *n;                   // 设置 iw 指针位置
    iq2 = iw + *n;                      // 设置 iq2 指针位置
    is = iq2 + *n * ldq2;               // 设置 is 指针位置

    indx = 1;                           // 设置 indx 指针位置
    indxc = indx + *n;                  // 设置 indxc 指针位置
    coltyp = indxc + *n;                // 设置 coltyp 指针位置
    indxp = coltyp + *n;                // 设置 indxp 指针位置

    /*
       Form the z-vector which consists of the last row of Q_1 and the
       first row of Q_2.
    */

    ptr = pow_ii(&c__2, tlvls) + 1;      // 计算 ptr 的值
    i__1 = *curlvl - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = *tlvls - i__;
        ptr += pow_ii(&c__2, &i__2);    // 根据循环计算 ptr 的值
    }
    curr = ptr + *curpbm;               // 设置 curr 的值
    slaeda_(n, tlvls, curlvl, curpbm, &prmptr[1], &perm[1], &givptr[1], &
        givcol[3], &givnum[3], &qstore[1], &qptr[1], &work[iz], &work[iz
        + *n], info);                   // 调用 slaeda_ 函数

    /*
       When solving the final problem, we no longer need the stored data,
       so we will overwrite the data from this level onto the previously
       used storage space.
    */

    if (*curlvl == *tlvls) {            // 如果当前层级等于总层级数，进行数据清理
        qptr[curr] = 1;                 // 重置 qptr
        prmptr[curr] = 1;               // 重置 prmptr
        givptr[curr] = 1;               // 重置 givptr
    }

    /* Sort and Deflate eigenvalues. */
    slaed8_(icompq, &k, n, qsiz, &d__[1], &q[q_offset], ldq, &indxq[1], rho,
        cutpnt, &work[iz], &work[idlmda], &work[iq2], &ldq2, &work[iw], &
        perm[prmptr[curr]], &givptr[curr + 1], &givcol[(givptr[curr] << 1)
         + 1], &givnum[(givptr[curr] << 1) + 1], &iwork[indxp], &iwork[
        indx], info);                    // 调用 slaed8_ 函数
    prmptr[curr + 1] = prmptr[curr] + *n;   // 更新 prmptr
    givptr[curr + 1] += givptr[curr];       // 更新 givptr

    /* Solve Secular Equation. */
    if (k != 0) {                       // 如果 k 不为 0，调用 slaed9_ 函数
        slaed9_(&k, &c__1, &k, n, &d__[1], &work[is], &k, rho, &work[idlmda],
            &work[iw], &qstore[qptr[curr]], &k, info);
        if (*info != 0) {               // 如果 slaed9_ 返回错误信息，跳转到 L30
            goto L30;
        }
        if (*icompq == 1) {             // 如果 icompq 为 1，调用 sgemm_ 函数
            sgemm_("N", "N", qsiz, &k, &k, &c_b15, &work[iq2], &ldq2, &qstore[
                qptr[curr]], &k, &c_b29, &q[q_offset], ldq);
        }
        /* Computing 2nd power */
        i__1 = k;
        qptr[curr + 1] = qptr[curr] + i__1 * i__1;   // 更新 qptr
    }

    /* Prepare the INDXQ sorting permutation. */
    n1 = k;                             // 设置 n1
    n2 = *n - k;                        // 设置 n2
    # 调用 SLAMRG 函数，对数组进行排序
    slamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &indxq[1]);
    } else {
    # 当前索引位置的下一个指针指向当前位置指针的值
    qptr[curr + 1] = qptr[curr];
    # 循环遍历每个元素
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 初始化 indxq 数组，将每个元素的索引设置为自身
        indxq[i__] = i__;
/* L20: */
    }
    }

L30:
    return 0;

/*     End of SLAED7 */

} /* slaed7_ */

/* Subroutine */ int slaed8_(integer *icompq, integer *k, integer *n, integer
    *qsiz, real *d__, real *q, integer *ldq, integer *indxq, real *rho,
    integer *cutpnt, real *z__, real *dlamda, real *q2, integer *ldq2,
    real *w, integer *perm, integer *givptr, integer *givcol, real *
    givnum, integer *indxp, integer *indx, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, q2_dim1, q2_offset, i__1;
    real r__1;

    /* Local variables */
    static real c__;
    static integer i__, j;
    static real s, t;
    static integer k2, n1, n2, jp, n1p1;
    static real eps, tau, tol;
    static integer jlam, imax, jmax;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *), sscal_(integer *, real *, real *,
        integer *), scopy_(integer *, real *, integer *, real *, integer *
        );
    extern doublereal slapy2_(real *, real *), slamch_(char *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer isamax_(integer *, real *, integer *);
    extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer
        *, integer *, integer *), slacpy_(char *, integer *, integer *,
        real *, integer *, real *, integer *);


/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SLAED8 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny element in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.

    K      (output) INTEGER
           The number of non-deflated eigenvalues, and the order of the
           related secular equation.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    QSIZ   (input) INTEGER
           The dimension of the orthogonal matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.

    D      (input/output) REAL array, dimension (N)
           On entry, the eigenvalues of the two submatrices to be
           combined.  On exit, the trailing (N-K) updated eigenvalues
           (those which were deflated) sorted into increasing order.



注释：
    Q      (input/output) REAL array, dimension (LDQ,N)
           If ICOMPQ = 0, Q is not referenced.  Otherwise,
           on entry, Q contains the eigenvectors of the partially solved
           system which has been previously updated in matrix
           multiplies with other partially solved eigensystems.
           On exit, Q contains the trailing (N-K) updated eigenvectors
           (those which were deflated) in its last N-K columns.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    INDXQ  (input) INTEGER array, dimension (N)
           The permutation which separately sorts the two sub-problems
           in D into ascending order.  Note that elements in the second
           half of this permutation must first have CUTPNT added to
           their values in order to be accurate.

    RHO    (input/output) REAL
           On entry, the off-diagonal element associated with the rank-1
           cut which originally split the two submatrices which are now
           being recombined.
           On exit, RHO has been modified to the value required by
           SLAED3.

    CUTPNT (input) INTEGER
           The location of the last eigenvalue in the leading
           sub-matrix.  min(1,N) <= CUTPNT <= N.

    Z      (input) REAL array, dimension (N)
           On entry, Z contains the updating vector (the last row of
           the first sub-eigenvector matrix and the first row of the
           second sub-eigenvector matrix).
           On exit, the contents of Z are destroyed by the updating
           process.

    DLAMDA (output) REAL array, dimension (N)
           A copy of the first K eigenvalues which will be used by
           SLAED3 to form the secular equation.

    Q2     (output) REAL array, dimension (LDQ2,N)
           If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
           a copy of the first K eigenvectors which will be used by
           SLAED7 in a matrix multiply (SGEMM) to update the new
           eigenvectors.

    LDQ2   (input) INTEGER
           The leading dimension of the array Q2.  LDQ2 >= max(1,N).

    W      (output) REAL array, dimension (N)
           The first k values of the final deflation-altered z-vector and
           will be passed to SLAED3.

    PERM   (output) INTEGER array, dimension (N)
           The permutations (from deflation and sorting) to be applied
           to each eigenblock.

    GIVPTR (output) INTEGER
           The number of Givens rotations which took place in this
           subproblem.

    GIVCOL (output) INTEGER array, dimension (2, N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

    GIVNUM (output) REAL array, dimension (2, N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.
    # INDXP 是一个整数数组，维度为 (N)，用于存储 D 的排列顺序，将被压缩的值放在数组末尾。
    # INDXP(1:K) 指向非压缩的 D 值，INDXP(K+1:N) 指向压缩的特征值。

    # INDX 是一个整数数组，维度为 (N)，用于对 D 的内容进行升序排序。

    # INFO 是输出参数，返回程序执行状态：
    #     = 0: 成功退出。
    #     < 0: 如果 INFO = -i，表示第 i 个参数具有非法值。

    # 进一步细节说明：
    #     根据 Jeff Rutter 在加州大学伯克利分校计算机科学部门的贡献。
    /* Parameter adjustments */
    --d__;              // 调整参数 d__ 数组，d__ 是一个浮点数数组
    q_dim1 = *ldq;      // q_dim1 是二维数组 q 的第一维大小，通过 ldq 来计算
    q_offset = 1 + q_dim1;  // 计算 q 数组的偏移量
    q -= q_offset;      // 调整 q 数组的起始位置到偏移量处
    --indxq;            // 调整参数 indxq，indxq 是一个整数数组
    --z__;              // 调整参数 z__，z__ 是一个浮点数数组
    --dlamda;           // 调整参数 dlamda，dlamda 是一个浮点数数组
    q2_dim1 = *ldq2;    // q2_dim1 是二维数组 q2 的第一维大小，通过 ldq2 来计算
    q2_offset = 1 + q2_dim1;  // 计算 q2 数组的偏移量
    q2 -= q2_offset;    // 调整 q2 数组的起始位置到偏移量处
    --w;                // 调整参数 w，w 是一个浮点数数组
    --perm;             // 调整参数 perm，perm 是一个整数数组
    givcol -= 3;        // 调整参数 givcol，givcol 是一个浮点数数组，减去常数 3
    givnum -= 3;        // 调整参数 givnum，givnum 是一个浮点数数组，减去常数 3
    --indxp;            // 调整参数 indxp，indxp 是一个整数数组
    --indx;             // 调整参数 indx，indx 是一个整数数组

    /* Function Body */
    *info = 0;          // 将 info 变量设为 0

    if (*icompq < 0 || *icompq > 1) {  // 检查参数 icompq 是否在有效范围内
        *info = -1;
    } else if (*n < 0) {    // 检查参数 n 是否为负数
        *info = -3;
    } else if (*icompq == 1 && *qsiz < *n) {  // 当 icompq 为 1 时，检查 qsiz 是否小于 n
        *info = -4;
    } else if (*ldq < max(1,*n)) {  // 检查 ldq 是否合法
        *info = -7;
    } else if (*cutpnt < min(1,*n) || *cutpnt > *n) {  // 检查 cutpnt 是否在有效范围内
        *info = -10;
    } else if (*ldq2 < max(1,*n)) {  // 检查 ldq2 是否合法
        *info = -14;
    }
    if (*info != 0) {   // 如果 info 不为 0，则报错并返回
        i__1 = -(*info);
        xerbla_("SLAED8", &i__1);
        return 0;
    }

    /*
       Need to initialize GIVPTR to 0 here in case of quick exit
       to prevent an unspecified code behavior (usually sigfault)
       when IWORK array on entry to *stedc is not zeroed
       (or at least some IWORK entries which used in *laed7 for GIVPTR).
    */
    *givptr = 0;    // 将 givptr 变量初始化为 0，以防止快速退出时出现未指定的代码行为（通常是段错误）

    /* Quick return if possible */
    if (*n == 0) {  // 如果 n 为 0，则直接返回
        return 0;
    }

    n1 = *cutpnt;   // 设置 n1 为 cutpnt 的值
    n2 = *n - n1;   // 计算 n2，即 n - cutpnt
    n1p1 = n1 + 1;  // 计算 n1+1 的值

    if (*rho < 0.f) {   // 如果 rho 小于 0
        sscal_(&n2, &c_b151, &z__[n1p1], &c__1);  // 对 z 数组的一部分进行缩放
    }

    /* Normalize z so that norm(z) = 1 */
    t = 1.f / sqrt(2.f);    // 计算常数 t
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        indx[j] = j;    // 初始化 indx 数组
    }
    sscal_(n, &t, &z__[1], &c__1);   // 对 z 数组进行缩放
    *rho = (r__1 = *rho * 2.f, dabs(r__1));    // 更新 rho 的值

    /* Sort the eigenvalues into increasing order */
    i__1 = *n;
    for (i__ = *cutpnt + 1; i__ <= i__1; ++i__) {
        indxq[i__] += *cutpnt;  // 更新 indxq 数组的值
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dlamda[i__] = d__[indxq[i__]];  // 更新 dlamda 数组的值
        w[i__] = z__[indxq[i__]];       // 更新 w 数组的值
    }
    i__ = 1;
    j = *cutpnt + 1;
    slamrg_(&n1, &n2, &dlamda[1], &c__1, &c__1, &indx[1]);  // 调用 slamrg 函数对数组进行排序
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        d__[i__] = dlamda[indx[i__]];   // 更新 d 数组的值
        z__[i__] = w[indx[i__]];        // 更新 z 数组的值
    }

    /* Calculate the allowable deflation tolerence */
    imax = isamax_(n, &z__[1], &c__1);   // 计算 z 数组中绝对值最大元素的索引
    jmax = isamax_(n, &d__[1], &c__1);   // 计算 d 数组中绝对值最大元素的索引
    eps = slamch_("Epsilon");           // 获取机器精度
    tol = eps * 8.f * (r__1 = d__[jmax], dabs(r__1));   // 计算容许的小量 tol

    /*
       If the rank-1 modifier is small enough, no more needs to be done
       except to reorganize Q so that its columns correspond with the
       elements in D.
    */
    if (*rho * (r__1 = z__[imax], dabs(r__1)) <= tol) {   // 如果 rank-1 修正因子足够小，则进行快速返回
        *k = 0;     // 设置 k 为 0
        if (*icompq == 0) {     // 如果 icompq 为 0
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                perm[j] = indxq[indx[j]];   // 更新 perm 数组的值
            }
        } else {    // 如果 icompq 不为 0
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                perm[j] = indxq[indx[j]];   // 更新 perm 数组的值
                scopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1
                    + 1], &c__1);   // 复制 q 的部分数据到 q2
            }
            slacpy_("A", qsiz, n, &q2[q2_dim1 + 1], ldq2, &q[q_dim1 + 1], ldq);  // 复制 q2 的数据到 q
        }
        return 0;   // 返回
    }
/*
   如果存在多个特征值，则问题会发生排除。在这里找到相等特征值的数量。每当找到一个相等的特征值时，
   就计算一个初等反射器来旋转相应的特征子空间，使得在这个新的基础上Z的相应分量为零。
*/

*k = 0;                          // 初始化相等特征值的数量为0
k2 = *n + 1;                     // k2 是索引指针，初始值为n+1
i__1 = *n;
for (j = 1; j <= i__1; ++j) {    // 遍历特征值数组
if (*rho * (r__1 = z__[j], dabs(r__1)) <= tol) {

/*           由于Z分量较小，进行排除。 */

    --k2;                       // k2向左移动一个位置
    indxp[k2] = j;              // 记录需要排除的特征值的索引
    if (j == *n) {
    goto L110;
    }
} else {
    jlam = j;                   // 记录当前特征值的索引
    goto L80;
}
/* L70: */
}
L80:
++j;                            // 继续向下一个特征值移动
if (j > *n) {
goto L100;
}
if (*rho * (r__1 = z__[j], dabs(r__1)) <= tol) {

/*        由于Z分量较小，进行排除。 */

--k2;                           // k2向左移动一个位置
indxp[k2] = j;                  // 记录需要排除的特征值的索引
} else {

/*        检查特征值是否足够接近以允许排除。 */

s = z__[jlam];                  // 记录上一个特征值
c__ = z__[j];                   // 记录当前特征值

/*
      找到sqrt(a**2+b**2)，避免溢出或破坏性下溢。
*/

tau = slapy2_(&c__, &s);        // 计算sqrt(c__^2 + s^2)
t = d__[j] - d__[jlam];         // 计算特征值之间的差
c__ /= tau;                     // 根据tau调整c__
s = -s / tau;                   // 根据tau调整s
if ((r__1 = t * c__ * s, dabs(r__1)) <= tol) {

/*           可以进行排除。 */

    z__[j] = tau;               // 更新特征值数组
    z__[jlam] = 0.f;            // 将前一个特征值置为零

/*           记录适当的Givens旋转 */

    ++(*givptr);                // 增加Givens旋转计数器
    givcol[(*givptr << 1) + 1] = indxq[indx[jlam]];  // 记录Givens旋转相关信息
    givcol[(*givptr << 1) + 2] = indxq[indx[j]];
    givnum[(*givptr << 1) + 1] = c__;  // 记录Givens旋转相关信息
    givnum[(*givptr << 1) + 2] = s;    // 记录Givens旋转相关信息
    if (*icompq == 1) {
    srot_(qsiz, &q[indxq[indx[jlam]] * q_dim1 + 1], &c__1, &q[
        indxq[indx[j]] * q_dim1 + 1], &c__1, &c__, &s);  // 对Q进行Givens旋转
    }
    t = d__[jlam] * c__ * c__ + d__[j] * s * s;  // 更新特征值数组
    d__[j] = d__[jlam] * s * s + d__[j] * c__ * c__;  // 更新特征值数组
    d__[jlam] = t;              // 更新特征值数组
    --k2;                       // k2向左移动一个位置
    i__ = 1;                     // 初始化i为1
L90:
    if (k2 + i__ <= *n) {
    if (d__[jlam] < d__[indxp[k2 + i__]]) {
        indxp[k2 + i__ - 1] = indxp[k2 + i__];  // 更新排除列表
        indxp[k2 + i__] = jlam;                 // 更新排除列表
        ++i__;                                  // i自增
        goto L90;
    } else {
        indxp[k2 + i__ - 1] = jlam;             // 更新排除列表
    }
    } else {
    indxp[k2 + i__ - 1] = jlam;                 // 更新排除列表
    }
    jlam = j;                   // 更新jlam为当前特征值
} else {
    ++(*k);                     // 特征值计数器加1
    w[*k] = z__[jlam];          // 记录特征值
    dlamda[*k] = d__[jlam];     // 记录特征值
    indxp[*k] = jlam;           // 记录特征值索引
    jlam = j;                   // 更新jlam为当前特征值
}
}
goto L80;
L100:

/*     记录最后一个特征值。 */

++(*k);                         // 特征值计数器加1
w[*k] = z__[jlam];              // 记录最后一个特征值
dlamda[*k] = d__[jlam];         // 记录最后一个特征值
indxp[*k] = jlam;               // 记录最后一个特征值索引

L110:

/*
   对DLAMDA和Q2中的特征值和相应的特征向量进行排序。
   没有被排除的特征值/向量将放入DLAMDA和Q2的前K个位置，
   被排除的将放入后面的N-K个位置。
*/

if (*icompq == 0) {
i__1 = *n;
    # 循环遍历从 1 到 i__1 的整数 j
    for (j = 1; j <= i__1; ++j) {
        # 获取 indxp 数组中索引为 j 的元素，赋值给 jp
        jp = indxp[j];
        # 将 d__ 数组中索引为 jp 的元素赋值给 dlamda 数组中索引为 j 的位置
        dlamda[j] = d__[jp];
        # 将 indxq 数组中索引为 indx[jp] 的元素赋值给 perm 数组中索引为 j 的位置
        perm[j] = indxq[indx[jp]];
/* L120: */
    }
    } else {
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        jp = indxp[j];
        dlamda[j] = d__[jp];
        perm[j] = indxq[indx[jp]];
        scopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1]
            , &c__1);
/* L130: */
    }
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

    if (*k < *n) {
    if (*icompq == 0) {
        i__1 = *n - *k;
        scopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
    } else {
        i__1 = *n - *k;
        scopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
        i__1 = *n - *k;
        slacpy_("A", qsiz, &i__1, &q2[(*k + 1) * q2_dim1 + 1], ldq2, &q[(*
            k + 1) * q_dim1 + 1], ldq);
    }
    }

    return 0;

/*     End of SLAED8 */

} /* slaed8_ */

/* Subroutine */ int slaed9_(integer *k, integer *kstart, integer *kstop,
    integer *n, real *d__, real *q, integer *ldq, real *rho, real *dlamda,
     real *w, real *s, integer *lds, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, s_dim1, s_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j;
    static real temp;
    extern doublereal snrm2_(integer *, real *, integer *);
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slaed4_(integer *, integer *, real *, real *, real *,
        real *, real *, integer *);
    extern doublereal slamc3_(real *, real *);
    extern /* Subroutine */ int xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAED9 finds the roots of the secular equation, as defined by the
    values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
    appropriate calls to SLAED4 and then stores the new matrix of
    eigenvectors for use in calculating the next level of Z vectors.

    Arguments
    =========

    K       (input) INTEGER
            The number of terms in the rational function to be solved by
            SLAED4.  K >= 0.

    KSTART  (input) INTEGER
    KSTOP   (input) INTEGER
            The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
            are to be computed.  1 <= KSTART <= KSTOP <= K.

    N       (input) INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (delation may result in N > K).

    D       (output) REAL array, dimension (N)
            D(I) contains the updated eigenvalues
            for KSTART <= I <= KSTOP.

    Q       (workspace) REAL array, dimension (LDQ,N)

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).


注释：
    # RHO是一个实数参数，用于更新方程中的一个参数，必须满足 RHO >= 0。
    RHO     (input) REAL
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.

    # DLAMDA是一个实数数组，长度为K，其中包含被缩减更新问题的旧根，即齐次方程的极点。
    DLAMDA  (input) REAL array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.

    # W是一个实数数组，长度为K，其中包含进行了缩减调整的更新向量的分量。
    W       (input) REAL array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector.

    # S是一个实数数组，维度为(LDS, K)，将包含修复矩阵的特征向量，
    # 这些特征向量将存储以供后续计算Z向量，并与先前累积的特征向量相乘以更新系统。
    S       (output) REAL array, dimension (LDS, K)
            Will contain the eigenvectors of the repaired matrix which
            will be stored for subsequent Z vector calculation and
            multiplied by the previously accumulated eigenvectors
            to update the system.

    # LDS是一个整数，是S数组的主维度。要求LDS >= max( 1, K )。
    LDS     (input) INTEGER
            The leading dimension of S.  LDS >= max( 1, K ).

    # INFO是一个整数，用于输出函数调用的状态信息。
    # = 0: 成功退出。
    # < 0: 如果INFO = -i，则第i个参数具有非法值。
    # > 0: 如果INFO = 1，则某个特征值未收敛。
    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge

    # 进一步细节
    # ===============
    # 基于以下贡献
    # Jeff Rutter, 加利福尼亚大学伯克利分校计算机科学系，美国

    # 测试输入参数的有效性。
    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;                              // 参数调整，指针 d__ 指向一个数组
    q_dim1 = *ldq;                      // q_dim1 表示 Q 的第一维大小，从参数 ldq 中获取
    q_offset = 1 + q_dim1;              // 计算 Q 的偏移量
    q -= q_offset;                      // 调整 Q 的指针，使其指向正确的起始位置
    --dlamda;                           // 调整指针，使其指向 dlamda 数组的正确起始位置
    --w;                                // 调整指针，使其指向 w 数组的正确起始位置
    s_dim1 = *lds;                      // s_dim1 表示 S 的第一维大小，从参数 lds 中获取
    s_offset = 1 + s_dim1;              // 计算 S 的偏移量
    s -= s_offset;                      // 调整 S 的指针，使其指向正确的起始位置

    /* Function Body */
    *info = 0;                          // 初始化 info 为 0，表示没有错误

    if (*k < 0) {                       // 如果 k 小于 0
        *info = -1;                     // 设置 info 为 -1，表示错误码
    } else if (*kstart < 1 || *kstart > max(1,*k)) {    // 如果 kstart 不在有效范围内
        *info = -2;                     // 设置 info 为 -2，表示错误码
    } else if (max(1,*kstop) < *kstart || *kstop > max(1,*k)) {   // 如果 kstop 不在有效范围内
        *info = -3;                     // 设置 info 为 -3，表示错误码
    } else if (*n < *k) {               // 如果 n 小于 k
        *info = -4;                     // 设置 info 为 -4，表示错误码
    } else if (*ldq < max(1,*k)) {      // 如果 ldq 小于 max(1,k)
        *info = -7;                     // 设置 info 为 -7，表示错误码
    } else if (*lds < max(1,*k)) {      // 如果 lds 小于 max(1,k)
        *info = -12;                    // 设置 info 为 -12，表示错误码
    }
    if (*info != 0) {                   // 如果 info 不为 0，表示有错误发生
        i__1 = -(*info);                // 取错误码的负值
        xerbla_("SLAED9", &i__1);        // 调用错误处理函数 xerbla_
        return 0;                       // 返回 0
    }

/*     Quick return if possible */

    if (*k == 0) {                      // 如果 k 等于 0，直接返回
        return 0;                       // 返回 0
    }

/*
       Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
       which on any of these machines zeros out the bottommost
       bit of DLAMDA(I) if it is 1; this makes the subsequent
       subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DLAMDA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DLAMDA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DLAMBDA(I) to prevent optimizing compilers from eliminating
       this code.
*/

    i__1 = *n;                          // 循环中的上界
    for (i__ = 1; i__ <= i__1; ++i__) { // 循环处理每个 dlamda(i)
        dlamda[i__] = slamc3_(&dlamda[i__], &dlamda[i__]) - dlamda[i__];
                                        // 调用 slamc3_ 函数，对 dlamda(i) 进行修改

/* L10: */
    }

    i__1 = *kstop;                      // 循环中的上界
    for (j = *kstart; j <= i__1; ++j) { // 循环处理每个 j
        slaed4_(k, &j, &dlamda[1], &w[1], &q[j * q_dim1 + 1], rho, &d__[j],
            info);                      // 调用 slaed4_ 函数进行计算

/*        If the zero finder fails, the computation is terminated. */

        if (*info != 0) {               // 如果 info 不为 0，表示计算失败
            goto L120;                  // 跳转到标签 L120
        }
/* L20: */
    }

    if (*k == 1 || *k == 2) {           // 如果 k 等于 1 或者 2
        i__1 = *k;                      // 循环中的上界
        for (i__ = 1; i__ <= i__1; ++i__) { // 外层循环处理每个 i
            i__2 = *k;                  // 内层循环中的上界
            for (j = 1; j <= i__2; ++j) {   // 内层循环处理每个 j
                s[j + i__ * s_dim1] = q[j + i__ * q_dim1];
                                        // 将 Q 的一部分赋值给 S
/* L30: */
            }
/* L40: */
        }
        goto L120;                      // 跳转到标签 L120
    }

/*     Compute updated W. */

    scopy_(k, &w[1], &c__1, &s[s_offset], &c__1);
                                        // 复制 w 到 s

/*     Initialize W(I) = Q(I,I) */

    i__1 = *ldq + 1;                    // 增加步长
    scopy_(k, &q[q_offset], &i__1, &w[1], &c__1);
                                        // 复制 Q 的一部分到 W

    i__1 = *k;                          // 循环中的上界
    for (j = 1; j <= i__1; ++j) {       // 外层循环处理每个 j
        i__2 = j - 1;                   // 内层循环中的上界
        for (i__ = 1; i__ <= i__2; ++i__) {   // 内层循环处理每个 i
            w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
                                        // 计算更新 w(i)
/* L50: */
        }
        i__2 = *k;                      // 内层循环中的上界
        for (i__ = j + 1; i__ <= i__2; ++i__) { // 内层循环处理每个 i
            w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
                                        // 计算更新 w(i)
/* L60: */
        }
/* L70: */
    }
    i__1 = *k;                          // 循环中的上界


注释完成后的代码块涵盖了每一行代码的作用和处理过程，符合注释要求并保持了原始代码的结构和缩进。
    # 对数组中的每个元素进行循环，从 i__ = 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 计算 w[i__] 的平方根，注意这里的 w[i__] 是一个复数，sqrt 函数要求其为负数
        r__1 = sqrt(-w[i__]);
        # 使用 s[i__ + s_dim1] 的符号来确定 sqrt(-w[i__]) 的符号，并将结果赋给 w[i__]
        w[i__] = r_sign(&r__1, &s[i__ + s_dim1]);
/* L80: */
    }

/*     Compute eigenvectors of the modified rank-1 modification. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        q[i__ + j * q_dim1] = w[i__] / q[i__ + j * q_dim1];
/* L90: */
    }
    temp = snrm2_(k, &q[j * q_dim1 + 1], &c__1);
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        s[i__ + j * s_dim1] = q[i__ + j * q_dim1] / temp;
/* L100: */
    }
/* L110: */
    }

L120:
    return 0;

/*     End of SLAED9 */

} /* slaed9_ */

/* Subroutine */ int slaeda_(integer *n, integer *tlvls, integer *curlvl,
    integer *curpbm, integer *prmptr, integer *perm, integer *givptr,
    integer *givcol, real *givnum, real *q, integer *qptr, real *z__,
    real *ztemp, integer *info)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k, mid, ptr, curr;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);
    static integer bsiz1, bsiz2, psiz1, psiz2, zptr1;
    extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *,
        real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *),
        xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SLAEDA computes the Z vector corresponding to the merge step in the
    CURLVLth step of the merge process with TLVLS steps for the CURPBMth
    problem.

    Arguments
    =========

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    TLVLS  (input) INTEGER
           The total number of merging levels in the overall divide and
           conquer tree.

    CURLVL (input) INTEGER
           The current level in the overall merge routine,
           0 <= curlvl <= tlvls.

    CURPBM (input) INTEGER
           The current problem in the current level in the overall
           merge routine (counting from upper left to lower right).

    PRMPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in PERM a
           level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
           indicates the size of the permutation and incidentally the
           size of the full, non-deflated problem.

    PERM   (input) INTEGER array, dimension (N lg N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.

    GIVPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in GIVCOL a
           level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
           indicates the number of Givens rotations.

*/
    # 定义输入参数 GIVCOL，表示进行 Givens 变换的列对
    GIVCOL (input) INTEGER array, dimension (2, N lg N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

    # 定义输入参数 GIVNUM，表示每个 Givens 变换中使用的 S 值
    GIVNUM (input) REAL array, dimension (2, N lg N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.

    # 定义输入参数 Q，包含先前级别的方形特征块，QPTR 指示块的起始位置
    Q      (input) REAL array, dimension (N**2)
           Contains the square eigenblocks from previous levels, the
           starting positions for blocks are given by QPTR.

    # 定义输入参数 QPTR，包含指示 Q 中特征块存储位置的指针列表
    QPTR   (input) INTEGER array, dimension (N+2)
           Contains a list of pointers which indicate where in Q an
           eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
           the size of the block.

    # 定义输出参数 Z，用于存储更新向量的最后一行和第一个子特征向量矩阵的第一行
    Z      (output) REAL array, dimension (N)
           On output this vector contains the updating vector (the last
           row of the first sub-eigenvector matrix and the first row of
           the second sub-eigenvector matrix).

    # 定义工作空间 ZTEMP，用于存储临时计算结果
    ZTEMP  (workspace) REAL array, dimension (N)

    # 定义输出参数 INFO，表示函数执行状态
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步的细节说明和贡献者信息
    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --ztemp;
    --z__;
    --qptr;
    --q;
    givnum -= 3;
    givcol -= 3;
    --givptr;
    --perm;
    --prmptr;

    /* Function Body */
    *info = 0;

    if (*n < 0) {
        *info = -1;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLAEDA", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /* Determine location of first number in second half. */
    mid = *n / 2 + 1;

    /* Gather last/first rows of appropriate eigenblocks into center of Z */
    ptr = 1;

    /*
       Determine location of lowest level subproblem in the full storage
       scheme
    */
    i__1 = *curlvl - 1;
    curr = ptr + *curpbm * pow_ii(&c__2, curlvl) + pow_ii(&c__2, &i__1) - 1;

    /*
       Determine size of these matrices.  We add HALF to the value of
       the SQRT in case the machine underestimates one of these square
       roots.
    */
    bsiz1 = (integer) (sqrt((real) (qptr[curr + 1] - qptr[curr])) + .5f);
    bsiz2 = (integer) (sqrt((real) (qptr[curr + 2] - qptr[curr + 1])) + .5f);
    i__1 = mid - bsiz1 - 1;
    for (k = 1; k <= i__1; ++k) {
        z__[k] = 0.f;
        /* L10: */
    }
    scopy_(&bsiz1, &q[qptr[curr] + bsiz1 - 1], &bsiz1, &z__[mid - bsiz1], &
        c__1);
    scopy_(&bsiz2, &q[qptr[curr + 1]], &bsiz2, &z__[mid], &c__1);
    i__1 = *n;
    for (k = mid + bsiz2; k <= i__1; ++k) {
        z__[k] = 0.f;
        /* L20: */
    }

    /*
       Loop through remaining levels 1 -> CURLVL applying the Givens
       rotations and permutation and then multiplying the center matrices
       against the current Z.
    */
    ptr = pow_ii(&c__2, tlvls) + 1;
    i__1 = *curlvl - 1;
    for (k = 1; k <= i__1; ++k) {
        i__2 = *curlvl - k;
        i__3 = *curlvl - k - 1;
        curr = ptr + *curpbm * pow_ii(&c__2, &i__2) + pow_ii(&c__2, &i__3) -
            1;
        psiz1 = prmptr[curr + 1] - prmptr[curr];
        psiz2 = prmptr[curr + 2] - prmptr[curr + 1];
        zptr1 = mid - psiz1;

        /* Apply Givens at CURR and CURR+1 */
        i__2 = givptr[curr + 1] - 1;
        for (i__ = givptr[curr]; i__ <= i__2; ++i__) {
            srot_(&c__1, &z__[zptr1 + givcol[(i__ << 1) + 1] - 1], &c__1, &
                z__[zptr1 + givcol[(i__ << 1) + 2] - 1], &c__1, &givnum[(
                i__ << 1) + 1], &givnum[(i__ << 1) + 2]);
            /* L30: */
        }
        i__2 = givptr[curr + 2] - 1;
        for (i__ = givptr[curr + 1]; i__ <= i__2; ++i__) {
            srot_(&c__1, &z__[mid - 1 + givcol[(i__ << 1) + 1]], &c__1, &z__[
                mid - 1 + givcol[(i__ << 1) + 2]], &c__1, &givnum[(i__ <<
                1) + 1], &givnum[(i__ << 1) + 2]);
            /* L40: */
        }
        psiz1 = prmptr[curr + 1] - prmptr[curr];
        psiz2 = prmptr[curr + 2] - prmptr[curr + 1];
        i__2 = psiz1 - 1;
        for (i__ = 0; i__ <= i__2; ++i__) {
            ztemp[i__ + 1] = z__[zptr1 + perm[prmptr[curr] + i__] - 1];
            /* L50: */
        }
        i__2 = psiz2 - 1;
        /* Remaining loop iteration and termination */
    # 循环开始，遍历索引范围从 0 到 i__2
    for (i__ = 0; i__ <= i__2; ++i__) {
        # 将 z__ 中的元素按照 perm 中的指定索引顺序，存入 ztemp 中的指定位置
        ztemp[psiz1 + i__ + 1] = z__[mid + perm[prmptr[curr + 1] + i__] - 1];
/* L60: */
    }

/*
          Multiply Blocks at CURR and CURR+1

          Determine size of these matrices.  We add HALF to the value of
          the SQRT in case the machine underestimates one of these
          square roots.
*/

    bsiz1 = (integer) (sqrt((real) (qptr[curr + 1] - qptr[curr])) + .5f);
    bsiz2 = (integer) (sqrt((real) (qptr[curr + 2] - qptr[curr + 1])) +
        .5f);
    if (bsiz1 > 0) {
        sgemv_("T", &bsiz1, &bsiz1, &c_b15, &q[qptr[curr]], &bsiz1, &
            ztemp[1], &c__1, &c_b29, &z__[zptr1], &c__1);
    }
    i__2 = psiz1 - bsiz1;
    scopy_(&i__2, &ztemp[bsiz1 + 1], &c__1, &z__[zptr1 + bsiz1], &c__1);
    if (bsiz2 > 0) {
        sgemv_("T", &bsiz2, &bsiz2, &c_b15, &q[qptr[curr + 1]], &bsiz2, &
            ztemp[psiz1 + 1], &c__1, &c_b29, &z__[mid], &c__1);
    }
    i__2 = psiz2 - bsiz2;
    scopy_(&i__2, &ztemp[psiz1 + bsiz2 + 1], &c__1, &z__[mid + bsiz2], &
        c__1);

    i__2 = *tlvls - k;
    ptr += pow_ii(&c__2, &i__2);
/* L70: */
    }

    return 0;

/*     End of SLAEDA */

} /* slaeda_ */

/* Subroutine */ int slaev2_(real *a, real *b, real *c__, real *rt1, real *
    rt2, real *cs1, real *sn1)
{
    /* System generated locals */
    real r__1;

    /* Local variables */
    static real ab, df, cs, ct, tb, sm, tn, rt, adf, acs;
    static integer sgn1, sgn2;
    static real acmn, acmx;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
       [  A   B  ]
       [  B   C  ].
    On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
    eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
    eigenvector for RT1, giving the decomposition

       [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
       [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].

    Arguments
    =========

    A       (input) REAL
            The (1,1) element of the 2-by-2 matrix.

    B       (input) REAL
            The (1,2) element and the conjugate of the (2,1) element of
            the 2-by-2 matrix.

    C       (input) REAL
            The (2,2) element of the 2-by-2 matrix.

    RT1     (output) REAL
            The eigenvalue of larger absolute value.

    RT2     (output) REAL
            The eigenvalue of smaller absolute value.

    CS1     (output) REAL
    SN1     (output) REAL
            The vector (CS1, SN1) is a unit right eigenvector for RT1.

    Further Details
    ===============

    RT1 is accurate to a few ulps barring over/underflow.

    RT2 may be inaccurate if there is massive cancellation in the
    determinant A*C-B*B; higher precision or correctly rounded or
    correctly truncated arithmetic would be needed to compute RT2
    accurately in all cases.


*/


注释：
这段代码是 Fortran 语言的一个子程序，用于计算一个对称 2x2 矩阵的特征值分解。它计算并返回两个特征值 RT1 和 RT2，以及对应的单位右特征向量 (CS1, SN1)。
    CS1 and SN1 are accurate to a few ulps barring over/underflow.
    CS1 和 SN1 在除溢出/下溢外，精度在几个 ULP（最小单位舍入误差）之内。

    Overflow is possible only if RT1 is within a factor of 5 of overflow.
    溢出仅在 RT1 接近溢出值的五倍时可能发生。

    Underflow is harmless if the input data is 0 or exceeds
       underflow_threshold / macheps.
    如果输入数据为 0 或超过下溢阈值 / macheps，则下溢是无害的。

   =====================================================================

       Compute the eigenvalues
       计算特征值
/*

    sm = *a + *c__;
    df = *a - *c__;
    adf = dabs(df);
    tb = *b + *b;
    ab = dabs(tb);
    if (dabs(*a) > dabs(*c__)) {
        acmx = *a;
        acmn = *c__;
    } else {
        acmx = *c__;
        acmn = *a;
    }
    if (adf > ab) {
        /* 计算第二次幂 */
        r__1 = ab / adf;
        rt = adf * sqrt(r__1 * r__1 + 1.f);
    } else if (adf < ab) {
        /* 计算第二次幂 */
        r__1 = adf / ab;
        rt = ab * sqrt(r__1 * r__1 + 1.f);
    } else {
        /* 包含 AB=ADF=0 的情况 */
        rt = ab * sqrt(2.f);
    }
    if (sm < 0.f) {
        *rt1 = (sm - rt) * .5f;
        sgn1 = -1;

        /*
              执行顺序重要。
              为了得到完全准确的较小特征值，
              下一行需要在更高精度下执行。
        */

        *rt2 = acmx / *rt1 * acmn - *b / *rt1 * *b;
    } else if (sm > 0.f) {
        *rt1 = (sm + rt) * .5f;
        sgn1 = 1;

        /*
              执行顺序重要。
              为了得到完全准确的较小特征值，
              下一行需要在更高精度下执行。
        */

        *rt2 = acmx / *rt1 * acmn - *b / *rt1 * *b;
    } else {
        /* 包含 RT1 = RT2 = 0 的情况 */
        *rt1 = rt * .5f;
        *rt2 = rt * -.5f;
        sgn1 = 1;
    }

    /* 计算特征向量 */

    if (df >= 0.f) {
        cs = df + rt;
        sgn2 = 1;
    } else {
        cs = df - rt;
        sgn2 = -1;
    }
    acs = dabs(cs);
    if (acs > ab) {
        ct = -tb / cs;
        *sn1 = 1.f / sqrt(ct * ct + 1.f);
        *cs1 = ct * *sn1;
    } else {
        if (ab == 0.f) {
            *cs1 = 1.f;
            *sn1 = 0.f;
        } else {
            tn = -cs / tb;
            *cs1 = 1.f / sqrt(tn * tn + 1.f);
            *sn1 = tn * *cs1;
        }
    }
    if (sgn1 == sgn2) {
        tn = *cs1;
        *cs1 = -(*sn1);
        *sn1 = tn;
    }
    return 0;

    /* SLAEV2 结束 */

} /* slaev2_ */

/* 子程序 */ int slaexc_(logical *wantq, integer *n, real *t, integer *
    ldt, real *q, integer *ldq, integer *j1, integer *n1, integer *n2,
    real *work, integer *info)
{
    /* 系统生成的本地变量 */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1;
    real r__1, r__2, r__3;

    /* 本地变量 */
    static real d__[16]    /* was [4][4] */;
    static integer k;
    static real u[3], x[4]    /* was [2][2] */;
    static integer j2, j3, j4;
    static real u1[3], u2[3];
    static integer nd;
    static real cs, t11, t22, t33, sn, wi1, wi2, wr1, wr2, eps, tau, tau1,
        tau2;
    static integer ierr;
    static real temp;
    extern /* 子程序 */ void srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);
    static real scale, dnorm, xnorm;
    extern /* 子程序 */ void slanv2_(real *, real *, real *, real *, real *
        , real *, real *, real *, real *, real *), slasy2_(logical *,
        logical *, integer *, integer *, integer *, real *, integer *,
        real *, integer *, real *, integer *, real *, real *, integer *,
        real *, integer *);
    # 声明外部函数 `slamch_` 和 `slange_`，这些函数在其他地方定义
    extern doublereal slamch_(char *), slange_(char *, integer *,
        integer *, real *, integer *, real *);

    # 声明外部子程序 `slarfg_` 和 `slacpy_`，以及函数 `slartg_`，这些在其他地方定义
    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *), slacpy_(char *, integer *, integer *, real *, integer *,
        real *, integer *), slartg_(real *, real *, real *, real *,
        real *);

    # 声明静态变量 `thresh`，用于存储某个阈值，这个变量在整个文件内可见但不可被其他文件访问
    static real thresh;

    # 声明外部子程序 `slarfx_`，这个子程序在其他地方定义
    extern /* Subroutine */ int slarfx_(char *, integer *, integer *, real *,
        real *, real *, integer *, real *);

    # 声明静态变量 `smlnum`，用于存储某个小数值，这个变量在整个文件内可见但不可被其他文件访问
    static real smlnum;
    // 调整参数的偏移量，使其从 1 开始索引
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --work;

    // 初始化 INFO 为 0，表示成功退出
    *info = 0;

    // 如果 N、N1 或 N2 为零，则直接返回
    if (*n == 0 || *n1 == 0 || *n2 == 0) {
        return 0;
    }
    // 如果第一个块 T11 超出了矩阵 T 的范围，则直接返回
    if (*j1 + *n1 > *n) {
        return 0;
    }

    // 计算第二个块的起始位置
    j2 = *j1 + 1;
    j3 = *j1 + 2;
    j4 = *j1 + 3;

    // 如果第一个块和第二个块都是 1x1 的情况
    if (*n1 == 1 && *n2 == 1) {

        // 读取 T11 和 T22 的值
        t11 = t[*j1 + *j1 * t_dim1];
        t22 = t[j2 + j2 * t_dim1];

        // 计算用于交换的变换参数
        r__1 = t22 - t11;
        slartg_(&t[*j1 + j2 * t_dim1], &r__1, &cs, &sn, &temp);

        // 将变换应用到矩阵 T 上
    # 如果 j3 小于等于 *n，则执行以下操作
    if (j3 <= *n) {
        # 计算数组索引的范围 i__1 为 *n - *j1 - 1
        i__1 = *n - *j1 - 1;
        # 调用 srot_ 函数，对数组进行旋转变换
        srot_(&i__1, &t[*j1 + j3 * t_dim1], ldt, &t[j2 + j3 * t_dim1],
            ldt, &cs, &sn);
    }
    # 计算数组索引的范围 i__1 为 *j1 - 1
    i__1 = *j1 - 1;
    # 调用 srot_ 函数，对数组进行旋转变换
    srot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &c__1,
        &cs, &sn);

    # 将 t22 赋值给 t[*j1 + *j1 * t_dim1]
    t[*j1 + *j1 * t_dim1] = t22;
    # 将 t11 赋值给 t[j2 + j2 * t_dim1]
    t[j2 + j2 * t_dim1] = t11;

    # 如果 *wantq 的值为真，则执行以下操作
    if (*wantq) {
/*           Accumulate transformation in the matrix Q. */
/*
          累积变换到矩阵 Q 中。
*/

        srot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &c__1,
            &cs, &sn);
/*
          对矩阵 Q 中的变换进行累积。
          使用 SROT 函数对 Q 的特定列进行正交旋转，以应用变换。
          n 是矩阵的大小。
          cs 和 sn 是旋转的参数。
          q_dim1 是 Q 的第一维度大小。
          j1 和 j2 是索引，用于定位 Q 中的特定列。
*/

    }

    } else {

/*
          Swapping involves at least one 2-by-2 block.

          Copy the diagonal block of order N1+N2 to the local array D
          and compute its norm.
*/

    nd = *n1 + *n2;
/*
          nd 是对角块的大小，即 N1 + N2。
*/

    slacpy_("Full", &nd, &nd, &t[*j1 + *j1 * t_dim1], ldt, d__, &c__4);
/*
          使用 SLACPY 函数将矩阵 T 的特定对角块复制到本地数组 D 中。
          "Full" 指定复制整个块。
          nd 是块的大小。
          t 是输入矩阵 T。
          ldt 是矩阵 T 的第一维度大小。
          d__ 是输出的本地数组。
          c__4 是 d__ 的第一维度大小。
*/

    dnorm = slange_("Max", &nd, &nd, d__, &c__4, &work[1]);
/*
          使用 SLANGE 函数计算本地数组 D 的最大范数 dnorm。
          "Max" 指定计算最大范数。
          nd 是数组 D 的大小。
          d__ 是输入的本地数组。
          c__4 是 d__ 的第一维度大小。
          work 是工作数组。
*/

/*
          Compute machine-dependent threshold for test for accepting
          swap.
*/

    eps = slamch_("P");
/*
          获取机器相关的精度参数 eps。
          SLAMCH 函数用于获取机器参数。
          "P" 指定获取精度。
*/

    smlnum = slamch_("S") / eps;
/*
          计算一个小的数 smlnum 作为阈值。
          "S" 指定获取安全范围的缩放因子。
*/

/* Computing MAX */
    r__1 = eps * 10.f * dnorm;
    thresh = dmax(r__1,smlnum);
/*
          计算接受交换的阈值 thresh。
          使用 EPS、dnorm 和 smlnum 计算阈值。
          dmax 是一个宏或内联函数，用于计算最大值。
*/

/*        Solve T11*X - X*T22 = scale*T12 for X. */

    slasy2_(&c_false, &c_false, &c_n1, n1, n2, d__, &c__4, &d__[*n1 + 1 +
        (*n1 + 1 << 2) - 5], &c__4, &d__[(*n1 + 1 << 2) - 4], &c__4, &
        scale, x, &c__2, &xnorm, &ierr);
/*
          使用 SLASY2 函数解线性方程组 T11*X - X*T22 = scale*T12，其中 X 是未知数。
          c_false 和 c_n1 是逻辑常量。
          n1 和 n2 是方程的尺寸参数。
          d__ 是对角块的本地数组。
          scale 是比例因子。
          x 是解向量。
          xnorm 是解的范数。
          ierr 是输出的错误码。
*/

/*        Swap the adjacent diagonal blocks. */

    k = *n1 + *n1 + *n2 - 3;
/*
          计算索引 k，表示对角块的大小。
*/

    switch (k) {
        case 1:  goto L10;
        case 2:  goto L20;
        case 3:  goto L30;
    }
/*
          根据 k 的值跳转到不同的标签进行处理。
*/

L10:

/*
          N1 = 1, N2 = 2: generate elementary reflector H so that:

          ( scale, X11, X12 ) H = ( 0, 0, * )
*/

    u[0] = scale;
    u[1] = x[0];
    u[2] = x[2];
/*
          生成元反射器 H，使得 ( scale, X11, X12 ) H = ( 0, 0, * )。
*/

    slarfg_(&c__3, &u[2], u, &c__1, &tau);
/*
          使用 SLARFG 函数计算元反射器 H。
          c__3 是向量 u 的大小。
          u 是输入和输出的向量。
          tau 是输出的反射系数。
*/

    u[2] = 1.f;
/*
          调整反射器 H 的最后一个元素。
*/

    t11 = t[*j1 + *j1 * t_dim1];
/*
          获取矩阵 T 中对角块的元素 T11。
*/

/*        Perform swap provisionally on diagonal block in D. */

    slarfx_("L", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
/*
          在本地数组 D 的对角块上进行临时交换。
          使用 SLARFX 函数对 D 的左侧进行变换。
*/

    slarfx_("R", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
/*
          使用 SLARFX 函数对 D 的右侧进行变换。
*/

/*
          Test whether to reject swap.

   Computing MAX
*/
    r__2 = dabs(d__[2]), r__3 = dabs(d__[6]), r__2 = max(r__2,r__3), r__3
        = (r__1 = d__[10] - t11, dabs(r__1));
/*
          计算拒绝交换的条件。
*/

    if (dmax(r__2,r__3) > thresh) {
        goto L50;
    }
/*
          如果条件满足阈值，则拒绝交换。
*/

/*        Accept swap: apply transformation to the entire matrix T. */

    i__1 = *n - *j1 + 1;
    slarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + *j1 * t_dim1], ldt, &
        work[1]);
/*
          接受交换：将变换应用到整个矩阵 T 上。
          使用 SLARFX 函数对 T 的左侧进行变换。
*/

    slarfx_("R", &j2, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);
/*
          使用 SLARFX 函数对 T 的右侧进行变换。
*/

    t[j3 + *j1 * t_dim1] = 0.f;
    t[j3 + j2 * t_dim1] = 0.f;
    t[j3 + j3 * t_dim1] = t11;
/*
          更新矩阵 T 中对角块的元素。
*/

    if (*wantq) {

/*           Accumulate transformation in the matrix Q. */

        slarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[
            1]);
/*
              在矩阵 Q 中累积变换。
              使用 SLARFX 函数对 Q 的右侧进行变换。
*/
    }
    goto L40;
/*
          跳转到标签 L40 继续处理。
*/

L20:

/*
          N1 = 2, N2 = 1: generate elementary reflector H so that:

          H (  -X11 ) = ( * )
            (  -X21 ) = ( 0 )
            ( scale ) = ( 0 )
*/

    u[0] = -x[0];
    u[1] = -x[1];
    u[2] = scale;
/*
          生成元反射器 H，使得 H (  -X11 ) = ( * )，(
    r__2 = dabs(d__[1]), r__3 = dabs(d__[2]), r__2 = max(r__2,r__3), r__3
        = (r__1 = d__[0] - t33, dabs(r__1));


    # 计算绝对值并比较大小，选择较大的值作为 r__2
    r__2 = dabs(d__[1]),  # 计算 d__[1] 的绝对值，赋给 r__2
    r__3 = dabs(d__[2]),  # 计算 d__[2] 的绝对值，赋给 r__3
    r__2 = max(r__2, r__3),  # 取 r__2 和 r__3 中较大的值，赋给 r__2
    r__3 = (r__1 = d__[0] - t33, dabs(r__1));  # 计算 d__[0] - t33 的绝对值，赋给 r__1，然后再赋给 r__3


```    
    if (dmax(r__2,r__3) > thresh) {
        goto L50;
    }


    # 检查 r__2 和 r__3 的最大值是否大于 thresh
    if (dmax(r__2, r__3) > thresh) {
        # 如果满足条件，跳转到标签 L50 处继续执行
        goto L50;
    }
/*
    Accept swap: apply transformation to the entire matrix T.
*/
slarfx_("R", &j3, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);
i__1 = *n - *j1;
slarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + j2 * t_dim1], ldt, &work[1]);

/*
    Set elements in T corresponding to the swap.
*/
t[*j1 + *j1 * t_dim1] = t33;
t[j2 + *j1 * t_dim1] = 0.f;
t[j3 + *j1 * t_dim1] = 0.f;

if (*wantq) {
    /*
        Accumulate transformation in the matrix Q.
    */
    slarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[1]);
}

L40:

/*
    N1 = 2, N2 = 2: generate elementary reflectors H(1) and H(2) so
    that:

    H(2) H(1) (  -X11  -X12 ) = (  *  * )
              (  -X21  -X22 )   (  0  * )
              ( scale    0  )   (  0  0 )
              (    0  scale )   (  0  0 )
*/
u1[0] = -x[0];
u1[1] = -x[1];
u1[2] = scale;
slarfg_(&c__3, u1, &u1[1], &c__1, &tau1);
u1[0] = 1.f;

temp = -tau1 * (x[2] + u1[1] * x[3]);
u2[0] = -temp * u1[1] - x[3];
u2[1] = -temp * u1[2];
u2[2] = scale;
slarfg_(&c__3, u2, &u2[1], &c__1, &tau2);
u2[0] = 1.f;

/*
    Perform swap provisionally on diagonal block in D.
*/
slarfx_("L", &c__3, &c__4, u1, &tau1, d__, &c__4, &work[1]);
slarfx_("R", &c__4, &c__3, u1, &tau1, d__, &c__4, &work[1]);
slarfx_("L", &c__3, &c__4, u2, &tau2, &d__[1], &c__4, &work[1]);
slarfx_("R", &c__4, &c__3, u2, &tau2, &d__[4], &c__4, &work[1]);

/*
    Test whether to reject swap.
*/
r__1 = dabs(d__[2]), r__2 = dabs(d__[6]), r__1 = max(r__1,r__2), r__2 = dabs(d__[3]), r__1 = max(r__1,r__2), r__2 = dabs(d__[7]);
if (dmax(r__1,r__2) > thresh) {
    goto L50;
}

/*
    Accept swap: apply transformation to the entire matrix T.
*/
i__1 = *n - *j1 + 1;
slarfx_("L", &c__3, &i__1, u1, &tau1, &t[*j1 + *j1 * t_dim1], ldt, &work[1]);
slarfx_("R", &j4, &c__3, u1, &tau1, &t[*j1 * t_dim1 + 1], ldt, &work[1]);
i__1 = *n - *j1 + 1;
slarfx_("L", &c__3, &i__1, u2, &tau2, &t[j2 + *j1 * t_dim1], ldt, &work[1]);
slarfx_("R", &j4, &c__3, u2, &tau2, &t[j2 * t_dim1 + 1], ldt, &work[1]);

t[j3 + *j1 * t_dim1] = 0.f;
t[j3 + j2 * t_dim1] = 0.f;
t[j4 + *j1 * t_dim1] = 0.f;
t[j4 + j2 * t_dim1] = 0.f;

if (*wantq) {
    /*
        Accumulate transformation in the matrix Q.
    */
    slarfx_("R", n, &c__3, u1, &tau1, &q[*j1 * q_dim1 + 1], ldq, &work[1]);
    slarfx_("R", n, &c__3, u2, &tau2, &q[j2 * q_dim1 + 1], ldq, &work[1]);
}

L40:

if (*n2 == 2) {
/*           Standardize new 2-by-2 block T11 */

/* 调用 SLANV2 子程序进行特征值计算与相似变换 */
slanv2_(&t[*j1 + *j1 * t_dim1], &t[*j1 + j2 * t_dim1], &t[j2 + *
    j1 * t_dim1], &t[j2 + j2 * t_dim1], &wr1, &wi1, &wr2, &
    wi2, &cs, &sn);
/* 计算对角块下方元素的旋转 */
i__1 = *n - *j1 - 1;
srot_(&i__1, &t[*j1 + (*j1 + 2) * t_dim1], ldt, &t[j2 + (*j1 + 2)
    * t_dim1], ldt, &cs, &sn);
/* 计算对角块左侧元素的旋转 */
i__1 = *j1 - 1;
srot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &
    c__1, &cs, &sn);
/* 如果需要计算 Q 矩阵，则对 Q 矩阵进行相似变换 */
if (*wantq) {
    srot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &
        c__1, &cs, &sn);
}
}

if (*n1 == 2) {

/*           Standardize new 2-by-2 block T22 */

/* 计算新的 2x2 块的相似变换 */
j3 = *j1 + *n2;
j4 = j3 + 1;
slanv2_(&t[j3 + j3 * t_dim1], &t[j3 + j4 * t_dim1], &t[j4 + j3 *
    t_dim1], &t[j4 + j4 * t_dim1], &wr1, &wi1, &wr2, &wi2, &
    cs, &sn);
/* 如果还有更多元素，则计算对角块下方元素的旋转 */
if (j3 + 2 <= *n) {
    i__1 = *n - j3 - 1;
    srot_(&i__1, &t[j3 + (j3 + 2) * t_dim1], ldt, &t[j4 + (j3 + 2)
         * t_dim1], ldt, &cs, &sn);
}
/* 计算对角块左侧元素的旋转 */
i__1 = j3 - 1;
srot_(&i__1, &t[j3 * t_dim1 + 1], &c__1, &t[j4 * t_dim1 + 1], &
    c__1, &cs, &sn);
/* 如果需要计算 Q 矩阵，则对 Q 矩阵进行相似变换 */
if (*wantq) {
    srot_(n, &q[j3 * q_dim1 + 1], &c__1, &q[j4 * q_dim1 + 1], &
        c__1, &cs, &sn);
}
}

}
return 0;

/*     如果交换被拒绝，则以 INFO = 1 结束。 */

L50:
*info = 1;
return 0;

/*     SLAEXC 子程序结束 */

} /* slaexc_ */

/* 子程序 SLAHQR */

/* 标准化 Hessenberg 矩阵 H 的特征值问题 */
int slahqr_(logical *wantt, logical *wantz, integer *n,
integer *ilo, integer *ihi, real *h__, integer *ldh, real *wr, real *
wi, integer *iloz, integer *ihiz, real *z__, integer *ldz, integer *
info)
{
/* 自动产生的本地变量 */
integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3;
real r__1, r__2, r__3, r__4;

/* 本地变量 */
static integer i__, j, k, l, m;
static real s, v[3];
static integer i1, i2;
static real t1, t2, t3, v2, v3, aa, ab, ba, bb, h11, h12, h21, h22, cs;
static integer nh;
static real sn;
static integer nr;
static real tr;
static integer nz;
static real det, h21s;
static integer its;
static real ulp, sum, tst, rt1i, rt2i, rt1r, rt2r;
extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
    integer *, real *, real *), scopy_(integer *, real *, integer *,
    real *, integer *), slanv2_(real *, real *, real *, real *, real *
    , real *, real *, real *, real *, real *), slabad_(real *, real *)
    ;
extern doublereal slamch_(char *);
static real safmin;
extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
    real *);
static real safmax, rtdisc, smlnum;
    *info = 0;


注释：


// 将指针info所指向的内存位置的值设置为0
*info = 0;


这行代码是一个简单的赋值语句，其中`*info`表示指针info所指向的内存位置，赋值操作将该位置的值设为0。
/*     Quick return if possible */
如果 n 的值为 0，直接返回 0
如果 ilo 和 ihi 相等，说明只有一个特征值，将其实部存入 wr[ilo]，虚部为 0，然后返回 0

/*     ==== clear out the trash ==== */
从 ilo 开始循环到 ihi-3
将 h 矩阵中对角线下第二和第三个位置的元素设为 0
如果 ilo <= ihi-2，将 h 矩阵中最右下角的第二个元素设为 0

计算 nh = ihi - ilo + 1 和 nz = ihiz - iloz + 1

/*     Set machine-dependent constants for the stopping criterion. */
设置机器相关的常数用于停止条件
safmin = slamch_("SAFE MINIMUM") 返回安全最小值
safmax = 1.f / safmin，计算安全最大值
slabad_(&safmin, &safmax) 设置 safmin 和 safmax
ulp = slamch_("PRECISION") 返回机器精度
smlnum = safmin * ((real) nh / ulp)，计算小常数 smlnum

/*
   I1 and I2 are the indices of the first row and last column of H
   to which transformations must be applied. If eigenvalues only are
   being computed, I1 and I2 are set inside the main loop.
*/
如果 wantt 为真，设置 i1 = 1 和 i2 = n

/*
   The main loop begins here. I is the loop index and decreases from
   IHI to ILO in steps of 1 or 2. Each iteration of the loop works
   with the active submatrix in rows and columns L to I.
   Eigenvalues I+1 to IHI have already converged. Either L = ILO or
   H(L,L-1) is negligible so that the matrix splits.
*/
从 i__ = ihi 开始循环到 ilo，每次减少 1 或 2
每次迭代处理活动子矩阵中从列 ilo 到 i 的行和列
已经收敛的特征值从 i+1 到 ihi
如果 l = ilo 或者 H(L,L-1) 很小导致矩阵分裂

进入 L20 标签位置：

l = ilo
如果 i__ < ilo，跳转到 L160

/*
   Perform QR iterations on rows and columns ILO to I until a
   submatrix of order 1 or 2 splits off at the bottom because a
   subdiagonal element has become negligible.
*/
执行 QR 迭代，直到底部出现一个 1 或 2 阶的子矩阵，因为次对角线元素变得很小

/*        Look for a single small subdiagonal element. */
查找一个小的次对角线元素

从 k = i__ 开始循环到 l+1
如果 h[k, k-1] 的绝对值 <= smlnum，跳转到 L40
计算 tst = |h[k-1, k-1]| + |h[k, k]|
如果 tst == 0.f，
如果 k-2 >= ilo，加上 |h[k-1, k-2]|
如果 k+1 <= ihi，加上 |h[k+1, k]|
如果 h[k, k-1] 的绝对值 <= ulp * tst，采用保守的小次对角线紧缩判据
计算 ab = max(|h[k, k-1]|, |h[k-1, k]|)
计算 ba = min(|h[k, k-1]|, |h[k-1, k]|)
/* Computing MAX */
r__3 = (r__1 = h__[k + k * h_dim1], dabs(r__1)), r__4 = (r__2
    = h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1],
     dabs(r__2));
aa = dmax(r__3,r__4);
/* Computing MIN */
r__3 = (r__1 = h__[k + k * h_dim1], dabs(r__1)), r__4 = (r__2
    = h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1],
     dabs(r__2));
bb = dmin(r__3,r__4);
s = aa + ab;
/* Computing MAX */
r__1 = smlnum, r__2 = ulp * (bb * (aa / s));
if (ba * (ab / s) <= dmax(r__1,r__2)) {
    goto L40;
}
}
/* L30: */
}

L40:
l = k;
if (l > *ilo) {

/* H(L,L-1) is negligible */

h__[l + (l - 1) * h_dim1] = 0.f;
}

/* Exit from loop if a submatrix of order 1 or 2 has split off. */

if (l >= i__ - 1) {
    goto L150;
}

/*
      Now the active submatrix is in rows and columns L to I. If
      eigenvalues only are being computed, only the active submatrix
      need be transformed.
*/

if (! (*wantt)) {
    i1 = l;
    i2 = i__;
}

if (its == 10) {

/* Exceptional shift. */

s = (r__1 = h__[l + 1 + l * h_dim1], dabs(r__1)) + (r__2 = h__[l
    + 2 + (l + 1) * h_dim1], dabs(r__2));
h11 = s * .75f + h__[l + l * h_dim1];
h12 = s * -.4375f;
h21 = s;
h22 = h11;
} else if (its == 20) {

/* Exceptional shift. */

s = (r__1 = h__[i__ + (i__ - 1) * h_dim1], dabs(r__1)) + (r__2 =
    h__[i__ - 1 + (i__ - 2) * h_dim1], dabs(r__2));
h11 = s * .75f + h__[i__ + i__ * h_dim1];
h12 = s * -.4375f;
h21 = s;
h22 = h11;
} else {

/*
     Prepare to use Francis' double shift
     (i.e. 2nd degree generalized Rayleigh quotient)
*/

h11 = h__[i__ - 1 + (i__ - 1) * h_dim1];
h21 = h__[i__ + (i__ - 1) * h_dim1];
h12 = h__[i__ - 1 + i__ * h_dim1];
h22 = h__[i__ + i__ * h_dim1];
}
s = dabs(h11) + dabs(h12) + dabs(h21) + dabs(h22);
if (s == 0.f) {
rt1r = 0.f;
rt1i = 0.f;
rt2r = 0.f;
rt2i = 0.f;
} else {
h11 /= s;
h21 /= s;
h12 /= s;
h22 /= s;
tr = (h11 + h22) / 2.f;
det = (h11 - tr) * (h22 - tr) - h12 * h21;
rtdisc = sqrt((dabs(det)));
if (det >= 0.f) {

/* ==== complex conjugate shifts ==== */

rt1r = tr * s;
rt2r = rt1r;
rt1i = rtdisc * s;
rt2i = -rt1i;
} else {

/* ==== real shifts (use only one of them) ==== */

rt1r = tr + rtdisc;
rt2r = tr - rtdisc;
if ((r__1 = rt1r - h22, dabs(r__1)) <= (r__2 = rt2r - h22,
    dabs(r__2))) {
    rt1r *= s;
    rt2r = rt1r;
} else {
    rt2r *= s;
    rt1r = rt2r;
}
rt1i = 0.f;
rt2i = 0.f;
}
}
/*        Look for two consecutive small subdiagonal elements. */
i__1 = l;
for (m = i__ - 2; m >= i__1; --m) {
/*
         Determine the effect of starting the double-shift QR
         iteration at row M, and see if this would make H(M,M-1)
         negligible.  (The following uses scaling to avoid
         overflows and most underflows.)
*/
h21s = h__[m + 1 + m * h_dim1];
s = (r__1 = h__[m + m * h_dim1] - rt2r, dabs(r__1)) + dabs(rt2i)
    + dabs(h21s);
h21s = h__[m + 1 + m * h_dim1] / s;
v[0] = h21s * h__[m + (m + 1) * h_dim1] + (h__[m + m * h_dim1] -
    rt1r) * ((h__[m + m * h_dim1] - rt2r) / s) - rt1i * (rt2i
    / s);
v[1] = h21s * (h__[m + m * h_dim1] + h__[m + 1 + (m + 1) * h_dim1]
     - rt1r - rt2r);
v[2] = h21s * h__[m + 2 + (m + 1) * h_dim1];
s = dabs(v[0]) + dabs(v[1]) + dabs(v[2]);
v[0] /= s;
v[1] /= s;
v[2] /= s;
if (m == l) {
goto L60;
}
if ((r__1 = h__[m + (m - 1) * h_dim1], dabs(r__1)) * (dabs(v[1])
    + dabs(v[2])) <= ulp * dabs(v[0]) * ((r__2 = h__[m - 1 + (
    m - 1) * h_dim1], dabs(r__2)) + (r__3 = h__[m + m *
    h_dim1], dabs(r__3)) + (r__4 = h__[m + 1 + (m + 1) *
    h_dim1], dabs(r__4)))) {
goto L60;
}
/* L50: */
}
L60:

/*        Double-shift QR step */
i__1 = i__ - 1;
for (k = m; k <= i__1; ++k) {

/*
         The first iteration of this loop determines a reflection G
         from the vector V and applies it from left and right to H,
         thus creating a nonzero bulge below the subdiagonal.

         Each subsequent iteration determines a reflection G to
         restore the Hessenberg form in the (K-1)th column, and thus
         chases the bulge one step toward the bottom of the active
         submatrix. NR is the order of G.

   Computing MIN
*/
i__2 = 3, i__3 = i__ - k + 1;
nr = min(i__2,i__3);
if (k > m) {
scopy_(&nr, &h__[k + (k - 1) * h_dim1], &c__1, v, &c__1);
}
slarfg_(&nr, v, &v[1], &c__1, &t1);
if (k > m) {
h__[k + (k - 1) * h_dim1] = v[0];
h__[k + 1 + (k - 1) * h_dim1] = 0.f;
if (k < i__ - 1) {
    h__[k + 2 + (k - 1) * h_dim1] = 0.f;
}
} else if (m > l) {
/*
         ==== Use the following instead of
         .    H( K, K-1 ) = -H( K, K-1 ) to
         .    avoid a bug when v(2) and v(3)
         .    underflow. ====
*/
h__[k + (k - 1) * h_dim1] *= 1.f - t1;
}
v2 = v[1];
t2 = t1 * v2;
if (nr == 3) {
v3 = v[2];
t3 = t1 * v3;

/*
        Apply G from the left to transform the rows of the matrix
        in columns K to I2.
*/
        i__2 = i2;
        // 循环：对于每个列索引 j 从 k 到 i2
        for (j = k; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1]
                + v3 * h__[k + 2 + j * h_dim1];
            h__[k + j * h_dim1] -= sum * t1;
            h__[k + 1 + j * h_dim1] -= sum * t2;
            h__[k + 2 + j * h_dim1] -= sum * t3;
/* L70: */
        }

/*
                从右侧应用 G 变换，将矩阵的列变换应用于行索引从 I1 到 min(K+3,I) 的区域
   计算 MIN
*/
        i__3 = k + 3;
        i__2 = min(i__3,i__);
        // 循环：对于每个行索引 j 从 i1 到 min(K+3,I)
        for (j = i1; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
                 + v3 * h__[j + (k + 2) * h_dim1];
            h__[j + k * h_dim1] -= sum * t1;
            h__[j + (k + 1) * h_dim1] -= sum * t2;
            h__[j + (k + 2) * h_dim1] -= sum * t3;
/* L80: */
        }

        if (*wantz) {

/*                 在矩阵 Z 中累积变换 */

            i__2 = *ihiz;
            // 循环：对于每个列索引 j 从 *iloz 到 *ihiz
            for (j = *iloz; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) *
                z_dim1] + v3 * z__[j + (k + 2) * z_dim1];
            z__[j + k * z_dim1] -= sum * t1;
            z__[j + (k + 1) * z_dim1] -= sum * t2;
            z__[j + (k + 2) * z_dim1] -= sum * t3;
/* L90: */
            }
        }
        } else if (nr == 2) {

/*
                从左侧应用 G 变换，将矩阵的行变换应用于列索引从 K 到 I2 的区域
*/

        i__2 = i2;
        // 循环：对于每个列索引 j 从 k 到 i2
        for (j = k; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1];
            h__[k + j * h_dim1] -= sum * t1;
            h__[k + 1 + j * h_dim1] -= sum * t2;
/* L100: */
        }

/*
                从右侧应用 G 变换，将矩阵的列变换应用于行索引从 I1 到 I 的区域
*/

        i__2 = i__;
        // 循环：对于每个行索引 j 从 i1 到 i__
        for (j = i1; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
                ;
            h__[j + k * h_dim1] -= sum * t1;
            h__[j + (k + 1) * h_dim1] -= sum * t2;
/* L110: */
        }

        if (*wantz) {

/*                 在矩阵 Z 中累积变换 */

            i__2 = *ihiz;
            // 循环：对于每个列索引 j 从 *iloz 到 *ihiz
            for (j = *iloz; j <= i__2; ++j) {
            // 计算对应元素的线性组合并更新
            sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) *
                z_dim1];
            z__[j + k * z_dim1] -= sum * t1;
            z__[j + (k + 1) * z_dim1] -= sum * t2;
/* L120: */
            }
        }
        }
/* L130: */
    }

/* L140: */
    }

/*     未能在剩余的迭代次数内收敛 */

    *info = i__;
    return 0;

L150:

    if (l == i__) {

/*        H(I,I-1) 微小：一个特征值已收敛。 */

    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.f;
    } else if (l == i__ - 1) {
/*
    H(I-1,I-2) is negligible: a pair of eigenvalues have converged.

    Transform the 2-by-2 submatrix to standard Schur form,
    and compute and store the eigenvalues.
*/
slanv2_(&h__[i__ - 1 + (i__ - 1) * h_dim1], &h__[i__ - 1 + i__ *
    h_dim1], &h__[i__ + (i__ - 1) * h_dim1], &h__[i__ + i__ *
    h_dim1], &wr[i__ - 1], &wi[i__ - 1], &wr[i__], &wi[i__], &cs,
    &sn);

if (*wantt) {
    /* Apply the transformation to the rest of H. */
    if (i2 > i__) {
        i__1 = i2 - i__;
        srot_(&i__1, &h__[i__ - 1 + (i__ + 1) * h_dim1], ldh, &h__[
            i__ + (i__ + 1) * h_dim1], ldh, &cs, &sn);
    }
    i__1 = i__ - i1 - 1;
    srot_(&i__1, &h__[i1 + (i__ - 1) * h_dim1], &c__1, &h__[i1 + i__ *
         h_dim1], &c__1, &cs, &sn);
}

if (*wantz) {
    /* Apply the transformation to Z. */
    srot_(&nz, &z__[*iloz + (i__ - 1) * z_dim1], &c__1, &z__[*iloz +
        i__ * z_dim1], &c__1, &cs, &sn);
}
}

/* return to start of the main loop with new value of I. */
i__ = l - 1;
goto L20;

L160:
return 0;

/* End of SLAHQR */
} /* slahqr_ */

/* Subroutine */ int slahr2_(integer *n, integer *k, integer *nb, real *a,
integer *lda, real *tau, real *t, integer *ldt, real *y, integer *ldy)
{
/* System generated locals */
integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2,
    i__3;
real r__1;

/* Local variables */
static integer i__;
static real ei;
extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
sgemm_(char *, char *, integer *, integer *, integer *, real *,
real *, integer *, real *, integer *, real *, real *, integer *), sgemv_(char *, integer *, integer *, real *,
real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *),
strmm_(char *, char *, char *, char *, integer *, integer *, real
    *, real *, integer *, real *, integer *), saxpy_(integer *, real *, real *, integer *, real *,
    integer *), strmv_(char *, char *, char *, integer *, real *,
    integer *, real *, integer *), slarfg_(
    integer *, real *, real *, integer *, real *), slacpy_(char *,
    integer *, integer *, real *, integer *, real *, integer *);

/*
-- LAPACK auxiliary routine (version 3.2.1)                        --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
-- April 2009                                                      --


Purpose
=======

SLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
matrix A so that elements below the k-th subdiagonal are zero. The
reduction is performed by an orthogonal similarity transformation
*/
    Q = I - V*T*V'. The routine returns the matrices V and T which determine
    Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.

    This is an auxiliary routine called by SGEHRD.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.

    K       (input) INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K < N.

    NB      (input) INTEGER
            The number of columns to be reduced.

    A       (input/output) REAL array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) REAL array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.

    T       (output) REAL array, dimension (LDT,NB)
            The upper triangular matrix T.

    LDT     (input) INTEGER
            The leading dimension of the array T.  LDT >= NB.

    Y       (output) REAL array, dimension (LDY,NB)
            The n-by-nb matrix Y.

    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= N.

    Further Details
    ===============

    The matrix Q is represented as a product of nb elementary reflectors

       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
    A(i+k+1:n,i), and tau in TAU(i).

    The elements of the vectors v together form the (n-k+1)-by-nb matrix
    V which is needed, with T and Y, to apply the transformation to the
    unreduced part of the matrix, using an update of the form:
    A := (I - V*T*V') * (A - Y*V').

    The contents of A on exit are illustrated by the following example
    with n = 7, k = 3 and nb = 2:

       ( a   a   a   a   a )
       ( a   a   a   a   a )
       ( a   a   a   a   a )
       ( h   h   a   a   a )
       ( v1  h   a   a   a )
       ( v1  v2  a   a   a )
       ( v1  v2  a   a   a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This subroutine is a slight modification of LAPACK-3.0's DLAHRD
    incorporating improvements proposed by Quintana-Orti and Van de
    Gejin. Note that the entries of A(1:K,2:NB) differ from those
       Quick return if possible
       # 如果可能，快速返回，说明此处可能有一种优化的情况下可以直接返回的情况
    /* Parameter adjustments */
    --tau;                          // 调整指针数组 tau，使其指向正确的位置
    a_dim1 = *lda;                  // a_dim1 表示数组 a 的第一维度大小
    a_offset = 1 + a_dim1;          // 计算 a 的偏移量
    a -= a_offset;                  // 调整数组 a，使其正确对应参数中传入的维度
    t_dim1 = *ldt;                  // t_dim1 表示数组 t 的第一维度大小
    t_offset = 1 + t_dim1;          // 计算 t 的偏移量
    t -= t_offset;                  // 调整数组 t，使其正确对应参数中传入的维度
    y_dim1 = *ldy;                  // y_dim1 表示数组 y 的第一维度大小
    y_offset = 1 + y_dim1;          // 计算 y 的偏移量
    y -= y_offset;                  // 调整数组 y，使其正确对应参数中传入的维度

    /* Function Body */
    if (*n <= 1) {                  // 如果 n 小于等于 1，则直接返回
        return 0;
    }

    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (i__ > 1) {

/*
             Update A(K+1:N,I)

             Update I-th column of A - Y * V'
*/

            i__2 = *n - *k;                                         // 计算更新 A 的起始索引
            i__3 = i__ - 1;                                         // 计算 Y 列的数量
            sgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151,             // 使用 SGEMV 函数更新 A
                   &y[*k + 1 + y_dim1], ldy, &a[*k + i__ - 1 + a_dim1], lda,
                   &c_b15, &a[*k + 1 + i__ * a_dim1], &c__1);

/*
             Apply I - V * T' * V' to this column (call it b) from the
             left, using the last column of T as workspace

             Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows)
                      ( V2 )             ( b2 )

             where V1 is unit lower triangular

             w := V1' * b1
*/

            i__2 = i__ - 1;                                         // 计算 V2 的数量
            scopy_(&i__2, &a[*k + 1 + i__ * a_dim1], &c__1,           // 复制 b1 到 T 的最后一列
                   &t[*nb * t_dim1 + 1], &c__1);
            i__2 = i__ - 1;
            strmv_("Lower", "Transpose", "UNIT", &i__2,               // 计算 w = V1' * b1
                   &a[*k + 1 + a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);

/*           w := w + V2'*b2 */

            i__2 = *n - *k - i__ + 1;                                // 计算 V2 的数量
            i__3 = i__ - 1;                                         // 计算 b2 的数量
            sgemv_("Transpose", &i__2, &i__3, &c_b15,                 // 计算 w = w + V2'*b2
                   &a[*k + i__ + a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1,
                   &c_b15, &t[*nb * t_dim1 + 1], &c__1);

/*           w := T'*w */

            i__2 = i__ - 1;                                         // 计算 T 的数量
            strmv_("Upper", "Transpose", "NON-UNIT", &i__2,           // 计算 w = T'*w
                   &t[t_offset], ldt, &t[*nb * t_dim1 + 1], &c__1);

/*           b2 := b2 - V2*w */

            i__2 = *n - *k - i__ + 1;                                // 计算 V2 的数量
            i__3 = i__ - 1;                                         // 计算 w 的数量
            sgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151,             // 计算 b2 = b2 - V2*w
                   &a[*k + i__ + a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1,
                   &c_b15, &a[*k + i__ + i__ * a_dim1], &c__1);

/*           b1 := b1 - V1*w */

            i__2 = i__ - 1;                                         // 计算 V1 的数量
            strmv_("Lower", "NO TRANSPOSE", "UNIT", &i__2,            // 计算 b1 = b1 - V1*w
                   &a[*k + 1 + a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);
            i__2 = i__ - 1;
            saxpy_(&i__2, &c_b151, &t[*nb * t_dim1 + 1], &c__1,        // 使用 SAXPY 函数更新 b1
                   &a[*k + 1 + i__ * a_dim1], &c__1);

            a[*k + i__ - 1 + (i__ - 1) * a_dim1] = ei;                // 将 ei 存储到 A 的对角元素位置
        }

/*
          Generate the elementary reflector H(I) to annihilate
          A(K+I+1:N,I)
*/

        i__2 = *n - *k - i__ + 1;                                     // 计算生成 H(I) 的长度
        /* Computing MIN */
        i__3 = *k + i__ + 1;                                          // 计算索引的最小值
        slarfg_(&i__2, &a[*k + i__ + i__ * a_dim1], &a[min(i__3,*n) + i__ * a_dim1],
                &c__1, &tau[i__]);                                    // 调用 SLARFG 生成 H(I)，并存储到 tau 数组

        ei = a[*k + i__ + i__ * a_dim1];                               // 将生成的 H(I) 元素存储到 ei
        a[*k + i__ + i__ * a_dim1] = 1.f;                              // 设置 A(K+I,I) = 1，将 H(I) 单位化

/*        Compute  Y(K+1:N,I) */

        i__2 = *n - *k;                                                // 计算 Y 的长度
        i__3 = *n - *k - i__ + 1;                                       // 计算 A 列的数量
        sgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b15,                     // 计算 Y(K+1:N,I)
               &a[*k + 1 + (i__ + 1) * a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1,
               &c_b29, &y[*k + 1 + i__ * y_dim1], &c__1);
    i__2 = *n - *k - i__ + 1;
    # 计算数组索引范围的大小
    i__3 = i__ - 1;
    # 计算数组索引范围的大小
    sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[*k + i__ + a_dim1], lda,
        &a[*k + i__ + i__ * a_dim1], &c__1, &c_b29, &t[i__ * t_dim1 +
        1], &c__1);
    # 调用 BLAS 库中的 sgemv 函数，执行矩阵-向量乘法，计算结果存入 t 数组
    i__2 = *n - *k;
    # 计算数组索引范围的大小
    i__3 = i__ - 1;
    # 计算数组索引范围的大小
    sgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151, &y[*k + 1 + y_dim1],
        ldy, &t[i__ * t_dim1 + 1], &c__1, &c_b15, &y[*k + 1 + i__ *
        y_dim1], &c__1);
    # 调用 BLAS 库中的 sgemv 函数，执行矩阵-向量乘法，计算结果存入 y 数组
    i__2 = *n - *k;
    # 计算数组索引范围的大小
    sscal_(&i__2, &tau[i__], &y[*k + 1 + i__ * y_dim1], &c__1);
    # 调用 BLAS 库中的 sscal 函数，对 y 数组中的向量进行缩放操作
/*
    Compute T(1:I,I)
*/

i__2 = i__ - 1;
r__1 = -tau[i__];
sscal_(&i__2, &r__1, &t[i__ * t_dim1 + 1], &c__1);

/*
    Apply the transformation to the remaining part of matrix T
*/

i__2 = i__ - 1;
strmv_("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
       &t[i__ * t_dim1 + 1], &c__1);

/*
    Set the diagonal element of T
*/

t[i__ + i__ * t_dim1] = tau[i__];

/* L10: */
}
/*
    Update matrix A with the value of ei
*/

a[*k + *nb + *nb * a_dim1] = ei;

/*
    Compute Y(1:K,1:NB)
*/

slacpy_("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
strmm_("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b15, &a[*k + 1
       + a_dim1], lda, &y[y_offset], ldy);

/*
    Perform further computations if n > k + nb
*/

if (*n > *k + *nb) {
    i__1 = *n - *k - *nb;
    sgemm_("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b15, &a[(*nb
           + 2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &
           c_b15, &y[y_offset], ldy);
}

/*
    Update matrix Y using the upper triangular matrix T
*/

strmm_("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b15, &t[
       t_offset], ldt, &y[y_offset], ldy);

return 0;

/*
    End of SLAHR2
*/

} /* slahr2_ */

logical slaisnan_(real *sin1, real *sin2)
{
    /*
        SLAISNAN checks for NaNs by comparing its two arguments for inequality.
        NaN is the only floating-point value where NaN != NaN returns .TRUE.
        To check for NaNs, pass the same variable as both arguments.
    */

    ret_val = *sin1 != *sin2;
    return ret_val;
} /* slaisnan_ */

int slaln2_(logical *ltrans, integer *na, integer *nw, real *smin, real *ca, real *a,
            integer *lda, real *d1, real *d2, real *b, integer *ldb, real *wr,
            real *wi, real *x, integer *ldx, real *scale, real *xnorm, integer *info)
{
    /*
        Initialized data
    */

    static logical cswap[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical rswap[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };
    static integer ipivot[16] = { 1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1 };

    /*
        Local variables
    */
    # 定义静态整型变量 j
    static integer j;
#define ci (equiv_0)
#define cr (equiv_1)
    static real bi1, bi2, br1, br2, xi1, xi2, xr1, xr2, ci21, ci22, cr21,
        cr22, li21, csi, ui11, lr21, ui12, ui22;
#define civ (equiv_0)
    static real csr, ur11, ur12, ur22;
#define crv (equiv_1)
    static real bbnd, cmax, ui11r, ui12s, temp, ur11r, ur12s, u22abs;
    static integer icmax;
    static real bnorm, cnorm, smini;
    extern doublereal slamch_(char *);
    static real bignum;
    extern /* Subroutine */ int sladiv_(real *, real *, real *, real *, real *
        , real *);
    static real smlnum;

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    SLALN2 solves a system of the form  (ca A - w D ) X = s B
    or (ca A' - w D) X = s B   with possible scaling ("s") and
    perturbation of A.  (A' means A-transpose.)

    A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
    real diagonal matrix, w is a real or complex value, and X and B are
    NA x 1 matrices -- real if w is real, complex if w is complex.  NA
    may be 1 or 2.

    If w is complex, X and B are represented as NA x 2 matrices,
    the first column of each being the real part and the second
    being the imaginary part.

    "s" is a scaling factor (.LE. 1), computed by SLALN2, which is
    so chosen that X can be computed without overflow.  X is further
    scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
    than overflow.

    If both singular values of (ca A - w D) are less than SMIN,
    SMIN*identity will be used instead of (ca A - w D).  If only one
    singular value is less than SMIN, one element of (ca A - w D) will be
    perturbed enough to make the smallest singular value roughly SMIN.
    If both singular values are at least SMIN, (ca A - w D) will not be
    perturbed.  In any case, the perturbation will be at most some small
    multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
    are computed by infinity-norm approximations, and thus will only be
    correct to a factor of 2 or so.

    Note: all input quantities are assumed to be smaller than overflow
    by a reasonable factor.  (See BIGNUM.)

    Arguments
    ==========

    LTRANS  (input) LOGICAL
            =.TRUE.:  A-transpose will be used.
            =.FALSE.: A will be used (not transposed.)

    NA      (input) INTEGER
            The size of the matrix A.  It may (only) be 1 or 2.

    NW      (input) INTEGER
            1 if "w" is real, 2 if "w" is complex.  It may only be 1
            or 2.


注释：
    SMIN    (input) REAL
            The desired lower bound on the singular values of A.  This
            should be a safe distance away from underflow or overflow,
            say, between (underflow/machine precision) and  (machine
            precision * overflow ).  (See BIGNUM and ULP.)

    CA      (input) REAL
            The coefficient c, which A is multiplied by.

    A       (input) REAL array, dimension (LDA,NA)
            The NA x NA matrix A.

    LDA     (input) INTEGER
            The leading dimension of A.  It must be at least NA.

    D1      (input) REAL
            The 1,1 element in the diagonal matrix D.

    D2      (input) REAL
            The 2,2 element in the diagonal matrix D.  Not used if NW=1.

    B       (input) REAL array, dimension (LDB,NW)
            The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
            complex), column 1 contains the real part of B and column 2
            contains the imaginary part.

    LDB     (input) INTEGER
            The leading dimension of B.  It must be at least NA.

    WR      (input) REAL
            The real part of the scalar "w".

    WI      (input) REAL
            The imaginary part of the scalar "w".  Not used if NW=1.

    X       (output) REAL array, dimension (LDX,NW)
            The NA x NW matrix X (unknowns), as computed by SLALN2.
            If NW=2 ("w" is complex), on exit, column 1 will contain
            the real part of X and column 2 will contain the imaginary
            part.

    LDX     (input) INTEGER
            The leading dimension of X.  It must be at least NA.

    SCALE   (output) REAL
            The scale factor that B must be multiplied by to insure
            that overflow does not occur when computing X.  Thus,
            (ca A - w D) X  will be SCALE*B, not B (ignoring
            perturbations of A.)  It will be at most 1.

    XNORM   (output) REAL
            The infinity-norm of X, when X is regarded as an NA x NW
            real matrix.

    INFO    (output) INTEGER
            An error flag.  It will be set to zero if no error occurs,
            a negative number if an argument is in error, or a positive
            number if  ca A - w D  had to be perturbed.
            The possible values are:
            = 0: No error occurred, and (ca A - w D) did not have to be
                 perturbed.
            = 1: (ca A - w D) had to be perturbed to make its smallest
                 (or only) singular value greater than SMIN.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.

   =====================================================================
    /* Parameter adjustments */
    // 设置矩阵 A、B 和 X 的维度及偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;

    /* Function Body */

    /*     Compute BIGNUM */
    // 计算 BIGNUM 和 SMLNUM 的值
    smlnum = 2.f * slamch_("Safe minimum");
    bignum = 1.f / smlnum;
    smini = dmax(*smin,smlnum);

    /*     Don't check for input errors */
    // 不检查输入错误，直接将 info 置为零
    *info = 0;

    /*     Standard Initializations */
    // 标准初始化，将 scale 设置为 1.0
    *scale = 1.f;

    if (*na == 1) {

        /*        1 x 1  (i.e., scalar) system   C X = B */

        if (*nw == 1) {

            /*
                 Real 1x1 system.

                 C = ca A - w D
            */

            // 计算 C 的值，其中 A 和 D 是输入矩阵和向量
            csr = *ca * a[a_dim1 + 1] - *wr * *d1;
            // 计算 C 的绝对值，用于后续判断
            cnorm = dabs(csr);

            /*           If | C | < SMINI, use C = SMINI */
            // 如果 | C | 小于预设的最小值 SMINI，则将 C 设置为 SMINI
            if (cnorm < smini) {
                csr = smini;
                cnorm = smini;
                *info = 1;  // 设置 info 为 1，表示 C 被截断为 SMINI
            }

            /*           Check scaling for  X = B / C */
            // 检查 X = B / C 的缩放情况
            bnorm = (r__1 = b[b_dim1 + 1], dabs(r__1));
            if (cnorm < 1.f && bnorm > 1.f) {
                if (bnorm > bignum * cnorm) {
                    *scale = 1.f / bnorm;  // 根据比例缩放 X
                }
            }

            /*           Compute X */
            // 计算 X = B / C
            x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / csr;
            *xnorm = (r__1 = x[x_dim1 + 1], dabs(r__1));  // 计算 X 的范数
        } else {

            /*
                 Complex 1x1 system (w is complex)

                 C = ca A - w D
            */

            // 计算复数情况下的 C
            csr = *ca * a[a_dim1 + 1] - *wr * *d1;
            csi = -(*wi) * *d1;
            // 计算复数 C 的绝对值
            cnorm = dabs(csr) + dabs(csi);

            /*           If | C | < SMINI, use C = SMINI */
            // 如果 | C | 小于预设的最小值 SMINI，则将 C 设置为 SMINI
            if (cnorm < smini) {
                csr = smini;
                csi = 0.f;
                cnorm = smini;
                *info = 1;  // 设置 info 为 1，表示 C 被截断为 SMINI
            }

            /*           Check scaling for  X = B / C */
            // 检查 X = B / C 的缩放情况
            bnorm = (r__1 = b[b_dim1 + 1], dabs(r__1)) + (r__2 = b[(b_dim1 <<
                1) + 1], dabs(r__2));
            if (cnorm < 1.f && bnorm > 1.f) {
                if (bnorm > bignum * cnorm) {
                    *scale = 1.f / bnorm;  // 根据比例缩放 X
                }
            }

            /*           Compute X */
            // 计算 X = B / C
            r__1 = *scale * b[b_dim1 + 1];
            r__2 = *scale * b[(b_dim1 << 1) + 1];
            sladiv_(&r__1, &r__2, &csr, &csi, &x[x_dim1 + 1], &x[(x_dim1 << 1)
                + 1]);
            *xnorm = (r__1 = x[x_dim1 + 1], dabs(r__1)) + (r__2 = x[(x_dim1 <<
                1) + 1], dabs(r__2));  // 计算 X 的范数
        }

    } else {

        /*
              2x2 System

              Compute the real part of  C = ca A - w D  (or  ca A' - w D )
        */

        // 计算 2x2 系统的实部 C
        cr[0] = *ca * a[a_dim1 + 1] - *wr * *d1;
        cr[3] = *ca * a[(a_dim1 << 1) + 2] - *wr * *d2;
        if (*ltrans) {
            cr[2] = *ca * a[a_dim1 + 2];
            cr[1] = *ca * a[(a_dim1 << 1) + 1];
        } else {
            cr[1] = *ca * a[a_dim1 + 2];
            cr[2] = *ca * a[(a_dim1 << 1) + 1];
        }

        if (*nw == 1) {

            /*
                 Real 2x2 system  (w is real)

                 Find the largest element in C
            */

            // 找到 C 中的最大元素
            cmax = 0.f;
            icmax = 0;

            for (j = 1; j <= 4; ++j) {
                if ((r__1 = cr[j - 1], dabs(r__1)) > cmax) {
                    cmax = (r__1 = cr[j - 1], dabs(r__1));
                    icmax = j;
                }
            }
/* L10: */

/* 如果 C 的最大范数小于 SMINI，则使用 SMINI*单位矩阵。 */
        }

/* 如果 norm(C) < SMINI，则使用 SMINI*单位矩阵。 */

/* 如果 C 的最大范数小于 SMINI，则执行以下操作 */
        if (cmax < smini) {
/* 计算 MAX */
        r__3 = (r__1 = b[b_dim1 + 1], dabs(r__1)), r__4 = (r__2 = b[
            b_dim1 + 2], dabs(r__2));
        bnorm = dmax(r__3,r__4);
        if (smini < 1.f && bnorm > 1.f) {
            if (bnorm > bignum * smini) {
            *scale = 1.f / bnorm;
            }
        }
        temp = *scale / smini;
        x[x_dim1 + 1] = temp * b[b_dim1 + 1];
        x[x_dim1 + 2] = temp * b[b_dim1 + 2];
        *xnorm = temp * bnorm;
        *info = 1;
        return 0;
        }

/* 高斯消元法与完全主元素交换。 */

/* 使用完全主元素交换的高斯消元法。 */
        ur11 = crv[icmax - 1];
        cr21 = crv[ipivot[(icmax << 2) - 3] - 1];
        ur12 = crv[ipivot[(icmax << 2) - 2] - 1];
        cr22 = crv[ipivot[(icmax << 2) - 1] - 1];
        ur11r = 1.f / ur11;
        lr21 = ur11r * cr21;
        ur22 = cr22 - ur12 * lr21;

/* 如果较小的主元素 < SMINI，则使用 SMINI。 */

/* 如果绝对值小于 SMINI，则将主元素替换为 SMINI。 */
        if (dabs(ur22) < smini) {
        ur22 = smini;
        *info = 1;
        }
        if (rswap[icmax - 1]) {
        br1 = b[b_dim1 + 2];
        br2 = b[b_dim1 + 1];
        } else {
        br1 = b[b_dim1 + 1];
        br2 = b[b_dim1 + 2];
        }
        br2 -= lr21 * br1;
/* 计算 MAX */
        r__2 = (r__1 = br1 * (ur22 * ur11r), dabs(r__1)), r__3 = dabs(br2)
            ;
        bbnd = dmax(r__2,r__3);
        if (bbnd > 1.f && dabs(ur22) < 1.f) {
        if (bbnd >= bignum * dabs(ur22)) {
            *scale = 1.f / bbnd;
        }
        }

        xr2 = br2 * *scale / ur22;
        xr1 = *scale * br1 * ur11r - xr2 * (ur11r * ur12);
        if (cswap[icmax - 1]) {
        x[x_dim1 + 1] = xr2;
        x[x_dim1 + 2] = xr1;
        } else {
        x[x_dim1 + 1] = xr1;
        x[x_dim1 + 2] = xr2;
        }
/* 计算 MAX */
        r__1 = dabs(xr1), r__2 = dabs(xr2);
        *xnorm = dmax(r__1,r__2);

/* 如果 norm(A) norm(X) > overflow，则进一步缩放。 */

/* 如果乘积的范数超出了限制，则进一步缩放。 */
        if (*xnorm > 1.f && cmax > 1.f) {
        if (*xnorm > bignum / cmax) {
            temp = cmax / bignum;
            x[x_dim1 + 1] = temp * x[x_dim1 + 1];
            x[x_dim1 + 2] = temp * x[x_dim1 + 2];
            *xnorm = temp * *xnorm;
            *scale = temp * *scale;
        }
        }
    } else {

/*
             复数 2x2 系统（w 是复数）

             查找 C 中的最大元素
*/

        ci[0] = -(*wi) * *d1;
        ci[1] = 0.f;
        ci[2] = 0.f;
        ci[3] = -(*wi) * *d2;
        cmax = 0.f;
        icmax = 0;

        for (j = 1; j <= 4; ++j) {
        if ((r__1 = crv[j - 1], dabs(r__1)) + (r__2 = civ[j - 1],
            dabs(r__2)) > cmax) {
            cmax = (r__1 = crv[j - 1], dabs(r__1)) + (r__2 = civ[j -
                1], dabs(r__2));
            icmax = j;
        }
/* L20: */
        }

/* 如果 norm(C) < SMINI，则使用 SMINI*单位矩阵。 */

/* 如果 C 的最大范数小于 SMINI，则使用 SMINI*单位矩阵。 */
        if (cmax < smini) {
/* Computing MAX */
        // 计算两个表达式的绝对值之和，确定最大值作为bnorm
        r__5 = (r__1 = b[b_dim1 + 1], dabs(r__1)) + (r__2 = b[(b_dim1
            << 1) + 1], dabs(r__2)), r__6 = (r__3 = b[b_dim1 + 2],
             dabs(r__3)) + (r__4 = b[(b_dim1 << 1) + 2], dabs(
            r__4));
        bnorm = dmax(r__5,r__6);
        // 如果smini小于1且bnorm大于1，则调整scale使得bnorm * scale = bignum * smini
        if (smini < 1.f && bnorm > 1.f) {
            if (bnorm > bignum * smini) {
            *scale = 1.f / bnorm;
            }
        }
        // 计算temp = scale / smini
        temp = *scale / smini;
        // 对x向量进行更新
        x[x_dim1 + 1] = temp * b[b_dim1 + 1];
        x[x_dim1 + 2] = temp * b[b_dim1 + 2];
        x[(x_dim1 << 1) + 1] = temp * b[(b_dim1 << 1) + 1];
        x[(x_dim1 << 1) + 2] = temp * b[(b_dim1 << 1) + 2];
        // 计算并更新xnorm
        *xnorm = temp * bnorm;
        // 设置info标志为1
        *info = 1;
        // 返回0表示成功
        return 0;
        }

/*           Gaussian elimination with complete pivoting. */

        // 从pivoted C矩阵中提取元素
        ur11 = crv[icmax - 1];
        ui11 = civ[icmax - 1];
        cr21 = crv[ipivot[(icmax << 2) - 3] - 1];
        ci21 = civ[ipivot[(icmax << 2) - 3] - 1];
        ur12 = crv[ipivot[(icmax << 2) - 2] - 1];
        ui12 = civ[ipivot[(icmax << 2) - 2] - 1];
        cr22 = crv[ipivot[(icmax << 2) - 1] - 1];
        ci22 = civ[ipivot[(icmax << 2) - 1] - 1];
        // 根据icmax值进行分支处理
        if (icmax == 1 || icmax == 4) {

/*              Code when off-diagonals of pivoted C are real */

        // 根据ur11和ui11的绝对值大小选择不同的计算路径
        if (dabs(ur11) > dabs(ui11)) {
            temp = ui11 / ur11;
/* Computing 2nd power */
            // 计算temp的平方
            r__1 = temp;
            // 计算ur11r和ui11r
            ur11r = 1.f / (ur11 * (r__1 * r__1 + 1.f));
            ui11r = -temp * ur11r;
        } else {
            temp = ur11 / ui11;
/* Computing 2nd power */
            // 计算temp的平方
            r__1 = temp;
            // 计算ur11r和ui11r
            ui11r = -1.f / (ui11 * (r__1 * r__1 + 1.f));
            ur11r = -temp * ui11r;
        }
        // 计算lr21和li21
        lr21 = cr21 * ur11r;
        li21 = cr21 * ui11r;
        // 计算ur12s和ui12s
        ur12s = ur12 * ur11r;
        ui12s = ur12 * ui11r;
        // 计算ur22和ui22
        ur22 = cr22 - ur12 * lr21;
        ui22 = ci22 - ur12 * li21;
        } else {

/*              Code when diagonals of pivoted C are real */

        // 当pivoted C的对角线元素是实数时的计算路径
        ur11r = 1.f / ur11;
        ui11r = 0.f;
        // 计算lr21和li21
        lr21 = cr21 * ur11r;
        li21 = ci21 * ur11r;
        // 计算ur12s和ui12s
        ur12s = ur12 * ur11r;
        ui12s = ui12 * ur11r;
        // 计算ur22和ui22
        ur22 = cr22 - ur12 * lr21 + ui12 * li21;
        ui22 = -ur12 * li21 - ui12 * lr21;
        }
        // 计算u22abs
        u22abs = dabs(ur22) + dabs(ui22);

/*           If smaller pivot < SMINI, use SMINI */

        // 如果u22abs小于smini，则设置ur22为smini，ui22为0，并设置info标志为1
        if (u22abs < smini) {
        ur22 = smini;
        ui22 = 0.f;
        *info = 1;
        }
        // 根据rswap数组选择更新b向量中的元素
        if (rswap[icmax - 1]) {
        br2 = b[b_dim1 + 1];
        br1 = b[b_dim1 + 2];
        bi2 = b[(b_dim1 << 1) + 1];
        bi1 = b[(b_dim1 << 1) + 2];
        } else {
        br1 = b[b_dim1 + 1];
        br2 = b[b_dim1 + 2];
        bi1 = b[(b_dim1 << 1) + 1];
        bi2 = b[(b_dim1 << 1) + 2];
        }
        // 更新br2和bi2
        br2 = br2 - lr21 * br1 + li21 * bi1;
        bi2 = bi2 - li21 * br1 - lr21 * bi1;
/* Computing MAX */
        r__1 = (dabs(br1) + dabs(bi1)) * (u22abs * (dabs(ur11r) + dabs(
            ui11r))), r__2 = dabs(br2) + dabs(bi2);
        bbnd = dmax(r__1,r__2);
        if (bbnd > 1.f && u22abs < 1.f) {
        if (bbnd >= bignum * u22abs) {
            *scale = 1.f / bbnd;
            br1 = *scale * br1;
            bi1 = *scale * bi1;
            br2 = *scale * br2;
            bi2 = *scale * bi2;
        }
        }

        sladiv_(&br2, &bi2, &ur22, &ui22, &xr2, &xi2);
        xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2;
        xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2;
        if (cswap[icmax - 1]) {
        x[x_dim1 + 1] = xr2;
        x[x_dim1 + 2] = xr1;
        x[(x_dim1 << 1) + 1] = xi2;
        x[(x_dim1 << 1) + 2] = xi1;
        } else {
        x[x_dim1 + 1] = xr1;
        x[x_dim1 + 2] = xr2;
        x[(x_dim1 << 1) + 1] = xi1;
        x[(x_dim1 << 1) + 2] = xi2;
        }
/* Computing MAX */
        r__1 = dabs(xr1) + dabs(xi1), r__2 = dabs(xr2) + dabs(xi2);
        *xnorm = dmax(r__1,r__2);

/*           Further scaling if  norm(A) norm(X) > overflow */

        if (*xnorm > 1.f && cmax > 1.f) {
        if (*xnorm > bignum / cmax) {
            temp = cmax / bignum;
            x[x_dim1 + 1] = temp * x[x_dim1 + 1];
            x[x_dim1 + 2] = temp * x[x_dim1 + 2];
            x[(x_dim1 << 1) + 1] = temp * x[(x_dim1 << 1) + 1];
            x[(x_dim1 << 1) + 2] = temp * x[(x_dim1 << 1) + 2];
            *xnorm = temp * *xnorm;
            *scale = temp * *scale;
        }
        }


注释：


/* Computing MAX */
        // 计算两个表达式的最大值，用于确定 bbnd 的值
        r__1 = (dabs(br1) + dabs(bi1)) * (u22abs * (dabs(ur11r) + dabs(
            ui11r))), r__2 = dabs(br2) + dabs(bi2);
        bbnd = dmax(r__1,r__2);

        // 如果 bbnd 大于 1 且 u22abs 小于 1，则进行进一步的条件判断和操作
        if (bbnd > 1.f && u22abs < 1.f) {
            // 如果 bbnd 超过阈值 bignum * u22abs，则进行归一化操作
            if (bbnd >= bignum * u22abs) {
                *scale = 1.f / bbnd;  // 计算缩放因子
                br1 = *scale * br1;   // 对 br1 进行缩放
                bi1 = *scale * bi1;   // 对 bi1 进行缩放
                br2 = *scale * br2;   // 对 br2 进行缩放
                bi2 = *scale * bi2;   // 对 bi2 进行缩放
            }
        }

        // 调用 sladiv_ 函数计算复数除法
        sladiv_(&br2, &bi2, &ur22, &ui22, &xr2, &xi2);

        // 计算更新后的 x 向量的值
        xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2;
        xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2;

        // 根据 cswap[icmax - 1] 的值选择如何排列 x 向量中的元素
        if (cswap[icmax - 1]) {
            x[x_dim1 + 1] = xr2;
            x[x_dim1 + 2] = xr1;
            x[(x_dim1 << 1) + 1] = xi2;
            x[(x_dim1 << 1) + 2] = xi1;
        } else {
            x[x_dim1 + 1] = xr1;
            x[x_dim1 + 2] = xr2;
            x[(x_dim1 << 1) + 1] = xi1;
            x[(x_dim1 << 1) + 2] = xi2;
        }

/* Computing MAX */
        // 计算两个表达式的最大值，用于更新 xnorm 的值
        r__1 = dabs(xr1) + dabs(xi1), r__2 = dabs(xr2) + dabs(xi2);
        *xnorm = dmax(r__1,r__2);

/*           Further scaling if  norm(A) norm(X) > overflow */

        // 如果 xnorm 和 cmax 的乘积大于阈值 bignum，则进行进一步的缩放
        if (*xnorm > 1.f && cmax > 1.f) {
            if (*xnorm > bignum / cmax) {
                temp = cmax / bignum;  // 计算缩放因子
                x[x_dim1 + 1] = temp * x[x_dim1 + 1];       // 对 x[x_dim1 + 1] 缩放
                x[x_dim1 + 2] = temp * x[x_dim1 + 2];       // 对 x[x_dim1 + 2] 缩放
                x[(x_dim1 << 1) + 1] = temp * x[(x_dim1 << 1) + 1]; // 对 x[(x_dim1 << 1) + 1] 缩放
                x[(x_dim1 << 1) + 2] = temp * x[(x_dim1 << 1) + 2]; // 对 x[(x_dim1 << 1) + 2] 缩放
                *xnorm = temp * *xnorm;     // 更新 xnorm 的值
                *scale = temp * *scale;     // 更新 scale 的值
            }
        }
    }
    }

    return 0;

/*     End of SLALN2 */

} /* slaln2_ */

#undef crv
#undef civ
#undef cr
#undef ci


/* Subroutine */ int slals0_(integer *icompq, integer *nl, integer *nr,
    integer *sqre, integer *nrhs, real *b, integer *ldb, real *bx,
    integer *ldbx, integer *perm, integer *givptr, integer *givcol,
    integer *ldgcol, real *givnum, integer *ldgnum, real *poles, real *
    difl, real *difr, real *z__, integer *k, real *c__, real *s, real *
    work, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, b_dim1, b_offset, bx_dim1, bx_offset,
        difr_dim1, difr_offset, givnum_dim1, givnum_offset, poles_dim1,
        poles_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j, m, n;
    static real dj;
    static integer nlp1;
    static real temp;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);
    extern doublereal snrm2_(integer *, real *, integer *);
    static real diflj, difrj, dsigj;
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        sgemv_(char *, integer *, integer *, real *, real *, integer *,
        real *, integer *, real *, real *, integer *), scopy_(
        integer *, real *, integer *, real *, integer *);
    extern doublereal slamc3_(real *, real *);


注释完成。这些注释解释了每行代码的具体作用
    # 外部声明一个名为 xerbla_ 的子程序，该子程序接受一个字符指针和一个整数指针作为参数
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 静态声明一个实数变量 dsigjp
    static real dsigjp;

    # 外部声明两个子程序 slascl_ 和 slacpy_
    # slascl_ 子程序接受多个参数，用于缩放矩阵
    # 参数解释：
    # - 第一个字符参数：指定操作类型
    # - 第二和第三个整数参数：指定矩阵的维度
    # - 第四和第五个实数参数：指定缩放的规模和类型
    # - 第六和第七个整数参数：指定矩阵中要缩放的元素范围
    # - 第八个实数参数：指定缩放系数
    # - 第九和第十个整数参数：指定缩放操作的详细信息
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);

    # slacpy_ 子程序接受多个参数，用于将矩阵复制到另一个矩阵中
    # 参数解释：
    # - 第一个字符参数：指定操作类型
    # - 第二和第三个整数参数：指定矩阵的维度
    # - 第四和第五个实数参数：源矩阵和目标矩阵
    # - 第六和第七个整数参数：指定矩阵的列宽
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, integer *,
        real *, integer *);
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======
SLALS0 applies back the multiplying factors of either the left or the
right singular vector matrix of a diagonal matrix appended by a row
to the right hand side matrix B in solving the least squares problem
using the divide-and-conquer SVD approach.

For the left singular vector matrix, three types of orthogonal
matrices are involved:

(1L) Givens rotations: the number of such rotations is GIVPTR; the
     pairs of columns/rows they were applied to are stored in GIVCOL;
     and the C- and S-values of these rotations are stored in GIVNUM.

(2L) Permutation. The (NL+1)-st row of B is to be moved to the first
     row, and for J=2:N, PERM(J)-th row of B is to be moved to the
     J-th row.

(3L) The left singular vector matrix of the remaining matrix.

For the right singular vector matrix, four types of orthogonal
matrices are involved:

(1R) The right singular vector matrix of the remaining matrix.

(2R) If SQRE = 1, one extra Givens rotation to generate the right
     null space.

(3R) The inverse transformation of (2L).

(4R) The inverse transformation of (1L).

Arguments
=========
ICOMPQ (input) INTEGER
       Specifies whether singular vectors are to be computed in
       factored form:
       = 0: Left singular vector matrix.
       = 1: Right singular vector matrix.

NL     (input) INTEGER
       The row dimension of the upper block. NL >= 1.

NR     (input) INTEGER
       The row dimension of the lower block. NR >= 1.

SQRE   (input) INTEGER
       = 0: the lower block is an NR-by-NR square matrix.
       = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

       The bidiagonal matrix has row dimension N = NL + NR + 1,
       and column dimension M = N + SQRE.

NRHS   (input) INTEGER
       The number of columns of B and BX. NRHS must be at least 1.

B      (input/output) REAL array, dimension ( LDB, NRHS )
       On input, B contains the right hand sides of the least
       squares problem in rows 1 through M. On output, B contains
       the solution X in rows 1 through N.

LDB    (input) INTEGER
       The leading dimension of B. LDB must be at least
       max(1,MAX( M, N ) ).

BX     (workspace) REAL array, dimension ( LDBX, NRHS )

LDBX   (input) INTEGER
       The leading dimension of BX.

PERM   (input) INTEGER array, dimension ( N )
       The permutations (from deflation and sorting) applied
       to the two blocks.

GIVPTR (input) INTEGER
       The number of Givens rotations which took place in this
       subproblem.
"""
    # 输入参数说明：
    #
    # GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )
    #        每对数字表示参与 Givens 旋转的一对行/列。
    #
    # LDGCOL (input) INTEGER
    #        GIVCOL 的 leading dimension，至少应为 N。
    #
    # GIVNUM (input) REAL array, dimension ( LDGNUM, 2 )
    #        每个数字表示对应 Givens 旋转中使用的 C 或 S 值。
    #
    # LDGNUM (input) INTEGER
    #        数组 DIFR、POLES 和 GIVNUM 的 leading dimension，至少应为 K。
    #
    # POLES  (input) REAL array, dimension ( LDGNUM, 2 )
    #        On entry, POLES(1:K, 1) 包含从解超越方程得到的新奇异值，
    #        POLES(1:K, 2) 是超越方程中的极点数组。
    #
    # DIFL   (input) REAL array, dimension ( K ).
    #        On entry, DIFL(I) 是第 I 个更新（未缩减）奇异值与第 I 个
    #        （未缩减）旧奇异值之间的距离。
    #
    # DIFR   (input) REAL array, dimension ( LDGNUM, 2 ).
    #        On entry, DIFR(I, 1) 包含第 I 个更新（未缩减）奇异值与第 I+1 个
    #        （未缩减）旧奇异值之间的距离。DIFR(I, 2) 是第 I 个右奇异向量的
    #        归一化因子。
    #
    # Z      (input) REAL array, dimension ( K )
    #        包含缩减调整后的更新行向量的分量。
    #
    # K      (input) INTEGER
    #        非缩减矩阵的维数，这是相关超越方程的阶数。1 <= K <= N。
    #
    # C      (input) REAL
    #        如果 SQRE = 0，则 C 包含垃圾值；如果 SQRE = 1，则 C 是与右零空间
    #        相关的 Givens 旋转的 C 值。
    #
    # S      (input) REAL
    #        如果 SQRE = 0，则 S 包含垃圾值；如果 SQRE = 1，则 S 是与右零空间
    #        相关的 Givens 旋转的 S 值。
    #
    # WORK   (workspace) REAL array, dimension ( K )
    #        工作空间数组。
    #
    # INFO   (output) INTEGER
    #        = 0:  成功退出。
    #        < 0:  如果 INFO = -i，则第 i 个参数具有非法值。
    #
    # Further Details
    # ===============
    # 基于以下贡献：
    #    Ming Gu 和 Ren-Cang Li，加州大学伯克利分校计算机科学系，美国
    #    Osni Marques，LBNL/NERSC，美国
    #
    # =====================================================================
    #
    # 测试输入参数。
    /* Parameter adjustments */
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    --perm;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    difr_dim1 = *ldgnum;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    poles_dim1 = *ldgnum;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    givnum_dim1 = *ldgnum;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    --difl;
    --z__;
    --work;

    /* Function Body */
    *info = 0;

    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*nl < 1) {
        *info = -2;
    } else if (*nr < 1) {
        *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -4;
    }

    n = *nl + *nr + 1;

    if (*nrhs < 1) {
        *info = -5;
    } else if (*ldb < n) {
        *info = -7;
    } else if (*ldbx < n) {
        *info = -9;
    } else if (*givptr < 0) {
        *info = -11;
    } else if (*ldgcol < n) {
        *info = -13;
    } else if (*ldgnum < n) {
        *info = -15;
    } else if (*k < 1) {
        *info = -20;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLALS0", &i__1);
        return 0;
    }

    m = n + *sqre;
    nlp1 = *nl + 1;

    if (*icompq == 0) {

/*
          Apply back orthogonal transformations from the left.

          Step (1L): apply back the Givens rotations performed.
*/

        i__1 = *givptr;
        for (i__ = 1; i__ <= i__1; ++i__) {
            srot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
                b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
                (givnum_dim1 << 1)], &givnum[i__ + givnum_dim1]);
/* L10: */
        }

/*        Step (2L): permute rows of B. */

        scopy_(nrhs, &b[nlp1 + b_dim1], ldb, &bx[bx_dim1 + 1], ldbx);
        i__1 = n;
        for (i__ = 2; i__ <= i__1; ++i__) {
            scopy_(nrhs, &b[perm[i__] + b_dim1], ldb, &bx[i__ + bx_dim1],
                ldbx);
/* L20: */
        }

/*
          Step (3L): apply the inverse of the left singular vector
          matrix to BX.
*/

        if (*k == 1) {
            scopy_(nrhs, &bx[bx_offset], ldbx, &b[b_offset], ldb);
            if (z__[1] < 0.f) {
                sscal_(nrhs, &c_b151, &b[b_offset], ldb);
            }

            }
        }
    }


注释结束。
    } else {
        // 计算每个极点对应的工作数组元素
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            diflj = difl[j];
            dj = poles[j + poles_dim1];
            dsigj = -poles[j + (poles_dim1 << 1)];
            // 如果不是最后一个极点，计算相关的右侧差分和下一个极点的负信号
            if (j < *k) {
                difrj = -difr[j + difr_dim1];
                dsigjp = -poles[j + 1 + (poles_dim1 << 1)];
            }
            // 如果当前极点或对应的信号为零，将工作数组元素设为零
            if (z__[j] == 0.f || poles[j + (poles_dim1 << 1)] == 0.f) {
                work[j] = 0.f;
            } else {
                // 计算当前工作数组元素的值
                work[j] = -poles[j + (poles_dim1 << 1)] * z__[j] / diflj /
                          (poles[j + (poles_dim1 << 1)] + dj);
            }
            // 计算其他极点对应的工作数组元素
            i__2 = j - 1;
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 如果当前极点或对应的信号为零，将工作数组元素设为零
                if (z__[i__] == 0.f || poles[i__ + (poles_dim1 << 1)] == 0.f) {
                    work[i__] = 0.f;
                } else {
                    // 计算当前工作数组元素的值
                    work[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__] /
                                (slamc3_(&poles[i__ + (poles_dim1 << 1)], &
                                dsigj) - diflj) / (poles[i__ + (poles_dim1 <<
                                1)] + dj);
                }
/* L30: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            if (z__[i__] == 0.f || poles[i__ + (poles_dim1 << 1)] ==
                0.f) {
            work[i__] = 0.f;
            } else {
            // 计算工作数组中的元素，用于右奇异向量矩阵的乘法操作
            work[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                / (slamc3_(&poles[i__ + (poles_dim1 << 1)], &
                dsigjp) + difrj) / (poles[i__ + (poles_dim1 <<
                 1)] + dj);
            }
/* L40: */
        }
        // 设置工作数组的第一个元素为-1
        work[1] = -1.f;
        // 计算工作数组的二范数
        temp = snrm2_(k, &work[1], &c__1);
        // 对矩阵 B 的一部分进行矩阵-向量乘法
        sgemv_("T", k, nrhs, &c_b15, &bx[bx_offset], ldbx, &work[1], &
            c__1, &c_b29, &b[j + b_dim1], ldb);
        // 将矩阵 B 的一部分按比例缩放
        slascl_("G", &c__0, &c__0, &temp, &c_b15, &c__1, nrhs, &b[j +
            b_dim1], ldb, info);
/* L50: */
        }
    }

/*        Move the deflated rows of BX to B also. */

    if (*k < max(m,n)) {
        // 将矩阵 BX 中被缩小的行移动到矩阵 B 中
        i__1 = n - *k;
        slacpy_("A", &i__1, nrhs, &bx[*k + 1 + bx_dim1], ldbx, &b[*k + 1
            + b_dim1], ldb);
    }
    } else {

/*
          Apply back the right orthogonal transformations.

          Step (1R): apply back the new right singular vector matrix
          to B.
*/

    if (*k == 1) {
        // 如果 k = 1，直接复制矩阵 B 的一部分到矩阵 BX 中
        scopy_(nrhs, &b[b_offset], ldb, &bx[bx_offset], ldbx);
    } else {
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
        dsigj = poles[j + (poles_dim1 << 1)];
        if (z__[j] == 0.f) {
            work[j] = 0.f;
        } else {
            // 计算工作数组中的元素，用于右奇异向量矩阵的乘法操作
            work[j] = -z__[j] / difl[j] / (dsigj + poles[j +
                poles_dim1]) / difr[j + (difr_dim1 << 1)];
        }
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            if (z__[j] == 0.f) {
            work[i__] = 0.f;
            } else {
            r__1 = -poles[i__ + 1 + (poles_dim1 << 1)];
            // 计算工作数组中的元素，用于右奇异向量矩阵的乘法操作
            work[i__] = z__[j] / (slamc3_(&dsigj, &r__1) - difr[
                i__ + difr_dim1]) / (dsigj + poles[i__ +
                poles_dim1]) / difr[i__ + (difr_dim1 << 1)];
            }
/* L60: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            if (z__[j] == 0.f) {
            work[i__] = 0.f;
            } else {
            r__1 = -poles[i__ + (poles_dim1 << 1)];
            // 计算工作数组中的元素，用于右奇异向量矩阵的乘法操作
            work[i__] = z__[j] / (slamc3_(&dsigj, &r__1) - difl[
                i__]) / (dsigj + poles[i__ + poles_dim1]) /
                difr[i__ + (difr_dim1 << 1)];
            }
/* L70: */
        }
        // 对矩阵 B 的一部分进行矩阵-向量乘法
        sgemv_("T", k, nrhs, &c_b15, &b[b_offset], ldb, &work[1], &
            c__1, &c_b29, &bx[j + bx_dim1], ldbx);
/* L80: */
        }
    }

/*
          Step (2R): if SQRE = 1, apply back the rotation that is
          related to the right null space of the subproblem.
*/

    if (*sqre == 1) {
        // 如果 SQRE = 1，将矩阵 B 的一部分复制到矩阵 BX 中，并应用旋转操作
        scopy_(nrhs, &b[m + b_dim1], ldb, &bx[m + bx_dim1], ldbx);
        srot_(nrhs, &bx[bx_dim1 + 1], ldbx, &bx[m + bx_dim1], ldbx, c__,
            s);
    }
    // 如果 k 指针所指的值小于 m 和 n 中的最大值时执行以下操作
    if (*k < max(m,n)) {
        // 计算数组 b 中复制的行数
        i__1 = n - *k;
        // 复制数组 b 中指定区域的数据到数组 bx 中相同位置
        slacpy_("A", &i__1, nrhs, &b[*k + 1 + b_dim1], ldb, &bx[*k + 1 + bx_dim1], ldbx);
    }
/*        Step (3R): permute rows of B. */
/* 步骤 (3R)：对 B 的行进行排列。 */

    scopy_(nrhs, &bx[bx_dim1 + 1], ldbx, &b[nlp1 + b_dim1], ldb);
    /* 复制 bx 的第一列到 b 的第 nlp1 列 */
    if (*sqre == 1) {
        scopy_(nrhs, &bx[m + bx_dim1], ldbx, &b[m + b_dim1], ldb);
        /* 如果 sqre 等于 1，复制 bx 的第 m 列到 b 的第 m 列 */
    }
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        scopy_(nrhs, &bx[i__ + bx_dim1], ldbx, &b[perm[i__] + b_dim1],
            ldb);
        /* 对于每个 i，复制 bx 的第 i 列到 b 的 perm[i] 列 */
/* L90: */
    }

/*        Step (4R): apply back the Givens rotations performed. */
/* 步骤 (4R): 应用之前执行的 Givens 旋转。 */

    for (i__ = *givptr; i__ >= 1; --i__) {
        r__1 = -givnum[i__ + givnum_dim1];
        srot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &r__1);
        /* 对每个 Givens 旋转，应用其逆操作到 b 的指定列 */
/* L100: */
    }
    }

    return 0;

/*     End of SLALS0 */

} /* slals0_ */

/* Subroutine */ int slalsa_(integer *icompq, integer *smlsiz, integer *n,
    integer *nrhs, real *b, integer *ldb, real *bx, integer *ldbx, real *
    u, integer *ldu, real *vt, integer *k, real *difl, real *difr, real *
    z__, real *poles, integer *givptr, integer *givcol, integer *ldgcol,
    integer *perm, real *givnum, real *c__, real *s, real *work, integer *
    iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, b_dim1,
        b_offset, bx_dim1, bx_offset, difl_dim1, difl_offset, difr_dim1,
        difr_offset, givnum_dim1, givnum_offset, poles_dim1, poles_offset,
         u_dim1, u_offset, vt_dim1, vt_offset, z_dim1, z_offset, i__1,
        i__2;

    /* Local variables */
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, nlvl, sqre, inode, ndiml;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer ndimr;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slals0_(integer *, integer *, integer *, integer *,
        integer *, real *, integer *, real *, integer *, integer *,
        integer *, integer *, integer *, real *, integer *, real *, real *
        , real *, real *, integer *, real *, real *, real *, integer *),
        xerbla_(char *, integer *), slasdt_(integer *, integer *,
        integer *, integer *, integer *, integer *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector
    # 根据ICOMPQ的值确定使用左奇异向量矩阵还是右奇异向量矩阵来操作
    # 如果ICOMPQ = 0，则应用左奇异向量矩阵到右侧；如果ICOMPQ = 1，则应用右奇异向量矩阵到右侧
    # 奇异向量矩阵是由SLALSA以紧凑形式生成的
    
    Arguments
    =========
    # 函数参数说明如下：
    
    ICOMPQ (input) INTEGER
           指定左奇异向量矩阵或右奇异向量矩阵的使用。
           = 0: 左奇异向量矩阵
           = 1: 右奇异向量矩阵
    
    SMLSIZ (input) INTEGER
           计算树底部子问题的最大尺寸。
    
    N      (input) INTEGER
           上三角双对角矩阵的行和列维度。
    
    NRHS   (input) INTEGER
           B和BX的列数。NRHS必须至少为1。
    
    B      (input/output) REAL array, dimension ( LDB, NRHS )
           输入时，B包含最小二乘问题的右手边，行范围从1到M。
           输出时，B包含解X，行范围从1到N。
    
    LDB    (input) INTEGER
           B在调用子程序中的主维度。LDB必须至少为max(1,MAX( M, N ) )。
    
    BX     (output) REAL array, dimension ( LDBX, NRHS )
           输出，应用左或右奇异向量矩阵到B后的结果。
    
    LDBX   (input) INTEGER
           BX的主维度。
    
    U      (input) REAL array, dimension ( LDU, SMLSIZ ).
           输入时，U包含所有底部子问题的左奇异向量矩阵。
    
    LDU    (input) INTEGER, LDU >= N.
           数组U, VT, DIFL, DIFR, POLES, GIVNUM, Z的主维度。
    
    VT     (input) REAL array, dimension ( LDU, SMLSIZ+1 ).
           输入时，VT'包含所有底部子问题的右奇异向量矩阵。
    
    K      (input) INTEGER array, dimension ( N ).
    
    DIFL   (input) REAL array, dimension ( LDU, NLVL ).
           其中NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1。
    
    DIFR   (input) REAL array, dimension ( LDU, 2 * NLVL ).
           输入时，DIFL(*, I) 和 DIFR(*, 2 * I -1) 记录第I级上奇异值与第(I -1)级奇异值之间的距离，
           DIFR(*, 2 * I) 记录第I级子问题右奇异向量矩阵的归一化因子。
    
    Z      (input) REAL array, dimension ( LDU, NLVL ).
           输入时，Z(1, I) 包含用于第I级子问题的调整后更新行向量的分量。
    
    POLES  (input) REAL array, dimension ( LDU, 2 * NLVL ).
           输入时，POLES(*, 2 * I -1: 2 * I) 包含第I级上涉及的新旧奇异值，这些奇异值参与I级上的世俗方程。
    # 输入参数的测试。

    GIVPTR (input) INTEGER array, dimension ( N ).
           On entry, GIVPTR( I ) records the number of Givens
           rotations performed on the I-th problem on the computation
           tree.

    GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
           On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
           locations of Givens rotations performed on the I-th level on
           the computation tree.

    LDGCOL (input) INTEGER, LDGCOL = > N.
           The leading dimension of arrays GIVCOL and PERM.

    PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
           On entry, PERM(*, I) records permutations done on the I-th
           level of the computation tree.

    GIVNUM (input) REAL array, dimension ( LDU, 2 * NLVL ).
           On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
           values of Givens rotations performed on the I-th level on the
           computation tree.

    C      (input) REAL array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           C( I ) contains the C-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    S      (input) REAL array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           S( I ) contains the S-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    WORK   (workspace) REAL array.
           The dimension must be at least N.

    IWORK  (workspace) INTEGER array.
           The dimension must be at least 3 * N

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    givnum_dim1 = *ldu;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    poles_dim1 = *ldu;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    z_dim1 = *ldu;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    difr_dim1 = *ldu;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    difl_dim1 = *ldu;
    difl_offset = 1 + difl_dim1;
    difl -= difl_offset;
    vt_dim1 = *ldu;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    --k;
    --givptr;
    perm_dim1 = *ldgcol;
    perm_offset = 1 + perm_dim1;
    perm -= perm_offset;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    --c__;
    --s;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;

    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*smlsiz < 3) {
        *info = -2;
    } else if (*n < *smlsiz) {
        *info = -3;
    } else if (*nrhs < 1) {
        *info = -4;
    } else if (*ldb < *n) {
        *info = -6;
    } else if (*ldbx < *n) {
        *info = -8;
    } else if (*ldu < *n) {
        *info = -10;
    } else if (*ldgcol < *n) {
        *info = -19;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLALSA", &i__1);
        return 0;
    }

/*     Book-keeping and  setting up the computation tree. */

    inode = 1;
    ndiml = inode + *n;
    ndimr = ndiml + *n;

    slasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
        smlsiz);

/*
       The following code applies back the left singular vector factors.
       For applying back the right singular vector factors, go to 50.
*/

    if (*icompq == 1) {
        goto L50;
    }

/*
       The nodes on the bottom level of the tree were solved
       by SLASDQ. The corresponding left and right singular vector
       matrices are in explicit form. First apply back the left
       singular vector matrices.
*/

    ndb1 = (nd + 1) / 2;
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
          IC : center row of each node
          NL : number of rows of left  subproblem
          NR : number of rows of right subproblem
          NLF: starting row of the left   subproblem
          NRF: starting row of the right  subproblem
*/

        i1 = i__ - 1;
        ic = iwork[inode + i1];
        nl = iwork[ndiml + i1];
        nr = iwork[ndimr + i1];
        nlf = ic - nl;
        nrf = ic + 1;
        sgemm_("T", "N", &nl, nrhs, &nl, &c_b15, &u[nlf + u_dim1], ldu, &b[
            nlf + b_dim1], ldb, &c_b29, &bx[nlf + bx_dim1], ldbx);
        sgemm_("T", "N", &nr, nrhs, &nr, &c_b15, &u[nrf + u_dim1], ldu, &b[
            nrf + b_dim1], ldb, &c_b29, &bx[nrf + bx_dim1], ldbx);
    }

/*
       Next copy the rows of B that correspond to unchanged rows
       in the bidiagonal matrix to BX.
*/

    i__1 = nd;
    # 循环遍历从 1 到 i__1 的整数序列，i__ 作为循环变量
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 从数组 iwork 中获取 inode + i__ - 1 索引处的值，存入变量 ic
        ic = iwork[inode + i__ - 1];
        # 调用外部函数 scopy_，复制长度为 nrhs 的数组 b 的一部分到数组 bx 的对应位置
        scopy_(nrhs, &b[ic + b_dim1], ldb, &bx[ic + bx_dim1], ldbx);
    }

/*
       Finally go through the left singular vector matrices of all
       the other subproblems bottom-up on the tree.
*/

    j = pow_ii(&c__2, &nlvl);
    sqre = 0;

    for (lvl = nlvl; lvl >= 1; --lvl) {
    lvl2 = (lvl << 1) - 1;

/*
          find the first node LF and last node LL on
          the current level LVL
*/

    if (lvl == 1) {
        lf = 1;  // 设置当前层级第一个节点 LF 为 1
        ll = 1;  // 设置当前层级最后一个节点 LL 为 1
    } else {
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);  // 计算 LF: 2^(lvl-1)
        ll = (lf << 1) - 1;  // 计算 LL: 2*LF - 1
    }
    i__1 = ll;
    for (i__ = lf; i__ <= i__1; ++i__) {
        im1 = i__ - 1;
        ic = iwork[inode + im1];  // 获取节点 IC 的索引
        nl = iwork[ndiml + im1];  // 获取节点 NL 的维度
        nr = iwork[ndimr + im1];  // 获取节点 NR 的维度
        nlf = ic - nl;  // 计算左边子树的维度范围
        nrf = ic + 1;   // 计算右边子树的维度范围
        --j;
        slals0_(icompq, &nl, &nr, &sqre, nrhs, &bx[nlf + bx_dim1], ldbx, &
            b[nlf + b_dim1], ldb, &perm[nlf + lvl * perm_dim1], &
            givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
            givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
             poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
            lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
            j], &s[j], &work[1], info);
/* L30: */
    }
/* L40: */
    }
    goto L90;

/*     ICOMPQ = 1: applying back the right singular vector factors. */

L50:

/*
       First now go through the right singular vector matrices of all
       the tree nodes top-down.
*/

    j = 0;
    i__1 = nlvl;
    for (lvl = 1; lvl <= i__1; ++lvl) {
    lvl2 = (lvl << 1) - 1;

/*
          Find the first node LF and last node LL on
          the current level LVL.
*/

    if (lvl == 1) {
        lf = 1;  // 设置当前层级第一个节点 LF 为 1
        ll = 1;  // 设置当前层级最后一个节点 LL 为 1
    } else {
        i__2 = lvl - 1;
        lf = pow_ii(&c__2, &i__2);  // 计算 LF: 2^(lvl-1)
        ll = (lf << 1) - 1;  // 计算 LL: 2*LF - 1
    }
    i__2 = lf;
    for (i__ = ll; i__ >= i__2; --i__) {
        im1 = i__ - 1;
        ic = iwork[inode + im1];  // 获取节点 IC 的索引
        nl = iwork[ndiml + im1];  // 获取节点 NL 的维度
        nr = iwork[ndimr + im1];  // 获取节点 NR 的维度
        nlf = ic - nl;  // 计算左边子树的维度范围
        nrf = ic + 1;   // 计算右边子树的维度范围
        if (i__ == ll) {
        sqre = 0;  // 如果是最后一个节点，设置 sqre 为 0
        } else {
        sqre = 1;  // 否则设置 sqre 为 1
        }
        ++j;
        slals0_(icompq, &nl, &nr, &sqre, nrhs, &b[nlf + b_dim1], ldb, &bx[
            nlf + bx_dim1], ldbx, &perm[nlf + lvl * perm_dim1], &
            givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
            givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
             poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
            lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
            j], &s[j], &work[1], info);
/* L60: */
    }
/* L70: */
    }

/*
       The nodes on the bottom level of the tree were solved
       by SLASDQ. The corresponding right singular vector
       matrices are in explicit form. Apply them back.
*/

    ndb1 = (nd + 1) / 2;  // 计算底层节点的起始索引
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {
    i1 = i__ - 1;
    ic = iwork[inode + i1];  // 获取节点 IC 的索引
    nl = iwork[ndiml + i1];  // 获取节点 NL 的维度
    nr = iwork[ndimr + i1];  // 获取节点 NR 的维度
    nlp1 = nl + 1;  // NL + 1
    // 检查 i__ 是否等于 nd，确定 nrp1 的赋值
    if (i__ == nd) {
        // 如果 i__ 等于 nd，则 nrp1 被赋值为 nr
        nrp1 = nr;
    } else {
        // 如果 i__ 不等于 nd，则 nrp1 被赋值为 nr + 1
        nrp1 = nr + 1;
    }
    // 计算 nlf 和 nrf 的值
    nlf = ic - nl;
    nrf = ic + 1;
    // 使用 BLAS 函数 sgemm_ 执行矩阵乘法运算
    sgemm_("T", "N", &nlp1, nrhs, &nlp1, &c_b15, &vt[nlf + vt_dim1], ldu,
           &b[nlf + b_dim1], ldb, &c_b29, &bx[nlf + bx_dim1], ldbx);
    // 继续使用 sgemm_ 执行另一组矩阵乘法运算
    sgemm_("T", "N", &nrp1, nrhs, &nrp1, &c_b15, &vt[nrf + vt_dim1], ldu,
           &b[nrf + b_dim1], ldb, &c_b29, &bx[nrf + bx_dim1], ldbx);
/* L80: */
    }

L90:

    return 0;

/*     End of SLALSA */

} /* slalsa_ */

/* Subroutine */ int slalsd_(char *uplo, integer *smlsiz, integer *n, integer
    *nrhs, real *d__, real *e, real *b, integer *ldb, real *rcond,
    integer *rank, real *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer c__, i__, j, k;
    static real r__;
    static integer s, u, z__;
    static real cs;
    static integer bx;
    static real sn;
    static integer st, vt, nm1, st1;
    static real eps;
    static integer iwk;
    static real tol;
    static integer difl, difr;
    static real rcnd;
    static integer perm, nsub, nlvl, sqre, bxst;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *), sgemm_(char *, char *, integer *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        , real *, real *, integer *);
    static integer poles, sizei, nsize;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    static integer nwork, icmpq1, icmpq2;
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int slasda_(integer *, integer *, integer *,
        integer *, real *, real *, real *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, integer *, integer *,
        integer *, real *, real *, real *, real *, integer *, integer *),
        xerbla_(char *, integer *), slalsa_(integer *, integer *,
        integer *, integer *, real *, integer *, real *, integer *, real *
        , integer *, real *, integer *, real *, real *, real *, real *,
        integer *, integer *, integer *, integer *, real *, real *, real *
        , real *, integer *, integer *), slascl_(char *, integer *,
        integer *, real *, real *, integer *, integer *, real *, integer *
        , integer *);
    static integer givcol;
    extern integer isamax_(integer *, real *, integer *);
    extern /* Subroutine */ int slasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, real *, real *, real *, integer *, real *
        , integer *, real *, integer *, real *, integer *),
        slacpy_(char *, integer *, integer *, real *, integer *, real *,
        integer *), slartg_(real *, real *, real *, real *, real *
        ), slaset_(char *, integer *, integer *, real *, real *, real *,
        integer *);
    static real orgnrm;
    static integer givnum;
    extern doublereal slanst_(char *, integer *, real *, real *);
    extern /* Subroutine */ int slasrt_(char *, integer *, real *, integer *);
    static integer givptr, smlszp;


/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======
    SLALSD computes the singular value decomposition (SVD) of a real upper
    bidiagonal matrix B using the implicit zero-shift QR method. The SVD
    computes the singular values and, optionally, the left and/or right
    singular vectors.

    Arguments
    =========
    UPLO    (input) CHARACTER*1
            Specifies whether the matrix B is upper or lower bidiagonal.
            = 'U': Upper bidiagonal
            = 'L': Lower bidiagonal

    SMLSIZ  (input) INTEGER
            The maximum size of the subproblems at the bottom of the
            computation tree.

    N       (input) INTEGER
            The dimension of the bidiagonal matrix B.

    NRHS    (input) INTEGER
            The number of right-hand sides, i.e., the number of columns
            of the matrix B.

    D       (input/output) REAL array, dimension (N)
            On entry, the diagonal elements of the bidiagonal matrix B.
            On exit, if INFO = 0, the singular values of B in decreasing
            order.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the off-diagonal elements of the bidiagonal matrix B.
            On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
            will contain the diagonal and superdiagonal elements of a
            bidiagonal matrix orthogonally equivalent to the one given
            as input.

    B       (input/output) REAL array, dimension (LDB,NRHS)
            On entry, contains the right-hand sides of the equations.
            On exit, B is overwritten with the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of B.

    RCOND   (output) REAL
            Reciprocal condition number of the matrix B after scaling by
            ZLACON.

    RANK    (output) INTEGER
            Number of nontrivial singular values.

    WORK    (workspace) REAL array, dimension (3*N*N + 2*M*N + N*NRHS +
                                           2*M*NRHS + NWORK)
            Workspace.

    IWORK   (workspace) INTEGER array, dimension (8*N)
            Workspace.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the algorithm did not converge; i
                 off-diagonal elements of E did not converge to zero.

    Further Details
    ===============
    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    =====================================================================

*/
    # SLALSD uses the singular value decomposition of A to solve the least
    # squares problem of finding X to minimize the Euclidean norm of each
    # column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
    # are N-by-NRHS. The solution X overwrites B.

    # The singular values of A smaller than RCOND times the largest
    # singular value are treated as zero in solving the least squares
    # problem; in this case a minimum norm solution is returned.
    # The actual singular values are returned in D in ascending order.

    # This code makes very mild assumptions about floating point
    # arithmetic. It will work on machines with a guard digit in
    # add/subtract, or on those binary machines without guard digits
    # which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    # It could conceivably fail on hexadecimal or decimal machines
    # without guard digits, but we know of none.

    # Arguments
    # =========

    # UPLO   (input) CHARACTER*1
    #        = 'U': D and E define an upper bidiagonal matrix.
    #        = 'L': D and E define a  lower bidiagonal matrix.

    # SMLSIZ (input) INTEGER
    #        The maximum size of the subproblems at the bottom of the
    #        computation tree.

    # N      (input) INTEGER
    #        The dimension of the  bidiagonal matrix.  N >= 0.

    # NRHS   (input) INTEGER
    #        The number of columns of B. NRHS must be at least 1.

    # D      (input/output) REAL array, dimension (N)
    #        On entry D contains the main diagonal of the bidiagonal
    #        matrix. On exit, if INFO = 0, D contains its singular values.

    # E      (input/output) REAL array, dimension (N-1)
    #        Contains the super-diagonal entries of the bidiagonal matrix.
    #        On exit, E has been destroyed.

    # B      (input/output) REAL array, dimension (LDB,NRHS)
    #        On input, B contains the right hand sides of the least
    #        squares problem. On output, B contains the solution X.

    # LDB    (input) INTEGER
    #        The leading dimension of B in the calling subprogram.
    #        LDB must be at least max(1,N).

    # RCOND  (input) REAL
    #        The singular values of A less than or equal to RCOND times
    #        the largest singular value are treated as zero in solving
    #        the least squares problem. If RCOND is negative,
    #        machine precision is used instead.
    #        For example, if diag(S)*X=B were the least squares problem,
    #        where diag(S) is a diagonal matrix of singular values, the
    #        solution would be X(i) = B(i) / S(i) if S(i) is greater than
    #        RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
    #        RCOND*max(S).

    # RANK   (output) INTEGER
    #        The number of singular values of A greater than RCOND times
    #        the largest singular value.

    # WORK   (workspace) REAL array, dimension at least
    #        (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),
    #        where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).
    IWORK  (workspace) INTEGER array, dimension at least
           (3*N*NLVL + 11*N)

# 定义整型数组 IWORK 作为工作空间，其维度至少为 (3*N*NLVL + 11*N)，用于算法运算时暂存数据。


    INFO   (output) INTEGER
           = 0:  successful exit.
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  The algorithm failed to compute a singular value while
                 working on the submatrix lying in rows and columns
                 INFO/(N+1) through MOD(INFO,N+1).

# 输出整型 INFO 表示函数的退出状态：
# - 当 INFO = 0 时，表示成功退出。
# - 当 INFO < 0 时，表示第 i 个参数具有非法值。
# - 当 INFO > 0 时，表示算法在处理子矩阵时未能计算出奇异值，相关子矩阵位于行和列 INFO/(N+1) 到 MOD(INFO,N+1) 之间。


    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

# 进一步细节说明：
# 基于以下贡献者的贡献：
# - Ming Gu 和 Ren-Cang Li，加州大学伯克利分校计算机科学系，美国
# - Osni Marques，劳伦斯伯克利国家实验室/国家能源研究科学计算中心，美国


    =====================================================================


       Test the input parameters.

# 测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;              // 调整参数 d__ 数组，表示 d__ 是一个一维数组，每次递减一个元素
    --e;                // 调整参数 e 数组，表示 e 是一个一维数组，每次递减一个元素
    b_dim1 = *ldb;      // b_dim1 是 b 的第一维的大小，即列数
    b_offset = 1 + b_dim1;  // b_offset 是 b 数组的偏移量
    b -= b_offset;      // 调整 b 数组的起始位置
    --work;             // 调整参数 work 数组，表示 work 是一个一维数组，每次递减一个元素
    --iwork;            // 调整参数 iwork 数组，表示 iwork 是一个一维数组，每次递减一个元素

    /* Function Body */
    *info = 0;          // 初始化 info 参数为 0

    if (*n < 0) {       // 如果 n 小于 0
        *info = -3;     // 设置 info 为 -3，表示参数错误
    } else if (*nrhs < 1) {  // 如果 nrhs 小于 1
        *info = -4;     // 设置 info 为 -4，表示参数错误
    } else if (*ldb < 1 || *ldb < *n) {  // 如果 ldb 小于 1 或 ldb 小于 n
        *info = -8;     // 设置 info 为 -8，表示参数错误
    }
    if (*info != 0) {   // 如果 info 不为 0
        i__1 = -(*info);    // 计算 -info
        xerbla_("SLALSD", &i__1);  // 调用错误处理例程 xerbla_
        return 0;       // 返回 0
    }

    eps = slamch_("Epsilon");   // 获取机器精度 epsilon

/*     Set up the tolerance. */

    if (*rcond <= 0.f || *rcond >= 1.f) {   // 如果 rcond 小于等于 0 或大于等于 1
        rcnd = eps;     // 设置 rcnd 为 epsilon
    } else {
        rcnd = *rcond;  // 否则设置 rcnd 为 rcond 的值
    }

    *rank = 0;          // 初始化 rank 为 0

/*     Quick return if possible. */

    if (*n == 0) {      // 如果 n 等于 0
        return 0;       // 直接返回 0
    } else if (*n == 1) {   // 如果 n 等于 1
        if (d__[1] == 0.f) {    // 如果 d__ 的第一个元素等于 0
            slaset_("A", &c__1, nrhs, &c_b29, &c_b29, &b[b_offset], ldb);   // 设置 b 为零矩阵
        } else {
            *rank = 1;  // 设置 rank 为 1
            slascl_("G", &c__0, &c__0, &d__[1], &c_b15, &c__1, nrhs, &b[
                b_offset], ldb, info);   // 调用矩阵缩放函数 slascl_
            d__[1] = dabs(d__[1]);  // 计算 d__ 的第一个元素的绝对值
        }
        return 0;       // 返回 0
    }

/*     Rotate the matrix if it is lower bidiagonal. */

    if (*(unsigned char *)uplo == 'L') {   // 如果 uplo 的第一个字符是 'L'
        i__1 = *n - 1;  // 计算循环次数
        for (i__ = 1; i__ <= i__1; ++i__) { // 循环处理每一列
            slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);  // 计算 Givens 旋转参数
            d__[i__] = r__;     // 更新 d__ 的第 i__ 个元素
            e[i__] = sn * d__[i__ + 1]; // 更新 e 的第 i__ 个元素
            d__[i__ + 1] = cs * d__[i__ + 1];   // 更新 d__ 的第 i__+1 个元素
            if (*nrhs == 1) {   // 如果 nrhs 等于 1
                srot_(&c__1, &b[i__ + b_dim1], &c__1, &b[i__ + 1 + b_dim1], &
                    c__1, &cs, &sn);    // 对 b 的列进行旋转
            } else {
                work[(i__ << 1) - 1] = cs;  // 设置 work 的值
                work[i__ * 2] = sn; // 设置 work 的值
            }
/* L10: */
        }
        if (*nrhs > 1) {    // 如果 nrhs 大于 1
            i__1 = *nrhs;   // 循环次数
            for (i__ = 1; i__ <= i__1; ++i__) { // 循环处理每一个 rhs
                i__2 = *n - 1;  // 计算循环次数
                for (j = 1; j <= i__2; ++j) {   // 循环处理每一列
                    cs = work[(j << 1) - 1];    // 获取 work 的值
                    sn = work[j * 2];   // 获取 work 的值
                    srot_(&c__1, &b[j + i__ * b_dim1], &c__1, &b[j + 1 + i__ *
                         b_dim1], &c__1, &cs, &sn);  // 对 b 的列进行旋转
/* L20: */
                }
/* L30: */
            }
        }
    }

/*     Scale. */

    nm1 = *n - 1;   // 计算 n-1
    orgnrm = slanst_("M", n, &d__[1], &e[1]);  // 计算矩阵的范数
    if (orgnrm == 0.f) {    // 如果矩阵范数为 0
        slaset_("A", n, nrhs, &c_b29, &c_b29, &b[b_offset], ldb);   // 设置 b 为零矩阵
        return 0;   // 返回 0
    }

    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, &c__1, &d__[1], n, info); // 缩放 d__
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &nm1, &c__1, &e[1], &nm1,
        info);  // 缩放 e

/*
       If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver.
*/

    if (*n <= *smlsiz) {    // 如果 n 小于等于 smlsiz
        nwork = *n * *n + 1;    // 计算 nwork
        slaset_("A", n, n, &c_b29, &c_b15, &work[1], n);    // 设置 work 为特定值
        slasdq_("U", &c__0, n, n, &c__0, nrhs, &d__[1], &e[1], &work[1], n, &
            work[1], n, &b[b_offset], ldb, &work[nwork], info); // 调用另一个求解器
        if (*info != 0) {   // 如果求解过程中出现错误
            return 0;   // 返回 0
        }
        tol = rcnd * (r__1 = d__[isamax_(n, &d__[1], &c__1)], dabs(r__1)); // 计算容差值
        i__1 = *n;  // 设置循环次数
    // 循环遍历索引 i__，从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 如果 d__[i__] 小于等于 tol
        if (d__[i__] <= tol) {
            // 调用 slaset_ 函数，将 b[i__ + b_dim1] 的元素设置为 0
            slaset_("A", &c__1, nrhs, &c_b29, &c_b29, &b[i__ + b_dim1], ldb);
        } else {
            // 如果 d__[i__] 大于 tol，则调用 slascl_ 函数
            // 将 b[i__ + b_dim1] 中的元素按比例缩放
            slascl_("G", &c__0, &c__0, &d__[i__], &c_b15, &c__1, nrhs, &b[i__ + b_dim1], ldb, info);
            // 增加 rank 的值
            ++(*rank);
        }
    }
    }
    // 调用 BLAS 函数 sgemm 进行矩阵乘法运算
    sgemm_("T", "N", n, nrhs, n, &c_b15, &work[1], n, &b[b_offset], ldb, &
        c_b29, &work[nwork], n);
    // 将 work 数组中的部分复制到 b 数组中
    slacpy_("A", n, nrhs, &work[nwork], n, &b[b_offset], ldb);

/*        Unscale. */

    // 对 d 数组进行缩放操作
    slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n,
        info);
    // 对 d 数组进行排序
    slasrt_("D", n, &d__[1], info);
    // 对 b 数组进行缩放操作
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, nrhs, &b[b_offset],
        ldb, info);

    return 0;
    }

/*     Book-keeping and setting up some constants. */

    // 计算 nlvl 的值
    nlvl = (integer) (log((real) (*n) / (real) (*smlsiz + 1)) / log(2.f)) + 1;

    // 设置 smlszp 的值
    smlszp = *smlsiz + 1;

    // 设置一些索引值和常数
    u = 1;
    vt = *smlsiz * *n + 1;
    difl = vt + smlszp * *n;
    difr = difl + nlvl * *n;
    z__ = difr + (nlvl * *n << 1);
    c__ = z__ + nlvl * *n;
    s = c__ + *n;
    poles = s + *n;
    givnum = poles + (nlvl << 1) * *n;
    bx = givnum + (nlvl << 1) * *n;
    nwork = bx + *n * *nrhs;

    sizei = *n + 1;
    k = sizei + *n;
    givptr = k + *n;
    perm = givptr + *n;
    givcol = perm + nlvl * *n;
    iwk = givcol + (nlvl * *n << 1);

    // 初始化一些变量
    st = 1;
    sqre = 0;
    icmpq1 = 1;
    icmpq2 = 0;
    nsub = 0;

    // 对 d 数组进行修正，确保其绝对值大于等于 eps
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    if ((r__1 = d__[i__], dabs(r__1)) < eps) {
        d__[i__] = r_sign(&eps, &d__[i__]);
    }
/* L50: */
    }

    // 遍历 e 数组，确定子问题的边界并处理
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    if ((r__1 = e[i__], dabs(r__1)) < eps || i__ == nm1) {
        ++nsub;
        iwork[nsub] = st;

/*
             Subproblem found. First determine its size and then
             apply divide and conquer on it.
*/

        if (i__ < nm1) {

/*              A subproblem with E(I) small for I < NM1. */

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else if ((r__1 = e[i__], dabs(r__1)) >= eps) {

/*              A subproblem with E(NM1) not too small but I = NM1. */

        nsize = *n - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else {

/*
                A subproblem with E(NM1) small. This implies an
                1-by-1 subproblem at D(N), which is not solved
                explicitly.
*/

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        ++nsub;
        iwork[nsub] = *n;
        iwork[sizei + nsub - 1] = 1;
        scopy_(nrhs, &b[*n + b_dim1], ldb, &work[bx + nm1], n);
        }
        st1 = st - 1;
        if (nsize == 1) {

/*
                This is a 1-by-1 subproblem and is not solved
                explicitly.
*/

        scopy_(nrhs, &b[st + b_dim1], ldb, &work[bx + st1], n);
        } else if (nsize <= *smlsiz) {
/*
   This section handles different scenarios in solving a singular value problem.
*/

        slaset_("A", &nsize, &nsize, &c_b29, &c_b15, &work[vt + st1],
            n);
        // Initialize a matrix portion to specified values

        slasdq_("U", &c__0, &nsize, &nsize, &c__0, nrhs, &d__[st], &e[
            st], &work[vt + st1], n, &work[nwork], n, &b[st +
            b_dim1], ldb, &work[nwork], info);
        // Compute singular values and update vectors using a QR decomposition

        if (*info != 0) {
            return 0;
        }
        // Check for errors and exit if encountered

        slacpy_("A", &nsize, nrhs, &b[st + b_dim1], ldb, &work[bx +
            st1], n);
        // Copy matrix data between arrays

        } else {

/*
              A large problem. Solve it using divide and conquer.
*/

        slasda_(&icmpq1, smlsiz, &nsize, &sqre, &d__[st], &e[st], &
            work[u + st1], n, &work[vt + st1], &iwork[k + st1], &
            work[difl + st1], &work[difr + st1], &work[z__ + st1],
             &work[poles + st1], &iwork[givptr + st1], &iwork[
            givcol + st1], n, &iwork[perm + st1], &work[givnum +
            st1], &work[c__ + st1], &work[s + st1], &work[nwork],
            &iwork[iwk], info);
        // Compute singular values for a large problem using divide and conquer

        if (*info != 0) {
            return 0;
        }
        // Check for errors and exit if encountered

        bxst = bx + st1;
        slalsa_(&icmpq2, smlsiz, &nsize, nrhs, &b[st + b_dim1], ldb, &
            work[bxst], n, &work[u + st1], n, &work[vt + st1], &
            iwork[k + st1], &work[difl + st1], &work[difr + st1],
            &work[z__ + st1], &work[poles + st1], &iwork[givptr +
            st1], &iwork[givcol + st1], n, &iwork[perm + st1], &
            work[givnum + st1], &work[c__ + st1], &work[s + st1],
            &work[nwork], &iwork[iwk], info);
        // Compute singular values and vectors for a large problem using divide and conquer

        if (*info != 0) {
            return 0;
        }
        // Check for errors and exit if encountered
        }
        st = i__ + 1;
    }
/* L60: */
    }

/*     Apply the singular values and treat the tiny ones as zero. */

    tol = rcnd * (r__1 = d__[isamax_(n, &d__[1], &c__1)], dabs(r__1));
    // Compute a tolerance based on condition number and largest singular value

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*
          Some of the elements in D can be negative because 1-by-1
          subproblems were not solved explicitly.
*/

    if ((r__1 = d__[i__], dabs(r__1)) <= tol) {
        slaset_("A", &c__1, nrhs, &c_b29, &c_b29, &work[bx + i__ - 1], n);
        // Set matrix elements to specified values if singular value is small

    } else {
        ++(*rank);
        slascl_("G", &c__0, &c__0, &d__[i__], &c_b15, &c__1, nrhs, &work[
            bx + i__ - 1], n, info);
        // Scale matrix elements based on singular value if it's sufficiently large
    }
    d__[i__] = (r__1 = d__[i__], dabs(r__1));
/* L70: */
    }

/*     Now apply back the right singular vectors. */

    icmpq2 = 1;
    i__1 = nsub;
    for (i__ = 1; i__ <= i__1; ++i__) {
    st = iwork[i__];
    st1 = st - 1;
    nsize = iwork[sizei + i__ - 1];
    bxst = bx + st1;
    if (nsize == 1) {
        scopy_(nrhs, &work[bxst], n, &b[st + b_dim1], ldb);
        // Copy vector elements if the size is 1

    } else if (nsize <= *smlsiz) {
        sgemm_("T", "N", &nsize, nrhs, &nsize, &c_b15, &work[vt + st1], n,
             &work[bxst], n, &c_b29, &b[st + b_dim1], ldb);
        // Perform matrix multiplication if size is less than or equal to small size threshold
    } else {
        slalsa_(&icmpq2, smlsiz, &nsize, nrhs, &work[bxst], n, &b[st +
            b_dim1], ldb, &work[u + st1], n, &work[vt + st1], &iwork[
            k + st1], &work[difl + st1], &work[difr + st1], &work[z__
            + st1], &work[poles + st1], &iwork[givptr + st1], &iwork[
            givcol + st1], n, &iwork[perm + st1], &work[givnum + st1],
             &work[c__ + st1], &work[s + st1], &work[nwork], &iwork[
            iwk], info);
        // 调用 slalsa_ 函数执行某种算法，解决线性方程组或最小二乘问题
        if (*info != 0) {
        // 如果 slalsa_ 函数返回错误信息，则返回 0
        return 0;
        }
    }
/* L80: */
    }

/*     Unscale and sort the singular values. */

    // 调用 LAPACK 的 slascl 子例程，对奇异值进行非线性伸缩
    slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n, info);
    // 调用 LAPACK 的 slasrt 子例程，对奇异值进行排序
    slasrt_("D", n, &d__[1], info);
    // 调用 LAPACK 的 slascl 子例程，对右手边的矩阵进行非线性伸缩
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, nrhs, &b[b_offset], ldb,
        info);

    // 返回 0 表示函数执行成功
    return 0;

/*     End of SLALSD */

} /* slalsd_ */

/* Subroutine */ int slamrg_(integer *n1, integer *n2, real *a, integer *
    strd1, integer *strd2, integer *index)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, ind1, ind2, n1sv, n2sv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAMRG will create a permutation list which will merge the elements
    of A (which is composed of two independently sorted sets) into a
    single set which is sorted in ascending order.

    Arguments
    =========

    N1     (input) INTEGER
    N2     (input) INTEGER
           These arguments contain the respective lengths of the two
           sorted lists to be merged.

    A      (input) REAL array, dimension (N1+N2)
           The first N1 elements of A contain a list of numbers which
           are sorted in either ascending or descending order.  Likewise
           for the final N2 elements.

    STRD1  (input) INTEGER
    STRD2  (input) INTEGER
           These are the strides to be taken through the array A.
           Allowable strides are 1 and -1.  They indicate whether a
           subset of A is sorted in ascending (STRDx = 1) or descending
           (STRDx = -1) order.

    INDEX  (output) INTEGER array, dimension (N1+N2)
           On exit this array will contain a permutation such that
           if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
           sorted in ascending order.

    =====================================================================
*/


    /* Parameter adjustments */
    --index;
    --a;

    /* Function Body */
    // 备份输入的 n1 和 n2 到本地变量 n1sv 和 n2sv
    n1sv = *n1;
    n2sv = *n2;
    // 根据 STRD1 和 STRD2 的正负值确定起始索引 ind1 和 ind2
    if (*strd1 > 0) {
    ind1 = 1;
    } else {
    ind1 = *n1;
    }
    if (*strd2 > 0) {
    ind2 = *n1 + 1;
    } else {
    ind2 = *n1 + *n2;
    }
    // 初始化循环索引 i
    i__ = 1;
/*     while ( (N1SV > 0) & (N2SV > 0) ) */
L10:
    // 当仍有元素需要合并时继续执行循环
    if (n1sv > 0 && n2sv > 0) {
    // 比较两个集合的当前元素，选择较小（或较大）的放入排序后的数组中
    if (a[ind1] <= a[ind2]) {
        index[i__] = ind1;
        ++i__;
        ind1 += *strd1;
        --n1sv;
    } else {
        index[i__] = ind2;
        ++i__;
        ind2 += *strd2;
        --n2sv;
    }
    // 继续合并直到一个集合的元素全部处理完
    goto L10;
    }
/*     end while */
    // 处理剩余未合并的元素
    if (n1sv == 0) {
    // 如果第一个集合已经处理完，则直接将第二个集合剩余元素加入结果集合中
    i__1 = n2sv;
    for (n1sv = 1; n1sv <= i__1; ++n1sv) {
        index[i__] = ind2;
        ++i__;
        ind2 += *strd2;
/* L20: */
    }
    } else {
/*     N2SV .EQ. 0 */
    // 如果第二个集合已经处理完，则直接将第一个集合剩余元素加入结果集合中
    i__1 = n1sv;
    for (n2sv = 1; n2sv <= i__1; ++n2sv) {
        index[i__] = ind1;
        ++i__;
        ind1 += *strd1;
/* L30: */
    }
    }
    return 0;


注释：


    # 返回整数值 0
    return 0;
/*
    End of SLAMRG
*/

} /* slamrg_ */

/* 计算矩阵的一范数、Frobenius范数、无穷范数或最大绝对值元素的值 */
doublereal slange_(char *norm, integer *m, integer *n, real *a, integer *lda,
    real *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    real ret_val, r__1, r__2, r__3;

    /* Local variables */
    static integer i__, j;
    static real sum, scale;
    extern logical lsame_(char *, char *);
    static real value;
    extern /* Subroutine */ int slassq_(integer *, real *, integer *, real *,
        real *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
        November 2006

        Purpose
        =======

        SLANGE  returns the value of the one norm,  or the Frobenius norm, or
        the  infinity norm,  or the  element of  largest absolute value  of a
        real matrix A.

        Description
        ===========

        SLANGE returns the value

           SLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                    (
                    ( norm1(A),         NORM = '1', 'O' or 'o'
                    (
                    ( normI(A),         NORM = 'I' or 'i'
                    (
                    ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

        where  norm1  denotes the  one norm of a matrix (maximum column sum),
        normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
        normF  denotes the  Frobenius norm of a matrix (square root of sum of
        squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

        Arguments
        =========

        NORM    (input) CHARACTER*1
                Specifies the value to be returned in SLANGE as described
                above.

        M       (input) INTEGER
                The number of rows of the matrix A.  M >= 0.  When M = 0,
                SLANGE is set to zero.

        N       (input) INTEGER
                The number of columns of the matrix A.  N >= 0.  When N = 0,
                SLANGE is set to zero.

        A       (input) REAL array, dimension (LDA,N)
                The m by n matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A.  LDA >= max(M,1).

        WORK    (workspace) REAL array, dimension (MAX(1,LWORK)),
                where LWORK >= M when NORM = 'I'; otherwise, WORK is not
                referenced.

       =====================================================================
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (min(*m,*n) == 0) {
        value = 0.f;
    } else if (lsame_(norm, "M")) {

        /* 计算 max(abs(A(i,j))) */
        value = 0.f;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* 计算 MAX */
                r__2 = value;
                r__3 = (r__1 = a[i__ + j * a_dim1], dabs(r__1));
                value = dmax(r__2,r__3);
                /* L10: */
            }
            /* L20: */
        }
    }
    } else if (lsame_(norm, "O") || *(unsigned char *)
        norm == '1') {



    # 如果字符串 norm 的内容与 "O" 相同（不区分大小写），或者 norm 的第一个字符是 '1'
    # 则执行以下操作
/*        Find norm1(A). */

value = 0.f;  // 初始化值为0，用于存储矩阵的一范数
i__1 = *n;  // 循环的上限是*n（矩阵的列数）
for (j = 1; j <= i__1; ++j) {
    sum = 0.f;  // 初始化每列的和为0
    i__2 = *m;  // 循环的上限是*m（矩阵的行数）
    for (i__ = 1; i__ <= i__2; ++i__) {
        sum += (r__1 = a[i__ + j * a_dim1], dabs(r__1));  // 求每列的绝对值和
        /* L30: */
    }
    value = dmax(value,sum);  // 更新矩阵的一范数
    /* L40: */
}
} else if (lsame_(norm, "I")) {

/*        Find normI(A). */

i__1 = *m;  // 循环的上限是*m（矩阵的行数）
for (i__ = 1; i__ <= i__1; ++i__) {
    work[i__] = 0.f;  // 初始化每行的和为0
    /* L50: */
}
i__1 = *n;  // 循环的上限是*n（矩阵的列数）
for (j = 1; j <= i__1; ++j) {
    i__2 = *m;  // 循环的上限是*m（矩阵的行数）
    for (i__ = 1; i__ <= i__2; ++i__) {
        work[i__] += (r__1 = a[i__ + j * a_dim1], dabs(r__1));  // 求每行的绝对值和
        /* L60: */
    }
    /* L70: */
}
value = 0.f;  // 初始化值为0，用于存储矩阵的无穷范数
i__1 = *m;  // 循环的上限是*m（矩阵的行数）
for (i__ = 1; i__ <= i__1; ++i__) {
    /* Computing MAX */
    r__1 = value, r__2 = work[i__];
    value = dmax(r__1,r__2);  // 更新矩阵的无穷范数
    /* L80: */
}
} else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

scale = 0.f;  // 初始化缩放因子为0
sum = 1.f;  // 初始化和为1
i__1 = *n;  // 循环的上限是*n（矩阵的列数）
for (j = 1; j <= i__1; ++j) {
    slassq_(m, &a[j * a_dim1 + 1], &c__1, &scale, &sum);  // 调用子例程计算Frobenius范数的中间量
    /* L90: */
}
value = scale * sqrt(sum);  // 计算Frobenius范数
}

ret_val = value;  // 将计算得到的范数值赋给返回值
return ret_val;

/*     End of SLANGE */

} /* slange_ */
    # N 是输入参数，表示矩阵 A 的阶数，必须满足 N >= 0。当 N = 0 时，SLANST 被设为零。
    N       (input) INTEGER

    # D 是输入参数，是矩阵 A 的对角线元素的数组。
    D       (input) REAL array, dimension (N)

    # E 是输入参数，是矩阵 A 的次对角线（超对角线）或者副对角线元素的数组，长度为 N-1。
    E       (input) REAL array, dimension (N-1)
/* Parameter adjustments */
--e;
--d__;

/* Function Body */
if (*n <= 0) {
anorm = 0.f;
} else if (lsame_(norm, "M")) {

/*        Find max(abs(A(i,j))). */

anorm = (r__1 = d__[*n], dabs(r__1));
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
    r__2 = anorm, r__3 = (r__1 = d__[i__], dabs(r__1));
    anorm = dmax(r__2,r__3);
/* Computing MAX */
    r__2 = anorm, r__3 = (r__1 = e[i__], dabs(r__1));
    anorm = dmax(r__2,r__3);
/* L10: */
}
} else if (lsame_(norm, "O") || *(unsigned char *)
    norm == '1' || lsame_(norm, "I")) {

/*        Find norm1(A). */

if (*n == 1) {
    anorm = dabs(d__[1]);
} else {
/* Computing MAX */
    r__3 = dabs(d__[1]) + dabs(e[1]), r__4 = (r__1 = e[*n - 1], dabs(
        r__1)) + (r__2 = d__[*n], dabs(r__2));
    anorm = dmax(r__3,r__4);
    i__1 = *n - 1;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing MAX */
    r__4 = anorm, r__5 = (r__1 = d__[i__], dabs(r__1)) + (r__2 =
        e[i__], dabs(r__2)) + (r__3 = e[i__ - 1], dabs(r__3));
    anorm = dmax(r__4,r__5);
/* L20: */
    }
}
} else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

scale = 0.f;
sum = 1.f;
if (*n > 1) {
    i__1 = *n - 1;
    slassq_(&i__1, &e[1], &c__1, &scale, &sum);
    sum *= 2;
}
slassq_(n, &d__[1], &c__1, &scale, &sum);
anorm = scale * sqrt(sum);
}

ret_val = anorm;
return ret_val;

/*     End of SLANST */

} /* slanst_ */

doublereal slansy_(char *norm, char *uplo, integer *n, real *a, integer *lda,
real *work)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2;
real ret_val, r__1, r__2, r__3;

/* Local variables */
static integer i__, j;
static real sum, absa, scale;
extern logical lsame_(char *, char *);
static real value;
extern /* Subroutine */ int slassq_(integer *, real *, integer *, real *,
    real *);

/*
-- LAPACK auxiliary routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006

Purpose
=======

SLANSY  returns the value of the one norm,  or the Frobenius norm, or
the  infinity norm,  or the  element of  largest absolute value  of a
real symmetric matrix A.

Description
===========

SLANSY returns the value

SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
            (
            ( norm1(A),         NORM = '1', 'O' or 'o'
            (
            ( normI(A),         NORM = 'I' or 'i'
            (
            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

where  norm1  denotes the  one norm of a matrix (maximum column sum),
normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    # normF  denotes the  Frobenius norm of a matrix (square root of sum of
    # squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

    # Arguments
    # =========

    # NORM    (input) CHARACTER*1
    #         Specifies the value to be returned in SLANSY as described
    #         above.

    # UPLO    (input) CHARACTER*1
    #         Specifies whether the upper or lower triangular part of the
    #         symmetric matrix A is to be referenced.
    #         = 'U':  Upper triangular part of A is referenced
    #         = 'L':  Lower triangular part of A is referenced

    # N       (input) INTEGER
    #         The order of the matrix A.  N >= 0.  When N = 0, SLANSY is
    #         set to zero.

    # A       (input) REAL array, dimension (LDA,N)
    #         The symmetric matrix A.  If UPLO = 'U', the leading n by n
    #         upper triangular part of A contains the upper triangular part
    #         of the matrix A, and the strictly lower triangular part of A
    #         is not referenced.  If UPLO = 'L', the leading n by n lower
    #         triangular part of A contains the lower triangular part of
    #         the matrix A, and the strictly upper triangular part of A is
    #         not referenced.

    # LDA     (input) INTEGER
    #         The leading dimension of the array A.  LDA >= max(N,1).

    # WORK    (workspace) REAL array, dimension (MAX(1,LWORK)),
    #         where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
    #         WORK is not referenced.

   # =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
        value = 0.f;
    } else if (lsame_(norm, "M")) {

        /* Find max(abs(A(i,j))). */

        value = 0.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    r__2 = value, r__3 = (r__1 = a[i__ + j * a_dim1], dabs(
                        r__1));
                    value = dmax(r__2,r__3);
                    /* L10: */
                }
                /* L20: */
            }
        } else {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n;
                for (i__ = j; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    r__2 = value, r__3 = (r__1 = a[i__ + j * a_dim1], dabs(
                        r__1));
                    value = dmax(r__2,r__3);
                    /* L30: */
                }
                /* L40: */
            }
        }
    } else if (lsame_(norm, "I") || lsame_(norm, "O") || *(unsigned char *)norm == '1') {

        /* Find normI(A) ( = norm1(A), since A is symmetric). */

        value = 0.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = 0.f;
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    absa = (r__1 = a[i__ + j * a_dim1], dabs(r__1));
                    sum += absa;
                    work[i__] += absa;
                    /* L50: */
                }
                work[j] = sum + (r__1 = a[j + j * a_dim1], dabs(r__1));
                /* L60: */
            }
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                /* Computing MAX */
                r__1 = value, r__2 = work[i__];
                value = dmax(r__1,r__2);
                /* L70: */
            }
        } else {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                work[i__] = 0.f;
                /* L80: */
            }
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = work[j] + (r__1 = a[j + j * a_dim1], dabs(r__1));
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    absa = (r__1 = a[i__ + j * a_dim1], dabs(r__1));
                    sum += absa;
                    work[i__] += absa;
                    /* L90: */
                }
                value = dmax(value,sum);
                /* L100: */
            }
        }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

        /* Find normF(A). */

        scale = 0.f;
        sum = 1.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 2; j <= i__1; ++j) {
                i__2 = j - 1;
                slassq_(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
                /* L110: */
            }
        } else {
            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                slassq_(&i__2, &a[j + 1 + j * a_dim1], &c__1, &scale, &sum);
                /* L120: */
            }
        }
        sum *= 2;
        i__1 = *lda + 1;
        slassq_(n, &a[a_offset], &i__1, &scale, &sum);
        value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

    /* End of SLANSY */

} /* slansy_ */

/* Subroutine */ int slanv2_(real *a, real *b, real *c__, real *d__, real *


注释：
    rt1r, real *rt1i, real *rt2r, real *rt2i, real *cs, real *sn)


    rt1r,         // 实数指针，存储第一个实根的实部
    real *rt1i,   // 实数指针，存储第一个实根的虚部
    real *rt2r,   // 实数指针，存储第二个实根的实部
    real *rt2i,   // 实数指针，存储第二个实根的虚部
    real *cs,     // 实数指针，用于输出余弦值的地址
    real *sn)     // 实数指针，用于输出正弦值的地址
    /* System generated locals */
    real r__1, r__2;

    /* Local variables */
    static real p, z__, aa, bb, cc, dd, cs1, sn1, sab, sac, eps, tau, temp,
        scale, bcmax, bcmis, sigma;
    extern doublereal slapy2_(real *, real *), slamch_(char *);

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
    matrix in standard form:

         [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
         [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]

    where either
    1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
    2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
    conjugate eigenvalues.

    Arguments
    =========

    A       (input/output) REAL
    B       (input/output) REAL
    C       (input/output) REAL
    D       (input/output) REAL
            On entry, the elements of the input matrix.
            On exit, they are overwritten by the elements of the
            standardised Schur form.

    RT1R    (output) REAL
    RT1I    (output) REAL
    RT2R    (output) REAL
    RT2I    (output) REAL
            The real and imaginary parts of the eigenvalues. If the
            eigenvalues are a complex conjugate pair, RT1I > 0.

    CS      (output) REAL
    SN      (output) REAL
            Parameters of the rotation matrix.

    Further Details
    ===============

    Modified by V. Sima, Research Institute for Informatics, Bucharest,
    Romania, to reduce the risk of cancellation errors,
    when computing real eigenvalues, and to ensure, if possible, that
    abs(RT1R) >= abs(RT2R).

    =====================================================================
*/

    eps = slamch_("P");  /* 获取机器精度 */

    if (*c__ == 0.f) {  /* 如果 C 为零 */
        *cs = 1.f;  /* 设定旋转矩阵的参数 CS */
        *sn = 0.f;  /* 设定旋转矩阵的参数 SN */
        goto L10;

    } else if (*b == 0.f) {  /* 如果 B 为零 */

/*        Swap rows and columns */

        *cs = 0.f;  /* 设定旋转矩阵的参数 CS */
        *sn = 1.f;  /* 设定旋转矩阵的参数 SN */
        temp = *d__;  /* 交换元素 */
        *d__ = *a;
        *a = temp;
        *b = -(*c__);
        *c__ = 0.f;
        goto L10;
    } else if (*a - *d__ == 0.f && r_sign(&c_b15, b) != r_sign(&c_b15, c__)) {  /* 如果 A-D 为零且符号不同 */

        *cs = 1.f;  /* 设定旋转矩阵的参数 CS */
        *sn = 0.f;  /* 设定旋转矩阵的参数 SN */
        goto L10;
    } else {

        temp = *a - *d__;  /* 计算 A-D */
        p = temp * .5f;  /* 计算 p = (A-D)/2 */
/* Computing MAX */
        r__1 = dabs(*b), r__2 = dabs(*c__);
        bcmax = dmax(r__1,r__2);  /* 计算 BC 的最大值 */
/* Computing MIN */
        r__1 = dabs(*b), r__2 = dabs(*c__);
        bcmis = dmin(r__1,r__2) * r_sign(&c_b15, b) * r_sign(&c_b15, c__);  /* 计算 BC 的最小值 */
/* Computing MAX */
        r__1 = dabs(p);
        scale = dmax(r__1,bcmax);  /* 计算比例尺度 */

        z__ = p / scale * p + bcmax / scale * bcmis;  /* 计算 z 值 */

/*
          If Z is of the order of the machine accuracy, postpone the
          decision on the nature of eigenvalues
*/

        if (z__ >= eps * 4.f) {  /* 如果 z 足够大 */
/*           Real eigenvalues. Compute A and D. */

        r__1 = sqrt(scale) * sqrt(z__);
        z__ = p + r_sign(&r__1, &p);
        *a = *d__ + z__;  /* 更新矩阵对角线元素a */
        *d__ -= bcmax / z__ * bcmis;  /* 更新矩阵对角线元素d */

/*           Compute B and the rotation matrix */

        tau = slapy2_(c__, &z__);  /* 计算旋转角度 */
        *cs = z__ / tau;  /* 更新旋转矩阵的cosine */
        *sn = *c__ / tau;  /* 更新旋转矩阵的sine */
        *b -= *c__;  /* 更新矩阵元素b */
        *c__ = 0.f;  /* 将矩阵元素c清零 */
    } else {

/*
             Complex eigenvalues, or real (almost) equal eigenvalues.
             Make diagonal elements equal.
*/

        sigma = *b + *c__;  /* 计算复杂特征值情况下的sigma */
        tau = slapy2_(&sigma, &temp);  /* 计算新的旋转角度 */
        *cs = sqrt((dabs(sigma) / tau + 1.f) * .5f);  /* 更新旋转矩阵的cosine */
        *sn = -(p / (tau * *cs)) * r_sign(&c_b15, &sigma);  /* 更新旋转矩阵的sine */

/*
             Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
                     [ CC  DD ]   [ C  D ] [ SN  CS ]
*/

        aa = *a * *cs + *b * *sn;  /* 计算新的矩阵元素AA */
        bb = -(*a) * *sn + *b * *cs;  /* 计算新的矩阵元素BB */
        cc = *c__ * *cs + *d__ * *sn;  /* 计算新的矩阵元素CC */
        dd = -(*c__) * *sn + *d__ * *cs;  /* 计算新的矩阵元素DD */

/*
             Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
                     [ C  D ]   [-SN  CS ] [ CC  DD ]
*/

        *a = aa * *cs + cc * *sn;  /* 更新矩阵元素A */
        *b = bb * *cs + dd * *sn;  /* 更新矩阵元素B */
        *c__ = -aa * *sn + cc * *cs;  /* 更新矩阵元素C */
        *d__ = -bb * *sn + dd * *cs;  /* 更新矩阵元素D */

        temp = (*a + *d__) * .5f;  /* 计算矩阵对角线元素的平均值 */
        *a = temp;  /* 更新矩阵元素A为平均值 */
        *d__ = temp;  /* 更新矩阵元素D为平均值 */

        if (*c__ != 0.f) {
        if (*b != 0.f) {
            if (r_sign(&c_b15, b) == r_sign(&c_b15, c__)) {

/*                    Real eigenvalues: reduce to upper triangular form */

            sab = sqrt((dabs(*b)));  /* 计算元素b的绝对值的平方根 */
            sac = sqrt((dabs(*c__)));  /* 计算元素c的绝对值的平方根 */
            r__1 = sab * sac;  /* 计算两者的乘积 */
            p = r_sign(&r__1, c__);  /* 计算符号修正后的乘积 */
            tau = 1.f / sqrt((r__1 = *b + *c__, dabs(r__1)));  /* 计算新的旋转角度 */
            *a = temp + p;  /* 更新矩阵元素A */
            *d__ = temp - p;  /* 更新矩阵元素D */
            *b -= *c__;  /* 更新矩阵元素B */
            *c__ = 0.f;  /* 将矩阵元素C清零 */
            cs1 = sab * tau;  /* 更新新的旋转矩阵的cosine */
            sn1 = sac * tau;  /* 更新新的旋转矩阵的sine */
            temp = *cs * cs1 - *sn * sn1;  /* 计算更新后的cosine */
            *sn = *cs * sn1 + *sn * cs1;  /* 计算更新后的sine */
            *cs = temp;  /* 更新旋转矩阵的cosine */
            }
        } else {
            *b = -(*c__);  /* 更新矩阵元素B为-c */
            *c__ = 0.f;  /* 将矩阵元素C清零 */
            temp = *cs;  /* 交换旋转矩阵的cosine和sine */
            *cs = -(*sn);  /* 更新旋转矩阵的cosine */
            *sn = temp;  /* 更新旋转矩阵的sine */
        }
        }
    }

    }

L10:

/*     Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I). */

    *rt1r = *a;  /* 存储第一个特征值的实部 */
    *rt2r = *d__;  /* 存储第二个特征值的实部 */
    if (*c__ == 0.f) {
    *rt1i = 0.f;  /* 如果矩阵元素C为零，则存储第一个特征值的虚部为零 */
    *rt2i = 0.f;  /* 如果矩阵元素C为零，则存储第二个特征值的虚部为零 */
    } else {
    *rt1i = sqrt((dabs(*b))) * sqrt((dabs(*c__)));  /* 计算第一个特征值的虚部 */
    *rt2i = -(*rt1i);  /* 计算第二个特征值的虚部 */
    }
    return 0;

/*     End of SLANV2 */

} /* slanv2_ */

doublereal slapy2_(real *x, real *y)
{
    /* System generated locals */
    real ret_val, r__1;

    /* Local variables */
    static real w, z__, xabs, yabs;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
    overflow.

    Arguments
    =========

    X       (input) REAL
*/


注释：
    Y       (input) REAL
            X and Y specify the values x and y.
/* Subroutine */ int slaqr0_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, real *h__, integer *ldh, real *wr, real *
    wi, integer *iloz, integer *ihiz, real *z__, integer *ldz, real *work,
    integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    real r__1, r__2, r__3, r__4;

    /* Local variables */
    static integer i__, k;
    static real aa, bb, cc, dd;
    static integer ld;
    static real cs;
    static integer nh, it, ks, kt;
    static real sn;
    static integer ku, kv, ls, ns;
    static real ss;
    static integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl,
        kbot, nmin;
    static real swap;
    static integer ktop;
    static real zdum[1]    /* was [1][1] */;
    static integer kacc22, itmax, nsmax, nwmax, kwtop;

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAQR0 computes the eigenvalues of a Hessenberg matrix H
    and optionally the matrices T and Z from the Schur decomposition
    of H.

    Arguments
    =========

    WANTT   (input) LOGICAL
            = .TRUE. : compute T
            = .FALSE.: do not compute T

    WANTZ   (input) LOGICAL
            = .TRUE. : compute Z
            = .FALSE.: do not compute Z

    N       (input) INTEGER
            The order of the matrix H. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that H is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to SGEBAL; otherwise they should be
            set to 1 and N respectively. See SGEBAL for further
            details.

    H       (input/output) REAL array, dimension (LDH,N)
            On entry, the upper Hessenberg matrix H.
            On exit, if INFO = 0 and WANTT is .TRUE., then H contains
            the upper quasi-triangular matrix T from the Schur
            decomposition (the Schur form). If INFO = 0 and WANT is
            .FALSE., then the contents of H are unspecified on exit.
            (The output value of H when INFO.GT.0 is given under the
            description of INFO below.)

    LDH     (input) INTEGER
            The leading dimension of the array H. LDH >= max(1,N).

    WR      (output) REAL array, dimension (N)
    WI      (output) REAL array, dimension (N)
            The real and imaginary parts of the eigenvalues of H.
            If WI(j) is zero, then the j-th eigenvalue is real; if
            positive, then the j-th and (j+1)-st eigenvalues are a
            complex conjugate pair, with WR(j) = WR(j+1) and
            WI(j) = -WI(j+1). Note that if a complex eigenvalue
            does not satisfy WI(j)=0, then both WR(j) and WR(j+1)
            will be set to the real part of the eigenvalue, and
            WI(j) and WI(j+1) will be set to the corresponding
            imaginary parts.

    ILOZ    (input) INTEGER
    IHIZ    (input) INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1=1st row. ILOZ and IHIZ
            must be at least 1 and no greater than N. If WANTZ is
            .FALSE., then ILOZ and IHIZ can be any arbitrary value.

    Z       (input/output) REAL array, dimension (LDZ,N)
            On entry, if WANTZ is .TRUE., then Z contains the
            orthogonal matrix Z of the Schur vectors of H.
            On exit, if INFO = 0, then if WANTZ is .TRUE., Z
            contains the orthogonal matrix Z of the Schur vectors
            of H; if WANTZ is .FALSE., Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z. LDZ >= max(1,N).

    WORK    (workspace/output) REAL array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value.
            > 0: if INFO = i, SLAQR0 failed to compute all of the
                 eigenvalues in a total of maxit iterations;
                 elements i+1:N of WR and WI contain those
                 eigenvalues which have been successfully computed.
*/
    ! 声明外部子程序 slanv2、slaqr3、slaqr4、slaqr5、ilaenv、slahqr 和 slacpy
    extern /* Subroutine */ int slanv2_(real *, real *, real *, real *, real *
        , real *, real *, real *, real *, real *), slaqr3_(logical *,
        logical *, integer *, integer *, integer *, integer *, real *,
        integer *, integer *, integer *, real *, integer *, integer *,
        integer *, real *, real *, real *, integer *, integer *, real *,
        integer *, integer *, real *, integer *, real *, integer *),
        slaqr4_(logical *, logical *, integer *, integer *, integer *,
        real *, integer *, real *, real *, integer *, integer *, real *,
        integer *, real *, integer *, integer *), slaqr5_(logical *,
        logical *, integer *, integer *, integer *, integer *, integer *,
        real *, real *, real *, integer *, integer *, integer *, real *,
        integer *, real *, integer *, real *, integer *, integer *, real *
        , integer *, integer *, real *, integer *);
    
    ! 声明静态整型变量 nibble
    static integer nibble;
    
    ! 调用 ilaenv 函数声明
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    ! 声明静态字符数组 jbcmpz，长度为 2
    static char jbcmpz[2];
    
    ! 声明外部子程序 slahqr 和 slacpy
    extern /* Subroutine */ int slahqr_(logical *, logical *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , integer *, real *, integer *, integer *), slacpy_(char *,
        integer *, integer *, real *, integer *, real *, integer *);
    
    ! 声明静态整型变量 nwupbd、sorted 和 lwkopt
    static integer nwupbd;
    static logical sorted;
    static integer lwkopt;
/*
*/
    /* Parameter adjustments */
    h_dim1 = *ldh;                           // 设置矩阵 H 的第一维度为 ldh
    h_offset = 1 + h_dim1;                   // 计算 h__ 的偏移量
    h__ -= h_offset;                         // 调整 h__ 指针的位置
    --wr;                                    // 调整 wr 数组指针位置
    --wi;                                    // 调整 wi 数组指针位置
    z_dim1 = *ldz;                           // 设置矩阵 Z 的第一维度为 ldz
    z_offset = 1 + z_dim1;                   // 计算 z__ 的偏移量
    z__ -= z_offset;                         // 调整 z__ 指针的位置
    --work;                                  // 调整 work 数组指针位置

    /* Function Body */
    *info = 0;                               // 初始化 info 参数为 0

/*     ==== Quick return for N = 0: nothing to do. ==== */

    if (*n == 0) {                           // 如果 n 等于 0
    work[1] = 1.f;                           // 设置 work 数组第一个元素为 1.0
    return 0;                                // 返回
    }

    if (*n <= 11) {

/*        ==== Tiny matrices must use SLAHQR. ==== */

    lwkopt = 1;                               // 设置 lwkopt 为 1
    if (*lwork != -1) {                       // 如果 lwork 不等于 -1
        slahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
            wi[1], iloz, ihiz, &z__[z_offset], ldz, info);   // 调用 slahqr 函数
    }
    } else {

/*
          ==== Use small bulge multi-shift QR with aggressive early
          .    deflation on larger-than-tiny matrices. ====

          ==== Hope for the best. ====
*/

    *info = 0;                                // 初始化 info 参数为 0

/*        ==== Set up job flags for ILAENV. ==== */

    if (*wantt) {                             // 如果 wantt 为真
        *(unsigned char *)jbcmpz = 'S';        // 设置 jbcmpz 的第一个字符为 'S'
    } else {
        *(unsigned char *)jbcmpz = 'E';        // 否则设置为 'E'
    }
    if (*wantz) {                             // 如果 wantz 为真
        *(unsigned char *)&jbcmpz[1] = 'V';    // 设置 jbcmpz 的第二个字符为 'V'
    } else {
        *(unsigned char *)&jbcmpz[1] = 'N';    // 否则设置为 'N'
    }

/*
          ==== NWR = recommended deflation window size.  At this
          .    point,  N .GT. NTINY = 11, so there is enough
          .    subdiagonal workspace for NWR.GE.2 as required.
          .    (In fact, there is enough subdiagonal space for
          .    NWR.GE.3.) ====
*/

    nwr = ilaenv_(&c__13, "SLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);                          // 调用 ilaenv 函数获取推荐的窗口大小 nwr
    nwr = max(2,nwr);                         // 取 nwr 和 2 的最大值
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
    nwr = min(i__1,nwr);                      // 取 nwr 和计算出来的值的最小值

/*
          ==== NSR = recommended number of simultaneous shifts.
          .    At this point N .GT. NTINY = 11, so there is at
          .    enough subdiagonal workspace for NSR to be even
          .    and greater than or equal to two as required. ====
*/

    nsr = ilaenv_(&c__15, "SLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);                          // 调用 ilaenv 函数获取推荐的同时移位数目 nsr
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;
    nsr = min(i__1,i__2);                     // 取 nsr 和计算出来的值的最小值
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;
    nsr = max(i__1,i__2);                     // 取 2 和 nsr - nsr % 2 的最大值

/*
          ==== Estimate optimal workspace ====

          ==== Workspace query call to SLAQR3 ====
*/

    i__1 = nwr + 1;                           // 计算传递给 slaqr3 函数的参数
    slaqr3_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
        h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset],
        ldh, &work[1], &c_n1);                // 调用 slaqr3 函数进行计算

/*
          ==== Optimal workspace = MAX(SLAQR5, SLAQR3) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1];
    lwkopt = max(i__1,i__2);                   // 取 nsr * 3 / 2 和 work[1] 的最大值

/*        ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {                       // 如果 lwork 等于 -1
        work[1] = (real) lwkopt;              // 设置 work[1] 为 lwkopt 的实数形式
        return 0;                              // 返回
    }

/*        ==== SLAHQR/SLAQR0 crossover point ==== */
    # 调用外部函数 ilaenv_，传入一系列参数，并将结果赋给 nmin
    nmin = ilaenv_(&c__12, "SLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
        6, (ftnlen)2);
    # 将 nmin 和 11 比较，取较大的值作为 nmin 的最终赋值
    nmin = max(11,nmin);
/*        ==== Nibble crossover point ==== */

    // 调用外部函数 ilaenv_，获取指定参数下的值，用于决定“nibble”值
    nibble = ilaenv_(&c__14, "SLAQR0", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 确保“nibble”不小于0
    nibble = max(0,nibble);

/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

    // 调用外部函数 ilaenv_，获取指定参数下的值，用于决定“kacc22”值
    kacc22 = ilaenv_(&c__16, "SLAQR0", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 确保“kacc22”不小于0，且不大于2
    kacc22 = max(0,kacc22);
    kacc22 = min(2,kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/
    // 计算“nwmax”，表示能够进行缩减的最大窗口大小
    i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
    nwmax = min(i__1,i__2);
    nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/
    // 计算“nsmax”，表示同时进行的最大位移数量
    i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
    nsmax = min(i__1,i__2);
    nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

    // 设置迭代计数器“ndfl”，用于在缩减时重新启动
    ndfl = 1;

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/
    // 计算“itmax”，迭代的上限
    i__1 = 10, i__2 = *ihi - *ilo + 1;
    itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

    // 设置“kbot”，表示活动块的最后一行和列
    kbot = *ihi;

/*        ==== Main Loop ==== */

    // 主循环，迭代次数由“itmax”决定
    i__1 = itmax;
    for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

        // 如果“kbot”小于“ilo”，跳出循环
        if (kbot < *ilo) {
        goto L90;
        }

/*           ==== Locate active block ==== */

        // 确定活动块的位置，“k”从“kbot”向上搜索
        i__2 = *ilo + 1;
        for (k = kbot; k >= i__2; --k) {
        // 如果对角线元素为0，则跳转到标签 L20
        if (h__[k + (k - 1) * h_dim1] == 0.f) {
            goto L20;
        }
/* L10: */
        }
        // 若未发现对角线元素为0的情况，则将“k”设置为“ilo”
        k = *ilo;
L20:
        // 设置“ktop”，表示活动块的首行和列

        ktop = k;

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

        // 计算“nh”，活动块的行数
        nh = kbot - ktop + 1;
        // 确定“nwupbd”，即可进行缩减的最大窗口大小
        nwupbd = min(nh,nwmax);
        // 根据当前迭代次数“ndfl”的值，选择缩减窗口大小
        if (ndfl < 5) {
        nw = min(nwupbd,nwr);
        } else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        } /* 更新 nw 为 nwupbd 和 2*nw 中的较小值 */

        if (nw < nwmax) {
/* 如果 nw 小于 nwmax */
        if (nw >= nh - 1) {
/* 如果 nw 大于等于 nh - 1 */
            nw = nh;
        } else {
            kwtop = kbot - nw + 1;
/* 计算 kwtop */
            if ((r__1 = h__[kwtop + (kwtop - 1) * h_dim1], dabs(r__1))
                 > (r__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1],
                dabs(r__2))) {
            ++nw;
            }
        }
        }
        if (ndfl < 5) {
/* 如果 ndfl 小于 5 */
        ndec = -1;
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 或者 ndec 大于等于 0 或 nw 大于等于 nwupbd */
        ++ndec;
        if (nw - ndec < 2) {
            ndec = 0;
        }
        nw -= ndec;
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/
/* 激进的早期降维策略说明 */

        kv = *n - nw + 1;
/* 计算 kv */
        kt = nw + 1;
/* 计算 kt */
        nho = *n - nw - 1 - kt + 1;
/* 计算 nho */
        kwv = nw + 2;
/* 计算 kwv */
        nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */
/* 激进的早期降维策略 */

        slaqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
             &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);
/* 调用 slaqr3 进行 QR 算法 */

/*           ==== Adjust KBOT accounting for new deflations. ==== */
/* 调整 KBOT，以考虑新的降维 */

        kbot -= ld;
/* 更新 kbot */

/*           ==== KS points to the shifts. ==== */
/* 设置 KS 指向的是位移 */

        ks = kbot - ls + 1;
/* 计算 ks */

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/
/* 如果有部分启发式理由表明许多特征值可以在没有进行昂贵的 QR 波动的情况下降低，那么跳过 */

        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if SLAQR3
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* 设置 NS，同时位移的名义数量 */
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
        ns = min(i__2,i__3);
        ns -= ns % 2;

/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    SLAQR3 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
/* 如果在 KEXSH 次迭代中没有发生降维，则尝试异常位移 */
        if (ndfl % 6 == 0) {
            // 如果 ndfl 能被 6 整除，则执行以下操作
            ks = kbot - ns + 1;
            // 计算 MAX
            i__3 = ks + 1, i__4 = ktop + 2;
            i__2 = max(i__3,i__4);
            // 循环，从 kbot 开始，每次递减2，直到 i__2
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
                // 计算 ss
                ss = (r__1 = h__[i__ + (i__ - 1) * h_dim1], dabs(r__1)
                    ) + (r__2 = h__[i__ - 1 + (i__ - 2) * h_dim1],
                     dabs(r__2));
                // 初始化 aa, bb, cc, dd
                aa = ss * .75f + h__[i__ + i__ * h_dim1];
                bb = ss;
                cc = ss * -.4375f;
                dd = aa;
                // 调用 SLANV2，求解一对特征值
                slanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
                    , &wr[i__], &wi[i__], &cs, &sn);
                // 循环结束标记
    /* L30: */
            }
            // 如果 ks 等于 ktop，则更新 wr 和 wi 数组
            if (ks == ktop) {
                wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
                wi[ks + 1] = 0.f;
                wr[ks] = wr[ks + 1];
                wi[ks] = wi[ks + 1];
            }
        } else {

            // 否则执行以下操作

/*
                   ==== Got NS/2 or fewer shifts? Use SLAQR4 or
                   .    SLAHQR on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
*/

            // 如果 kbot - ks + 1 小于等于 ns / 2
            if (kbot - ks + 1 <= ns / 2) {
                // 更新 ks 和 kt
                ks = kbot - ns + 1;
                kt = *n - ns + 1;
                // 复制数组 h__ 的一部分
                slacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
                    h__[kt + h_dim1], ldh);
                // 根据 ns 的大小选择调用 slaqr4_ 或 slahqr_
                if (ns > nmin) {
                    slaqr4_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                        kt + h_dim1], ldh, &wr[ks], &wi[ks], &
                        c__1, &c__1, zdum, &c__1, &work[1], lwork,
                         &inf);
                } else {
                    slahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                        kt + h_dim1], ldh, &wr[ks], &wi[ks], &
                        c__1, &c__1, zdum, &c__1, &inf);
                }
                // 更新 ks
                ks += inf;

/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  ====
*/

                // 如果 ks 大于等于 kbot，则求解 trailing 2-by-2 子矩阵的特征值
                if (ks >= kbot) {
                    aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
                    cc = h__[kbot + (kbot - 1) * h_dim1];
                    bb = h__[kbot - 1 + kbot * h_dim1];
                    dd = h__[kbot + kbot * h_dim1];
                    // 调用 SLANV2，求解一对特征值
                    slanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
                        kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
                        ;
                    ks = kbot - 1;
                }
            }

            // 如果 kbot - ks + 1 大于 ns，则对移位进行排序
            if (kbot - ks + 1 > ns) {

/*
                      ==== Sort the shifts (Helps a little)
                      .    Bubble sort keeps complex conjugate
                      .    pairs together. ====
*/
            // 初始化排序标志为假
            sorted = FALSE_;
            // 循环从 kbot 到 ks+1，反向遍历
            i__2 = ks + 1;
            for (k = kbot; k >= i__2; --k) {
                // 如果已经排序好则跳转到标签 L60
                if (sorted) {
                goto L60;
                }
                // 设置排序标志为真
                sorted = TRUE_;
                // 内部循环从 ks 到 k-1
                i__3 = k - 1;
                for (i__ = ks; i__ <= i__3; ++i__) {
                // 如果当前元素比后一个元素大，则交换它们
                if ((r__1 = wr[i__], dabs(r__1)) + (r__2 = wi[
                    i__], dabs(r__2)) < (r__3 = wr[i__ +
                    1], dabs(r__3)) + (r__4 = wi[i__ + 1],
                     dabs(r__4))) {
                    sorted = FALSE_;

                    swap = wr[i__];
                    wr[i__] = wr[i__ + 1];
                    wr[i__ + 1] = swap;

                    swap = wi[i__];
                    wi[i__] = wi[i__ + 1];
                    wi[i__ + 1] = swap;
                }
/* L40: */
                }
/* L50: */
            }
L60:
            ;

            // ==== 将移位按照一对实数移位和一对共轭复数移位的方式重新排列 ====
            i__2 = ks + 2;
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
            // 如果当前元素不是前一个元素的复共轭，则交换它们
            if (wi[i__] != -wi[i__ - 1]) {

                swap = wr[i__];
                wr[i__] = wr[i__ - 1];
                wr[i__ - 1] = wr[i__ - 2];
                wr[i__ - 2] = swap;

                swap = wi[i__];
                wi[i__] = wi[i__ - 1];
                wi[i__ - 1] = wi[i__ - 2];
                wi[i__ - 2] = swap;
            }
/* L70: */
            }
        }

        // ==== 如果只有两个移位并且都是实数，则只使用一个移位 ====
        if (kbot - ks + 1 == 2) {
            // 如果最后一个复数部分为零
            if (wi[kbot] == 0.f) {
            // 比较两个实数移位，并保留较小的一个
            if ((r__1 = wr[kbot] - h__[kbot + kbot * h_dim1],
                dabs(r__1)) < (r__2 = wr[kbot - 1] - h__[kbot
                + kbot * h_dim1], dabs(r__2))) {
                wr[kbot - 1] = wr[kbot];
            } else {
                wr[kbot] = wr[kbot - 1];
            }
            }
        }

        // ==== 使用最小数量为 NS 的最小幅值移位 ====
        // 计算可用的最小幅值移位数
        i__2 = ns, i__3 = kbot - ks + 1;
        ns = min(i__2,i__3);
        // 如果移位数不是偶数，则减少一个以保证偶数个移位
        ns -= ns % 2;
        // 更新 ks 的值以反映实际使用的移位数
        ks = kbot - ns + 1;
/*
    ==== Small-bulge multi-shift QR sweep: ====
    .    split workspace under the subdiagonal into
    .    - a KDU-by-KDU work array U in the lower
    .      left-hand-corner,
    .    - a KDU-by-at-least-KDU-but-more-is-better
    .      (KDU-by-NHo) horizontal work array WH along
    .      the bottom edge,
    .    - and an at-least-KDU-but-more-is-better-by-KDU
    .      (NVE-by-KDU) vertical work array WV along
    .      the left-hand-edge.
*/

kdu = ns * 3 - 3;   // Compute the size of the workspace for U
ku = *n - kdu + 1;  // Compute the starting index for U in the matrix
kwh = kdu + 1;      // Compute the size of the horizontal workspace WH
nho = *n - kdu - 3 - (kdu + 1) + 1;  // Compute the size of the horizontal workspace NHo
kwv = kdu + 4;      // Compute the size of the vertical workspace WV
nve = *n - kdu - kwv + 1;  // Compute the size of the vertical workspace NVE

/*
    ==== Small-bulge multi-shift QR sweep ====
*/

slaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks],
        &wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
        z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1],
        ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku +
        kwh * h_dim1], ldh);

/* 
    ==== Note progress (or the lack of it). ====
*/

if (ld > 0) {
    ndfl = 1;   // Set ndfl to 1 if ld > 0
} else {
    ++ndfl;     // Increment ndfl if ld <= 0
}

/*
    ==== End of main loop ====
*/

}

/*
    ==== Iteration limit exceeded.  Set INFO to show where
    .    the problem occurred and exit. ====
*/

*info = kbot;
L90:
;

/*
    ==== Return the optimal value of LWORK. ====
*/

work[1] = (real) lwkopt;  // Store the optimal value of LWORK in work[1]

/*
    ==== End of SLAQR0 ====
*/

return 0;
} /* slaqr0_ */

/* Subroutine */ int slaqr1_(integer *n, real *h__, integer *ldh, real *sr1,
    real *si1, real *sr2, real *si2, real *v)
{
    /* System generated locals */
    integer h_dim1, h_offset;
    real r__1, r__2, r__3;

    /* Local variables */
    static real s, h21s, h31s;
    -- LAPACK辅助例程（版本3.2）--
       田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司。
       2006年11月
    
    
         给定一个2x2或3x3矩阵H，SLAQR1将v设置为乘积的第一列的标量倍数
    
         (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
    
         这是为了避免溢出和大多数下溢。假设满足以下条件之一：
    
                 1) sr1 = sr2 且 si1 = -si2
             或
                 2) si1 = si2 = 0.
    
         这在启动QR算法中的双隐式移位突起时很有用。
    
    
         N      (输入) 整数
                矩阵H的阶数。N必须是2或3。
    
         H      (输入) 实数数组，维度为(LDH,N)
                (*)中的2x2或3x3矩阵H。
    
         LDH    (输入) 整数
                H的主维度，如在调用过程中声明的。LDH.GE.N
    
         SR1    (输入) 实数
         SI1    (*)中的移位参数。
         SR2
         SI2
    
         V      (输出) 实数数组，维度为N
                (*)中矩阵K的第一列的标量倍数。
    
       ================================================================
       基于以下贡献
          Karen Braman 和 Ralph Byers，数学系，
          美国堪萨斯大学
    
       ================================================================
    /* Parameter adjustments */
    // 定义并调整参数h_dim1为列数*ldh，h_offset为1+h_dim1
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;  // 将h__数组向左偏移h_offset，即1+h_dim1

    --v;  // v数组减1，将其从1-based调整为0-based

    /* Function Body */
    // 如果n等于2
    if (*n == 2) {
        // 计算s为h__[h_dim1 + 1] - *sr2的绝对值加上*si2的绝对值再加上h__[h_dim1 + 2]的绝对值
        s = (r__1 = h__[h_dim1 + 1] - *sr2, dabs(r__1)) + dabs(*si2) + (r__2 =
             h__[h_dim1 + 2], dabs(r__2));
        // 如果s等于0
        if (s == 0.f) {
            v[1] = 0.f;  // 设置v[1]为0
            v[2] = 0.f;  // 设置v[2]为0
        } else {
            // 计算h21s为h__[h_dim1 + 2]除以s
            h21s = h__[h_dim1 + 2] / s;
            // 计算v[1]为h21s乘以h__[(h_dim1 << 1) + 1]加上(h__[h_dim1 + 1] - *sr1)乘以((h__[h_dim1 + 1] - *sr2)除以s)再减去*si1乘以(*si2除以s)
            v[1] = h21s * h__[(h_dim1 << 1) + 1] + (h__[h_dim1 + 1] - *sr1) *
                ((h__[h_dim1 + 1] - *sr2) / s) - *si1 * (*si2 / s);
            // 计算v[2]为h21s乘以(h__[h_dim1 + 1]加上h__[(h_dim1 << 1) + 2]减去*sr1减去*sr2)再加上h__[h_dim1 * 3 + 2]乘以h31s
            v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
                sr2) + h__[h_dim1 * 3 + 2] * h31s;
        }
    } else {
        // 计算s为h__[h_dim1 + 1] - *sr2的绝对值加上*si2的绝对值再加上h__[h_dim1 + 2]的绝对值再加上h__[h_dim1 + 3]的绝对值
        s = (r__1 = h__[h_dim1 + 1] - *sr2, dabs(r__1)) + dabs(*si2) + (r__2 =
             h__[h_dim1 + 2], dabs(r__2)) + (r__3 = h__[h_dim1 + 3], dabs(
            r__3));
        // 如果s等于0
        if (s == 0.f) {
            v[1] = 0.f;  // 设置v[1]为0
            v[2] = 0.f;  // 设置v[2]为0
            v[3] = 0.f;  // 设置v[3]为0
        } else {
            // 计算h21s为h__[h_dim1 + 2]除以s
            h21s = h__[h_dim1 + 2] / s;
            // 计算h31s为h__[h_dim1 + 3]除以s
            h31s = h__[h_dim1 + 3] / s;
            // 计算v[1]为(h__[h_dim1 + 1] - *sr1)乘以((h__[h_dim1 + 1] - *sr2)除以s)减去*si1乘以(*si2除以s)再加上h__[(h_dim1 << 1) + 1]乘以h21s再加上h__[h_dim1 * 3 + 1]乘以h31s
            v[1] = (h__[h_dim1 + 1] - *sr1) * ((h__[h_dim1 + 1] - *sr2) / s)
                - *si1 * (*si2 / s) + h__[(h_dim1 << 1) + 1] * h21s + h__[
                h_dim1 * 3 + 1] * h31s;
            // 计算v[2]为h21s乘以(h__[h_dim1 + 1]加上h__[(h_dim1 << 1) + 2]减去*sr1减去*sr2)再加上h__[h_dim1 * 3 + 2]乘以h31s
            v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
                sr2) + h__[h_dim1 * 3 + 2] * h31s;
            // 计算v[3]为h31s乘以(h__[h_dim1 + 1]加上h__[h_dim1 * 3 + 3]减去*sr1减去*sr2)再加上h21s乘以h__[(h_dim1 << 1) + 3]
            v[3] = h31s * (h__[h_dim1 + 1] + h__[h_dim1 * 3 + 3] - *sr1 - *
                sr2) + h21s * h__[(h_dim1 << 1) + 3];
        }
    }
    return 0;
} /* slaqr1_ */

/* Subroutine */ int slaqr2_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, real *h__, integer *ldh,
    integer *iloz, integer *ihiz, real *z__, integer *ldz, integer *ns,
    integer *nd, real *sr, real *si, real *v, integer *ldv, integer *nh,
    real *t, integer *ldt, integer *nv, real *wv, integer *ldwv, real *
    work, integer *lwork)
{
    /* System generated locals */
    // 自动计算的变量维度和偏移
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;

    /* Local variables */
    // 局部变量声明
    static integer i__, j, k;
    static real s, aa, bb, cc, dd, cs, sn;
    static integer jw;
    static real evi, evk, foo;
    static integer kln;
    static real tau, ulp;
    static integer lwk1, lwk2;
    static real beta;
    static integer kend, kcol, info, ifst, ilst, ltop, krow;
    static logical bulge;
    // 外部子程序声明
    extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
        integer *, real *, real *, integer *, real *);
    extern /* Subroutine */ int sgemm_(
        char *, char *, integer *, integer *, integer *, real *, real *,
        integer *, real *, integer *, real *, real *, integer *);
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    extern /* Subroutine */ int slanv2_(real *, real *, real *, real *, real *
        , real *, real *, real *, real *, real *), slabad_(real *, real *);
    # 外部函数声明，用于获取机器精度相关的参数
    extern doublereal slamch_(char *);
    # 外部子程序声明，用于实现矩阵的 Hessenberg 分解
    extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *);
    # 静态变量声明，用于存储最小安全浮点数
    static real safmin;
    # 外部子程序声明，用于生成 Householder 变换
    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *);
    # 静态变量声明，用于存储最大安全浮点数
    static real safmax;
    # 外部子程序声明，用于计算实矩阵的 Hessenberg-累积 QR 方法
    extern /* Subroutine */ int slahqr_(logical *, logical *, integer *,
        integer *, integer *, real *, integer *, real *, real *, integer *
        , integer *, real *, integer *, integer *);
    # 外部子程序声明，用于复制矩阵
    extern /* Subroutine */ int slacpy_(char *,
        integer *, integer *, real *, integer *, real *, integer *);
    # 外部子程序声明，用于设置矩阵的值
    extern /* Subroutine */ int slaset_(char *, integer *, integer *, real *, real *,
        real *, integer *);
    # 静态变量声明，用于存储最小的正浮点数
    static real smlnum;
    # 静态变量声明，用于存储工作数组的长度
    static integer lwkopt;
/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

/* Parameter adjustments */
h_dim1 = *ldh;                               // 获取矩阵 h 的第一维度大小
h_offset = 1 + h_dim1;                       // 计算 h 的偏移量
h__ -= h_offset;                             // 调整 h 的起始地址
z_dim1 = *ldz;                               // 获取矩阵 z 的第一维度大小
z_offset = 1 + z_dim1;                       // 计算 z 的偏移量
z__ -= z_offset;                             // 调整 z 的起始地址
--sr;                                        // 将 sr 指向下一个元素
--si;                                        // 将 si 指向下一个元素
v_dim1 = *ldv;                               // 获取矩阵 v 的第一维度大小
v_offset = 1 + v_dim1;                       // 计算 v 的偏移量
v -= v_offset;                               // 调整 v 的起始地址
t_dim1 = *ldt;                               // 获取矩阵 t 的第一维度大小
t_offset = 1 + t_dim1;                       // 计算 t 的偏移量
t -= t_offset;                               // 调整 t 的起始地址
wv_dim1 = *ldwv;                             // 获取矩阵 wv 的第一维度大小
wv_offset = 1 + wv_dim1;                     // 计算 wv 的偏移量
wv -= wv_offset;                             // 调整 wv 的起始地址
--work;                                      // 将 work 指向下一个元素

/* Function Body */
/* Computing MIN */
i__1 = *nw, i__2 = *kbot - *ktop + 1;         // 计算 nw 和 kbot - ktop + 1 的最小值
jw = min(i__1,i__2);                         // 将结果保存到 jw 中
if (jw <= 2) {                               // 如果 jw 小于等于 2
lwkopt = 1;                                  // 设置 lwkopt 为 1
} else {

/*        ==== Workspace query call to SGEHRD ==== */

i__1 = jw - 1;                               // 计算 jw - 1
sgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
    c_n1, &info);                           // 调用 SGEHRD 获取所需的工作空间大小
lwk1 = (integer) work[1];                    // 将结果保存到 lwk1 中

/*        ==== Workspace query call to SORMHR ==== */

i__1 = jw - 1;                               // 计算 jw - 1
sormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
     &v[v_offset], ldv, &work[1], &c_n1, &info);  // 调用 SORMHR 获取所需的工作空间大小
lwk2 = (integer) work[1];                    // 将结果保存到 lwk2 中

/*        ==== Optimal workspace ==== */

lwkopt = jw + max(lwk1,lwk2);                // 计算最优工作空间大小
}

/*     ==== Quick return in case of workspace query. ==== */

if (*lwork == -1) {                          // 如果 lwork 为 -1，表示查询工作空间大小
work[1] = (real) lwkopt;                     // 将最优工作空间大小保存到 work[1] 中
return 0;                                    // 返回
}

/*
       ==== Nothing to do ...
       ... for an empty active block ... ====
*/
*ns = 0;                                      // 设置 ns 为 0
*nd = 0;                                      // 设置 nd 为 0
work[1] = 1.f;                                // 设置 work[1] 为 1.0
if (*ktop > *kbot) {                         // 如果 ktop 大于 kbot
return 0;                                    // 返回
}
/*     ... nor for an empty deflation window. ==== */
if (*nw < 1) {                               // 如果 nw 小于 1
return 0;                                    // 返回
}

/*     ==== Machine constants ==== */

safmin = slamch_("SAFE MINIMUM");             // 获取安全最小值
safmax = 1.f / safmin;                       // 计算安全最大值
slabad_(&safmin, &safmax);                    // 调整机器常数
ulp = slamch_("PRECISION");                   // 获取精度单位舍入值
smlnum = safmin * ((real) (*n) / ulp);        // 计算小数点后最小数

/*
       ==== Setup deflation window ====

   Computing MIN
*/
i__1 = *nw, i__2 = *kbot - *ktop + 1;          // 计算 nw 和 kbot - ktop + 1 的最小值
jw = min(i__1,i__2);                          // 将结果保存到 jw 中
kwtop = *kbot - jw + 1;                       // 计算 deflation 窗口的顶部索引
if (kwtop == *ktop) {                         // 如果顶部索引等于 ktop
s = 0.f;                                      // 设置 s 为 0
} else {
s = h__[kwtop + (kwtop - 1) * h_dim1];        // 否则，从 h 中获取 s 的值
}

if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

sr[kwtop] = h__[kwtop + kwtop * h_dim1];      // 设置 sr[kwtop]
si[kwtop] = 0.f;                              // 设置 si[kwtop]
*ns = 1;                                      // 设置 ns 为 1
*nd = 0;                                      // 设置 nd 为 0
/* Computing MAX */
r__2 = smlnum, r__3 = ulp * (r__1 = h__[kwtop + kwtop * h_dim1], dabs(
    r__1));                                  // 计算 s 的绝对值与给定值的最大值
if (dabs(s) <= dmax(r__2,r__3)) {              // 如果 s 的绝对值小于等于给定值
*ns = 0;                                      // 设置 ns 为 0
*nd = 1;                                      // 设置 nd 为 1
if (kwtop > *ktop) {
h__[kwtop + (kwtop - 1) * h_dim1] = 0.f;      // 如果 kwtop 大于 ktop，将 h 中的值设置为 0
}
}
work[1] = 1.f;                                // 设置 work[1] 为 1.0
return 0;                                      // 返回
}

/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/
    # 调用 LAPACK 库中的 slacpy_ 函数，复制矩阵 h__ 的一部分到矩阵 t__
    slacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
            ldt);
    
    # 设置变量 i__1 为 jw - 1
    i__1 = jw - 1;
    # 设置变量 i__2 为 *ldh + 1
    i__2 = *ldh + 1;
    # 设置变量 i__3 为 *ldt + 1
    i__3 = *ldt + 1;
    # 调用 LAPACK 库中的 scopy_ 函数，复制矩阵 h__ 的一部分到矩阵 t__ 的另一部分
    scopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
           i__3);
    
    # 调用 LAPACK 库中的 slaset_ 函数，将矩阵 v__ 的一部分设置为常数
    slaset_("A", &jw, &jw, &c_b29, &c_b15, &v[v_offset], ldv);
    
    # 调用 LAPACK 库中的 slahqr_ 函数，进行 Hessenberg 矩阵的 QR 分解
    slahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[kwtop],
            &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
/*     ==== STREXC needs a clean margin near the diagonal ==== */
/*     ==== STREXC 需要在对角线附近有一个清晰的空白边缘 ==== */

    i__1 = jw - 3;
    for (j = 1; j <= i__1; ++j) {
        t[j + 2 + j * t_dim1] = 0.f;
        t[j + 3 + j * t_dim1] = 0.f;
/* L10: */
    }

    if (jw > 2) {
        t[jw + (jw - 2) * t_dim1] = 0.f;
    }

/*     ==== Deflation detection loop ==== */
/*     ==== 缩并检测循环 ==== */

    *ns = jw;
    ilst = infqr + 1;
L20:
    if (ilst <= *ns) {
        if (*ns == 1) {
            bulge = FALSE_;
        } else {
            bulge = t[*ns + (*ns - 1) * t_dim1] != 0.f;
        }

/*        ==== Small spike tip test for deflation ==== */
/*        ==== 小尖峰测试是否要缩并 ==== */

        if (! bulge) {

/*           ==== Real eigenvalue ==== */
/*           ==== 实特征值 ==== */

            foo = (r__1 = t[*ns + *ns * t_dim1], dabs(r__1));
            if (foo == 0.f) {
                foo = dabs(s);
            }
/* Computing MAX */
            r__2 = smlnum, r__3 = ulp * foo;
            if ((r__1 = s * v[*ns * v_dim1 + 1], dabs(r__1)) <= dmax(r__2,
                r__3)) {

/*              ==== Deflatable ==== */
/*              ==== 可缩并的情况 ==== */

                --(*ns);
            } else {

/*
                ==== Undeflatable.   Move it up out of the way.
                .    (STREXC can not fail in this case.) ====
*/
/*                ==== 不可缩并。将其上移，让路。
                 *    （在这种情况下，STREXC 不会失败。）====
*/

                ifst = *ns;
                strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                     &ilst, &work[1], &info);
                ++ilst;
            }
        } else {

/*           ==== Complex conjugate pair ==== */
/*           ==== 复共轭对 ==== */

            foo = (r__3 = t[*ns + *ns * t_dim1], dabs(r__3)) + sqrt((r__1 = t[
                *ns + (*ns - 1) * t_dim1], dabs(r__1))) * sqrt((r__2 = t[
                *ns - 1 + *ns * t_dim1], dabs(r__2)));
            if (foo == 0.f) {
                foo = dabs(s);
            }
/* Computing MAX */
            r__3 = (r__1 = s * v[*ns * v_dim1 + 1], dabs(r__1)), r__4 = (r__2
                = s * v[(*ns - 1) * v_dim1 + 1], dabs(r__2));
/* Computing MAX */
            r__5 = smlnum, r__6 = ulp * foo;
            if (dmax(r__3,r__4) <= dmax(r__5,r__6)) {

/*              ==== Deflatable ==== */
/*              ==== 可缩并的情况 ==== */

                *ns += -2;
            } else {

/*
                ==== Undeflatable. Move them up out of the way.
                .    Fortunately, STREXC does the right thing with
                .    ILST in case of a rare exchange failure. ====
*/
/*                ==== 不可缩并。将它们上移，让路。
                 *    幸运的是，STREXC 在交换失败时会处理 ILST。====
*/

                ifst = *ns;
                strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                     &ilst, &work[1], &info);
                ilst += 2;
            }
        }

/*        ==== End deflation detection loop ==== */
/*        ==== 结束缩并检测循环 ==== */

        goto L20;
    }

/*        ==== Return to Hessenberg form ==== */
/*        ==== 返回到 Hessenberg 形式 ==== */

    if (*ns == 0) {
        s = 0.f;
    }

    if (*ns < jw) {

/*
          ==== sorting diagonal blocks of T improves accuracy for
          .    graded matrices.  Bubble sort deals well with
          .    exchange failures. ====
*/
/*          ==== 对 T 的对角块排序可以提高分级矩阵的精度。
 *          .    冒泡排序在处理交换失败时表现良好。====
*/

        sorted = FALSE_;
        i__ = *ns + 1;
L30:
        if (sorted) {
            goto L50;
        }
        sorted = TRUE_;

        kend = i__ - 1;
        i__ = infqr + 1;
        if (i__ == *ns) {
            k = i__ + 1;
        } else if (t[i__ + 1 + i__ * t_dim1] == 0.f) {
            k = i__ + 1;
        } else {
            k = i__ + 2;
        }
L40:
    ```python`
        # 如果 k 小于等于 kend，则执行以下操作
        if (k <= kend) {
            # 如果 k 等于 i__ + 1，则计算 evi
            if (k == i__ + 1) {
                evi = (r__1 = t[i__ + i__ * t_dim1], dabs(r__1));
            } else {
                # 否则根据给定公式计算 evi
                evi = (r__3 = t[i__ + i__ * t_dim1], dabs(r__3)) + sqrt((r__1
                    = t[i__ + 1 + i__ * t_dim1], dabs(r__1))) * sqrt((
                    r__2 = t[i__ + (i__ + 1) * t_dim1], dabs(r__2)));
            }
    
            # 如果 k 等于 kend，则计算 evk
            if (k == kend) {
                evk = (r__1 = t[k + k * t_dim1], dabs(r__1));
            } else if (t[k + 1 + k * t_dim1] == 0.f) {
                # 如果 t[k + 1 + k * t_dim1] 等于 0，则计算 evk
                evk = (r__1 = t[k + k * t_dim1], dabs(r__1));
            } else {
                # 否则根据给定公式计算 evk
                evk = (r__3 = t[k + k * t_dim1], dabs(r__3)) + sqrt((r__1 = t[
                    k + 1 + k * t_dim1], dabs(r__1))) * sqrt((r__2 = t[k
                    + (k + 1) * t_dim1], dabs(r__2)));
            }
    
            # 根据 evi 和 evk 的比较结果更新 i__
            if (evi >= evk) {
                i__ = k;
            } else {
                # 设置 sorted 为 FALSE，并确定 ifst 和 ilst 的值
                sorted = FALSE_;
                ifst = i__;
                ilst = k;
                # 调用 strexc_ 函数交换矩阵 t 的特定部分
                strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                     &ilst, &work[1], &info);
                # 根据 strexc_ 的执行结果更新 i__
                if (info == 0) {
                    i__ = ilst;
                } else {
                    i__ = k;
                }
            }
    
            # 根据 i__ 的值更新 k 的值
            if (i__ == kend) {
                k = i__ + 1;
            } else if (t[i__ + 1 + i__ * t_dim1] == 0.f) {
                k = i__ + 1;
            } else {
                k = i__ + 2;
            }
            # 跳转到标签 L40 继续执行循环
            goto L40;
        }
        # 如果 k 大于 kend，则跳转到标签 L30 结束循环
        goto L30;
L50:
    ;
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__ = jw;
L60:
    if (i__ >= infqr + 1) {
    // 如果 i__ 大于等于 infqr + 1，则执行以下操作
    if (i__ == infqr + 1) {
        // 如果 i__ 等于 infqr + 1，则将 t[i__, i__] 的值赋给 sr[kwtop + i__ - 1]，si[kwtop + i__ - 1] 设为 0
        sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
        si[kwtop + i__ - 1] = 0.f;
        // 减小 i__
        --i__;
    } else if (t[i__ + (i__ - 1) * t_dim1] == 0.f) {
        // 如果 t[i__, i__-1] 的值为 0，则将 t[i__, i__] 的值赋给 sr[kwtop + i__ - 1]，si[kwtop + i__ - 1] 设为 0
        sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
        si[kwtop + i__ - 1] = 0.f;
        // 减小 i__
        --i__;
    } else {
        // 否则，进行奇异值分解，将结果存储在 sr 和 si 数组中
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];
        cc = t[i__ + (i__ - 1) * t_dim1];
        bb = t[i__ - 1 + i__ * t_dim1];
        dd = t[i__ + i__ * t_dim1];
        slanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        // 减小 i__ 以便下一次循环
        i__ += -2;
    }
    // 转到标签 L60 处继续执行
    goto L60;
    }

    if (*ns < jw || s == 0.f) {
    // 如果 ns 小于 jw 或者 s 等于 0，则执行以下操作
    if (*ns > 1 && s != 0.f) {

/*           ==== Reflect spike back into lower triangle ==== */

        // 复制 v 数组中的部分数据到 work 数组
        scopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        beta = work[1];
        // 对 work 数组进行反射变换，结果存储在 t 数组中
        slarfg_(ns, &beta, &work[2], &c__1, &tau);
        work[1] = 1.f;

        // 设置矩阵 t 的部分元素为零
        i__1 = jw - 2;
        i__2 = jw - 2;
        slaset_("L", &i__1, &i__2, &c_b29, &c_b29, &t[t_dim1 + 3], ldt);

        // 对 t 和 v 进行哈尔德变换，结果存储在 h 数组和 work 数组中
        slarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        slarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        slarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        // 对 t 矩阵进行哈尔德分解，结果存储在 t 数组和 work 数组中
        i__1 = *lwork - jw;
        sgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== Copy updated reduced window into place ==== */

    // 如果 kwtop 大于 1，则将 s * v[v_dim1 + 1] 的值赋给 h__[kwtop + (kwtop - 1) * h_dim1]
    if (kwtop > 1) {
        h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
    }
    // 复制 t 数组的一部分数据到 h__ 数组
    slacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    scopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    // 如果 ns 大于 1 并且 s 不等于 0，则对 t 和 v 进行乘法更新，结果存储在 h__ 和 work 数组中
    if (*ns > 1 && s != 0.f) {
        i__1 = *lwork - jw;
        sormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== Update vertical slab in H ==== */

    // 如果 *wantt 为真，则 ltop 设为 1；否则设为 *ktop
    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
// 计算 kln，即 *nv 和 kwtop - krow 的最小值
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
// 对 h__ 和 v 进行乘法运算，结果存储在 wv 数组中
        sgemm_("N", "N", &kln, &jw, &jw, &c_b15, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b29, &wv[wv_offset],
            ldwv);
// 复制 wv 数组的一部分数据到 h__ 数组
        slacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L70: */
    }
/*        ==== Update horizontal slab in H ==== */

    if (*wantt) {
        /* Loop over columns of H in horizontal slabs */
        i__2 = *n;
        i__1 = *nh;
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
            /* Compute the size of the current slab */
            /* Computing MIN */
            i__3 = *nh, i__4 = *n - kcol + 1;
            kln = min(i__3,i__4);
            /* Perform matrix-matrix multiplication */
            sgemm_("C", "N", &jw, &kln, &jw, &c_b15, &v[v_offset], ldv, &
                h__[kwtop + kcol * h_dim1], ldh, &c_b29, &t[t_offset],
                ldt);
            /* Copy computed result back to H */
            slacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
                 h_dim1], ldh);
        /* L80: */
        }
    }

/*        ==== Update vertical slab in Z ==== */

    if (*wantz) {
        /* Loop over rows of Z in vertical slabs */
        i__1 = *ihiz;
        i__2 = *nv;
        for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
             i__2) {
            /* Compute the size of the current slab */
            /* Computing MIN */
            i__3 = *nv, i__4 = *ihiz - krow + 1;
            kln = min(i__3,i__4);
            /* Perform matrix-matrix multiplication */
            sgemm_("N", "N", &kln, &jw, &jw, &c_b15, &z__[krow + kwtop *
                z_dim1], ldz, &v[v_offset], ldv, &c_b29, &wv[
                wv_offset], ldwv);
            /* Copy computed result back to Z */
            slacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
                kwtop * z_dim1], ldz);
        /* L90: */
        }
    }

/*     ==== Return the number of deflations ... ==== */

    *nd = jw - *ns;

/*
       ==== ... and the number of shifts. (Subtracting
       .    INFQR from the spike length takes care
       .    of the case of a rare QR failure while
       .    calculating eigenvalues of the deflation
       .    window.)  ====
*/

    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */

    work[1] = (real) lwkopt;

/*     ==== End of SLAQR2 ==== */

    return 0;
} /* slaqr2_ */

/* Subroutine */ int slaqr3_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, real *h__, integer *ldh,
    integer *iloz, integer *ihiz, real *z__, integer *ldz, integer *ns,
    integer *nd, real *sr, real *si, real *v, integer *ldv, integer *nh,
    real *t, integer *ldt, integer *nv, real *wv, integer *ldwv, real *
    work, integer *lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;

    /* Local variables */
    static integer i__, j, k;
    static real s, aa, bb, cc, dd, cs, sn;
    static integer jw;
    static real evi, evk, foo;
    static integer kln;
    static real tau, ulp;
    static integer lwk1, lwk2, lwk3;
    static real beta;
    static integer kend, kcol, info, nmin, ifst, ilst, ltop, krow;
    static logical bulge;
    extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
        integer *, real *, real *, integer *, real *), sgemm_(
        char *, char *, integer *, integer *, integer *, real *, real *,
        integer *, real *, integer *, real *, real *, integer *);
    static integer infqr;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    ! 外部函数声明：复制数组的子程序
    static integer kwtop;
    ! 静态变量声明：kwtop，可能是某种整数型变量
    extern /* Subroutine */ int slanv2_(real *, real *, real *, real *, real *
        , real *, real *, real *, real *, real *);
    ! 外部函数声明：计算特定对称双对角化问题的子程序
    extern /* Subroutine */ int slaqr4_(logical *, logical *, integer *, integer *, integer *, real *, integer *,
        real *, real *, integer *, integer *, real *, integer *, real *, integer *, integer *);
    ! 外部函数声明：计算特定特征值问题的子程序
    extern /* Subroutine */ int slabad_(real *, real *);
    ! 外部函数声明：生成机器精度相关参数的子程序
    extern doublereal slamch_(char *);
    ! 外部函数声明：返回机器参数的浮点函数
    extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *);
    ! 外部函数声明：计算特定型矩阵的高纽氏约化的子程序
    static real safmin;
    ! 静态变量声明：safmin，可能是机器下界
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 外部函数声明：返回特定环境参数的整型函数
    static real safmax;
    ! 静态变量声明：safmax，可能是机器上界
    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *);
    ! 外部函数声明：生成特定反射系数的子程序
    extern /* Subroutine */ int slahqr_(logical *, logical *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, integer *,
        real *, integer *, integer *);
    ! 外部函数声明：计算特定双实对称-三对角型矩阵的特征值的子程序
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, integer *, real *, integer *);
    ! 外部函数声明：复制矩阵的子程序
    extern /* Subroutine */ int slaset_(
        char *, integer *, integer *, real *, real *, real *, integer *);
    ! 外部函数声明：设置矩阵元素为特定值的子程序
    static logical sorted;
    ! 静态变量声明：sorted，可能是逻辑型变量，表示排序状态
    extern /* Subroutine */ int strexc_(char *, integer *, real *, integer *,
        real *, integer *, integer *, integer *, real *, integer *);
    ! 外部函数声明：交换矩阵块的子程序
    extern /* Subroutine */ int sormhr_(char *, char *, integer *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);
    ! 外部函数声明：应用特定正交矩阵到矩阵的乘法的子程序
    static real smlnum;
    ! 静态变量声明：smlnum，可能是机器小数
    static integer lwkopt;
    ! 静态变量声明：lwkopt，可能是工作空间的最优尺寸
/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

    /* Parameter adjustments */
    // 设置矩阵 H 和 Z 的维数
    h_dim1 = *ldh;
    // 计算 h__ 数组的偏移量
    h_offset = 1 + h_dim1;
    // 调整 h__ 数组的指针以匹配实际的数据布局
    h__ -= h_offset;
    // 设置矩阵 Z 的维数
    z_dim1 = *ldz;
    // 计算 z__ 数组的偏移量
    z_offset = 1 + z_dim1;
    // 调整 z__ 数组的指针以匹配实际的数据布局
    z__ -= z_offset;
    // 调整 sr 数组的指针以匹配实际的数据布局
    --sr;
    // 调整 si 数组的指针以匹配实际的数据布局
    --si;
    // 设置矩阵 V 的维数
    v_dim1 = *ldv;
    // 计算 v 数组的偏移量
    v_offset = 1 + v_dim1;
    // 调整 v 数组的指针以匹配实际的数据布局
    v -= v_offset;
    // 设置矩阵 T 的维数
    t_dim1 = *ldt;
    // 计算 t 数组的偏移量
    t_offset = 1 + t_dim1;
    // 调整 t 数组的指针以匹配实际的数据布局
    t -= t_offset;
    // 设置矩阵 WV 的维数
    wv_dim1 = *ldwv;
    // 计算 wv 数组的偏移量
    wv_offset = 1 + wv_dim1;
    // 调整 wv 数组的指针以匹配实际的数据布局
    wv -= wv_offset;
    // 调整 work 数组的指针以匹配实际的数据布局
    --work;

    /* Function Body */
/* Computing MIN */
    // 计算 jw 取 *nw 和 *kbot - *ktop + 1 的最小值
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    // 如果 jw 小于等于 2，则设置 lwkopt 为 1
    if (jw <= 2) {
    lwkopt = 1;
    } else {

/*        ==== Workspace query call to SGEHRD ==== */

    // 对 SGEHRD 的工作空间进行查询调用
    i__1 = jw - 1;
    sgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
        c_n1, &info);
    // 获取 SGEHRD 所需的最小工作空间
    lwk1 = (integer) work[1];

/*        ==== Workspace query call to SORMHR ==== */

    // 对 SORMHR 的工作空间进行查询调用
    i__1 = jw - 1;
    sormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
         &v[v_offset], ldv, &work[1], &c_n1, &info);
    // 获取 SORMHR 所需的最小工作空间
    lwk2 = (integer) work[1];

/*        ==== Workspace query call to SLAQR4 ==== */

    // 对 SLAQR4 的工作空间进行查询调用
    slaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[1],
        &si[1], &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &
        infqr);
    // 获取 SLAQR4 所需的最小工作空间
    lwk3 = (integer) work[1];

/*
          ==== Optimal workspace ====

   Computing MAX
*/
    // 计算最优工作空间的大小
    i__1 = jw + max(lwk1,lwk2);
    lwkopt = max(i__1,lwk3);
    }

/*     ==== Quick return in case of workspace query. ==== */

    // 如果 *lwork == -1，表示进行工作空间查询，直接返回所需最小工作空间
    if (*lwork == -1) {
    work[1] = (real) lwkopt;
    return 0;
    }

/*
       ==== Nothing to do ...
       ... for an empty active block ... ====
*/
    // 对于空活动块，不需要执行任何操作
    *ns = 0;
    *nd = 0;
    work[1] = 1.f;
    // 如果 *ktop > *kbot，则直接返回
    if (*ktop > *kbot) {
    return 0;
    }
/*     ... nor for an empty deflation window. ==== */
    // 对于空的减缩窗口，不需要执行任何操作
    if (*nw < 1) {
    return 0;
    }

/*     ==== Machine constants ==== */

    // 计算机器常数：安全最小值
    safmin = slamch_("SAFE MINIMUM");
    // 计算机器常数：安全最大值的倒数
    safmax = 1.f / safmin;
    // 调整 safmin 和 safmax 以匹配实际的计算机器常数
    slabad_(&safmin, &safmax);
    // 计算机器常数：ulp（最小精度单位）
    ulp = slamch_("PRECISION");
    // 计算机器常数：smlnum
    smlnum = safmin * ((real) (*n) / ulp);

/*
       ==== Setup deflation window ====

   Computing MIN
*/
    // 设置减缩窗口的大小
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    // 计算减缩窗口的起始位置
    kwtop = *kbot - jw + 1;
    // 如果 kwtop == *ktop，则设置 s 为 0
    if (kwtop == *ktop) {
    s = 0.f;
    } else {
    s = h__[kwtop + (kwtop - 1) * h_dim1];
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

    // 对于 1x1 的减缩窗口，执行相应操作
    sr[kwtop] = h__[kwtop + kwtop * h_dim1];
    si[kwtop] = 0.f;
    *ns = 1;
    *nd = 0;
/* Computing MAX */
    // 计算并比较 s 的绝对值和相应的机器常数
    r__2 = smlnum, r__3 = ulp * (r__1 = h__[kwtop + kwtop * h_dim1], dabs(
        r__1));
    if (dabs(s) <= dmax(r__2,r__3)) {
        *ns = 0;
        *nd = 1;
        if (kwtop > *ktop) {
        h__[kwtop + (kwtop - 1) * h_dim1] = 0.f;
        }
    }
    work[1] = 1.f;
    return 0;
    }
/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/

/*
   复制上三角部分到矩阵 t，并将下三角部分复制到 t 的第二行和第三行中
*/
slacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
        ldt);

/*
   复制 h__ 矩阵的第一列（除了第一个元素）到 t 的第二行，用于后续计算
*/
i__1 = jw - 1;
i__2 = *ldh + 1;
i__3 = *ldt + 1;
scopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
       i__3);

/*
   初始化 v 矩阵为零矩阵
*/
slaset_("A", &jw, &jw, &c_b29, &c_b15, &v[v_offset], ldv);

/*
   计算 ILAENV 函数确定的 nmin 值，用于后续的计算
*/
nmin = ilaenv_(&c__12, "SLAQR3", "SV", &jw, &c__1, &jw, lwork, (ftnlen)6,
               (ftnlen)2);

/*
   根据 jw 和 nmin 的大小关系选择 slaqr4 或 slahqr 函数进行计算
*/
if (jw > nmin) {
    slaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
            kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &work[1],
            lwork, &infqr);
} else {
    slahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
            kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
}

/*
   ==== STREXC needs a clean margin near the diagonal ====
*/

/*
   将 t 矩阵中除了对角线和其相邻的两个下三角元素外的其它元素置零
*/
i__1 = jw - 3;
for (j = 1; j <= i__1; ++j) {
    t[j + 2 + j * t_dim1] = 0.f;
    t[j + 3 + j * t_dim1] = 0.f;
}

/*
   如果 jw 大于 2，则将 t 矩阵的倒数第二行最后一个元素置零
*/
if (jw > 2) {
    t[jw + (jw - 2) * t_dim1] = 0.f;
}

/*
   ==== Deflation detection loop ====
*/

/*
   初始化 *ns 为 jw，表示当前未被排除的矩阵维度
*/
*ns = jw;
ilst = infqr + 1;
L20:
if (ilst <= *ns) {
    if (*ns == 1) {
        bulge = FALSE_;
    } else {
        bulge = t[*ns + (*ns - 1) * t_dim1] != 0.f;
    }

    /*
       ==== Small spike tip test for deflation ====
    */

    /*
       如果 bulge 为假，则表示是一个实特征值，进行相关判断
    */
    if (! bulge) {

        /*
           ==== Real eigenvalue ====
        */

        foo = (r__1 = t[*ns + *ns * t_dim1], dabs(r__1));
        if (foo == 0.f) {
            foo = dabs(s);
        }

        /*
           计算判断条件，用于判断是否进行排除
        */
        if ((r__1 = s * v[*ns * v_dim1 + 1], dabs(r__1)) <= dmax(smlnum,
            ulp * foo)) {

            /*
               ==== Deflatable ====
            */

            --(*ns);
        } else {

            /*
               ==== Undeflatable.   Move it up out of the way.
               .    (STREXC can not fail in this case.) ====
            */

            ifst = *ns;
            strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                    &ilst, &work[1], &info);
            ++ilst;
        }
    } else {

        /*
           ==== Complex conjugate pair ====
        */

        foo = (r__3 = t[*ns + *ns * t_dim1], dabs(r__3)) + sqrt((r__1 = t[
                *ns + (*ns - 1) * t_dim1], dabs(r__1))) * sqrt((r__2 = t[
                *ns - 1 + *ns * t_dim1], dabs(r__2)));
        if (foo == 0.f) {
            foo = dabs(s);
        }

        /*
           计算判断条件，用于判断是否进行排除
        */
        if (dmax((r__1 = s * v[*ns * v_dim1 + 1], dabs(r__1)), (r__2 =
                s * v[(*ns - 1) * v_dim1 + 1], dabs(r__2))) <= dmax(smlnum,
                ulp * foo)) {

            /*
               ==== Deflatable ====
            */

            *ns += -2;
        } else {
/*
        ==== Undeflatable. Move them up out of the way.
        .    Fortunately, STREXC does the right thing with
        .    ILST in case of a rare exchange failure. ====
*/

ifst = *ns;
// 设置ifst为当前处理的子矩阵的起始列索引

strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
     &ilst, &work[1], &info);
// 调用STREXC函数进行特征值交换，处理第jw个特征向量，更新t矩阵和v矩阵，
// ifst表示要交换的起始列，ilst是返回的交换结束的列，work是工作数组，info是返回的状态信息

ilst += 2;
// 更新ilst，使其指向下一个未处理的列

}

/*        ==== End deflation detection loop ==== */

goto L20;
// 跳转到标号L20处继续执行

}

/*        ==== Return to Hessenberg form ==== */

if (*ns == 0) {
// 如果*ns为0，即没有剩余的未处理列
s = 0.f;
// 将s置为0
}

if (*ns < jw) {

/*
      ==== sorting diagonal blocks of T improves accuracy for
      .    graded matrices.  Bubble sort deals well with
      .    exchange failures. ====
*/

sorted = FALSE_;
// 初始化sorted标志为假

i__ = *ns + 1;
// 设置i__为*ns + 1

L30:
if (sorted) {
    goto L50;
}
sorted = TRUE_;
// 标志位设置为真

kend = i__ - 1;
// 设置kend为i__ - 1
i__ = infqr + 1;
// 设置i__为infqr + 1

if (i__ == *ns) {
    k = i__ + 1;
} else if (t[i__ + 1 + i__ * t_dim1] == 0.f) {
    k = i__ + 1;
} else {
    k = i__ + 2;
}
// 根据条件设置k的值

L40:
if (k <= kend) {
    if (k == i__ + 1) {
    evi = (r__1 = t[i__ + i__ * t_dim1], dabs(r__1));
    } else {
    evi = (r__3 = t[i__ + i__ * t_dim1], dabs(r__3)) + sqrt((r__1
        = t[i__ + 1 + i__ * t_dim1], dabs(r__1))) * sqrt((
        r__2 = t[i__ + (i__ + 1) * t_dim1], dabs(r__2)));
    }
    // 计算evi特征值

    if (k == kend) {
    evk = (r__1 = t[k + k * t_dim1], dabs(r__1));
    } else if (t[k + 1 + k * t_dim1] == 0.f) {
    evk = (r__1 = t[k + k * t_dim1], dabs(r__1));
    } else {
    evk = (r__3 = t[k + k * t_dim1], dabs(r__3)) + sqrt((r__1 = t[
        k + 1 + k * t_dim1], dabs(r__1))) * sqrt((r__2 = t[k
        + (k + 1) * t_dim1], dabs(r__2)));
    }
    // 计算evk特征值

    if (evi >= evk) {
    i__ = k;
    } else {
    sorted = FALSE_;
    ifst = i__;
    ilst = k;
    strexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
         &ilst, &work[1], &info);
    // 调用STREXC函数进行特征值交换，更新ifst和ilst，并更新t矩阵和v矩阵

    if (info == 0) {
        i__ = ilst;
    } else {
        i__ = k;
    }
    }
    if (i__ == kend) {
    k = i__ + 1;
    } else if (t[i__ + 1 + i__ * t_dim1] == 0.f) {
    k = i__ + 1;
    } else {
    k = i__ + 2;
    }
    goto L40;
}
goto L30;
// 继续执行标号L30处的循环

L50:
;
}

/*     ==== Restore shift/eigenvalue array from T ==== */

i__ = jw;
// 将i__设置为jw

L60:
if (i__ >= infqr + 1) {
if (i__ == infqr + 1) {
    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
    si[kwtop + i__ - 1] = 0.f;
    --i__;
} else if (t[i__ + (i__ - 1) * t_dim1] == 0.f) {
    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
    si[kwtop + i__ - 1] = 0.f;
    --i__;
    // 将计算得到的特征值存储到sr和si数组中
    } else {
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];
        cc = t[i__ + (i__ - 1) * t_dim1];
        bb = t[i__ - 1 + i__ * t_dim1];
        dd = t[i__ + i__ * t_dim1];
        slanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        i__ += -2;
    }
    goto L60;
    }



    } else {
        # 当前分支处理条件不满足时的代码块
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];  # 访问矩阵 t 中的元素 aa
        cc = t[i__ + (i__ - 1) * t_dim1];      # 访问矩阵 t 中的元素 cc
        bb = t[i__ - 1 + i__ * t_dim1];        # 访问矩阵 t 中的元素 bb
        dd = t[i__ + i__ * t_dim1];            # 访问矩阵 t 中的元素 dd
        # 调用 slanv2_ 函数处理给定的四个输入值，并更新输出参数
        slanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        # 更新循环索引 i__
        i__ += -2;
    }
    # 跳转至标签 L60 处继续执行
    goto L60;
    }
/*           ==== Reflect spike back into lower triangle ==== */

        // 将反射的尖峰反射回下三角部分

        scopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        beta = work[1];
        slarfg_(ns, &beta, &work[2], &c__1, &tau);
        work[1] = 1.f;

        i__1 = jw - 2;
        i__2 = jw - 2;
        slaset_("L", &i__1, &i__2, &c_b29, &c_b29, &t[t_dim1 + 3], ldt);

        slarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        slarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        slarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        i__1 = *lwork - jw;
        sgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== Copy updated reduced window into place ==== */

    // 将更新后的减少窗口复制到指定位置

    if (kwtop > 1) {
        h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
    }
    slacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    scopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    // 如果需要，累积正交矩阵以更新 H 和 Z

    if (*ns > 1 && s != 0.f) {
        i__1 = *lwork - jw;
        sormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== Update vertical slab in H ==== */

    // 更新 H 中的垂直板块

    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
/* Computing MIN */
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
        sgemm_("N", "N", &kln, &jw, &jw, &c_b15, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b29, &wv[wv_offset],
            ldwv);
        slacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L70: */
    }

/*        ==== Update horizontal slab in H ==== */

    // 更新 H 中的水平板块

    if (*wantt) {
        i__2 = *n;
        i__1 = *nh;
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
/* Computing MIN */
        i__3 = *nh, i__4 = *n - kcol + 1;
        kln = min(i__3,i__4);
        sgemm_("C", "N", &jw, &kln, &jw, &c_b15, &v[v_offset], ldv, &
            h__[kwtop + kcol * h_dim1], ldh, &c_b29, &t[t_offset],
             ldt);
        slacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
             h_dim1], ldh);
/* L80: */
        }
    }

/*        ==== Update vertical slab in Z ==== */

    // 更新 Z 中的垂直板块

    if (*wantz) {
        i__1 = *ihiz;
        i__2 = *nv;
        for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
             i__2) {
/* Computing MIN */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
        kln = min(i__3,i__4);
        sgemm_("N", "N", &kln, &jw, &jw, &c_b15, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b29, &wv[
            wv_offset], ldwv);
        slacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
/* L90: */
        }
    }
    }

/* L90: */
    /* 计算 kln 的值，即 nv 和 ihiz - krow + 1 的较小值，用于矩阵运算 */
    i__3 = *nv, i__4 = *ihiz - krow + 1;
    kln = min(i__3,i__4);

    /* 对称广义矩阵乘法，计算 wv = c_b15 * Z * V */
    sgemm_("N", "N", &kln, &jw, &jw, &c_b15, &z__[krow + kwtop *
        z_dim1], ldz, &v[v_offset], ldv, &c_b29, &wv[
        wv_offset], ldwv);

    /* 复制 wv 到 Z 的相应位置 */
    slacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
        kwtop * z_dim1], ldz);

    /* 结束内循环 */
    }
}
}

/*     ==== Return the number of deflations ... ==== */

*nd = jw - *ns;

/*
   ==== ... and the number of shifts. (Subtracting
   .    INFQR from the spike length takes care
   .    of the case of a rare QR failure while
   .    calculating eigenvalues of the deflation
   .    window.)  ====
*/

*ns -= infqr;

/*      ==== Return optimal workspace. ==== */

work[1] = (real) lwkopt;

/*     ==== End of SLAQR3 ==== */

return 0;
} /* slaqr3_ */

/* Subroutine */ int slaqr4_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, real *h__, integer *ldh, real *wr, real *
    wi, integer *iloz, integer *ihiz, real *z__, integer *ldz, real *work,
     integer *lwork, integer *info)
{
/* 局部变量声明 */
/* System generated locals */
integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
real r__1, r__2, r__3, r__4;

/* Local variables */
static integer i__, k;
static real aa, bb, cc, dd;
static integer ld;
static real cs;
static integer nh, it, ks, kt;
static real sn;
static integer ku, kv, ls, ns;
static real ss;
static integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl,
    kbot, nmin;
static real swap;
static integer ktop;
static real zdum[1]    /* was [1][1] */;
static integer kacc22, itmax, nsmax, nwmax, kwtop;
extern /* Subroutine */ int slaqr2_(logical *, logical *, integer *,
    integer *, integer *, integer *, real *, integer *, integer *,
    integer *, real *, integer *, integer *, integer *, real *, real *
    , real *, integer *, integer *, real *, integer *, integer *,
    real *, integer *, real *, integer *), slanv2_(real *, real *,
    real *, real *, real *, real *, real *, real *, real *, real *);
extern /* Subroutine */ int slaqr5_(logical *, logical *, integer *, integer *,
    integer *, integer *, integer *, real *, real *, real *, integer *, integer *
    , integer *, real *, integer *, real *, integer *, real *,
    integer *, integer *, real *, integer *, integer *, real *,
    integer *);
static integer nibble;
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static char jbcmpz[2];
extern /* Subroutine */ int slahqr_(logical *, logical *, integer *,
    integer *, integer *, real *, integer *, real *, real *, integer *
    , integer *, real *, integer *, integer *), slacpy_(char *,
    integer *, integer *, real *, integer *, real *, integer *);
static integer nwupbd;
    # 定义静态逻辑变量 sorted，用于标识数据是否已排序
    static logical sorted;
    # 定义静态整数变量 lwkopt，用于存储工作区数组的长度
    static integer lwkopt;
/*
*/
    /* 参数调整 */
    h_dim1 = *ldh;                           // 获取 ldh 的值，即 h 的第一维度大小
    h_offset = 1 + h_dim1;                   // 计算 h__ 数据的偏移量
    h__ -= h_offset;                         // 调整 h__ 指针，使其指向正确的数据起始位置
    --wr;                                    // 将 wr 指针向前移动一个位置
    --wi;                                    // 将 wi 指针向前移动一个位置
    z_dim1 = *ldz;                           // 获取 ldz 的值，即 z 的第一维度大小
    z_offset = 1 + z_dim1;                   // 计算 z__ 数据的偏移量
    z__ -= z_offset;                         // 调整 z__ 指针，使其指向正确的数据起始位置
    --work;                                  // 将 work 指针向前移动一个位置

    /* 函数体 */
    *info = 0;                               // 初始化 info 变量为 0

/*     ==== N = 0 时的快速返回：无需操作。==== */

    if (*n == 0) {                           // 如果 n 等于 0
    work[1] = 1.f;                           // 设置 work 数组的第一个元素为 1.0
    return 0;                                 // 返回 0
    }

    if (*n <= 11) {

/*        ==== 微小矩阵必须使用 SLAHQR。==== */

    lwkopt = 1;                               // 设置 lwkopt 为 1
    if (*lwork != -1) {                       // 如果 lwork 不等于 -1
        slahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
            wi[1], iloz, ihiz, &z__[z_offset], ldz, info);
    }
    } else {

/*
          ==== 对于大于微小矩阵的情况，使用多重移位的小突起 QR 分解，
          .    并对较大矩阵进行早期的积极缩小。====

          ==== 希望一切顺利。====
*/

    *info = 0;                                // 重新初始化 info 变量为 0

/*        ==== 设置 ILAENV 的作业标志。==== */

    if (*wantt) {                             // 如果 wantt 为真
        *(unsigned char *)jbcmpz = 'S';        // 设置 jbcmpz 的第一个字符为 'S'
    } else {
        *(unsigned char *)jbcmpz = 'E';        // 设置 jbcmpz 的第一个字符为 'E'
    }
    if (*wantz) {                             // 如果 wantz 为真
        *(unsigned char *)&jbcmpz[1] = 'V';    // 设置 jbcmpz 的第二个字符为 'V'
    } else {
        *(unsigned char *)&jbcmpz[1] = 'N';    // 设置 jbcmpz 的第二个字符为 'N'
    }

/*
          ==== NWR = 推荐的缩小窗口大小。此时，N > NTINY = 11，
          .    因此有足够的次对角线空间使得 NWR >= 2。
          .    （事实上，有足够的次对角线空间使得 NWR >= 3。）====
*/

    nwr = ilaenv_(&c__13, "SLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
    nwr = max(2,nwr);
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
    nwr = min(i__1,nwr);

/*
          ==== NSR = 推荐的同时移位数目。
          .    此时 N > NTINY = 11，因此有足够的次对角线空间使得 NSR 是偶数
          .    且大于或等于 2。====
*/

    nsr = ilaenv_(&c__15, "SLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;
    nsr = min(i__1,i__2);
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;
    nsr = max(i__1,i__2);

/*
          ==== 估计最优工作空间 ====

          ==== SLAQR2 的工作空间查询调用。====
*/

    i__1 = nwr + 1;
    slaqr2_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
        h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset],
        ldh, &work[1], &c_n1);

/*
          ==== 最优工作空间 = MAX(SLAQR5, SLAQR2) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1];
    lwkopt = max(i__1,i__2);

/*        ==== 在工作空间查询情况下的快速返回。==== */

    if (*lwork == -1) {
        work[1] = (real) lwkopt;
        return 0;
    }

/*        ==== SLAHQR/SLAQR0 的交叉点 ==== */
    # 调用外部函数 ilaenv_ 来获取一个整数值，用于设定 nmin 的初始值
    nmin = ilaenv_(&c__12, "SLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
        6, (ftnlen)2);
    # 将 nmin 设定为 11 和 ilaenv_ 函数返回值中的较大者
    nmin = max(11,nmin);
/*        ==== Nibble crossover point ==== */

    // 调用ilaenv_函数获取SLAQR4算法的特定参数值，用于决定“nibble”值
    nibble = ilaenv_(&c__14, "SLAQR4", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 将“nibble”值设为非负数
    nibble = max(0,nibble);

/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

    // 调用ilaenv_函数获取SLAQR4算法的特定参数值，用于决定“kacc22”值
    kacc22 = ilaenv_(&c__16, "SLAQR4", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 将“kacc22”值设为非负数
    kacc22 = max(0,kacc22);
    // 将“kacc22”值限制在0到2之间
    kacc22 = min(2,kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/
    // 计算最大可能的缩小窗口尺寸，确保有足够的工作空间
    i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
    nwmax = min(i__1,i__2);
    // 将“nw”值设为“nwmax”
    nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/
    // 计算最大可能的同时位移数，确保有足够的工作空间
    i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
    nsmax = min(i__1,i__2);
    // 将“nsmax”设为偶数
    nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

    // 设定迭代次数计数器，用于在缩小窗口时重新启动
    ndfl = 1;

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/
    // 计算迭代次数上限
    i__1 = 10, i__2 = *ihi - *ilo + 1;
    itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

    // 标记当前活动块的最后一行和最后一列
    kbot = *ihi;

/*        ==== Main Loop ==== */

    // 主循环，执行最多“itmax”次
    i__1 = itmax;
    for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

        // 当“kbot”小于“ilo”时跳出循环
        if (kbot < *ilo) {
        goto L90;
        }

/*           ==== Locate active block ==== */

        // 确定当前活动块的位置
        i__2 = *ilo + 1;
        for (k = kbot; k >= i__2; --k) {
        // 如果对角线元素为零，跳转至L20
        if (h__[k + (k - 1) * h_dim1] == 0.f) {
            goto L20;
        }
/* L10: */
        }
        k = *ilo;
L20:
        // 标记当前活动块的顶部和底部
        ktop = k;

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

        // 计算当前可能的缩小窗口大小
        nh = kbot - ktop + 1;
        nwupbd = min(nh,nwmax);
        // 根据迭代次数决定缩小窗口的大小
        if (ndfl < 5) {
        nw = min(nwupbd,nwr);
        } else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
/* 将 nwupbd 和 nw << 1 中的较小值赋给 nw */
        nw = min(i__2,i__3);
/* 如果 nw 小于 nwmax，则执行以下条件 */
        }
/* 如果 nw 小于 nwmax，则执行以下条件 */
        if (nw < nwmax) {
/* 如果 nw 大于等于 nh - 1，则执行以下条件 */
        if (nw >= nh - 1) {
/* 将 nw 设置为 nh */
            nw = nh;
/* 否则执行以下条件 */
        } else {
/* 将 kwtop 设置为 kbot - nw + 1 */
            kwtop = kbot - nw + 1;
/* 如果 h__[kwtop + (kwtop - 1) * h_dim1] 的绝对值大于 h__[kwtop - 1 + (kwtop - 2) * h_dim1] 的绝对值，则执行以下条件 */
            if ((r__1 = h__[kwtop + (kwtop - 1) * h_dim1], dabs(r__1))
                 > (r__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1],
                dabs(r__2))) {
/* nw 增加 1 */
            ++nw;
            }
        }
        }
/* 如果 ndfl 小于 5，则执行以下条件 */
        if (ndfl < 5) {
/* 将 ndec 设置为 -1 */
        ndec = -1;
/* 否则如果 ndec 大于等于 0 或 nw 大于等于 nwupbd，则执行以下条件 */
        } else if (ndec >= 0 || nw >= nwupbd) {
/* ndec 增加 1 */
        ++ndec;
/* 如果 nw - ndec 小于 2，则将 ndec 设置为 0 */
        if (nw - ndec < 2) {
            ndec = 0;
        }
/* nw 减去 ndec */
        nw -= ndec;
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

/* kv 设置为 *n - nw + 1 */
        kv = *n - nw + 1;
/* kt 设置为 nw + 1 */
        kt = nw + 1;
/* nho 设置为 *n - nw - 1 - kt + 1 */
        nho = *n - nw - 1 - kt + 1;
/* kwv 设置为 nw + 2 */
        kwv = nw + 2;
/* nve 设置为 *n - nw - kwv + 1 */
        nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

/* 调用 slaqr2_ 函数 */
        slaqr2_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
             &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

/* kbot 减去 ld */
        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

/* ks 设置为 kbot - ls + 1 */
        ks = kbot - ls + 1;

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

/* 如果 ld 为 0 或 ld * 100 小于等于 nw * nibble 且 kbot - ktop + 1 大于 min(nmin,nwmax)，则执行以下条件 */
        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if SLAQR2
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* 将 2 和 kbot - ktop 中的较大值赋给 i__4 */
        i__4 = 2, i__5 = kbot - ktop;
/* 将 nsmax 和 nsr 中的较小值赋给 i__2 */
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
/* 将 i__3 和 i__2 中的较小值赋给 ns */
        ns = min(i__2,i__3);
/* ns 减去 ns 除以 2 的余数 */
        ns -= ns % 2;

/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    SLAQR2 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
        if (ndfl % 6 == 0) {
            ks = kbot - ns + 1;
            // 计算 MAX
            i__3 = ks + 1, i__4 = ktop + 2;
            i__2 = max(i__3,i__4);
            // 循环处理每个 i__
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
                // 计算 ss，aa，bb，cc，dd
                ss = (r__1 = h__[i__ + (i__ - 1) * h_dim1], dabs(r__1)
                    ) + (r__2 = h__[i__ - 1 + (i__ - 2) * h_dim1],
                     dabs(r__2));
                aa = ss * .75f + h__[i__ + i__ * h_dim1];
                bb = ss;
                cc = ss * -.4375f;
                dd = aa;
                // 调用 SLANV2 函数
                slanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
                    , &wr[i__], &wi[i__], &cs, &sn);
                // L30 标签处
            }
            if (ks == ktop) {
                // 处理 ks == ktop 的情况
                wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
                wi[ks + 1] = 0.f;
                wr[ks] = wr[ks + 1];
                wi[ks] = wi[ks + 1];
            }
        } else {

            /*
                           ==== Got NS/2 or fewer shifts? Use SLAHQR
                           .    on a trailing principal submatrix to
                           .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                           .    there is enough space below the subdiagonal
                           .    to fit an NS-by-NS scratch array.) ====
            */

            if (kbot - ks + 1 <= ns / 2) {
                // 更新 ks
                ks = kbot - ns + 1;
                // 设置 kt
                kt = *n - ns + 1;
                // 复制矩阵
                slacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
                    h__[kt + h_dim1], ldh);
                // 调用 SLAHQR 函数
                slahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[kt
                    + h_dim1], ldh, &wr[ks], &wi[ks], &c__1, &
                    c__1, zdum, &c__1, &inf);
                // 更新 ks
                ks += inf;

                /*
                              ==== In case of a rare QR failure use
                              .    eigenvalues of the trailing 2-by-2
                              .    principal submatrix.  ====
                */

                if (ks >= kbot) {
                    // 处理 ks >= kbot 的情况
                    aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
                    cc = h__[kbot + (kbot - 1) * h_dim1];
                    bb = h__[kbot - 1 + kbot * h_dim1];
                    dd = h__[kbot + kbot * h_dim1];
                    // 调用 SLANV2 函数
                    slanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
                        kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
                        ;
                    // 更新 ks
                    ks = kbot - 1;
                }
            }

            if (kbot - ks + 1 > ns) {

                /*
                              ==== Sort the shifts (Helps a little)
                              .    Bubble sort keeps complex conjugate
                              .    pairs together. ====
                */
/*

            sorted = FALSE_;
            // 初始化 sorted 标志为假，用于记录是否已经排序
            i__2 = ks + 1;
            // 设置循环的终止条件为 ks + 1
            for (k = kbot; k >= i__2; --k) {
                // 从 kbot 向 ks + 1 循环，每次递减 k
                if (sorted) {
                // 如果已经排序过，跳转到标签 L60
                goto L60;
                }
                sorted = TRUE_;
                // 标记已经排序过
                i__3 = k - 1;
                // 设置内层循环的终止条件为 k - 1
                for (i__ = ks; i__ <= i__3; ++i__) {
                // 从 ks 开始到 k - 1 的循环，每次递增 i__
                if ((r__1 = wr[i__], dabs(r__1)) + (r__2 = wi[
                    i__], dabs(r__2)) < (r__3 = wr[i__ +
                    1], dabs(r__3)) + (r__4 = wi[i__ + 1],
                     dabs(r__4))) {
                    sorted = FALSE_;

                    // 交换 wr[i__] 和 wr[i__ + 1]
                    swap = wr[i__];
                    wr[i__] = wr[i__ + 1];
                    wr[i__ + 1] = swap;

                    // 交换 wi[i__] 和 wi[i__ + 1]
                    swap = wi[i__];
                    wi[i__] = wi[i__ + 1];
                    wi[i__ + 1] = swap;
                }
/* L40: */
                }
/* L50: */
            }
L60:
            ;
            // 标签 L60

/*

                   ==== Shuffle shifts into pairs of real shifts
                   .    and pairs of complex conjugate shifts
                   .    assuming complex conjugate shifts are
                   .    already adjacent to one another. (Yes,
                   .    they are.)  ====

            // 将移位数对整理成实数移位对和共轭复数移位对，假设共轭复数移位对已经相邻。 （是的，它们是。）

            i__2 = ks + 2;
            // 设置循环的终止条件为 ks + 2
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
            // 从 kbot 向 ks + 2 循环，每次递减 2
            if (wi[i__] != -wi[i__ - 1]) {

                // 交换 wr[i__], wr[i__ - 1], wr[i__ - 2]
                swap = wr[i__];
                wr[i__] = wr[i__ - 1];
                wr[i__ - 1] = wr[i__ - 2];
                wr[i__ - 2] = swap;

                // 交换 wi[i__], wi[i__ - 1], wi[i__ - 2]
                swap = wi[i__];
                wi[i__] = wi[i__ - 1];
                wi[i__ - 1] = wi[i__ - 2];
                wi[i__ - 2] = swap;
            }
/* L70: */
            }

        }

/*

                ==== If there are only two shifts and both are
                .    real, then use only one.  ====

            // 如果只有两个移位数，且都是实数，则只使用一个。

        if (kbot - ks + 1 == 2) {
            // 如果移位数的数量为 2
            if (wi[kbot] == 0.f) {
            // 如果最后一个移位数是实数
            if ((r__1 = wr[kbot] - h__[kbot + kbot * h_dim1],
                dabs(r__1)) < (r__2 = wr[kbot - 1] - h__[kbot
                + kbot * h_dim1], dabs(r__2))) {
                wr[kbot - 1] = wr[kbot];
            } else {
                wr[kbot] = wr[kbot - 1];
            }
            }
        }

/*

                ==== Use up to NS of the smallest magnatiude
                .    shifts.  If there aren't NS shifts available,
                .    then use them all, possibly dropping one to
                .    make the number of shifts even. ====

   Computing MIN
*/

        // 使用最小数量的移位数 NS。如果可用的移位数少于 NS，则使用所有可用的移位数，可能减少一个以保证移位数为偶数。
        i__2 = ns, i__3 = kbot - ks + 1;
        // 计算 NS 和 kbot - ks + 1 的较小值
        ns = min(i__2,i__3);
        // 将 ns 减去 ns 与 2 的余数
        ns -= ns % 2;
        // 重新计算 ks
        ks = kbot - ns + 1;
/*
                ==== Small-bulge multi-shift QR sweep:
                .    split workspace under the subdiagonal into
                .    - a KDU-by-KDU work array U in the lower
                .      left-hand-corner,
                .    - a KDU-by-at-least-KDU-but-more-is-better
                .      (KDU-by-NHo) horizontal work array WH along
                .      the bottom edge,
                .    - and an at-least-KDU-but-more-is-better-by-KDU
                .      (NVE-by-KDU) vertical work array WV along
                .      the left-hand-edge. ====
*/



        kdu = ns * 3 - 3;
        ku = *n - kdu + 1;
        kwh = kdu + 1;
        nho = *n - kdu - 3 - (kdu + 1) + 1;
        kwv = kdu + 4;
        nve = *n - kdu - kwv + 1;

/*
        // 计算工作空间尺寸和偏移量
        kdu = ns * 3 - 3;  // 计算 KDU 的大小
        ku = *n - kdu + 1;  // 计算 U 左下角的工作数组的起始行
        kwh = kdu + 1;  // 计算 WH 水平工作数组的起始列
        nho = *n - kdu - 3 - (kdu + 1) + 1;  // 计算 NHo 水平工作数组的高度
        kwv = kdu + 4;  // 计算 WV 垂直工作数组的起始行
        nve = *n - kdu - kwv + 1;  // 计算 NVe 垂直工作数组的宽度
*/

/*
              ==== Small-bulge multi-shift QR sweep ====
*/



        slaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks],
            &wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
            z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku +
            kwh * h_dim1], ldh);
    static integer krcol, nbmps;
    extern /* Subroutine */ int strmm_(char *, char *, char *, char *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        ),
        slaqr1_(integer *, real *, integer *, real *, real *, real *, real *, real *);
    extern doublereal slamch_(char *);
    static real safmin;
    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *);
    static real safmax;
    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *),
        slaset_(char *, integer *, integer *, real *, real *, real *, integer *);
    static real refsum;
    static integer mstart;
    static real smlnum;



    static integer krcol, nbmps;
    声明静态整型变量 krcol 和 nbmps，它们在整个程序的生命周期内保持其值不变。

    extern /* Subroutine */ int strmm_(char *, char *, char *, char *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        ),
        slaqr1_(integer *, real *, integer *, real *, real *, real *, real *, real *);
    声明两个外部子程序的原型：
    - strmm_：一个计算矩阵乘积的子程序，接受多个参数，包括字符型和整数型，返回一个实数型结果。
    - slaqr1_：一个计算特定矩阵特征值的子程序，接受多个整数和实数参数。

    extern doublereal slamch_(char *);
    声明一个外部函数的原型：
    - slamch_：返回一个双精度浮点数，其行为基于传入的字符参数。

    static real safmin;
    声明静态实数型变量 safmin，用于在程序中存储一个最小安全数。

    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *);
    声明一个外部子程序的原型：
    - slarfg_：计算一个特殊的元素的不同表现形式。

    static real safmax;
    声明静态实数型变量 safmax，用于在程序中存储一个最大安全数。

    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *),
        slaset_(char *, integer *, integer *, real *, real *, real *, integer *);
    声明两个外部子程序的原型：
    - slacpy_：复制一个矩阵或者设置一个矩阵中的一部分元素。
    - slaset_：设置一个矩阵中的一部分元素。

    static real refsum;
    声明静态实数型变量 refsum，用于在程序中存储一个参考总和。

    static integer mstart;
    声明静态整型变量 mstart，用于在程序中存储一个开始标记。

    static real smlnum;
    声明静态实数型变量 smlnum，用于在程序中存储一个小数。
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
*/

/* Parameter adjustments */
--sr;
--si;
h_dim1 = *ldh;
h_offset = 1 + h_dim1;
h__ -= h_offset;
z_dim1 = *ldz;
z_offset = 1 + z_dim1;
z__ -= z_offset;
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;
u_dim1 = *ldu;
u_offset = 1 + u_dim1;
u -= u_offset;
wv_dim1 = *ldwv;
wv_offset = 1 + wv_dim1;
wv -= wv_offset;
wh_dim1 = *ldwh;
wh_offset = 1 + wh_dim1;
wh -= wh_offset;

/* Function Body */
if (*nshfts < 2) {
    return 0;
}

/*
   ==== If the active block is empty or 1-by-1, then there
   .    is nothing to do. ====
*/

if (*ktop >= *kbot) {
    return 0;
}

/*
   ==== Shuffle shifts into pairs of real shifts and pairs
   .    of complex conjugate shifts assuming complex
   .    conjugate shifts are already adjacent to one
   .    another. ====
*/

i__1 = *nshfts - 2;
for (i__ = 1; i__ <= i__1; i__ += 2) {
    if (si[i__] != -si[i__ + 1]) {

        swap = sr[i__];
        sr[i__] = sr[i__ + 1];
        sr[i__ + 1] = sr[i__ + 2];
        sr[i__ + 2] = swap;

        swap = si[i__];
        si[i__] = si[i__ + 1];
        si[i__ + 1] = si[i__ + 2];
        si[i__ + 2] = swap;
    }
    /* L10: */
}

/*
   ==== NSHFTS is supposed to be even, but if it is odd,
   .    then simply reduce it by one.  The shuffle above
   .    ensures that the dropped shift is real and that
   .    the remaining shifts are paired. ====
*/

ns = *nshfts - *nshfts % 2;

/*     ==== Machine constants for deflation ==== */

safmin = slamch_("SAFE MINIMUM");
safmax = 1.f / safmin;
slabad_(&safmin, &safmax);
ulp = slamch_("PRECISION");
smlnum = safmin * ((real) (*n) / ulp);

/*
   ==== Use accumulated reflections to update far-from-diagonal
   .    entries ? ====
*/

accum = *kacc22 == 1 || *kacc22 == 2;

/*     ==== If so, exploit the 2-by-2 block structure? ==== */

blk22 = ns > 2 && *kacc22 == 2;

/*     ==== clear trash ==== */

if (*ktop + 2 <= *kbot) {
    h__[*ktop + 2 + *ktop * h_dim1] = 0.f;
}

/*     ==== NBMPS = number of 2-shift bulges in the chain ==== */

nbmps = ns / 2;

/*     ==== KDU = width of slab ==== */

kdu = nbmps * 6 - 3;

/*     ==== Create and chase chains of NBMPS bulges ==== */

i__1 = *kbot - 2;
i__2 = nbmps * 3 - 2;
for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 :
    incol <= i__1; incol += i__2) {
    ndcol = incol + kdu;
    if (accum) {
        slaset_("ALL", &kdu, &kdu, &c_b29, &c_b15, &u[u_offset], ldu);
    }
}
    /*
              ==== Near-the-diagonal bulge chase.  The following loop
              .    performs the near-the-diagonal part of a small bulge
              .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
              .    chunk extends from column INCOL to column NDCOL
              .    (including both column INCOL and column NDCOL). The
              .    following loop chases a 3*NBMPS column long chain of
              .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
              .    may be less than KTOP and and NDCOL may be greater than
              .    KBOT indicating phantom columns from which to chase
              .    bulges before they are actually introduced or to which
              .    to chase bulges beyond column KBOT.)  ====

       Computing MIN
    */
    i__4 = incol + nbmps * 3 - 3, i__5 = *kbot - 2;
    i__3 = min(i__4,i__5);
    for (krcol = incol; krcol <= i__3; ++krcol) {

    /*
                 ==== Bulges number MTOP to MBOT are active double implicit
                 .    shift bulges.  There may or may not also be small
                 .    2-by-2 bulge, if there is room.  The inactive bulges
                 .    (if any) must wait until the active bulges have moved
                 .    down the diagonal to make room.  The phantom matrix
                 .    paradigm described above helps keep track.  ====

       Computing MAX
    */
        i__4 = 1, i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
        mtop = max(i__4,i__5);
    /* Computing MIN */
        i__4 = nbmps, i__5 = (*kbot - krcol) / 3;
        mbot = min(i__4,i__5);
        m22 = mbot + 1;
        bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

    /*
                 ==== Generate reflections to chase the chain right
                 .    one column.  (The minimum value of K is KTOP-1.) ====
    */

        i__4 = mbot;
        for (m = mtop; m <= i__4; ++m) {
            k = krcol + (m - 1) * 3;
            if (k == *ktop - 1) {
                slaqr1_(&c__3, &h__[*ktop + *ktop * h_dim1], ldh, &sr[(m
                    << 1) - 1], &si[(m << 1) - 1], &sr[m * 2], &si[m *
                     2], &v[m * v_dim1 + 1]);
                alpha = v[m * v_dim1 + 1];
                slarfg_(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m *
                    v_dim1 + 1]);
            } else {
                beta = h__[k + 1 + k * h_dim1];
                v[m * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
                v[m * v_dim1 + 3] = h__[k + 3 + k * h_dim1];
                slarfg_(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m *
                    v_dim1 + 1]);

    /*
                       ==== A Bulge may collapse because of vigilant
                       .    deflation or destructive underflow.  In the
                       .    underflow case, try the two-small-subdiagonals
                       .    trick to try to reinflate the bulge.  ====
    */

                if (h__[k + 3 + k * h_dim1] != 0.f || h__[k + 3 + (k + 1)
                    * h_dim1] != 0.f || h__[k + 3 + (k + 2) * h_dim1]
                    == 0.f) {
/*                    ==== Typical case: not collapsed (yet). ==== */

/* 设置 H 矩阵中的特定位置的值 */
h__[k + 1 + k * h_dim1] = beta;
/* 将其他相关位置的值设置为0 */
h__[k + 2 + k * h_dim1] = 0.f;
h__[k + 3 + k * h_dim1] = 0.f;
} else {

/*
                      ==== Atypical case: collapsed.  Attempt to
                      .    reintroduce ignoring H(K+1,K) and H(K+2,K).
                      .    If the fill resulting from the new
                      .    reflector is too large, then abandon it.
                      .    Otherwise, use the new one. ====
*/

/* 调用 slaqr1 函数处理 H 矩阵的变形，以生成新的反射器 */
slaqr1_(&c__3, &h__[k + 1 + (k + 1) * h_dim1], ldh, &
    sr[(m << 1) - 1], &si[(m << 1) - 1], &sr[m *
    2], &si[m * 2], vt);
/* 提取处理后的反射系数 */
alpha = vt[0];
/* 调用 slarfg 函数生成新的反射器 */
slarfg_(&c__3, &alpha, &vt[1], &c__1, vt);
/* 计算反射的和 */
refsum = vt[0] * (h__[k + 1 + k * h_dim1] + vt[1] *
    h__[k + 2 + k * h_dim1]);

/* 判断是否生成新的反射器会导致填充过大 */
if ((r__1 = h__[k + 2 + k * h_dim1] - refsum * vt[1],
    dabs(r__1)) + (r__2 = refsum * vt[2], dabs(
    r__2)) > ulp * ((r__3 = h__[k + k * h_dim1],
    dabs(r__3)) + (r__4 = h__[k + 1 + (k + 1) *
    h_dim1], dabs(r__4)) + (r__5 = h__[k + 2 + (k
    + 2) * h_dim1], dabs(r__5)))) {

/*
                         ==== Starting a new bulge here would
                         .    create non-negligible fill.  Use
                         .    the old one with trepidation. ====
*/

/* 如果填充过大，则保留原有的反射器 */
h__[k + 1 + k * h_dim1] = beta;
h__[k + 2 + k * h_dim1] = 0.f;
h__[k + 3 + k * h_dim1] = 0.f;
} else {

/*
                         ==== Stating a new bulge here would
                         .    create only negligible fill.
                         .    Replace the old reflector with
                         .    the new one. ====
*/

/* 如果填充不大，则使用新生成的反射器替换旧的 */
h__[k + 1 + k * h_dim1] -= refsum;
h__[k + 2 + k * h_dim1] = 0.f;
h__[k + 3 + k * h_dim1] = 0.f;
v[m * v_dim1 + 1] = vt[0];
v[m * v_dim1 + 2] = vt[1];
v[m * v_dim1 + 3] = vt[2];
}
}
}
/* L20: */
}
/*           ==== Generate a 2-by-2 reflection, if needed. ==== */

/* 计算反射矩阵的列索引 */
k = krcol + (m22 - 1) * 3;
/* 如果需要生成2x2的反射矩阵 */
if (bmp22) {
    /* 检查是否需要在顶部生成反射 */
    if (k == *ktop - 1) {
        /* 生成2x2的反射变换 */
        slaqr1_(&c__2, &h__[k + 1 + (k + 1) * h_dim1], ldh, &sr[(
            m22 << 1) - 1], &si[(m22 << 1) - 1], &sr[m22 * 2],
             &si[m22 * 2], &v[m22 * v_dim1 + 1]);
        beta = v[m22 * v_dim1 + 1];
        /* 执行反射变换 */
        slarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22
            * v_dim1 + 1]);
    } else {
        /* 获取反射变换的参数 */
        beta = h__[k + 1 + k * h_dim1];
        v[m22 * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
        /* 执行反射变换 */
        slarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22
            * v_dim1 + 1]);
        h__[k + 1 + k * h_dim1] = beta;
        h__[k + 2 + k * h_dim1] = 0.f;
    }
}

/*           ==== Multiply H by reflections from the left ==== */

/* 如果需要累积乘法 */
if (accum) {
    jbot = min(ndcol,*kbot);
} else if (*wantt) {
    jbot = *n;
} else {
    jbot = *kbot;
}
/* 循环遍历 H 矩阵的列 */
i__4 = jbot;
for (j = max(*ktop,krcol); j <= i__4; ++j) {
    /* 计算 m 的上限 */
    /* Computing MIN */
    i__5 = mbot, i__6 = (j - krcol + 2) / 3;
    mend = min(i__5,i__6);
    /* 循环遍历每个 m */
    i__5 = mend;
    for (m = mtop; m <= i__5; ++m) {
        k = krcol + (m - 1) * 3;
        /* 计算反射的和 */
        refsum = v[m * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] + v[
            m * v_dim1 + 2] * h__[k + 2 + j * h_dim1] + v[m *
            v_dim1 + 3] * h__[k + 3 + j * h_dim1]);
        /* 执行乘法 */
        h__[k + 1 + j * h_dim1] -= refsum;
        h__[k + 2 + j * h_dim1] -= refsum * v[m * v_dim1 + 2];
        h__[k + 3 + j * h_dim1] -= refsum * v[m * v_dim1 + 3];
    }
}

/* 如果存在2x2的反射矩阵 */
if (bmp22) {
    k = krcol + (m22 - 1) * 3;
    /* 计算 j 的下限 */
    /* Computing MAX */
    i__4 = k + 1;
    i__5 = jbot;
    /* 循环遍历每个 j */
    for (j = max(i__4,*ktop); j <= i__5; ++j) {
        /* 计算反射的和 */
        refsum = v[m22 * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] +
            v[m22 * v_dim1 + 2] * h__[k + 2 + j * h_dim1]);
        /* 执行乘法 */
        h__[k + 1 + j * h_dim1] -= refsum;
        h__[k + 2 + j * h_dim1] -= refsum * v[m22 * v_dim1 + 2];
    }
}

/*
     ==== Multiply H by reflections from the right.
     .    Delay filling in the last row until the
     .    vigilant deflation check is complete. ====
*/

/* 如果需要累积乘法 */
if (accum) {
    jtop = max(*ktop,incol);
} else if (*wantt) {
    jtop = 1;
} else {
    jtop = *ktop;
}
/* 循环遍历每个 m */
i__5 = mbot;
for (m = mtop; m <= i__5; ++m) {
    /* 如果第一个元素不为0 */
    if (v[m * v_dim1 + 1] != 0.f) {
        k = krcol + (m - 1) * 3;
/* Computing MIN */
/* 计算两个数的最小值，*kbot和k + 3 */
i__6 = *kbot, i__7 = k + 3;
/* 取最小值 */
i__4 = min(i__6,i__7);
/* 对于每个j从jtop到计算得到的最小值i__4，执行以下操作 */
for (j = jtop; j <= i__4; ++j) {
    /* 计算引用总和 */
    refsum = v[m * v_dim1 + 1] * (h__[j + (k + 1) * h_dim1] + v[m * v_dim1 + 2] * h__[j + (k + 2) * h_dim1] + v[m * v_dim1 + 3] * h__[j + (k + 3) * h_dim1]);
    /* 更新h__矩阵 */
    h__[j + (k + 1) * h_dim1] -= refsum;
    h__[j + (k + 2) * h_dim1] -= refsum * v[m * v_dim1 + 2];
    h__[j + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 + 3];
    /* L60: */
}

if (accum) {

    /*
              ==== Accumulate U. (If necessary, update Z later
              .    with an efficient matrix-matrix
              .    multiply.) ====
    */

    /* 计算kms */
    kms = k - incol;
    /* Computing MAX */
    i__4 = 1, i__6 = *ktop - incol;
    i__7 = kdu;
    /* 对于每个j从max(i__4,i__6)到i__7，执行以下操作 */
    for (j = max(i__4,i__6); j <= i__7; ++j) {
        /* 计算引用总和 */
        refsum = v[m * v_dim1 + 1] * (u[j + (kms + 1) * u_dim1] + v[m * v_dim1 + 2] * u[j + (kms + 2) * u_dim1] + v[m * v_dim1 + 3] * u[j + (kms + 3) * u_dim1]);
        /* 更新u矩阵 */
        u[j + (kms + 1) * u_dim1] -= refsum;
        u[j + (kms + 2) * u_dim1] -= refsum * v[m * v_dim1 + 2];
        u[j + (kms + 3) * u_dim1] -= refsum * v[m * v_dim1 + 3];
        /* L70: */
    }
} else if (*wantz) {

    /*
              ==== U is not accumulated, so update Z
              .    now by multiplying by reflections
              .    from the right. ====
    */

    i__7 = *ihiz;
    /* 对于每个j从*iloz到i__7，执行以下操作 */
    for (j = *iloz; j <= i__7; ++j) {
        /* 计算引用总和 */
        refsum = v[m * v_dim1 + 1] * (z__[j + (k + 1) * z_dim1] + v[m * v_dim1 + 2] * z__[j + (k + 2) * z_dim1] + v[m * v_dim1 + 3] * z__[j + (k + 3) * z_dim1]);
        /* 更新z矩阵 */
        z__[j + (k + 1) * z_dim1] -= refsum;
        z__[j + (k + 2) * z_dim1] -= refsum * v[m * v_dim1 + 2];
        z__[j + (k + 3) * z_dim1] -= refsum * v[m * v_dim1 + 3];
        /* L80: */
    }
}
}

/* L90: */
}

/*           ==== Special case: 2-by-2 reflection (if needed) ==== */

/* 计算k */
k = krcol + (m22 - 1) * 3;
if (bmp22 && v[m22 * v_dim1 + 1] != 0.f) {
/* Computing MIN */
i__7 = *kbot, i__4 = k + 3;
i__5 = min(i__7,i__4);
/* 对于每个j从jtop到计算得到的最小值i__5，执行以下操作 */
for (j = jtop; j <= i__5; ++j) {
    /* 计算引用总和 */
    refsum = v[m22 * v_dim1 + 1] * (h__[j + (k + 1) * h_dim1] + v[m22 * v_dim1 + 2] * h__[j + (k + 2) * h_dim1]);
    /* 更新h__矩阵 */
    h__[j + (k + 1) * h_dim1] -= refsum;
    h__[j + (k + 2) * h_dim1] -= refsum * v[m22 * v_dim1 + 2];
    /* L100: */
}

if (accum) {
    kms = k - incol;
/* Computing MAX */
/* 计算最大值 */
            i__5 = 1, i__7 = *ktop - incol;
            i__4 = kdu;
            for (j = max(i__5,i__7); j <= i__4; ++j) {
/* 遍历循环，j从max(i__5,i__7)开始，直到i__4结束 */
            refsum = v[m22 * v_dim1 + 1] * (u[j + (kms + 1) *
                u_dim1] + v[m22 * v_dim1 + 2] * u[j + (kms +
                2) * u_dim1]);
/* 计算refsum的值 */
            u[j + (kms + 1) * u_dim1] -= refsum;
/* 更新u矩阵的值 */
            u[j + (kms + 2) * u_dim1] -= refsum * v[m22 * v_dim1
                + 2];
/* 更新u矩阵的值 */
/* L110: */
            }
/* 结束for循环 */
        } else if (*wantz) {
/* 否则，如果wantz为真 */
            i__4 = *ihiz;
            for (j = *iloz; j <= i__4; ++j) {
/* 遍历循环，j从*iloz到*ihiz结束 */
            refsum = v[m22 * v_dim1 + 1] * (z__[j + (k + 1) *
                z_dim1] + v[m22 * v_dim1 + 2] * z__[j + (k +
                2) * z_dim1]);
/* 计算refsum的值 */
            z__[j + (k + 1) * z_dim1] -= refsum;
/* 更新z矩阵的值 */
            z__[j + (k + 2) * z_dim1] -= refsum * v[m22 * v_dim1
                + 2];
/* 更新z矩阵的值 */
/* L120: */
            }
/* 结束for循环 */
        }
/* 结束else if条件 */

/*           ==== Vigilant deflation check ==== */
/* 严格的下降检查 */

        mstart = mtop;
/* 设置mstart为mtop */
        if (krcol + (mstart - 1) * 3 < *ktop) {
/* 如果krcol + (mstart - 1) * 3小于ktop，则执行下面操作 */
        ++mstart;
/* mstart增加1 */
        }
/* 结束if条件 */
        mend = mbot;
/* 设置mend为mbot */
        if (bmp22) {
/* 如果bmp22为真 */
        ++mend;
/* mend增加1 */
        }
/* 结束if条件 */
        if (krcol == *kbot - 2) {
/* 如果krcol等于*kbot - 2 */
        ++mend;
/* mend增加1 */
        }
/* 结束if条件 */
        i__4 = mend;
/* 设置循环上限为mend */
        for (m = mstart; m <= i__4; ++m) {
/* 遍历循环，m从mstart到i__4结束 */
/* Computing MIN */
/* 计算最小值 */
        i__5 = *kbot - 1, i__7 = krcol + (m - 1) * 3;
        k = min(i__5,i__7);
/* 设置k为i__5和i__7的最小值 */
/* 进行下面的收敛测试要求，需要满足传统的小于相邻对角线的标准和Ahues&Tisseur(LAWN 122, 1997)标准 */

/*
                ==== The following convergence test requires that
                .    the tradition small-compared-to-nearby-diagonals
                .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
                .    criteria both be satisfied.  The latter improves
                .    accuracy in some examples. Falling back on an
                .    alternate convergence criterion when TST1 or TST2
                .    is zero (as done here) is traditional but probably
                .    unnecessary. ====
*/

        if (h__[k + 1 + k * h_dim1] != 0.f) {
/* 如果h__[k + 1 + k * h_dim1]不等于0 */
            tst1 = (r__1 = h__[k + k * h_dim1], dabs(r__1)) + (r__2 =
                h__[k + 1 + (k + 1) * h_dim1], dabs(r__2));
/* 计算tst1的值 */
            if (tst1 == 0.f) {
/* 如果tst1等于0 */
            if (k >= *ktop + 1) {
/* 如果k大于等于*ktop + 1 */
                tst1 += (r__1 = h__[k + (k - 1) * h_dim1], dabs(
                    r__1));
/* tst1增加h__[k + (k - 1) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            if (k >= *ktop + 2) {
/* 如果k大于等于*ktop + 2 */
                tst1 += (r__1 = h__[k + (k - 2) * h_dim1], dabs(
                    r__1));
/* tst1增加h__[k + (k - 2) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            if (k >= *ktop + 3) {
/* 如果k大于等于*ktop + 3 */
                tst1 += (r__1 = h__[k + (k - 3) * h_dim1], dabs(
                    r__1));
/* tst1增加h__[k + (k - 3) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            if (k <= *kbot - 2) {
/* 如果k小于等于*kbot - 2 */
                tst1 += (r__1 = h__[k + 2 + (k + 1) * h_dim1],
                    dabs(r__1));
/* tst1增加h__[k + 2 + (k + 1) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            if (k <= *kbot - 3) {
/* 如果k小于等于*kbot - 3 */
                tst1 += (r__1 = h__[k + 3 + (k + 1) * h_dim1],
                    dabs(r__1));
/* tst1增加h__[k + 3 + (k + 1) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            if (k <= *kbot - 4) {
/* 如果k小于等于*kbot - 4 */
                tst1 += (r__1 = h__[k + 4 + (k + 1) * h_dim1],
                    dabs(r__1));
/* tst1增加h__[k + 4 + (k + 1) * h_dim1]的绝对值 */
            }
/* 结束if条件 */
            }
/* 结束if条件 */
            /* 计算 MAX */
            r__2 = smlnum, r__3 = ulp * tst1;
            // 如果 h__[k + 1 + k * h_dim1] 的绝对值小于等于 dmax(r__2, r__3)
            if ((r__1 = h__[k + 1 + k * h_dim1], dabs(r__1)) <= dmax(
                r__2,r__3)) {
                /* 计算 MAX */
                r__3 = (r__1 = h__[k + 1 + k * h_dim1], dabs(r__1)),
                    r__4 = (r__2 = h__[k + (k + 1) * h_dim1],
                    dabs(r__2));
                // 计算 h12 的最大值
                h12 = dmax(r__3,r__4);
                /* 计算 MIN */
                r__3 = (r__1 = h__[k + 1 + k * h_dim1], dabs(r__1)),
                    r__4 = (r__2 = h__[k + (k + 1) * h_dim1],
                    dabs(r__2));
                // 计算 h21 的最小值
                h21 = dmin(r__3,r__4);
                /* 计算 MAX */
                r__3 = (r__1 = h__[k + 1 + (k + 1) * h_dim1], dabs(
                    r__1)), r__4 = (r__2 = h__[k + k * h_dim1] -
                    h__[k + 1 + (k + 1) * h_dim1], dabs(r__2));
                // 计算 h11 的最大值
                h11 = dmax(r__3,r__4);
                /* 计算 MIN */
                r__3 = (r__1 = h__[k + 1 + (k + 1) * h_dim1], dabs(
                    r__1)), r__4 = (r__2 = h__[k + k * h_dim1] -
                    h__[k + 1 + (k + 1) * h_dim1], dabs(r__2));
                // 计算 h22 的最小值
                h22 = dmin(r__3,r__4);
                // 计算 scl
                scl = h11 + h12;
                // 计算 tst2
                tst2 = h22 * (h11 / scl);

                /* 计算 MAX */
                r__1 = smlnum, r__2 = ulp * tst2;
                // 如果 tst2 等于 0 或者 h21 * (h12 / scl) 小于等于 dmax(r__1, r__2)
                if (tst2 == 0.f || h21 * (h12 / scl) <= dmax(r__1,
                    r__2)) {
                    // 设置 h__[k + 1 + k * h_dim1] 为 0
                    h__[k + 1 + k * h_dim1] = 0.f;
                }
            }
        }
        /* L130: */
        }

/*
             ==== 填充每个突出部分的最后一行。 ====

   计算 MIN
*/
        i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
        // 计算 mend，选择较小的值作为终止条件
        mend = min(i__4,i__5);
        i__4 = mend;
        // 循环处理每个突出部分
        for (m = mtop; m <= i__4; ++m) {
            // 计算当前突出部分的起始列
            k = krcol + (m - 1) * 3;
            // 计算 refsum
            refsum = v[m * v_dim1 + 1] * v[m * v_dim1 + 3] * h__[k + 4 + (
                k + 3) * h_dim1];
            // 更新 h__ 中的值
            h__[k + 4 + (k + 1) * h_dim1] = -refsum;
            h__[k + 4 + (k + 2) * h_dim1] = -refsum * v[m * v_dim1 + 2];
            h__[k + 4 + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 + 3];
        /* L140: */
        }

/*
             ==== 接近对角线的突出部分追踪结束。 ====

   L150:
*/
    }

/*
          ==== 使用 U（如果已累积）更新 H 中远离对角线的条目。
          .    如果需要，也使用 U 来更新 Z。 ====
*/

    if (accum) {
        // 如果要求更新 T
        if (*wantt) {
            // 设置 jtop 和 jbot
            jtop = 1;
            jbot = *n;
        } else {
            // 设置 jtop 和 jbot
            jtop = *ktop;
            jbot = *kbot;
        }
        // 如果不利用 U 的 2x2 块结构进行更新，或者在特殊情况下（引入突出部分或从底部追逐突出部分），或者 NS <= 2
        if (! blk22 || incol < *ktop || ndcol > *kbot || ns <= 2) {

/*
                ==== 不利用 U 的 2x2 块结构进行更新。 K1 和 NU 跟踪 U 在引入突出部分和追逐突出部分时的特殊位置和大小。在这些特殊情况和 NS = 2 的情况下，没有 2x2 块结构可供利用。 ====

   计算 MAX
*/
        i__3 = 1, i__4 = *ktop - incol;
        // 计算 k1，选择较大的值作为起始条件
        k1 = max(i__3,i__4);
/* Computing MAX */
/* 计算 nu 的值，其中 nu 是水平乘积的维度 */
i__3 = 0, i__4 = ndcol - *kbot;
nu = kdu - max(i__3,i__4) - k1 + 1;

/* ==== Horizontal Multiply ==== */
/* 水平乘积部分 */

i__3 = jbot;
i__4 = *nh;
for (jcol = min(ndcol,*kbot) + 1; i__4 < 0 ? jcol >= i__3 :
    jcol <= i__3; jcol += i__4) {
    /* Computing MIN */
    /* 计算 jlen，它是当前水平乘积的列长度 */
    i__5 = *nh, i__7 = jbot - jcol + 1;
    jlen = min(i__5,i__7);

    /* 进行矩阵乘法操作 sgemm */
    sgemm_("C", "N", &nu, &jlen, &nu, &c_b15, &u[k1 + k1 *
        u_dim1], ldu, &h__[incol + k1 + jcol * h_dim1],
        ldh, &c_b29, &wh[wh_offset], ldwh);

    /* 将结果复制回原始矩阵 h__ */
    slacpy_("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h__[
        incol + k1 + jcol * h_dim1], ldh);
    /* L160: */
}

/* ==== Vertical multiply ==== */
/* 垂直乘积部分 */

i__4 = max(*ktop,incol) - 1;
i__3 = *nv;
for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
    jrow += i__3) {
    /* Computing MIN */
    /* 计算 jlen，它是当前垂直乘积的行长度 */
    i__5 = *nv, i__7 = max(*ktop,incol) - jrow;
    jlen = min(i__5,i__7);

    /* 进行矩阵乘法操作 sgemm */
    sgemm_("N", "N", &jlen, &nu, &nu, &c_b15, &h__[jrow + (
        incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1],
        ldu, &c_b29, &wv[wv_offset], ldwv);

    /* 将结果复制回原始矩阵 h__ */
    slacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h__[
        jrow + (incol + k1) * h_dim1], ldh);
    /* L170: */
}

/* ==== Z multiply (also vertical) ==== */
/* Z 矩阵的乘积部分，同时也是垂直乘积 */

if (*wantz) {
    /* 如果需要计算 Z 矩阵 */
    i__3 = *ihiz;
    i__4 = *nv;
    for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
         jrow += i__4) {
        /* Computing MIN */
        /* 计算 jlen，它是当前 Z 矩阵乘积的行长度 */
        i__5 = *nv, i__7 = *ihiz - jrow + 1;
        jlen = min(i__5,i__7);

        /* 进行矩阵乘法操作 sgemm */
        sgemm_("N", "N", &jlen, &nu, &nu, &c_b15, &z__[jrow +
            (incol + k1) * z_dim1], ldz, &u[k1 + k1 *
            u_dim1], ldu, &c_b29, &wv[wv_offset], ldwv);

        /* 将结果复制回原始矩阵 Z__ */
        slacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z__[
            jrow + (incol + k1) * z_dim1], ldz);
        /* L180: */
    }
} else {
    /* 如果不需要计算 Z 矩阵，执行如下更新 */

    /*
        ==== Updates exploiting U's 2-by-2 block structure.
        .    (I2, I4, J2, J4 are the last rows and columns
        .    of the blocks.) ====
    */

    /* 根据 U 的 2x2 块结构进行更新 */

    i2 = (kdu + 1) / 2;
    i4 = kdu;
    j2 = i4 - i2;
    j4 = kdu;

    /*
        ==== KZS and KNZ deal with the band of zeros
        .    along the diagonal of one of the triangular
        .    blocks. ====
    */

    /* KZS 和 KNZ 处理其中一个三角块对角线上的零带 */

    kzs = j4 - j2 - (ns + 1);
    knz = ns + 1;

    /* ==== Horizontal multiply ==== */
    /* 水平乘积部分 */

    i__4 = jbot;
    i__3 = *nh;
    for (jcol = min(ndcol,*kbot) + 1; i__3 < 0 ? jcol >= i__4 :
        jcol <= i__4; jcol += i__3) {
        /* Computing MIN */
        /* 计算 jlen，它是当前水平乘积的列长度 */
        i__5 = *nh, i__7 = jbot - jcol + 1;
        jlen = min(i__5,i__7);
/*
                   ==== Copy bottom of H to top+KZS of scratch ====
                    (The first KZS rows get multiplied by zero.) ====
*/
slacpy_("ALL", &knz, &jlen, &h__[incol + 1 + j2 + jcol *
    h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);

/*
                 ==== Multiply by U21' ====
*/
slaset_("ALL", &kzs, &jlen, &c_b29, &c_b29, &wh[wh_offset]
    , ldwh);
strmm_("L", "U", "C", "N", &knz, &jlen, &c_b15, &u[j2 + 1
    + (kzs + 1) * u_dim1], ldu, &wh[kzs + 1 + wh_dim1]
    , ldwh);

/*
                 ==== Multiply top of H by U11' ====
*/
sgemm_("C", "N", &i2, &jlen, &j2, &c_b15, &u[u_offset],
    ldu, &h__[incol + 1 + jcol * h_dim1], ldh, &c_b15,
    &wh[wh_offset], ldwh);

/*
                 ==== Copy top of H to bottom of WH ====
*/
slacpy_("ALL", &j2, &jlen, &h__[incol + 1 + jcol * h_dim1]
    , ldh, &wh[i2 + 1 + wh_dim1], ldwh);

/*
                 ==== Multiply by U21' ====
*/
strmm_("L", "L", "C", "N", &j2, &jlen, &c_b15, &u[(i2 + 1)
     * u_dim1 + 1], ldu, &wh[i2 + 1 + wh_dim1], ldwh);

/*
                 ==== Multiply by U22 ====
*/
i__5 = i4 - i2;
i__7 = j4 - j2;
sgemm_("C", "N", &i__5, &jlen, &i__7, &c_b15, &u[j2 + 1 +
    (i2 + 1) * u_dim1], ldu, &h__[incol + 1 + j2 +
    jcol * h_dim1], ldh, &c_b15, &wh[i2 + 1 + wh_dim1]
    , ldwh);

/*
                 ==== Copy it back ====
*/
slacpy_("ALL", &kdu, &jlen, &wh[wh_offset], ldwh, &h__[
    incol + 1 + jcol * h_dim1], ldh);
/* L190: */
}

/*
              ==== Vertical multiply ====
*/
i__3 = max(incol,*ktop) - 1;
i__4 = *nv;
for (jrow = jtop; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
    jrow += i__4) {
/* Computing MIN */
    i__5 = *nv, i__7 = max(incol,*ktop) - jrow;
    jlen = min(i__5,i__7);

/*
                   ==== Copy right of H to scratch (the first KZS
                   .    columns get multiplied by zero) ====
*/
slacpy_("ALL", &jlen, &knz, &h__[jrow + (incol + 1 + j2) *
     h_dim1], ldh, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

/*
                 ==== Multiply by U21 ====
*/
slaset_("ALL", &jlen, &kzs, &c_b29, &c_b29, &wv[wv_offset]
    , ldwv);
strmm_("R", "U", "N", "N", &jlen, &knz, &c_b15, &u[j2 + 1
    + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1) *
    wv_dim1 + 1], ldwv);

/*
                 ==== Multiply by U11 ====
*/
sgemm_("N", "N", &jlen, &i2, &j2, &c_b15, &h__[jrow + (
    incol + 1) * h_dim1], ldh, &u[u_offset], ldu, &
    c_b15, &wv[wv_offset], ldwv);
/*                 ==== Copy left of H to right of scratch ==== */

slacpy_("ALL", &jlen, &j2, &h__[jrow + (incol + 1) * h_dim1], ldh, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);
/* 
   将矩阵 H 的左侧数据复制到临时存储区域 wv 的右侧。
   - "ALL": 复制整个矩阵区域
   - jlen: 复制的行数
   - j2: 复制的列数
   - h__[jrow + (incol + 1) * h_dim1]: H 矩阵的起始位置
   - ldh: H 矩阵的列数维度
   - &wv[(i2 + 1) * wv_dim1 + 1]: wv 矩阵的起始位置
   - ldwv: wv 矩阵的列数维度
*/

/*                 ==== Multiply by U21 ==== */

i__5 = i4 - i2;
strmm_("R", "L", "N", "N", &jlen, &i__5, &c_b15, &u[(i2 + 1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);
/* 
   使用 BLAS 函数 strmm 对 wv 中的数据进行矩阵乘法运算。
   - "R": 右侧矩阵乘法
   - "L": 左侧矩阵乘法
   - "N": 不转置
   - &jlen: 结果矩阵的行数
   - &i__5: 结果矩阵的列数
   - &c_b15: 乘法的标量系数
   - &u[(i2 + 1) * u_dim1 + 1]: U 矩阵的起始位置
   - ldu: U 矩阵的列数维度
   - &wv[(i2 + 1) * wv_dim1 + 1]: wv 矩阵的起始位置（结果存放位置）
   - ldwv: wv 矩阵的列数维度
*/

/*                 ==== Multiply by U22 ==== */

i__5 = i4 - i2;
i__7 = j4 - j2;
sgemm_("N", "N", &jlen, &i__5, &i__7, &c_b15, &h__[jrow + (incol + 1 + j2) * h_dim1], ldh, &u[j2 + 1 + (i2 + 1) * u_dim1], ldu, &c_b15, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);
/* 
   使用 BLAS 函数 sgemm 对 h__ 和 u 中的数据进行一般矩阵乘法运算。
   - "N": 不转置
   - "N": 不转置
   - &jlen: 结果矩阵的行数
   - &i__5: h__ 矩阵的列数（结果矩阵的行数）
   - &i__7: u 矩阵的列数（结果矩阵的列数）
   - &c_b15: 乘法的标量系数
   - &h__[jrow + (incol + 1 + j2) * h_dim1]: h__ 矩阵的起始位置
   - ldh: h__ 矩阵的列数维度
   - &u[j2 + 1 + (i2 + 1) * u_dim1]: u 矩阵的起始位置
   - ldu: u 矩阵的列数维度
   - &c_b15: 乘法的标量系数（结果累加系数）
   - &wv[(i2 + 1) * wv_dim1 + 1]: wv 矩阵的起始位置（结果存放位置）
   - ldwv: wv 矩阵的列数维度
*/

/*                 ==== Copy it back ==== */

slacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h__[jrow + (incol + 1) * h_dim1], ldh);
/* 
   将临时存储区域 wv 中的数据复制回 h__ 矩阵的指定位置。
   - "ALL": 复制整个矩阵区域
   - &jlen: 复制的行数
   - &kdu: 复制的列数
   - &wv[wv_offset]: wv 矩阵的起始位置
   - ldwv: wv 矩阵的列数维度
   - &h__[jrow + (incol + 1) * h_dim1]: h__ 矩阵的起始位置
   - ldh: h__ 矩阵的列数维度
*/
/*                    ==== Copy the result back to Z ==== */

            slacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &
                z__[jrow + (incol + 1) * z_dim1], ldz);
/* L210: */
            }
        }
        }
    }
/* L220: */
    }

/*     ==== End of SLAQR5 ==== */

    return 0;
} /* slaqr5_ */

/* Subroutine */ int slarf_(char *side, integer *m, integer *n, real *v,
    integer *incv, real *tau, real *c__, integer *ldc, real *work)
{
    /* System generated locals */
    integer c_dim1, c_offset;
    real r__1;

    /* Local variables */
    static integer i__;
    static logical applyleft;
    extern /* Subroutine */ int sger_(integer *, integer *, real *, real *,
        integer *, real *, integer *, real *, integer *);
    extern logical lsame_(char *, char *);
    static integer lastc;
    extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *,
        real *, integer *, real *, integer *, real *, real *, integer *);
    static integer lastv;
    extern integer ilaslc_(integer *, integer *, real *, integer *), ilaslr_(
        integer *, integer *, real *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLARF applies a real elementary reflector H to a real m by n matrix
    C, from either the left or the right. H is represented in the form

          H = I - tau * v * v'

    where tau is a real scalar and v is a real vector.

    If tau = 0, then H is taken to be the unit matrix.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H

    M       (input) INTEGER
            The number of rows of the matrix C.

    N       (input) INTEGER
            The number of columns of the matrix C.

    V       (input) REAL array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.

    INCV    (input) INTEGER
            The increment between elements of v. INCV <> 0.

    TAU     (input) REAL
            The value tau in the representation of H.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) REAL array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'

    =====================================================================
*/


    /* Parameter adjustments */
    --v;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;

    /*
     * Copy the result from workspace back to matrix C.
     * Depending on the value of SIDE, the multiplication of H * C or C * H
     * has been computed in workspace 'work'. This step writes the result
     * back into the original matrix C.
     */
    c__ -= c_offset;
    // 减去偏移量 c_offset 的值并赋给 c__
    --work;
    // 将 work 指针向前移动一个位置

    /* Function Body */
    // 这是函数的主体部分

    // 检查 side 是否等于 "L"，返回布尔值给 applyleft
    applyleft = lsame_(side, "L");

    // 初始化 lastv 和 lastc 为零
    lastv = 0;
    lastc = 0;

    // 如果 tau 不等于 0.0（浮点数），执行以下操作
    if (*tau != 0.f) {
# 设置变量来扫描 V，LASTV 指向 V 的末尾
if (applyleft):  # 如果 applyleft 为真
    lastv = *m  # 将 lastv 设置为 m 的值
else:
    lastv = *n  # 否则将 lastv 设置为 n 的值
if (*incv > 0):  # 如果 incv 的值大于 0
    i__ = (lastv - 1) * *incv + 1  # 将 i__ 设置为 (lastv - 1) * incv + 1
else:
    i__ = 1  # 否则将 i__ 设置为 1
# 查找 V 中最后一个非零行
while(lastv > 0 and v[i__] == 0.f):
    --lastv  # lastv 减 1
    i__ -= *incv  # i__ 减去 incv 的值
if (applyleft):  # 如果 applyleft 为真
    # 扫描 C(1:lastv, :) 查找最后一个非零列
    lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc)
else:  # 否则
    # 扫描 C(:, 1:lastv) 查找最后一个非零行
    lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc)
# 注意，当 lastc 等于 0 时，BLAS 操作为空；在这个级别不需要特殊情况处理
if (applyleft):  # 如果 applyleft 为真
    # 计算 H * C
    if (lastv > 0):  # 如果 lastv 大于 0
        # 计算 w(1:lastc,1) := C(1:lastv,1:lastc)' * v(1:lastv,1)
        sgemv_("Transpose", &lastv, &lastc, &c_b15, &c__[c_offset], ldc, &
            v[1], incv, &c_b29, &work[1], &c__1)
        # C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)'
        r__1 = -(*tau)
        sger_(&lastv, &lastc, &r__1, &v[1], incv, &work[1], &c__1, &c__[
            c_offset], ldc)
else:  # 否则
    # 计算 C * H
    if (lastv > 0):  # 如果 lastv 大于 0
        # w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)
        sgemv_("No transpose", &lastc, &lastv, &c_b15, &c__[c_offset],
            ldc, &v[1], incv, &c_b29, &work[1], &c__1)
        # C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)'
        r__1 = -(*tau)
        sger_(&lastc, &lastv, &r__1, &work[1], &c__1, &v[1], incv, &c__[
            c_offset], ldc)
return 0
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLARFB applies a real block reflector H or its transpose H' to a
    real m by n matrix C, from either the left or the right.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply H or H' from the Left
            = 'R': apply H or H' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply H (No transpose)
            = 'T': apply H' (Transpose)

    DIRECT  (input) CHARACTER*1
            Indicates how H is formed from a product of elementary
            reflectors
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)

    STOREV  (input) CHARACTER*1
            Indicates how the vectors which define the elementary
            reflectors are stored:
            = 'C': Columnwise
            = 'R': Rowwise

    M       (input) INTEGER
            The number of rows of the matrix C.

    N       (input) INTEGER
            The number of columns of the matrix C.

    K       (input) INTEGER
            The order of the matrix T (= the number of elementary
            reflectors whose product defines the block reflector).

    V       (input) REAL array, dimension
                                  (LDV,K) if STOREV = 'C'
                                  (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                  (LDV,N) if STOREV = 'R' and SIDE = 'R'
            The matrix V. See further details.

    LDV     (input) INTEGER
            The leading dimension of the array V.
            If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
            if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
            if STOREV = 'R', LDV >= K.

    T       (input) REAL array, dimension (LDT,K)
            The triangular k by k matrix T in the representation of the
            block reflector.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= K.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by H*C or H'*C or C*H or C*H'.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDA >= max(1,M).

    WORK    (workspace) REAL array, dimension (LDWORK,K)

    LDWORK  (input) INTEGER
            The leading dimension of the array WORK.
            If SIDE = 'L', LDWORK >= max(1,N);
            if SIDE = 'R', LDWORK >= max(1,M).

    =====================================================================


       Quick return if possible
    /* Parameter adjustments */
    v_dim1 = *ldv;                    // 获取参数 ldv 的值，表示 V 矩阵的列数
    v_offset = 1 + v_dim1;            // 计算 V 矩阵的偏移量
    v -= v_offset;                    // 调整 V 矩阵的起始位置

    t_dim1 = *ldt;                    // 获取参数 ldt 的值，表示 T 矩阵的列数
    t_offset = 1 + t_dim1;            // 计算 T 矩阵的偏移量
    t -= t_offset;                    // 调整 T 矩阵的起始位置

    c_dim1 = *ldc;                    // 获取参数 ldc 的值，表示 C 矩阵的列数
    c_offset = 1 + c_dim1;            // 计算 C 矩阵的偏移量
    c__ -= c_offset;                  // 调整 C 矩阵的起始位置

    work_dim1 = *ldwork;              // 获取参数 ldwork 的值，表示工作数组的列数
    work_offset = 1 + work_dim1;      // 计算工作数组的偏移量
    work -= work_offset;              // 调整工作数组的起始位置

    /* Function Body */
    if (*m <= 0 || *n <= 0) {         // 检查输入参数 m 和 n 是否小于等于零
        return 0;                     // 若是，直接返回
    }

    if (lsame_(trans, "N")) {         // 检查参数 trans 是否为 "N"
        *(unsigned char *)transt = 'T';  // 若是，将 transt 设置为 'T'
    } else {
        *(unsigned char *)transt = 'N';  // 否则，将 transt 设置为 'N'
    }

    if (lsame_(storev, "C")) {        // 检查参数 storev 是否为 "C"
        if (lsame_(direct, "F")) {    // 若是，再检查参数 direct 是否为 "F"

            /*
                 Let  V =  ( V1 )    (first K rows)
                           ( V2 )
                 where  V1  is unit lower triangular.
            */

            if (lsame_(side, "L")) {  // 若参数 side 为 "L"

                /*
                    Form  H * C  or  H' * C  where  C = ( C1 )
                                                        ( C2 )

                    Computing MAX
                */

                // 计算 max 值
                i__1 = *k;
                i__2 = ilaslr_(m, k, &v[v_offset], ldv);
                lastv = max(i__1, i__2);  // 获取 lastv 的最大值
                lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc);  // 计算 lastc 的值

                /*
                    W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

                    W := C1'
                */

                // 将 C1' 的转置存储到工作数组中
                i__1 = *k;
                for (j = 1; j <= i__1; ++j) {
                    scopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
                    // 使用 scopy_ 将 C1' 的列复制到工作数组的相应位置
                    // L10:
                }

                /* W := W * V1 */
                // 计算 W := W * V1，其中 V1 是单位下三角矩阵
                strmm_("Right", "Lower", "No transpose", "Unit", &lastc, k,
                       &c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

                if (lastv > *k) {

                    /* W := W + C2'*V2 */
                    // 计算 W := W + C2'*V2
                    i__1 = lastv - *k;
                    sgemm_("Transpose", "No transpose", &lastc, k, &i__1,
                           &c_b15, &c__[*k + 1 + c_dim1], ldc, &v[*k + 1 +
                           v_dim1], ldv, &c_b15, &work[work_offset], ldwork);
                }

                /* W := W * T'  or  W * T */
                // 计算 W := W * T' 或者 W * T
                strmm_("Right", "Upper", transt, "Non-unit", &lastc, k,
                       &c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

                /* C := C - V * W' */
                // 计算 C := C - V * W'
                if (lastv > *k) {

                    /* C2 := C2 - V2 * W' */
                    // 计算 C2 := C2 - V2 * W'
                    i__1 = lastv - *k;
                    sgemm_("No transpose", "Transpose", &i__1, &lastc, k,
                           &c_b151, &v[*k + 1 + v_dim1], ldv, &work[
                           work_offset], ldwork, &c_b15, &c__[*k + 1 +
                           c_dim1], ldc);
                }

                /* W := W * V1' */
                // 计算 W := W * V1'
                strmm_("Right", "Lower", "Transpose", "Unit", &lastc, k,
                       &c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

                /* C1 := C1 - W' */
                // 计算 C1 := C1 - W'
                i__1 = *k;
                for (j = 1; j <= i__1; ++j) {
                    i__2 = lastc;
                    for (i__ = 1; i__ <= i__2; ++i__) {
                        c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
                        // 更新 C1 的值
                        // L20:
                    }
                    // L30:
                }

            } else if (lsame_(side, "R")) {  // 若参数 side 为 "R"

                /*
                    Form  C * H  or  C * H'  where  C = ( C1  C2 )
                */

                // 计算 max 值
/*
        i__1 = *k, i__2 = ilaslr_(n, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);
*/
        // 计算 lastv 和 lastc 的值，分别表示 K 和 C 的最大尺寸
        i__1 = *k, i__2 = ilaslr_(n, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);  // 计算 K 和 ilaslr_ 返回值的最大值，作为 lastv
        lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);  // 计算 C 的尺寸，作为 lastc

/*
                W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

                W := C1
*/
        // 将 C 的前部分 C1 复制到 WORK 中
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
                work_dim1 + 1], &c__1);
/* L40: */
        }

/*              W := W * V1 */
        // 计算 W = W * V1，其中 V1 是下三角矩阵

        strmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2 * V2 */
            // 如果 V 的尺寸大于 K，则计算 W = W + C2 * V2，其中 V2 是上三角矩阵

            i__1 = lastv - *k;
            sgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
                1 + v_dim1], ldv, &c_b15, &work[work_offset],
                ldwork);
        }

/*              W := W * T  or  W * T' */
        // 计算 W = W * T 或 W = W * T'，取决于参数 trans 的设定

        strmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */
        // 计算 C = C - W * V'

        if (lastv > *k) {

/*                 C2 := C2 - W * V2' */
            // 如果 V 的尺寸大于 K，则计算 C2 = C2 - W * V2'

            i__1 = lastv - *k;
            sgemm_("No transpose", "Transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[*k + 1 +
                v_dim1], ldv, &c_b15, &c__[(*k + 1) * c_dim1 + 1],
                 ldc);
        }

/*              W := W * V1' */
        // 计算 W = W * V1'

        strmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */
        // 计算 C1 = C1 - W

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L50: */
            }
/* L60: */
        }
        }

    } else {

/*
             Let  V =  ( V1 )
                       ( V2 )    (last K rows)
             where  V2  is unit upper triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaslr_(m, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

                W := C2'
*/
        // 将 C 的后部分 C2' 复制到 WORK 中
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
/* L70: */
        }

/*              W := W * V2 */
        // 计算 W = W * V2，其中 V2 是上三角矩阵

        strmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2 * V2 */
            // 如果 V 的尺寸大于 K，则计算 W = W + C2 * V2，其中 V2 是上三角矩阵

            i__1 = lastv - *k;
            sgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
                1 + v_dim1], ldv, &c_b15, &work[work_offset],
                ldwork);
        }

/*              W := W * T  or  W * T' */
        // 计算 W = W * T 或 W = W * T'，取决于参数 trans 的设定

        strmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */
        // 计算 C = C - W * V'

        if (lastv > *k) {

/*                 C2 := C2 - W * V2' */
            // 如果 V 的尺寸大于 K，则计算 C2 = C2 - W * V2'

            i__1 = lastv - *k;
            sgemm_("No transpose", "Transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[*k + 1 +
                v_dim1], ldv, &c_b15, &c__[(*k + 1) * c_dim1 + 1],
                 ldc);
        }

/*              W := W * V1' */
        // 计算 W = W * V1'

        strmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */
        // 计算 C1 = C1 - W

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L50: */
            }
/* L60: */
        }
        }

    } else {

/*              Let  V =  ( V1 )
                        ( V2 )    (last K rows)
              where  V2  is unit upper triangular.
*/
        // 处理 V 矩阵的形状和性质描述，V2 是单位上三角矩阵

        if (lsame_(side, "L")) {

/*                Form  H * C  or  H' * C  where  C = ( C1 )
                                                     ( C2 )
*/
            // 根据参数 side 的值处理 H * C 或 H' * C 的乘法运算

   // 计算 MAX
        i__1 = *k, i__2 = ilaslr_(m, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

                W := C2'
*/
        // 将 C 的后部分 C2' 复制到 WORK 中
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
/* L70: */
        }

/*              W := W * V2 */
        // 计算 W = W * V2，其中 V2 是上三角矩阵

        strmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {
/* W := W + C1'*V1 */
i__1 = lastv - *k;  // 计算矩阵乘法的行数
sgemm_("Transpose", "No transpose", &lastc, k, &i__1, &
    c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
    c_b15, &work[work_offset], ldwork);  // 执行矩阵乘法，将结果存储在 work 中

/* W := W * T'  or  W * T */
strmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
    c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);  // 执行右侧三角矩阵与矩阵乘法

/* C := C - V * W' */
if (lastv > *k) {

    /* C1 := C1 - V1 * W' */
    i__1 = lastv - *k;  // 计算矩阵乘法的列数
    sgemm_("No transpose", "Transpose", &i__1, &lastc, k, &
        c_b151, &v[v_offset], ldv, &work[work_offset],
        ldwork, &c_b15, &c__[c_offset], ldc);  // 执行矩阵乘法，更新部分矩阵 C1
}

/* W := W * V2' */
strmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
    c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
    work_offset], ldwork);  // 执行右侧三角矩阵与矩阵乘法，更新矩阵 W

/* C2 := C2 - W' */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        c__[lastv - *k + j + i__ * c_dim1] -= work[i__ + j *
            work_dim1];  // 更新部分矩阵 C2
    }
}

} else if (lsame_(side, "R")) {

    /*
            Form  C * H  or  C * H'  where  C = ( C1  C2 )
    */

    /* 计算 lastv 和 lastc */
    i__1 = *k, i__2 = ilaslr_(n, k, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);

    /*
            W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

            W := C2
    */

    /* 将 C2 复制到工作区 */
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        scopy_(&lastc, &c__[(*n - *k + j) * c_dim1 + 1], &c__1, &
            work[j * work_dim1 + 1], &c__1);  // 复制 C2 到工作区
    }

    /* W := W * V2 */
    strmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
        c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
        work_offset], ldwork);  // 执行右侧三角矩阵与矩阵乘法，更新矩阵 W

    if (lastv > *k) {

        /* W := W + C1 * V1 */
        i__1 = lastv - *k;
        sgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
            c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
            c_b15, &work[work_offset], ldwork);  // 执行矩阵乘法，更新工作区 W
    }

    /* W := W * T  or  W * T' */
    strmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b15,
         &t[t_offset], ldt, &work[work_offset], ldwork);  // 执行右侧三角矩阵与矩阵乘法

    /* C := C - W * V' */
    if (lastv > *k) {

        /* C1 := C1 - W * V1' */
        i__1 = lastv - *k;
        sgemm_("No transpose", "Transpose", &lastc, &i__1, k, &
            c_b151, &work[work_offset], ldwork, &v[v_offset],
            ldv, &c_b15, &c__[c_offset], ldc);  // 执行矩阵乘法，更新部分矩阵 C1
    }
}
/*              W := W * V2' */

        strmm_("Right",             // 使用 BLAS 函数 strmm，右侧矩阵乘法
               "Upper",             // 上三角矩阵 V2'
               "Transpose",         // 转置操作，计算 V2' 的乘积
               "Unit",              // V2' 是单位三角矩阵
               &lastc,              // 矩阵 W 的行数
               k,                   // 矩阵 W 的列数
               &c_b15,              // 常数 1.0，用于乘法
               &v[lastv - *k + 1 + v_dim1], ldv,   // V2' 的起始地址及其列步长
               &work[work_offset], ldwork);        // 存储结果的工作区及其列步长

/*              C2 := C2 - W */

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                c__[i__ + (lastv - *k + j) * c_dim1] -= work[i__ + j * work_dim1];
                // 更新矩阵 C2，减去 W 的乘积结果
/* L110: */
            }
/* L120: */
        }
        }
    }

    } else if (lsame_(storev, "R")) {

    if (lsame_(direct, "F")) {

/*
             Let  V =  ( V1  V2 )    (V1: first K columns)
             where  V1  is unit upper triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaslc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C1'
*/

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1
                + 1], &c__1);
            // 复制矩阵 C1 到工作区 W，作为中间计算结果
/* L130: */
        }

/*              W := W * V1' */

        strmm_("Right",             // 右侧矩阵乘法
               "Upper",             // 上三角矩阵 V1'
               "Transpose",         // 转置操作，计算 V1' 的乘积
               "Unit",              // V1' 是单位三角矩阵
               &lastc,              // 矩阵 W 的行数
               k,                   // 矩阵 W 的列数
               &c_b15,              // 常数 1.0，用于乘法
               &v[v_offset], ldv,   // V1' 的起始地址及其列步长
               &work[work_offset], ldwork);    // 存储结果的工作区及其列步长
        if (lastv > *k) {

/*                 W := W + C2'*V2' */

            i__1 = lastv - *k;
            sgemm_("Transpose",        // 矩阵转置，C2' 的乘法
                   "Transpose",       // 矩阵转置，V2' 的乘法
                   &lastc,            // 矩阵 W 的行数
                   k,                 // 矩阵 W 的列数
                   &i__1,             // 矩阵 C2' 的行数
                   &c_b15,            // 常数 1.0，用于乘法
                   &c__[*k + 1 + c_dim1], ldc,   // C2' 的起始地址及其列步长
                   &v[(*k + 1) * v_dim1 + 1], ldv,  // V2' 的起始地址及其列步长
                   &c_b15,            // 常数 1.0，用于乘法
                   &work[work_offset], ldwork);    // 存储结果的工作区及其列步长
        }

/*              W := W * T'  or  W * T */

        strmm_("Right",             // 右侧矩阵乘法
               "Upper",             // 上三角矩阵 T
               transt,              // 转置操作或非转置操作
               "Non-unit",          // T 不是单位三角矩阵
               &lastc,              // 矩阵 W 的行数
               k,                   // 矩阵 W 的列数
               &c_b15,              // 常数 1.0，用于乘法
               &t[t_offset], ldt,   // T 的起始地址及其列步长
               &work[work_offset], ldwork);    // 存储结果的工作区及其列步长

/*              C := C - V' * W' */

        if (lastv > *k) {

/*                 C2 := C2 - V2' * W' */

            i__1 = lastv - *k;
            sgemm_("Transpose",        // 矩阵转置，V2' 的乘法
                   "Transpose",       // 矩阵转置，W 的乘法
                   &i__1,             // 矩阵 C2 的行数
                   &lastc,            // 矩阵 C2 的列数
                   k,                 // 矩阵 W 的行数
                   &c_b151,           // 常数 -1.0，用于乘法
                   &v[(*k + 1) * v_dim1 + 1], ldv,  // V2' 的起始地址及其列步长
                   &work[work_offset], ldwork,     // W 的起始地址及其列步长
                   &c_b15,            // 常数 1.0，用于乘法
                   &c__[*k + 1 + c_dim1], ldc);    // C2 的起始地址及其列步长
        }

/*              W := W * V1 */

        strmm_("Right",             // 右侧矩阵乘法
               "Upper",             // 上三角矩阵 V1
               "No transpose",      // 非转置操作
               "Unit",              // V1 是单位三角矩阵
               &lastc,              // 矩阵 W 的行数
               k,                   // 矩阵 W 的列数
               &c_b15,              // 常数 1.0，用于乘法
               &v[v_offset], ldv,   // V1 的起始地址及其列步长
               &work[work_offset], ldwork);    // 存储结果的工作区及其列步长

/*              C1 := C1 - W' */

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
                // 更新矩阵 C1，减去 W 的转置结果
/* L140: */
            }
/* L150: */
        }

        } else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
/*
        i__1 = *k, i__2 = ilaslc_(k, n, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);
*/

        // 计算 lastv 为 k 和 ilaslc_(k, n, &v[v_offset], ldv) 的最大值
        i__1 = *k, i__2 = ilaslc_(k, n, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        // 计算 lastc 为 ilaslr_(m, &lastv, &c__[c_offset], ldc) 的结果
        lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

                W := C1
*/

        // 将 C 的前 k 列复制到工作区域 WORK
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
                work_dim1 + 1], &c__1);
/* L160: */
        }

/*              W := W * V1' */

        // 计算 W := W * V1'，其中 V1 是上三角矩阵 V 的前 k 列
        strmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2 * V2' */

            // 如果 lastv 大于 k，则计算 W := W + C2 * V2'，其中 V2 是 V 的后 lastv-k 列
            i__1 = lastv - *k;
            sgemm_("No transpose", "Transpose", &lastc, k, &i__1, &
                c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[(*k +
                1) * v_dim1 + 1], ldv, &c_b15, &work[work_offset],
                 ldwork);
        }

/*              W := W * T  or  W * T' */

        // 计算 W := W * T 或 W * T'，T 是一个上三角矩阵
        strmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

        // 计算 C := C - W * V，其中 V 是由 V1 和 V2 组成的矩阵
        if (lastv > *k) {

/*                 C2 := C2 - W * V2 */

            // 如果 lastv 大于 k，则计算 C2 := C2 - W * V2，其中 V2 是 V 的后 lastv-k 列
            i__1 = lastv - *k;
            sgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[(*k + 1) *
                v_dim1 + 1], ldv, &c_b15, &c__[(*k + 1) * c_dim1
                + 1], ldc);
        }

/*              W := W * V1 */

        // 计算 W := W * V1，其中 V1 是上三角矩阵 V 的前 k 列
        strmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */

        // 计算 C1 := C1 - W，其中 W 是之前计算得到的矩阵
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L170: */
            }
/* L180: */
        }

        }

    } else {

/*
             Let  V =  ( V1  V2 )    (V2: last K columns)
             where  V2  is unit lower triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaslc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        // 计算 lastc 为 ilaslc_(&lastv, n, &c__[c_offset], ldc) 的结果
        lastc = ilaslc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C2'
*/

        // 将 C 的后 k 行复制到工作区域 WORK
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            scopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
/* L190: */
        }

/*              W := W * V2' */

        // 计算 W := W * V2'，其中 V2 是 V 的最后 k 列
        strmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C2 * V2' */

            // 如果 lastv 大于 k，则计算 W := W + C2 * V2'，其中 V2 是 V 的最后 k 列
            i__1 = lastv - *k;
            sgemm_("No transpose", "Transpose", &lastc, k, &i__1, &
                c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[(*k +
                1) * v_dim1 + 1], ldv, &c_b15, &work[work_offset],
                 ldwork);
        }

/*              W := W * T  or  W * T' */

        // 计算 W := W * T 或 W * T'，T 是一个上三角矩阵
        strmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);
        }
    }


注释：
/*                 W := W + C1'*V1' */
/* 计算矩阵乘积 W := W + C1'*V1' */

            i__1 = lastv - *k;
/* 计算矩阵乘积的行数 */

            sgemm_("Transpose", "Transpose", &lastc, k, &i__1, &c_b15,
/* 调用 BLAS 函数 sgemm 计算矩阵乘积，将 C1' * V1' 存储到 W 中 */
                 &c__[c_offset], ldc, &v[v_offset], ldv, &c_b15, &
                work[work_offset], ldwork);
        }

/*              W := W * T'  or  W * T */
/* 计算矩阵乘积 W := W * T' 或者 W * T */

        strmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
            c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */
/* 计算矩阵差 C := C - V' * W' */

        if (lastv > *k) {

/*                 C1 := C1 - V1' * W' */
/* 计算矩阵差 C1 := C1 - V1' * W' */

            i__1 = lastv - *k;
/* 计算矩阵乘积的列数 */

            sgemm_("Transpose", "Transpose", &i__1, &lastc, k, &
                c_b151, &v[v_offset], ldv, &work[work_offset],
                ldwork, &c_b15, &c__[c_offset], ldc);
        }

/*              W := W * V2 */
/* 计算矩阵乘积 W := W * V2 */

        strmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);

/*              C2 := C2 - W' */
/* 计算矩阵差 C2 := C2 - W' */

        i__1 = *k;
/* 循环开始，遍历每一列 */
        for (j = 1; j <= i__1; ++j) {
/* 循环开始，遍历每一行 */
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
/* 执行矩阵差的计算 */
            c__[lastv - *k + j + i__ * c_dim1] -= work[i__ + j *
                work_dim1];
/* L200: */
            }
/* L210: */
        }

        } else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaslc_(k, n, &v[v_offset], ldv);
/* 计算 lastv，为 C * V' 的维度 */
        lastv = max(i__1,i__2);
/* 计算 lastc，为 C * V' 的维度 */

        lastc = ilaslr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

                W := C2
*/

        i__1 = *k;
/* 循环开始，复制 C2 到工作区域 */
        for (j = 1; j <= i__1; ++j) {
/* 复制 C2 到工作区域 */
            scopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
                 &work[j * work_dim1 + 1], &c__1);
/* L220: */
        }

/*              W := W * V2' */
/* 计算矩阵乘积 W := W * V2' */

        strmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);
/* 如果 lastv 大于 k */

        if (lastv > *k) {

/*                 W := W + C1 * V1' */
/* 计算矩阵和 W := W + C1 * V1' */

            i__1 = lastv - *k;
/* 计算矩阵乘积的列数 */

            sgemm_("No transpose", "Transpose", &lastc, k, &i__1, &
                c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
                c_b15, &work[work_offset], ldwork);
        }

/*              W := W * T  or  W * T' */
/* 计算矩阵乘积 W := W * T 或者 W * T' */

        strmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */
/* 计算矩阵差 C := C - W * V */

        if (lastv > *k) {

/*                 C1 := C1 - W * V1 */
/* 计算矩阵差 C1 := C1 - W * V1 */

            i__1 = lastv - *k;
/* 计算矩阵乘积的行数 */

            sgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[v_offset],
                ldv, &c_b15, &c__[c_offset], ldc);
        }
/*              W := W * V2 */

/* 
   这行代码执行矩阵乘法 W := W * V2，其中：
   - strmm_ 是 LAPACK 库中的一个子程序，用于执行右侧三角矩阵与矩阵的乘法
   - "Right", "Lower", "No transpose", "Unit" 是 strmm_ 函数的参数，指定操作方式
   - &lastc, k, &c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[work_offset], ldwork 是 strmm_ 函数的具体参数
*/

        strmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);

/*              C1 := C1 - W */

/* 
   这部分代码执行矩阵减法 C1 := C1 - W，其中：
   - 使用嵌套的循环对矩阵 C1 的每个元素进行更新
   - c__[i__ + (lastv - *k + j) * c_dim1] 表示矩阵 C1 中的特定元素
   - work[i__ + j * work_dim1] 表示矩阵 W 中的特定元素
*/

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                c__[i__ + (lastv - *k + j) * c_dim1] -= work[i__ + j *
                     work_dim1];
/* L230: */
            }
/* L240: */
        }

        }

    }
    }

    return 0;

/*     End of SLARFB */

} /* slarfb_ */

/* Subroutine */ int slarfg_(integer *n, real *alpha, real *x, integer *incx,
    real *tau)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Local variables */
    static integer j, knt;
    static real beta;
    extern doublereal snrm2_(integer *, real *, integer *);
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
    static real xnorm;
    extern doublereal slapy2_(real *, real *), slamch_(char *);
    static real safmin, rsafmn;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLARFG generates a real elementary reflector H of order n, such
    that

          H * ( alpha ) = ( beta ),   H' * H = I.
              (   x   )   (   0  )

    where alpha and beta are scalars, and x is an (n-1)-element real
    vector. H is represented in the form

          H = I - tau * ( 1 ) * ( 1 v' ) ,
                        ( v )

    where tau is a real scalar and v is a real (n-1)-element
    vector.

    If the elements of x are all zero, then tau = 0 and H is taken to be
    the unit matrix.

    Otherwise  1 <= tau <= 2.

    Arguments
    =========

    N       (input) INTEGER
            The order of the elementary reflector.

    ALPHA   (input/output) REAL
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.

    X       (input/output) REAL array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.

    INCX    (input) INTEGER
            The increment between elements of X. INCX > 0.

    TAU     (output) REAL
            The value tau.

    =====================================================================
*/


    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 1) {
    *tau = 0.f;
    return 0;
    }

    i__1 = *n - 1;
    xnorm = snrm2_(&i__1, &x[1], incx);

    if (xnorm == 0.f) {

/*        H  =  I */

    *tau = 0.f;
    } else {

/*        general case */

    r__1 = slapy2_(alpha, &xnorm);
    beta = -r_sign(&r__1, alpha);
    safmin = slamch_("S") / slamch_("E");
    knt = 0;
    if (dabs(beta) < safmin) {
/*           XNORM, BETA may be inaccurate; scale X and recompute them */

        rsafmn = 1.f / safmin;
L10:
        ++knt;
        // 缩放向量 X 的部分元素，以增加数值稳定性
        i__1 = *n - 1;
        sscal_(&i__1, &rsafmn, &x[1], incx);
        // 更新 beta 和 alpha，以保持精度
        beta *= rsafmn;
        *alpha *= rsafmn;
        // 如果新的 beta 小于安全最小值 safmin，则继续缩放 X
        if (dabs(beta) < safmin) {
        goto L10;
        }

/*           New BETA is at most 1, at least SAFMIN */

        // 重新计算 x 的范数，并计算新的 beta
        i__1 = *n - 1;
        xnorm = snrm2_(&i__1, &x[1], incx);
        r__1 = slapy2_(alpha, &xnorm);
        beta = -r_sign(&r__1, alpha);
    }
    // 计算 tau，以确定反射系数
    *tau = (beta - *alpha) / beta;
    // 缩放向量 X 的部分元素，以保持数值稳定性
    i__1 = *n - 1;
    r__1 = 1.f / (*alpha - beta);
    sscal_(&i__1, &r__1, &x[1], incx);

/*        If ALPHA is subnormal, it may lose relative accuracy */

    // 如果 alpha 是次正规数，可能会损失相对精度
    i__1 = knt;
    for (j = 1; j <= i__1; ++j) {
        // 多次乘以 safmin 来避免损失精度
        beta *= safmin;
/* L20: */
    }
    // 更新 alpha 为最终值
    *alpha = beta;
    }

    return 0;

/*     End of SLARFG */

} /* slarfg_ */

/* Subroutine */ int slarft_(char *direct, char *storev, integer *n, integer *
    k, real *v, integer *ldv, real *tau, real *t, integer *ldt)
{
    /* System generated locals */
    integer t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3;
    real r__1;

    /* Local variables */
    static integer i__, j, prevlastv;
    static real vii;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *,
        real *, integer *, real *, integer *, real *, real *, integer *);
    static integer lastv;
    extern /* Subroutine */ int strmv_(char *, char *, char *, integer *,
        real *, integer *, real *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLARFT forms the triangular factor T of a real block reflector H
    of order n, which is defined as a product of k elementary reflectors.

    If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

    If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

    If STOREV = 'C', the vector which defines the elementary reflector
    H(i) is stored in the i-th column of the array V, and

       H  =  I - V * T * V'

    If STOREV = 'R', the vector which defines the elementary reflector
    H(i) is stored in the i-th row of the array V, and

       H  =  I - V' * T * V

    Arguments
    =========

    DIRECT  (input) CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)

    STOREV  (input) CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise

*/
    N       (input) INTEGER
            The order of the block reflector H. N >= 0.

    K       (input) INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.

    V       (input/output) REAL array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.

    LDV     (input) INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.

    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).

    T       (output) REAL array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= K.

    Further Details
    ===============

    The shape of the matrix V and the storage of the vectors which define
    the H(i) is best illustrated by the following example with n = 5 and
    k = 3. The elements equal to 1 are not stored; the corresponding
    array elements are modified but restored on exit. The rest of the
    array is not used.

    DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                 V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                     ( v1  1    )                     (     1 v2 v2 v2 )
                     ( v1 v2  1 )                     (        1 v3 v3 )
                     ( v1 v2 v3 )
                     ( v1 v2 v3 )

    DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                 V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                     ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                     (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                     (     1 v3 )
                     (        1 )

    =====================================================================

    Quick return if possible
    /* Parameter adjustments */
    // 设置参数 v 和 t 的维度和偏移
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --tau;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;

    /* Function Body */
    // 如果矩阵维度为零，直接返回
    if (*n == 0) {
        return 0;
    }

    // 如果 direct 字符串为 "F"
    if (lsame_(direct, "F")) {
        // 初始化 prevlastv 为 n
        prevlastv = *n;
        // 循环处理每个 k
        i__1 = *k;
        for (i__ = 1; i__ <= i__1; ++i__) {
            // 更新 prevlastv 为 i 和 prevlastv 中较大的值
            prevlastv = max(i__,prevlastv);
            // 如果 tau[i__] 等于 0
            if (tau[i__] == 0.f) {

                /* H(i) = I */
                // 将 T 的第 i 列前 i 行元素置零
                i__2 = i__;
                for (j = 1; j <= i__2; ++j) {
                    t[j + i__ * t_dim1] = 0.f;
                }
            } else {

                /* general case */
                // 获取 V 的对角元素 v[i,i]
                vii = v[i__ + i__ * v_dim1];
                // 设置 v[i,i] = 1
                v[i__ + i__ * v_dim1] = 1.f;
                // 如果存储模式为 "C"
                if (lsame_(storev, "C")) {
                    // 查找 V(i:j,1:i-1) 中非零元素的最后一列 j
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        if (v[lastv + i__ * v_dim1] != 0.f) {
                            goto L15;
                        }
                    }
L15:
                    // 计算 j 和 prevlastv 中较小的值
                    j = min(lastv,prevlastv);

                    /* T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)' * V(i:j,i) */
                    // 执行矩阵乘法操作
                    i__2 = j - i__ + 1;
                    i__3 = i__ - 1;
                    r__1 = -tau[i__];
                    sgemv_("Transpose", &i__2, &i__3, &r__1, &v[i__ + v_dim1],
                         ldv, &v[i__ + i__ * v_dim1], &c__1, &c_b29, &t[
                        i__ * t_dim1 + 1], &c__1);
                } else {
                    // 如果存储模式为 "R"
                    // 查找 V(1:i-1,i:j) 中非零元素的最后一行 j
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        if (v[i__ + lastv * v_dim1] != 0.f) {
                            goto L16;
                        }
                    }
L16:
                    // 计算 j 和 prevlastv 中较小的值
                    j = min(lastv,prevlastv);

                    /* T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)' */
                    // 执行矩阵乘法操作
                    i__2 = i__ - 1;
                    i__3 = j - i__ + 1;
                    r__1 = -tau[i__];
                    sgemv_("No transpose", &i__2, &i__3, &r__1, &v[i__ *
                        v_dim1 + 1], ldv, &v[i__ + i__ * v_dim1], ldv, &
                        c_b29, &t[i__ * t_dim1 + 1], &c__1);
                }
                // 恢复 v[i,i] 的值为 vii
                v[i__ + i__ * v_dim1] = vii;

                /* T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) */
                // 执行矩阵向量乘法操作
                i__2 = i__ - 1;
                strmv_("Upper", "No transpose", "Non-unit", &i__2, &t[
                    t_offset], ldt, &t[i__ * t_dim1 + 1], &c__1);
                // 设置 T 的对角元素
                t[i__ + i__ * t_dim1] = tau[i__];
                // 更新 prevlastv 为 i 和 lastv 中较大的值
                if (i__ > 1) {
                    prevlastv = max(prevlastv,lastv);
                } else {
                    prevlastv = lastv;
                }
            }
        }
    } else {
        // 如果 direct 字符串不为 "F"
        // 初始化 prevlastv 为 1
        prevlastv = 1;
        // 反向处理每个 k
        for (i__ = *k; i__ >= 1; --i__) {
            // 如果 tau[i__] 等于 0
            if (tau[i__] == 0.f) {

                /* H(i) = I */
                // 将 T 的第 i 列从 i 行到 k 行元素置零
                i__1 = *k;
                for (j = i__; j <= i__1; ++j) {
                    t[j + i__ * t_dim1] = 0.f;
                }
            } else {

                /* general case */
                // 如果 i 小于 k
                if (i__ < *k) {
                    // 如果存储模式为 "C"
                    if (lsame_(storev, "C")) {
                        // 获取 V(n-k+i,i) 的对角元素 vii
                        vii = v[*n - *k + i__ + i__ * v_dim1];
                        // 设置 V(n-k+i,i) = 1
                        v[*n - *k + i__ + i__ * v_dim1] = 1.f;


这段代码涉及了对矩阵操作的一系列计算和更新，具体注释了参数调整、特定条件下的矩阵操作以及相关的数学运算。
/*                    Skip any leading zeros. */
            // 初始化lastv为1，逐行检查v数组，找到第一个非零元素的索引lastv
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                // 如果v[lastv + i__ * v_dim1]不为0，跳转至标签L35
                if (v[lastv + i__ * v_dim1] != 0.f) {
                goto L35;
                }
            }
L35:
            // 计算j为lastv和prevlastv的最大值
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(j:n-k+i,i+1:k)' * V(j:n-k+i,i)
*/
            // 计算矩阵乘法结果并赋给T矩阵的一部分，使用SGEMV函数
            i__1 = *n - *k + i__ - j + 1;
            i__2 = *k - i__;
            r__1 = -tau[i__];
            sgemv_("Transpose", &i__1, &i__2, &r__1, &v[j + (i__
                + 1) * v_dim1], ldv, &v[j + i__ * v_dim1], &
                c__1, &c_b29, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            // 设置v数组中的一个元素为vii
            v[*n - *k + i__ + i__ * v_dim1] = vii;
            } else {
            // 保存v数组的一个元素的值，并将其设置为1
            vii = v[i__ + (*n - *k + i__) * v_dim1];
            v[i__ + (*n - *k + i__) * v_dim1] = 1.f;
/*                    Skip any leading zeros. */
            // 初始化lastv为1，逐列检查v数组，找到第一个非零元素的索引lastv
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                // 如果v[i__ + lastv * v_dim1]不为0，跳转至标签L36
                if (v[i__ + lastv * v_dim1] != 0.f) {
                goto L36;
                }
            }
L36:
            // 计算j为lastv和prevlastv的最大值
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)'
*/
            // 计算矩阵乘法结果并赋给T矩阵的一部分，使用SGEMV函数
            i__1 = *k - i__;
            i__2 = *n - *k + i__ - j + 1;
            r__1 = -tau[i__];
            sgemv_("No transpose", &i__1, &i__2, &r__1, &v[i__ +
                1 + j * v_dim1], ldv, &v[i__ + j * v_dim1],
                ldv, &c_b29, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            // 恢复v数组中之前保存的元素的值
            v[i__ + (*n - *k + i__) * v_dim1] = vii;
            }

/*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) */
            // 计算矩阵乘法结果并赋给T矩阵的一部分，使用STRMV函数
            i__1 = *k - i__;
            strmv_("Lower", "No transpose", "Non-unit", &i__1, &t[i__
                + 1 + (i__ + 1) * t_dim1], ldt, &t[i__ + 1 + i__ *
                 t_dim1], &c__1)
                ;
            // 如果i大于1，更新prevlastv为lastv和prevlastv的最小值；否则，prevlastv为lastv
            if (i__ > 1) {
            prevlastv = min(prevlastv,lastv);
            } else {
            prevlastv = lastv;
            }
        }
        // 将tau[i__]赋给T矩阵的一个元素
        t[i__ + i__ * t_dim1] = tau[i__];
        }
/* L40: */
    }
    }
    // 返回0，表示函数执行成功
    return 0;

/*     End of SLARFT */

} /* slarft_ */

/* Subroutine */ int slarfx_(char *side, integer *m, integer *n, real *v,
    real *tau, real *c__, integer *ldc, real *work)
{
    /* System generated locals */
    integer c_dim1, c_offset, i__1;

    /* Local variables */
    static integer j;
    static real t1, t2, t3, t4, t5, t6, t7, t8, t9, v1, v2, v3, v4, v5, v6,
        v7, v8, v9, t10, v10, sum;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
        integer *, real *, real *, integer *, real *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
*/
    Purpose
    =======
    SLARFX applies a real elementary reflector H to a real m by n
    matrix C, from either the left or the right. H is represented in the
    form

          H = I - tau * v * v'

    where tau is a real scalar and v is a real vector.

    If tau = 0, then H is taken to be the unit matrix

    This version uses inline code if H has order < 11.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            Indicates whether the operation applies H from the left or right.

    M       (input) INTEGER
            The number of rows of the matrix C.

    N       (input) INTEGER
            The number of columns of the matrix C.

    V       (input) REAL array, dimension (M) if SIDE = 'L'
                                       or (N) if SIDE = 'R'
            The vector v in the representation of H.
            For 'L': V is of length M.
            For 'R': V is of length N.

    TAU     (input) REAL
            The value tau in the representation of H.
            Scalar multiplier of the reflector.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            Matrix to be transformed by the elementary reflector.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            Specifies the size of the first dimension of C.

    WORK    (workspace) REAL array, dimension
                        (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            WORK is not referenced if H has order < 11.
            Workspace array used for intermediate calculations.

    =====================================================================
    /* Parameter adjustments */
    --v;  // 将指针 v 往前移动一个位置，即使其指向数组的第一个元素
    c_dim1 = *ldc;  // 获取 c 的第一维度大小
    c_offset = 1 + c_dim1;  // 计算 c 的偏移量
    c__ -= c_offset;  // 调整指针 c__，使其指向正确的内存位置
    --work;  // 将指针 work 往前移动一个位置，使其指向数组的第一个元素

    /* Function Body */
    if (*tau == 0.f) {  // 检查参数 tau 是否为 0
        return 0;  // 如果是，直接返回 0
    }
    if (lsame_(side, "L")) {  // 检查 side 参数是否为 "L"

/*        Form  H * C, where H has order m. */

        switch (*m) {  // 根据 m 的值选择不同的分支
            case 1:  goto L10;  // 如果 m 等于 1，跳转到标签 L10 处
            case 2:  goto L30;  // 如果 m 等于 2，跳转到标签 L30 处
            case 3:  goto L50;  // 如果 m 等于 3，跳转到标签 L50 处
            case 4:  goto L70;  // 如果 m 等于 4，跳转到标签 L70 处
            case 5:  goto L90;  // 如果 m 等于 5，跳转到标签 L90 处
            case 6:  goto L110;  // 如果 m 等于 6，跳转到标签 L110 处
            case 7:  goto L130;  // 如果 m 等于 7，跳转到标签 L130 处
            case 8:  goto L150;  // 如果 m 等于 8，跳转到标签 L150 处
            case 9:  goto L170;  // 如果 m 等于 9，跳转到标签 L170 处
            case 10:  goto L190;  // 如果 m 等于 10，跳转到标签 L190 处
        }

/*        Code for general M */

        slarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);  // 调用 slarf 函数处理一般情况
        goto L410;  // 跳转到标签 L410 处
L10:

/*        Special code for 1 x 1 Householder */

        t1 = 1.f - *tau * v[1] * v[1];  // 计算特殊情况下的 t1 值
        i__1 = *n;  // 获取 n 的值
        for (j = 1; j <= i__1; ++j) {  // 循环处理每一列
            c__[j * c_dim1 + 1] = t1 * c__[j * c_dim1 + 1];  // 更新 c 的第一列
        }
        goto L410;  // 跳转到标签 L410 处
L30:

/*        Special code for 2 x 2 Householder */

        v1 = v[1];  // 获取 v1 的值
        t1 = *tau * v1;  // 计算 t1 的值
        v2 = v[2];  // 获取 v2 的值
        t2 = *tau * v2;  // 计算 t2 的值
        i__1 = *n;  // 获取 n 的值
        for (j = 1; j <= i__1; ++j) {  // 循环处理每一列
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2];  // 计算 sum 的值
            c__[j * c_dim1 + 1] -= sum * t1;  // 更新 c 的第一列
            c__[j * c_dim1 + 2] -= sum * t2;  // 更新 c 的第二列
        }
        goto L410;  // 跳转到标签 L410 处
L50:

/*        Special code for 3 x 3 Householder */

        v1 = v[1];  // 获取 v1 的值
        t1 = *tau * v1;  // 计算 t1 的值
        v2 = v[2];  // 获取 v2 的值
        t2 = *tau * v2;  // 计算 t2 的值
        v3 = v[3];  // 获取 v3 的值
        t3 = *tau * v3;  // 计算 t3 的值
        i__1 = *n;  // 获取 n 的值
        for (j = 1; j <= i__1; ++j) {  // 循环处理每一列
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * c__[j * c_dim1 + 3];  // 计算 sum 的值
            c__[j * c_dim1 + 1] -= sum * t1;  // 更新 c 的第一列
            c__[j * c_dim1 + 2] -= sum * t2;  // 更新 c 的第二列
            c__[j * c_dim1 + 3] -= sum * t3;  // 更新 c 的第三列
        }
        goto L410;  // 跳转到标签 L410 处
L70:

/*        Special code for 4 x 4 Householder */

        v1 = v[1];  // 获取 v1 的值
        t1 = *tau * v1;  // 计算 t1 的值
        v2 = v[2];  // 获取 v2 的值
        t2 = *tau * v2;  // 计算 t2 的值
        v3 = v[3];  // 获取 v3 的值
        t3 = *tau * v3;  // 计算 t3 的值
        v4 = v[4];  // 获取 v4 的值
        t4 = *tau * v4;  // 计算 t4 的值
        i__1 = *n;  // 获取 n 的值
        for (j = 1; j <= i__1; ++j) {  // 循环处理每一列
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4];  // 计算 sum 的值
            c__[j * c_dim1 + 1] -= sum * t1;  // 更新 c 的第一列
            c__[j * c_dim1 + 2] -= sum * t2;  // 更新 c 的第二列
            c__[j * c_dim1 + 3] -= sum * t3;  // 更新 c 的第三列
            c__[j * c_dim1 + 4] -= sum * t4;  // 更新 c 的第四列
        }
        goto L410;  // 跳转到标签 L410 处
L90:

/*        Special code for 5 x 5 Householder */

        v1 = v[1];  // 获取 v1 的值
        t1 = *tau * v1;  // 计算 t1 的值
        v2 = v[2];  // 获取 v2 的值
        t2 = *tau * v2;  // 计算 t2 的值
        v3 = v[3];  // 获取 v3 的值
        t3 = *tau * v3;  // 计算 t3 的值
        v4 = v[4];  // 获取 v4 的值
        t4 = *tau * v4;  // 计算 t4 的值
        v5 = v[5];  // 获取 v5 的值
        t5 = *tau * v5;  // 计算 t5 的值
        i__1 = *n;  // 获取 n 的值
        for (j = 1; j <= i__1; ++j) {  // 循环处理每一列
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c
    # 跳转到代码标签 L410 处执行
    goto L410;
# 处理 6 x 6 Householder 特例的代码段

v1 = v[1];
t1 = *tau * v1;
v2 = v[2];
t2 = *tau * v2;
v3 = v[3];
t3 = *tau * v3;
v4 = v[4];
t4 = *tau * v4;
v5 = v[5];
t5 = *tau * v5;
v6 = v[6];
t6 = *tau * v6;
# 对矩阵 C 的每一列执行 Householder 变换
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    # 计算矩阵 C 的第 j 列与向量 v1-v6 的内积
    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
        c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
        j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6];
    # 更新矩阵 C 的第 j 列，应用 Householder 变换
    c__[j * c_dim1 + 1] -= sum * t1;
    c__[j * c_dim1 + 2] -= sum * t2;
    c__[j * c_dim1 + 3] -= sum * t3;
    c__[j * c_dim1 + 4] -= sum * t4;
    c__[j * c_dim1 + 5] -= sum * t5;
    c__[j * c_dim1 + 6] -= sum * t6;
    # 跳转到 L410 标签处
/* L120: */
}
goto L410;

# 处理 7 x 7 Householder 特例的代码段

v1 = v[1];
t1 = *tau * v1;
v2 = v[2];
t2 = *tau * v2;
v3 = v[3];
t3 = *tau * v3;
v4 = v[4];
t4 = *tau * v4;
v5 = v[5];
t5 = *tau * v5;
v6 = v[6];
t6 = *tau * v6;
v7 = v[7];
t7 = *tau * v7;
# 对矩阵 C 的每一列执行 Householder 变换
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    # 计算矩阵 C 的第 j 列与向量 v1-v7 的内积
    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
        c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
        j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
        c_dim1 + 7];
    # 更新矩阵 C 的第 j 列，应用 Householder 变换
    c__[j * c_dim1 + 1] -= sum * t1;
    c__[j * c_dim1 + 2] -= sum * t2;
    c__[j * c_dim1 + 3] -= sum * t3;
    c__[j * c_dim1 + 4] -= sum * t4;
    c__[j * c_dim1 + 5] -= sum * t5;
    c__[j * c_dim1 + 6] -= sum * t6;
    c__[j * c_dim1 + 7] -= sum * t7;
    # 跳转到 L410 标签处
/* L140: */
}
goto L410;

# 处理 8 x 8 Householder 特例的代码段

v1 = v[1];
t1 = *tau * v1;
v2 = v[2];
t2 = *tau * v2;
v3 = v[3];
t3 = *tau * v3;
v4 = v[4];
t4 = *tau * v4;
v5 = v[5];
t5 = *tau * v5;
v6 = v[6];
t6 = *tau * v6;
v7 = v[7];
t7 = *tau * v7;
v8 = v[8];
t8 = *tau * v8;
# 对矩阵 C 的每一列执行 Householder 变换
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    # 计算矩阵 C 的第 j 列与向量 v1-v8 的内积
    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
        c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
        j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
        c_dim1 + 7] + v8 * c__[j * c_dim1 + 8];
    # 更新矩阵 C 的第 j 列，应用 Householder 变换
    c__[j * c_dim1 + 1] -= sum * t1;
    c__[j * c_dim1 + 2] -= sum * t2;
    c__[j * c_dim1 + 3] -= sum * t3;
    c__[j * c_dim1 + 4] -= sum * t4;
    c__[j * c_dim1 + 5] -= sum * t5;
    c__[j * c_dim1 + 6] -= sum * t6;
    c__[j * c_dim1 + 7] -= sum * t7;
    c__[j * c_dim1 + 8] -= sum * t8;
    # 跳转到 L410 标签处
/* L160: */
}
goto L410;

# 处理 9 x 9 Householder 特例的代码段

v1 = v[1];
t1 = *tau * v1;
v2 = v[2];
t2 = *tau * v2;
v3 = v[3];
t3 = *tau * v3;
v4 = v[4];
t4 = *tau * v4;
v5 = v[5];
t5 = *tau * v5;
v6 = v[6];
t6 = *tau * v6;
v7 = v[7];
# 仅解释到这里，因为示例只要求解释到 v7 的部分
    // 计算 t7，等于 tau 乘以 v7
    t7 = *tau * v7;
    // 获取向量 v 的第 8 个元素
    v8 = v[8];
    // 计算 t8，等于 tau 乘以 v8
    t8 = *tau * v8;
    // 获取向量 v 的第 9 个元素
    v9 = v[9];
    // 计算 t9，等于 tau 乘以 v9
    t9 = *tau * v9;
    // 循环遍历从 1 到 n 的所有列 j
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        // 计算 sum，表示 v1 到 v9 和对应列 c__ 的乘积之和
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
            c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j *
            c_dim1 + 9];
        // 更新 c__ 的各列值，减去 sum 乘以对应的 t1 到 t9
        c__[j * c_dim1 + 1] -= sum * t1;
        c__[j * c_dim1 + 2] -= sum * t2;
        c__[j * c_dim1 + 3] -= sum * t3;
        c__[j * c_dim1 + 4] -= sum * t4;
        c__[j * c_dim1 + 5] -= sum * t5;
        c__[j * c_dim1 + 6] -= sum * t6;
        c__[j * c_dim1 + 7] -= sum * t7;
        c__[j * c_dim1 + 8] -= sum * t8;
        c__[j * c_dim1 + 9] -= sum * t9;
/* L180: */
    }
    goto L410;
L190:

/*        Special code for 10 x 10 Householder */

    // 获取向量 v 的前 10 个元素，并计算它们与 tau 的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    v9 = v[9];
    t9 = *tau * v9;
    v10 = v[10];
    t10 = *tau * v10;
    
    // 循环遍历矩阵 C 的每一列，进行 Householder 变换
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
            c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j *
            c_dim1 + 9] + v10 * c__[j * c_dim1 + 10];
        
        // 应用 Householder 变换到矩阵 C 的每一列
        c__[j * c_dim1 + 1] -= sum * t1;
        c__[j * c_dim1 + 2] -= sum * t2;
        c__[j * c_dim1 + 3] -= sum * t3;
        c__[j * c_dim1 + 4] -= sum * t4;
        c__[j * c_dim1 + 5] -= sum * t5;
        c__[j * c_dim1 + 6] -= sum * t6;
        c__[j * c_dim1 + 7] -= sum * t7;
        c__[j * c_dim1 + 8] -= sum * t8;
        c__[j * c_dim1 + 9] -= sum * t9;
        c__[j * c_dim1 + 10] -= sum * t10;
/* L200: */
    }
    goto L410;
    } else {

/*        Form  C * H, where H has order n. */

    // 根据 n 的大小选择不同的 Householder 变换方式
    switch (*n) {
        case 1:  goto L210;
        case 2:  goto L230;
        case 3:  goto L250;
        case 4:  goto L270;
        case 5:  goto L290;
        case 6:  goto L310;
        case 7:  goto L330;
        case 8:  goto L350;
        case 9:  goto L370;
        case 10:  goto L390;
    }

/*        Code for general N */

    // 调用 BLAS 库中的 slarf 函数，进行一般情况下的 Householder 变换
    slarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);
    // 跳转到结束标签 L410
    goto L410;
L210:

/*        Special code for 1 x 1 Householder */

    // 计算 1 x 1 Householder 变换的参数
    t1 = 1.f - *tau * v[1] * v[1];
    // 循环遍历矩阵 C 的每一行，应用 1 x 1 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        c__[j + c_dim1] = t1 * c__[j + c_dim1];
/* L220: */
    }
    // 跳转到结束标签 L410
    goto L410;
L230:

/*        Special code for 2 x 2 Householder */

    // 获取向量 v 的前 2 个元素，并计算它们与 tau 的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    // 循环遍历矩阵 C 的每一行，应用 2 x 2 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)];
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
/* L240: */
    }
    // 跳转到结束标签 L410
    goto L410;
L250:

/*        Special code for 3 x 3 Householder */

    // 获取向量 v 的前 3 个元素，并计算它们与 tau 的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    // 循环遍历矩阵 C 的每一行，应用 3 x 3 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3];
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
/* L260: */
    }
    // 跳转到结束标签 L410
    goto L410;
L270:

/*        Special code for 4 x 4 Householder */

    // 获取向量 v 的前 4 个元素，并计算它们与 tau 的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    t4 = *tau * v4;

计算变量 t4 的值，等于指针 tau 指向的值乘以 v4。


    i__1 = *m;

将指针 m 指向的值赋给变量 i__1，用于循环的上限。


    for (j = 1; j <= i__1; ++j) {

从 j=1 开始循环，直到 j <= i__1 结束循环。


        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)];

计算变量 sum 的值，为 v1 乘以 c__[j + c_dim1]、v2 乘以 c__[j + (c_dim1 << 1)]、v3 乘以 c__[j + c_dim1 * 3]、v4 乘以 c__[j + (c_dim1 << 2)] 的和。


        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;

更新数组 c__ 中的元素：
- c__[j + c_dim1] 减去 sum 乘以 t1 的值。
- c__[j + (c_dim1 << 1)] 减去 sum 乘以 t2 的值。
- c__[j + c_dim1 * 3] 减去 sum 乘以 t3 的值。
- c__[j + (c_dim1 << 2)] 减去 sum 乘以 t4 的值。
/* L280: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L290:

/*        Special code for 5 x 5 Householder */

    // 提取向量 v 中的元素并计算对应的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    // 对矩阵 c 中的列进行循环，应用 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算线性组合的和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5];
        // 更新矩阵 c 的列
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
/* L300: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L310:

/*        Special code for 6 x 6 Householder */

    // 提取向量 v 中的元素并计算对应的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    // 对矩阵 c 中的列进行循环，应用 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算线性组合的和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6];
        // 更新矩阵 c 的列
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
/* L320: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L330:

/*        Special code for 7 x 7 Householder */

    // 提取向量 v 中的元素并计算对应的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    // 对矩阵 c 中的列进行循环，应用 Householder 变换
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算线性组合的和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7];
        // 更新矩阵 c 的列
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
/* L340: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L350:

/*        Special code for 8 x 8 Householder */

    // 提取向量 v 中的元素并计算对应的乘积
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    // 对矩阵 c 中的列进行循环，应用 Householder 变换
    i__1 = *m;
    // 对数组 c__ 中的每个元素进行循环处理，计算其新值并更新
    for (j = 1; j <= i__1; ++j) {
        // 计算线性组合的和 sum
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)];
        // 根据预先计算好的系数 t1 到 t8，更新数组 c__ 中的每个元素
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
        c__[j + (c_dim1 << 3)] -= sum * t8;
    }
/* L360: */
    }
    goto L410;
L370:

/*        Special code for 9 x 9 Householder */

    v1 = v[1];  // 从向量 v 中读取第一个元素
    t1 = *tau * v1;  // 计算 tau 与 v1 的乘积
    v2 = v[2];  // 从向量 v 中读取第二个元素
    t2 = *tau * v2;  // 计算 tau 与 v2 的乘积
    v3 = v[3];  // 从向量 v 中读取第三个元素
    t3 = *tau * v3;  // 计算 tau 与 v3 的乘积
    v4 = v[4];  // 从向量 v 中读取第四个元素
    t4 = *tau * v4;  // 计算 tau 与 v4 的乘积
    v5 = v[5];  // 从向量 v 中读取第五个元素
    t5 = *tau * v5;  // 计算 tau 与 v5 的乘积
    v6 = v[6];  // 从向量 v 中读取第六个元素
    t6 = *tau * v6;  // 计算 tau 与 v6 的乘积
    v7 = v[7];  // 从向量 v 中读取第七个元素
    t7 = *tau * v7;  // 计算 tau 与 v7 的乘积
    v8 = v[8];  // 从向量 v 中读取第八个元素
    t8 = *tau * v8;  // 计算 tau 与 v8 的乘积
    v9 = v[9];  // 从向量 v 中读取第九个元素
    t9 = *tau * v9;  // 计算 tau 与 v9 的乘积
    i__1 = *m;  // 循环次数为 m
    for (j = 1; j <= i__1; ++j) {  // 循环遍历从 1 到 m
        // 计算矩阵乘积和，包括向量 v 的元素和矩阵 c__ 的乘积
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
            j + c_dim1 * 9];
        // 更新矩阵 c__ 的列向量，减去 sum 乘以对应的 tau 值
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
        c__[j + (c_dim1 << 3)] -= sum * t8;
        c__[j + c_dim1 * 9] -= sum * t9;
/* L380: */
    }
    goto L410;
L390:

/*        Special code for 10 x 10 Householder */

    v1 = v[1];  // 从向量 v 中读取第一个元素
    t1 = *tau * v1;  // 计算 tau 与 v1 的乘积
    v2 = v[2];  // 从向量 v 中读取第二个元素
    t2 = *tau * v2;  // 计算 tau 与 v2 的乘积
    v3 = v[3];  // 从向量 v 中读取第三个元素
    t3 = *tau * v3;  // 计算 tau 与 v3 的乘积
    v4 = v[4];  // 从向量 v 中读取第四个元素
    t4 = *tau * v4;  // 计算 tau 与 v4 的乘积
    v5 = v[5];  // 从向量 v 中读取第五个元素
    t5 = *tau * v5;  // 计算 tau 与 v5 的乘积
    v6 = v[6];  // 从向量 v 中读取第六个元素
    t6 = *tau * v6;  // 计算 tau 与 v6 的乘积
    v7 = v[7];  // 从向量 v 中读取第七个元素
    t7 = *tau * v7;  // 计算 tau 与 v7 的乘积
    v8 = v[8];  // 从向量 v 中读取第八个元素
    t8 = *tau * v8;  // 计算 tau 与 v8 的乘积
    v9 = v[9];  // 从向量 v 中读取第九个元素
    t9 = *tau * v9;  // 计算 tau 与 v9 的乘积
    v10 = v[10];  // 从向量 v 中读取第十个元素
    t10 = *tau * v10;  // 计算 tau 与 v10 的乘积
    i__1 = *m;  // 循环次数为 m
    for (j = 1; j <= i__1; ++j) {  // 循环遍历从 1 到 m
        // 计算矩阵乘积和，包括向量 v 的元素和矩阵 c__ 的乘积
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
            j + c_dim1 * 9] + v10 * c__[j + c_dim1 * 10];
        // 更新矩阵 c__ 的列向量，减去 sum 乘以对应的 tau 值
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
        c__[j + (c_dim1 << 3)] -= sum * t8;
        c__[j + c_dim1 * 9] -= sum * t9;
        c__[j + c_dim1 * 10] -= sum * t10;
/* L400: */
    }
    goto L410;
    }
L410:
    return 0;

/*     End of SLARFX */

} /* slarfx_ */

/* Subroutine */ int slartg_(real *f, real *g, real *cs, real *sn, real *r__)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2;

    /* Local variables */
    static integer i__;
    static real f1, g1, eps, scale;
    static integer count;
    static real safmn2, safmx2;
    extern doublereal slamch_(char *);
    static real safmin;


/*
    --
       ! 定义逻辑变量 FIRST，用于标记是否第一次调用该函数
       LOGICAL            FIRST
       ! 声明变量 FIRST, SAFMX2, SAFMIN, SAFMN2 在多次调用中保持不变
       SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
       ! 初始化 FIRST 为 TRUE
       DATA               FIRST / .TRUE. /

       ! 如果是第一次调用该函数，则执行以下代码块
       IF( FIRST ) THEN
/*
    safmin = slamch_("S");
    eps = slamch_("E");
    r__1 = slamch_("B");
    i__1 = (integer) (log(safmin / eps) / log(slamch_("B")) / 2.f);
    safmn2 = pow_ri(&r__1, &i__1);
    safmx2 = 1.f / safmn2;
*/
    // 获取安全最小值（safmin），机器精度（eps）和基数（r__1），计算safmn2和safmx2
    safmin = slamch_("S");  // 获取安全最小值（safmin）
    eps = slamch_("E");     // 获取机器精度（eps）
    r__1 = slamch_("B");    // 获取基数（r__1）
    // 计算指数i__1，使得 safmin / eps 的对数的一半成为i__1的值
    i__1 = (integer) (log(safmin / eps) / log(slamch_("B")) / 2.f);
    // 计算safmn2为 r__1 的 i__1 次幂
    safmn2 = pow_ri(&r__1, &i__1);
    // 计算safmx2为 1 / safmn2
    safmx2 = 1.f / safmn2;

/*
          FIRST = .FALSE.
       END IF
*/
    // 如果 g 等于 0，设定返回的参数
    if (*g == 0.f) {
    *cs = 1.f;
    *sn = 0.f;
    *r__ = *f;
    } else if (*f == 0.f) {
    *cs = 0.f;
    *sn = 1.f;
    *r__ = *g;
    } else {
    // 用局部变量存储输入的值
    f1 = *f;
    g1 = *g;
/* Computing MAX */
    // 计算 f1 和 g1 的绝对值中的较大值
    r__1 = dabs(f1), r__2 = dabs(g1);
    scale = dmax(r__1,r__2);
    // 如果 scale 大于或等于 safmx2
    if (scale >= safmx2) {
        count = 0;
L10:
        // 计数器加一
        ++count;
        // f1 和 g1 各自乘以 safmn2
        f1 *= safmn2;
        g1 *= safmn2;
/* Computing MAX */
        // 重新计算 scale 为 f1 和 g1 的绝对值中的较大值
        r__1 = dabs(f1), r__2 = dabs(g1);
        scale = dmax(r__1,r__2);
        // 如果 scale 仍然大于或等于 safmx2，回到标号 L10 处
        if (scale >= safmx2) {
        goto L10;
        }
/* Computing 2nd power */
        // 计算 f1 的平方
        r__1 = f1;
/* Computing 2nd power */
        // 计算 g1 的平方
        r__2 = g1;
        // 计算返回值 r__，余弦值 cs 和正弦值 sn
        *r__ = sqrt(r__1 * r__1 + r__2 * r__2);
        *cs = f1 / *r__;
        *sn = g1 / *r__;
        // 循环执行 count 次，将 r__ 乘以 safmx2
        i__1 = count;
        for (i__ = 1; i__ <= i__1; ++i__) {
        *r__ *= safmx2;
/* L20: */
        }
    } else if (scale <= safmn2) {
        count = 0;
L30:
        ++count;
        f1 *= safmx2;
        g1 *= safmx2;
/* Computing MAX */
        r__1 = dabs(f1), r__2 = dabs(g1);
        scale = dmax(r__1,r__2);
        if (scale <= safmn2) {
        goto L30;
        }
/* Computing 2nd power */
        r__1 = f1;
/* Computing 2nd power */
        r__2 = g1;
        *r__ = sqrt(r__1 * r__1 + r__2 * r__2);
        *cs = f1 / *r__;
        *sn = g1 / *r__;
        i__1 = count;
        for (i__ = 1; i__ <= i__1; ++i__) {
        *r__ *= safmn2;
/* L40: */
        }
    } else {
/* Computing 2nd power */
        r__1 = f1;
/* Computing 2nd power */
        r__2 = g1;
        *r__ = sqrt(r__1 * r__1 + r__2 * r__2);
        *cs = f1 / *r__;
        *sn = g1 / *r__;
    }
    // 如果 f 的绝对值大于 g 的绝对值且 cs 小于 0，则更改 cs、sn 和 r__
    if (dabs(*f) > dabs(*g) && *cs < 0.f) {
        *cs = -(*cs);
        *sn = -(*sn);
        *r__ = -(*r__);
    }
    }
    // 返回值为 0
    return 0;

/*     End of SLARTG */

} /* slartg_ */

/* Subroutine */ int slas2_(real *f, real *g, real *h__, real *ssmin, real *
    ssmax)
{
    // 局部变量声明
    /* System generated locals */
    real r__1, r__2;

    // 局部变量声明
    /* Local variables */
    static real c__, fa, ga, ha, as, at, au, fhmn, fhmx;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAS2  computes the singular values of the 2-by-2 matrix
       [  F   G  ]
       [  0   H  ].
    On return, SSMIN is the smaller singular value and SSMAX is the
    larger singular value.

    Arguments
    =========

    F       (input) REAL
            The (1,1) element of the 2-by-2 matrix.

    G       (input) REAL
            The (1,2) element of the 2-by-2 matrix.

    H       (input) REAL
            The (2,2) element of the 2-by-2 matrix.


*/
    # SSMIN (output) REAL
    #     存储较小的奇异值。

    # SSMAX (output) REAL
    #     存储较大的奇异值。

    # Further Details
    # ===============

    # 除非出现溢出/下溢，所有输出结果的精确度均在最后一位单位（ulp）以内，
    # 即使在加法/减法中没有守卫位的情况下也是如此。

    # 在 IEEE 算术中，如果一个矩阵元素是无穷大，该代码也能正确运行。

    # 只有在最大奇异值本身溢出或接近溢出的几个 ulp 时，才会发生溢出。
    # （在具有部分溢出的机器上，如 Cray，如果最大奇异值接近溢出的因子 2，则可能会发生溢出。）

    # 如果下溢是渐进的，那么它是无害的。否则，结果可能对应于由接近下溢阈值大小的扰动修改过的矩阵。
    
    # ====================================================================
    fa = dabs(*f);
    // 计算 f 的绝对值
    ga = dabs(*g);
    // 计算 g 的绝对值
    ha = dabs(*h__);
    // 计算 h__ 的绝对值
    fhmn = dmin(fa,ha);
    // 计算 fa 和 ha 的最小值，赋给 fhmn
    fhmx = dmax(fa,ha);
    // 计算 fa 和 ha 的最大值，赋给 fhmx
    if (fhmn == 0.f) {
    // 如果 fhmn 等于 0
        *ssmin = 0.f;
        // 将 ssmin 设为 0
        if (fhmx == 0.f) {
        // 如果 fhmx 也等于 0
            *ssmax = ga;
            // 将 ssmax 设为 ga 的值
        } else {
        // 否则
    /* Computing 2nd power */
            r__1 = dmin(fhmx,ga) / dmax(fhmx,ga);
            // 计算表达式中的平方
            *ssmax = dmax(fhmx,ga) * sqrt(r__1 * r__1 + 1.f);
            // 计算 ssmax
        }
    } else {
    // 如果 fhmn 不等于 0
        if (ga < fhmx) {
        // 如果 ga 小于 fhmx
            as = fhmn / fhmx + 1.f;
            // 计算 as
            at = (fhmx - fhmn) / fhmx;
            // 计算 at
    /* Computing 2nd power */
            r__1 = ga / fhmx;
            // 计算表达式中的平方
            au = r__1 * r__1;
            // 计算 au
            c__ = 2.f / (sqrt(as * as + au) + sqrt(at * at + au));
            // 计算 c__
            *ssmin = fhmn * c__;
            // 计算 ssmin
            *ssmax = fhmx / c__;
            // 计算 ssmax
        } else {
        // 否则
            au = fhmx / ga;
            // 计算 au
            if (au == 0.f) {

    /*
                    Avoid possible harmful underflow if exponent range
                    asymmetric (true SSMIN may not underflow even if
                    AU underflows)
    */

                *ssmin = fhmn * fhmx / ga;
                // 计算 ssmin
                *ssmax = ga;
                // 计算 ssmax
            } else {
            // 否则
                as = fhmn / fhmx + 1.f;
                // 计算 as
                at = (fhmx - fhmn) / fhmx;
                // 计算 at
    /* Computing 2nd power */
                r__1 = as * au;
    /* Computing 2nd power */
                r__2 = at * au;
                // 计算表达式中的平方
                c__ = 1.f / (sqrt(r__1 * r__1 + 1.f) + sqrt(r__2 * r__2 + 1.f));
                // 计算 c__
                *ssmin = fhmn * c__ * au;
                // 计算 ssmin
                *ssmin += *ssmin;
                // 更新 ssmin
                *ssmax = ga / (c__ + c__);
                // 计算 ssmax
            }
        }
    }
    return 0;

/*     End of SLAS2 */
    ! 根据输入的类型 TYPE 确定矩阵 A 的存储类型：
    ! 'G': A 是一个完整的矩阵。
    ! 'L': A 是一个下三角矩阵。
    ! 'U': A 是一个上三角矩阵。
    ! 'H': A 是一个上 Hessenberg 矩阵。
    ! 'B': A 是一个带状对称矩阵，具有下带宽 KL 和上带宽 KU，只存储下半部分。
    ! 'Q': A 是一个带状对称矩阵，具有下带宽 KL 和上带宽 KU，只存储上半部分。
    ! 'Z': A 是一个带状矩阵，具有下带宽 KL 和上带宽 KU。

    TYPE    (input) CHARACTER*1
            ! indices the storage type of the input matrix.

    KL      (input) INTEGER
            ! The lower bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.

    KU      (input) INTEGER
            ! The upper bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.

    CFROM   (input) REAL
            ! The scalar to multiply the matrix A.

    CTO     (input) REAL
            ! The scalar to divide the matrix A by.

    M       (input) INTEGER
            ! The number of rows of the matrix A. M >= 0.

    N       (input) INTEGER
            ! The number of columns of the matrix A. N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            ! The matrix to be multiplied by CTO/CFROM.

    LDA     (input) INTEGER
            ! The leading dimension of the array A. LDA >= max(1,M).

    INFO    (output) INTEGER
            ! 0 - successful exit
            ! <0 - if INFO = -i, the i-th argument had an illegal value.
    /* Parameter adjustments */
    // 调整参数指针，a_dim1 是 lda，a_offset 是 1 + a_dim1
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 将 info 设置为 0，表示初始化没有错误
    *info = 0;

    // 根据 type__ 的值确定 itype 的类型
    if (lsame_(type__, "G")) {
        itype = 0;
    } else if (lsame_(type__, "L")) {
        itype = 1;
    } else if (lsame_(type__, "U")) {
        itype = 2;
    } else if (lsame_(type__, "H")) {
        itype = 3;
    } else if (lsame_(type__, "B")) {
        itype = 4;
    } else if (lsame_(type__, "Q")) {
        itype = 5;
    } else if (lsame_(type__, "Z")) {
        itype = 6;
    } else {
        itype = -1;
    }

    // 如果 itype 未能识别类型，设置 *info 为相应的错误码
    if (itype == -1) {
        *info = -1;
    } else if (*cfrom == 0.f || sisnan_(cfrom)) {
        *info = -4;
    } else if (sisnan_(cto)) {
        *info = -5;
    } else if (*m < 0) {
        *info = -6;
    } else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m) {
        *info = -7;
    } else if (itype <= 3 && *lda < max(1,*m)) {
        *info = -9;
    } else if (itype >= 4) {
        // 检查 itype 为 4、5 或 6 时的特殊条件
        /* Computing MAX */
        i__1 = *m - 1;
        if (*kl < 0 || *kl > max(i__1,0)) {
            *info = -2;
        } else {
            /* Computing MAX */
            i__1 = *n - 1;
            if (*ku < 0 || *ku > max(i__1,0) || (itype == 4 || itype == 5) &&
                *kl != *ku) {
                *info = -3;
            } else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *
                ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1) {
                *info = -9;
            }
        }
    }

    // 如果发现有错误，调用错误处理程序 xerbla_
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASCL", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 如果 m 或 n 为 0，直接返回
    if (*n == 0 || *m == 0) {
        return 0;
    }

/*     Get machine parameters */

    // 获取机器参数，smlnum 是接近 1 的最小浮点数，bignum 是其倒数
    smlnum = slamch_("S");
    bignum = 1.f / smlnum;

    // 初始化 cfromc 和 ctoc
    cfromc = *cfrom;
    ctoc = *cto;

L10:
    // 根据 smlnum 计算 cfrom1
    cfrom1 = cfromc * smlnum;
    if (cfrom1 == cfromc) {
        // 如果 cfromc 是无穷大，根据 ctoc 的有限性选择乘法因子
        /* CFROMC is an inf.  Multiply by a correctly signed zero for
           finite CTOC, or a NaN if CTOC is infinite. */
        mul = ctoc / cfromc;
        done = TRUE_;
        cto1 = ctoc;
    } else {
        // 否则根据 bignum 计算 cto1，并根据比较结果选择乘法因子
        cto1 = ctoc / bignum;
        if (cto1 == ctoc) {
            /* CTOC is either 0 or an inf.  In both cases, CTOC itself
               serves as the correct multiplication factor. */
            mul = ctoc;
            done = TRUE_;
            cfromc = 1.f;
        } else if (dabs(cfrom1) > dabs(ctoc) && ctoc != 0.f) {
            mul = smlnum;
            done = FALSE_;
            cfromc = cfrom1;
        } else if (dabs(cto1) > dabs(cfromc)) {
            mul = bignum;
            done = FALSE_;
            ctoc = cto1;
        } else {
            mul = ctoc / cfromc;
            done = TRUE_;
        }
    }

    // 根据 itype 的类型执行相应的矩阵操作
    if (itype == 0) {

        /* Full matrix */
        // 对整个矩阵进行缩放操作
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] *= mul;
                /* L20: */
            }
            /* L30: */
        }

    } else if (itype == 1) {

        /* Lower triangular matrix */
        // 对下三角矩阵进行缩放操作
        i__1 = *n;
        ...
    // 外层循环，遍历从1到i__1的整数值，其中i__1是外层循环的上限
    for (j = 1; j <= i__1; ++j) {
        // 内层循环，遍历从j到*m的整数值，其中*m是内层循环的上限
        i__2 = *m;
        for (i__ = j; i__ <= i__2; ++i__) {
            // 访问和更新矩阵a中的元素，乘以变量mul
            a[i__ + j * a_dim1] *= mul;
    } else if (itype == 2) {

/*        上三角矩阵 */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
/*      对于每列 j，最多遍历到 j 和 m 中较小的一个 */
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L60: */
        }
/* L70: */
    }

    } else if (itype == 3) {

/*        上 Hessenberg 矩阵 */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* 计算 MIN */
        i__3 = j + 1;
        i__2 = min(i__3,*m);
/*      对于每列 j，最多遍历到 j+1 和 m 中较小的一个 */
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L80: */
        }
/* L90: */
    }

    } else if (itype == 4) {

/*        对称带矩阵的下半部分 */

    k3 = *kl + 1;
    k4 = *n + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* 计算 MIN */
        i__3 = k3, i__4 = k4 - j;
        i__2 = min(i__3,i__4);
/*      对于每列 j，最多遍历到 k3 和 k4-j 中较小的一个 */
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L100: */
        }
/* L110: */
    }

    } else if (itype == 5) {

/*        对称带矩阵的上半部分 */

    k1 = *ku + 2;
    k3 = *ku + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* 计算 MAX */
        i__2 = k1 - j;
        i__3 = k3;
/*      对于每列 j，从 max(k1-j,1) 到 k3 遍历 */
        for (i__ = max(i__2,1); i__ <= i__3; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L120: */
        }
/* L130: */
    }

    } else if (itype == 6) {

/*        带状矩阵 */

    k1 = *kl + *ku + 2;
    k2 = *kl + 1;
    k3 = (*kl << 1) + *ku + 1;
    k4 = *kl + *ku + 1 + *m;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* 计算 MAX 和 MIN */
        i__3 = k1 - j;
        i__4 = k3, i__5 = k4 - j;
        i__2 = min(i__4,i__5);
/*      对于每列 j，从 max(k1-j,k2) 到 min(k3,k4-j) 遍历 */
        for (i__ = max(i__3,k2); i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L140: */
        }
/* L150: */
    }

    }

    if (! done) {
    goto L10;
    }
/*  SLASCL 结束 */

} /* slascl_ */

/* Subroutine */ int slasd0_(integer *n, integer *sqre, real *d__, real *e,
    real *u, integer *ldu, real *vt, integer *ldvt, integer *smlsiz,
    integer *iwork, real *work, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, m, i1, ic, lf, nd, ll, nl, nr, im1, ncc, nlf, nrf,
        iwk, lvl, ndb1, nlp1, nrp1;
    static real beta;
    static integer idxq, nlvl;
    static real alpha;
    static integer inode, ndiml, idxqc, ndimr, itemp, sqrei;
    extern /* Subroutine */ int slasd1_(integer *, integer *, integer *, real
        *, real *, real *, real *, integer *, real *, integer *, integer *
        , integer *, real *, integer *), xerbla_(char *, integer *), slasdq_(char *, integer *, integer *, integer *, integer
        *, integer *, real *, real *, real *, integer *, real *, integer *
        , real *, integer *, real *, integer *), slasdt_(integer *
        , integer *, integer *, integer *, integer *, integer *, integer *
        );
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    Using a divide and conquer approach, SLASD0 computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M
    matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
    The algorithm computes orthogonal matrices U and VT such that
    B = U * S * VT. The singular values S are overwritten on D.

    A related subroutine, SLASDA, computes only the singular values,
    and optionally, the singular vectors in compact form.

    Arguments
    =========

    N      (input) INTEGER
           On entry, the row dimension of the upper bidiagonal matrix.
           This is also the dimension of the main diagonal array D.

    SQRE   (input) INTEGER
           Specifies the column dimension of the bidiagonal matrix.
           = 0: The bidiagonal matrix has column dimension M = N;
           = 1: The bidiagonal matrix has column dimension M = N+1;

    D      (input/output) REAL array, dimension (N)
           On entry D contains the main diagonal of the bidiagonal
           matrix.
           On exit D, if INFO = 0, contains its singular values.

    E      (input) REAL array, dimension (M-1)
           Contains the subdiagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    U      (output) REAL array, dimension at least (LDU, N)
           On exit, U contains the left singular vectors.

    LDU    (input) INTEGER
           On entry, leading dimension of U.

    VT     (output) REAL array, dimension at least (LDVT, M)
           On exit, VT' contains the right singular vectors.

    LDVT   (input) INTEGER
           On entry, leading dimension of VT.

    SMLSIZ (input) INTEGER
           On entry, maximum size of the subproblems at the
           bottom of the computation tree.

    IWORK  (workspace) INTEGER array, dimension (8*N)

    WORK   (workspace) REAL array, dimension (3*M**2+2*M)

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --e;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --iwork;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

    if (*n < 0) {  // 检查输入参数 n 是否小于 0
    *info = -1;
    } else if (*sqre < 0 || *sqre > 1) {  // 检查输入参数 sqre 是否不在 0 和 1 之间
    *info = -2;
    }

    m = *n + *sqre;  // 计算 m = n + sqre

    if (*ldu < *n) {  // 检查输入参数 ldu 是否小于 n
    *info = -6;
    } else if (*ldvt < m) {  // 检查输入参数 ldvt 是否小于 m
    *info = -8;
    } else if (*smlsiz < 3) {  // 检查输入参数 smlsiz 是否小于 3
    *info = -9;
    }
    if (*info != 0) {  // 如果 info 不等于 0，调用错误处理函数 xerbla_
    i__1 = -(*info);
    xerbla_("SLASD0", &i__1);
    return 0;
    }

/*     If the input matrix is too small, call SLASDQ to find the SVD. */

    if (*n <= *smlsiz) {  // 如果 n 小于等于 smlsiz，调用 SLASDQ 函数计算奇异值分解
    slasdq_("U", sqre, n, &m, n, &c__0, &d__[1], &e[1], &vt[vt_offset],
        ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[1], info);
    return 0;
    }

/*     Set up the computation tree. */

    inode = 1;  // 初始化节点编号为 1
    ndiml = inode + *n;  // 计算左子树维度的结束位置
    ndimr = ndiml + *n;  // 计算右子树维度的结束位置
    idxq = ndimr + *n;  // 计算索引的结束位置
    iwk = idxq + *n;  // 计算工作数组的结束位置
    slasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
        smlsiz);  // 调用 SLASDT 函数设置计算树结构

/*
       For the nodes on bottom level of the tree, solve
       their subproblems by SLASDQ.
*/

    ndb1 = (nd + 1) / 2;  // 计算最底层子节点数量的一半
    ncc = 0;  // 初始化计数器为 0
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {  // 遍历每个底层节点

/*
       IC : center row of each node
       NL : number of rows of left  subproblem
       NR : number of rows of right subproblem
       NLF: starting row of the left   subproblem
       NRF: starting row of the right  subproblem
*/

    i1 = i__ - 1;  // 计算节点编号的索引
    ic = iwork[inode + i1];  // 获取当前节点的中心行
    nl = iwork[ndiml + i1];  // 获取左子问题的行数
    nlp1 = nl + 1;  // nl + 1
    nr = iwork[ndimr + i1];  // 获取右子问题的行数
    nrp1 = nr + 1;  // nr + 1
    nlf = ic - nl;  // 左子问题的起始行
    nrf = ic + 1;  // 右子问题的起始行
    sqrei = 1;  // 设置奇异值分解的标志为 1
    slasdq_("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d__[nlf], &e[nlf], &vt[
        nlf + nlf * vt_dim1], ldvt, &u[nlf + nlf * u_dim1], ldu, &u[
        nlf + nlf * u_dim1], ldu, &work[1], info);  // 调用 SLASDQ 函数解决左子问题
    if (*info != 0) {  // 如果出错，返回
        return 0;
    }
    itemp = idxq + nlf - 2;  // 计算索引数组的起始位置
    i__2 = nl;
    for (j = 1; j <= i__2; ++j) {  // 初始化左子问题的索引数组
        iwork[itemp + j] = j;
/* L10: */
    }
    if (i__ == nd) {  // 如果是最后一个节点
        sqrei = *sqre;  // 使用输入参数 sqre
    } else {
        sqrei = 1;  // 否则使用默认值 1
    }
    nrp1 = nr + sqrei;  // 计算右子问题的结束行
    slasdq_("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d__[nrf], &e[nrf], &vt[
        nrf + nrf * vt_dim1], ldvt, &u[nrf + nrf * u_dim1], ldu, &u[
        nrf + nrf * u_dim1], ldu, &work[1], info);  // 调用 SLASDQ 函数解决右子问题
    if (*info != 0) {  // 如果出错，返回
        return 0;
    }
    itemp = idxq + ic;  // 计算索引数组的起始位置
    i__2 = nr;
    for (j = 1; j <= i__2; ++j) {  // 初始化右子问题的索引数组
        iwork[itemp + j - 1] = j;
/* L20: */
    }
/* L30: */
    }

/*     Now conquer each subproblem bottom-up. */

    for (lvl = nlvl; lvl >= 1; --lvl) {  // 自底向上解决每个子问题

/*
          Find the first node LF and last node LL on the
          current level LVL.
*/

    if (lvl == 1) {  // 如果是第一层
        lf = 1;  // 第一个节点编号为 1
        ll = 1;  // 最后一个节点编号为 1
    } else {
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);  // 计算第一个节点编号
        ll = (lf << 1) - 1;  // 计算最后一个节点编号
    }
    i__1 = ll;
    # 循环遍历 lf 到 i__1 之间的整数，i__ 是循环变量
    for (i__ = lf; i__ <= i__1; ++i__) {
        # 计算前一个索引
        im1 = i__ - 1;
        # 从 iwork 数组中获取 ic 值
        ic = iwork[inode + im1];
        # 从 iwork 数组中获取 nl 值
        nl = iwork[ndiml + im1];
        # 从 iwork 数组中获取 nr 值
        nr = iwork[ndimr + im1];
        # 计算 nlf 的值
        nlf = ic - nl;
        # 如果 sqre 不为 0 并且 i__ 等于 ll，则 sqrei 等于 sqre；否则为 1
        if (*sqre == 0 && i__ == ll) {
            sqrei = *sqre;
        } else {
            sqrei = 1;
        }
        # 计算 idxqc 的值
        idxqc = idxq + nlf - 1;
        # 获取 d__[ic] 的值赋给 alpha
        alpha = d__[ic];
        # 获取 e[ic] 的值赋给 beta
        beta = e[ic];
        # 调用 slasd1_ 函数，进行奇异值分解计算
        slasd1_(&nl, &nr, &sqrei, &d__[nlf], &alpha, &beta, &u[nlf + nlf * u_dim1], ldu, &vt[nlf + nlf * vt_dim1], ldvt, &iwork[idxqc], &iwork[iwk], &work[1], info);
        # 如果返回的 info 不为 0，则返回 0
        if (*info != 0) {
            return 0;
        }
    }
/* L40: */
    }
/* L50: */
    }

    return 0;

/*     End of SLASD0 */

} /* slasd0_ */

/* Subroutine */ int slasd1_(integer *nl, integer *nr, integer *sqre, real *
    d__, real *alpha, real *beta, real *u, integer *ldu, real *vt,
    integer *ldvt, integer *idxq, integer *iwork, real *work, integer *
    info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1;
    real r__1, r__2;

    /* Local variables */
    static integer i__, k, m, n, n1, n2, iq, iz, iu2, ldq, idx, ldu2, ivt2,
        idxc, idxp, ldvt2;
    extern /* Subroutine */ int slasd2_(integer *, integer *, integer *,
        integer *, real *, real *, real *, real *, real *, integer *,
        real *, integer *, real *, real *, integer *, real *, integer *,
        integer *, integer *, integer *, integer *, integer *, integer *),
         slasd3_(integer *, integer *, integer *, integer *, real *, real
        *, integer *, real *, real *, integer *, real *, integer *, real *
        , integer *, real *, integer *, integer *, integer *, real *,
        integer *);
    static integer isigma;
    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
        char *, integer *, integer *, real *, real *, integer *, integer *
        , real *, integer *, integer *), slamrg_(integer *,
        integer *, real *, integer *, integer *, integer *);
    static real orgnrm;
    static integer coltyp;


/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
    where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0.

    A related subroutine SLASD7 handles the case in which the singular
    values (and the singular vectors in factored form) are desired.

    SLASD1 computes the SVD as follows:

                  ( D1(in)  0    0     0 )
      B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
                  (   0     0   D2(in) 0 )

        = U(out) * ( D(out) 0) * VT(out)

    where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The left singular vectors of the original matrix are stored in U, and
    the transpose of the right singular vectors are stored in VT, and the
*/


注释中包含了代码块的注释解释，保持了原始代码的结构和格式。
    singular values are in D.  The algorithm consists of three stages:

       The first stage consists of deflating the size of the problem
       when there are multiple singular values or when there are zeros in
       the Z vector.  For each such occurence the dimension of the
       secular equation problem is reduced by one.  This stage is
       performed by the routine SLASD2.

       The second stage consists of calculating the updated
       singular values. This is done by finding the square roots of the
       roots of the secular equation via the routine SLASD4 (as called
       by SLASD3). This routine also calculates the singular vectors of
       the current problem.

       The final stage consists of computing the updated singular vectors
       directly using the updated singular values.  The singular vectors
       for the current problem are multiplied with the singular vectors
       from the overall problem.

    Arguments
    =========

    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has row dimension N = NL + NR + 1,
           and column dimension M = N + SQRE.

    D      (input/output) REAL array, dimension (NL+NR+1).
           N = NL+NR+1
           On entry D(1:NL,1:NL) contains the singular values of the
           upper block; and D(NL+2:N) contains the singular values of
           the lower block. On exit D(1:N) contains the singular values
           of the modified matrix.

    ALPHA  (input/output) REAL
           Contains the diagonal element associated with the added row.

    BETA   (input/output) REAL
           Contains the off-diagonal element associated with the added
           row.

    U      (input/output) REAL array, dimension (LDU,N)
           On entry U(1:NL, 1:NL) contains the left singular vectors of
           the upper block; U(NL+2:N, NL+2:N) contains the left singular
           vectors of the lower block. On exit U contains the left
           singular vectors of the bidiagonal matrix.

    LDU    (input) INTEGER
           The leading dimension of the array U.  LDU >= max( 1, N ).

    VT     (input/output) REAL array, dimension (LDVT,M)
           where M = N + SQRE.
           On entry VT(1:NL+1, 1:NL+1)' contains the right singular
           vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
           the right singular vectors of the lower block. On exit
           VT' contains the right singular vectors of the
           bidiagonal matrix.

    LDVT   (input) INTEGER
           The leading dimension of the array VT.  LDVT >= max( 1, M ).
    # IDXQ 是整数数组，维度为 (N)，存储将子问题解归并回排序顺序的排列
           这里包含的排列将重新整合刚刚解决的子问题，使得 D(IDXQ(I = 1, N)) 以升序排列。

    # IWORK 是整数数组，维度为 (4*N)，用作工作空间。

    # WORK 是实数数组，维度为 (3*M**2 + 2*M)，也用作工作空间。

    # INFO 是输出参数，整数类型
            = 0:  成功退出。
            < 0:  如果 INFO = -i，则第 i 个参数有非法值。
            > 0:  如果 INFO = 1，则某个奇异值未收敛。

    # 进一步细节
    # ===============

    # 本代码的贡献者包括
    #    Ming Gu 和 Huan Ren，加利福尼亚大学伯克利分校计算机科学系，美国

    # =====================================================================


       检测输入参数的有效性。
    /*
       Parameter adjustments
    */
    --d__;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --idxq;
    --iwork;
    --work;

    /*
       Function Body
    */
    *info = 0;

    if (*nl < 1) {
        *info = -1;
    } else if (*nr < 1) {
        *info = -2;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -3;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASD1", &i__1);
        return 0;
    }

    n = *nl + *nr + 1;
    m = n + *sqre;

    /*
           The following values are for bookkeeping purposes only.  They are
           integer pointers which indicate the portion of the workspace
           used by a particular array in SLASD2 and SLASD3.
    */
    ldu2 = n;
    ldvt2 = m;

    iz = 1;
    isigma = iz + m;
    iu2 = isigma + n;
    ivt2 = iu2 + ldu2 * n;
    iq = ivt2 + ldvt2 * m;

    idx = 1;
    idxc = idx + n;
    coltyp = idxc + n;
    idxp = coltyp + n;

    /*
           Scale.

       Computing MAX
    */
    r__1 = dabs(*alpha), r__2 = dabs(*beta);
    orgnrm = dmax(r__1,r__2);
    d__[*nl + 1] = 0.f;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if ((r__1 = d__[i__], dabs(r__1)) > orgnrm) {
            orgnrm = (r__1 = d__[i__], dabs(r__1));
        }
        /* L10: */
    }
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &n, &c__1, &d__[1], &n, info);
    *alpha /= orgnrm;
    *beta /= orgnrm;

    /* Deflate singular values. */
    slasd2_(nl, nr, sqre, &k, &d__[1], &work[iz], alpha, beta, &u[u_offset],
            ldu, &vt[vt_offset], ldvt, &work[isigma], &work[iu2], &ldu2, &
            work[ivt2], &ldvt2, &iwork[idxp], &iwork[idx], &iwork[idxc], &
            idxq[1], &iwork[coltyp], info);

    /* Solve Secular Equation and update singular vectors. */
    ldq = k;
    slasd3_(nl, nr, sqre, &k, &d__[1], &work[iq], &ldq, &work[isigma], &u[
            u_offset], ldu, &work[iu2], &ldu2, &vt[vt_offset], ldvt, &work[
            ivt2], &ldvt2, &iwork[idxc], &iwork[coltyp], &work[iz], info);
    if (*info != 0) {
        return 0;
    }

    /* Unscale. */
    slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &n, &c__1, &d__[1], &n, info);

    /* Prepare the IDXQ sorting permutation. */
    n1 = k;
    n2 = n - k;
    slamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &idxq[1]);

    return 0;

    /* End of SLASD1 */
} /* slasd1_ */

/* Subroutine */ int slasd2_(integer *nl, integer *nr, integer *sqre, integer
    *k, real *d__, real *z__, real *alpha, real *beta, real *u, integer *
    ldu, real *vt, integer *ldvt, real *dsigma, real *u2, integer *ldu2,
    real *vt2, integer *ldvt2, integer *idxp, integer *idx, integer *idxc,
    integer *idxq, integer *coltyp, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1, vt_offset,
        vt2_dim1, vt2_offset, i__1;
    real r__1, r__2;

    /* Local variables */
    static real c__;
    static integer i__, j, m, n;
    static real s;
    static integer k2;
    static real z1;
    static integer ct, jp;
    static real eps, tau, tol;
    static integer psm[4], nlp1, nlp2, idxi, idxj, ctot[4];

静态声明变量，包括整数（`ct`, `jp`, `nlp1`, `nlp2`, `idxi`, `idxj`, `ctot[4]`）和实数（`eps`, `tau`, `tol`, `psm[4]`）类型的变量，用于存储程序中的各种计数、索引和阈值等信息。


    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);

声明外部函数 `srot_`，该函数接受一些整数和实数参数，用于执行特定的旋转操作。


    static integer idxjp, jprev;

声明静态整数变量 `idxjp` 和 `jprev`，用于存储索引值。


    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);

声明外部函数 `scopy_`，用于在实数数组之间进行复制操作。


    extern doublereal slapy2_(real *, real *), slamch_(char *);

声明外部函数 `slapy2_` 和 `slamch_`，分别用于计算两个实数的平方和并返回双精度结果，以及获取机器参数的函数。


    extern /* Subroutine */ int xerbla_(char *, integer *);

声明外部函数 `xerbla_`，用于处理错误信息输出。


    extern /* Subroutine */ int slamrg_(
        integer *, integer *, real *, integer *, integer *, integer *);

声明外部函数 `slamrg_`，用于合并两个有序数组。


    static real hlftol;

静态声明实数变量 `hlftol`，用于存储某种半阈值。


    extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *);

声明外部函数 `slacpy_`，用于将一个实数数组复制到另一个实数数组。


    extern /* Subroutine */ int slaset_(char *, integer *,
        integer *, real *, real *, real *, integer *);

声明外部函数 `slaset_`，用于设置实数矩阵的所有元素为指定值。
/*
    -- LAPACK辅助例程（版本3.2）--
    -- LAPACK是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包。--
       2006年11月


    目的
    =======

    SLASD2将两组奇异值合并为单个排序的集合。然后尝试减小问题的规模。
    减小问题规模有两种方式：当两个或更多奇异值接近时，或者Z向量中存在一个微小的条目。每次出现这种情况时，相关的世俗方程问题的阶数都会减少一次。

    SLASD2从SLASD1中调用。

    参数
    =========

    NL     （输入）整数
           上半部分的行维度。NL >= 1。

    NR     （输入）整数
           下半部分的行维度。NR >= 1。

    SQRE   （输入）整数
           = 0：下半部分是一个NR×NR的方阵。
           = 1：下半部分是一个NR×(NR+1)的矩形矩阵。

           双对角矩阵有N = NL + NR + 1行和M = N + SQRE >= N列。

    K      （输出）整数
           非缩小矩阵的维度，这是相关世俗方程的阶数。1 <= K <= N。

    D      （输入/输出）实数数组，维度为（N）
           在输入时，D包含要合并的两个子矩阵的奇异值。
           在输出时，D包含排列成增序的更新的尾部（N-K）奇异值（被缩小的那些）。

    Z      （输出）实数数组，维度为（N）
           在输出时，Z包含世俗方程中的更新行向量。

    ALPHA  （输入）实数
           包含与添加行相关联的对角线元素。

    BETA   （输入）实数
           包含与添加行相关联的非对角线元素。

    U      （输入/输出）实数数组，维度为（LDU,N）
           在输入时，U包含两个子矩阵中左奇异向量，这些子矩阵的角落在（1,1）、（NL, NL）和（NL+2, NL+2）、（N,N）。
           在输出时，U的最后N-K列包含更新的左奇异向量（被缩小的那些）。

    LDU    （输入）整数
           数组U的领先维度。LDU >= N。

    VT     （输入/输出）实数数组，维度为（LDVT,M）
           在输入时，VT的转置包含两个子矩阵中的右奇异向量，这些子矩阵的角落在（1,1）、（NL+1, NL+1）和（NL+2, NL+2）、（M,M）。
           在输出时，VT的转置的最后N-K列包含更新的右奇异向量（被缩小的那些）。
           如果SQRE = 1，则VT的最后一行跨越右零空间。

    LDVT   （输入）整数
           数组VT的领先维度。LDVT >= M。

*/
    # DSIGMA (output) REAL array, dimension (N)
    #    存储截断奇异值问题中对角元素的副本（K-1个奇异值和一个零）。

    # U2 (output) REAL array, dimension (LDU2,N)
    #    存储前K-1个左奇异向量的副本，将用于SLASD3中的矩阵乘法（SGEMM）以解决新的左奇异向量。U2被分成四个块。
    #    第一个块包含一个在NL+1处为1，其他位置为零的列；第二个块只在NL及以上位置有非零条目；
    #    第三个块只在NL+1以下位置有非零条目；第四个块是密集的。

    # LDU2 (input) INTEGER
    #    数组U2的领先维度。LDU2 >= N。

    # VT2 (output) REAL array, dimension (LDVT2,N)
    #    VT2'包含前K个右奇异向量的副本，将用于SLASD3中的矩阵乘法（SGEMM）以解决新的右奇异向量。VT2被分成三个块。
    #    第一个块包含与SIGMA中特殊的零对角元素对应的行；第二个块包含在NL+1及其之前位置非零的条目；
    #    第三个块包含在NL+2及其之后位置非零的条目。

    # LDVT2 (input) INTEGER
    #    数组VT2的领先维度。LDVT2 >= M。

    # IDXP (workspace) INTEGER array, dimension (N)
    #    将包含用于将D的被截断值放置在数组末尾的置换。在输出时，IDXP(2:K)指向未被截断的D值，IDXP(K+1:N)指向被截断的奇异值。

    # IDX (workspace) INTEGER array, dimension (N)
    #    将包含用于将D的内容按升序排序的置换。

    # IDXC (output) INTEGER array, dimension (N)
    #    将包含用于将截断后的U矩阵的列排列成三组的置换。第一组仅包含在NL及以上位置有非零条目的列，
    #    第二组仅包含在NL+2以下位置有非零条目的列，第三组是密集的。

    # IDXQ (input/output) INTEGER array, dimension (N)
    #    包含将D中两个子问题分别按升序排序的置换。需要注意，此置换的前半部分的条目需要向后移动一位，
    #    而后半部分的条目需要将NL+1添加到它们的值中。
    # COLTYP 是一个整数数组，维度为 (N)，作为工作空间使用，用于标识以下情况：
    # 1 : 仅在上半部分非零
    # 2 : 仅在下半部分非零
    # 3 : 密集型
    # 4 : 被压缩
    # 这些标识表示在矩阵 U2 的列或者矩阵 VT2 的行中的列的类型。

    COLTYP (workspace/output) INTEGER array, dimension (N)
           As workspace, this will contain a label which will indicate
           which of the following types a column in the U2 matrix or a
           row in the VT2 matrix is:
           1 : non-zero in the upper half only
           2 : non-zero in the lower half only
           3 : dense
           4 : deflated

           On exit, it is an array of dimension 4, with COLTYP(I) being
           the dimension of the I-th type columns.

    # INFO 是一个输出参数，表示函数执行的结果：
    # = 0: 成功退出。
    # < 0: 如果 INFO = -i，表示第 i 个参数的值非法。

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步的细节
    # ===============

    # 此函数的实现基于以下贡献者的工作：
    # 明·顾 和 环·任，加利福尼亚大学伯克利分校，计算机科学系，美国

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --z__;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --dsigma;
    u2_dim1 = *ldu2;
    u2_offset = 1 + u2_dim1;
    u2 -= u2_offset;
    vt2_dim1 = *ldvt2;
    vt2_offset = 1 + vt2_dim1;
    vt2 -= vt2_offset;
    --idxp;
    --idx;
    --idxc;
    --idxq;
    --coltyp;

    /* Function Body */
    *info = 0;

    /* Check if dimensions are valid */
    if (*nl < 1) {
        *info = -1;
    } else if (*nr < 1) {
        *info = -2;
    } else if (*sqre != 1 && *sqre != 0) {
        *info = -3;
    }

    /* Calculate total dimensions */
    n = *nl + *nr + 1;
    m = n + *sqre;

    /* Check if leading dimensions are sufficient */
    if (*ldu < n) {
        *info = -10;
    } else if (*ldvt < m) {
        *info = -12;
    } else if (*ldu2 < n) {
        *info = -15;
    } else if (*ldvt2 < m) {
        *info = -17;
    }

    /* Handle errors */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASD2", &i__1);
        return 0;
    }

    nlp1 = *nl + 1;
    nlp2 = *nl + 2;

    /*
       Generate the first part of the vector Z; and move the singular
       values in the first part of D one position backward.
    */

    z1 = *alpha * vt[nlp1 + nlp1 * vt_dim1];
    z__[1] = z1;
    for (i__ = *nl; i__ >= 1; --i__) {
        z__[i__ + 1] = *alpha * vt[i__ + nlp1 * vt_dim1];
        d__[i__ + 1] = d__[i__];
        idxq[i__ + 1] = idxq[i__] + 1;
        /* L10: */
    }

    /* Generate the second part of the vector Z. */

    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        z__[i__] = *beta * vt[i__ + nlp2 * vt_dim1];
        /* L20: */
    }

    /* Initialize column types for reference arrays. */

    i__1 = nlp1;
    for (i__ = 2; i__ <= i__1; ++i__) {
        coltyp[i__] = 1;
        /* L30: */
    }
    i__1 = n;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        coltyp[i__] = 2;
        /* L40: */
    }

    /* Sort the singular values into increasing order */

    i__1 = n;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        idxq[i__] += nlp1;
        /* L50: */
    }

    /*
       DSIGMA, IDXC, IDXC, and the first column of U2
       are used as storage space.
    */

    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        dsigma[i__] = d__[idxq[i__]];
        u2[i__ + u2_dim1] = z__[idxq[i__]];
        idxc[i__] = coltyp[idxq[i__]];
        /* L60: */
    }

    /* Sort the singular values using slamrg */

    slamrg_(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);

    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        idxi = idx[i__] + 1;
        d__[i__] = dsigma[idxi];
        z__[i__] = u2[idxi + u2_dim1];
        coltyp[i__] = idxc[idxi];
        /* L70: */
    }

    /* Calculate the allowable deflation tolerance */

    eps = slamch_("Epsilon");
    /* Computing MAX */
    r__1 = dabs(*alpha), r__2 = dabs(*beta);
    tol = dmax(r__1,r__2);
    /* Computing MAX */
    r__2 = (r__1 = d__[n], dabs(r__1));
    tol = eps * 8.f * dmax(r__2,tol);
/*
   There are 2 kinds of deflation -- first a value in the z-vector
   is small, second two (or more) singular values are very close
   together (their difference is small).

   If the value in the z-vector is small, we simply permute the
   array so that the corresponding singular value is moved to the
   end.

   If two values in the D-vector are close, we perform a two-sided
   rotation designed to make one of the corresponding z-vector
   entries zero, and then permute the array so that the deflated
   singular value is moved to the end.

   If there are multiple singular values then the problem deflates.
   Here the number of equal singular values are found.  As each equal
   singular value is found, an elementary reflector is computed to
   rotate the corresponding singular subspace so that the
   corresponding components of Z are zero in this new basis.
*/

*k = 1;  // Initialize the count of singular values

k2 = n + 1;  // Initialize index for storing deflated indices

// Loop through the singular values
i__1 = n;
for (j = 2; j <= i__1; ++j) {
if ((r__1 = z__[j], dabs(r__1)) <= tol) {

/* Deflate due to small z component. */

--k2;  // Decrease the index for deflated singular values
idxp[k2] = j;  // Store the index of deflated singular value
coltyp[j] = 4;  // Mark the column type as deflated

if (j == n) {
goto L120;  // Exit loop if at the end of singular values
}
} else {
jprev = j;  // Record the previous singular value index
goto L90;  // Jump to check for close singular values
}
/* L80: */
}
L90:
j = jprev;  // Start from the previously recorded singular value index
L100:
++j;  // Move to the next singular value index

if (j > n) {
goto L110;  // Exit loop if reached the end of singular values
}

if ((r__1 = z__[j], dabs(r__1)) <= tol) {

/* Deflate due to small z component. */

--k2;  // Decrease the index for deflated singular values
idxp[k2] = j;  // Store the index of deflated singular value
coltyp[j] = 4;  // Mark the column type as deflated

} else {

/* Check if singular values are close enough to allow deflation. */

if ((r__1 = d__[j] - d__[jprev], dabs(r__1)) <= tol) {

/* Deflation is possible. */

s = z__[jprev];  // Store previous z-vector value
c__ = z__[j];  // Store current z-vector value

/*
   Find sqrt(a**2+b**2) without overflow or
   destructive underflow.
*/

tau = slapy2_(&c__, &s);  // Compute the hypotenuse sqrt(a**2 + b**2)
c__ /= tau;  // Normalize c
s = -s / tau;  // Compute and normalize s
z__[j] = tau;  // Update z-vector with tau
z__[jprev] = 0.f;  // Set previous z-vector value to zero

/*
   Apply back the Givens rotation to the left and right
   singular vector matrices.
*/

idxjp = idxq[idx[jprev] + 1];  // Retrieve index for left singular vector
idxj = idxq[idx[j] + 1];  // Retrieve index for right singular vector

if (idxjp <= nlp1) {
--idxjp;  // Adjust index if within range
}
if (idxj <= nlp1) {
--idxj;  // Adjust index if within range
}

srot_(&n, &u[idxjp * u_dim1 + 1], &c__1, &u[idxj * u_dim1 + 1], &
    c__1, &c__, &s);  // Apply Givens rotation to left singular vectors
srot_(&m, &vt[idxjp + vt_dim1], ldvt, &vt[idxj + vt_dim1], ldvt, &
    c__, &s);  // Apply Givens rotation to right singular vectors

if (coltyp[j] != coltyp[jprev]) {
coltyp[j] = 3;  // Mark column type as reflector
}
coltyp[jprev] = 4;  // Mark previous column type as deflated
--k2;  // Decrease the index for deflated singular values
idxp[k2] = jprev;  // Store the index of deflated singular value
jprev = j;  // Update previous singular value index
} else {
++(*k);  // Increment count of singular values
u2[*k + u2_dim1] = z__[jprev];  // Store previous z-vector value
dsigma[*k] = d__[jprev];  // Store previous singular value
idxp[*k] = jprev;  // Store index of previous singular value
jprev = j;  // Update previous singular value index
}
}
goto L100;  // Return to loop for next singular value

L110:

/* Record the last singular value. */

++(*k);  // Increment count of singular values
u2[*k + u2_dim1] = z__[jprev];  // Store last z-vector value
dsigma[*k] = d__[jprev];  // Store last singular value
idxp[*k] = jprev;  // Store index of last singular value

L120:
/*
       Count up the total number of the various types of columns, then
       form a permutation which positions the four column types into
       four groups of uniform structure (although one or more of these
       groups may be empty).
*/
for (j = 1; j <= 4; ++j) {
    ctot[j - 1] = 0;
/* L130: */
}

i__1 = n;
for (j = 2; j <= i__1; ++j) {
    ct = coltyp[j];
    ++ctot[ct - 1];
/* L140: */
}

/* PSM(*) = Position in SubMatrix (of types 1 through 4) */
psm[0] = 2;
psm[1] = ctot[0] + 2;
psm[2] = psm[1] + ctot[1];
psm[3] = psm[2] + ctot[2];

/*
       Fill out the IDXC array so that the permutation which it induces
       will place all type-1 columns first, all type-2 columns next,
       then all type-3's, and finally all type-4's, starting from the
       second column. This applies similarly to the rows of VT.
*/
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    ct = coltyp[jp];
    idxc[psm[ct - 1]] = j;
    ++psm[ct - 1];
/* L150: */
}

/*
       Sort the singular values and corresponding singular vectors into
       DSIGMA, U2, and VT2 respectively.  The singular values/vectors
       which were not deflated go into the first K slots of DSIGMA, U2,
       and VT2 respectively, while those which were deflated go into the
       last N - K slots, except that the first column/row will be treated
       separately.
*/
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    dsigma[j] = d__[jp];
    idxj = idxq[idx[idxp[idxc[j]]] + 1];
    if (idxj <= nlp1) {
        --idxj;
    }
    scopy_(&n, &u[idxj * u_dim1 + 1], &c__1, &u2[j * u2_dim1 + 1], &c__1);
    scopy_(&m, &vt[idxj + vt_dim1], ldvt, &vt2[j + vt2_dim1], ldvt2);
/* L160: */
}

/* Determine DSIGMA(1), DSIGMA(2) and Z(1) */
dsigma[1] = 0.f;
hlftol = tol / 2.f;
if (dabs(dsigma[2]) <= hlftol) {
    dsigma[2] = hlftol;
}
if (m > n) {
    z__[1] = slapy2_(&z1, &z__[m]);
    if (z__[1] <= tol) {
        c__ = 1.f;
        s = 0.f;
        z__[1] = tol;
    } else {
        c__ = z1 / z__[1];
        s = z__[m] / z__[1];
    }
} else {
    if (dabs(z1) <= tol) {
        z__[1] = tol;
    } else {
        z__[1] = z1;
    }
}

/* Move the rest of the updating row to Z. */
i__1 = *k - 1;
scopy_(&i__1, &u2[u2_dim1 + 2], &c__1, &z__[2], &c__1);

/*
       Determine the first column of U2, the first row of VT2 and the
       last row of VT.
*/
slaset_("A", &n, &c__1, &c_b29, &c_b29, &u2[u2_offset], ldu2);
u2[nlp1 + u2_dim1] = 1.f;
if (m > n) {
    i__1 = nlp1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        vt[m + i__ * vt_dim1] = -s * vt[nlp1 + i__ * vt_dim1];
        vt2[i__ * vt2_dim1 + 1] = c__ * vt[nlp1 + i__ * vt_dim1];
/* L170: */
    }
    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        vt2[i__ * vt2_dim1 + 1] = s * vt[m + i__ * vt_dim1];
        vt[m + i__ * vt_dim1] = c__ * vt[m + i__ * vt_dim1];
/* L180: */
    }
} else {

/*
       Determine the first column of U2, the first row of VT2 and the
       last row of VT.
*/
slaset_("A", &n, &c__1, &c_b29, &c_b29, &u2[u2_offset], ldu2);
u2[nlp1 + u2_dim1] = 1.f;
if (m > n) {
    // Update columns in VT and VT2 when m > n
    i__1 = nlp1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        vt[m + i__ * vt_dim1] = -s * vt[nlp1 + i__ * vt_dim1];
        vt2[i__ * vt2_dim1 + 1] = c__ * vt[nlp1 + i__ * vt_dim1];
/* L170: */
    }
    // Update rows in VT and VT2 when m > n
    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        vt2[i__ * vt2_dim1 + 1] = s * vt[m + i__ * vt_dim1];
        vt[m + i__ * vt_dim1] = c__ * vt[m + i__ * vt_dim1];
/* L180: */
    }
} else {
    // Handle the case when m <= n

    // Handle the case when m <= n
    if (dabs(z1) <= tol) {
        z__[1] = tol;
    } else {
        z__[1] = z1;
    }
}
    ! 调用 SCOPY_ 函数，将矩阵 m 的部分复制到 vt 的特定行上，并存储到 vt2 的对应行上
    scopy_(&m, &vt[nlp1 + vt_dim1], ldvt, &vt2[vt2_dim1 + 1], ldvt2);
    }
    ! 如果 m 大于 n，则继续复制矩阵 m 的另一部分到 vt2 的另一对应行上
    if (m > n) {
    ! 调用 SCOPY_ 函数，将矩阵 m 的另一部分复制到 vt 的另一行上，并存储到 vt2 的另一对应行上
    scopy_(&m, &vt[m + vt_dim1], ldvt, &vt2[m + vt2_dim1], ldvt2);
    }
/*
       The deflated singular values and their corresponding vectors go
       into the back of D, U, and V respectively.
*/
    if (n > *k) {
    // 如果 n 大于 k，则执行以下操作
    i__1 = n - *k;
    // 计算需要复制的元素个数
    scopy_(&i__1, &dsigma[*k + 1], &c__1, &d__[*k + 1], &c__1);
    // 复制 dsigma[*k+1] 到 d__[*k+1]
    i__1 = n - *k;
    // 计算需要复制的元素个数
    slacpy_("A", &n, &i__1, &u2[(*k + 1) * u2_dim1 + 1], ldu2, &u[(*k + 1)
         * u_dim1 + 1], ldu);
    // 复制 u2 的一部分到 u
    i__1 = n - *k;
    // 计算需要复制的元素个数
    slacpy_("A", &i__1, &m, &vt2[*k + 1 + vt2_dim1], ldvt2, &vt[*k + 1 +
        vt_dim1], ldvt);
    // 复制 vt2 的一部分到 vt
    }

/*     Copy CTOT into COLTYP for referencing in SLASD3. */
    for (j = 1; j <= 4; ++j) {
    // 遍历 j 从 1 到 4
    coltyp[j] = ctot[j - 1];
    // 将 ctot 的值复制到 coltyp
/* L190: */
    }

    return 0;

/*     End of SLASD2 */

} /* slasd2_ */

/* Subroutine */ int slasd3_(integer *nl, integer *nr, integer *sqre, integer
    *k, real *d__, real *q, integer *ldq, real *dsigma, real *u, integer *
    ldu, real *u2, integer *ldu2, real *vt, integer *ldvt, real *vt2,
    integer *ldvt2, integer *idxc, integer *ctot, real *z__, integer *
    info)
{
    /* System generated locals */
    integer q_dim1, q_offset, u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1,
        vt_offset, vt2_dim1, vt2_offset, i__1, i__2;
    real r__1, r__2;

    /* Local variables */
    static integer i__, j, m, n, jc;
    static real rho;
    static integer nlp1, nlp2, nrp1;
    static real temp;
    extern doublereal snrm2_(integer *, real *, integer *);
    static integer ctemp;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer ktemp;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    extern doublereal slamc3_(real *, real *);
    extern /* Subroutine */ int slasd4_(integer *, integer *, real *, real *,
        real *, real *, real *, real *, integer *), xerbla_(char *,
        integer *), slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *), slacpy_(char *, integer *, integer *, real *, integer *,
        real *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SLASD3 finds all the square roots of the roots of the secular
    equation, as defined by the values in D and Z.  It makes the
    appropriate calls to SLASD4 and then updates the singular
    vectors by matrix multiplication.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.
*/
    # SLASD3 is called from SLASD1.
    # This function computes some properties related to a bidiagonal matrix and its singular value decomposition (SVD).
    
    Arguments
    =========
    
    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.
    
    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.
    
    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
    
           The bidiagonal matrix has N = NL + NR + 1 rows and
           M = N + SQRE >= N columns.
    
    K      (input) INTEGER
           The size of the secular equation, 1 =< K = < N.
    
    D      (output) REAL array, dimension(K)
           On exit, contains the square roots of the roots of the secular equation,
           in ascending order.
    
    Q      (workspace) REAL array,
                       dimension at least (LDQ,K).
    
    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= K.
    
    DSIGMA (input/output) REAL array, dimension(K)
           On input, the first K elements contain the old roots
           of the deflated updating problem. These are the poles
           of the secular equation. Modified on output.
    
    U      (output) REAL array, dimension (LDU, N)
           The last N - K columns of this matrix contain the deflated
           left singular vectors.
    
    LDU    (input) INTEGER
           The leading dimension of the array U.  LDU >= N.
    
    U2     (input) REAL array, dimension (LDU2, N)
           The first K columns of this matrix contain the non-deflated
           left singular vectors for the split problem.
    
    LDU2   (input) INTEGER
           The leading dimension of the array U2.  LDU2 >= N.
    
    VT     (output) REAL array, dimension (LDVT, M)
           The last M - K columns of VT' contain the deflated
           right singular vectors.
    
    LDVT   (input) INTEGER
           The leading dimension of the array VT.  LDVT >= N.
    
    VT2    (input/output) REAL array, dimension (LDVT2, N)
           The first K columns of VT2' contain the non-deflated
           right singular vectors for the split problem.
    
    LDVT2  (input) INTEGER
           The leading dimension of the array VT2.  LDVT2 >= N.
    
    IDXC   (input) INTEGER array, dimension (N)
           The permutation used to arrange the columns of U (and rows of
           VT) into three groups: the first group contains non-zero
           entries only at and above (or before) NL +1; the second
           contains non-zero entries only at and below (or after) NL+2;
           and the third is dense. The first column of U and the row of
           VT are treated separately.
    
           The rows of the singular vectors found by SLASD4
           must be likewise permuted before the matrix multiplies can
           take place.
    # 输入参数：
    # CTOT (输入)：整数数组，维度为 (4)
    #    U 中各种类型列的总数，如 IDXC 中所描述的。第四种列类型是已经压缩的列。
    #
    # Z (输入/输出)：实数数组，维度为 (K)
    #    数组的前 K 个元素包含调整过的更新行向量的组成部分。
    #
    # INFO (输出)：整数
    #    = 0: 操作成功完成。
    #    < 0: 若 INFO = -i，则第 i 个参数的值非法。
    #    > 0: 若 INFO = 1，则某个奇异值未收敛。
    #
    # 进一步细节：
    # ===============
    #
    # 基于以下贡献：
    #    明顾和焕仁，加利福尼亚大学伯克利分校，美国计算机科学系

       # 测试输入参数的合法性。
    /* Parameter adjustments */
    --d__;                          // 调整参数d__的指针，减少索引1
    q_dim1 = *ldq;                  // 设置q_dim1为参数ldq的值
    q_offset = 1 + q_dim1;          // 设置q_offset为1加上q_dim1
    q -= q_offset;                  // 调整q的指针，使其指向正确位置
    --dsigma;                       // 调整参数dsigma的指针，减少索引1
    u_dim1 = *ldu;                  // 设置u_dim1为参数ldu的值
    u_offset = 1 + u_dim1;          // 设置u_offset为1加上u_dim1
    u -= u_offset;                  // 调整u的指针，使其指向正确位置
    u2_dim1 = *ldu2;                // 设置u2_dim1为参数ldu2的值
    u2_offset = 1 + u2_dim1;        // 设置u2_offset为1加上u2_dim1
    u2 -= u2_offset;                // 调整u2的指针，使其指向正确位置
    vt_dim1 = *ldvt;                // 设置vt_dim1为参数ldvt的值
    vt_offset = 1 + vt_dim1;        // 设置vt_offset为1加上vt_dim1
    vt -= vt_offset;                // 调整vt的指针，使其指向正确位置
    vt2_dim1 = *ldvt2;              // 设置vt2_dim1为参数ldvt2的值
    vt2_offset = 1 + vt2_dim1;      // 设置vt2_offset为1加上vt2_dim1
    vt2 -= vt2_offset;              // 调整vt2的指针，使其指向正确位置
    --idxc;                         // 调整参数idxc的指针，减少索引1
    --ctot;                         // 调整参数ctot的指针，减少索引1
    --z__;                          // 调整参数z__的指针，减少索引1

    /* Function Body */
    *info = 0;                      // 将info指向的值设为0

    if (*nl < 1) {                  // 如果nl指向的值小于1
        *info = -1;                 // 将info指向的值设为-1
    } else if (*nr < 1) {           // 否则如果nr指向的值小于1
        *info = -2;                 // 将info指向的值设为-2
    } else if (*sqre != 1 && *sqre != 0) { // 否则如果sqre指向的值不是1且不是0
        *info = -3;                 // 将info指向的值设为-3
    }

    n = *nl + *nr + 1;              // 计算n的值
    m = n + *sqre;                  // 计算m的值
    nlp1 = *nl + 1;                 // 计算nlp1的值
    nlp2 = *nl + 2;                 // 计算nlp2的值

    if (*k < 1 || *k > n) {         // 如果k指向的值小于1或者大于n
        *info = -4;                 // 将info指向的值设为-4
    } else if (*ldq < *k) {         // 否则如果ldq指向的值小于k指向的值
        *info = -7;                 // 将info指向的值设为-7
    } else if (*ldu < n) {          // 否则如果ldu指向的值小于n
        *info = -10;                // 将info指向的值设为-10
    } else if (*ldu2 < n) {         // 否则如果ldu2指向的值小于n
        *info = -12;                // 将info指向的值设为-12
    } else if (*ldvt < m) {         // 否则如果ldvt指向的值小于m
        *info = -14;                // 将info指向的值设为-14
    } else if (*ldvt2 < m) {        // 否则如果ldvt2指向的值小于m
        *info = -16;                // 将info指向的值设为-16
    }
    if (*info != 0) {               // 如果info指向的值不为0
        i__1 = -(*info);            // 计算负的info指向的值
        xerbla_("SLASD3", &i__1);    // 调用错误处理程序xerbla_
        return 0;                   // 返回0
    }

/*     Quick return if possible */

    if (*k == 1) {                  // 如果k指向的值等于1
        d__[1] = dabs(z__[1]);      // 设置d__[1]为z__[1]的绝对值
        scopy_(&m, &vt2[vt2_dim1 + 1], ldvt2, &vt[vt_dim1 + 1], ldvt); // 复制vt2到vt
        if (z__[1] > 0.f) {         // 如果z__[1]大于0
            scopy_(&n, &u2[u2_dim1 + 1], &c__1, &u[u_dim1 + 1], &c__1); // 复制u2到u
        } else {                    // 否则
            i__1 = n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                u[i__ + u_dim1] = -u2[i__ + u2_dim1];  // 将u2的相反数赋给u
/* L10: */      // 标号L10
            }
        }
        return 0;                   // 返回0
    }

/*
       Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
       which on any of these machines zeros out the bottommost
       bit of DSIGMA(I) if it is 1; this makes the subsequent
       subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DSIGMA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DSIGMA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DSIGMA(I) to prevent optimizing compilers from eliminating
       this code.
*/

    i__1 = *k;                      // 将i__1设为k指向的值
    for (i__ = 1; i__ <= i__1; ++i__) { // 循环i从1到i__1
        dsigma[i__] = slamc3_(&dsigma[i__], &dsigma[i__]) - dsigma[i__]; // 修改dsigma的值
/* L20: */                          // 标号L20
    }

/*     Keep a copy of Z. */

    scopy_(k, &z__[1], &c__1, &q[q_offset], &c__1); // 复制z到q

/*     Normalize Z. */

    rho = snrm2_(k, &z__[1], &c__1);    // 计算z的二范数
    slascl_("G", &c__0, &c__0, &rho, &c_b15, k, &c__1, &z__[1], k, info); // 将z标准化
    rho *= rho;                         // 计算rho的平方

/*     Find the new singular values. */

    i__1 = *k;                          // 将i__1设为k指向的值
    for (j = 1; j <= i__1; ++j) {       // 循环j从1到i__1

        // 计算新的奇异值
        dsigma[j] = slamc3_(&dsigma[j], &dsigma[j]) - dsigma[j];
/* L20: */                              // 标号L20
    }
    # 调用名为 slasd4_ 的外部函数，并传递以下参数：
    # k: 整数 k
    # &j: 指向整数 j 的指针
    # &dsigma[1]: 指向 dsigma 数组的第一个元素的指针
    # &z__[1]: 指向 z__ 数组的第一个元素的指针
    # &u[j * u_dim1 + 1]: 指向 u 矩阵第 j 列第一个元素的指针
    # &rho: 指向变量 rho 的指针
    # &d__[j]: 指向 d__ 数组的第 j 个元素的指针
    # &vt[j * vt_dim1 + 1]: 指向 vt 矩阵第 j 列第一个元素的指针
    # info: 指向整数 info 的指针
    slasd4_(k, &j, &dsigma[1], &z__[1], &u[j * u_dim1 + 1], &rho, &d__[j],
            &vt[j * vt_dim1 + 1], info);
/*        If the zero finder fails, the computation is terminated. */
if (*info != 0) {
    return 0;
}
/* L30: */
}

/*     Compute updated Z. */
i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
z__[i__] = u[i__ + *k * u_dim1] * vt[i__ + *k * vt_dim1];
i__2 = i__ - 1;
for (j = 1; j <= i__2; ++j) {
    z__[i__] *= u[i__ + j * u_dim1] * vt[i__ + j * vt_dim1] / (dsigma[
        i__] - dsigma[j]) / (dsigma[i__] + dsigma[j]);
/* L40: */
}
i__2 = *k - 1;
for (j = i__; j <= i__2; ++j) {
    z__[i__] *= u[i__ + j * u_dim1] * vt[i__ + j * vt_dim1] / (dsigma[
        i__] - dsigma[j + 1]) / (dsigma[i__] + dsigma[j + 1]);
/* L50: */
}
r__2 = sqrt((r__1 = z__[i__], dabs(r__1)));
z__[i__] = r_sign(&r__2, &q[i__ + q_dim1]);
/* L60: */
}

/*
   Compute left singular vectors of the modified diagonal matrix,
   and store related information for the right singular vectors.
*/

i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
vt[i__ * vt_dim1 + 1] = z__[1] / u[i__ * u_dim1 + 1] / vt[i__ *
    vt_dim1 + 1];
u[i__ * u_dim1 + 1] = -1.f;
i__2 = *k;
for (j = 2; j <= i__2; ++j) {
    vt[j + i__ * vt_dim1] = z__[j] / u[j + i__ * u_dim1] / vt[j + i__
        * vt_dim1];
    u[j + i__ * u_dim1] = dsigma[j] * vt[j + i__ * vt_dim1];
/* L70: */
}
temp = snrm2_(k, &u[i__ * u_dim1 + 1], &c__1);
q[i__ * q_dim1 + 1] = u[i__ * u_dim1 + 1] / temp;
i__2 = *k;
for (j = 2; j <= i__2; ++j) {
    jc = idxc[j];
    q[j + i__ * q_dim1] = u[jc + i__ * u_dim1] / temp;
/* L80: */
}
/* L90: */
}

/*     Update the left singular vector matrix. */

if (*k == 2) {
sgemm_("N", "N", &n, k, k, &c_b15, &u2[u2_offset], ldu2, &q[q_offset],
     ldq, &c_b29, &u[u_offset], ldu);
goto L100;
}
if (ctot[1] > 0) {
sgemm_("N", "N", nl, k, &ctot[1], &c_b15, &u2[(u2_dim1 << 1) + 1],
    ldu2, &q[q_dim1 + 2], ldq, &c_b29, &u[u_dim1 + 1], ldu);
if (ctot[3] > 0) {
    ktemp = ctot[1] + 2 + ctot[2];
    sgemm_("N", "N", nl, k, &ctot[3], &c_b15, &u2[ktemp * u2_dim1 + 1]
        , ldu2, &q[ktemp + q_dim1], ldq, &c_b15, &u[u_dim1 + 1],
        ldu);
}
} else if (ctot[3] > 0) {
ktemp = ctot[1] + 2 + ctot[2];
sgemm_("N", "N", nl, k, &ctot[3], &c_b15, &u2[ktemp * u2_dim1 + 1],
    ldu2, &q[ktemp + q_dim1], ldq, &c_b29, &u[u_dim1 + 1], ldu);
} else {
slacpy_("F", nl, k, &u2[u2_offset], ldu2, &u[u_offset], ldu);
}
scopy_(k, &q[q_dim1 + 1], ldq, &u[nlp1 + u_dim1], ldu);
ktemp = ctot[1] + 2;
ctemp = ctot[2] + ctot[3];
sgemm_("N", "N", nr, k, &ctemp, &c_b15, &u2[nlp2 + ktemp * u2_dim1], ldu2,
     &q[ktemp + q_dim1], ldq, &c_b29, &u[nlp2 + u_dim1], ldu);

/*     Generate the right singular vectors. */

L100:
i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
temp = snrm2_(k, &vt[i__ * vt_dim1 + 1], &c__1);
    // 将 vt[i__ * vt_dim1 + 1] / temp 的结果赋值给 q[i__ + q_dim1]
    q[i__ + q_dim1] = vt[i__ * vt_dim1 + 1] / temp;

    // 循环遍历列索引 idxc 中的元素，从第二列开始到第 *k 列
    i__2 = *k;
    for (j = 2; j <= i__2; ++j) {
        // 取出列索引 idxc[j] 的值
        jc = idxc[j];
        // 将 vt[jc + i__ * vt_dim1] / temp 的结果赋值给 q[i__ + j * q_dim1]
        q[i__ + j * q_dim1] = vt[jc + i__ * vt_dim1] / temp;


这段代码看起来是在进行某种矩阵操作，使用了一些索引和除法运算来填充矩阵 `q` 的部分元素。
/* L110: */
    }
/* L120: */
    }

/*     Update the right singular vector matrix. */

    if (*k == 2) {
        sgemm_("N", "N", k, &m, k, &c_b15, &q[q_offset], ldq, &vt2[vt2_offset]
            , ldvt2, &c_b29, &vt[vt_offset], ldvt);
        return 0;
    }
    ktemp = ctot[1] + 1;
    sgemm_("N", "N", k, &nlp1, &ktemp, &c_b15, &q[q_dim1 + 1], ldq, &vt2[
        vt2_dim1 + 1], ldvt2, &c_b29, &vt[vt_dim1 + 1], ldvt);
    ktemp = ctot[1] + 2 + ctot[2];
    if (ktemp <= *ldvt2) {
        sgemm_("N", "N", k, &nlp1, &ctot[3], &c_b15, &q[ktemp * q_dim1 + 1],
            ldq, &vt2[ktemp + vt2_dim1], ldvt2, &c_b15, &vt[vt_dim1 + 1],
            ldvt);
    }

    ktemp = ctot[1] + 1;
    nrp1 = *nr + *sqre;
    if (ktemp > 1) {
        i__1 = *k;
        for (i__ = 1; i__ <= i__1; ++i__) {
            q[i__ + ktemp * q_dim1] = q[i__ + q_dim1];
/* L130: */
        }
        i__1 = m;
        for (i__ = nlp2; i__ <= i__1; ++i__) {
            vt2[ktemp + i__ * vt2_dim1] = vt2[i__ * vt2_dim1 + 1];
/* L140: */
        }
    }
    ctemp = ctot[2] + 1 + ctot[3];
    sgemm_("N", "N", k, &nrp1, &ctemp, &c_b15, &q[ktemp * q_dim1 + 1], ldq, &
        vt2[ktemp + nlp2 * vt2_dim1], ldvt2, &c_b29, &vt[nlp2 * vt_dim1 +
        1], ldvt);

    return 0;

/*     End of SLASD3 */

} /* slasd3_ */

/* Subroutine */ int slasd4_(integer *n, integer *i__, real *d__, real *z__,
    real *delta, real *rho, real *sigma, real *work, integer *info)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Local variables */
    static real a, b, c__;
    static integer j;
    static real w, dd[3];
    static integer ii;
    static real dw, zz[3];
    static integer ip1;
    static real eta, phi, eps, tau, psi;
    static integer iim1, iip1;
    static real dphi, dpsi;
    static integer iter;
    static real temp, prew, sg2lb, sg2ub, temp1, temp2, dtiim, delsq, dtiip;
    static integer niter;
    static real dtisq;
    static logical swtch;
    static real dtnsq;
    extern /* Subroutine */ int slaed6_(integer *, logical *, real *, real *,
        real *, real *, real *, integer *);
    static real delsq2;
    extern /* Subroutine */ int slasd5_(integer *, real *, real *, real *,
        real *, real *, real *);
    static real dtnsq1;
    static logical swtch3;
    extern doublereal slamch_(char *);
    static logical orgati;
    static real erretm, dtipsq, rhoinv;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    This subroutine computes the square root of the I-th updated
    eigenvalue of a positive symmetric rank-one modification to
    a positive diagonal matrix whose entries are given as the squares
    of the corresponding entries in the array d, and that

           0 <= D(i) < D(j)  for  i < j

    and that RHO > 0. This is arranged by the calling routine, and is
*/


注释：
    # 以下是用于计算更新后特征值的函数。在这个方法中，我们使用了一种对更新过程中的特征值进行逼近的方法。
    # 这个系统是一个经过一次秩修改后的系统，形式为 diag(D) * diag(D) + RHO * Z * Z_transpose。
    # 这里假设 Z 的欧几里德范数为 1。

    # 参数说明：
    # N      (输入) 整数，所有数组的长度。
    # I      (输入) 整数，要计算的特征值的索引。1 <= I <= N。
    # D      (输入) 实数数组，维度为 (N)，原始特征值数组。假设它们已按顺序排列，对于所有的 I < J，有 0 <= D(I) < D(J)。
    # Z      (输入) 实数数组，维度为 (N)，更新向量的组成部分。
    # DELTA  (输出) 实数数组，维度为 (N)。如果 N ≠ 1，则 DELTA 的第 j 个分量包含 D(j) - sigma_I。如果 N = 1，则 DELTA(1) = 1。DELTA 向量包含了构造（奇异的）特征向量所需的信息。
    # RHO    (输入) 实数，对称更新公式中的标量。
    # SIGMA  (输出) 实数，计算得到的 sigma_I，第 I 个更新后的特征值。
    # WORK   (工作空间) 实数数组，维度为 (N)。如果 N ≠ 1，则 WORK 的第 j 个分量包含 D(j) + sigma_I。如果 N = 1，则 WORK(1) = 1。
    # INFO   (输出) 整数，返回状态信息。= 0 表示成功退出，> 0 表示更新过程失败。

    # 内部参数：
    # 逻辑变量 ORGATI 用于区分是否将 D(i) 或 D(i+1) 视为起点。
    #       ORGATI = .true.    起点在 i
    #       ORGATI = .false.   起点在 i+1
    # 逻辑变量 SWTCH3 用于指示是否处理三个极点的情况。
    # MAXIT 是允许每个特征值计算的最大迭代次数。

    # 进一步的细节说明：
    # 基于以下贡献：
    #    Ren-Cang Li, 加利福尼亚大学伯克利分校计算机科学系，美国

    # 由于这个例程在内部循环中调用，因此我们不进行参数检查。

    # 当 N=1 或 2 时，进行快速返回。
    /* Parameter adjustments */
    --work;     // 调整工作数组的指针，使其指向数组的起始位置
    --delta;    // 调整增量数组的指针，使其指向数组的起始位置
    --z__;      // 调整 z__ 数组的指针，使其指向数组的起始位置
    --d__;      // 调整 d__ 数组的指针，使其指向数组的起始位置

    /* Function Body */
    *info = 0;   // 将 info 指向的内存位置设置为 0
    if (*n == 1) {

/*        Presumably, I=1 upon entry */

        *sigma = sqrt(d__[1] * d__[1] + *rho * z__[1] * z__[1]);  // 计算 sigma 值
        delta[1] = 1.f;  // 设置 delta[1] 的值为 1
        work[1] = 1.f;   // 设置 work[1] 的值为 1
        return 0;   // 返回 0，表示函数执行成功
    }
    if (*n == 2) {
        slasd5_(i__, &d__[1], &z__[1], &delta[1], rho, sigma, &work[1]);  // 调用 slasd5 函数处理 n=2 的情况
        return 0;   // 返回 0，表示函数执行成功
    }

/*     Compute machine epsilon */

    eps = slamch_("Epsilon");  // 计算机器 epsilon

/*     The case I = N */

    if (*i__ == *n) {

/*        Initialize some basic variables */

        ii = *n - 1;    // 初始化 ii 变量
        niter = 1;      // 初始化 niter 变量为 1

/*        Calculate initial guess */

        temp = *rho / 2.f;  // 计算 temp 初始值

/*
          If ||Z||_2 is not one, then TEMP should be set to
          RHO * ||Z||_2^2 / TWO
*/

        temp1 = temp / (d__[*n] + sqrt(d__[*n] * d__[*n] + temp));  // 计算 temp1 值
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[*n] + temp1;  // 设置 work[j] 的值
            delta[j] = d__[j] - d__[*n] - temp1; // 设置 delta[j] 的值
/* L10: */
        }

        psi = 0.f;   // 初始化 psi 变量为 0
        i__1 = *n - 2;
        for (j = 1; j <= i__1; ++j) {
            psi += z__[j] * z__[j] / (delta[j] * work[j]);   // 计算 psi 值
/* L20: */
        }

        c__ = rhoinv + psi;  // 计算 c__ 值
        w = c__ + z__[ii] * z__[ii] / (delta[ii] * work[ii]) + z__[*n] * z__[*n] / (delta[*n] * work[*n]);  // 计算 w 值

        if (w <= 0.f) {
            temp1 = sqrt(d__[*n] * d__[*n] + *rho);  // 计算 temp1 值
            temp = z__[*n - 1] * z__[*n - 1] / ((d__[*n - 1] + temp1) * (d__[*n] - d__[*n - 1] + *rho / (d__[*n] + temp1))) + z__[*n] * z__[*n] / *rho;  // 计算 temp 值

/*
             The following TAU is to approximate
             SIGMA_n^2 - D( N )*D( N )
*/

            if (c__ <= temp) {
                tau = *rho;  // 计算 tau 值
            } else {
                delsq = (d__[*n] - d__[*n - 1]) * (d__[*n] + d__[*n - 1]);  // 计算 delsq 值
                a = -c__ * delsq + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];  // 计算 a 值
                b = z__[*n] * z__[*n] * delsq;  // 计算 b 值
                if (a < 0.f) {
                    tau = b * 2.f / (sqrt(a * a + b * 4.f * c__) - a);  // 计算 tau 值
                } else {
                    tau = (a + sqrt(a * a + b * 4.f * c__)) / (c__ * 2.f);  // 计算 tau 值
                }
            }

/*
             It can be proved that
                 D(N)^2+RHO/2 <= SIGMA_n^2 < D(N)^2+TAU <= D(N)^2+RHO
*/

        } else {
            delsq = (d__[*n] - d__[*n - 1]) * (d__[*n] + d__[*n - 1]);  // 计算 delsq 值
            a = -c__ * delsq + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];  // 计算 a 值
            b = z__[*n] * z__[*n] * delsq;  // 计算 b 值

/*
             The following TAU is to approximate
             SIGMA_n^2 - D( N )*D( N )
*/

            if (a < 0.f) {
                tau = b * 2.f / (sqrt(a * a + b * 4.f * c__) - a);  // 计算 tau 值
            } else {
                tau = (a + sqrt(a * a + b * 4.f * c__)) / (c__ * 2.f);  // 计算 tau 值
            }

/*
             It can be proved that
             D(N)^2 < D(N)^2+TAU < SIGMA(N)^2 < D(N)^2+RHO/2
*/

        }

/*        The following ETA is to approximate SIGMA_n - D( N ) */

        eta = tau / (d__[*n] + sqrt(d__[*n] * d__[*n] + tau));  // 计算 eta 值

        *sigma = d__[*n] + eta;  // 更新 sigma 值
        i__1 = *n;  // 结束注释
    # 循环遍历从 1 到 i__1 的所有索引 j
    for (j = 1; j <= i__1; ++j) {
        # 计算 delta[j]，即 d__[j] 减去 d__[*i__] 再减去 eta 的结果
        delta[j] = d__[j] - d__[*i__] - eta;
        # 计算 work[j]，即 d__[j] 加上 d__[*i__] 再加上 eta 的结果
        work[j] = d__[j] + d__[*i__] + eta;
    }

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.f;  // 初始化 PSI 的导数为 0
    psi = 0.f;   // 初始化 PSI 为 0
    erretm = 0.f; // 初始化误差估计为 0
    i__1 = ii;    // 循环上界为 ii
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (delta[j] * work[j]);  // 计算临时变量 temp
        psi += z__[j] * temp;  // 更新 PSI
        dpsi += temp * temp;   // 更新 DPSI
        erretm += psi;         // 更新误差估计
/* L40: */ }
    erretm = dabs(erretm);  // 取误差估计的绝对值

/*        Evaluate PHI and the derivative DPHI */

    temp = z__[*n] / (delta[*n] * work[*n]);  // 计算临时变量 temp
    phi = z__[*n] * temp;  // 计算 PHI
    dphi = temp * temp;    // 计算 DPHI
    erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) * (
        dpsi + dphi);   // 更新误差估计 erretm

    w = rhoinv + phi + psi;  // 计算 w

/*        Test for convergence */

    if (dabs(w) <= eps * erretm) {  // 判断是否收敛
        goto L240;
    }

/*        Calculate the new step */

    ++niter;  // 增加迭代计数器 niter
    dtnsq1 = work[*n - 1] * delta[*n - 1];  // 计算 dtnsq1
    dtnsq = work[*n] * delta[*n];  // 计算 dtnsq
    c__ = w - dtnsq1 * dpsi - dtnsq * dphi;  // 计算 c__
    a = (dtnsq + dtnsq1) * w - dtnsq * dtnsq1 * (dpsi + dphi);  // 计算 a
    b = dtnsq * dtnsq1 * w;  // 计算 b
    if (c__ < 0.f) {  // 如果 c__ 小于 0，则取其绝对值
        c__ = dabs(c__);
    }
    if (c__ == 0.f) {  // 根据 c__ 的值计算 eta
        eta = *rho - *sigma * *sigma;
    } else if (a >= 0.f) {
        eta = (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) / (
            c__ * 2.f);
    } else {
        eta = b * 2.f / (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(
            r__1))));
    }

/*
          Note, eta should be positive if w is negative, and
          eta should be negative otherwise. However,
          if for some reason caused by roundoff, eta*w > 0,
          we simply use one Newton step instead. This way
          will guarantee eta*w < 0.
*/

    if (w * eta > 0.f) {  // 如果 eta * w > 0，则进行一步牛顿法修正
        eta = -w / (dpsi + dphi);
    }
    temp = eta - dtnsq;  // 计算临时变量 temp
    if (temp > *rho) {  // 根据 temp 的值调整 eta
        eta = *rho + dtnsq;
    }

    tau += eta;  // 更新 tau
    eta /= *sigma + sqrt(eta + *sigma * *sigma);  // 更新 eta
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {  // 更新 delta 和 work 数组
        delta[j] -= eta;
        work[j] += eta;
/* L50: */ }
    *sigma += eta;  // 更新 sigma

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.f;  // 重新初始化 PSI 的导数为 0
    psi = 0.f;   // 重新初始化 PSI 为 0
    erretm = 0.f;  // 重新初始化误差估计为 0
    i__1 = ii;    // 循环上界为 ii
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (work[j] * delta[j]);  // 计算临时变量 temp
        psi += z__[j] * temp;  // 更新 PSI
        dpsi += temp * temp;   // 更新 DPSI
        erretm += psi;         // 更新误差估计
/* L60: */ }
    erretm = dabs(erretm);  // 取误差估计的绝对值

/*        Evaluate PHI and the derivative DPHI */

    temp = z__[*n] / (work[*n] * delta[*n]);  // 计算临时变量 temp
    phi = z__[*n] * temp;  // 计算 PHI
    dphi = temp * temp;    // 计算 DPHI
    erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) * (
        dpsi + dphi);   // 更新误差估计 erretm

    w = rhoinv + phi + psi;  // 计算 w

/*        Main loop to update the values of the array   DELTA */

    iter = niter + 1;  // 更新迭代次数计数器 iter

    for (niter = iter; niter <= 20; ++niter) {  // 主循环，更新 DELTA 数组的值

/*           Test for convergence */

        if (dabs(w) <= eps * erretm) {  // 判断是否收敛
        goto L240;
        }
/*           Calculate the new step */

        dtnsq1 = work[*n - 1] * delta[*n - 1];
        dtnsq = work[*n] * delta[*n];
        c__ = w - dtnsq1 * dpsi - dtnsq * dphi;
        a = (dtnsq + dtnsq1) * w - dtnsq1 * dtnsq * (dpsi + dphi);
        b = dtnsq1 * dtnsq * w;
        if (a >= 0.f) {
            eta = (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
                 (c__ * 2.f);
        } else {
            eta = b * 2.f / (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(
                r__1))));
        }

/*
             Note, eta should be positive if w is negative, and
             eta should be negative otherwise. However,
             if for some reason caused by roundoff, eta*w > 0,
             we simply use one Newton step instead. This way
             will guarantee eta*w < 0.
*/

        if (w * eta > 0.f) {
            eta = -w / (dpsi + dphi);
        }
        temp = eta - dtnsq;
        if (temp <= 0.f) {
            eta /= 2.f;
        }

        tau += eta;
        eta /= *sigma + sqrt(eta + *sigma * *sigma);
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            delta[j] -= eta;
            work[j] += eta;
/* L70: */
        }

        *sigma += eta;

/*           Evaluate PSI and the derivative DPSI */

        dpsi = 0.f;
        psi = 0.f;
        erretm = 0.f;
        i__1 = ii;
        for (j = 1; j <= i__1; ++j) {
            temp = z__[j] / (work[j] * delta[j]);
            psi += z__[j] * temp;
            dpsi += temp * temp;
            erretm += psi;
/* L80: */
        }
        erretm = dabs(erretm);

/*           Evaluate PHI and the derivative DPHI */

        temp = z__[*n] / (work[*n] * delta[*n]);
        phi = z__[*n] * temp;
        dphi = temp * temp;
        erretm = (-phi - psi) * 8.f + erretm - phi + rhoinv + dabs(tau) *
            (dpsi + dphi);

        w = rhoinv + phi + psi;
/* L90: */
    }

/*        Return with INFO = 1, NITER = MAXIT and not converged */

    *info = 1;
    goto L240;

/*        End for the case I = N */

    } else {

/*        The case for I < N */

    niter = 1;
    ip1 = *i__ + 1;

/*        Calculate initial guess */

    delsq = (d__[ip1] - d__[*i__]) * (d__[ip1] + d__[*i__]);
    delsq2 = delsq / 2.f;
    temp = delsq2 / (d__[*i__] + sqrt(d__[*i__] * d__[*i__] + delsq2));
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        work[j] = d__[j] + d__[*i__] + temp;
        delta[j] = d__[j] - d__[*i__] - temp;
/* L100: */
    }

    psi = 0.f;
    i__1 = *i__ - 1;
    for (j = 1; j <= i__1; ++j) {
        psi += z__[j] * z__[j] / (work[j] * delta[j]);
/* L110: */
    }

    phi = 0.f;
    i__1 = *i__ + 2;
    for (j = *n; j >= i__1; --j) {
        phi += z__[j] * z__[j] / (work[j] * delta[j]);
/* L120: */
    }
    c__ = rhoinv + psi + phi;
    w = c__ + z__[*i__] * z__[*i__] / (work[*i__] * delta[*i__]) + z__[
        ip1] * z__[ip1] / (work[ip1] * delta[ip1]);

    if (w > 0.f) {

/*
             d(i)^2 < the ith sigma^2 < (d(i)^2+d(i+1)^2)/2

             We choose d(i) as origin.

*/
        orgati = TRUE_;
        sg2lb = 0.f;
        sg2ub = delsq2;
        a = c__ * delsq + z__[*i__] * z__[*i__] + z__[ip1] * z__[ip1];
        b = z__[*i__] * z__[*i__] * delsq;
        if (a > 0.f) {
            tau = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(
                r__1))));
        } else {
            tau = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
                 (c__ * 2.f);
        }

        // TAU 现在是 SIGMA^2 - D( I )^2 的估计值。然而，下面是对应的 SIGMA - D( I ) 的估计值。
        eta = tau / (d__[*i__] + sqrt(d__[*i__] * d__[*i__] + tau));
    } else {

        // (d(i)^2+d(i+1)^2)/2 <= 第 i 个 sigma^2 < d(i+1)^2/2
        // 我们选择 d(i+1) 作为原点。

        orgati = FALSE_;
        sg2lb = -delsq2;
        sg2ub = 0.f;
        a = c__ * delsq - z__[*i__] * z__[*i__] - z__[ip1] * z__[ip1];
        b = z__[ip1] * z__[ip1] * delsq;
        if (a < 0.f) {
            tau = b * 2.f / (a - sqrt((r__1 = a * a + b * 4.f * c__, dabs(
                r__1))));
        } else {
            tau = -(a + sqrt((r__1 = a * a + b * 4.f * c__, dabs(r__1))))
                / (c__ * 2.f);
        }

        // TAU 现在是 SIGMA^2 - D( IP1 )^2 的估计值。然而，下面是对应的 SIGMA - D( IP1 ) 的估计值。
        eta = tau / (d__[ip1] + sqrt((r__1 = d__[ip1] * d__[ip1] + tau,
            dabs(r__1))));
    }

    if (orgati) {
        ii = *i__;
        *sigma = d__[*i__] + eta;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[*i__] + eta;
            delta[j] = d__[j] - d__[*i__] - eta;
        }
    } else {
        ii = *i__ + 1;
        *sigma = d__[ip1] + eta;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[ip1] + eta;
            delta[j] = d__[j] - d__[ip1] - eta;
        }
    }
    iim1 = ii - 1;
    iip1 = ii + 1;

    // 计算 PSI 和其导数 DPSI
    dpsi = 0.f;
    psi = 0.f;
    erretm = 0.f;
    i__1 = iim1;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (work[j] * delta[j]);
        psi += z__[j] * temp;
        dpsi += temp * temp;
        erretm += psi;
    }
    erretm = dabs(erretm);

    // 计算 PHI 和其导数 DPHI
    dphi = 0.f;
    phi = 0.f;
    i__1 = iip1;
    for (j = *n; j >= i__1; --j) {
        temp = z__[j] / (work[j] * delta[j]);
        phi += z__[j] * temp;
        dphi += temp * temp;
        erretm += phi;
    }

    w = rhoinv + phi + psi;

    // W 是移除了第 ii 个元素后的分离函数的值。

    swtch3 = FALSE_;
    if (orgati) {
        if (w < 0.f) {
            swtch3 = TRUE_;
        }
    } else {
        if (w > 0.f) {
            swtch3 = TRUE_;
        }
    }
    if (ii == 1 || ii == *n) {
        swtch3 = FALSE_;
    }
    // 计算临时变量 temp，其值为 z__[ii] 除以 (work[ii] * delta[ii]) 的结果
    temp = z__[ii] / (work[ii] * delta[ii]);

    // 计算 dw，其值为 dpsi + dphi + temp 的平方
    dw = dpsi + dphi + temp * temp;

    // 计算临时变量 temp 的新值，为 z__[ii] 乘以 temp
    temp = z__[ii] * temp;

    // 更新 w 的值，加上临时变量 temp
    w += temp;

    // 计算 erretm 的新值，包括多项式的计算
    erretm = (phi - psi) * 8.f + erretm + rhoinv * 2.f + dabs(temp) * 3.f
        + dabs(tau) * dw;
/*        Test for convergence */
/* 检查是否收敛 */

    if (dabs(w) <= eps * erretm) {
        goto L240;
    }

    if (w <= 0.f) {
        sg2lb = dmax(sg2lb,tau);
    } else {
        sg2ub = dmin(sg2ub,tau);
    }

/*        Calculate the new step */
/* 计算新的步长 */

    ++niter;
    if (! swtch3) {
        dtipsq = work[ip1] * delta[ip1];
        dtisq = work[*i__] * delta[*i__];
        if (orgati) {
/* Computing 2nd power */
        r__1 = z__[*i__] / dtisq;
        c__ = w - dtipsq * dw + delsq * (r__1 * r__1);
        } else {
/* Computing 2nd power */
        r__1 = z__[ip1] / dtipsq;
        c__ = w - dtisq * dw - delsq * (r__1 * r__1);
        }
        a = (dtipsq + dtisq) * w - dtipsq * dtisq * dw;
        b = dtipsq * dtisq * w;
        if (c__ == 0.f) {
        if (a == 0.f) {
            if (orgati) {
            a = z__[*i__] * z__[*i__] + dtipsq * dtipsq * (dpsi +
                dphi);
            } else {
            a = z__[ip1] * z__[ip1] + dtisq * dtisq * (dpsi +
                dphi);
            }
        }
        eta = b / a;
        } else if (a <= 0.f) {
        eta = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1)))) /
             (c__ * 2.f);
        } else {
        eta = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__, dabs(
            r__1))));
        }
    } else {

/*           Interpolation using THREE most relevant poles */
/* 使用最相关的三个极点进行插值 */

        dtiim = work[iim1] * delta[iim1];
        dtiip = work[iip1] * delta[iip1];
        temp = rhoinv + psi + phi;
        if (orgati) {
        temp1 = z__[iim1] / dtiim;
        temp1 *= temp1;
        c__ = temp - dtiip * (dpsi + dphi) - (d__[iim1] - d__[iip1]) *
             (d__[iim1] + d__[iip1]) * temp1;
        zz[0] = z__[iim1] * z__[iim1];
        if (dpsi < temp1) {
            zz[2] = dtiip * dtiip * dphi;
        } else {
            zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
        }
        } else {
        temp1 = z__[iip1] / dtiip;
        temp1 *= temp1;
        c__ = temp - dtiim * (dpsi + dphi) - (d__[iip1] - d__[iim1]) *
             (d__[iim1] + d__[iip1]) * temp1;
        if (dphi < temp1) {
            zz[0] = dtiim * dtiim * dpsi;
        } else {
            zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
        }
        zz[2] = z__[iip1] * z__[iip1];
        }
        zz[1] = z__[ii] * z__[ii];
        dd[0] = dtiim;
        dd[1] = delta[ii] * work[ii];
        dd[2] = dtiip;
        slaed6_(&niter, &orgati, &c__, dd, zz, &w, &eta, info);
        if (*info != 0) {
        goto L240;
        }
    }

/*
          Note, eta should be positive if w is negative, and
          eta should be negative otherwise. However,
          if for some reason caused by roundoff, eta*w > 0,
          we simply use one Newton step instead. This way
          will guarantee eta*w < 0.
*/
/*
          注意，如果 w 是负数，eta 应该是正数，否则应该是负数。然而，
          如果由于舍入误差的某些原因，eta*w > 0，则我们简单地使用一个
          牛顿步骤。这样可以确保 eta*w < 0。
*/

    if (w * eta >= 0.f) {
        eta = -w / dw;
    }
    if (orgati) {
        temp1 = work[*i__] * delta[*i__];
        temp = eta - temp1;
    } else {
        // 如果条件不满足，则计算 temp1 的值
        temp1 = work[ip1] * delta[ip1];
        // 计算 temp 的值
        temp = eta - temp1;
    }
    // 如果 temp 超出范围 sg2ub 或 sg2lb，则重新调整 eta 的值
    if (temp > sg2ub || temp < sg2lb) {
        if (w < 0.f) {
            // 根据 w 的值更新 eta
            eta = (sg2ub - tau) / 2.f;
        } else {
            // 根据 w 的值更新 eta
            eta = (sg2lb - tau) / 2.f;
        }
    }

    // 更新 tau
    tau += eta;
    // 更新 eta
    eta /= *sigma + sqrt(*sigma * *sigma + eta);

    // 保存当前的 w 到 prew
    prew = w;

    // 更新 *sigma
    *sigma += eta;
    // 循环更新 work 和 delta 数组的值
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        work[j] += eta;
        delta[j] -= eta;
    }

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.f;  // 初始化 DPSI（PSI 的导数）为 0
    psi = 0.f;   // 初始化 PSI 为 0
    erretm = 0.f; // 初始化误差估计 erretm 为 0
    i__1 = iim1;  // 循环上限为 iim1
    for (j = 1; j <= i__1; ++j) {  // 循环遍历 j 从 1 到 iim1
        temp = z__[j] / (work[j] * delta[j]);  // 计算临时变量 temp
        psi += z__[j] * temp;  // 更新 PSI
        dpsi += temp * temp;   // 更新 DPSI
        erretm += psi;         // 更新误差估计 erretm
/* L180: */  // 结束循环体
    }
    erretm = dabs(erretm);  // 计算 erretm 的绝对值

/*        Evaluate PHI and the derivative DPHI */

    dphi = 0.f;  // 初始化 DPHI（PHI 的导数）为 0
    phi = 0.f;   // 初始化 PHI 为 0
    i__1 = iip1;  // 循环上限为 iip1
    for (j = *n; j >= i__1; --j) {  // 逆序循环遍历 j 从 *n 到 iip1
        temp = z__[j] / (work[j] * delta[j]);  // 计算临时变量 temp
        phi += z__[j] * temp;  // 更新 PHI
        dphi += temp * temp;   // 更新 DPHI
        erretm += phi;         // 更新误差估计 erretm
/* L190: */  // 结束循环体
    }

    temp = z__[ii] / (work[ii] * delta[ii]);  // 计算临时变量 temp
    dw = dpsi + dphi + temp * temp;  // 计算 dw
    temp = z__[ii] * temp;  // 更新临时变量 temp
    w = rhoinv + phi + psi + temp;  // 计算 w
    erretm = (phi - psi) * 8.f + erretm + rhoinv * 2.f + dabs(temp) * 3.f
        + dabs(tau) * dw;  // 更新误差估计 erretm

    if (w <= 0.f) {  // 如果 w 小于等于 0
        sg2lb = dmax(sg2lb,tau);  // 更新 sg2lb
    } else {  // 否则
        sg2ub = dmin(sg2ub,tau);  // 更新 sg2ub
    }

    swtch = FALSE_;  // 初始化 swtch 为 FALSE
    if (orgati) {  // 如果 orgati 为真
        if (-w > dabs(prew) / 10.f) {  // 如果 -w 大于 prew 的绝对值除以 10
            swtch = TRUE_;  // 设置 swtch 为 TRUE
        }
    } else {  // 否则
        if (w > dabs(prew) / 10.f) {  // 如果 w 大于 prew 的绝对值除以 10
            swtch = TRUE_;  // 设置 swtch 为 TRUE
        }
    }

/*        Main loop to update the values of the array   DELTA and WORK */

    iter = niter + 1;  // 更新 iter
    for (niter = iter; niter <= 20; ++niter) {  // 循环遍历 niter 从 iter 到 20

/*           Test for convergence */

        if (dabs(w) <= eps * erretm) {  // 如果 w 的绝对值小于等于 eps 乘以 erretm
            goto L240;  // 转到标签 L240
        }

/*           Calculate the new step */

        if (! swtch3) {  // 如果 swtch3 不为真
            dtipsq = work[ip1] * delta[ip1];  // 计算 dtipsq
            dtisq = work[*i__] * delta[*i__];  // 计算 dtisq
            if (! swtch) {  // 如果 swtch 不为真
                if (orgati) {  // 如果 orgati 为真
/* Computing 2nd power */
                    r__1 = z__[*i__] / dtisq;  // 计算 z__[*i__] / dtisq 的平方
                    c__ = w - dtipsq * dw + delsq * (r__1 * r__1);  // 计算 c__
                } else {  // 否则
        /* 计算 z[ip1] 的平方除以 dtipsq */
        r__1 = z__[ip1] / dtipsq;
        /* 计算 c__ 的值 */
        c__ = w - dtisq * dw - delsq * (r__1 * r__1);
        }
    } else {
        /* 计算 temp 的值 */
        temp = z__[ii] / (work[ii] * delta[ii]);
        /* 根据 orgati 的条件选择更新 dpsi 或 dphi */
        if (orgati) {
        /* 更新 dpsi */
        dpsi += temp * temp;
        } else {
        /* 更新 dphi */
        dphi += temp * temp;
        }
        /* 计算 c__ 的值 */
        c__ = w - dtisq * dpsi - dtipsq * dphi;
    }
    /* 计算 a 和 b 的值 */
    a = (dtipsq + dtisq) * w - dtipsq * dtisq * dw;
    b = dtipsq * dtisq * w;
    /* 根据 c__ 的值选择计算 eta 的方式 */
    if (c__ == 0.f) {
        if (a == 0.f) {
        /* 根据 swtch 的条件选择计算 a 的值 */
        if (! swtch) {
            /* 根据 orgati 的条件选择计算 a 的值 */
            if (orgati) {
            a = z__[*i__] * z__[*i__] + dtipsq * dtipsq *
                (dpsi + dphi);
            } else {
            a = z__[ip1] * z__[ip1] + dtisq * dtisq * (
                dpsi + dphi);
            }
        } else {
            /* 计算 a 的值 */
            a = dtisq * dtisq * dpsi + dtipsq * dtipsq * dphi;
        }
        }
        /* 计算 eta 的值 */
        eta = b / a;
    } else if (a <= 0.f) {
        /* 计算 eta 的值 */
        eta = (a - sqrt((r__1 = a * a - b * 4.f * c__, dabs(r__1))
            )) / (c__ * 2.f);
    } else {
        /* 计算 eta 的值 */
        eta = b * 2.f / (a + sqrt((r__1 = a * a - b * 4.f * c__,
            dabs(r__1))));
    }
    } else {

/*              使用三个最相关的极点进行插值 */

    /* 计算 dtiim 和 dtiip 的值 */
    dtiim = work[iim1] * delta[iim1];
    dtiip = work[iip1] * delta[iip1];
    /* 计算 temp 的值 */
    temp = rhoinv + psi + phi;
    /* 根据 swtch 的条件选择更新 c__ 和 zz 数组 */
    if (swtch) {
        /* 更新 c__ 和 zz[0], zz[2] */
        c__ = temp - dtiim * dpsi - dtiip * dphi;
        zz[0] = dtiim * dtiim * dpsi;
        zz[2] = dtiip * dtiip * dphi;
    } else {
        /* 根据 orgati 的条件选择更新 temp1, temp2, c__ 和 zz 数组 */
        if (orgati) {
        /* 更新 temp1 和 temp2 */
        temp1 = z__[iim1] / dtiim;
        temp1 *= temp1;
        temp2 = (d__[iim1] - d__[iip1]) * (d__[iim1] + d__[
            iip1]) * temp1;
        /* 更新 c__ 和 zz[0], zz[2] */
        c__ = temp - dtiip * (dpsi + dphi) - temp2;
        zz[0] = z__[iim1] * z__[iim1];
        if (dpsi < temp1) {
            zz[2] = dtiip * dtiip * dphi;
        } else {
            zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
        }
        } else {
        /* 更新 temp1 和 temp2 */
        temp1 = z__[iip1] / dtiip;
        temp1 *= temp1;
        temp2 = (d__[iip1] - d__[iim1]) * (d__[iim1] + d__[
            iip1]) * temp1;
        /* 更新 c__ 和 zz[0], zz[2] */
        c__ = temp - dtiim * (dpsi + dphi) - temp2;
        if (dphi < temp1) {
            zz[0] = dtiim * dtiim * dpsi;
        } else {
            zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
        }
        zz[2] = z__[iip1] * z__[iip1];
        }
    }
    /* 更新 dd 数组 */
    dd[0] = dtiim;
    dd[1] = delta[ii] * work[ii];
    dd[2] = dtiip;
    /* 调用 slaed6 函数处理迭代 */
    slaed6_(&niter, &orgati, &c__, dd, zz, &w, &eta, info);
    /* 检查 slaed6 函数的返回信息 */
    if (*info != 0) {
        goto L240;
    }
    }
/*
   Note, eta should be positive if w is negative, and
   eta should be negative otherwise. However,
   if for some reason caused by roundoff, eta*w > 0,
   we simply use one Newton step instead. This way
   will guarantee eta*w < 0.
*/
if (w * eta >= 0.f) {
    eta = -w / dw;
}

if (orgati) {
    temp1 = work[*i__] * delta[*i__];
    temp = eta - temp1;
} else {
    temp1 = work[ip1] * delta[ip1];
    temp = eta - temp1;
}

if (temp > sg2ub || temp < sg2lb) {
    if (w < 0.f) {
        eta = (sg2ub - tau) / 2.f;
    } else {
        eta = (sg2lb - tau) / 2.f;
    }
}

tau += eta;
eta /= *sigma + sqrt(*sigma * *sigma + eta);

*sigma += eta;

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    work[j] += eta;
    delta[j] -= eta;
}
prew = w;

/* Evaluate PSI and the derivative DPSI */
dpsi = 0.f;
psi = 0.f;
erretm = 0.f;
i__1 = iim1;
for (j = 1; j <= i__1; ++j) {
    temp = z__[j] / (work[j] * delta[j]);
    psi += z__[j] * temp;
    dpsi += temp * temp;
    erretm += psi;
}

erretm = dabs(erretm);

/* Evaluate PHI and the derivative DPHI */
dphi = 0.f;
phi = 0.f;
i__1 = iip1;
for (j = *n; j >= i__1; --j) {
    temp = z__[j] / (work[j] * delta[j]);
    phi += z__[j] * temp;
    dphi += temp * temp;
    erretm += phi;
}

temp = z__[ii] / (work[ii] * delta[ii]);
dw = dpsi + dphi + temp * temp;
temp = z__[ii] * temp;
w = rhoinv + phi + psi + temp;
erretm = (phi - psi) * 8.f + erretm + rhoinv * 2.f + dabs(temp) *
    3.f + dabs(tau) * dw;

if (w * prew > 0.f && dabs(w) > dabs(prew) / 10.f) {
    swtch = ! swtch;
}

if (w <= 0.f) {
    sg2lb = dmax(sg2lb,tau);
} else {
    sg2ub = dmin(sg2ub,tau);
}
    The diagonal entries in the array D are assumed to satisfy

               0 <= D(i) < D(j)  for  i < j .

    We also assume RHO > 0 and that the Euclidean norm of the vector
    Z is one.

    Arguments
    =========

    I      (input) INTEGER
           The index of the eigenvalue to be computed.  I = 1 or I = 2.
           计算的特征值的索引，可以是1或2。

    D      (input) REAL array, dimension (2)
           The original eigenvalues.  We assume 0 <= D(1) < D(2).
           原始特征值数组。假设 0 <= D(1) < D(2)。

    Z      (input) REAL array, dimension (2)
           The components of the updating vector.
           更新向量的组成部分。

    DELTA  (output) REAL array, dimension (2)
           Contains (D(j) - sigma_I) in its  j-th component.
           The vector DELTA contains the information necessary
           to construct the eigenvectors.
           包含 (D(j) - sigma_I) 的结果数组，用于构建特征向量。

    RHO    (input) REAL
           The scalar in the symmetric updating formula.
           对称更新公式中的标量值。

    DSIGMA (output) REAL
           The computed sigma_I, the I-th updated eigenvalue.
           计算得到的 sigma_I，即第 I 个更新的特征值。

    WORK   (workspace) REAL array, dimension (2)
           WORK contains (D(j) + sigma_I) in its  j-th component.
           WORK 包含 (D(j) + sigma_I) 的结果数组，作为工作空间使用。

    Further Details
    ===============

    Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA

    =====================================================================
/* Parameter adjustments */
    --work;           // 调整工作数组的指针
    --delta;          // 调整增量数组的指针
    --z__;            // 调整 Z__ 数组的指针
    --d__;            // 调整 D__ 数组的指针

/* Function Body */
    del = d__[2] - d__[1];  // 计算 D(2) - D(1)
    delsq = del * (d__[2] + d__[1]);  // 计算 del * (D(2) + D(1))
    if (*i__ == 1) {  // 如果 i__ 等于 1

        // 计算 w
        w = *rho * 4.f * (z__[2] * z__[2] / (d__[1] + d__[2] * 3.f) - z__[1] *
             z__[1] / (d__[1] * 3.f + d__[2])) / del + 1.f;

        // 如果 w 大于 0
        if (w > 0.f) {
            b = delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);  // 计算 b
            c__ = *rho * z__[1] * z__[1] * delsq;  // 计算 c__

            /*
                 B > ZERO, always

                 The following TAU is DSIGMA * DSIGMA - D( 1 ) * D( 1 )
            */

            // 计算 tau
            tau = c__ * 2.f / (b + sqrt((r__1 = b * b - c__ * 4.f, dabs(r__1))));

            /* 
               The following TAU is DSIGMA - D( 1 )
            */

            // 对 tau 进行调整
            tau /= d__[1] + sqrt(d__[1] * d__[1] + tau);
            *dsigma = d__[1] + tau;  // 更新 dsigma
            delta[1] = -tau;  // 更新 delta(1)
            delta[2] = del - tau;  // 更新 delta(2)
            work[1] = d__[1] * 2.f + tau;  // 更新 work(1)
            work[2] = d__[1] + tau + d__[2];  // 更新 work(2)

            /*
                 DELTA( 1 ) = -Z( 1 ) / TAU
                 DELTA( 2 ) = Z( 2 ) / ( DEL-TAU )
            */
        } else {
            b = -delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);  // 计算 b
            c__ = *rho * z__[2] * z__[2] * delsq;  // 计算 c__

            /* 
               The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )
            */

            // 如果 b 大于 0
            if (b > 0.f) {
                tau = c__ * -2.f / (b + sqrt(b * b + c__ * 4.f));
            } else {
                tau = (b - sqrt(b * b + c__ * 4.f)) / 2.f;
            }

            /* 
               The following TAU is DSIGMA - D( 2 )
            */

            // 对 tau 进行调整
            tau /= d__[2] + sqrt((r__1 = d__[2] * d__[2] + tau, dabs(r__1)));
            *dsigma = d__[2] + tau;  // 更新 dsigma
            delta[1] = -(del + tau);  // 更新 delta(1)
            delta[2] = -tau;  // 更新 delta(2)
            work[1] = d__[1] + tau + d__[2];  // 更新 work(1)
            work[2] = d__[2] * 2.f + tau;  // 更新 work(2)

            /*
                 DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
                 DELTA( 2 ) = -Z( 2 ) / TAU
            */
        }

        /*
              TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
              DELTA( 1 ) = DELTA( 1 ) / TEMP
              DELTA( 2 ) = DELTA( 2 ) / TEMP
        */

    } else {

        /* Now I=2 */

        b = -delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);  // 计算 b
        c__ = *rho * z__[2] * z__[2] * delsq;  // 计算 c__

        /* 
           The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )
        */

        // 如果 b 大于 0
        if (b > 0.f) {
            tau = (b + sqrt(b * b + c__ * 4.f)) / 2.f;
        } else {
            tau = c__ * 2.f / (-b + sqrt(b * b + c__ * 4.f));
        }

        /* 
           The following TAU is DSIGMA - D( 2 )
        */

        // 对 tau 进行调整
        tau /= d__[2] + sqrt(d__[2] * d__[2] + tau);
        *dsigma = d__[2] + tau;  // 更新 dsigma
        delta[1] = -(del + tau);  // 更新 delta(1)
        delta[2] = -tau;  // 更新 delta(2)
        work[1] = d__[1] + tau + d__[2];  // 更新 work(1)
        work[2] = d__[2] * 2.f + tau;  // 更新 work(2)

        /*
              DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
              DELTA( 2 ) = -Z( 2 ) / TAU
              TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
              DELTA( 1 ) = DELTA( 1 ) / TEMP
              DELTA( 2 ) = DELTA( 2 ) / TEMP
        */
    }

    return 0;

/* End of SLASD5 */

} /* slasd5_ */


这样，我们对每一行代码都添加了相应的注释，解释了其作用和功能。
    integer *sqre, real *d__, real *vf, real *vl, real *alpha, real *beta,
     integer *idxq, integer *perm, integer *givptr, integer *givcol,
    integer *ldgcol, real *givnum, integer *ldgnum, real *poles, real *
    difl, real *difr, real *z__, integer *k, real *c__, real *s, real *
    work, integer *iwork, integer *info)



声明函数的参数列表，这是一个Fortran函数声明，指定了函数的输入参数和它们的类型。每个参数的含义如下：
- integer *sqre: 整数指针，可能用于传递一个整数数组或值。
- real *d__: 实数指针，可能用于传递一个实数数组或值。
- real *vf: 实数指针，可能用于传递一个实数数组或值。
- real *vl: 实数指针，可能用于传递一个实数数组或值。
- real *alpha: 实数指针，可能用于传递一个实数数组或值。
- real *beta: 实数指针，可能用于传递一个实数数组或值。
- integer *idxq: 整数指针，可能用于传递一个整数数组或值。
- integer *perm: 整数指针，可能用于传递一个整数数组或值。
- integer *givptr: 整数指针，可能用于传递一个整数数组或值。
- integer *givcol: 整数指针，可能用于传递一个整数数组或值。
- integer *ldgcol: 整数指针，可能用于传递一个整数数组或值。
- real *givnum: 实数指针，可能用于传递一个实数数组或值。
- integer *ldgnum: 整数指针，可能用于传递一个整数数组或值。
- real *poles: 实数指针，可能用于传递一个实数数组或值。
- real *difl: 实数指针，可能用于传递一个实数数组或值。
- real *difr: 实数指针，可能用于传递一个实数数组或值。
- real *z__: 实数指针，可能用于传递一个实数数组或值。
- integer *k: 整数指针，可能用于传递一个整数值。
- real *c__: 实数指针，可能用于传递一个实数数组或值。
- real *s: 实数指针，可能用于传递一个实数数组或值。
- real *work: 实数指针，可能用于传递一个实数数组或值。
- integer *iwork: 整数指针，可能用于传递一个整数数组或值。
- integer *info: 整数指针，可能用于传递一个整数值，用于返回函数的信息或状态。
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, i__1;
    real r__1, r__2;

    /* Local variables */
    static integer i__, m, n, n1, n2, iw, idx, idxc, idxp, ivfw, ivlw;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slasd7_(integer *, integer *, integer *, integer *,
        integer *, real *, real *, real *, real *, real *, real *, real *,
         real *, real *, real *, integer *, integer *, integer *, integer
        *, integer *, integer *, integer *, real *, integer *, real *,
        real *, integer *), slasd8_(integer *, integer *, real *, real *,
        real *, real *, real *, real *, integer *, real *, real *,
        integer *);
    static integer isigma;
    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
        char *, integer *, integer *, real *, real *, integer *, integer *
        , real *, integer *, integer *), slamrg_(integer *,
        integer *, real *, integer *, integer *, integer *);
    static real orgnrm;


/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    SLASD6 computes the SVD of an updated upper bidiagonal matrix B
    obtained by merging two smaller ones by appending a row. This
    routine is used only for the problem which requires all singular
    values and optionally singular vector matrices in factored form.
    B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
    A related subroutine, SLASD1, handles the case in which all singular
    values and singular vectors of the bidiagonal matrix are desired.

    SLASD6 computes the SVD as follows:

                  ( D1(in)  0    0     0 )
      B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
                  (   0     0   D2(in) 0 )

        = U(out) * ( D(out) 0) * VT(out)

    where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The singular values of B can be computed using D1, D2, the first
    components of all the right singular vectors of the lower block, and
    the last components of all the right singular vectors of the upper
    block. These components are stored and updated in VF and VL,
    respectively, in SLASD6. Hence U and VT are not explicitly
    referenced.

    The singular values are stored in D. The algorithm consists of two
*/
    # SLASD6是SLASDA中的一个子程序，用于求解奇异值问题的更新
    # 此函数的目的是根据给定的参数计算更新后的奇异值和奇异向量
    def SLASD6(ICOMPQ, NL, NR, SQRE, D, VF, VL, ALPHA, BETA):
        # SLASD6的第一阶段，通过调用SLASD7来减少问题的维度
        # 当存在多个奇异值或Z向量中存在零时，将问题的维度减少一次
        # 这一阶段由SLASD7例程执行
        # SLASD7的调用用于减少问题的维度
        # 在这里没有直接的代码，但通过描述表达了调用的目的和作用
        stages:
    
              The first stage consists of deflating the size of the problem
              when there are multiple singular values or if there is a zero
              in the Z vector. For each such occurence the dimension of the
              secular equation problem is reduced by one. This stage is
              performed by the routine SLASD7.
    
        # SLASD6的第二阶段，计算更新后的奇异值
        # 通过解奇异方程来找到更新后的奇异值，SLASD4例程（由SLASD8调用）完成这一任务
        # 此例程还更新VF和VL，并计算更新后的奇异值与旧奇异值之间的距离
        # 在这里没有直接的代码，但通过描述表达了调用的目的和作用
        The second stage consists of calculating the updated
        singular values. This is done by finding the roots of the
        secular equation via the routine SLASD4 (as called by SLASD8).
        This routine also updates VF and VL and computes the distances
        between the updated singular values and the old singular
        values.
    
        Arguments
        =========
    
        ICOMPQ (input) INTEGER
               Specifies whether singular vectors are to be computed in
               factored form:
               = 0: Compute singular values only.
               = 1: Compute singular vectors in factored form as well.
    
        NL     (input) INTEGER
               The row dimension of the upper block.  NL >= 1.
    
        NR     (input) INTEGER
               The row dimension of the lower block.  NR >= 1.
    
        SQRE   (input) INTEGER
               = 0: the lower block is an NR-by-NR square matrix.
               = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
    
               The bidiagonal matrix has row dimension N = NL + NR + 1,
               and column dimension M = N + SQRE.
    
        D      (input/output) REAL array, dimension (NL+NR+1).
               On entry D(1:NL,1:NL) contains the singular values of the
               upper block, and D(NL+2:N) contains the singular values
               of the lower block. On exit D(1:N) contains the singular
               values of the modified matrix.
    
        VF     (input/output) REAL array, dimension (M)
               On entry, VF(1:NL+1) contains the first components of all
               right singular vectors of the upper block; and VF(NL+2:M)
               contains the first components of all right singular vectors
               of the lower block. On exit, VF contains the first components
               of all right singular vectors of the bidiagonal matrix.
    
        VL     (input/output) REAL array, dimension (M)
               On entry, VL(1:NL+1) contains the  last components of all
               right singular vectors of the upper block; and VL(NL+2:M)
               contains the last components of all right singular vectors of
               the lower block. On exit, VL contains the last components of
               all right singular vectors of the bidiagonal matrix.
    
        ALPHA  (input/output) REAL
               Contains the diagonal element associated with the added row.
    
        BETA   (input/output) REAL
               Contains the off-diagonal element associated with the added
               row.
    IDXQ   (output) INTEGER array, dimension (N)
           ! 这个数组包含了重新整合已解决子问题的排列，
           ! 即 D(IDXQ(I)) 将按升序排列。

    PERM   (output) INTEGER array, dimension (N)
           ! 用于每个块的排列（来自于缩减和排序）。
           ! 如果 ICOMPQ = 0，则不被引用。

    GIVPTR (output) INTEGER
           ! 在这个子问题中发生的 Givens 旋转的数量。
           ! 如果 ICOMPQ = 0，则不被引用。

    GIVCOL (output) INTEGER array, dimension (LDGCOL, 2)
           ! 每对数字指示参与 Givens 旋转的列。
           ! 如果 ICOMPQ = 0，则不被引用。

    LDGCOL (input) INTEGER
           ! GIVCOL 的 leading dimension，至少为 N。

    GIVNUM (output) REAL array, dimension (LDGNUM, 2)
           ! 每个数字指示在对应的 Givens 旋转中使用的 C 或 S 值。
           ! 如果 ICOMPQ = 0，则不被引用。

    LDGNUM (input) INTEGER
           ! GIVNUM 和 POLES 的 leading dimension，至少为 N。

    POLES  (output) REAL array, dimension (LDGNUM, 2)
           ! 在退出时，POLES(1,*) 包含从解决截断方程得到的新奇异值，
           ! POLES(2,*) 包含截断方程中的极点。
           ! 如果 ICOMPQ = 0，则不被引用。

    DIFL   (output) REAL array, dimension (N)
           ! 在退出时，DIFL(I) 是第 I 个更新（未缩减）奇异值和第 I 个
           ! 旧（未缩减）奇异值之间的距离。

    DIFR   (output) REAL array,
                    dimension (LDGNUM, 2) 如果 ICOMPQ = 1，或
                    dimension (N) 如果 ICOMPQ = 0。
           ! 在退出时，DIFR(I, 1) 是第 I 个更新（未缩减）奇异值和第 I+1 个
           ! 旧（未缩减）奇异值之间的距离。
           ! 如果 ICOMPQ = 1，则 DIFR(1:K,2) 是包含右奇异向量矩阵的归一化因子的数组。
           ! 详见 SLASD8 关于 DIFL 和 DIFR 的详情。

    Z      (output) REAL array, dimension (M)
           ! 这个数组的前几个元素包含调整后的更新行向量的分量。

    K      (output) INTEGER
           ! 包含非缩减矩阵的维度，这是相关截断方程的阶数。1 <= K <= N。

    C      (output) REAL
           ! 如果 SQRE = 0，则 C 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 C 值。

    S      (output) REAL
           ! 如果 SQRE = 0，则 S 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 S 值。

    WORK   (workspace) REAL array, dimension (4 * M)
           ! 工作空间数组。

    IWORK  (workspace) INTEGER array, dimension (3 * N)
           ! 工作空间数组。
    # INFO 是一个输出参数，用于指示函数的执行结果：
    # - INFO = 0: 成功退出。
    # - INFO < 0: 如果 INFO = -i，表示第 i 个参数具有非法值。
    # - INFO > 0: 如果 INFO = 1，表示某个奇异值没有收敛。
    
    # 进一步的细节说明：
    # =================
    # 此部分基于以下贡献：
    # Ming Gu 和 Huan Ren，加利福尼亚大学伯克利分校，计算机科学系，美国
    
    # =========================================================================
    
    # 测试输入参数的有效性。
/* Parameter adjustments */
/* 调整参数 */

    --d__;
    --vf;
    --vl;
    --idxq;
    --perm;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    poles_dim1 = *ldgnum;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    givnum_dim1 = *ldgnum;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    --difl;
    --difr;
    --z__;
    --work;
    --iwork;

    /* Function Body */
    /* 函数主体 */

    *info = 0;
    /* 将 info 初始化为 0 */
    n = *nl + *nr + 1;
    /* 计算 n 的值 */
    m = n + *sqre;
    /* 计算 m 的值 */

    if (*icompq < 0 || *icompq > 1) {
    /* 检查 icompq 的取值范围 */
    *info = -1;
    } else if (*nl < 1) {
    /* 检查 nl 的取值 */
    *info = -2;
    } else if (*nr < 1) {
    /* 检查 nr 的取值 */
    *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {
    /* 检查 sqre 的取值 */
    *info = -4;
    } else if (*ldgcol < n) {
    /* 检查 ldgcol 的取值 */
    *info = -14;
    } else if (*ldgnum < n) {
    /* 检查 ldgnum 的取值 */
    *info = -16;
    }
    if (*info != 0) {
    /* 如果 info 不为 0，则调用错误处理程序并返回 */
    i__1 = -(*info);
    xerbla_("SLASD6", &i__1);
    return 0;
    }

/*
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in SLASD7 and SLASD8.
*/
/*
       以下数值仅用于簿记目的。它们是整数指针，指示 SLASD7 和 SLASD8 中某个数组在工作空间中的使用部分。
*/

    isigma = 1;
    /* 设置 isigma 的初始值 */
    iw = isigma + n;
    /* 计算 iw 的值 */
    ivfw = iw + m;
    /* 计算 ivfw 的值 */
    ivlw = ivfw + m;
    /* 计算 ivlw 的值 */

    idx = 1;
    /* 设置 idx 的初始值 */
    idxc = idx + n;
    /* 计算 idxc 的值 */
    idxp = idxc + n;
    /* 计算 idxp 的值 */

/*
       Scale.
*/
/*
       缩放。
*/

   Computing MAX
   /* 计算最大值 */

    r__1 = dabs(*alpha), r__2 = dabs(*beta);
    /* 计算 alpha 和 beta 的绝对值 */
    orgnrm = dmax(r__1,r__2);
    /* 取 alpha 和 beta 绝对值的较大值作为 orgnrm */
    d__[*nl + 1] = 0.f;
    /* 将 d 中的第 nl+1 个元素设为 0 */
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 循环处理每个元素 */
    if ((r__1 = d__[i__], dabs(r__1)) > orgnrm) {
        orgnrm = (r__1 = d__[i__], dabs(r__1));
    }
/* L10: */
    }
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &n, &c__1, &d__[1], &n, info);
    /* 调用 slascl 函数进行缩放 */
    *alpha /= orgnrm;
    /* 将 alpha 除以 orgnrm */
    *beta /= orgnrm;
    /* 将 beta 除以 orgnrm */

/*     Sort and Deflate singular values. */
/*     对奇异值进行排序和缩减。 */

    slasd7_(icompq, nl, nr, sqre, k, &d__[1], &z__[1], &work[iw], &vf[1], &
        work[ivfw], &vl[1], &work[ivlw], alpha, beta, &work[isigma], &
        iwork[idx], &iwork[idxp], &idxq[1], &perm[1], givptr, &givcol[
        givcol_offset], ldgcol, &givnum[givnum_offset], ldgnum, c__, s,
        info);

/*     Solve Secular Equation, compute DIFL, DIFR, and update VF, VL. */
/*     解决特征方程，计算 DIFL、DIFR，并更新 VF 和 VL。 */

    slasd8_(icompq, k, &d__[1], &z__[1], &vf[1], &vl[1], &difl[1], &difr[1],
        ldgnum, &work[isigma], &work[iw], info);

/*     Save the poles if ICOMPQ = 1. */
/*     如果 ICOMPQ = 1，则保存极点。 */

    if (*icompq == 1) {
    /* 如果 icompq 为 1 */
    scopy_(k, &d__[1], &c__1, &poles[poles_dim1 + 1], &c__1);
    /* 复制 d 的部分到 poles */
    scopy_(k, &work[isigma], &c__1, &poles[(poles_dim1 << 1) + 1], &c__1);
    /* 复制 work 中的部分到 poles 的第二部分 */
    }

/*     Unscale. */
/*     反缩放。 */

    slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &n, &c__1, &d__[1], &n, info);

/*     Prepare the IDXQ sorting permutation. */
/*     准备 IDXQ 排序置换。 */

    n1 = *k;
    /* 设置 n1 的值为 k */
    n2 = n - *k;
    /* 设置 n2 的值为 n - k */
    slamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &idxq[1]);
    /* 调用 slamrg 函数进行排序 */

    return 0;

/*     End of SLASD6 */
/*     SLASD6 结束 */

} /* slasd6_ */

/* Subroutine */ int slasd7_(integer *icompq, integer *nl, integer *nr,
    integer *sqre, integer *k, real *d__, real *z__, real *zw, real *vf,
    /* 子程序 slasd7 的声明 */
    # 声明实数指针，用于存储向量vfw、向量vl、向量vlw、alpha、beta、dsigma的地址
    real *vfw, real *vl, real *vlw, real *alpha, real *beta, real *dsigma,
    # 声明整数指针，用于存储数组idx、idxp、idxq、perm、givptr、givcol的地址
     integer *idx, integer *idxp, integer *idxq, integer *perm, integer *
    # 声明整数指针，用于存储ldgcol、givnum、ldgnum、c__、s、info的地址
    givptr, integer *givcol, integer *ldgcol, real *givnum, integer *
    # 声明实数指针，用于存储数组ldgnum、c__、s的地址
    ldgnum, real *c__, real *s, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, givnum_dim1, givnum_offset, i__1;
    real r__1, r__2;

    /* Local variables */
    static integer i__, j, m, n, k2;
    static real z1;
    static integer jp;
    static real eps, tau, tol;
    static integer nlp1, nlp2, idxi, idxj;
    extern /* Subroutine */ int srot_(integer *, real *, integer *, real *,
        integer *, real *, real *);
    static integer idxjp, jprev;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    extern doublereal slapy2_(real *, real *), slamch_(char *);
    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
        integer *, integer *, real *, integer *, integer *, integer *);
    static real hlftol;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASD7 merges the two sets of singular values together into a single
    sorted set. Then it tries to deflate the size of the problem. There
    are two ways in which deflation can occur:  when two or more singular
    values are close together or if there is a tiny entry in the Z
    vector. For each such occurrence the order of the related
    secular equation problem is reduced by one.

    SLASD7 is called from SLASD6.

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows:
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper
                 bidiagonal matrix in compact form.

    NL     (input) INTEGER
           The row dimension of the upper block. NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block. NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has
           N = NL + NR + 1 rows and
           M = N + SQRE >= N columns.

    K      (output) INTEGER
           Contains the dimension of the non-deflated matrix, this is
           the order of the related secular equation. 1 <= K <=N.

    D      (input/output) REAL array, dimension ( N )
           On entry D contains the singular values of the two submatrices
           to be combined. On exit D contains the trailing (N-K) updated
           singular values (those which were deflated) sorted into
           increasing order.

    Z      (output) REAL array, dimension ( M )
           On exit Z contains the updating row vector in the secular
           equation.

    ZW     (workspace) REAL array, dimension ( M )
           Workspace for Z.
*/
    # VF 是一个实数数组，用于存储右奇异向量的第一个分量。
    # 在函数调用前，VF(1:NL+1) 包含上半部分的右奇异向量的第一个分量，
    # VF(NL+2:M) 包含下半部分的右奇异向量的第一个分量。
    # 函数执行后，VF 存储了奇异值分解后的右奇异向量的第一个分量。

    # VFW 是 VF 的工作空间，用于临时存储数据。

    # VL 是一个实数数组，用于存储右奇异向量的最后一个分量。
    # 在函数调用前，VL(1:NL+1) 包含上半部分的右奇异向量的最后一个分量，
    # VL(NL+2:M) 包含下半部分的右奇异向量的最后一个分量。
    # 函数执行后，VL 存储了奇异值分解后的右奇异向量的最后一个分量。

    # VLW 是 VL 的工作空间，用于临时存储数据。

    # ALPHA 是一个实数，表示添加行对应的对角线元素。

    # BETA 是一个实数，表示添加行对应的非对角线元素。

    # DSIGMA 是一个实数数组，长度为 N，存储了副对角线矩阵的奇异值分解中的对角元素。

    # IDX 是一个整数数组，长度为 N，用作排序 D 中元素的排列。

    # IDXP 是一个整数数组，长度为 N，用于将 D 的被缩减值放置在数组末尾。

    # IDXQ 是一个整数数组，长度为 N，用于分别对 D 中的两个子问题进行排序。

    # PERM 是一个整数数组，长度为 N，包含了对每个奇异块应用的排列（用于缩减和排序）。

    # GIVPTR 是一个整数，表示在此子问题中进行的 Givens 旋转的数量。

    # GIVCOL 是一个整数数组，维度为 (LDGCOL, 2)，每对数字表示参与 Givens 旋转的列。
    # LDGCOL 是 GIVCOL 的行数，至少为 N。
    # GIVNUM (output) REAL array, dimension ( LDGNUM, 2 )
    #        每个数值表示相应 Givens 旋转中要使用的 C 或 S 值。如果 ICOMPQ = 0，则不引用此参数。

    # LDGNUM (input) INTEGER
    #        GIVNUM 的主维度，必须至少为 N。

    # C      (output) REAL
    #        如果 SQRE = 0，则 C 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 C 值。

    # S      (output) REAL
    #        如果 SQRE = 0，则 S 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 S 值。

    # INFO   (output) INTEGER
    #        = 0: 成功退出。
    #        < 0: 如果 INFO = -i，则第 i 个参数具有非法值。

    # Further Details
    # ===============

    # 基于以下贡献而设计：
    #    Ming Gu 和 Huan Ren，加州大学伯克利分校，计算机科学系，美国

    # =====================================================================

    # 测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;              /* Adjusted pointers for arrays: d__ */
    --z__;              /* Adjusted pointers for arrays: z__ */
    --zw;               /* Adjusted pointers for arrays: zw */
    --vf;               /* Adjusted pointers for arrays: vf */
    --vfw;              /* Adjusted pointers for arrays: vfw */
    --vl;               /* Adjusted pointers for arrays: vl */
    --vlw;              /* Adjusted pointers for arrays: vlw */
    --dsigma;           /* Adjusted pointers for arrays: dsigma */
    --idx;              /* Adjusted pointers for arrays: idx */
    --idxp;             /* Adjusted pointers for arrays: idxp */
    --idxq;             /* Adjusted pointers for arrays: idxq */
    --perm;             /* Adjusted pointers for arrays: perm */
    givcol_dim1 = *ldgcol;  /* Setting dimension for givcol */
    givcol_offset = 1 + givcol_dim1;  /* Setting offset for givcol */
    givcol -= givcol_offset;  /* Adjusting givcol pointer */
    givnum_dim1 = *ldgnum;  /* Setting dimension for givnum */
    givnum_offset = 1 + givnum_dim1;  /* Setting offset for givnum */
    givnum -= givnum_offset;  /* Adjusting givnum pointer */

    /* Function Body */
    *info = 0;          /* Initializing info to 0 */
    n = *nl + *nr + 1;  /* Calculating n */
    m = n + *sqre;      /* Calculating m */

    if (*icompq < 0 || *icompq > 1) {
        *info = -1;     /* Checking and setting info for invalid icompq */
    } else if (*nl < 1) {
        *info = -2;     /* Checking and setting info for nl < 1 */
    } else if (*nr < 1) {
        *info = -3;     /* Checking and setting info for nr < 1 */
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -4;     /* Checking and setting info for invalid sqre */
    } else if (*ldgcol < n) {
        *info = -22;    /* Checking and setting info for ldgcol < n */
    } else if (*ldgnum < n) {
        *info = -24;    /* Checking and setting info for ldgnum < n */
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASD7", &i__1);  /* Handling errors with xerbla_ */
        return 0;       /* Returning from function in case of error */
    }

    nlp1 = *nl + 1;     /* Calculating nlp1 */
    nlp2 = *nl + 2;     /* Calculating nlp2 */
    if (*icompq == 1) {
        *givptr = 0;    /* Initializing givptr if icompq == 1 */
    }

/*
       Generate the first part of the vector Z and move the singular
       values in the first part of D one position backward.
*/

    z1 = *alpha * vl[nlp1];     /* Calculating z1 */
    vl[nlp1] = 0.f;             /* Setting vl[nlp1] to 0 */
    tau = vf[nlp1];             /* Assigning tau */
    for (i__ = *nl; i__ >= 1; --i__) {
        z__[i__ + 1] = *alpha * vl[i__];    /* Calculating z__[i__ + 1] */
        vl[i__] = 0.f;                      /* Setting vl[i__] to 0 */
        vf[i__ + 1] = vf[i__];              /* Shifting vf */
        d__[i__ + 1] = d__[i__];            /* Shifting d */
        idxq[i__ + 1] = idxq[i__] + 1;      /* Updating idxq */
/* L10: */
    }
    vf[1] = tau;    /* Assigning vf[1] */

/*     Generate the second part of the vector Z. */

    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        z__[i__] = *beta * vf[i__];     /* Calculating z__[i__] */
        vf[i__] = 0.f;                  /* Setting vf[i__] to 0 */
/* L20: */
    }

/*     Sort the singular values into increasing order */

    i__1 = n;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        idxq[i__] += nlp1;  /* Updating idxq */
/* L30: */
    }

/*     DSIGMA, IDXC, IDXC, and ZW are used as storage space. */

    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        dsigma[i__] = d__[idxq[i__]];   /* Assigning dsigma[i__] */
        zw[i__] = z__[idxq[i__]];       /* Assigning zw[i__] */
        vfw[i__] = vf[idxq[i__]];       /* Assigning vfw[i__] */
        vlw[i__] = vl[idxq[i__]];       /* Assigning vlw[i__] */
/* L40: */
    }

    slamrg_(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);  /* Calling slamrg_ to sort */

    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        idxi = idx[i__] + 1;        /* Calculating idxi */
        d__[i__] = dsigma[idxi];    /* Assigning d__[i__] */
        z__[i__] = zw[idxi];        /* Assigning z__[i__] */
        vf[i__] = vfw[idxi];        /* Assigning vf[i__] */
        vl[i__] = vlw[idxi];        /* Assigning vl[i__] */
/* L50: */
    }

/*     Calculate the allowable deflation tolerence */

    eps = slamch_("Epsilon");       /* Calculating machine epsilon */
/* Computing MAX */
    r__1 = dabs(*alpha), r__2 = dabs(*beta);
    tol = dmax(r__1,r__2);          /* Calculating maximum of absolute values */
/* Computing MAX */
    r__2 = (r__1 = d__[n], dabs(r__1));
    tol = eps * 64.f * dmax(r__2,tol);  /* Calculating tolerance */
/*
   There are 2 kinds of deflation -- first a value in the z-vector
   is small, second two (or more) singular values are very close
   together (their difference is small).

   If the value in the z-vector is small, we simply permute the
   array so that the corresponding singular value is moved to the
   end.

   If two values in the D-vector are close, we perform a two-sided
   rotation designed to make one of the corresponding z-vector
   entries zero, and then permute the array so that the deflated
   singular value is moved to the end.

   If there are multiple singular values then the problem deflates.
   Here the number of equal singular values are found.  As each equal
   singular value is found, an elementary reflector is computed to
   rotate the corresponding singular subspace so that the
   corresponding components of Z are zero in this new basis.
*/

*k = 1;   // Initialize the number of deflated singular values

k2 = n + 1;   // Initialize the index for permutation of deflated singular values

// Loop through the singular values to determine deflation criteria
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    if ((r__1 = z__[j], dabs(r__1)) <= tol) {

        /* Deflate due to small z component. */

        --k2;   // Decrease the permutation index
        idxp[k2] = j;   // Record the index of the deflated singular value
        if (j == n) {
            goto L100;   // Exit loop if at the end of singular values
        }
    } else {
        jprev = j;   // Store current index as previous for potential deflation
        goto L70;   // Jump to check further criteria
    }
    /* L60: */
}

L70:
j = jprev;   // Initialize j from the stored previous index
L80:
++j;   // Move to the next singular value
if (j > n) {
    goto L90;   // Exit loop if all singular values have been processed
}
if ((r__1 = z__[j], dabs(r__1)) <= tol) {

    /* Deflate due to small z component. */

    --k2;   // Decrease the permutation index
    idxp[k2] = j;   // Record the index of the deflated singular value
} else {

    /* Check if singular values are close enough to allow deflation. */

    if ((r__1 = d__[j] - d__[jprev], dabs(r__1)) <= tol) {

        /* Deflation is possible. */

        *s = z__[jprev];   // Store z-vector element for rotation
        *c__ = z__[j];     // Store z-vector element for rotation

        /*
           Find sqrt(a**2+b**2) without overflow or
           destructive underflow.
        */

        tau = slapy2_(c__, s);   // Compute square root of sum of squares
        z__[j] = tau;   // Update z-vector with the computed value
        z__[jprev] = 0.f;   // Zero out the previous z-vector element
        *c__ /= tau;   // Normalize rotation coefficients
        *s = -(*s) / tau;   // Normalize rotation coefficients

        /* Record the appropriate Givens rotation */

        if (*icompq == 1) {
            ++(*givptr);   // Increment Givens rotation counter
            idxjp = idxq[idx[jprev] + 1];   // Calculate index for permutation
            idxj = idxq[idx[j] + 1];   // Calculate index for permutation
            if (idxjp <= nlp1) {
                --idxjp;   // Adjust index for permutation
            }
            if (idxj <= nlp1) {
                --idxj;   // Adjust index for permutation
            }
            givcol[*givptr + (givcol_dim1 << 1)] = idxjp;   // Store index for Givens rotation
            givcol[*givptr + givcol_dim1] = idxj;   // Store index for Givens rotation
            givnum[*givptr + (givnum_dim1 << 1)] = *c__;   // Store rotation coefficient
            givnum[*givptr + givnum_dim1] = *s;   // Store rotation coefficient
        }
        srot_(&c__1, &vf[jprev], &c__1, &vf[j], &c__1, c__, s);   // Apply rotation to vectors
        srot_(&c__1, &vl[jprev], &c__1, &vl[j], &c__1, c__, s);   // Apply rotation to vectors
        --k2;   // Decrease the permutation index
        idxp[k2] = jprev;   // Record the index of the deflated singular value
        jprev = j;   // Update previous index for potential further deflation
    } else {
        ++(*k);   // Increment count of singular values
        zw[*k] = z__[jprev];   // Store z-vector element
        dsigma[*k] = d__[jprev];   // Store D-vector element
        idxp[*k] = jprev;   // Record the index of the deflated singular value
        jprev = j;   // Update previous index for potential further deflation
    }
}
goto L80;   // Continue looping through singular values
L90:

/* Record the last singular value. */

++(*k);   // Increment count of singular values
zw[*k] = z__[jprev];   // Store z-vector element
dsigma[*k] = d__[jprev];   // Store D-vector element
idxp[*k] = jprev;   // Record the index of the deflated singular value

L100:
/*
       Sort the singular values into DSIGMA. The singular values which
       were not deflated go into the first K slots of DSIGMA, except
       that DSIGMA(1) is treated separately.
*/

i__1 = n;
for (j = 2; j <= i__1; ++j) {
jp = idxp[j];
dsigma[j] = d__[jp];
vfw[j] = vf[jp];
vlw[j] = vl[jp];
/* L110: */
}

if (*icompq == 1) {
i__1 = n;
for (j = 2; j <= i__1; ++j) {
jp = idxp[j];
perm[j] = idxq[idx[jp] + 1];
if (perm[j] <= nlp1) {
--perm[j];
}
/* L120: */
}
}

/*
       The deflated singular values go back into the last N - K slots of
       D.
*/

i__1 = n - *k;
scopy_(&i__1, &dsigma[*k + 1], &c__1, &d__[*k + 1], &c__1);

/*
       Determine DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), and
       VL(M).
*/

dsigma[1] = 0.f;
hlftol = tol / 2.f;
if (dabs(dsigma[2]) <= hlftol) {
dsigma[2] = hlftol;
}
if (m > n) {
z__[1] = slapy2_(&z1, &z__[m]);
if (z__[1] <= tol) {
*c__ = 1.f;
*s = 0.f;
z__[1] = tol;
} else {
*c__ = z1 / z__[1];
*s = -z__[m] / z__[1];
}
srot_(&c__1, &vf[m], &c__1, &vf[1], &c__1, c__, s);
srot_(&c__1, &vl[m], &c__1, &vl[1], &c__1, c__, s);
} else {
if (dabs(z1) <= tol) {
z__[1] = tol;
} else {
z__[1] = z1;
}
}

/*     Restore Z, VF, and VL. */

i__1 = *k - 1;
scopy_(&i__1, &zw[2], &c__1, &z__[2], &c__1);
i__1 = n - 1;
scopy_(&i__1, &vfw[2], &c__1, &vf[2], &c__1);
i__1 = n - 1;
scopy_(&i__1, &vlw[2], &c__1, &vl[2], &c__1);

return 0;

/*     End of SLASD7 */

} /* slasd7_ */


注释：

/*
       Sort the singular values into DSIGMA. The singular values which
       were not deflated go into the first K slots of DSIGMA, except
       that DSIGMA(1) is treated separately.
*/

// 将奇异值按顺序排序到 DSIGMA 中，未被放缩的奇异值放入 DSIGMA 的前 K 个位置，但 DSIGMA(1) 需要单独处理。

i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    dsigma[j] = d__[jp];
    vfw[j] = vf[jp];
    vlw[j] = vl[jp];
    // 将未放缩的奇异值及其对应的 VF 和 VL 存入 DSIGMA、VFW 和 VLW 数组中
    /* L110: */
}

if (*icompq == 1) {
    i__1 = n;
    for (j = 2; j <= i__1; ++j) {
        jp = idxp[j];
        perm[j] = idxq[idx[jp] + 1];
        if (perm[j] <= nlp1) {
            --perm[j];
        }
        // 如果需要计算 Q 矩阵，则重新排列 perm 数组
        /* L120: */
    }
}

/*
       The deflated singular values go back into the last N - K slots of
       D.
*/

// 放缩后的奇异值重新放回 D 的末尾 N-K 个位置

i__1 = n - *k;
scopy_(&i__1, &dsigma[*k + 1], &c__1, &d__[*k + 1], &c__1);

/*
       Determine DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), and
       VL(M).
*/

// 确定 DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), 和 VL(M)

dsigma[1] = 0.f;
hlftol = tol / 2.f;
if (dabs(dsigma[2]) <= hlftol) {
    dsigma[2] = hlftol;
}
// 将 DSIGMA(1) 初始化为 0，确保 DSIGMA(2) 大于等于阈值 hlftol

if (m > n) {
    z__[1] = slapy2_(&z1, &z__[m]);
    if (z__[1] <= tol) {
        *c__ = 1.f;
        *s = 0.f;
        z__[1] = tol;
    } else {
        *c__ = z1 / z__[1];
        *s = -z__[m] / z__[1];
    }
    // 如果 m 大于 n，则计算 Z(1)，并根据条件计算旋转角度 *c__ 和 *s，以及更新 Z(1)
    srot_(&c__1, &vf[m], &c__1, &vf[1], &c__1, c__, s);
    srot_(&c__1, &vl[m], &c__1, &vl[1], &c__1, c__, s);
    // 对 VF 和 VL 进行旋转变换
} else {
    if (dabs(z1) <= tol) {
        z__[1] = tol;
    } else {
        z__[1] = z1;
    }
    // 如果 m 不大于 n，则直接更新 Z(1)
}

/*     Restore Z, VF, and VL. */

// 恢复 Z, VF 和 VL 数组的值

i__1 = *k - 1;
scopy_(&i__1, &zw[2], &c__1, &z__[2], &c__1);
// 复制 zw 数组中除第一个元素外的值到 Z 数组中
i__1 = n - 1;
scopy_(&i__1, &vfw[2], &c__1, &vf[2], &c__1);
// 复制 vfw 数组中除第一个元素外的值到 VF 数组中
i__1 = n - 1;
scopy_(&i__1, &vlw[2], &c__1, &vl[2], &c__1);
// 复制 vlw 数组中除第一个元素外的值到 VL 数组中

return 0;

/*     End of SLASD7 */

} /* slasd7_ */
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    ! LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，发布于2010年6月。


    Purpose
    =======


    ! 该部分介绍SLASD8的目的和功能。


    SLASD8 finds the square roots of the roots of the secular equation,
    as defined by the values in DSIGMA and Z. It makes the appropriate
    calls to SLASD4, and stores, for each  element in D, the distance
    to its two nearest poles (elements in DSIGMA). It also updates
    the arrays VF and VL, the first and last components of all the
    right singular vectors of the original bidiagonal matrix.

    SLASD8 is called from SLASD6.


    ! SLASD8用于找到分母多项式的根的平方根，根据DSIGMA和Z中的值定义。它调用SLASD4，并且为D中的每个元素存储到其两个最近极点（DSIGMA中的元素）的距离。
    ! 还更新数组VF和VL，它们分别是原始双对角矩阵所有右奇异向量的第一个和最后一个分量。
    ! SLASD8由SLASD6调用。


    Arguments
    =========


    ! 以下是SLASD8的参数说明。


    ICOMPQ  (input) INTEGER
            Specifies whether singular vectors are to be computed in
            factored form in the calling routine:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.

    K       (input) INTEGER
            The number of terms in the rational function to be solved
            by SLASD4.  K >= 1.

    D       (output) REAL array, dimension ( K )
            On output, D contains the updated singular values.

    Z       (input/output) REAL array, dimension ( K )
            On entry, the first K elements of this array contain the
            components of the deflation-adjusted updating row vector.
            On exit, Z is updated.

    VF      (input/output) REAL array, dimension ( K )
            On entry, VF contains  information passed through DBEDE8.
            On exit, VF contains the first K components of the first
            components of all right singular vectors of the bidiagonal
            matrix.

    VL      (input/output) REAL array, dimension ( K )
            On entry, VL contains  information passed through DBEDE8.
            On exit, VL contains the first K components of the last
            components of all right singular vectors of the bidiagonal
            matrix.

    DIFL    (output) REAL array, dimension ( K )
            On exit, DIFL(I) = D(I) - DSIGMA(I).

    DIFR    (output) REAL array,
                     dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                     dimension ( K ) if ICOMPQ = 0.
            On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
            defined and will not be referenced.

            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.

    LDDIFR  (input) INTEGER
            The leading dimension of DIFR, must be at least K.

    DSIGMA  (input/output) REAL array, dimension ( K )
            On entry, the first K elements of this array contain the old
            roots of the deflated updating problem.  These are the poles
            of the secular equation.
            On exit, the elements of DSIGMA may be very slightly altered
            in value.

    WORK    (workspace) REAL array, dimension at least 3 * K


    ! 参数说明：
    ! - ICOMPQ：指定是否在调用例程中以分解形式计算奇异向量。
    ! - K：SLASD4要解决的有理函数中的项数。
    ! - D：输出，包含更新的奇异值。
    ! - Z：输入/输出，数组的前K个元素包含调整后的更新行向量的分量。返回时Z被更新。
    ! - VF：输入/输出，包含通过DBEDE8传递的信息。返回时包含双对角矩阵所有右奇异向量的第一个分量的前K个分量。
    ! - VL：输入/输出，包含通过DBEDE8传递的信息。返回时包含双对角矩阵所有右奇异向量的最后一个分量的前K个分量。
    ! - DIFL：输出，DIFL(I) = D(I) - DSIGMA(I)。
    ! - DIFR：输出，如果ICOMPQ = 1，则维度为(LDDIFR, 2)，如果ICOMPQ = 0，则维度为(K)。返回时，DIFR(I,1) = D(I) - DSIGMA(I+1)，DIFR(K,1)未定义也不会被引用。如果ICOMPQ = 1，则DIFR(1:K,2)是包含右奇异向量矩阵的归一化因子的数组。
    ! - LDDIFR：输入，DIFR的主维度，至少为K。
    ! - DSIGMA：输入/输出，数组的前K个元素包含缩减更新问题的旧根。这些是分母多项式的极点。返回时，DSIGMA的元素可能会有极小的变化。
    ! - WORK：工作空间，至少为3 * K维。
    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge

# INFO是函数的输出参数，表示函数的执行状态：
# - 0: 函数成功执行完成。
# - 小于0: 如果INFO = -i，表示第i个参数具有非法值。
# - 大于0: 如果INFO = 1，表示某个奇异值未收敛。


    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================


# 说明：
# - 详细信息：
# - 根据以下贡献
# - Ming Gu和Huan Ren，加州大学伯克利分校的计算机科学系
    /* Parameter adjustments */
    --d__;               // 参数d的指针
    --z__;               // 参数z的指针
    --vf;                // 参数vf的指针
    --vl;                // 参数vl的指针
    --difl;              // 参数difl的指针
    difr_dim1 = *lddifr; // 定义变量difr_dim1为参数*lddifr的值
    difr_offset = 1 + difr_dim1;  // 计算difr数组的偏移量
    difr -= difr_offset;   // 对difr数组进行偏移
    --dsigma;             // 参数dsigma的指针
    --work;               // 参数work的指针

    /* Function Body */
    *info = 0;            // 初始化info为0

    if (*icompq < 0 || *icompq > 1) {  // 检查icompq的取值范围
        *info = -1;
    } else if (*k < 1) {   // 检查k的取值范围
        *info = -2;
    } else if (*lddifr < *k) {  // 检查lddifr的取值范围
        *info = -9;
    }
    if (*info != 0) {      // 如果info不等于0，则报错
        i__1 = -(*info);
        xerbla_("SLASD8", &i__1);  // 调用错误处理函数xerbla_
        return 0;
    }

/*     Quick return if possible */

    if (*k == 1) {         // 如果k等于1，直接返回结果
        d__[1] = dabs(z__[1]);  // 计算d[1]的绝对值
        difl[1] = d__[1];    // 设置difl[1]的值
        if (*icompq == 1) {  // 如果icompq为1，设置额外的difl和difr值
            difl[2] = 1.f;
            difr[(difr_dim1 << 1) + 1] = 1.f;
        }
        return 0;
    }

/*
       Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
       which on any of these machines zeros out the bottommost
       bit of DSIGMA(I) if it is 1; this makes the subsequent
       subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DSIGMA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DSIGMA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DLAMBDA(I) to prevent optimizing compilers from eliminating
       this code.
*/

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dsigma[i__] = slamc3_(&dsigma[i__], &dsigma[i__]) - dsigma[i__];  // 修改dsigma数组的值
    }

/*     Book keeping. */

    iwk1 = 1;              // 初始化iwk1
    iwk2 = iwk1 + *k;      // 计算iwk2
    iwk3 = iwk2 + *k;      // 计算iwk3
    iwk2i = iwk2 - 1;      // 计算iwk2i
    iwk3i = iwk3 - 1;      // 计算iwk3i

/*     Normalize Z. */

    rho = snrm2_(k, &z__[1], &c__1);  // 计算向量z的二范数
    slascl_("G", &c__0, &c__0, &rho, &c_b15, k, &c__1, &z__[1], k, info);  // 对z进行归一化
    rho *= rho;            // 计算rho的平方

/*     Initialize WORK(IWK3). */

    slaset_("A", k, &c__1, &c_b15, &c_b15, &work[iwk3], k);  // 初始化work数组的一部分为常数

/*
       Compute the updated singular values, the arrays DIFL, DIFR,
       and the updated Z.
*/

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        slasd4_(k, &j, &dsigma[1], &z__[1], &work[iwk1], &rho, &d__[j], &work[iwk2], info);  // 调用slasd4_计算更新后的值

/*        If the root finder fails, the computation is terminated. */

        if (*info != 0) {  // 如果info不为0，结束计算
            return 0;
        }
        work[iwk3i + j] = work[iwk3i + j] * work[j] * work[iwk2i + j];  // 更新work数组的一个部分
        difl[j] = -work[j];  // 更新difl数组的一个部分
        difr[j + difr_dim1] = -work[j + 1];  // 更新difr数组的一个部分
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            work[iwk3i + i__] = work[iwk3i + i__] * work[i__] * work[iwk2i + i__] / (dsigma[i__] - dsigma[j]) / (dsigma[i__] + dsigma[j]);  // 更新work数组的一部分
        }
/* L20: */
    }
    i__2 = *k;
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        work[iwk3i + i__] = work[iwk3i + i__] * work[i__] * work[iwk2i +
            i__] / (dsigma[i__] - dsigma[j]) / (dsigma[i__] + dsigma[
            j]);
    }



// 循环遍历 i__ 从 j+1 到 i__2
for (i__ = j + 1; i__ <= i__2; ++i__) {
    // 计算 work 数组中的元素
    work[iwk3i + i__] = work[iwk3i + i__] * work[i__] * work[iwk2i +
        i__] / (dsigma[i__] - dsigma[j]) / (dsigma[i__] + dsigma[
        j]);
}
/* L30: */
    }
/* L40: */
    }

/*     Compute updated Z. */

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
    r__2 = sqrt((r__1 = work[iwk3i + i__], dabs(r__1)));
    z__[i__] = r_sign(&r__2, &z__[i__]);
/* L50: */
    }

/*     Update VF and VL. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    diflj = difl[j];
    dj = d__[j];
    dsigj = -dsigma[j];
    if (j < *k) {
        difrj = -difr[j + difr_dim1];
        dsigjp = -dsigma[j + 1];
    }
    work[j] = -z__[j] / diflj / (dsigma[j] + dj);
    i__2 = j - 1;
    for (i__ = 1; i__ <= i__2; ++i__) {
        work[i__] = z__[i__] / (slamc3_(&dsigma[i__], &dsigj) - diflj) / (
            dsigma[i__] + dj);
/* L60: */
    }
    i__2 = *k;
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        work[i__] = z__[i__] / (slamc3_(&dsigma[i__], &dsigjp) + difrj) /
            (dsigma[i__] + dj);
/* L70: */
    }
    temp = snrm2_(k, &work[1], &c__1);
    work[iwk2i + j] = sdot_(k, &work[1], &c__1, &vf[1], &c__1) / temp;
    work[iwk3i + j] = sdot_(k, &work[1], &c__1, &vl[1], &c__1) / temp;
    if (*icompq == 1) {
        difr[j + (difr_dim1 << 1)] = temp;
    }
/* L80: */
    }

    scopy_(k, &work[iwk2], &c__1, &vf[1], &c__1);
    scopy_(k, &work[iwk3], &c__1, &vl[1], &c__1);

    return 0;

/*     End of SLASD8 */

} /* slasd8_ */

/* Subroutine */ int slasda_(integer *icompq, integer *smlsiz, integer *n,
    integer *sqre, real *d__, real *e, real *u, integer *ldu, real *vt,
    integer *k, real *difl, real *difr, real *z__, real *poles, integer *
    givptr, integer *givcol, integer *ldgcol, integer *perm, real *givnum,
     real *c__, real *s, real *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
        difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
        z_dim1, z_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, m, i1, ic, lf, nd, ll, nl, vf, nr, vl, im1, ncc,
        nlf, nrf, vfi, iwk, vli, lvl, nru, ndb1, nlp1, lvl2, nrp1;
    static real beta;
    static integer idxq, nlvl;
    static real alpha;
    static integer inode, ndiml, ndimr, idxqi, itemp, sqrei;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slasd6_(integer *, integer *, integer *, integer *,
        real *, real *, real *, real *, real *, integer *, integer *,
        integer *, integer *, integer *, real *, integer *, real *, real *
        , real *, real *, integer *, real *, real *, real *, integer *,
        integer *);
    static integer nwork1, nwork2;
    # 外部声明，调用了一个子程序 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *),

    # 调用了 slasdq_ 子程序，执行特定的对称对角化任务
    slasdq_(char *, integer *, integer *, integer *, integer *, integer *,
            real *, real *, real *, integer *, real *, integer *, real *,
            integer *, real *, integer *),

    # 调用了 slasdt_ 子程序，初始化对称矩阵的特征值排序
    slasdt_(integer *, integer *, integer *, integer *, integer *, integer *, integer *),

    # 调用了 slaset_ 子程序，设置矩阵的特定部分为给定值
    slaset_(char *, integer *, integer *, real *, real *, real *,
            integer *);

    # 静态变量声明，定义一个整数 smlszp
    static integer smlszp;
/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    Using a divide and conquer approach, SLASDA computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
    B with diagonal D and offdiagonal E, where M = N + SQRE. The
    algorithm computes the singular values in the SVD B = U * S * VT.
    The orthogonal matrices U and VT are optionally computed in
    compact form.

    A related subroutine, SLASD0, computes the singular values and
    the singular vectors in explicit form.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether singular vectors are to be computed
           in compact form, as follows
           = 0: Compute singular values only.
           = 1: Compute singular vectors of upper bidiagonal
                matrix in compact form.

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The row dimension of the upper bidiagonal matrix. This is
           also the dimension of the main diagonal array D.

    SQRE   (input) INTEGER
           Specifies the column dimension of the bidiagonal matrix.
           = 0: The bidiagonal matrix has column dimension M = N;
           = 1: The bidiagonal matrix has column dimension M = N + 1.

    D      (input/output) REAL array, dimension ( N )
           On entry D contains the main diagonal of the bidiagonal
           matrix. On exit D, if INFO = 0, contains its singular values.

    E      (input) REAL array, dimension ( M-1 )
           Contains the subdiagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    U      (output) REAL array,
           dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
           singular vector matrices of all subproblems at the bottom
           level.

    LDU    (input) INTEGER, LDU = > N.
           The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
           GIVNUM, and Z.

    VT     (output) REAL array,
           dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT' contains the right
           singular vector matrices of all subproblems at the bottom
           level.

    K      (output) INTEGER array, dimension ( N )
           if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
           If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
           secular equation on the computation tree.

    DIFL   (output) REAL array, dimension ( LDU, NLVL ),
           where NLVL = floor(log_2 (N/SMLSIZ))).
*/
    DIFR   (output) REAL array,
                    dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
           ! If ICOMPQ = 1, DIFR stores distances between singular values
           ! on consecutive levels and normalizing factors for right singular
           ! vector matrix. See SLASD8 for details.

    Z      (output) REAL array,
                    dimension ( LDU, NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
           ! If ICOMPQ = 1, Z contains deflation-adjusted updating row vectors
           ! for subproblems at each level.

    POLES  (output) REAL array,
           dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0.
           ! If ICOMPQ = 1, POLES stores new and old singular values involved
           ! in secular equations at each level.

    GIVPTR (output) INTEGER array,
           dimension ( N ) if ICOMPQ = 1, and not referenced if
           ICOMPQ = 0.
           ! If ICOMPQ = 1, GIVPTR records the number of Givens rotations
           ! performed on each subproblem on the computation tree.

    GIVCOL (output) INTEGER array,
           dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
           referenced if ICOMPQ = 0.
           ! If ICOMPQ = 1, GIVCOL records the locations of Givens rotations
           ! performed at each level on the computation tree.

    LDGCOL (input) INTEGER, LDGCOL = > N.
           ! The leading dimension of arrays GIVCOL and PERM.

    PERM   (output) INTEGER array, dimension ( LDGCOL, NLVL )
           if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0.
           ! If ICOMPQ = 1, PERM records permutations done at each level of
           ! the computation tree.

    GIVNUM (output) REAL array,
           dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
           referenced if ICOMPQ = 0.
           ! If ICOMPQ = 1, GIVNUM records the C- and S-values of Givens
           ! rotations performed at each level on the computation tree.

    C      (output) REAL array,
           dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
           ! If ICOMPQ = 1 and a subproblem is not square, C contains the
           ! C-value of a Givens rotation related to the right null space
           ! of each subproblem.
    # S (output) REAL array, dimension ( N ) if
    #    ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
    #    and the I-th subproblem is not square, on exit, S( I )
    #    contains the S-value of a Givens rotation related to
    #    the right null space of the I-th subproblem.
    S      (output) REAL array, dimension ( N )

    # WORK (workspace) REAL array, dimension
    #    (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
    WORK   (workspace) REAL array, dimension

    # IWORK (workspace) INTEGER array, dimension (7*N).
    IWORK  (workspace) INTEGER array, dimension

    # INFO (output) INTEGER
    #     = 0:  successful exit.
    #     < 0:  if INFO = -i, the i-th argument had an illegal value.
    #     > 0:  if INFO = 1, a singular value did not converge
    INFO   (output) INTEGER

    # Further Details
    # ===============
    # Based on contributions by
    #    Ming Gu and Huan Ren, Computer Science Division, University of
    #    California at Berkeley, USA

    # =====================================================================
    # Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --e;
    givnum_dim1 = *ldu;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    poles_dim1 = *ldu;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    z_dim1 = *ldu;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    difr_dim1 = *ldu;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    difl_dim1 = *ldu;
    difl_offset = 1 + difl_dim1;
    difl -= difl_offset;
    vt_dim1 = *ldu;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    --k;
    --givptr;
    perm_dim1 = *ldgcol;
    perm_offset = 1 + perm_dim1;
    perm -= perm_offset;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    --c__;
    --s;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;

    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*smlsiz < 3) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -4;
    } else if (*ldu < *n + *sqre) {
        *info = -8;
    } else if (*ldgcol < *n) {
        *info = -17;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASDA", &i__1);
        return 0;
    }

    m = *n + *sqre;

/*     If the input matrix is too small, call SLASDQ to find the SVD. */

    if (*n <= *smlsiz) {
        if (*icompq == 0) {
            slasdq_("U", sqre, n, &c__0, &c__0, &c__0, &d__[1], &e[1], &vt[
                vt_offset], ldu, &u[u_offset], ldu, &u[u_offset], ldu, &
                work[1], info);
        } else {
            slasdq_("U", sqre, n, &m, n, &c__0, &d__[1], &e[1], &vt[vt_offset]
                , ldu, &u[u_offset], ldu, &u[u_offset], ldu, &work[1],
                info);
        }
        return 0;
    }

/*     Book-keeping and  set up the computation tree. */

    inode = 1;
    ndiml = inode + *n;
    ndimr = ndiml + *n;
    idxq = ndimr + *n;
    iwk = idxq + *n;

    ncc = 0;
    nru = 0;

    smlszp = *smlsiz + 1;
    vf = 1;
    vl = vf + m;
    nwork1 = vl + m;
    nwork2 = nwork1 + smlszp * smlszp;

    slasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
        smlsiz);

/*
       for the nodes on bottom level of the tree, solve
       their subproblems by SLASDQ.
*/

    ndb1 = (nd + 1) / 2;
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
          IC : center row of each node
          NL : number of rows of left  subproblem
          NR : number of rows of right subproblem
          NLF: starting row of the left   subproblem
          NRF: starting row of the right  subproblem
*/

        i1 = i__ - 1;
        ic = iwork[inode + i1];
        nl = iwork[ndiml + i1];
        nlp1 = nl + 1;
        nr = iwork[ndimr + i1];
        nlf = ic - nl;
        nrf = ic + 1;
        idxqi = idxq + nlf - 2;
        vfi = vf + nlf - 1;
        vli = vl + nlf - 1;
        sqrei = 1;
    # 如果 icompq 等于 0，表示不需要计算特征向量
    if (*icompq == 0) {
        # 初始化工作区域中的一部分为常数值，用于后续计算
        slaset_("A", &nlp1, &nlp1, &c_b29, &c_b15, &work[nwork1], &smlszp);
        # 计算部分奇异值分解，结果存储在 d 和 e 数组中
        slasdq_("U", &sqrei, &nl, &nlp1, &nru, &ncc, &d__[nlf], &e[nlf], &
            work[nwork1], &smlszp, &work[nwork2], &nl, &work[nwork2],
            &nl, &work[nwork2], info);
        # 计算工作区域的偏移量
        itemp = nwork1 + nl * smlszp;
        # 复制部分数据到指定位置
        scopy_(&nlp1, &work[nwork1], &c__1, &work[vfi], &c__1);
        scopy_(&nlp1, &work[itemp], &c__1, &work[vli], &c__1);
    } else {
        # 初始化矩阵 u 的一部分为常数值
        slaset_("A", &nl, &nl, &c_b29, &c_b15, &u[nlf + u_dim1], ldu);
        # 初始化矩阵 vt 的一部分为常数值
        slaset_("A", &nlp1, &nlp1, &c_b29, &c_b15, &vt[nlf + vt_dim1],
            ldu);
        # 计算部分奇异值分解，结果存储在 d 和 e 数组中，并计算部分特征向量
        slasdq_("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d__[nlf], &e[nlf], &
            vt[nlf + vt_dim1], ldu, &u[nlf + u_dim1], ldu, &u[nlf +
            u_dim1], ldu, &work[nwork1], info);
        # 复制部分数据到指定位置
        scopy_(&nlp1, &vt[nlf + vt_dim1], &c__1, &work[vfi], &c__1);
        scopy_(&nlp1, &vt[nlf + nlp1 * vt_dim1], &c__1, &work[vli], &c__1)
            ;
    }
    # 如果计算过程中出现错误，则返回 0
    if (*info != 0) {
        return 0;
    }
    # 初始化索引数组 iwork 中一部分的值
    i__2 = nl;
    for (j = 1; j <= i__2; ++j) {
        iwork[idxqi + j] = j;
/* L10: */
    }
    // 如果 i__ 等于 nd 并且 *sqre 等于 0，则将 sqrei 设为 0，否则设为 1
    if (i__ == nd && *sqre == 0) {
        sqrei = 0;
    } else {
        sqrei = 1;
    }
    // 更新索引值
    idxqi += nlp1;
    vfi += nlp1;
    vli += nlp1;
    // 计算 nrp1
    nrp1 = nr + sqrei;
    // 如果 *icompq 等于 0，则执行以下步骤
    if (*icompq == 0) {
        // 设置矩阵 work[nwork1] 的值为 c_b29，其余部分为 c_b15
        slaset_("A", &nrp1, &nrp1, &c_b29, &c_b15, &work[nwork1], &smlszp);
        // 执行奇异值分解的算法
        slasdq_("U", &sqrei, &nr, &nrp1, &nru, &ncc, &d__[nrf], &e[nrf], &
            work[nwork1], &smlszp, &work[nwork2], &nr, &work[nwork2],
            &nr, &work[nwork2], info);
        // 计算 itemp 的值
        itemp = nwork1 + (nrp1 - 1) * smlszp;
        // 复制 work[nwork1] 的值到 work[vfi]
        scopy_(&nrp1, &work[nwork1], &c__1, &work[vfi], &c__1);
        // 复制 work[itemp] 的值到 work[vli]
        scopy_(&nrp1, &work[itemp], &c__1, &work[vli], &c__1);
    } else {
        // 设置矩阵 u[nrf + u_dim1] 的值为 c_b29，其余部分为 c_b15
        slaset_("A", &nr, &nr, &c_b29, &c_b15, &u[nrf + u_dim1], ldu);
        // 设置矩阵 vt[nrf + vt_dim1] 的值为 c_b29，其余部分为 c_b15
        slaset_("A", &nrp1, &nrp1, &c_b29, &c_b15, &vt[nrf + vt_dim1],
            ldu);
        // 执行奇异值分解的算法
        slasdq_("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d__[nrf], &e[nrf], &
            vt[nrf + vt_dim1], ldu, &u[nrf + u_dim1], ldu, &u[nrf +
            u_dim1], ldu, &work[nwork1], info);
        // 复制 vt[nrf + vt_dim1] 的值到 work[vfi]
        scopy_(&nrp1, &vt[nrf + vt_dim1], &c__1, &work[vfi], &c__1);
        // 复制 vt[nrf + nrp1 * vt_dim1] 的值到 work[vli]
        scopy_(&nrp1, &vt[nrf + nrp1 * vt_dim1], &c__1, &work[vli], &c__1);
    }
    // 如果 *info 不等于 0，则返回 0
    if (*info != 0) {
        return 0;
    }
    // 将 iwork[idxqi + j] 设置为 j，j 的范围是 1 到 nr
    i__2 = nr;
    for (j = 1; j <= i__2; ++j) {
        iwork[idxqi + j] = j;
/* L20: */
    }
/* L30: */
    }

/*     现在自底向上征服每个子问题。 */

    // 计算 j 的值为 2 的 nlvl 次方
    j = pow_ii(&c__2, &nlvl);
    // 从最底层 nlvl 开始向上征服每个子问题
    for (lvl = nlvl; lvl >= 1; --lvl) {
        // 计算 lvl2 的值为 (lvl << 1) - 1
        lvl2 = (lvl << 1) - 1;

/*
          在当前级别 LVL 上找到第一个节点 LF 和最后一个节点 LL。
*/

    // 如果 lvl 等于 1，则将 lf 和 ll 都设为 1
    if (lvl == 1) {
        lf = 1;
        ll = 1;
    } else {
        // 计算 lf 和 ll 的值
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);
        ll = (lf << 1) - 1;
    }
    // 计算 i__1 的值为 ll
    i__1 = ll;
    // 循环遍历 lf 到 i__1 之间的索引 i__
    for (i__ = lf; i__ <= i__1; ++i__) {
        // 计算当前索引的上一个索引 im1
        im1 = i__ - 1;
        // 从 inode 处获取 ic
        ic = iwork[inode + im1];
        // 从 ndiml 处获取 nl
        nl = iwork[ndiml + im1];
        // 从 ndimr 处获取 nr
        nr = iwork[ndimr + im1];
        // 计算 nlf 和 nrf
        nlf = ic - nl;
        nrf = ic + 1;
        
        // 如果 i__ 等于 ll，则将 sqrei 设置为 *sqre 的值，否则设为 1
        if (i__ == ll) {
            sqrei = *sqre;
        } else {
            sqrei = 1;
        }
        
        // 计算 vfi, vli, idxqi 的索引位置
        vfi = vf + nlf - 1;
        vli = vl + nlf - 1;
        idxqi = idxq + nlf - 1;
        
        // 获取 alpha 和 beta 的值
        alpha = d__[ic];
        beta = e[ic];
        
        // 根据 icompq 的值选择调用不同的函数 slasd6_
        if (*icompq == 0) {
            // icompq 为 0，调用 slasd6_ 函数
            slasd6_(icompq, &nl, &nr, &sqrei, &d__[nlf], &work[vfi], &
                work[vli], &alpha, &beta, &iwork[idxqi], &perm[
                perm_offset], &givptr[1], &givcol[givcol_offset],
                ldgcol, &givnum[givnum_offset], ldu, &poles[
                poles_offset], &difl[difl_offset], &difr[difr_offset],
                &z__[z_offset], &k[1], &c__[1], &s[1], &work[nwork1],
                &iwork[iwk], info);
        } else {
            // icompq 不为 0，调用 slasd6_ 函数，并更新相应的数组和索引
            --j;
            slasd6_(icompq, &nl, &nr, &sqrei, &d__[nlf], &work[vfi], &
                work[vli], &alpha, &beta, &iwork[idxqi], &perm[nlf +
                lvl * perm_dim1], &givptr[j], &givcol[nlf + lvl2 *
                givcol_dim1], ldgcol, &givnum[nlf + lvl2 *
                givnum_dim1], ldu, &poles[nlf + lvl2 * poles_dim1], &
                difl[nlf + lvl * difl_dim1], &difr[nlf + lvl2 *
                difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[j],
                &s[j], &work[nwork1], &iwork[iwk], info);
        }
        
        // 如果 info 不等于 0，则返回 0
        if (*info != 0) {
            return 0;
        }
    }
/* L40: */
    }
/* L50: */
    }

    return 0;

/*     End of SLASDA */

} /* slasda_ */

/* Subroutine */ int slasdq_(char *uplo, integer *sqre, integer *n, integer *
    ncvt, integer *nru, integer *ncc, real *d__, real *e, real *vt,
    integer *ldvt, real *u, integer *ldu, real *c__, integer *ldc, real *
    work, integer *info)
{
    /* System generated locals */
    integer c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2;

    /* Local variables */
    static integer i__, j;
    static real r__, cs, sn;
    static integer np1, isub;
    static real smin;
    static integer sqre1;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int slasr_(char *, char *, char *, integer *,
        integer *, real *, real *, real *, integer *);
    static integer iuplo;
    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *,
        integer *), xerbla_(char *, integer *), slartg_(real *,
        real *, real *, real *, real *);
    static logical rotate;
    extern /* Subroutine */ int sbdsqr_(char *, integer *, integer *, integer
        *, integer *, real *, real *, real *, integer *, real *, integer *
        , real *, integer *, real *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASDQ computes the singular value decomposition (SVD) of a real
    (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
    E, accumulating the transformations if desired. Letting B denote
    the input bidiagonal matrix, the algorithm computes orthogonal
    matrices Q and P such that B = Q * S * P' (P' denotes the transpose
    of P). The singular values S are overwritten on D.

    The input matrix U  is changed to U  * Q  if desired.
    The input matrix VT is changed to P' * VT if desired.
    The input matrix C  is changed to Q' * C  if desired.

    See "Computing  Small Singular Values of Bidiagonal Matrices With
    Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
    LAPACK Working Note #3, for a detailed description of the algorithm.

    Arguments
    =========

    UPLO  (input) CHARACTER*1
          On entry, UPLO specifies whether the input bidiagonal matrix
          is upper or lower bidiagonal, and wether it is square are
          not.
             UPLO = 'U' or 'u'   B is upper bidiagonal.
             UPLO = 'L' or 'l'   B is lower bidiagonal.

    SQRE  (input) INTEGER
          = 0: then the input matrix is N-by-N.
          = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
               (N+1)-by-N if UPLU = 'L'.

          The bidiagonal matrix has
          N = NL + NR + 1 rows and
          M = N + SQRE >= N columns.
*/
    N     (input) INTEGER
          On entry, N specifies the number of rows and columns
          in the matrix. N must be at least 0.
          
    NCVT  (input) INTEGER
          On entry, NCVT specifies the number of columns of
          the matrix VT. NCVT must be at least 0.
          
    NRU   (input) INTEGER
          On entry, NRU specifies the number of rows of
          the matrix U. NRU must be at least 0.
          
    NCC   (input) INTEGER
          On entry, NCC specifies the number of columns of
          the matrix C. NCC must be at least 0.
          
    D     (input/output) REAL array, dimension (N)
          On entry, D contains the diagonal entries of the
          bidiagonal matrix whose SVD is desired. On normal exit,
          D contains the singular values in ascending order.
          
    E     (input/output) REAL array.
          dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
          On entry, the entries of E contain the offdiagonal entries
          of the bidiagonal matrix whose SVD is desired. On normal
          exit, E will contain 0. If the algorithm does not converge,
          D and E will contain the diagonal and superdiagonal entries
          of a bidiagonal matrix orthogonally equivalent to the one
          given as input.
          
    VT    (input/output) REAL array, dimension (LDVT, NCVT)
          On entry, contains a matrix which on exit has been
          premultiplied by P', dimension N-by-NCVT if SQRE = 0
          and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
          
    LDVT  (input) INTEGER
          On entry, LDVT specifies the leading dimension of VT as
          declared in the calling (sub) program. LDVT must be at
          least 1. If NCVT is nonzero LDVT must also be at least N.
          
    U     (input/output) REAL array, dimension (LDU, N)
          On entry, contains a matrix which on exit has been
          postmultiplied by Q, dimension NRU-by-N if SQRE = 0
          and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
          
    LDU   (input) INTEGER
          On entry, LDU  specifies the leading dimension of U as
          declared in the calling (sub) program. LDU must be at
          least max( 1, NRU ) .
          
    C     (input/output) REAL array, dimension (LDC, NCC)
          On entry, contains an N-by-NCC matrix which on exit
          has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
          and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
          
    LDC   (input) INTEGER
          On entry, LDC  specifies the leading dimension of C as
          declared in the calling (sub) program. LDC must be at
          least 1. If NCC is nonzero, LDC must also be at least N.
          
    WORK  (workspace) REAL array, dimension (4*N)
          Workspace. Only referenced if one of NCVT, NRU, or NCC is
          nonzero, and if N is at least 2.
    # INFO (output) INTEGER
    #       On exit, a value of 0 indicates a successful exit.
    #       If INFO < 0, argument number -INFO is illegal.
    #       If INFO > 0, the algorithm did not converge, and INFO
    #       specifies how many superdiagonals did not converge.

    # Further Details
    # ===============

    # Based on contributions by
    #    Ming Gu and Huan Ren, Computer Science Division, University of
    #    California at Berkeley, USA

    # =====================================================================

    # Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --e;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    iuplo = 0;
    if (lsame_(uplo, "U")) {
        iuplo = 1;
    }
    if (lsame_(uplo, "L")) {
        iuplo = 2;
    }
    if (iuplo == 0) {
        *info = -1;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*ncvt < 0) {
        *info = -4;
    } else if (*nru < 0) {
        *info = -5;
    } else if (*ncc < 0) {
        *info = -6;
    } else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < max(1,*n)) {
        *info = -10;
    } else if (*ldu < max(1,*nru)) {
        *info = -12;
    } else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < max(1,*n)) {
        *info = -14;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLASDQ", &i__1);
        return 0;
    }
    if (*n == 0) {
        return 0;
    }

/*     ROTATE is true if any singular vectors desired, false otherwise */

    rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;
    np1 = *n + 1;
    sqre1 = *sqre;

/*
       If matrix non-square upper bidiagonal, rotate to be lower
       bidiagonal.  The rotations are on the right.
*/

    if (iuplo == 1 && sqre1 == 1) {
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {
            slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);
            d__[i__] = r__;
            e[i__] = sn * d__[i__ + 1];
            d__[i__ + 1] = cs * d__[i__ + 1];
            if (rotate) {
                work[i__] = cs;
                work[*n + i__] = sn;
            }
/* L10: */
        }
        slartg_(&d__[*n], &e[*n], &cs, &sn, &r__);
        d__[*n] = r__;
        e[*n] = 0.f;
        if (rotate) {
            work[*n] = cs;
            work[*n + *n] = sn;
        }
        iuplo = 2;
        sqre1 = 0;

/*        Update singular vectors if desired. */

        if (*ncvt > 0) {
            slasr_("L", "V", "F", &np1, ncvt, &work[1], &work[np1], &vt[
                vt_offset], ldvt);
        }
    }

/*
       If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left.
*/

    if (iuplo == 2) {
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {
            slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);
            d__[i__] = r__;
            e[i__] = sn * d__[i__ + 1];
            d__[i__ + 1] = cs * d__[i__ + 1];
            if (rotate) {
                work[i__] = cs;
                work[*n + i__] = sn;
            }
/* L20: */
        }

/*
          If matrix (N+1)-by-N lower bidiagonal, one additional
          rotation is needed.
*/

        if (sqre1 == 1) {
            slartg_(&d__[*n], &e[*n], &cs, &sn, &r__);
            d__[*n] = r__;
            if (rotate) {
                work[*n] = cs;
                work[*n + *n] = sn;
            }
        }

/*        Update singular vectors if desired. */

        if (*nru > 0) {
            slasr_("R", "V", "F", nru, &np1, &work[1], &work[np1], &u[
                u_offset], ldu);
        }
        if (*ncc > 0) {
            slasr_("R", "V", "F", ncc, &np1, &work[1], &work[np1], &c__[
                c_offset], ldc);
        }
    }
    # 如果输入的 nru 大于 0，则执行下面的条件语句块
    if (*nru > 0) {
        # 如果 sqre1 等于 0，则执行以下操作
        if (sqre1 == 0) {
            # 对右侧的向量应用 slasr 函数，作用是将矩阵的右边部分转化为上三角形式
            slasr_("R", "V", "F", nru, n, &work[1], &work[np1], &u[
                u_offset], ldu);
        } else {
            # 对右侧的向量应用 slasr 函数，作用是将矩阵的右边部分转化为上三角形式
            slasr_("R", "V", "F", nru, &np1, &work[1], &work[np1], &u[
                u_offset], ldu);
        }
    }
    # 如果输入的 ncc 大于 0，则执行下面的条件语句块
    if (*ncc > 0) {
        # 如果 sqre1 等于 0，则执行以下操作
        if (sqre1 == 0) {
            # 对左侧的向量应用 slasr 函数，作用是将矩阵的左边部分转化为上三角形式
            slasr_("L", "V", "F", n, ncc, &work[1], &work[np1], &c__[
                c_offset], ldc);
        } else {
            # 对左侧的向量应用 slasr 函数，作用是将矩阵的左边部分转化为上三角形式
            slasr_("L", "V", "F", &np1, ncc, &work[1], &work[np1], &c__[
                c_offset], ldc);
        }
    }
/*
       Call SBDSQR to compute the SVD of the reduced real
       N-by-N upper bidiagonal matrix.
*/
sbdsqr_("U", n, ncvt, nru, ncc, &d__[1], &e[1], &vt[vt_offset], ldvt, &u[
    u_offset], ldu, &c__[c_offset], ldc, &work[1], info);

/*
       Sort the singular values into ascending order (insertion sort on
       singular values, but only one transposition per singular vector)
*/
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {

    /* Scan for smallest D(I). */
    isub = i__;
    smin = d__[i__];
    i__2 = *n;
    for (j = i__ + 1; j <= i__2; ++j) {
        if (d__[j] < smin) {
            isub = j;
            smin = d__[j];
        }
        /* L30: */
    }
    if (isub != i__) {

        /* Swap singular values and vectors. */
        d__[isub] = d__[i__];
        d__[i__] = smin;
        if (*ncvt > 0) {
            sswap_(ncvt, &vt[isub + vt_dim1], ldvt, &vt[i__ + vt_dim1],
                ldvt);
        }
        if (*nru > 0) {
            sswap_(nru, &u[isub * u_dim1 + 1], &c__1, &u[i__ * u_dim1 + 1]
                , &c__1);
        }
        if (*ncc > 0) {
            sswap_(ncc, &c__[isub + c_dim1], ldc, &c__[i__ + c_dim1], ldc);
        }
    }
    /* L40: */
}

return 0;

/* End of SLASDQ */
} /* slasdq_ */

/* Subroutine */ int slasdt_(integer *n, integer *lvl, integer *nd, integer *
    inode, integer *ndiml, integer *ndimr, integer *msub)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, il, ir, maxn;
    static real temp;
    static integer nlvl, llst, ncrnt;

    /*
       -- LAPACK auxiliary routine (version 3.2.2) --
       -- LAPACK is a software package provided by Univ. of Tennessee,    --
       -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

       Purpose
       =======

       SLASDT creates a tree of subproblems for bidiagonal divide and
       conquer.

       Arguments
       =========

        N      (input) INTEGER
               On entry, the number of diagonal elements of the
               bidiagonal matrix.

        LVL    (output) INTEGER
               On exit, the number of levels on the computation tree.

        ND     (output) INTEGER
               On exit, the number of nodes on the tree.

        INODE  (output) INTEGER array, dimension ( N )
               On exit, centers of subproblems.

        NDIML  (output) INTEGER array, dimension ( N )
               On exit, row dimensions of left children.

        NDIMR  (output) INTEGER array, dimension ( N )
               On exit, row dimensions of right children.

        MSUB   (input) INTEGER
               On entry, the maximum row dimension each subproblem at the
               bottom of the tree can be of.

       Further Details
       ===============

       Based on contributions by
          Ming Gu and Huan Ren, Computer Science Division, University of
          California at Berkeley, USA

       =====================================================================
    */

    /*
       Find the number of levels on the tree.
    */
    /* Parameter adjustments */
    --ndimr;
    --ndiml;
    --inode;

    /* Function Body */
    maxn = max(1,*n);  // 计算最大值 maxn，取 1 和 *n 中的较大值
    temp = log((real) maxn / (real) (*msub + 1)) / log(2.f);  // 计算 log(maxn / (*msub + 1)) 的结果，并以 2 为底求对数
    *lvl = (integer) temp + 1;  // 将上一步计算的结果加1后赋给 *lvl

    i__ = *n / 2;  // 计算 *n 的一半并赋给 i__
    inode[1] = i__ + 1;  // 设置 inode 数组的第一个元素为 i__ + 1
    ndiml[1] = i__;  // 设置 ndiml 数组的第一个元素为 i__
    ndimr[1] = *n - i__ - 1;  // 计算 *n - i__ - 1 后赋给 ndimr 数组的第一个元素
    il = 0;  // 初始化 il 为 0
    ir = 1;  // 初始化 ir 为 1
    llst = 1;  // 初始化 llst 为 1
    i__1 = *lvl - 1;  // 计算 *lvl - 1 并赋给 i__1
    for (nlvl = 1; nlvl <= i__1; ++nlvl) {  // 循环 nlvl 从 1 到 *lvl - 1

/*
          Constructing the tree at (NLVL+1)-st level. The number of
          nodes created on this level is LLST * 2.
*/

    i__2 = llst - 1;  // 计算 llst - 1 并赋给 i__2
    for (i__ = 0; i__ <= i__2; ++i__) {  // 循环 i__ 从 0 到 llst - 1
        il += 2;  // il 增加 2
        ir += 2;  // ir 增加 2
        ncrnt = llst + i__;  // 计算 ncrnt 并赋给 llst + i__
        ndiml[il] = ndiml[ncrnt] / 2;  // 计算 ndiml[il] 并赋值为 ndiml[ncrnt] 的一半
        ndimr[il] = ndiml[ncrnt] - ndiml[il] - 1;  // 计算 ndimr[il] 并赋值为 ndiml[ncrnt] 减去 ndiml[il] 再减 1
        inode[il] = inode[ncrnt] - ndimr[il] - 1;  // 计算 inode[il] 并赋值为 inode[ncrnt] 减去 ndimr[il] 再减 1
        ndiml[ir] = ndimr[ncrnt] / 2;  // 计算 ndiml[ir] 并赋值为 ndimr[ncrnt] 的一半
        ndimr[ir] = ndimr[ncrnt] - ndiml[ir] - 1;  // 计算 ndimr[ir] 并赋值为 ndimr[ncrnt] 减去 ndiml[ir] 再减 1
        inode[ir] = inode[ncrnt] + ndiml[ir] + 1;  // 计算 inode[ir] 并赋值为 inode[ncrnt] 加上 ndiml[ir] 再加 1
/* L10: */
    }
    llst <<= 1;  // llst 左移一位，相当于乘以 2
/* L20: */
    }
    *nd = (llst << 1) - 1;  // 计算 *nd 并赋值为 (llst 左移一位再减 1)

    return 0;

/*     End of SLASDT */

} /* slasdt_ */

/* Subroutine */ int slaset_(char *uplo, integer *m, integer *n, real *alpha,
    real *beta, real *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    SLASET initializes an m-by-n matrix A to BETA on the diagonal and
    ALPHA on the offdiagonals.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set; the strictly lower
                        triangular part of A is not changed.
            = 'L':      Lower triangular part is set; the strictly upper
                        triangular part of A is not changed.
            Otherwise:  All of the matrix A is set.

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    ALPHA   (input) REAL
            The constant to which the offdiagonal elements are to be set.

    BETA    (input) REAL
            The constant to which the diagonal elements are to be set.

    A       (input/output) REAL array, dimension (LDA,N)
            On exit, the leading m-by-n submatrix of A is set as follows:

            if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
            if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
            otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,

            and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    if (lsame_(uplo, "U")) {

/*
          Set the strictly upper triangular or trapezoidal part of the
          array to ALPHA.
*/

设置数组的严格上三角或梯形部分为 ALPHA。


    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
/* Computing MIN */
        i__3 = j - 1;
        i__2 = min(i__3,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] = *alpha;
/* L10: */
        }
/* L20: */
    }

遍历设置数组的严格上三角或梯形部分为 ALPHA。


    } else if (lsame_(uplo, "L")) {

/*
          Set the strictly lower triangular or trapezoidal part of the
          array to ALPHA.
*/

设置数组的严格下三角或梯形部分为 ALPHA。


    i__1 = min(*m,*n);
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] = *alpha;
/* L30: */
        }
/* L40: */
    }

遍历设置数组的严格下三角或梯形部分为 ALPHA。


    } else {

/*        Set the leading m-by-n submatrix to ALPHA. */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] = *alpha;
/* L50: */
        }
/* L60: */
    }
    }

设置数组的主子矩阵大小为 m-by-n 的部分为 ALPHA。


/*     Set the first min(M,N) diagonal elements to BETA. */

    i__1 = min(*m,*n);
    for (i__ = 1; i__ <= i__1; ++i__) {
    a[i__ + i__ * a_dim1] = *beta;
/* L70: */
    }

设置数组的对角线上的前 min(M,N) 个元素为 BETA。


    return 0;

/*     End of SLASET */

} /* slaset_ */

SLASET 的结束标记。


/* Subroutine */ int slasq1_(integer *n, real *d__, real *e, real *work,
    integer *info)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1, r__2, r__3;

    /* Local variables */
    static integer i__;
    static real eps;
    extern /* Subroutine */ int slas2_(real *, real *, real *, real *, real *)
        ;
    static real scale;
    static integer iinfo;
    static real sigmn, sigmx;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), slasq2_(integer *, real *, integer *);
    extern doublereal slamch_(char *);
    static real safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
        char *, integer *, integer *, real *, real *, integer *, integer *
        , real *, integer *, integer *), slasrt_(char *, integer *
        , real *, integer *);

/*
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*/

SLASQ1 的目的和 LAPACK 贡献信息。


    Purpose
    =======

    SLASQ1 computes the singular values of a real N-by-N bidiagonal
    matrix with diagonal D and off-diagonal E. The singular values
    are computed to high relative accuracy, in the absence of

SLASQ1 计算一个实的 N-by-N 的双对角矩阵的奇异值，其中有对角线 D 和非对角线 E。在没有其他条件下，这些奇异值被计算为高相对精度。

This completes the commented section of the provided Fortran code.
    # 该函数实现了求解特定形式矩阵的奇异值分解（SVD）中的一部分算法，处理了正常化、下溢和上溢的问题。
    # 算法首次在 K. V. Fernando 和 B. N. Parlett 的论文中提出，详见《Accurate singular values and differential qd algorithms》（1994年，Numer. Math., Vol-67, No. 2, pp. 191-230）。
    # 本实现的描述见 LAPACK Working Note 中的《An implementation of the dqds Algorithm (Positive Case)》。

    # Arguments
    # =========

    # N     (input) INTEGER
    #       矩阵的行数和列数，N >= 0。

    # D     (input/output) REAL array, dimension (N)
    #       输入时，D 包含所需进行奇异值分解的双对角矩阵的对角线元素。正常退出时，D 包含按降序排列的奇异值。

    # E     (input/output) REAL array, dimension (N)
    #       输入时，E(1:N-1) 包含所需进行奇异值分解的双对角矩阵的非对角线元素。退出时，E 被重写。

    # WORK  (workspace) REAL array, dimension (4*N)
    #       工作空间数组，用于存储临时数据。

    # INFO  (output) INTEGER
    #       = 0: 成功退出
    #       < 0: 若 INFO = -i，则第 i 个参数具有非法值
    #       > 0: 算法执行失败
    #            = 1，E 中出现正值标志了一次分裂
    #            = 2，Z 的当前块在内部循环中没有在30*N次迭代后对角化
    #            = 3，外部循环的终止条件未满足（程序创建了超过 N 个未减少的块）
    # =====================================================================
    /* Parameter adjustments */
    /* 参数调整 */
    --work;
    --e;
    --d__;

    /* Function Body */
    /* 函数主体 */
    *info = 0;
    /* 初始化 info 为 0 */
    if (*n < 0) {
    /* 如果输入的 n 小于 0 */
    *info = -2;
    /* 设置 info 为 -2 */
    i__1 = -(*info);
    xerbla_("SLASQ1", &i__1);
    /* 调用错误处理函数 xerbla_，报告错误 */
    return 0;
    /* 返回 */
    } else if (*n == 0) {
    /* 如果 n 等于 0 */
    return 0;
    /* 直接返回 */
    } else if (*n == 1) {
    /* 如果 n 等于 1 */
    d__[1] = dabs(d__[1]);
    /* 取第一个特征值的绝对值 */
    return 0;
    /* 返回 */
    } else if (*n == 2) {
    /* 如果 n 等于 2 */
    slas2_(&d__[1], &e[1], &d__[2], &sigmn, &sigmx);
    /* 调用子程序 slas2_ 计算特征值 */
    d__[1] = sigmx;
    d__[2] = sigmn;
    /* 更新特征值数组 */
    return 0;
    /* 返回 */
    }

/*     Estimate the largest singular value. */
/*     估计最大奇异值 */

    sigmx = 0.f;
    /* 初始化最大奇异值为 0 */
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 循环遍历 */
    d__[i__] = (r__1 = d__[i__], dabs(r__1));
    /* 取特征值数组的绝对值 */
/* Computing MAX */
    r__2 = sigmx, r__3 = (r__1 = e[i__], dabs(r__1));
    sigmx = dmax(r__2,r__3);
    /* 更新最大奇异值 */
/* L10: */
    }
    d__[*n] = (r__1 = d__[*n], dabs(r__1));
    /* 取最后一个特征值的绝对值 */

/*     Early return if SIGMX is zero (matrix is already diagonal). */
/*     如果 SIGMX 等于零，则提前返回（矩阵已经是对角的）。 */

    if (sigmx == 0.f) {
    /* 如果最大奇异值为 0 */
    slasrt_("D", n, &d__[1], &iinfo);
    /* 调用排序函数 slasrt_ 对特征值数组排序 */
    return 0;
    /* 返回 */
    }

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 循环遍历 */
/* Computing MAX */
    r__1 = sigmx, r__2 = d__[i__];
    sigmx = dmax(r__1,r__2);
    /* 更新最大奇异值 */
/* L20: */
    }

/*
       Copy D and E into WORK (in the Z format) and scale (squaring the
       input data makes scaling by a power of the radix pointless).
*/
/* 
       将 D 和 E 复制到 WORK 中（以 Z 格式），并缩放（将输入数据平方化使得按基数的幂进行缩放没有意义）。
*/

    eps = slamch_("Precision");
    /* 获取精度 */
    safmin = slamch_("Safe minimum");
    /* 获取安全最小值 */
    scale = sqrt(eps / safmin);
    /* 计算缩放因子 */
    scopy_(n, &d__[1], &c__1, &work[1], &c__2);
    /* 复制特征值数组到工作数组中 */
    i__1 = *n - 1;
    scopy_(&i__1, &e[1], &c__1, &work[2], &c__2);
    /* 复制次对角元素到工作数组中 */
    i__1 = (*n << 1) - 1;
    i__2 = (*n << 1) - 1;
    slascl_("G", &c__0, &c__0, &sigmx, &scale, &i__1, &c__1, &work[1], &i__2,
        &iinfo);
    /* 调用缩放函数 slascl_ 对工作数组进行缩放 */

/*     Compute the q's and e's. */
/*     计算 q 和 e。 */

    i__1 = (*n << 1) - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    /* 循环遍历 */
/* Computing 2nd power */
    r__1 = work[i__];
    work[i__] = r__1 * r__1;
    /* 计算平方 */
/* L30: */
    }
    work[*n * 2] = 0.f;

    slasq2_(n, &work[1], info);
    /* 调用子程序 slasq2_ 处理工作数组 */

    if (*info == 0) {
    /* 如果返回信息为 0 */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        /* 循环遍历 */
        d__[i__] = sqrt(work[i__]);
        /* 取平方根得到特征值 */
/* L40: */
    }
    slascl_("G", &c__0, &c__0, &scale, &sigmx, n, &c__1, &d__[1], n, &
        iinfo);
    /* 再次调用缩放函数对特征值进行缩放 */
    }

    return 0;

/*     End of SLASQ1 */
/*     SLASQ1 结束 */

} /* slasq1_ */
/* slasq1_ 子程序结束 */

/* Subroutine */ int slasq2_(integer *n, real *z__, integer *info)
{
    /* System generated locals */
    /* 系统生成的本地变量 */
    integer i__1, i__2, i__3;
    real r__1, r__2;

    /* Local variables */
    /* 本地变量 */
    static real d__, e, g;
    static integer k;
    static real s, t;
    static integer i0, i4, n0;
    static real dn;
    static integer pp;
    static real dn1, dn2, dee, eps, tau, tol;
    static integer ipn4;
    static real tol2;
    static logical ieee;
    static integer nbig;
    static real dmin__, emin, emax;
    static integer kmin, ndiv, iter;
    static real qmin, temp, qmax, zmax;
    static integer splt;
    static real dmin1, dmin2;
    static integer nfail;
    static real desig, trace, sigma;
    static integer iinfo, ttype;
    # 声明外部子程序 slasq3_
    extern /* Subroutine */ int slasq3_(integer *, integer *, real *, integer
        *, real *, real *, real *, real *, integer *, integer *, integer *
        , logical *, integer *, real *, real *, real *, real *, real *,
        real *, real *);

    # 声明静态实数变量 deemin
    static real deemin;

    # 声明外部函数 slamch_
    extern doublereal slamch_(char *);

    # 声明静态整数变量 iwhila, iwhilb
    static integer iwhila, iwhilb;

    # 声明静态实数变量 oldemn, safmin
    static real oldemn, safmin;

    # 声明外部子程序 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明外部子程序 slasrt_
    extern /* Subroutine */ int slasrt_(
        char *, integer *, real *, integer *);
"""
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    SLASQ2 computes all the eigenvalues of the symmetric positive
    definite tridiagonal matrix associated with the qd array Z to high
    relative accuracy are computed to high relative accuracy, in the
    absence of denormalization, underflow and overflow.

    To see the relation of Z to the tridiagonal matrix, let L be a
    unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
    let U be an upper bidiagonal matrix with 1's above and diagonal
    Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
    symmetric tridiagonal to which it is similar.

    Note : SLASQ2 defines a logical variable, IEEE, which is true
    on machines which follow ieee-754 floating-point standard in their
    handling of infinities and NaNs, and false otherwise. This variable
    is passed to SLASQ3.

    Arguments
    =========

    N     (input) INTEGER
          The number of rows and columns in the matrix. N >= 0.

    Z     (input/output) REAL array, dimension ( 4*N )
          On entry Z holds the qd array. On exit, entries 1 to N hold
          the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
          trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
          N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
          holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
          shifts that failed.

    INFO  (output) INTEGER
          = 0: successful exit
          < 0: if the i-th argument is a scalar and had an illegal
               value, then INFO = -i, if the i-th argument is an
               array and the j-entry had an illegal value, then
               INFO = -(i*100+j)
          > 0: the algorithm failed
                = 1, a split was marked by a positive value in E
                = 2, current block of Z not diagonalized after 30*N
                     iterations (in inner while loop)
                = 3, termination criterion of outer while loop not met
                     (program created more than N unreduced blocks)

    Further Details
    ===============
    Local Variables: I0:N0 defines a current unreduced segment of Z.
    The shifts are accumulated in SIGMA. Iteration count is in ITER.
    Ping-pong is controlled by PP (alternates between 0 and 1).

    =====================================================================


       Test the input arguments.
       (in case SLASQ2 is not called by SLASQ1)
"""
    /* 参数调整 */
    --z__;

    /* 函数主体 */
    *info = 0;
    // 获取机器精度，并赋值给 eps
    eps = slamch_("Precision");
    // 获取安全最小值，并赋值给 safmin
    safmin = slamch_("Safe minimum");
    // 计算容差值，为机器精度的 100 倍
    tol = eps * 100.f;
/* Computing 2nd power */
    r__1 = tol;
    tol2 = r__1 * r__1;

    if (*n < 0) {
    *info = -1;
    xerbla_("SLASQ2", &c__1);
    return 0;
    } else if (*n == 0) {
    return 0;
    } else if (*n == 1) {

/*        1-by-1 case. */

    if (z__[1] < 0.f) {
        *info = -201;
        xerbla_("SLASQ2", &c__2);
    }
    return 0;
    } else if (*n == 2) {

/*        2-by-2 case. */

    if (z__[2] < 0.f || z__[3] < 0.f) {
        *info = -2;
        xerbla_("SLASQ2", &c__2);
        return 0;
    } else if (z__[3] > z__[1]) {
        d__ = z__[3];
        z__[3] = z__[1];
        z__[1] = d__;
    }
    z__[5] = z__[1] + z__[2] + z__[3];
    if (z__[2] > z__[3] * tol2) {
        t = (z__[1] - z__[3] + z__[2]) * .5f;
        s = z__[3] * (z__[2] / t);
        if (s <= t) {
        s = z__[3] * (z__[2] / (t * (sqrt(s / t + 1.f) + 1.f)));
        } else {
        s = z__[3] * (z__[2] / (t + sqrt(t) * sqrt(t + s)));
        }
        t = z__[1] + (s + z__[2]);
        z__[3] *= z__[1] / t;
        z__[1] = t;
    }
    z__[2] = z__[3];
    z__[6] = z__[2] + z__[1];
    return 0;
    }

/*     Check for negative data and compute sums of q's and e's. */

    z__[*n * 2] = 0.f;
    emin = z__[2];
    qmax = 0.f;
    zmax = 0.f;
    d__ = 0.f;
    e = 0.f;

    i__1 = *n - 1 << 1;
    for (k = 1; k <= i__1; k += 2) {
    if (z__[k] < 0.f) {
        *info = -(k + 200);
        xerbla_("SLASQ2", &c__2);
        return 0;
    } else if (z__[k + 1] < 0.f) {
        *info = -(k + 201);
        xerbla_("SLASQ2", &c__2);
        return 0;
    }
    d__ += z__[k];
    e += z__[k + 1];
/* Computing MAX */
    r__1 = qmax, r__2 = z__[k];
    qmax = dmax(r__1,r__2);
/* Computing MIN */
    r__1 = emin, r__2 = z__[k + 1];
    emin = dmin(r__1,r__2);
/* Computing MAX */
    r__1 = max(qmax,zmax), r__2 = z__[k + 1];
    zmax = dmax(r__1,r__2);
/* L10: */
    }
    if (z__[(*n << 1) - 1] < 0.f) {
    *info = -((*n << 1) + 199);
    xerbla_("SLASQ2", &c__2);
    return 0;
    }
    d__ += z__[(*n << 1) - 1];
/* Computing MAX */
    r__1 = qmax, r__2 = z__[(*n << 1) - 1];
    qmax = dmax(r__1,r__2);
    zmax = dmax(qmax,zmax);

/*     Check for diagonality. */

    if (e == 0.f) {
    i__1 = *n;
    for (k = 2; k <= i__1; ++k) {
        z__[k] = z__[(k << 1) - 1];
/* L20: */
    }
    slasrt_("D", n, &z__[1], &iinfo);
    z__[(*n << 1) - 1] = d__;
    return 0;
    }

    trace = d__ + e;

/*     Check for zero data. */

    if (trace == 0.f) {
    z__[(*n << 1) - 1] = 0.f;
    return 0;
    }

/*
       Check whether the machine is IEEE conformable.

       IEEE = ILAENV( 10, 'SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.
      $       ILAENV( 11, 'SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1

       [11/15/2008] The case IEEE=.TRUE. has a problem in single precision with
       some the test matrices of type 16. The double precision code is fine.
*/

    ieee = FALSE_;

/*     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...). */
    # 循环，从数组中的倒数第二个元素开始，每次递减2
    for (k = *n << 1; k >= 2; k += -2) {
        # 将数组中索引为 k*2 的元素设为 0.0
        z__[k * 2] = 0.f;
        # 将数组中索引为 (k<<1)-1 的元素设为与索引为 k 的元素相同
        z__[(k << 1) - 1] = z__[k];
        # 将数组中索引为 (k<<1)-2 的元素设为 0.0
        z__[(k << 1) - 2] = 0.f;
        # 将数组中索引为 (k<<1)-3 的元素设为与索引为 k-1 的元素相同
        z__[(k << 1) - 3] = z__[k - 1];
/* L30: */
    }

    // 初始化索引和大小
    i0 = 1;
    n0 = *n;

/*     Reverse the qd-array, if warranted. */

    // 如果需要，反转qd数组
    if (z__[(i0 << 2) - 3] * 1.5f < z__[(n0 << 2) - 3]) {
    ipn4 = i0 + n0 << 2;
    i__1 = i0 + n0 - 1 << 1;
    for (i4 = i0 << 2; i4 <= i__1; i4 += 4) {
        temp = z__[i4 - 3];
        z__[i4 - 3] = z__[ipn4 - i4 - 3];
        z__[ipn4 - i4 - 3] = temp;
        temp = z__[i4 - 1];
        z__[i4 - 1] = z__[ipn4 - i4 - 5];
        z__[ipn4 - i4 - 5] = temp;
/* L40: */
    }
    }

/*     Initial split checking via dqd and Li's test. */

    // 初始化通过dqd和Li's测试进行的分裂检查
    pp = 0;

    for (k = 1; k <= 2; ++k) {

    d__ = z__[(n0 << 2) + pp - 3];
    i__1 = (i0 << 2) + pp;
    for (i4 = (n0 - 1 << 2) + pp; i4 >= i__1; i4 += -4) {
        if (z__[i4 - 1] <= tol2 * d__) {
        z__[i4 - 1] = -0.f;
        d__ = z__[i4 - 3];
        } else {
        d__ = z__[i4 - 3] * (d__ / (d__ + z__[i4 - 1]));
        }
/* L50: */
    }

/*        dqd maps Z to ZZ plus Li's test. */

    // dqd将Z映射到ZZ再加上Li的测试
    emin = z__[(i0 << 2) + pp + 1];
    d__ = z__[(i0 << 2) + pp - 3];
    i__1 = (n0 - 1 << 2) + pp;
    for (i4 = (i0 << 2) + pp; i4 <= i__1; i4 += 4) {
        z__[i4 - (pp << 1) - 2] = d__ + z__[i4 - 1];
        if (z__[i4 - 1] <= tol2 * d__) {
        z__[i4 - 1] = -0.f;
        z__[i4 - (pp << 1) - 2] = d__;
        z__[i4 - (pp << 1)] = 0.f;
        d__ = z__[i4 + 1];
        } else if (safmin * z__[i4 + 1] < z__[i4 - (pp << 1) - 2] &&
            safmin * z__[i4 - (pp << 1) - 2] < z__[i4 + 1]) {
        temp = z__[i4 + 1] / z__[i4 - (pp << 1) - 2];
        z__[i4 - (pp << 1)] = z__[i4 - 1] * temp;
        d__ *= temp;
        } else {
        z__[i4 - (pp << 1)] = z__[i4 + 1] * (z__[i4 - 1] / z__[i4 - (
            pp << 1) - 2]);
        d__ = z__[i4 + 1] * (d__ / z__[i4 - (pp << 1) - 2]);
        }
/* Computing MIN */
        r__1 = emin, r__2 = z__[i4 - (pp << 1)];
        emin = dmin(r__1,r__2);
/* L60: */
    }
    z__[(n0 << 2) - pp - 2] = d__;

/*        Now find qmax. */

    // 现在找到qmax
    qmax = z__[(i0 << 2) - pp - 2];
    i__1 = (n0 << 2) - pp - 2;
    for (i4 = (i0 << 2) - pp + 2; i4 <= i__1; i4 += 4) {
/* Computing MAX */
        r__1 = qmax, r__2 = z__[i4];
        qmax = dmax(r__1,r__2);
/* L70: */
    }

/*        Prepare for the next iteration on K. */

    // 为下一个K的迭代做准备
    pp = 1 - pp;
/* L80: */
    }

/*     Initialise variables to pass to SLASQ3. */

    // 初始化传递给SLASQ3的变量
    ttype = 0;
    dmin1 = 0.f;
    dmin2 = 0.f;
    dn = 0.f;
    dn1 = 0.f;
    dn2 = 0.f;
    g = 0.f;
    tau = 0.f;

    iter = 2;
    nfail = 0;
    ndiv = n0 - i0 << 1;

    i__1 = *n + 1;
    for (iwhila = 1; iwhila <= i__1; ++iwhila) {
    if (n0 < 1) {
        goto L170;
    }

/*
          While array unfinished do

          E(N0) holds the value of SIGMA when submatrix in I0:N0
          splits from the rest of the array, but is negated.
*/

    // 当数组未完成时
    desig = 0.f;
    if (n0 == *n) {
        sigma = 0.f;
    } else {
        sigma = -z__[(n0 << 2) - 1];
    }
    if (sigma < 0.f) {
        *info = 1;
        return 0;
    }
/*
          Find last unreduced submatrix's top index I0, find QMAX and
          EMIN. Find Gershgorin-type bound if Q's much greater than E's.
*/

// 初始化 emax 为 0
emax = 0.f;
// 如果 n0 大于 i0，则计算 emin 为 z__[(n0 << 2) - 5] 的绝对值，否则设为 0
if (n0 > i0) {
    emin = (r__1 = z__[(n0 << 2) - 5], dabs(r__1));
} else {
    emin = 0.f;
}
// 初始化 qmin 为 z__[(n0 << 2) - 3]，并将 qmax 初始化为 qmin
qmin = z__[(n0 << 2) - 3];
qmax = qmin;
// 从最后一个 4x4 子矩阵向前遍历
for (i4 = n0 << 2; i4 >= 8; i4 += -4) {
    // 如果 z__[i4 - 5] <= 0，则跳转至 L100
    if (z__[i4 - 5] <= 0.f) {
        goto L100;
    }
    // 如果 qmin 大于等于 emax 的 4 倍，则更新 qmin
    r__1 = qmin, r__2 = z__[i4 - 3];
    qmin = dmin(r__1,r__2);
    // 更新 emax
    r__1 = emax, r__2 = z__[i4 - 5];
    emax = dmax(r__1,r__2);
    // 更新 qmax
    r__1 = qmax, r__2 = z__[i4 - 7] + z__[i4 - 5];
    qmax = dmax(r__1,r__2);
    // 更新 emin
    r__1 = emin, r__2 = z__[i4 - 5];
    emin = dmin(r__1,r__2);
    // 继续下一个循环
    // L90:
}

i4 = 4;

L100:
// 更新 i0 为 i4 / 4
i0 = i4 / 4;
// 初始化 pp 为 0
pp = 0;

// 如果 n0 - i0 大于 1，则进入下一步操作
if (n0 - i0 > 1) {
    // 初始化 dee 为 z__[(i0 << 2) - 3]
    dee = z__[(i0 << 2) - 3];
    // 初始化 deemin 为 dee，初始化 kmin 为 i0
    deemin = dee;
    kmin = i0;
    // 从 (i0 << 2) + 1 开始向后遍历到 (n0 << 2) - 3
    i__2 = (n0 << 2) - 3;
    for (i4 = (i0 << 2) + 1; i4 <= i__2; i4 += 4) {
        // 更新 dee
        dee = z__[i4] * (dee / (dee + z__[i4 - 2]));
        // 如果 dee 小于等于 deemin，则更新 deemin 和 kmin
        if (dee <= deemin) {
            deemin = dee;
            kmin = (i4 + 3) / 4;
        }
        // L110:
    }
    // 如果 kmin - i0 的两倍小于 n0 - kmin，并且 deemin 小于等于 z__[(n0 << 2) - 3] 的一半，则执行以下操作
    if (kmin - i0 << 1 < n0 - kmin && deemin <= z__[(n0 << 2) - 3] *
        .5f) {
        // 计算 ipn4
        ipn4 = i0 + n0 << 2;
        // 更新 pp 为 2
        pp = 2;
        // 设置 i__2 为 i0 + n0 - 1 的两倍
        i__2 = i0 + n0 - 1 << 1;
        // 从 i0 << 2 开始向后遍历到 i__2，执行数组 z__ 的翻转操作
        for (i4 = i0 << 2; i4 <= i__2; i4 += 4) {
            temp = z__[i4 - 3];
            z__[i4 - 3] = z__[ipn4 - i4 - 3];
            z__[ipn4 - i4 - 3] = temp;
            temp = z__[i4 - 2];
            z__[i4 - 2] = z__[ipn4 - i4 - 2];
            z__[ipn4 - i4 - 2] = temp;
            temp = z__[i4 - 1];
            z__[i4 - 1] = z__[ipn4 - i4 - 5];
            z__[ipn4 - i4 - 5] = temp;
            temp = z__[i4];
            z__[i4] = z__[ipn4 - i4 - 4];
            z__[ipn4 - i4 - 4] = temp;
            // L120:
        }
    }
}

/*
          Put -(initial shift) into DMIN.

   Computing MAX
*/
// 计算 dmin__ 为 -max(0, qmin - sqrt(qmin) * 2 * sqrt(emax))
r__1 = 0.f, r__2 = qmin - sqrt(qmin) * 2.f * sqrt(emax);
dmin__ = -dmax(r__1,r__2);

/*
          Now I0:N0 is unreduced.
          PP = 0 for ping, PP = 1 for pong.
          PP = 2 indicates that flipping was applied to the Z array and
                 and that the tests for deflation upon entry in SLASQ3
                 should not be performed.
*/

// 计算 nbig
nbig = (n0 - i0 + 1) * 30;
// 从 1 到 nbig 进行循环
i__2 = nbig;
for (iwhilb = 1; iwhilb <= i__2; ++iwhilb) {
    // 如果 i0 大于 n0，则跳转至 L150
    if (i0 > n0) {
        goto L150;
    }

    // 在子矩阵未完成的情况下进行 dqds 步骤
    slasq3_(&i0, &n0, &z__[1], &pp, &dmin__, &sigma, &desig, &qmax, &
        nfail, &iter, &ndiv, &ieee, &ttype, &dmin1, &dmin2, &dn, &
        dn1, &dn2, &g, &tau);

    // 更新 pp
    pp = 1 - pp;
}
/*           When EMIN is very small check for splits. */

        // 如果 EMIN 非常小，则检查是否需要进行分裂
        if (pp == 0 && n0 - i0 >= 3) {
        // 如果 pp 为 0 并且 n0 - i0 大于等于 3
        if (z__[n0 * 4] <= tol2 * qmax || z__[(n0 << 2) - 1] <= tol2 *
             sigma) {
            // 检查是否满足分裂条件：最后一个元素或者倒数第二个元素小于等于阈值的一部分
            splt = i0 - 1;
            // 将分裂位置设为 i0 - 1
            qmax = z__[(i0 << 2) - 3];
            // 更新 qmax
            emin = z__[(i0 << 2) - 1];
            // 更新 emin
            oldemn = z__[i0 * 4];
            // 更新 oldemn
            i__3 = n0 - 3 << 2;
            // 计算循环上限
            for (i4 = i0 << 2; i4 <= i__3; i4 += 4) {
            // 从 i0 处开始，以步长 4 遍历到 n0 - 3
            if (z__[i4] <= tol2 * z__[i4 - 3] || z__[i4 - 1] <=
                tol2 * sigma) {
                // 如果满足分裂条件
                z__[i4 - 1] = -sigma;
                // 标记为分裂点
                splt = i4 / 4;
                // 更新分裂位置
                qmax = 0.f;
                // 重置 qmax
                emin = z__[i4 + 3];
                // 更新 emin
                oldemn = z__[i4 + 4];
                // 更新 oldemn
            } else {
/* Computing MAX */
                r__1 = qmax, r__2 = z__[i4 + 1];
                // 计算 qmax 的最大值
                qmax = dmax(r__1,r__2);
/* Computing MIN */
                r__1 = emin, r__2 = z__[i4 - 1];
                // 计算 emin 的最小值
                emin = dmin(r__1,r__2);
/* Computing MIN */
                r__1 = oldemn, r__2 = z__[i4];
                // 计算 oldemn 的最小值
                oldemn = dmin(r__1,r__2);
            }
/* L130: */
            }
            z__[(n0 << 2) - 1] = emin;
            // 更新最后一个元素
            z__[n0 * 4] = oldemn;
            // 更新倒数第二个元素
            i0 = splt + 1;
            // 更新 i0 为分裂位置加 1
        }
        }

/* L140: */
    }

    *info = 2;
    // 设置 info 为 2
    return 0;

/*        end IWHILB */

L150:

/* L160: */
    ;
    // 空行

    }

    *info = 3;
    // 设置 info 为 3
    return 0;

/*     end IWHILA */

L170:

/*     Move q's to the front. */

    i__1 = *n;
    // 循环从 2 到 n
    for (k = 2; k <= i__1; ++k) {
    // 将每个 q 移动到前面
    z__[k] = z__[(k << 2) - 3];
/* L180: */
    }

/*     Sort and compute sum of eigenvalues. */

    slasrt_("D", n, &z__[1], &iinfo);
    // 对 z__ 数组进行排序

    e = 0.f;
    // 初始化总和变量 e 为 0
    for (k = *n; k >= 1; --k) {
    // 计算所有特征值的总和
    e += z__[k];
/* L190: */
    }

/*     Store trace, sum(eigenvalues) and information on performance. */

    z__[(*n << 1) + 1] = trace;
    // 存储迹的值
    z__[(*n << 1) + 2] = e;
    // 存储特征值总和
    z__[(*n << 1) + 3] = (real) iter;
    // 存储迭代次数
/* Computing 2nd power */
    i__1 = *n;
    // 计算 n 的平方
    z__[(*n << 1) + 4] = (real) ndiv / (real) (i__1 * i__1);
    // 计算 ndiv 与 n^2 的比值
    z__[(*n << 1) + 5] = nfail * 100.f / (real) iter;
    // 计算 nfail 与 iter 的百分比
    return 0;

/*     End of SLASQ2 */

} /* slasq2_ */

/* Subroutine */ int slasq3_(integer *i0, integer *n0, real *z__, integer *pp,
     real *dmin__, real *sigma, real *desig, real *qmax, integer *nfail,
    integer *iter, integer *ndiv, logical *ieee, integer *ttype, real *
    dmin1, real *dmin2, real *dn, real *dn1, real *dn2, real *g, real *
    tau)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2;

    /* Local variables */
    static real s, t;
    // 静态实数变量 s, t
    static integer j4, nn;
    // 静态整数变量 j4, nn
    static real eps, tol;
    // 静态实数变量 eps, tol
    static integer n0in, ipn4;
    // 静态整数变量 n0in, ipn4
    static real tol2, temp;
    // 静态实数变量 tol2, temp
    # 外部子程序声明，声明了三个外部子程序slasq4, slasq5, slasq6
    # 这些子程序用于某些特定的数值计算
    extern /* Subroutine */ int slasq4_(integer *, integer *, real *, integer
        *, integer *, real *, real *, real *, real *, real *, real *,
        real *, integer *, real *), slasq5_(integer *, integer *, real *,
        integer *, real *, real *, real *, real *, real *, real *, real *,
         logical *), slasq6_(integer *, integer *, real *, integer *,
        real *, real *, real *, real *, real *, real *);
    # 外部函数声明，声明了两个外部函数slamch, sisnan
    # 这些函数用于返回特定计算机环境的参数，以及判断一个实数是否为NaN
    extern doublereal slamch_(char *);
    extern logical sisnan_(real *);
/*
    -- LAPACK routine (version 3.2.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- June 2010                                                       --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

    Purpose
    =======

    SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
    In case of failure it changes shifts, and tries again until output
    is positive.

    Arguments
    =========

    I0     (input) INTEGER
           First index.

    N0     (input/output) INTEGER
           Last index.

    Z      (input) REAL array, dimension ( 4*N )
           Z holds the qd array.

    PP     (input/output) INTEGER
           PP=0 for ping, PP=1 for pong.
           PP=2 indicates that flipping was applied to the Z array
           and that the initial tests for deflation should not be
           performed.

    DMIN   (output) REAL
           Minimum value of d.

    SIGMA  (output) REAL
           Sum of shifts used in current segment.

    DESIG  (input/output) REAL
           Lower order part of SIGMA

    QMAX   (input) REAL
           Maximum value of q.

    NFAIL  (output) INTEGER
           Number of times shift was too big.

    ITER   (output) INTEGER
           Number of iterations.

    NDIV   (output) INTEGER
           Number of divisions.

    IEEE   (input) LOGICAL
           Flag for IEEE or non IEEE arithmetic (passed to SLASQ5).

    TTYPE  (input/output) INTEGER
           Shift type.

    DMIN1  (input/output) REAL

    DMIN2  (input/output) REAL

    DN     (input/output) REAL

    DN1    (input/output) REAL

    DN2    (input/output) REAL

    G      (input/output) REAL

    TAU    (input/output) REAL

           These are passed as arguments in order to save their values
           between calls to SLASQ3.

    =====================================================================
*/

    /* Parameter adjustments */
    --z__;

    /* Function Body */
    
    // Initialize local variables
    n0in = *n0;  // Store the initial value of N0
    eps = slamch_("Precision");  // Determine machine precision
    // Compute tolerance based on machine precision
    tol = eps * 100.f;
    // Compute square of tolerance
    /* Computing 2nd power */
    r__1 = tol;
    tol2 = r__1 * r__1;

    // Check for deflation
L10:
    if (*n0 < *i0) {
        return 0;  // Exit if last index is less than first index
    }
    if (*n0 == *i0) {
        goto L20;  // Proceed to L20 if last index equals first index
    }
    nn = (*n0 << 2) + *pp;  // Calculate index position
    if (*n0 == *i0 + 1) {
        goto L40;  // Proceed to L40 if last index equals first index plus one
    }

    // Check whether E(N0-1) is negligible, 1 eigenvalue
    if (z__[nn - 5] > tol2 * (*sigma + z__[nn - 3]) && z__[nn - (*pp << 1) - 4] > tol2 * z__[nn - 7]) {
        goto L30;  // Proceed to L30 if conditions for deflation are met
    }

L20:
    // Update Z array and decrement last index
    z__[(*n0 << 2) - 3] = z__[(*n0 << 2) + *pp - 3] + *sigma;
    --(*n0);
    goto L10;  // Repeat the deflation check

    // Check whether E(N0-2) is negligible, 2 eigenvalues
L30:
    # 如果条件成立，执行下面的语句块
    if (z__[nn - 9] > tol2 * *sigma && z__[nn - (*pp << 1) - 8] > tol2 * z__[
        nn - 11]) {
    # 转移到标签 L50 处继续执行
    goto L50;
    }
L40:

    if (z__[nn - 3] > z__[nn - 7]) {
        s = z__[nn - 3];  // 将 z__[nn - 3] 的值赋给 s
        z__[nn - 3] = z__[nn - 7];  // 将 z__[nn - 7] 的值赋给 z__[nn - 3]
        z__[nn - 7] = s;  // 将 s 的值赋给 z__[nn - 7]
    }
    if (z__[nn - 5] > z__[nn - 3] * tol2) {
        t = (z__[nn - 7] - z__[nn - 3] + z__[nn - 5]) * .5f;  // 计算 t 的值
        s = z__[nn - 3] * (z__[nn - 5] / t);  // 计算 s 的值
        if (s <= t) {
            s = z__[nn - 3] * (z__[nn - 5] / (t * (sqrt(s / t + 1.f) + 1.f)));  // 根据条件计算 s 的值
        } else {
            s = z__[nn - 3] * (z__[nn - 5] / (t + sqrt(t) * sqrt(t + s)));  // 根据条件计算 s 的值
        }
        t = z__[nn - 7] + (s + z__[nn - 5]);  // 计算 t 的值
        z__[nn - 3] *= z__[nn - 7] / t;  // 更新 z__[nn - 3] 的值
        z__[nn - 7] = t;  // 更新 z__[nn - 7] 的值
    }
    z__[(*n0 << 2) - 7] = z__[nn - 7] + *sigma;  // 更新 z__[(*n0 << 2) - 7] 的值
    z__[(*n0 << 2) - 3] = z__[nn - 3] + *sigma;  // 更新 z__[(*n0 << 2) - 3] 的值
    *n0 += -2;  // 将 *n0 减去 2
    goto L10;  // 跳转到标签 L10 处

L50:
    if (*pp == 2) {
        *pp = 0;  // 如果 *pp 等于 2，则将其设为 0
    }

/*     Reverse the qd-array, if warranted. */

    if (*dmin__ <= 0.f || *n0 < n0in) {
        if (z__[(*i0 << 2) + *pp - 3] * 1.5f < z__[(*n0 << 2) + *pp - 3]) {
            ipn4 = *i0 + *n0 << 2;  // 计算 ipn4 的值
            i__1 = *i0 + *n0 - 1 << 1;  // 计算 i__1 的值
            for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
                temp = z__[j4 - 3];  // 临时存储 z__[j4 - 3] 的值
                z__[j4 - 3] = z__[ipn4 - j4 - 3];  // 交换数组元素的值
                z__[ipn4 - j4 - 3] = temp;  // 交换数组元素的值
                temp = z__[j4 - 2];  // 临时存储 z__[j4 - 2] 的值
                z__[j4 - 2] = z__[ipn4 - j4 - 2];  // 交换数组元素的值
                z__[ipn4 - j4 - 2] = temp;  // 交换数组元素的值
                temp = z__[j4 - 1];  // 临时存储 z__[j4 - 1] 的值
                z__[j4 - 1] = z__[ipn4 - j4 - 5];  // 交换数组元素的值
                z__[ipn4 - j4 - 5] = temp;  // 交换数组元素的值
                temp = z__[j4];  // 临时存储 z__[j4] 的值
                z__[j4] = z__[ipn4 - j4 - 4];  // 交换数组元素的值
                z__[ipn4 - j4 - 4] = temp;  // 交换数组元素的值
            }
            if (*n0 - *i0 <= 4) {
                z__[(*n0 << 2) + *pp - 1] = z__[(*i0 << 2) + *pp - 1];  // 更新数组元素的值
                z__[(*n0 << 2) - *pp] = z__[(*i0 << 2) - *pp];  // 更新数组元素的值
            }
            /* Computing MIN */
            r__1 = *dmin2, r__2 = z__[(*n0 << 2) + *pp - 1];  // 计算最小值
            *dmin2 = dmin(r__1,r__2);  // 更新 *dmin2 的值
            /* Computing MIN */
            r__1 = z__[(*n0 << 2) + *pp - 1], r__2 = z__[(*i0 << 2) + *pp - 1],
                r__1 = min(r__1,r__2), r__2 = z__[(*i0 << 2) + *pp + 3];  // 计算最小值
            z__[(*n0 << 2) + *pp - 1] = dmin(r__1,r__2);  // 更新数组元素的值
            /* Computing MIN */
            r__1 = z__[(*n0 << 2) - *pp], r__2 = z__[(*i0 << 2) - *pp], r__1 =
                 min(r__1,r__2), r__2 = z__[(*i0 << 2) - *pp + 4];  // 计算最小值
            z__[(*n0 << 2) - *pp] = dmin(r__1,r__2);  // 更新数组元素的值
            /* Computing MAX */
            r__1 = *qmax, r__2 = z__[(*i0 << 2) + *pp - 3], r__1 = max(r__1,
                r__2), r__2 = z__[(*i0 << 2) + *pp + 1];  // 计算最大值
            *qmax = dmax(r__1,r__2);  // 更新 *qmax 的值
            *dmin__ = -0.f;  // 将 *dmin__ 设为负零
        }
    }

/*     Choose a shift. */

    slasq4_(i0, n0, &z__[1], pp, &n0in, dmin__, dmin1, dmin2, dn, dn1, dn2,
        tau, ttype, g);  // 调用 slasq4_ 函数

/*     Call dqds until DMIN > 0. */

L70:

    slasq5_(i0, n0, &z__[1], pp, tau, dmin__, dmin1, dmin2, dn, dn1, dn2,
        ieee);  // 调用 slasq5_ 函数

    *ndiv += *n0 - *i0 + 2;  // 更新 *ndiv 的值
    ++(*iter);  // 将 *iter 自增

/*     Check status. */

    if (*dmin__ >= 0.f && *dmin1 > 0.f) {

/*        Success. */

    goto L90;  // 跳转到标签 L90 处

    } else if (*dmin__ < 0.f && *dmin1 > 0.f && z__[(*n0 - 1 << 2) - *pp] <
        tol * (*sigma + *dn1) && dabs(*dn) < tol * *sigma) {

/*        Convergence hidden by negative DN. */

    z__[(*n0 - 1 << 2) - *pp + 2] = 0.f;  // 更新数组元素的值
    *dmin__ = 0.f;  // 将 *dmin__ 设为零
    // 转到代码标签 L90 处执行代码
    goto L90;
    // 如果 dmin__ 指针所指向的值小于 0.0，则执行以下代码块
    } else if (*dmin__ < 0.f) {
/*        TAU too big. Select new TAU and try again. */

++(*nfail);
if (*ttype < -22) {

/*           Failed twice. Play it safe. */

*tau = 0.f;
} else if (*dmin1 > 0.f) {

/*           Late failure. Gives excellent shift. */

*tau = (*tau + *dmin__) * (1.f - eps * 2.f);
*ttype += -11;
} else {

/*           Early failure. Divide by 4. */

*tau *= .25f;
*ttype += -12;
}
goto L70;
} else if (sisnan_(dmin__)) {

/*        NaN. */

if (*tau == 0.f) {
    goto L80;
} else {
    *tau = 0.f;
    goto L70;
}
} else {

/*        Possible underflow. Play it safe. */

goto L80;
}

/*     Risk of underflow. */

L80:
slasq6_(i0, n0, &z__[1], pp, dmin__, dmin1, dmin2, dn, dn1, dn2);
*ndiv += *n0 - *i0 + 2;
++(*iter);
*tau = 0.f;

L90:
if (*tau < *sigma) {
*desig += *tau;
t = *sigma + *desig;
*desig -= t - *sigma;
} else {
t = *sigma + *tau;
*desig = *sigma - (t - *tau) + *desig;
}
*sigma = t;

return 0;

/*     End of SLASQ3 */

} /* slasq3_ */

/* Subroutine */ int slasq4_(integer *i0, integer *n0, real *z__, integer *pp,
 integer *n0in, real *dmin__, real *dmin1, real *dmin2, real *dn,
real *dn1, real *dn2, real *tau, integer *ttype, real *g)
{
/* System generated locals */
integer i__1;
real r__1, r__2;

/* Local variables */
static real s, a2, b1, b2;
static integer i4, nn, np;
static real gam, gap1, gap2;


/*
-- LAPACK routine (version 3.2)                                    --

-- Contributed by Osni Marques of the Lawrence Berkeley National   --
-- Laboratory and Beresford Parlett of the Univ. of California at  --
-- Berkeley                                                        --
-- November 2008                                                   --

-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


Purpose
=======

SLASQ4 computes an approximation TAU to the smallest eigenvalue
using values of d from the previous transform.

I0    (input) INTEGER
      First index.

N0    (input) INTEGER
      Last index.

Z     (input) REAL array, dimension ( 4*N )
      Z holds the qd array.

PP    (input) INTEGER
      PP=0 for ping, PP=1 for pong.

NOIN  (input) INTEGER
      The value of N0 at start of EIGTEST.

DMIN  (input) REAL
      Minimum value of d.

DMIN1 (input) REAL
      Minimum value of d, excluding D( N0 ).

DMIN2 (input) REAL
      Minimum value of d, excluding D( N0 ) and D( N0-1 ).

DN    (input) REAL
      d(N)

DN1   (input) REAL
      d(N-1)

DN2   (input) REAL
      d(N-2)

TAU   (output) REAL
      This is the shift.

TTYPE (output) INTEGER
      Shift type.
    # G是一个实数，作为参数传入以在调用SLASQ4时保存其数值
    G     (input/output) REAL
          G is passed as an argument in order to save its value between
          calls to SLASQ4.

    # 进一步的细节
    # CNST1被赋值为9/16
    CNST1 = 9/16

    =====================================================================


       # 一个负的DMIN会强制该值取绝对值
       # TTYPE记录了移位的类型
       A negative DMIN forces the shift to take that absolute value
       TTYPE records the type of shift.
    /* 参数 z__ 是一个指针，用来指向一个浮点数数组 */
    --z__;

    /* 函数体开始 */
    if (*dmin__ <= 0.f) {
    /* 如果输入的最小特征值小于等于零 */
    *tau = -(*dmin__);
    *ttype = -1;
    return 0;
    }

    /* 计算 nn 的值 */
    nn = (*n0 << 2) + *pp;
    /* 如果 n0in 等于 n0 */
    if (*n0in == *n0) {

/*        没有特征值被消除的情况。 */

    /* 如果 dmin__ 等于 dn 或者 dmin__ 等于 dn1 */
    if (*dmin__ == *dn || *dmin__ == *dn1) {

        /* 计算 b1 和 b2 的值 */
        b1 = sqrt(z__[nn - 3]) * sqrt(z__[nn - 5]);
        b2 = sqrt(z__[nn - 7]) * sqrt(z__[nn - 9]);
        /* 计算 a2 的值 */
        a2 = z__[nn - 7] + z__[nn - 5];

/*           Cases 2 and 3. */

        /* 如果 dmin__ 等于 dn 并且 dmin1 等于 dn1 */
        if (*dmin__ == *dn && *dmin1 == *dn1) {
        /* 计算 gap2 的值 */
        gap2 = *dmin2 - a2 - *dmin2 * .25f;
        /* 如果 gap2 大于零并且大于 b2 */
        if (gap2 > 0.f && gap2 > b2) {
            /* 计算 gap1 的值 */
            gap1 = a2 - *dn - b2 / gap2 * b2;
        } else {
            /* 否则计算 gap1 的值 */
            gap1 = a2 - *dn - (b1 + b2);
        }
        /* 如果 gap1 大于零并且大于 b1 */
        if (gap1 > 0.f && gap1 > b1) {
/* Computing MAX */
            /* 计算 s 的值 */
            r__1 = *dn - b1 / gap1 * b1, r__2 = *dmin__ * .5f;
            s = dmax(r__1,r__2);
            *ttype = -2;
        } else {
            /* 否则 s 的值为零 */
            s = 0.f;
            /* 如果 dn 大于 b1 */
            if (*dn > b1) {
            s = *dn - b1;
            }
            /* 如果 a2 大于 b1 + b2 */
            if (a2 > b1 + b2) {
/* Computing MIN */
            r__1 = s, r__2 = a2 - (b1 + b2);
            s = dmin(r__1,r__2);
            }
/* Computing MAX */
            /* 计算 s 的值 */
            r__1 = s, r__2 = *dmin__ * .333f;
            s = dmax(r__1,r__2);
            *ttype = -3;
        }
        } else {

/*              Case 4. */

        /* 设置 ttype 为 -4 */
        *ttype = -4;
        /* 计算 s 的值 */
        s = *dmin__ * .25f;
        /* 如果 dmin__ 等于 dn */
        if (*dmin__ == *dn) {
            /* 设置 gam 的值为 dn */
            gam = *dn;
            /* 设置 a2 的值为零 */
            a2 = 0.f;
            /* 如果 z__[nn - 5] 大于 z__[nn - 7] */
            if (z__[nn - 5] > z__[nn - 7]) {
            return 0;
            }
            /* 计算 b2 的值 */
            b2 = z__[nn - 5] / z__[nn - 7];
            /* 设置 np 的值 */
            np = nn - 9;
        } else {
            /* 否则设置 np 的值 */
            np = nn - (*pp << 1);
            /* 计算 b2 的值 */
            b2 = z__[np - 2];
            /* 设置 gam 的值为 dn1 */
            gam = *dn1;
            /* 如果 z__[np - 4] 大于 z__[np - 2] */
            if (z__[np - 4] > z__[np - 2]) {
            return 0;
            }
            /* 计算 a2 的值 */
            a2 = z__[np - 4] / z__[np - 2];
            /* 如果 z__[nn - 9] 大于 z__[nn - 11] */
            if (z__[nn - 9] > z__[nn - 11]) {
            return 0;
            }
            /* 计算 b2 的值 */
            b2 = z__[nn - 9] / z__[nn - 11];
            /* 设置 np 的值 */
            np = nn - 13;
        }

/*              Approximate contribution to norm squared from I < NN-1. */

        /* 计算 a2 的值 */
        a2 += b2;
        /* 设置 i4 的初始值 */
        i__1 = (*i0 << 2) - 1 + *pp;
        /* 从 np 开始向前遍历 */
        for (i4 = np; i4 >= i__1; i4 += -4) {
            /* 如果 b2 等于零 */
            if (b2 == 0.f) {
            goto L20;
            }
            /* 设置 b1 的值 */
            b1 = b2;
            /* 如果 z__[i4] 大于 z__[i4 - 2] */
            if (z__[i4] > z__[i4 - 2]) {
            return 0;
            }
            /* 计算 b2 的值 */
            b2 *= z__[i4] / z__[i4 - 2];
            /* 计算 a2 的值 */
            a2 += b2;
            /* 如果 dmax(b2,b1) * 100.f < a2 或者 .563f < a2 */
            if (dmax(b2,b1) * 100.f < a2 || .563f < a2) {
            goto L20;
            }
/* L10: */
        }
L20:
        /* a2 增加 5% */
        a2 *= 1.05f;

/*              Rayleigh quotient residual bound. */

        /* 如果 a2 小于 .563f */
        if (a2 < .563f) {
            /* 计算 s 的值 */
            s = gam * (1.f - sqrt(a2)) / (a2 + 1.f);
        }
        }
    } else if (*dmin__ == *dn2) {

/*           Case 5. */

        /* 设置 ttype 为 -5 */
        *ttype = -5;
        /* 计算 s 的值 */
        s = *dmin__ * .25f;

        /* 继续填写 Case 5 的部分 */
/*           Compute contribution to norm squared from I > NN-2. */

/* 计算贡献到范数平方的部分，对于 I > NN-2。*/

np = nn - (*pp << 1);
/* 计算 np，即 nn - (*pp << 1)，用于确定数组 z__ 中的索引位置。*/

b1 = z__[np - 2];
/* 从 z__ 数组中获取 np - 2 处的值，赋给 b1。*/

b2 = z__[np - 6];
/* 从 z__ 数组中获取 np - 6 处的值，赋给 b2。*/

gam = *dn2;
/* 从指针 dn2 处获取值，赋给 gam。*/

if (z__[np - 8] > b2 || z__[np - 4] > b1) {
/* 检查 z__ 数组中 np - 8 和 np - 4 处的值是否大于 b2 和 b1。*/

return 0;
/* 如果条件成立，函数返回 0。*/
}

a2 = z__[np - 8] / b2 * (z__[np - 4] / b1 + 1.f);
/* 计算 a2 的值，使用 z__[np - 8] / b2 和 (z__[np - 4] / b1 + 1.f) 的乘积。*/

/*           Approximate contribution to norm squared from I < NN-2. */

/* 对于 I < NN-2，近似计算贡献到范数平方的部分。*/

if (*n0 - *i0 > 2) {
/* 如果 n0 - i0 大于 2，则执行以下操作。*/

b2 = z__[nn - 13] / z__[nn - 15];
/* 计算 b2，使用 z__[nn - 13] / z__[nn - 15] 的值。*/

a2 += b2;
/* 将 b2 的值加到 a2 上。*/

i__1 = (*i0 << 2) - 1 + *pp;
/* 计算 i__1，使用 (*i0 << 2) - 1 + *pp。*/

for (i4 = nn - 17; i4 >= i__1; i4 += -4) {
/* 循环从 nn - 17 开始，每次减 4，直到 i4 大于或等于 i__1。*/

if (b2 == 0.f) {
/* 如果 b2 等于 0，则跳转到标签 L40。*/

goto L40;
/* 跳转到标签 L40。*/
}

b1 = b2;
/* 将 b2 的值赋给 b1。*/

if (z__[i4] > z__[i4 - 2]) {
/* 如果 z__[i4] 大于 z__[i4 - 2]，则返回 0。*/

return 0;
/* 返回 0。*/
}

b2 *= z__[i4] / z__[i4 - 2];
/* 将 b2 乘以 z__[i4] / z__[i4 - 2]。*/

a2 += b2;
/* 将 b2 的值加到 a2 上。*/

if (dmax(b2, b1) * 100.f < a2 || .563f < a2) {
/* 如果 dmax(b2, b1) * 100.f 小于 a2 或者 .563f 小于 a2，则跳转到标签 L40。*/

goto L40;
/* 跳转到标签 L40。*/
}
/* L30: */
}
L40:
/* 标签 L40。*/

a2 *= 1.05f;
/* 将 a2 乘以 1.05。*/
}

if (a2 < .563f) {
/* 如果 a2 小于 .563f，则执行以下操作。*/

s = gam * (1.f - sqrt(a2)) / (a2 + 1.f);
/* 计算 s 的值，使用 gam * (1.f - sqrt(a2)) / (a2 + 1.f)。*/
}
} else {

/*           Case 6, no information to guide us. */

/* Case 6，没有信息可以指导我们。*/

if (*ttype == -6) {
/* 如果指针 ttype 指向的值等于 -6，则执行以下操作。*/

*g += (1.f - *g) * .333f;
/* 将 *g 增加 (1.f - *g) * .333f。*/
} else if (*ttype == -18) {
/* 否则，如果指针 ttype 指向的值等于 -18，则执行以下操作。*/

*g = .083250000000000005f;
/* 将 *g 设置为 .083250000000000005。*/
} else {
/* 否则（如果以上条件都不满足），执行以下操作。*/

*g = .25f;
/* 将 *g 设置为 .25。*/
}

s = *g * *dmin__;
/* 计算 s 的值，使用 *g * *dmin__。*/

*ttype = -6;
/* 将 ttype 指向的值设置为 -6。*/
}

} else if (*n0in == *n0 + 1) {

/*        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN. */

/* 一个特征值刚刚消失。使用 DMIN1 和 DN1 作为 DMIN 和 DN。*/

if (*dmin1 == *dn1 && *dmin2 == *dn2) {
/* 如果指针 dmin1 指向的值等于指针 dn1 指向的值，并且指针 dmin2 指向的值等于指针 dn2 指向的值，则执行以下操作。*/

/*           Cases 7 and 8. */

/* Case 7 和 8。*/

*ttype = -7;
/* 将 ttype 指向的值设置为 -7。*/

s = *dmin1 * .333f;
/* 计算 s 的值，使用 *dmin1 * .333f。*/

if (z__[nn - 5] > z__[nn - 7]) {
/* 如果 z__[nn - 5] 大于 z__[nn - 7]，则返回 0。*/

return 0;
/* 返回 0。*/
}

b1 = z__[nn - 5] / z__[nn - 7];
/* 计算 b1 的值，使用 z__[nn - 5] / z__[nn - 7]。*/

b2 = b1;
/* 将 b1 的值赋给 b2。*/

if (b2 == 0.f) {
/* 如果 b2 等于 0，则跳转到标签 L60。*/

goto L60;
/* 跳转到标签 L60。*/
}

i__1 = (*i0 << 2) - 1 + *pp;
/* 计算 i__1，使用 (*i0 << 2) - 1 + *pp。*/

for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4) {
/* 循环从 (*n0 << 2) - 9 + *pp 开始，每次减 4，直到 i4 大于或等于 i__1。*/

a2 = b1;
/* 将 b1 的值赋给 a2。*/

if (z__[i4] > z__[i4 - 2]) {
/* 如果 z__[i4] 大于 z__[i4 - 2]，则返回 0。*/

return 0;
/* 返回 0。*/
}

b1 *= z__[i4] / z__[i4 - 2];
/* 将 b1 乘以 z__[i4] / z__[i4 - 2]。*/

b2 += b1;
/* 将 b1 的值加到 b2 上。*/

if (dmax(b1, a2) * 100.f < b2) {
/* 如果 dmax(b1, a2) * 100.f 小于 b2，则跳转到标签 L60。*/

goto L60;
/* 跳转到标签 L60。*/
}
/* L50: */
}

L60:
/* 标签 L60。*/

b2 = sqrt(b2 * 1.05f);
/* 计算 b2 的平方根，使用 sqrt(b2 * 1.05f)。*/

/* Computing 2nd power */
/* 计算平方 */
r__1 = b2;
/* r__1 等于 b2 的平方。*/

a2 = *dmin1 / (r__1 * r__1 + 1.f);
/* 计算 a2 的值，使用 *dmin1 / (r
    # 如果指针指向的值与另一个指针指向的值相等，并且数组中倒数第五个元素的两倍小于倒数第七个元素
    if (*dmin2 == *dn2 && z__[nn - 5] * 2.f < z__[nn - 7]) {
        # 设置类型标记为 -10
        *ttype = -10;
        # 计算 dmin2 的三分之一，并将结果赋给 s
        s = *dmin2 * .333f;
        # 如果 z__[nn - 5] 大于 z__[nn - 7]
        if (z__[nn - 5] > z__[nn - 7]) {
            # 返回 0
            return 0;
        }
        # 计算 b1 为 z__[nn - 5] 除以 z__[nn - 7]
        b1 = z__[nn - 5] / z__[nn - 7];
        # 初始化 b2 为 b1 的值
        b2 = b1;
        # 如果 b2 的值为 0
        if (b2 == 0.f) {
            # 跳转到标签 L80
            goto L80;
        }
        # 循环从 (*i0 << 2) - 1 + *pp 到 (*n0 << 2) - 9 + *pp，每次递减 4
        for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4) {
            # 如果 z__[i4] 大于 z__[i4 - 2]
            if (z__[i4] > z__[i4 - 2]) {
                # 返回 0
                return 0;
            }
            # 计算 b1 乘以 z__[i4] 除以 z__[i4 - 2]，并将结果赋给 b1
            b1 *= z__[i4] / z__[i4 - 2];
            # b2 增加 b1 的值
            b2 += b1;
            # 如果 b1 的值乘以 100 小于 b2
            if (b1 * 100.f < b2) {
                # 跳转到标签 L80
                goto L80;
            }
/* L70: */
        }
L80:
        b2 = sqrt(b2 * 1.05f);
/* Computing 2nd power */
        r__1 = b2;
        a2 = *dmin2 / (r__1 * r__1 + 1.f);
        gap2 = z__[nn - 7] + z__[nn - 9] - sqrt(z__[nn - 11]) * sqrt(z__[
            nn - 9]) - a2;
        if (gap2 > 0.f && gap2 > b2 * a2) {
/* Computing MAX */
        r__1 = s, r__2 = a2 * (1.f - a2 * 1.01f * (b2 / gap2) * b2);
        s = dmax(r__1,r__2);
        } else {
/* Computing MAX */
        r__1 = s, r__2 = a2 * (1.f - b2 * 1.01f);
        s = dmax(r__1,r__2);
        }
    } else {
        s = *dmin2 * .25f;
        *ttype = -11;
    }
    } else if (*n0in > *n0 + 2) {

/*        Case 12, more than two eigenvalues deflated. No information. */

    s = 0.f;
    *ttype = -12;
    }

    *tau = s;
    return 0;

/*     End of SLASQ4 */

} /* slasq4_ */

/* Subroutine */ int slasq5_(integer *i0, integer *n0, real *z__, integer *pp,
     real *tau, real *dmin__, real *dmin1, real *dmin2, real *dn, real *
    dnm1, real *dnm2, logical *ieee)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2;

    /* Local variables */
    static real d__;
    static integer j4, j4p2;
    static real emin, temp;


/*
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    SLASQ5 computes one dqds transform in ping-pong form, one
    version for IEEE machines another for non IEEE machines.

    Arguments
    =========

    I0    (input) INTEGER
          First index.

    N0    (input) INTEGER
          Last index.

    Z     (input) REAL array, dimension ( 4*N )
          Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
          an extra argument.

    PP    (input) INTEGER
          PP=0 for ping, PP=1 for pong.

    TAU   (input) REAL
          This is the shift.

    DMIN  (output) REAL
          Minimum value of d.

    DMIN1 (output) REAL
          Minimum value of d, excluding D( N0 ).

    DMIN2 (output) REAL
          Minimum value of d, excluding D( N0 ) and D( N0-1 ).

    DN    (output) REAL
          d(N0), the last value of d.

    DNM1  (output) REAL
          d(N0-1).

    DNM2  (output) REAL
          d(N0-2).

    IEEE  (input) LOGICAL
          Flag for IEEE or non IEEE arithmetic.

    =====================================================================
*/


    /* Parameter adjustments */
    --z__;

    /* Function Body */
    if (*n0 - *i0 - 1 <= 0) {
    return 0;
    }

    j4 = (*i0 << 2) + *pp - 3;
    emin = z__[j4 + 4];
    d__ = z__[j4] - *tau;


注释完成。
    # 将 d__ 的值赋给 *dmin__
    *dmin__ = d__;

    # 将 z__[j4] 的负值赋给 *dmin1
    *dmin1 = -z__[j4];

    # 如果 ieee 参数为真，则执行以下代码块
    if (*ieee) {
/*        Code for IEEE arithmetic. */

    // 检查 pp 是否为 0
    if (*pp == 0) {
        // 计算循环次数的上限
        i__1 = *n0 - 3 << 2;
        // 循环迭代，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        // 执行向量运算：z__[j4-2] = d__ + z__[j4-1];
        z__[j4 - 2] = d__ + z__[j4 - 1];
        // 计算临时变量 temp
        temp = z__[j4 + 1] / z__[j4 - 2];
        // 更新 d__ 的值
        d__ = d__ * temp - *tau;
        // 更新 dmin__ 的值
        *dmin__ = dmin(*dmin__,d__);
        // 计算并更新 emin 的值
        z__[j4] = z__[j4 - 1] * temp;
        /* Computing MIN */
        r__1 = z__[j4];
        emin = dmin(r__1,emin);
        // 标签，用于循环结构
        /* L10: */
        }
    } else {
        // 计算循环次数的上限
        i__1 = *n0 - 3 << 2;
        // 循环迭代，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        // 执行向量运算：z__[j4-3] = d__ + z__[j4];
        z__[j4 - 3] = d__ + z__[j4];
        // 计算临时变量 temp
        temp = z__[j4 + 2] / z__[j4 - 3];
        // 更新 d__ 的值
        d__ = d__ * temp - *tau;
        // 更新 dmin__ 的值
        *dmin__ = dmin(*dmin__,d__);
        // 计算并更新 emin 的值
        z__[j4 - 1] = z__[j4] * temp;
        /* Computing MIN */
        r__1 = z__[j4 - 1];
        emin = dmin(r__1,emin);
        // 标签，用于循环结构
        /* L20: */
        }
    }

/*        Unroll last two steps. */

    // 更新 *dnm2 和 *dmin2 的值
    *dnm2 = d__;
    *dmin2 = *dmin__;
    // 计算数组索引值 j4 和 j4p2
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp << 1) - 1;
    // 执行向量运算：z__[j4-2] = *dnm2 + z__[j4p2];
    z__[j4 - 2] = *dnm2 + z__[j4p2];
    // 执行向量运算：z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    // 计算临时变量 *dnm1 的值
    *dnm1 = z__[j4p2 + 2] * (*dnm2 / z__[j4 - 2]) - *tau;
    // 更新 dmin__ 的值
    *dmin__ = dmin(*dmin__,*dnm1);

    // 更新 *dmin1 的值
    *dmin1 = *dmin__;
    // 更新数组索引值 j4 和 j4p2
    j4 += 4;
    j4p2 = j4 + (*pp << 1) - 1;
    // 执行向量运算：z__[j4-2] = *dnm1 + z__[j4p2];
    z__[j4 - 2] = *dnm1 + z__[j4p2];
    // 如果 *dnm1 小于 0，则返回 0
    if (*dnm1 < 0.f) {
        return 0;
    } else {
        // 执行向量运算：z__[j4] = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau;
        z__[j4] = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau;
    }
    // 更新 dmin__ 的值
    *dmin__ = dmin(*dmin__,*dn);

    } else {

/*        Code for non IEEE arithmetic. */

    // 检查 pp 是否为 0
    if (*pp == 0) {
        // 计算循环次数的上限
        i__1 = *n0 - 3 << 2;
        // 循环迭代，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        // 执行向量运算：z__[j4-2] = d__ + z__[j4-1];
        z__[j4 - 2] = d__ + z__[j4 - 1];
        // 检查 d__ 是否小于 0
        if (d__ < 0.f) {
            // 如果是，返回 0
            return 0;
        } else {
            // 否则，执行向量运算：z__[j4] = z__[j4 + 1] * (z__[j4 - 1] / z__[j4 - 2]);
            z__[j4] = z__[j4 + 1] * (z__[j4 - 1] / z__[j4 - 2]);
            // 执行向量运算：d__ = z__[j4 + 1] * (d__ / z__[j4 - 2]) - *tau;
            d__ = z__[j4 + 1] * (d__ / z__[j4 - 2]) - *tau;
        }
        // 更新 dmin__ 的值
        *dmin__ = dmin(*dmin__,d__);
        /* Computing MIN */
        r__1 = emin, r__2 = z__[j4];
        emin = dmin(r__1,r__2);
        // 标签，用于循环结构
        /* L30: */
        }
    } else {
        // 计算循环次数的上限
        i__1 = *n0 - 3 << 2;
        // 循环迭代，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        // 执行向量运算：z__[j4-3] = d__ + z__[j4];
        z__[j4 - 3] = d__ + z__[j4];
        // 检查 d__ 是否小于 0
        if (d__ < 0.f) {
            // 如果是，返回 0
            return 0;
        } else {
            // 否则，执行向量运算：z__[j4 - 1] = z__[j4 + 2] * (z__[j4] / z__[j4 - 3]);
            z__[j4 - 1] = z__[j4 + 2] * (z__[j4] / z__[j4 - 3]);
            // 执行向量运算：d__ = z__[j4 + 2] * (d__ / z__[j4 - 3]) - *tau;
            d__ = z__[j4 + 2] * (d__ / z__[j4 - 3]) - *tau;
        }
        // 更新 dmin__ 的值
        *dmin__ = dmin(*dmin__,d__);
        /* Computing MIN */
        r__1 = emin, r__2 = z__[j4 - 1];
        emin = dmin(r__1,r__2);
        // 标签，用于循环结构
        /* L40: */
        }
    }

/*        Unroll last two steps. */

    // 更新 *dnm2 和 *dmin2 的值
    *dnm2 = d__;
    *dmin2 = *dmin__;
    // 计算数组索引值 j4 和 j4p2
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp <<
    } else {
        // 计算 z__[j4] 的值，根据公式 z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2])
        z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
        // 计算 *dn 的值，根据公式 *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau
        *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau;
    }
    // 更新 dmin__ 的值，使其成为 *dmin__ 和 *dn 中的最小值
    *dmin__ = dmin(*dmin__, *dn);

    }

    // 设置 z__[j4 + 2] 的值为 *dn
    z__[j4 + 2] = *dn;
    // 设置 z__[(*n0 << 2) - *pp] 的值为 emin
    z__[(*n0 << 2) - *pp] = emin;
    // 返回成功状态码 0
    return 0;
    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        z__[j4 + 2] = d__ + z__[j4 + 1];
        if (z__[j4 + 2] == 0.f) {
            z__[j4 + 4] = 0.f;
            d__ = z__[j4 + 3];
            *dmin__ = d__;
            emin = 0.f;
        } else if (safmin * z__[j4 + 3] < z__[j4 + 2] && safmin * z__[j4 + 2] < z__[j4 + 3]) {
            temp = z__[j4 + 3] / z__[j4 + 2];
            z__[j4 + 4] = z__[j4 + 1] * temp;
            d__ *= temp;
        } else {
            z__[j4 + 4] = z__[j4 + 3] * (z__[j4 + 1] / z__[j4 + 2]);
            d__ = z__[j4 + 3] * (d__ / z__[j4 + 2]);
        }
        *dmin__ = dmin(*dmin__, d__);
        r__1 = emin;
        r__2 = z__[j4 + 4];
        emin = dmin(r__1, r__2);
    }
}

/*     End of SLASQ6 */

} /* slasq6_ */


注释：

/*     End of SLASQ6 */
在这里结束 SLASQ6 子程序的定义。

} /* slasq6_ */
在这里结束 slasq6_ 子程序的定义。
    // 循环，从 *i0 左移两位后的值开始，每次增加4，直到 i__1
    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        // 计算 z__[j4 - 3] 的值为 d__ 加上 z__[j4] 的结果
        z__[j4 - 3] = d__ + z__[j4];
        
        // 如果 z__[j4 - 3] 等于 0.f
        if (z__[j4 - 3] == 0.f) {
            // 将 z__[j4 - 1] 设为 0.f
            z__[j4 - 1] = 0.f;
            // 将 d__ 设为 z__[j4 + 2]
            d__ = z__[j4 + 2];
            // 将 *dmin__ 设为 d__
            *dmin__ = d__;
            // 将 emin 设为 0.f
            emin = 0.f;
        } else if (safmin * z__[j4 + 2] < z__[j4 - 3] && safmin * z__[j4 - 3] < z__[j4 + 2]) {
            // 如果 safmin 乘以 z__[j4 + 2] 小于 z__[j4 - 3]，
            // 且 safmin 乘以 z__[j4 - 3] 小于 z__[j4 + 2]
            // 则计算 temp 等于 z__[j4 + 2] 除以 z__[j4 - 3]
            temp = z__[j4 + 2] / z__[j4 - 3];
            // 将 z__[j4 - 1] 设为 z__[j4] 乘以 temp
            z__[j4 - 1] = z__[j4] * temp;
            // 将 d__ 乘以 temp
            d__ *= temp;
        } else {
            // 否则将 z__[j4 - 1] 设为 z__[j4 + 2] 乘以 (z__[j4] 除以 z__[j4 - 3])
            z__[j4 - 1] = z__[j4 + 2] * (z__[j4] / z__[j4 - 3]);
            // 将 d__ 设为 z__[j4 + 2] 乘以 (d__ 除以 z__[j4 - 3])
            d__ = z__[j4 + 2] * (d__ / z__[j4 - 3]);
        }
        // 将 *dmin__ 设为 dmin(*dmin__, d__)
        *dmin__ = dmin(*dmin__, d__);
    }
/* Computing MIN */
/* 计算最小值 */
        r__1 = emin, r__2 = z__[j4 - 1];
        emin = dmin(r__1,r__2);
/* L20: */
    }
    }

/*     Unroll last two steps. */

    *dnm2 = d__;
    *dmin2 = *dmin__;
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp << 1) - 1;
    z__[j4 - 2] = *dnm2 + z__[j4p2];
    if (z__[j4 - 2] == 0.f) {
    z__[j4] = 0.f;
    *dnm1 = z__[j4p2 + 2];
    *dmin__ = *dnm1;
    emin = 0.f;
    } else if (safmin * z__[j4p2 + 2] < z__[j4 - 2] && safmin * z__[j4 - 2] <
        z__[j4p2 + 2]) {
    temp = z__[j4p2 + 2] / z__[j4 - 2];
    z__[j4] = z__[j4p2] * temp;
    *dnm1 = *dnm2 * temp;
    } else {
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    *dnm1 = z__[j4p2 + 2] * (*dnm2 / z__[j4 - 2]);
    }
    *dmin__ = dmin(*dmin__,*dnm1);

    *dmin1 = *dmin__;
    j4 += 4;
    j4p2 = j4 + (*pp << 1) - 1;
    z__[j4 - 2] = *dnm1 + z__[j4p2];
    if (z__[j4 - 2] == 0.f) {
    z__[j4] = 0.f;
    *dn = z__[j4p2 + 2];
    *dmin__ = *dn;
    emin = 0.f;
    } else if (safmin * z__[j4p2 + 2] < z__[j4 - 2] && safmin * z__[j4 - 2] <
        z__[j4p2 + 2]) {
    temp = z__[j4p2 + 2] / z__[j4 - 2];
    z__[j4] = z__[j4p2] * temp;
    *dn = *dnm1 * temp;
    } else {
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]);
    }
    *dmin__ = dmin(*dmin__,*dn);

    z__[j4 + 2] = *dn;
    z__[(*n0 << 2) - *pp] = emin;
    return 0;

/*     End of SLASQ6 */

} /* slasq6_ */

/* Subroutine */ int slasr_(char *side, char *pivot, char *direct, integer *m,
     integer *n, real *c__, real *s, real *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, info;
    static real temp;
    extern logical lsame_(char *, char *);
    static real ctemp, stemp;
    extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASR applies a sequence of plane rotations to a real matrix A,
    from either the left or the right.

    When SIDE = 'L', the transformation takes the form

       A := P*A

    and when SIDE = 'R', the transformation takes the form

       A := A*P**T

    where P is an orthogonal matrix consisting of a sequence of z plane
    rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
    and P**T is the transpose of P.

    When DIRECT = 'F' (Forward sequence), then

       P = P(z-1) * ... * P(2) * P(1)

    and when DIRECT = 'B' (Backward sequence), then

       P = P(1) * P(2) * ... * P(z-1)

    where P(k) is a plane rotation matrix defined by the 2-by-2 rotation

       R(k) = (  c(k)  s(k) )
            = ( -s(k)  c(k) ).

    When PIVOT = 'V' (Variable pivot), the rotation is performed
/* 该函数用于应用一系列平面旋转到实矩阵 A，可以是从左侧或右侧应用 */

/*     -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK 是由 Univ. of Tennessee, Univ. of California Berkeley,
       Univ. of Colorado Denver 和 NAG Ltd. 提供的软件包 --
       2006年11月
*/

/* 定义变量和局部变量 */
integer i__, j, info;
real temp;
static real ctemp, stemp;

/* LSAME 是 LAPACK 中的一个外部函数，用于比较字符的大小写是否相同 */
extern logical lsame_(char *, char *);

/* XERBLA 是 LAPACK 中的一个外部函数，用于处理错误信息 */
extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    Purpose
    =======
    SLASR 对实矩阵 A 应用一系列平面旋转，可以是从左侧或右侧应用。

    当 SIDE = 'L' 时，变换形式为
       A := P*A

    当 SIDE = 'R' 时，变换形式为
       A := A*P**T

    其中 P 是由 z 个平面旋转组成的正交矩阵，当 SIDE = 'L' 时，z = M；
    当 SIDE = 'R' 时，z = N；P**T 表示 P 的转置。

    当 DIRECT = 'F'（正向顺序）时，
       P = P(z-1) * ... * P(2) * P(1)

    当 DIRECT = 'B'（反向顺序）时，
       P = P(1) * P(2) * ... * P(z-1)

    其中 P(k) 是由 2x2 旋转矩阵定义的平面旋转

       R(k) = (  c(k)  s(k) )
            = ( -s(k)  c(k) ).

    当 PIVOT = 'V'（可变枢轴）时，执行旋转操作
*/
``` 

This covers the initial part of the `slasr_` subroutine and provides comments as per the provided guidelines. Let me know if you need further assistance with the rest of the subroutine!
    for the plane (k,k+1), i.e., P(k) has the form

       P(k) = (  1                                            )
              (       ...                                     )
              (              1                                )
              (                   c(k)  s(k)                  )
              (                  -s(k)  c(k)                  )
              (                                1              )
              (                                     ...       )
              (                                            1  )

    where R(k) appears as a rank-2 modification to the identity matrix in
    rows and columns k and k+1.

    When PIVOT = 'T' (Top pivot), the rotation is performed for the
    plane (1,k+1), so P(k) has the form

       P(k) = (  c(k)                    s(k)                 )
              (         1                                     )
              (              ...                              )
              (                     1                         )
              ( -s(k)                    c(k)                 )
              (                                 1             )
              (                                      ...      )
              (                                             1 )

    where R(k) appears in rows and columns 1 and k+1.

    Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
    performed for the plane (k,z), giving P(k) the form

       P(k) = ( 1                                             )
              (      ...                                      )
              (             1                                 )
              (                  c(k)                    s(k) )
              (                         1                     )
              (                              ...              )
              (                                     1         )
              (                 -s(k)                    c(k) )

    where R(k) appears in rows and columns k and z.  The rotations are
    performed without ever forming P(k) explicitly.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T

    PIVOT   (input) CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)

    DIRECT  (input) CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
    # M (input) INTEGER
    #     矩阵 A 的行数。如果 m <= 1，则立即返回。

    # N (input) INTEGER
    #     矩阵 A 的列数。如果 n <= 1，则立即返回。

    # C (input) REAL array, dimension
    #     如果 SIDE = 'L'，维度为 (M-1)
    #     如果 SIDE = 'R'，维度为 (N-1)
    #     平面旋转的余弦值 c(k)。

    # S (input) REAL array, dimension
    #     如果 SIDE = 'L'，维度为 (M-1)
    #     如果 SIDE = 'R'，维度为 (N-1)
    #     平面旋转的正弦值 s(k)。矩阵 P(k) 的 2x2 平面旋转部分 R(k) 形如：
    #         R(k) = (  c(k)  s(k) )
    #                ( -s(k)  c(k) ).

    # A (input/output) REAL array, dimension (LDA,N)
    #     大小为 MxN 的矩阵 A。退出时，如果 SIDE = 'R'，则被 P*A 覆盖；
    #     如果 SIDE = 'L'，则被 A*P**T 覆盖。

    # LDA (input) INTEGER
    #     数组 A 的领先维度。LDA >= max(1,M)。

    # =====================================================================


    # 测试输入参数
    /* Parameter adjustments */
    --c__;                  /* c__ 是一个一维数组，参数向量 */
    --s;                    /* s 是一个一维数组，参数向量 */
    a_dim1 = *lda;          /* a_dim1 是矩阵 a 的第一维的维度 */
    a_offset = 1 + a_dim1;  /* 计算矩阵 a 的偏移量 */
    a -= a_offset;          /* 对矩阵 a 进行偏移 */

    /* Function Body */
    info = 0;               /* 初始化 info 变量为 0 */
    if (! (lsame_(side, "L") || lsame_(side, "R"))) {
        info = 1;           /* 如果 side 不是 "L" 或 "R"，则将 info 置为 1 */
    } else if (! (lsame_(pivot, "V") || lsame_(pivot, "T") || lsame_(pivot, "B"))) {
        info = 2;           /* 如果 pivot 不是 "V", "T", 或 "B"，则将 info 置为 2 */
    } else if (! (lsame_(direct, "F") || lsame_(direct, "B"))) {
        info = 3;           /* 如果 direct 不是 "F" 或 "B"，则将 info 置为 3 */
    } else if (*m < 0) {
        info = 4;           /* 如果 m 小于 0，则将 info 置为 4 */
    } else if (*n < 0) {
        info = 5;           /* 如果 n 小于 0，则将 info 置为 5 */
    } else if (*lda < max(1,*m)) {
        info = 9;           /* 如果 lda 小于 max(1,*m)，则将 info 置为 9 */
    }
    if (info != 0) {
        xerbla_("SLASR ", &info);  /* 如果 info 不为 0，调用错误处理例程 xerbla_ */
        return 0;           /* 返回 0 */
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0) {
        return 0;           /* 如果 m 或 n 为 0，直接返回 0 */
    }
    if (lsame_(side, "L")) {

        /* Form  P * A */

        if (lsame_(pivot, "V")) {
            if (lsame_(direct, "F")) {

                /* Case V and Forward */

                i__1 = *m - 1;
                for (j = 1; j <= i__1; ++j) {
                    ctemp = c__[j];             /* 获取 c[j] */
                    stemp = s[j];               /* 获取 s[j] */
                    if (ctemp != 1.f || stemp != 0.f) {  /* 如果 ctemp 不为 1 或 stemp 不为 0 */
                        i__2 = *n;
                        for (i__ = 1; i__ <= i__2; ++i__) {
                            temp = a[j + 1 + i__ * a_dim1];    /* 获取 a[j+1][i] */
                            a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp * a[j + i__ * a_dim1];  /* 更新 a[j+1][i] */
                            a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j + i__ * a_dim1];     /* 更新 a[j][i] */
                        }
                    }
                }

            } else if (lsame_(direct, "B")) {

                /* Case V and Backward */

                for (j = *m - 1; j >= 1; --j) {
                    ctemp = c__[j];             /* 获取 c[j] */
                    stemp = s[j];               /* 获取 s[j] */
                    if (ctemp != 1.f || stemp != 0.f) {  /* 如果 ctemp 不为 1 或 stemp 不为 0 */
                        i__1 = *n;
                        for (i__ = 1; i__ <= i__1; ++i__) {
                            temp = a[j + 1 + i__ * a_dim1];    /* 获取 a[j+1][i] */
                            a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp * a[j + i__ * a_dim1];  /* 更新 a[j+1][i] */
                            a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j + i__ * a_dim1];     /* 更新 a[j][i] */
                        }
                    }
                }

            }
        } else if (lsame_(pivot, "T")) {

            /* Case T */

            if (lsame_(direct, "F")) {
                i__1 = *m;
                for (j = 2; j <= i__1; ++j) {
                    ctemp = c__[j - 1];         /* 获取 c[j-1] */
                    stemp = s[j - 1];           /* 获取 s[j-1] */
                    if (ctemp != 1.f || stemp != 0.f) {  /* 如果 ctemp 不为 1 或 stemp 不为 0 */
                        i__2 = *n;
                        for (i__ = 1; i__ <= i__2; ++i__) {
                            temp = a[j + i__ * a_dim1];    /* 获取 a[j][i] */
                            a[j + i__ * a_dim1] = ctemp * temp - stemp * a[i__ * a_dim1 + 1];   /* 更新 a[j][i] */
                            a[i__ * a_dim1 + 1] = stemp * temp + ctemp * a[i__ * a_dim1 + 1];   /* 更新 a[i][1] */
                        }
                    }
                }
            }
        }
    }
/* L60: */
        }
        } else if (lsame_(direct, "B")) {
        /* 向后施加旋转至第一列 */
        for (j = *m; j >= 2; --j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1.f || stemp != 0.f) {
            /* 应用非平凡的 Givens 旋转 */
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = ctemp * temp - stemp * a[
                    i__ * a_dim1 + 1];
                a[i__ * a_dim1 + 1] = stemp * temp + ctemp * a[
                    i__ * a_dim1 + 1];
/* L70: */
            }
            }
/* L80: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        /* 向前施加旋转至最后一列 */
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            /* 应用非平凡的 Givens 旋转 */
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * a[*m + i__ * a_dim1]
                     + ctemp * temp;
                a[*m + i__ * a_dim1] = ctemp * a[*m + i__ *
                    a_dim1] - stemp * temp;
/* L90: */
            }
            }
/* L100: */
        }
        } else if (lsame_(direct, "B")) {
        /* 向后施加旋转至第一列 */
        for (j = *m - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            /* 应用非平凡的 Givens 旋转 */
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * a[*m + i__ * a_dim1]
                     + ctemp * temp;
                a[*m + i__ * a_dim1] = ctemp * a[*m + i__ *
                    a_dim1] - stemp * temp;
/* L110: */
            }
            }
/* L120: */
        }
        }
    }
    } else if (lsame_(side, "R")) {

/*        Form A * P' */

    if (lsame_(pivot, "V")) {
        if (lsame_(direct, "F")) {
        /* 向前施加旋转至最后一行 */
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            /* 应用非平凡的 Givens 旋转 */
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + (j + 1) * a_dim1];
                a[i__ + (j + 1) * a_dim1] = ctemp * temp - stemp *
                     a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * temp + ctemp * a[
                    i__ + j * a_dim1];
/* L130: */
            }
            }
/* L140: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + (j + 1) * a_dim1];
                a[i__ + (j + 1) * a_dim1] = ctemp * temp - stemp *
                     a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * temp + ctemp * a[
                    i__ + j * a_dim1];
/* L150: */
            }
            }
/* L160: */
        }
        }
    } else if (lsame_(pivot, "T")) {
        if (lsame_(direct, "F")) {
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = ctemp * temp - stemp * a[
                    i__ + a_dim1];
                a[i__ + a_dim1] = stemp * temp + ctemp * a[i__ +
                    a_dim1];
/* L170: */
            }
            }
/* L180: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *n; j >= 2; --j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = ctemp * temp - stemp * a[
                    i__ + a_dim1];
                a[i__ + a_dim1] = stemp * temp + ctemp * a[i__ +
                    a_dim1];
/* L190: */
            }
            }
/* L200: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * a[i__ + *n * a_dim1]
                     + ctemp * temp;
                a[i__ + *n * a_dim1] = ctemp * a[i__ + *n *
                    a_dim1] - stemp * temp;
/* L210: */
            }
            }
/* L220: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * a[i__ + *n * a_dim1]
                     + ctemp * temp;
                a[i__ + *n * a_dim1] = ctemp * a[i__ + *n *
                    a_dim1] - stemp * temp;
/* L230: */
            }
            }
/* L240: */
        }
        }
    }
    }
    # 返回整数值 0，结束函数执行并返回结果
    return 0;
/*     End of SLASR */

} /* slasr_ */

/* Subroutine */ int slasrt_(char *id, integer *n, real *d__, integer *info)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, j;
    static real d1, d2, d3;
    static integer dir;
    static real tmp;
    static integer endd;
    extern logical lsame_(char *, char *);
    static integer stack[64]    /* was [2][32] */;
    static real dmnmx;
    static integer start;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static integer stkpnt;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    Sort the numbers in D in increasing order (if ID = 'I') or
    in decreasing order (if ID = 'D' ).

    Use Quick Sort, reverting to Insertion sort on arrays of
    size <= 20. Dimension of STACK limits N to about 2**32.

    Arguments
    =========

    ID      (input) CHARACTER*1
            = 'I': sort D in increasing order;
            = 'D': sort D in decreasing order.

    N       (input) INTEGER
            The length of the array D.

    D       (input/output) REAL array, dimension (N)
            On entry, the array to be sorted.
            On exit, D has been sorted into increasing order
            (D(1) <= ... <= D(N) ) or into decreasing order
            (D(1) >= ... >= D(N) ), depending on ID.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input paramters.
*/

    /* Parameter adjustments */
    --d__;

    /* Function Body */
    *info = 0; // 初始化 INFO 为 0，表示成功退出
    dir = -1; // 初始化排序方向标志为 -1
    if (lsame_(id, "D")) { // 如果 ID 为 'D'，则设定排序为降序
    dir = 0;
    } else if (lsame_(id, "I")) { // 如果 ID 为 'I'，则设定排序为升序
    dir = 1;
    }
    if (dir == -1) { // 如果 dir 仍为 -1，表示未匹配到有效的排序标志
    *info = -1; // 设置 INFO 为 -1，表示 ID 参数错误
    } else if (*n < 0) { // 如果 N 小于 0
    *info = -2; // 设置 INFO 为 -2，表示 N 参数错误
    }
    if (*info != 0) { // 如果 INFO 不为 0，即有错误发生
    i__1 = -(*info); // 将 INFO 取负数作为参数调用错误处理函数
    xerbla_("SLASRT", &i__1);
    return 0; // 直接退出程序
    }

/*     Quick return if possible */

    if (*n <= 1) { // 如果 N 小于等于 1，已经有序或者无需排序
    return 0; // 直接退出程序
    }

    stkpnt = 1; // 初始化堆栈指针
    stack[0] = 1; // 初始化堆栈起始索引
    stack[1] = *n; // 初始化堆栈结束索引
L10:
    start = stack[(stkpnt << 1) - 2]; // 从堆栈中获取起始索引
    endd = stack[(stkpnt << 1) - 1]; // 从堆栈中获取结束索引
    --stkpnt; // 堆栈指针减一
    if (endd - start <= 20 && endd - start > 0) { // 如果子数组大小小于等于 20，使用插入排序

/*        Do Insertion sort on D( START:ENDD ) */

    if (dir == 0) { // 如果是降序排序

/*           Sort into decreasing order */

        i__1 = endd;
        for (i__ = start + 1; i__ <= i__1; ++i__) {
        i__2 = start + 1;
        for (j = i__; j >= i__2; --j) {
            if (d__[j] > d__[j - 1]) { // 如果当前元素大于前一个元素，交换它们
            dmnmx = d__[j];
            d__[j] = d__[j - 1];
            d__[j - 1] = dmnmx;
            } else {
            goto L30; // 否则跳出内层循环
            }
/* L20: */
        }
L30:
        ;
        }

    } else { // 如果是升序排序
/*           Sort into increasing order */
/* 将数组 d__ 中的元素按升序排列 */

        i__1 = endd;
        for (i__ = start + 1; i__ <= i__1; ++i__) {
/* 循环从 start+1 到 endd */
        i__2 = start + 1;
        for (j = i__; j >= i__2; --j) {
/* 嵌套循环，从 i__ 到 start+1，用于比较和交换元素 */
            if (d__[j] < d__[j - 1]) {
/* 如果当前元素小于前一个元素，则交换它们 */
            dmnmx = d__[j];
            d__[j] = d__[j - 1];
            d__[j - 1] = dmnmx;
            } else {
/* 否则跳到标签 L50 */
            goto L50;
            }
/* L40: */
        }
L50:
/* 标签 L50，用于跳出内层循环 */
        ;
        }

    }

    } else if (endd - start > 20) {

/*
          Partition D( START:ENDD ) and stack parts, largest one first

          Choose partition entry as median of 3
*/
/* 对 D(START:ENDD) 进行分区并堆栈部分，先处理最大的部分 */

    d1 = d__[start];
    d2 = d__[endd];
    i__ = (start + endd) / 2;
    d3 = d__[i__];
    if (d1 < d2) {
        if (d3 < d1) {
        dmnmx = d1;
        } else if (d3 < d2) {
        dmnmx = d3;
        } else {
        dmnmx = d2;
        }
    } else {
        if (d3 < d2) {
        dmnmx = d2;
        } else if (d3 < d1) {
        dmnmx = d3;
        } else {
        dmnmx = d1;
        }
    }

    if (dir == 0) {

/*           Sort into decreasing order */
/* 将数组 d__ 中的元素按降序排列 */

        i__ = start - 1;
        j = endd + 1;
L60:
/* 标签 L60 */
L70:
/* 标签 L70 */
        --j;
        if (d__[j] < dmnmx) {
/* 如果当前元素小于 dmnmx，则跳到 L70 */
        goto L70;
        }
L80:
/* 标签 L80 */
        ++i__;
        if (d__[i__] > dmnmx) {
/* 如果当前元素大于 dmnmx，则跳到 L80 */
        goto L80;
        }
        if (i__ < j) {
/* 如果 i__ 小于 j，则交换这两个元素 */
        tmp = d__[i__];
        d__[i__] = d__[j];
        d__[j] = tmp;
        goto L60;
        }
/* 如果 j-start 大于 endd-j-1，则将两部分入栈 */
        if (j - start > endd - j - 1) {
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        } else {
/* 否则，将较小的部分先入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        }
    } else {

/*           Sort into increasing order */
/* 将数组 d__ 中的元素按升序排列 */

        i__ = start - 1;
        j = endd + 1;
L90:
/* 标签 L90 */
L100:
/* 标签 L100 */
        --j;
        if (d__[j] > dmnmx) {
/* 如果当前元素大于 dmnmx，则跳到 L100 */
        goto L100;
        }
L110:
/* 标签 L110 */
        ++i__;
        if (d__[i__] < dmnmx) {
/* 如果当前元素小于 dmnmx，则跳到 L110 */
        goto L110;
        }
        if (i__ < j) {
/* 如果 i__ 小于 j，则交换这两个元素 */
        tmp = d__[i__];
        d__[i__] = d__[j];
        d__[j] = tmp;
        goto L90;
        }
/* 如果 j-start 大于 endd-j-1，则将两部分入栈 */
        if (j - start > endd - j - 1) {
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        } else {
/* 否则，将较小的部分先入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        }
    }
    }
    if (stkpnt > 0) {
/* 如果栈中有元素，则跳到 L10 */
    goto L10;
    }
/* 如果栈为空，则返回 0 */
    return 0;

/*     End of SLASRT */

} /* slasrt_ */

/* Subroutine */ int slassq_(integer *n, real *x, integer *incx, real *scale,
    real *sumsq)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1;

    /* 定义实数变量 r__1 */

    /* Local variables */
    static integer ix;
    /* 声明静态整型变量 ix */
    static real absxi;
    /* 声明静态实数变量 absxi */
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASSQ  returns the values  scl  and  smsq  such that

       ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
    assumed to be non-negative and  scl  returns the value

       scl = max( scale, abs( x( i ) ) ).

    scale and sumsq must be supplied in SCALE and SUMSQ and
    scl and smsq are overwritten on SCALE and SUMSQ respectively.

    The routine makes only one pass through the vector x.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.

    X       (input) REAL array, dimension (N)
            The vector for which a scaled sum of squares is computed.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.

    SCALE   (input/output) REAL
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with  scl , the scaling factor
            for the sum of squares.

    SUMSQ   (input/output) REAL
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with  smsq , the basic sum of
            squares from which  scl  has been factored out.

   =====================================================================
*/


    /* Parameter adjustments */
    --x;  // Adjust the array indexing to start from 0 instead of 1

    /* Function Body */
    if (*n > 0) {  // Check if the number of elements is positive
    i__1 = (*n - 1) * *incx + 1;  // Calculate the upper limit for iteration
    i__2 = *incx;  // Set the increment for the loop
    for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {  // Loop over the vector X
        if (x[ix] != 0.f) {  // Check if the current element of X is non-zero
        absxi = (r__1 = x[ix], dabs(r__1));  // Compute the absolute value of x[ix]
        if (*scale < absxi) {  // Compare scale with absxi
/* Computing 2nd power */
            r__1 = *scale / absxi;  // Compute the square of the ratio scale/absxi
            *sumsq = *sumsq * (r__1 * r__1) + 1;  // Update sumsq using the computed square
            *scale = absxi;  // Update scale to absxi
        } else {
/* Computing 2nd power */
            r__1 = absxi / *scale;  // Compute the square of the ratio absxi/scale
            *sumsq += r__1 * r__1;  // Update sumsq using the computed square
        }
        }
/* L10: */
    }
    }
    return 0;  // Return 0 to indicate successful completion

/*     End of SLASSQ */

} /* slassq_ */

/* Subroutine */ int slasv2_(real *f, real *g, real *h__, real *ssmin, real *
    ssmax, real *snr, real *csr, real *snl, real *csl)
{
    /* System generated locals */
    real r__1;

    /* Local variables */
    static real a, d__, l, m, r__, s, t, fa, ga, ha, ft, gt, ht, mm, tt, clt,
        crt, slt, srt;
    static integer pmax;
    static real temp;
    static logical swap;
    static real tsign;
    static logical gasmal;
    extern doublereal slamch_(char *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --

*/
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


# 提供代码的版权信息和编写日期



    Purpose
    =======


# 说明此程序的目的和功能



    SLASV2 computes the singular value decomposition of a 2-by-2
    triangular matrix
       [  F   G  ]
       [  0   H  ].


# SLASV2 计算一个2x2上三角矩阵的奇异值分解
# 矩阵结构为：
#   [ F  G ]
#   [ 0  H ]



    On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
    smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
    right singular vectors for abs(SSMAX), giving the decomposition


# 函数返回时，abs(SSMAX)是较大的奇异值，abs(SSMIN)是较小的奇异值，
# (CSL, SNL)和(CSR, SNR)分别是 abs(SSMAX) 对应的左奇异向量和右奇异向量，
# 完成分解：
#   [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
#   [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].



    Arguments
    =========


# 下面列出了函数的参数说明



    F       (input) REAL
            The (1,1) element of the 2-by-2 matrix.


# 输入参数 F 是 2x2 矩阵的 (1,1) 元素



    G       (input) REAL
            The (1,2) element of the 2-by-2 matrix.


# 输入参数 G 是 2x2 矩阵的 (1,2) 元素



    H       (input) REAL
            The (2,2) element of the 2-by-2 matrix.


# 输入参数 H 是 2x2 矩阵的 (2,2) 元素



    SSMIN   (output) REAL
            abs(SSMIN) is the smaller singular value.


# 输出参数 SSMIN 是较小的奇异值的绝对值



    SSMAX   (output) REAL
            abs(SSMAX) is the larger singular value.


# 输出参数 SSMAX 是较大的奇异值的绝对值



    SNL     (output) REAL
    CSL     (output) REAL
            The vector (CSL, SNL) is a unit left singular vector for the
            singular value abs(SSMAX).


# 输出参数 (CSL, SNL) 是 abs(SSMAX) 对应的单位左奇异向量



    SNR     (output) REAL
    CSR     (output) REAL
            The vector (CSR, SNR) is a unit right singular vector for the
            singular value abs(SSMAX).


# 输出参数 (CSR, SNR) 是 abs(SSMAX) 对应的单位右奇异向量



    Further Details
    ===============


# 提供进一步的细节说明



    Any input parameter may be aliased with any output parameter.


# 任何输入参数都可能与任何输出参数重叠



    Barring over/underflow and assuming a guard digit in subtraction, all
    output quantities are correct to within a few units in the last
    place (ulps).


# 忽略过度/欠流动并假设减法中有一个保护数字，所有输出量在最后一位上都正确到几个单位（ulps）



    In IEEE arithmetic, the code works correctly if one matrix element is
    infinite.


# 在 IEEE 算术中，如果一个矩阵元素是无限的，代码将正确运行



    Overflow will not occur unless the largest singular value itself
    overflows or is within a few ulps of overflow. (On machines with
    partial overflow, like the Cray, overflow may occur if the largest
    singular value is within a factor of 2 of overflow.)


# 除非最大奇异值本身溢出或接近溢出的几个 ulps，否则不会发生溢出。（在存在部分溢出的机器上，如 Cray，如果最大奇异值接近溢出的两倍，则可能发生溢出）



    Underflow is harmless if underflow is gradual. Otherwise, results
    may correspond to a matrix modified by perturbations of size near
    the underflow threshold.


# 如果下溢是渐进的，则下溢是无害的。否则，结果可能与在接近下溢阈值的大小的扰动下被修改的矩阵相对应



   =====================================================================


# 分隔线，标记文档的结尾
/*
       PMAX points to the maximum absolute element of matrix
         PMAX = 1 if F largest in absolute values
         PMAX = 2 if G largest in absolute values
         PMAX = 3 if H largest in absolute values
*/
ft = *f;
fa = dabs(ft);
ht = *h__;
ha = dabs(*h__);

/*
       PMAX points to the maximum absolute element of matrix
         PMAX = 1 if F largest in absolute values
         PMAX = 2 if G largest in absolute values
         PMAX = 3 if H largest in absolute values
*/
pmax = 1;
swap = ha > fa;
if (swap) {
pmax = 3;
temp = ft;
ft = ht;
ht = temp;
temp = fa;
fa = ha;
ha = temp;

/*        Now FA .ge. HA */

}
gt = *g;
ga = dabs(gt);
if (ga == 0.f) {

/*        Diagonal matrix */

*ssmin = ha;
*ssmax = fa;
clt = 1.f;
crt = 1.f;
slt = 0.f;
srt = 0.f;
} else {
gasmal = TRUE_;
if (ga > fa) {
pmax = 2;
if (fa / ga < slamch_("EPS")) {

/*              Case of very large GA */

gasmal = FALSE_;
*ssmax = ga;
if (ha > 1.f) {
*ssmin = fa / (ga / ha);
} else {
*ssmin = fa / ga * ha;
}
clt = 1.f;
slt = ht / gt;
srt = 1.f;
crt = ft / gt;
}
}
if (gasmal) {

/*           Normal case */

d__ = fa - ha;
if (d__ == fa) {

/*              Copes with infinite F or H */

l = 1.f;
} else {
l = d__ / fa;
}

/*           Note that 0 .le. L .le. 1 */

m = gt / ft;

/*           Note that abs(M) .le. 1/macheps */

t = 2.f - l;

/*           Note that T .ge. 1 */

mm = m * m;
tt = t * t;
s = sqrt(tt + mm);

/*           Note that 1 .le. S .le. 1 + 1/macheps */

if (l == 0.f) {
r__ = dabs(m);
} else {
r__ = sqrt(l * l + mm);
}

/*           Note that 0 .le. R .le. 1 + 1/macheps */

a = (s + r__) * .5f;

/*           Note that 1 .le. A .le. 1 + abs(M) */

*ssmin = ha / a;
*ssmax = fa * a;
if (mm == 0.f) {

/*              Note that M is very tiny */

if (l == 0.f) {
t = r_sign(&c_b3178, &ft) * r_sign(&c_b15, &gt);
} else {
t = gt / r_sign(&d__, &ft) + m / t;
}
} else {
t = (m / (s + t) + m / (r__ + l)) * (a + 1.f);
}
l = sqrt(t * t + 4.f);
crt = 2.f / l;
srt = t / l;
clt = (crt + srt * m) / a;
slt = ht / ft * srt / a;
}
}
if (swap) {
*csl = srt;
*snl = crt;
*csr = slt;
*snr = clt;
} else {
*csl = clt;
*snl = slt;
*csr = crt;
*snr = srt;
}

/*     Correct signs of SSMAX and SSMIN */

if (pmax == 1) {
tsign = r_sign(&c_b15, csr) * r_sign(&c_b15, csl) * r_sign(&c_b15, f);
}
if (pmax == 2) {
tsign = r_sign(&c_b15, snr) * r_sign(&c_b15, csl) * r_sign(&c_b15, g);
}
if (pmax == 3) {
tsign = r_sign(&c_b15, snr) * r_sign(&c_b15, snl) * r_sign(&c_b15,
h__);
}
*ssmax = r_sign(ssmax, &tsign);
r__1 = tsign * r_sign(&c_b15, f) * r_sign(&c_b15, h__);
    *ssmin = r_sign(ssmin, &r__1);
    return 0;



    // 调用 r_sign 函数，并将返回值赋给 ssmin 指针指向的位置
    *ssmin = r_sign(ssmin, &r__1);
    // 返回整数值 0，表示函数执行成功
    return 0;
/*     End of SLASV2 */

} /* slasv2_ */

/* Subroutine */ int slaswp_(integer *n, real *a, integer *lda, integer *k1,
    integer *k2, integer *ipiv, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    static real temp;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASWP performs a series of row interchanges on the matrix A.
    One row interchange is initiated for each of rows K1 through K2 of A.

    Arguments
    =========

    N       (input) INTEGER
            The number of columns of the matrix A.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the matrix of column dimension N to which the row
            interchanges will be applied.
            On exit, the permuted matrix.

    LDA     (input) INTEGER
            The leading dimension of the array A.

    K1      (input) INTEGER
            The first element of IPIV for which a row interchange will
            be done.

    K2      (input) INTEGER
            The last element of IPIV for which a row interchange will
            be done.

    IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
            The vector of pivot indices.  Only the elements in positions
            K1 through K2 of IPIV are accessed.
            IPIV(K) = L implies rows K and L are to be interchanged.

    INCX    (input) INTEGER
            The increment between successive values of IPIV.  If IPIV
            is negative, the pivots are applied in reverse order.

    Further Details
    ===============

    Modified by
     R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA

   =====================================================================


       Interchange row I with row IPIV(I) for each of rows K1 through K2.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    if (*incx > 0) {
        ix0 = *k1;
        i1 = *k1;
        i2 = *k2;
        inc = 1;
    } else if (*incx < 0) {
        ix0 = (1 - *k2) * *incx + 1;
        i1 = *k2;
        i2 = *k1;
        inc = -1;
    } else {
        return 0;
    }

    n32 = *n / 32 << 5;
    if (n32 != 0) {
        /* Loop over blocks of 32 columns */
        i__1 = n32;
        for (j = 1; j <= i__1; j += 32) {
            ix = ix0;
            /* Loop over rows to be interchanged */
            i__2 = i2;
            i__3 = inc;
            for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3)
            {
                /* Determine the row index to swap with */
                ip = ipiv[ix];
                /* If the row index differs, perform the row interchange */
                if (ip != i__) {
                    /* Loop over columns within the block */
                    i__4 = j + 31;
                    for (k = j; k <= i__4; ++k) {
                        temp = a[i__ + k * a_dim1];
                        a[i__ + k * a_dim1] = a[ip + k * a_dim1];
                        a[ip + k * a_dim1] = temp;
                    }
                }
                /* Move to the next index in the pivot array */
                ix += *incx;
            }
        }
    }

    /* End of SLASWP */
} /* slaswp_ */


注释：


/*     End of SLASV2 */
这一行是标识 SLASV2 子程序的结尾。

} /* slasv2_ */
结束 slasv2_ 子程序。

/* Subroutine */ int slaswp_(integer *n, real *a, integer *lda, integer *k1,
    integer *k2, integer *ipiv, integer *incx)
定义 SLASWP 子程序，用于在矩阵 A 上执行一系列行置换。

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
系统生成的局部变量声明，包括数组索引和循环控制变量。

    /* Local variables */
    static integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    static real temp;
静态局部变量声明，包括循环变量和临时变量。

    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
此处注释标识了 LAPACK 辅助例程的版本和提供者信息。

    Purpose
    =======
此注释说明了 SLASWP 子程序的目的，即在矩阵 A 上执行一系列行置换。

    Arguments
    ==========
此注释开始列出 SLASWP 子程序的参数说明。

    N       (input) INTEGER
输入参数，矩阵 A 的列数。

    A       (input/output) REAL array, dimension (LDA,N)
输入/输出参数，维度为 (LDA,N) 的实数数组，输入时为待置换行的矩阵 A，输出时为置换后的矩阵。

    LDA     (input) INTEGER
输入参数，矩阵 A 的首维度。

    K1      (input) INTEGER
输入参数，IPIV 中第一个需要进行行置换的元素索引。

    K2      (input) INTEGER
输入参数，IPIV 中最后一个需要进行行置换的元素索引。

    IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
输入参数，整型数组，维度为 K2*abs(INCX)，存储行置换的索引信息。

    INCX    (input) INTEGER
输入参数，IPIV 中连续值之间的增量。若为负数，行置换将以相反顺序应用。

    Further Details
    ===============
此注释提供了 SLASWP 子程序的更多细节，指出其修改者和其他相关信息。

    Modified by
     R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
此处标识了子程序的修改者和所属单位。

   =====================================================================


       Interchange row I with row IPIV(I) for each of rows K1 through K2.
此注释描述了程序实现的核心功能，即对矩阵 A 的每一行进行行置换。

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
此处调整参数，确保能够正确访问数组 A 和 IPIV。

    /* Function Body */
    if (*incx > 0) {
        ix0 = *k1;
        i1 = *k1;
        i2 = *k2;
        inc = 1;
    } else if (*incx < 0) {
        ix0 = (1 - *k2) * *incx + 1;
        i1 = *k2;
        i2 = *k1;
        inc = -1;
    } else {
        return 0;
    }
此处根据 INCX 的正负确定循环控制变量的起始值和增量。

    n32 = *n / 32 << 5;
    if (n32 != 0) {
        /* Loop over blocks of 32 columns */
        i__1 = n32;
        for (j = 1; j <= i__1; j += 32) {
            ix = ix0;
            /* Loop over rows to be interchanged */
            i__2 = i2;
            i__3 = inc;
            for (i__ = i1
/* L10: */
            }
        }
        ix += *incx;
/* L20: */
        }
/* L30: */
    }
    }
    if (n32 != *n) {
    ++n32;
    ix = ix0;
    i__1 = i2;
    i__3 = inc;
    for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
        ip = ipiv[ix];
        if (ip != i__) {
        i__2 = *n;
        for (k = n32; k <= i__2; ++k) {
            temp = a[i__ + k * a_dim1];
            a[i__ + k * a_dim1] = a[ip + k * a_dim1];
            a[ip + k * a_dim1] = temp;
/* L40: */
        }
        }
        ix += *incx;
/* L50: */
    }
    }

    return 0;

/*     End of SLASWP */

} /* slaswp_ */

/* Subroutine */ int slasy2_(logical *ltranl, logical *ltranr, integer *isgn,
    integer *n1, integer *n2, real *tl, integer *ldtl, real *tr, integer *
    ldtr, real *b, integer *ldb, real *scale, real *x, integer *ldx, real
    *xnorm, integer *info)
{
    /* Initialized data */

    static integer locu12[4] = { 3,4,1,2 };
    static integer locl21[4] = { 2,1,4,3 };
    static integer locu22[4] = { 4,3,2,1 };
    static logical xswpiv[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical bswpiv[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };

    /* System generated locals */
    integer b_dim1, b_offset, tl_dim1, tl_offset, tr_dim1, tr_offset, x_dim1,
        x_offset;
    real r__1, r__2, r__3, r__4, r__5, r__6, r__7, r__8;

    /* Local variables */
    static integer i__, j, k;
    static real x2[2], l21, u11, u12;
    static integer ip, jp;
    static real u22, t16[16]    /* was [4][4] */, gam, bet, eps, sgn, tmp[4],
        tau1, btmp[4], smin;
    static integer ipiv;
    static real temp;
    static integer jpiv[4];
    static real xmax;
    static integer ipsv, jpsv;
    static logical bswap;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *), sswap_(integer *, real *, integer *, real *, integer *
        );
    static logical xswap;
    extern doublereal slamch_(char *);
    extern integer isamax_(integer *, real *, integer *);
    static real smlnum;


/* 
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in

           op(TL)*X + ISGN*X*op(TR) = SCALE*B,

    where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
    -1.  op(T) = T or T', where T' denotes the transpose of T.

    Arguments
    =========

    LTRANL  (input) LOGICAL
            On entry, LTRANL specifies the op(TL):
               = .FALSE., op(TL) = TL,
               = .TRUE., op(TL) = TL'.

    LTRANR  (input) LOGICAL
            On entry, LTRANR specifies the op(TR):
              = .FALSE., op(TR) = TR,
              = .TRUE., op(TR) = TR'.
    ISGN    (input) INTEGER
            输入参数，指定方程的符号。
            只能为1或-1。

    N1      (input) INTEGER
            输入参数，指定矩阵TL的阶数。
            只能为0、1或2。

    N2      (input) INTEGER
            输入参数，指定矩阵TR的阶数。
            只能为0、1或2。

    TL      (input) REAL array, dimension (LDTL,2)
            输入参数，包含一个N1 × N1的矩阵。

    LDTL    (input) INTEGER
            矩阵TL的领先维度。LDTL >= max(1,N1)。

    TR      (input) REAL array, dimension (LDTR,2)
            输入参数，包含一个N2 × N2的矩阵。

    LDTR    (input) INTEGER
            矩阵TR的领先维度。LDTR >= max(1,N2)。

    B       (input) REAL array, dimension (LDB,2)
            输入参数，包含方程的右侧。
            是一个N1 × N2的矩阵。

    LDB     (input) INTEGER
            矩阵B的领先维度。LDB >= max(1,N1)。

    SCALE   (output) REAL
            输出参数，包含缩放因子。
            缩放因子小于或等于1，以防止解溢出。

    X       (output) REAL array, dimension (LDX,2)
            输出参数，包含N1 × N2的解。

    LDX     (input) INTEGER
            矩阵X的领先维度。LDX >= max(1,N1)。

    XNORM   (output) REAL
            输出参数，是解的无穷范数。

    INFO    (output) INTEGER
            输出参数，指示返回状态：
               0: 成功返回。
               1: TL和TR具有太接近的特征值，因此TL或TR被扰动以获得非奇异方程。
            注意：为了提高速度，此例程不检查输入错误。
    /* Parameter adjustments */
    tl_dim1 = *ldtl;  // 从参数中获取 tl 的第一维度大小
    tl_offset = 1 + tl_dim1;  // 计算 tl 数组的偏移量
    tl -= tl_offset;  // 调整 tl 指针，使其指向正确的起始位置
    tr_dim1 = *ldtr;  // 从参数中获取 tr 的第一维度大小
    tr_offset = 1 + tr_dim1;  // 计算 tr 数组的偏移量
    tr -= tr_offset;  // 调整 tr 指针，使其指向正确的起始位置
    b_dim1 = *ldb;  // 从参数中获取 b 的第一维度大小
    b_offset = 1 + b_dim1;  // 计算 b 数组的偏移量
    b -= b_offset;  // 调整 b 指针，使其指向正确的起始位置
    x_dim1 = *ldx;  // 从参数中获取 x 的第一维度大小
    x_offset = 1 + x_dim1;  // 计算 x 数组的偏移量
    x -= x_offset;  // 调整 x 指针，使其指向正确的起始位置

    /* Function Body */

    /* Do not check the input parameters for errors */

    *info = 0;  // 将 info 参数初始化为 0

    /* Quick return if possible */

    if (*n1 == 0 || *n2 == 0) {
        return 0;  // 如果 n1 或 n2 为 0，则直接返回
    }

    /* Set constants to control overflow */

    eps = slamch_("P");  // 获取机器精度 eps
    smlnum = slamch_("S") / eps;  // 获取小常数 smlnum
    sgn = (real) (*isgn);  // 将 isgn 转换为实数类型，并赋值给 sgn

    k = *n1 + *n1 + *n2 - 2;  // 计算 k 的值
    switch (k) {
    case 1:  goto L10;  // 根据 k 的值跳转到不同的处理分支
    case 2:  goto L20;
    case 3:  goto L30;
    case 4:  goto L50;
    }

    /* 1 by 1: TL11*X + SGN*X*TR11 = B11 */

L10:
    tau1 = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];  // 计算 tau1
    bet = dabs(tau1);  // 计算 bet 的绝对值
    if (bet <= smlnum) {
        tau1 = smlnum;  // 如果 bet 小于等于 smlnum，则将 tau1 设置为 smlnum
        bet = smlnum;  // 同时将 bet 设置为 smlnum
        *info = 1;  // 设置 info 为 1，表示出现了问题
    }

    *scale = 1.f;  // 初始化 scale 参数为 1
    gam = (r__1 = b[b_dim1 + 1], dabs(r__1));  // 计算 gam 的绝对值
    if (smlnum * gam > bet) {
        *scale = 1.f / gam;  // 如果条件满足，更新 scale 参数的值
    }

    x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / tau1;  // 计算 x 的值
    *xnorm = (r__1 = x[x_dim1 + 1], dabs(r__1));  // 计算 xnorm 的绝对值
    return 0;  // 返回值为 0，表示成功执行

/*
       1 by 2:
       TL11*[X11 X12] + ISGN*[X11 X12]*op[TR11 TR12]  = [B11 B12]
                                         [TR21 TR22]
*/

L20:

/*
   Computing MAX
   Computing MAX
*/
    r__7 = (r__1 = tl[tl_dim1 + 1], dabs(r__1)), r__8 = (r__2 = tr[tr_dim1 +
        1], dabs(r__2)), r__7 = max(r__7,r__8), r__8 = (r__3 = tr[(
        tr_dim1 << 1) + 1], dabs(r__3)), r__7 = max(r__7,r__8), r__8 = (
        r__4 = tr[tr_dim1 + 2], dabs(r__4)), r__7 = max(r__7,r__8), r__8 =
         (r__5 = tr[(tr_dim1 << 1) + 2], dabs(r__5));
    r__6 = eps * dmax(r__7,r__8);  // 计算 smin 的值
    smin = dmax(r__6,smlnum);  // 获取 smin 的最大值
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];  // 计算 tmp 数组的第一个元素
    tmp[3] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];  // 计算 tmp 数组的第四个元素
    if (*ltranr) {
        tmp[1] = sgn * tr[tr_dim1 + 2];  // 根据 ltranr 参数更新 tmp 数组的第二个元素
        tmp[2] = sgn * tr[(tr_dim1 << 1) + 1];  // 根据 ltranr 参数更新 tmp 数组的第三个元素
    } else {
        tmp[1] = sgn * tr[(tr_dim1 << 1) + 1];  // 根据 ltranr 参数更新 tmp 数组的第二个元素
        tmp[2] = sgn * tr[tr_dim1 + 2];  // 根据 ltranr 参数更新 tmp 数组的第三个元素
    }
    btmp[0] = b[b_dim1 + 1];  // 更新 btmp 数组的第一个元素
    btmp[1] = b[(b_dim1 << 1) + 1];  // 更新 btmp 数组的第二个元素
    goto L40;  // 跳转到标签 L40 处继续执行

/*
       2 by 1:
            op[TL11 TL12]*[X11] + ISGN* [X11]*TR11  = [B11]
              [TL21 TL22] [X21]         [X21]         [B21]
*/

L30:
/*
   Computing MAX
   Computing MAX
*/
    r__7 = (r__1 = tr[tr_dim1 + 1], dabs(r__1)), r__8 = (r__2 = tl[tl_dim1 +
        1], dabs(r__2)), r__7 = max(r__7,r__8), r__8 = (r__3 = tl[(
        tl_dim1 << 1) + 1], dabs(r__3)), r__7 = max(r__7,r__8), r__8 = (
        r__4 = tl[tl_dim1 + 2], dabs(r__4)), r__7 = max(r__7,r__8), r__8 =
         (r__5 = tl[(tl_dim1 << 1) + 2], dabs(r__5));
    r__6 = eps * dmax(r__7,r__8);  // 计算 smin 的值
    smin = dmax(r__6,smlnum);  // 获取 smin 的最大值
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];  // 计算 tmp 数组的第一个元素
    tmp[3] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];  // 计算 tmp 数组的第四个元素
    if (*ltranl) {
        tmp[1] = tl[(tl_dim1 << 1) + 1];  // 根据 ltranl 参数更新 tmp 数组的第二个元素
        tmp[2] = tl[tl_dim1 + 2];  // 根据 ltranl 参数更新 tmp 数组的第三个元素
    } else {
        tmp[1] = tl[tl_dim1 + 2];  // 根据 ltranl 参数更新 tmp 数组的
    # 如果条件成立，将数组 tl 中的第三个元素赋值给 tmp 数组的第三个位置
    tmp[2] = tl[tl_dim1 + 2];
    # 如果条件不成立，将数组 tl 中的第三个元素赋值给 tmp 数组的第二个位置
    } else {
    tmp[1] = tl[tl_dim1 + 2];
    # 将数组 tl 中的第一个元素赋值给 tmp 数组的第一个位置
    tmp[2] = tl[(tl_dim1 << 1) + 1];
    }
    # 将数组 b 中的第二个元素赋值给 btmp 数组的第一个位置
    btmp[0] = b[b_dim1 + 1];
    # 将数组 b 中的第三个元素赋值给 btmp 数组的第二个位置
    btmp[1] = b[b_dim1 + 2];
L40:
/*
       Solve 2 by 2 system using complete pivoting.
       Set pivots less than SMIN to SMIN.
*/
    ipiv = isamax_(&c__4, tmp, &c__1);  // Find index of maximum absolute value in tmp array
    u11 = tmp[ipiv - 1];  // Select pivot element u11
    if (dabs(u11) <= smin) {  // Check if pivot is less than or equal to threshold smin
        *info = 1;  // Set info to 1 indicating issues with pivot
        u11 = smin;  // Set pivot u11 to smin
    }
    u12 = tmp[locu12[ipiv - 1] - 1];  // Select u12 using pivot index ipiv
    l21 = tmp[locl21[ipiv - 1] - 1] / u11;  // Compute l21
    u22 = tmp[locu22[ipiv - 1] - 1] - u12 * l21;  // Compute u22
    xswap = xswpiv[ipiv - 1];  // Determine if swapping is necessary for x vector
    bswap = bswpiv[ipiv - 1];  // Determine if swapping is necessary for btmp vector
    if (dabs(u22) <= smin) {  // Check if u22 is less than or equal to smin
        *info = 1;  // Set info to 1 indicating issues with pivot
        u22 = smin;  // Set pivot u22 to smin
    }
    if (bswap) {  // If bswap is true, perform temporary variable swap
        temp = btmp[1];
        btmp[1] = btmp[0] - l21 * temp;
        btmp[0] = temp;
    } else {  // Otherwise, update btmp directly
        btmp[1] -= l21 * btmp[0];
    }
    *scale = 1.f;  // Initialize scaling factor
    if (smlnum * 2.f * dabs(btmp[1]) > dabs(u22) || smlnum * 2.f * dabs(btmp[0]) > dabs(u11)) {
/* Computing MAX */
        r__1 = dabs(btmp[0]), r__2 = dabs(btmp[1]);
        *scale = .5f / dmax(r__1,r__2);  // Compute scaling factor based on btmp and pivots
        btmp[0] *= *scale;  // Apply scaling to btmp
        btmp[1] *= *scale;
    }
    x2[1] = btmp[1] / u22;  // Solve for x2[1]
    x2[0] = btmp[0] / u11 - u12 / u11 * x2[1];  // Solve for x2[0]
    if (xswap) {  // If xswap is true, swap x2[0] and x2[1]
        temp = x2[1];
        x2[1] = x2[0];
        x2[0] = temp;
    }
    x[x_dim1 + 1] = x2[0];  // Store result in x array
    if (*n1 == 1) {  // Check if n1 is 1
        x[(x_dim1 << 1) + 1] = x2[1];  // Store x2[1] in extended x array
        *xnorm = (r__1 = x[x_dim1 + 1], dabs(r__1)) + (r__2 = x[(x_dim1 << 1) + 1], dabs(r__2));  // Compute xnorm
    } else {  // Otherwise
        x[x_dim1 + 2] = x2[1];  // Store x2[1] in next position of x array
/* Computing MAX */
        r__3 = (r__1 = x[x_dim1 + 1], dabs(r__1)), r__4 = (r__2 = x[x_dim1 + 2], dabs(r__2));
        *xnorm = dmax(r__3,r__4);  // Compute xnorm
    }
    return 0;  // Return success

/*
       2 by 2:
       op[TL11 TL12]*[X11 X12] +ISGN* [X11 X12]*op[TR11 TR12] = [B11 B12]
         [TL21 TL22] [X21 X22]        [X21 X22]   [TR21 TR22]   [B21 B22]

       Solve equivalent 4 by 4 system using complete pivoting.
       Set pivots less than SMIN to SMIN.
*/

L50:
/* Computing MAX */
    r__5 = (r__1 = tr[tr_dim1 + 1], dabs(r__1)), r__6 = (r__2 = tr[(tr_dim1 << 1) + 1], dabs(r__2)), r__5 = max(r__5,r__6), r__6 = (r__3 = tr[tr_dim1 + 2], dabs(r__3)), r__5 = max(r__5,r__6), r__6 = (r__4 = tr[(tr_dim1 << 1) + 2], dabs(r__4));
    smin = dmax(r__5,r__6);  // Compute smin based on elements of tr matrix
/* Computing MAX */
    r__5 = smin, r__6 = (r__1 = tl[tl_dim1 + 1], dabs(r__1)), r__5 = max(r__5, r__6), r__6 = (r__2 = tl[(tl_dim1 << 1) + 1], dabs(r__2)), r__5 = max(r__5,r__6), r__6 = (r__3 = tl[tl_dim1 + 2], dabs(r__3)), r__5 = max(r__5,r__6), r__6 = (r__4 = tl[(tl_dim1 << 1) + 2], dabs(r__4));
    smin = dmax(r__5,r__6);  // Update smin considering elements of tl matrix
/* Computing MAX */
    r__1 = eps * smin;
    smin = dmax(r__1,smlnum);  // Adjust smin based on eps and smlnum
    btmp[0] = 0.f;  // Initialize btmp[0]
    scopy_(&c__16, btmp, &c__0, t16, &c__1);  // Copy btmp to t16 array
    t16[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];  // Compute elements of t16 matrix
    t16[5] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];
    t16[10] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];
    t16[15] = tl[(tl_dim1 << 1) + 2] + sgn * tr[(tr_dim1 << 1) + 2];
    if (*ltranl) {  // Check if ltranl is true
        t16[4] = tl[tl_dim1 + 2];  // Assign elements of t16 accordingly
        t16[1] = tl[(tl_dim1 << 1) + 1];
        t16[14] = tl[tl_dim1 + 2];
        t16[11] = tl[(tl_dim1 << 1) + 1];
    } else {  // Otherwise

        // Assign elements of t16 matrix differently based on ltranl
        t16[4] = tl[tl_dim1 + 2];
        t16[1] = tl[(tl_dim1 << 1) + 1];
        t16[14] = tl[tl_dim1 + 2];
        t16[11] = tl[(tl_dim1 << 1) + 1];
    }
    # 将数组 tl 的特定索引赋值给数组 t16 的对应位置
    t16[4] = tl[(tl_dim1 << 1) + 1];
    # 将数组 tl 的特定索引赋值给数组 t16 的对应位置
    t16[1] = tl[tl_dim1 + 2];
    # 将数组 tl 的特定索引赋值给数组 t16 的对应位置
    t16[14] = tl[(tl_dim1 << 1) + 1];
    # 将数组 tl 的特定索引赋值给数组 t16 的对应位置
    t16[11] = tl[tl_dim1 + 2];
    }

    # 如果 ltranr 指向的值为真，则执行以下操作
    if (*ltranr) {
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[8] = sgn * tr[(tr_dim1 << 1) + 1];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[13] = sgn * tr[(tr_dim1 << 1) + 1];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[2] = sgn * tr[tr_dim1 + 2];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[7] = sgn * tr[tr_dim1 + 2];
    } else {
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[8] = sgn * tr[tr_dim1 + 2];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[13] = sgn * tr[tr_dim1 + 2];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[2] = sgn * tr[(tr_dim1 << 1) + 1];
        # 将数组 tr 的特定索引乘以 sgn 后赋值给数组 t16 的对应位置
        t16[7] = sgn * tr[(tr_dim1 << 1) + 1];
    }

    # 将数组 b 的特定索引赋值给数组 btmp 的对应位置
    btmp[0] = b[b_dim1 + 1];
    # 将数组 b 的特定索引赋值给数组 btmp 的对应位置
    btmp[1] = b[b_dim1 + 2];
    # 将数组 b 的特定索引赋值给数组 btmp 的对应位置
    btmp[2] = b[(b_dim1 << 1) + 1];
    # 将数组 b 的特定索引赋值给数组 btmp 的对应位置
    btmp[3] = b[(b_dim1 << 1) + 2];
/*     Perform elimination */

/* 循环i__从1到3，执行消元操作 */
    for (i__ = 1; i__ <= 3; ++i__) {
/* 初始化xmax为0 */
    xmax = 0.f;
/* 循环ip从i__到4 */
    for (ip = i__; ip <= 4; ++ip) {
/* 循环jp从i__到4 */
        for (jp = i__; jp <= 4; ++jp) {
/* 计算t16[ip + (jp << 2) - 5]的绝对值，并与xmax比较 */
        if ((r__1 = t16[ip + (jp << 2) - 5], dabs(r__1)) >= xmax) {
/* 更新xmax和对应的ipsv、jpsv */
            xmax = (r__1 = t16[ip + (jp << 2) - 5], dabs(r__1));
            ipsv = ip;
            jpsv = jp;
        }
/* L60: */
        }
/* L70: */
    }
/* 如果ipsv不等于i__，则交换t16中的行 */
    if (ipsv != i__) {
        sswap_(&c__4, &t16[ipsv - 1], &c__4, &t16[i__ - 1], &c__4);
/* 交换btmp中的元素 */
        temp = btmp[i__ - 1];
        btmp[i__ - 1] = btmp[ipsv - 1];
        btmp[ipsv - 1] = temp;
    }
/* 如果jpsv不等于i__，则交换t16中的列 */
    if (jpsv != i__) {
        sswap_(&c__4, &t16[(jpsv << 2) - 4], &c__1, &t16[(i__ << 2) - 4],
            &c__1);
    }
/* 记录jpsv到jpiv数组中 */
    jpiv[i__ - 1] = jpsv;
/* 如果t16[i__ + (i__ << 2) - 5]的绝对值小于smin，则设置info为1 */
    if ((r__1 = t16[i__ + (i__ << 2) - 5], dabs(r__1)) < smin) {
        *info = 1;
/* 将t16[i__ + (i__ << 2) - 5]设置为smin */
        t16[i__ + (i__ << 2) - 5] = smin;
    }
/* 对j从i__+1到4进行循环 */
    for (j = i__ + 1; j <= 4; ++j) {
/* t16[j + (i__ << 2) - 5]除以t16[i__ + (i__ << 2) - 5] */
        t16[j + (i__ << 2) - 5] /= t16[i__ + (i__ << 2) - 5];
/* 更新btmp数组 */
        btmp[j - 1] -= t16[j + (i__ << 2) - 5] * btmp[i__ - 1];
/* 对k从i__+1到4进行循环 */
        for (k = i__ + 1; k <= 4; ++k) {
/* 更新t16数组 */
        t16[j + (k << 2) - 5] -= t16[j + (i__ << 2) - 5] * t16[i__ + (
            k << 2) - 5];
/* L80: */
        }
/* L90: */
    }
/* L100: */
    }
/* 如果t16[15]的绝对值小于smin，则设置t16[15]为smin */
    if (dabs(t16[15]) < smin) {
    t16[15] = smin;
    }
/* 设置*scale为1.0 */
    *scale = 1.f;
/* 如果某个btmp元素的绝对值乘以smlnum的8倍大于对应的t16元素的绝对值，则进行缩放 */
    if (smlnum * 8.f * dabs(btmp[0]) > dabs(t16[0]) || smlnum * 8.f * dabs(
        btmp[1]) > dabs(t16[5]) || smlnum * 8.f * dabs(btmp[2]) > dabs(
        t16[10]) || smlnum * 8.f * dabs(btmp[3]) > dabs(t16[15])) {
/* 计算btmp的绝对值的最大值 */
    r__1 = dabs(btmp[0]), r__2 = dabs(btmp[1]), r__1 = max(r__1,r__2),
        r__2 = dabs(btmp[2]), r__1 = max(r__1,r__2), r__2 = dabs(btmp[
        3]);
/* 缩放因子为0.125f除以btmp中绝对值的最大值 */
    *scale = .125f / dmax(r__1,r__2);
/* 对btmp数组进行缩放 */
    btmp[0] *= *scale;
    btmp[1] *= *scale;
    btmp[2] *= *scale;
    btmp[3] *= *scale;
    }
/* 对k从1到4进行循环 */
    for (i__ = 1; i__ <= 4; ++i__) {
    k = 5 - i__;
/* 计算temp */
    temp = 1.f / t16[k + (k << 2) - 5];
/* 计算tmp[k-1] */
    tmp[k - 1] = btmp[k - 1] * temp;
/* 对j从k+1到4进行循环 */
    for (j = k + 1; j <= 4; ++j) {
/* 更新tmp[k-1] */
        tmp[k - 1] -= temp * t16[k + (j << 2) - 5] * tmp[j - 1];
/* L110: */
    }
/* L120: */
    }
/* 对i__从1到3进行循环 */
    for (i__ = 1; i__ <= 3; ++i__) {
/* 如果jpiv[4-i__-1]不等于4-i__，则交换tmp中的元素 */
    if (jpiv[4 - i__ - 1] != 4 - i__) {
        temp = tmp[4 - i__ - 1];
        tmp[4 - i__ - 1] = tmp[jpiv[4 - i__ - 1] - 1];
        tmp[jpiv[4 - i__ - 1] - 1] = temp;
    }
/* L130: */
    }
/* 更新x数组 */
    x[x_dim1 + 1] = tmp[0];
    x[x_dim1 + 2] = tmp[1];
    x[(x_dim1 << 1) + 1] = tmp[2];
    x[(x_dim1 << 1) + 2] = tmp[3];
/* 计算tmp中元素的绝对值之和作为xnorm */
/* Computing MAX */
    r__1 = dabs(tmp[0]) + dabs(tmp[2]), r__2 = dabs(tmp[1]) + dabs(tmp[3]);
    *xnorm = dmax(r__1,r__2);
/* 返回0表示成功执行 */
    return 0;

/*     End of SLASY2 */

} /* slasy2_ */

/* 子程序slatrd_ */
/* 对矩阵a进行特定操作 */
int slatrd_(char *uplo, integer *n, integer *nb, real *a,
    integer *lda, real *e, real *tau, real *w, integer *ldw)
{
    /* System generated locals */
    integer a_dim1, a_offset, w_dim1, w_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, iw;
    # 声明一个外部函数 `sdot_`，计算两个实数向量的点积
    extern doublereal sdot_(integer *, real *, integer *, real *, integer *);

    # 声明一个静态的实数变量 `alpha`
    static real alpha;

    # 声明一个外部函数 `lsame_`，用于比较两个字符是否相同，返回逻辑值
    extern logical lsame_(char *, char *);

    # 声明一个外部子程序 `sscal_`，用于对实数向量进行比例缩放
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);

    # 声明一个外部子程序 `sgemv_`，执行矩阵-向量乘法
    extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *,
        real *, integer *, real *, integer *, real *, real *, integer *);

    # 声明一个外部子程序 `saxpy_`，计算向量的线性组合
    extern /* Subroutine */ int saxpy_(integer *, real *, real *, integer *,
        real *, integer *);

    # 声明一个外部子程序 `ssymv_`，执行对称矩阵-向量乘法
    extern /* Subroutine */ int ssymv_(char *, integer *, real *, real *,
        integer *, real *, integer *, real *, real *, integer *);

    # 声明一个外部子程序 `slarfg_`，生成一个标量和一个向量的 Householder 变换
    extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *,
        real *);
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLATRD reduces NB rows and columns of a real symmetric matrix A to
    symmetric tridiagonal form by an orthogonal similarity
    transformation Q' * A * Q, and returns the matrices V and W which are
    needed to apply the transformation to the unreduced part of A.

    If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
    matrix, of which the upper triangle is supplied;
    if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
    matrix, of which the lower triangle is supplied.

    This is an auxiliary routine called by SSYTRD.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular

    N       (input) INTEGER
            The order of the matrix A.

    NB      (input) INTEGER
            The number of rows and columns to be reduced.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the orthogonal matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  orthogonal matrix Q as a
              product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= (1,N).

    E       (output) REAL array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
*/
    TAU     (output) REAL array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            # TAU 是存储初等反射器的标量因子的数组，根据 UPLO 的值不同存储方式也不同。

    W       (output) REAL array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            # W 是一个 n × nb 的矩阵，用于更新矩阵 A 未约化部分的内容。

    LDW     (input) INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            # W 数组的主维度，LDW 必须大于等于 max(1, N)。

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n) H(n-1) . . . H(n-nb+1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
    and tau in TAU(i-1).
    # 如果 UPLO = 'U'，矩阵 Q 被表示为一系列初等反射器的乘积，具体的形式和存储方式。

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
    and tau in TAU(i).
    # 如果 UPLO = 'L'，矩阵 Q 被表示为一系列初等反射器的乘积，具体的形式和存储方式。

    The elements of the vectors v together form the n-by-nb matrix V
    which is needed, with W, to apply the transformation to the unreduced
    part of the matrix, using a symmetric rank-2k update of the form:
    A := A - V*W' - W*V'.
    # 向量 v 的元素共同形成一个 n × nb 的矩阵 V，与矩阵 W 一起，用于对矩阵的未约化部分进行变换。

    The contents of A on exit are illustrated by the following examples
    with n = 5 and nb = 2:

    if UPLO = 'U':                       if UPLO = 'L':

      (  a   a   a   v4  v5 )              (  d                  )
      (      a   a   v4  v5 )              (  1   d              )
      (          a   1   v5 )              (  v1  1   a          )
      (              d   1  )              (  v1  v2  a   a      )
      (                  d  )              (  v1  v2  a   a   a  )

    where d denotes a diagonal element of the reduced matrix, a denotes
    an element of the original matrix that is unchanged, and vi denotes
    an element of the vector defining H(i).
    # 退出时矩阵 A 的内容示例，包括 UPLO 为 'U' 和 'L' 时的具体形式说明。

    =====================================================================


       Quick return if possible
       # 如果可能的话，快速返回
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --e;
    --tau;
    w_dim1 = *ldw;
    w_offset = 1 + w_dim1;
    w -= w_offset;

    /* Function Body */
    if (*n <= 0) {
        return 0;
    }

    if (lsame_(uplo, "U")) {

        /* Reduce last NB columns of upper triangle */

        i__1 = *n - *nb + 1;
        for (i__ = *n; i__ >= i__1; --i__) {
            iw = i__ - *n + *nb;
            if (i__ < *n) {

                /* Update A(1:i,i) */

                i__2 = *n - i__;
                sgemv_("No transpose", &i__, &i__2, &c_b151, &a[(i__ + 1) *
                    a_dim1 + 1], lda, &w[i__ + (iw + 1) * w_dim1], ldw, &
                    c_b15, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                sgemv_("No transpose", &i__, &i__2, &c_b151, &w[(iw + 1) *
                    w_dim1 + 1], ldw, &a[i__ + (i__ + 1) * a_dim1], lda, &
                    c_b15, &a[i__ * a_dim1 + 1], &c__1);
            }
            if (i__ > 1) {

                /* Generate elementary reflector H(i) to annihilate
                   A(1:i-2,i) */

                i__2 = i__ - 1;
                slarfg_(&i__2, &a[i__ - 1 + i__ * a_dim1], &a[i__ * a_dim1 +
                    1], &c__1, &tau[i__ - 1]);
                e[i__ - 1] = a[i__ - 1 + i__ * a_dim1];
                a[i__ - 1 + i__ * a_dim1] = 1.f;

                /* Compute W(1:i-1,i) */

                i__2 = i__ - 1;
                ssymv_("Upper", &i__2, &c_b15, &a[a_offset], lda, &a[i__ *
                    a_dim1 + 1], &c__1, &c_b29, &w[iw * w_dim1 + 1], &
                    c__1);
                if (i__ < *n) {
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    sgemv_("Transpose", &i__2, &i__3, &c_b15, &w[(iw + 1) *
                        w_dim1 + 1], ldw, &a[i__ * a_dim1 + 1], &c__1, &
                        c_b29, &w[i__ + 1 + iw * w_dim1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1)
                         * a_dim1 + 1], lda, &w[i__ + 1 + iw * w_dim1], &
                        c__1, &c_b15, &w[iw * w_dim1 + 1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
                        a_dim1 + 1], lda, &a[i__ * a_dim1 + 1], &c__1, &
                        c_b29, &w[i__ + 1 + iw * w_dim1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    sgemv_("No transpose", &i__2, &i__3, &c_b151, &w[(iw + 1)
                        * w_dim1 + 1], ldw, &w[i__ + 1 + iw * w_dim1], &
                        c__1, &c_b15, &w[iw * w_dim1 + 1], &c__1);
                }
                i__2 = i__ - 1;
                sscal_(&i__2, &tau[i__ - 1], &w[iw * w_dim1 + 1], &c__1);
                i__2 = i__ - 1;
                alpha = tau[i__ - 1] * -.5f * sdot_(&i__2, &w[iw * w_dim1 + 1]
                    , &c__1, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = i__ - 1;
                saxpy_(&i__2, &alpha, &a[i__ * a_dim1 + 1], &c__1, &w[iw *
                    w_dim1 + 1], &c__1);
            }

            /* L10: */
        }
    } else {

        /* Reduce first NB columns of lower triangle */

        i__1 = *nb;


注释：
    # 循环开始，从 i__ = 1 开始，逐步递增直到 i__ <= i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
/*           Update A(i:n,i) */
/* 更新 A(i:n,i) */

        i__2 = *n - i__ + 1;
        i__3 = i__ - 1;
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + a_dim1],
            lda, &w[i__ + w_dim1], ldw, &c_b15, &a[i__ + i__ * a_dim1]
            , &c__1);
/* 使用 sgemv 函数对 A 的部分列进行更新，无需转置 */
        i__2 = *n - i__ + 1;
        i__3 = i__ - 1;
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &w[i__ + w_dim1],
            ldw, &a[i__ + a_dim1], lda, &c_b15, &a[i__ + i__ * a_dim1]
            , &c__1);
/* 使用 sgemv 函数再次更新 A 的部分列，无需转置 */
        if (i__ < *n) {

/*
                Generate elementary reflector H(i) to annihilate
                A(i+2:n,i)
*/
/* 生成用于消除 A(i+2:n,i) 的初等反射变换 H(i) */

        i__2 = *n - i__;
/* 计算要操作的向量的长度 */
/* Computing MIN */
        i__3 = i__ + 2;
        slarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*n) +
            i__ * a_dim1], &c__1, &tau[i__]);
/* 调用 slarfg 函数生成初等反射变换 H(i) */
        e[i__] = a[i__ + 1 + i__ * a_dim1];
/* 将 A(i+1,i) 的值存入 e(i) 中 */
        a[i__ + 1 + i__ * a_dim1] = 1.f;
/* 设置 A(i+1,i) 为 1 */

/*              Compute W(i+1:n,i) */

        i__2 = *n - i__;
        ssymv_("Lower", &i__2, &c_b15, &a[i__ + 1 + (i__ + 1) *
            a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b29, &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 ssymv 函数计算 W(i+1:n,i) */
        i__2 = *n - i__;
        i__3 = i__ - 1;
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &w[i__ + 1 + w_dim1]
            , ldw, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &w[
            i__ * w_dim1 + 1], &c__1);
/* 使用 sgemv 函数计算矩阵乘积，转置操作 */
        i__2 = *n - i__;
        i__3 = i__ - 1;
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &w[i__ * w_dim1 + 1], &c__1, &c_b15, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 sgemv 函数计算矩阵乘积，无需转置 */
        i__2 = *n - i__;
        i__3 = i__ - 1;
        sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + a_dim1]
            , lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &w[
            i__ * w_dim1 + 1], &c__1);
/* 使用 sgemv 函数计算矩阵乘积，转置操作 */
        i__2 = *n - i__;
        i__3 = i__ - 1;
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &w[i__ + 1 +
            w_dim1], ldw, &w[i__ * w_dim1 + 1], &c__1, &c_b15, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 sgemv 函数计算矩阵乘积，无需转置 */
        i__2 = *n - i__;
        sscal_(&i__2, &tau[i__], &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 sscal 函数进行向量的缩放 */
        i__2 = *n - i__;
        alpha = tau[i__] * -.5f * sdot_(&i__2, &w[i__ + 1 + i__ *
            w_dim1], &c__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
/* 计算 alpha 值 */
        i__2 = *n - i__;
        saxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 saxpy 函数进行向量运算 */
        }

/* L20: */
/* L20 标签，循环结束 */

    }
    }

    return 0;

/*     End of SLATRD */

} /* slatrd_ */

/* Subroutine */ int slauu2_(char *uplo, integer *n, real *a, integer *lda,
    integer *info)
{
    /* System generated locals */
/* 系统生成的局部变量 */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
/* 局部变量 */
    static integer i__;
    static real aii;
/* 静态变量 aii */
    extern doublereal sdot_(integer *, real *, integer *, real *, integer *);
/* 外部函数声明：sdot */
    extern logical lsame_(char *, char *);
/* 外部函数声明：lsame */


注释结束
    # 外部声明：调用名为 sscal_ 和 sgemv_ 的子程序（函数），并指定它们的参数类型和顺序
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        sgemv_(char *, integer *, integer *, real *, real *, integer *,
        real *, integer *, real *, real *, integer *);
    # 静态变量声明：声明一个名为 upper 的逻辑变量，静态变量在程序运行期间保持不变
    static logical upper;
    # 外部声明：调用名为 xerbla_ 的子程序（函数），并指定它的参数类型和顺序
    extern /* Subroutine */ int xerbla_(char *, integer *);
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SLAUU2 computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the unblocked form of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    // 设置数组 A 的偏移量和维度
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 将 INFO 初始化为 0，表示成功退出
    *info = 0;
    // 检查 UPLO 参数是否合法
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
    // 如果 UPLO 不是 'U' 或 'L'，设置 INFO 为 -1
    *info = -1;
    } else if (*n < 0) {
    // 如果 N 小于 0，设置 INFO 为 -2
    *info = -2;
    } else if (*lda < max(1,*n)) {
    // 如果 LDA 小于 max(1, N)，设置 INFO 为 -4
    *info = -4;
    }
    if (*info != 0) {
    // 如果 INFO 不为 0，调用错误处理程序 xerbla_
    i__1 = -(*info);
    xerbla_("SLAUU2", &i__1);
    // 返回 0 表示处理结束
    return 0;
    }

/*     Quick return if possible */

    // 如果 N 为 0，直接返回，无需计算
    if (*n == 0) {
    return 0;
    }

    // 如果 UPLO 是 'U'
    if (upper) {

/*        Compute the product U * U'. */

    // 循环计算 U * U'
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 取出 A 的对角元素
        aii = a[i__ + i__ * a_dim1];
        if (i__ < *n) {
        // 计算 U * U' 的非对角部分
        i__2 = *n - i__ + 1;
        a[i__ + i__ * a_dim1] = sdot_(&i__2, &a[i__ + i__ * a_dim1],
            lda, &a[i__ + i__ * a_dim1], lda);
        i__2 = i__ - 1;
        i__3 = *n - i__;
        sgemv_("No transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            aii, &a[i__ * a_dim1 + 1], &c__1);
        } else {
        // 计算 U * U' 的对角元素
        sscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
        }
/* L10: */
    }

    } else {

/*        Compute the product L' * L. */

    // 计算 L' * L
    i__1 = *n;

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 取出 A 的对角元素
        aii = a[i__ + i__ * a_dim1];
        if (i__ < *n) {
            // 计算 L' * L 的非对角部分
            i__2 = *n - i__ + 1;
            a[i__ + i__ * a_dim1] = sdot_(&i__2, &a[i__ + i__ * a_dim1],
                                          lda, &a[i__ + i__ * a_dim1], lda);
            i__2 = i__ - 1;
            i__3 = *n - i__;
            sgemv_("Transpose", &i__3, &i__2, &c_b15, &a[(i__ + 1) * a_dim1 + i__],
                   lda, &a[i__ + i__ * a_dim1], lda, &aii, &a[i__ + 1 + i__ * a_dim1],
                   lda);
        } else {
            // 计算 L' * L 的对角元素
            sscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
        }
        /* L20: */
    }

    } /* End of SLAUU2 */


注释：
    # 循环遍历从 1 到 i__1 的索引变量 i__
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 获取主对角线元素 aii = a[i__, i__]
        aii = a[i__ + i__ * a_dim1];
        # 如果 i__ 小于总列数 *n
        if (i__ < *n) {
            # 计算需要处理的子向量的长度 i__2
            i__2 = *n - i__ + 1;
            # 计算并存储 a[i__, i__] 的二范数平方
            a[i__ + i__ * a_dim1] = sdot_(&i__2, &a[i__ + i__ * a_dim1], &
                c__1, &a[i__ + i__ * a_dim1], &c__1);
            # 计算矩阵-向量乘法的结果
            i__2 = *n - i__;
            i__3 = i__ - 1;
            sgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + a_dim1]
                , lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &aii, &a[
                i__ + a_dim1], lda);
        } else {
            # 对矩阵的最后一行进行缩放操作
            sscal_(&i__, &aii, &a[i__ + a_dim1], lda);
        }
    }
/*
    SLAUUM computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the blocked form of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================

    Test the input parameters.
*/
/* L20: */
    /* Parameter adjustments */
    // 设置数组 A 的维度参数
    a_dim1 = *lda;
    // 设置 A 数组的偏移量
    a_offset = 1 + a_dim1;
    // 调整 A 数组的指针，指向正确的内存位置
    a -= a_offset;

    /* Function Body */
    // 初始化 INFO 为 0，表示执行成功
    *info = 0;
    // 判断 triangular factor 是否为 upper
    upper = lsame_(uplo, "U");


这些注释详细解释了代码的各个部分，包括参数设置和功能说明。
    // 如果不是大写（upper为假）并且uplo不是"L"，则设定info为-1
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    // 如果n小于0，则设定info为-2
    } else if (*n < 0) {
        *info = -2;
    // 如果lda小于1和n中的最大值，则设定info为-4
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    // 如果info不等于0，调用xerbla_函数报错并返回0
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SLAUUM", &i__1);
        return 0;
    }
/*     Quick return if possible */
如果输入的矩阵维度 *n 等于0，直接返回0，无需进行任何计算。
    if (*n == 0) {
    return 0;
    }

/*     Determine the block size for this environment. */
确定适合当前环境的块大小 nb。

    nb = ilaenv_(&c__1, "SLAUUM", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);

    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code */
如果块大小 nb 小于等于1或者大于等于 *n，使用未块化的代码。

    slauu2_(uplo, n, &a[a_offset], lda, info);
    } else {

/*        Use blocked code */
否则，使用块化的代码。

    if (upper) {

/*           Compute the product U * U'. */
计算上三角部分 U * U' 的乘积。

        i__1 = *n;
        i__2 = nb;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = nb, i__4 = *n - i__ + 1;
        ib = min(i__3,i__4);
计算当前块的大小 ib，即 min(nb, *n - i + 1)。
        i__3 = i__ - 1;
使用 BLAS 函数 strmm 计算乘积 U * U' 的一部分。
        strmm_("Right", "Upper", "Transpose", "Non-unit", &i__3, &ib,
            &c_b15, &a[i__ + i__ * a_dim1], lda, &a[i__ * a_dim1
            + 1], lda)
            ;
使用 BLAS 函数 slauu2 计算上三角部分的 Cholesky 分解。
        slauu2_("Upper", &ib, &a[i__ + i__ * a_dim1], lda, info);
如果还有剩余的部分，则继续计算。
        if (i__ + ib <= *n) {
            i__3 = i__ - 1;
            i__4 = *n - i__ - ib + 1;
使用 BLAS 函数 sgemm 计算乘积 U * U' 的其余部分。
            sgemm_("No transpose", "Transpose", &i__3, &ib, &i__4, &
                c_b15, &a[(i__ + ib) * a_dim1 + 1], lda, &a[i__ +
                (i__ + ib) * a_dim1], lda, &c_b15, &a[i__ *
                a_dim1 + 1], lda);
使用 BLAS 函数 ssyrk 更新矩阵 A 的其余部分。
            i__3 = *n - i__ - ib + 1;
            ssyrk_("Upper", "No transpose", &ib, &i__3, &c_b15, &a[
                i__ + (i__ + ib) * a_dim1], lda, &c_b15, &a[i__ +
                i__ * a_dim1], lda);
        }
/* L10: */
        }
    } else {

/*           Compute the product L' * L. */
计算下三角部分 L' * L 的乘积。

        i__2 = *n;
        i__1 = nb;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {
/* Computing MIN */
        i__3 = nb, i__4 = *n - i__ + 1;
        ib = min(i__3,i__4);
计算当前块的大小 ib，即 min(nb, *n - i + 1)。
        i__3 = i__ - 1;
使用 BLAS 函数 strmm 计算乘积 L' * L 的一部分。
        strmm_("Left", "Lower", "Transpose", "Non-unit", &ib, &i__3, &
            c_b15, &a[i__ + i__ * a_dim1], lda, &a[i__ + a_dim1],
            lda);
使用 BLAS 函数 slauu2 计算下三角部分的 Cholesky 分解。
        slauu2_("Lower", &ib, &a[i__ + i__ * a_dim1], lda, info);
如果还有剩余的部分，则继续计算。
        if (i__ + ib <= *n) {
            i__3 = i__ - 1;
            i__4 = *n - i__ - ib + 1;
使用 BLAS 函数 sgemm 计算乘积 L' * L 的其余部分。
            sgemm_("Transpose", "No transpose", &ib, &i__3, &i__4, &
                c_b15, &a[i__ + ib + i__ * a_dim1], lda, &a[i__ +
                ib + a_dim1], lda, &c_b15, &a[i__ + a_dim1], lda);
使用 BLAS 函数 ssyrk 更新矩阵 A 的其余部分。
            i__3 = *n - i__ - ib + 1;
            ssyrk_("Lower", "Transpose", &ib, &i__3, &c_b15, &a[i__ +
                ib + i__ * a_dim1], lda, &c_b15, &a[i__ + i__ *
                a_dim1], lda);
        }
/* L20: */
        }
    }
    }

    return 0;

/*     End of SLAUUM */

} /* slauum_ */

/* Subroutine */ int sorg2r_(integer *m, integer *n, integer *k, real *a,
    integer *lda, real *tau, real *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j, l;
    # 声明外部的三个子程序：sscal、slarf 和 xerbla，它们都是 Fortran 程序
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        slarf_(char *, integer *, integer *, real *, integer *, real *,
        real *, integer *, real *),
        xerbla_(char *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORG2R generates an m by n real matrix Q with orthonormal columns,
    which is defined as the first n columns of a product of k elementary
    reflectors of order m

          Q  =  H(1) H(2) . . . H(k)

    as returned by SGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by SGEQRF in the first k columns of its array
            argument A.
            On exit, the m-by-n matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.

    WORK    (workspace) REAL array, dimension (N)

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    =====================================================================


       Test the input arguments
*/
    /*
       Parameter adjustments
    */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /*
       Function Body
    */
    *info = 0;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0 || *n > *m) {
        *info = -2;
    } else if (*k < 0 || *k > *n) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORG2R", &i__1);
        return 0;
    }

    /*
       Quick return if possible
    */
    if (*n <= 0) {
        return 0;
    }

    /*
       Initialise columns k+1:n to columns of the unit matrix
    */
    i__1 = *n;
    for (j = *k + 1; j <= i__1; ++j) {
        i__2 = *m;
        for (l = 1; l <= i__2; ++l) {
            a[l + j * a_dim1] = 0.f;
        }
        a[j + j * a_dim1] = 1.f;
    }

    for (i__ = *k; i__ >= 1; --i__) {

        /*
           Apply H(i) to A(i:m,i:n) from the left
        */
        if (i__ < *n) {
            a[i__ + i__ * a_dim1] = 1.f;
            i__1 = *m - i__ + 1;
            i__2 = *n - i__;
            slarf_("Left", &i__1, &i__2, &a[i__ + i__ * a_dim1], &c__1, &tau[
                i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
        }
        if (i__ < *m) {
            i__1 = *m - i__;
            r__1 = -tau[i__];
            sscal_(&i__1, &r__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
        }
/* L30: */
    }
/* L40: */
    # 在二维数组 a 中的特定位置进行赋值操作
    a[i__ + i__ * a_dim1] = 1.f - tau[i__];
/*        Set A(1:i-1,i) to zero */

// 循环将矩阵 A 的第 i 列的前 i-1 行元素置零
i__1 = i__ - 1;
for (l = 1; l <= i__1; ++l) {
    a[l + i__ * a_dim1] = 0.f;
/* L30: */
}
/* L40: */
}
return 0;

/*     End of SORG2R */

} /* sorg2r_ */

/* Subroutine */ int sorgbr_(char *vect, integer *m, integer *n, integer *k,
    real *a, integer *lda, real *tau, real *work, integer *lwork, integer
    *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, nb, mn;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    static logical wantq;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int sorglq_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *), sorgqr_(
        integer *, integer *, integer *, real *, integer *, real *, real *
        , integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORGBR generates one of the real orthogonal matrices Q or P**T
    determined by SGEBRD when reducing a real matrix A to bidiagonal
    form: A = Q * B * P**T.  Q and P**T are defined as products of
    elementary reflectors H(i) or G(i) respectively.

    If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
    is of order M:
    if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
    columns of Q, where m >= n >= k;
    if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
    M-by-M matrix.

    If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
    is of order N:
    if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
    rows of P**T, where n >= m >= k;
    if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
    an N-by-N matrix.

    Arguments
    =========

    VECT    (input) CHARACTER*1
            Specifies whether the matrix Q or the matrix P**T is
            required, as defined in the transformation applied by SGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**T.

    M       (input) INTEGER
            The number of rows of the matrix Q or P**T to be returned.
            M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q or P**T to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
    # 输入参数 K
    K       (input) INTEGER
            If VECT = 'Q', the number of columns in the original M-by-K
            matrix reduced by SGEBRD.
            If VECT = 'P', the number of rows in the original K-by-N
            matrix reduced by SGEBRD.
            K >= 0.

    # 输入/输出数组 A
    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by SGEBRD.
            On exit, the M-by-N matrix Q or P**T.

    # 数组 A 的第一个维度大小
    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,M).

    # TAU 数组
    TAU     (input) REAL array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i), which determines Q or P**T, as
            returned by SGEBRD in its array argument TAUQ or TAUP.

    # 工作空间数组 WORK
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    # 工作空间数组 WORK 的维度
    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            For optimum performance LWORK >= min(M,N)*NB, where NB
            is the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    # 输出参数 INFO
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================

    # 测试输入参数的有效性
       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;  // a_dim1是矩阵a的第一维度大小，即每列元素个数
    a_offset = 1 + a_dim1;  // a_offset是a数组的起始偏移量
    a -= a_offset;  // 将a指针前移a_offset个位置，使得a的索引从1开始
    --tau;  // 将tau指针前移一个位置，tau是存储元素反射器的向量
    --work;  // 将work指针前移一个位置，work是工作数组

    /* Function Body */
    *info = 0;  // 将info指针所指的内容置为0，用于存储返回状态
    wantq = lsame_(vect, "Q");  // 判断vect是否等于"Q"，决定是否计算Q矩阵
    mn = min(*m,*n);  // 计算m和n的最小值，mn用于确定工作数组的大小
    lquery = *lwork == -1;  // 判断是否进行工作数组大小查询
    if (! wantq && ! lsame_(vect, "P")) {  // 如果既不需要计算Q也不需要计算P'
        *info = -1;  // 返回错误信息-1，说明vect参数不合法
    } else if (*m < 0) {  // 如果m小于0
        *info = -2;  // 返回错误信息-2，说明m参数不合法
    } else if (*n < 0 || wantq && (*n > *m || *n < min(*m,*k)) || ! wantq && (
        *m > *n || *m < min(*n,*k))) {
        *info = -3;  // 返回错误信息-3，说明n参数不合法
    } else if (*k < 0) {  // 如果k小于0
        *info = -4;  // 返回错误信息-4，说明k参数不合法
    } else if (*lda < max(1,*m)) {  // 如果lda小于1和m的最大值
        *info = -6;  // 返回错误信息-6，说明lda参数不合法
    } else if (*lwork < max(1,mn) && ! lquery) {  // 如果lwork小于1和mn的最大值且不是查询工作数组大小
        *info = -9;  // 返回错误信息-9，说明lwork参数不合法
    }

    if (*info == 0) {  // 如果没有错误信息
        if (wantq) {  // 如果需要计算Q
            nb = ilaenv_(&c__1, "SORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (
                ftnlen)1);  // 获取SORGQR的优化块大小
        } else {  // 否则需要计算P'
            nb = ilaenv_(&c__1, "SORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (
                ftnlen)1);  // 获取SORGLQ的优化块大小
        }
        lwkopt = max(1,mn) * nb;  // 计算工作数组的推荐大小
        work[1] = (real) lwkopt;  // 将推荐大小存储在工作数组的第一个位置
    }

    if (*info != 0) {  // 如果存在错误信息
        i__1 = -(*info);
        xerbla_("SORGBR", &i__1);  // 调用xerbla函数处理错误信息
        return 0;  // 返回0表示程序终止
    } else if (lquery) {  // 如果是查询工作数组大小
        return 0;  // 返回0表示程序终止
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {  // 如果m或n为0
        work[1] = 1.f;  // 设置工作数组的第一个位置为1
        return 0;  // 返回0表示程序终止
    }

    if (wantq) {  // 如果需要计算Q

/*
          Form Q, determined by a call to SGEBRD to reduce an m-by-k
          matrix
*/

        if (*m >= *k) {  // 如果m大于等于k

/*           If m >= k, assume m >= n >= k */

            sorgqr_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  // 调用sorgqr函数计算Q矩阵

        } else {

/*
             If m < k, assume m = n

             Shift the vectors which define the elementary reflectors one
             column to the right, and set the first row and column of Q
             to those of the unit matrix
*/

            for (j = *m; j >= 2; --j) {  // 遍历列
                a[j * a_dim1 + 1] = 0.f;  // 第一列置零
                i__1 = *m;  // 循环次数为m
                for (i__ = j + 1; i__ <= i__1; ++i__) {  // 遍历行
                    a[i__ + j * a_dim1] = a[i__ + (j - 1) * a_dim1];  // 向右移动反射向量
/* L10: */          // 循环结束
                }
/* L20: */          // 结束
            }
            a[a_dim1 + 1] = 1.f;  // 第一行的a_dim1置1
            i__1 = *m;  // 循环次数
            for (i__ = 2; i__ <= i__1; ++i__) {  // 遍历次数
                a[i__ + a_dim1] = 0.f;  // 对角线上置0
/* L30: */          // 循环次数
            }
            if (*m > 1) {  // 如果m大于1

/*              Form Q(2:m,2:m) */

                i__1 = *m - 1;  // i__1 为 m-1
                i__2 = *m - 1;  // i__2 为 m-1
                i__3 = *m - 1;  // i__3 为 m-1
                sorgqr_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
                    1], &work[1], lwork, &iinfo);  // 计算Q
            }
        }
    } else {  // 如果需要计算P'

/*
          Form P', determined by a call to SGEBRD to reduce a k-by-n
          matrix
*/

        if (*k < *n) {  // 如果k<n

/*           If k < n, assume k <= m <= n */

            sorglq_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  // 计算P'

        } else {

/*
             If k >= n, assume m = n

             Shift the vectors which define the elementary reflectors one
             row downward, and set the first row and column of P' to
             those of the unit matrix
*/

            a[a_dim1 + 1] = 1.f;  // 一个数据为1
            i__1 = *n;  // 一个数据
            for (i__ = 2; i__ <= i__1; ++i__) {  // 一个数据
                a[i__ + a_dim1] = 0.f;  // 一个数据
/* L40: */
        }
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
        for (i__ = j - 1; i__ >= 2; --i__) {
            a[i__ + j * a_dim1] = a[i__ - 1 + j * a_dim1];
/* L50: */
        }
        a[j * a_dim1 + 1] = 0.f;
/* L60: */
        }
        if (*n > 1) {

/*              Form P'(2:n,2:n) */

        i__1 = *n - 1;
        i__2 = *n - 1;
        i__3 = *n - 1;
        sorglq_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
            1], &work[1], lwork, &iinfo);
        }
    }
    }
    work[1] = (real) lwkopt;
    return 0;

/*     End of SORGBR */

} /* sorgbr_ */

/* Subroutine */ int sorghr_(integer *n, integer *ilo, integer *ihi, real *a,
    integer *lda, real *tau, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, nb, nh, iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int sorgqr_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORGHR generates a real orthogonal matrix Q which is defined as the
    product of IHI-ILO elementary reflectors of order N, as returned by
    SGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix Q. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of SGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by SGEHRD.
            On exit, the N-by-N orthogonal matrix Q.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,N).

    TAU     (input) REAL array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEHRD.

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    # LWORK （输入）整数
    # WORK 数组的维度。要求 LWORK >= IHI-ILO。
    # 为了获得最佳性能，建议 LWORK >= (IHI-ILO)*NB，其中 NB 是最佳块大小。

    # 如果 LWORK = -1，则假定需要工作空间查询；该例程仅计算 WORK 数组的最佳大小，
    # 将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会因 LWORK 相关的错误而发出错误消息。

    # INFO （输出）整数
    # = 0：成功退出
    # < 0：如果 INFO = -i，则第 i 个参数具有非法值

    # =====================================================================

    # 测试输入参数
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
--work;

/* Function Body */
*info = 0;
nh = *ihi - *ilo;
lquery = *lwork == -1;

if (*n < 0) {
*info = -1;
} else if (*ilo < 1 || *ilo > max(1,*n)) {
*info = -2;
} else if (*ihi < min(*ilo,*n) || *ihi > *n) {
*info = -3;
} else if (*lda < max(1,*n)) {
*info = -5;
} else if (*lwork < max(1,nh) && ! lquery) {
*info = -8;
}

if (*info == 0) {
nb = ilaenv_(&c__1, "SORGQR", " ", &nh, &nh, &nh, &c_n1, (ftnlen)6, (ftnlen)1);
lwkopt = max(1,nh) * nb;
work[1] = (real) lwkopt;
}

if (*info != 0) {
i__1 = -(*info);
xerbla_("SORGHR", &i__1);
return 0;
} else if (lquery) {
return 0;
}

/* Quick return if possible */

if (*n == 0) {
work[1] = 1.f;
return 0;
}

/*
   Shift the vectors which define the elementary reflectors one
   column to the right, and set the first ilo and the last n-ihi
   rows and columns to those of the unit matrix
*/

i__1 = *ilo + 1;
for (j = *ihi; j >= i__1; --j) {
i__2 = j - 1;
for (i__ = 1; i__ <= i__2; ++i__) {
a[i__ + j * a_dim1] = 0.f;
/* L10: */
}
i__2 = *ihi;
for (i__ = j + 1; i__ <= i__2; ++i__) {
a[i__ + j * a_dim1] = a[i__ + (j - 1) * a_dim1];
/* L20: */
}
i__2 = *n;
for (i__ = *ihi + 1; i__ <= i__2; ++i__) {
a[i__ + j * a_dim1] = 0.f;
/* L30: */
}
/* L40: */
}
i__1 = *ilo;
for (j = 1; j <= i__1; ++j) {
i__2 = *n;
for (i__ = 1; i__ <= i__2; ++i__) {
a[i__ + j * a_dim1] = 0.f;
/* L50: */
}
a[j + j * a_dim1] = 1.f;
/* L60: */
}
i__1 = *n;
for (j = *ihi + 1; j <= i__1; ++j) {
i__2 = *n;
for (i__ = 1; i__ <= i__2; ++i__) {
a[i__ + j * a_dim1] = 0.f;
/* L70: */
}
a[j + j * a_dim1] = 1.f;
/* L80: */
}

if (nh > 0) {

/* Generate Q(ilo+1:ihi,ilo+1:ihi) */

sorgqr_(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*ilo], &work[1], lwork, &iinfo);
}
work[1] = (real) lwkopt;
return 0;

/* End of SORGHR */
} /* sorghr_ */

/* Subroutine */ int sorgl2_(integer *m, integer *n, integer *k, real *a, integer *lda, real *tau, real *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2;
real r__1;

/* Local variables */
static integer i__, j, l;
extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), slarf_(char *, integer *, integer *, real *, integer *, real *, real *, integer *, real *), xerbla_(char *, integer *);

/*
   -- LAPACK routine (version 3.2) --
   -- LAPACK is a software package provided by Univ. of Tennessee,    --
   -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


   Purpose
   =======
    # 测试输入参数的合法性
    if m < 0:
        # 如果M小于0，返回错误信息INFO=-1
        info = -1
        return
    elif n < m:
        # 如果N小于M，返回错误信息INFO=-2
        info = -2
        return
    elif k < 0 or k > m:
        # 如果K小于0或大于M，返回错误信息INFO=-3
        info = -3
        return
    elif lda < max(1, m):
        # 如果LDA小于max(1, M)，返回错误信息INFO=-5
        info = -5
        return

    # 初始化INFO为0，表示成功退出
    info = 0

    # Quick return if possible
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0; // 初始化 info，用于存储函数执行状态
    if (*m < 0) { // 检查 m 是否小于 0
    *info = -1; // 若 m 小于 0，设置 info 为 -1
    } else if (*n < *m) { // 检查 n 是否小于 m
    *info = -2; // 若 n 小于 m，设置 info 为 -2
    } else if (*k < 0 || *k > *m) { // 检查 k 是否在有效范围内
    *info = -3; // 若 k 小于 0 或大于 m，设置 info 为 -3
    } else if (*lda < max(1,*m)) { // 检查 lda 是否小于等于 max(1, m)
    *info = -5; // 若 lda 小于要求的最小值，设置 info 为 -5
    }
    if (*info != 0) { // 如果 info 不为 0，说明参数存在问题
    i__1 = -(*info);
    xerbla_("SORGL2", &i__1); // 调用错误处理函数 xerbla_
    return 0; // 返回
    }

/*     Quick return if possible */

    if (*m <= 0) { // 如果 m 小于等于 0，直接返回
    return 0; // 返回
    }

    if (*k < *m) { // 如果 k 小于 m，执行以下操作

/*        Initialise rows k+1:m to rows of the unit matrix */

    i__1 = *n; // 设置循环上限为 n
    for (j = 1; j <= i__1; ++j) { // 遍历列 j 从 1 到 n
        i__2 = *m; // 设置循环上限为 m
        for (l = *k + 1; l <= i__2; ++l) { // 遍历行 l 从 k+1 到 m
        a[l + j * a_dim1] = 0.f; // 将 A(l, j) 设置为 0
/* L10: */
        }
        if (j > *k && j <= *m) { // 如果 j 大于 k 且小于等于 m
        a[j + j * a_dim1] = 1.f; // 将 A(j, j) 设置为 1
        }
/* L20: */
    }
    }

    for (i__ = *k; i__ >= 1; --i__) { // 从 k 循环到 1

/*        Apply H(i) to A(i:m,i:n) from the right */

    if (i__ < *n) { // 如果 i 小于 n
        if (i__ < *m) { // 如果 i 小于 m
        a[i__ + i__ * a_dim1] = 1.f; // 将 A(i, i) 设置为 1
        i__1 = *m - i__; // 计算行数
        i__2 = *n - i__ + 1; // 计算列数
        slarf_("Right", &i__1, &i__2, &a[i__ + i__ * a_dim1], lda, &
            tau[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]); // 调用 slarf 函数
        }
        i__1 = *n - i__; // 计算行数
        r__1 = -tau[i__]; // 计算乘数
        sscal_(&i__1, &r__1, &a[i__ + (i__ + 1) * a_dim1], lda); // 调用 sscal 函数
    }
    a[i__ + i__ * a_dim1] = 1.f - tau[i__]; // 更新 A(i, i)

/*        Set A(i,1:i-1) to zero */

    i__1 = i__ - 1; // 计算循环上限
    for (l = 1; l <= i__1; ++l) { // 遍历 l 从 1 到 i-1
        a[i__ + l * a_dim1] = 0.f; // 将 A(i, l) 设置为 0
/* L30: */
    }
/* L40: */
    }
    return 0;

/*     End of SORGL2 */

} /* sorgl2_ */

/* Subroutine */ int sorglq_(integer *m, integer *n, integer *k, real *a,
    integer *lda, real *tau, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int sorgl2_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *), slarfb_(char *, char *,
        char *, char *, integer *, integer *, integer *, real *, integer *
        , real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);
    static integer ldwork, lwkopt;
    static logical lquery;

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORGLQ generates an M-by-N real matrix Q with orthonormal rows,
    which is defined as the first M rows of a product of K elementary
    # 测试输入参数的合法性，确保参数的取值符合预期要求
    if M < 0:
        # 如果 M 小于 0，则输出错误信息，返回 -1 表示参数非法
        return -1
    elif N < M:
        # 如果 N 小于 M，则输出错误信息，返回 -2 表示参数非法
        return -2
    elif K < 0 or K > M:
        # 如果 K 小于 0 或者大于 M，则输出错误信息，返回 -3 表示参数非法
        return -3
    elif LDA < max(1, M):
        # 如果 LDA 小于 max(1, M)，则输出错误信息，返回 -4 表示参数非法
        return -4
    elif LWORK < max(1, M):
        # 如果 LWORK 小于 max(1, M)，则输出错误信息，返回 -7 表示参数非法
        return -7
    else:
        # 如果输入参数都合法，则继续执行后续的计算
        pass
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    nb = ilaenv_(&c__1, "SORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);  // 获取优化参数 nb
    lwkopt = max(1,*m) * nb;  // 计算工作数组的最优大小
    work[1] = (real) lwkopt;  // 将最优大小存入工作数组的第一个位置
    lquery = *lwork == -1;  // 判断是否是查询工作空间大小的阶段
    if (*m < 0) {
        *info = -1;  // m 参数无效
    } else if (*n < *m) {
        *info = -2;  // n 参数小于 m 参数
    } else if (*k < 0 || *k > *m) {
        *info = -3;  // k 参数无效
    } else if (*lda < max(1,*m)) {
        *info = -5;  // lda 参数无效
    } else if (*lwork < max(1,*m) && ! lquery) {
        *info = -8;  // lwork 参数不足
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORGLQ", &i__1);  // 错误处理函数
        return 0;  // 返回
    } else if (lquery) {
        return 0;  // 若为查询阶段，直接返回
    }

/*     Quick return if possible */

    if (*m <= 0) {
        work[1] = 1.f;  // 若 m 小于等于 0，直接返回并设置 work[1] 为 1
        return 0;
    }

    nbmin = 2;  // 设置最小的分块大小为 2
    nx = 0;  // 初始化 nx 为 0
    iws = *m;  // 设置工作空间大小为 m
    if (nb > 1 && nb < *k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
        i__1 = 0, i__2 = ilaenv_(&c__3, "SORGLQ", " ", m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);  // 计算最大的 cross-over 点
        if (nx < *k) {

/*           Determine if workspace is large enough for blocked code. */

            ldwork = *m;  // 设置工作数组的第一维大小为 m
            iws = ldwork * nb;  // 计算使用分块方法时所需的工作空间大小
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

                nb = *lwork / ldwork;  // 调整 nb 的大小以适应工作空间
/* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "SORGLQ", " ", m, n, k, &c_n1,
                     (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);  // 计算最小的分块大小
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*
          Use blocked code after the last block.
          The first kk rows are handled by the block method.
*/

        ki = (*k - nx - 1) / nb * nb;  // 计算最后一个分块之后的起始索引
/* Computing MIN */
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);  // 计算实际使用的分块大小

/*        Set A(kk+1:m,1:kk) to zero. */

        i__1 = kk;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = kk + 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] = 0.f;  // 将指定区域的矩阵元素设为零
/* L10: */
            }
/* L20: */
        }
    } else {
        kk = 0;  // 若无法使用分块方法，则 kk 设为 0
    }

/*     Use unblocked code for the last or only block. */

    if (kk < *m) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        sorgl2_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &
            tau[kk + 1], &work[1], &iinfo);  // 调用不分块方法处理最后一个或唯一的分块
    }

    if (kk > 0) {

/*        Use blocked code */

        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);  // 计算当前分块的大小
            if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

                i__2 = *n - i__ + 1;
                slarft_("Forward", "Rowwise", &i__2, &ib, &a[i__ + i__ *
                    a_dim1], lda, &tau[i__], &work[1], &ldwork);  // 计算分块反射因子 H
/*              Apply H' to A(i+ib:m,i:n) from the right */
/*              将 H' 应用于 A(i+ib:m,i:n)，从右侧 */

        i__2 = *m - i__ - ib + 1;
        i__3 = *n - i__ + 1;
        slarfb_("Right", "Transpose", "Forward", "Rowwise", &i__2, &
            i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
            ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib +
            1], &ldwork);
        }

/*           Apply H' to columns i:n of current block */
/*           将 H' 应用于当前块的第 i 到 n 列 */

        i__2 = *n - i__ + 1;
        sorgl2_(&ib, &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
            work[1], &iinfo);

/*           Set columns 1:i-1 of current block to zero */
/*           将当前块的第 1 到 i-1 列置零 */

        i__2 = i__ - 1;
        for (j = 1; j <= i__2; ++j) {
        i__3 = i__ + ib - 1;
        for (l = i__; l <= i__3; ++l) {
            a[l + j * a_dim1] = 0.f;
/* L30: */
        }
/* L40: */
        }
/* L50: */
    }
    }

    work[1] = (real) iws;
    return 0;

/*     End of SORGLQ */
/*     SORGLQ 的结束 */

} /* sorglq_ */

/* Subroutine */ int sorgqr_(integer *m, integer *n, integer *k, real *a,
    integer *lda, real *tau, real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int sorg2r_(integer *, integer *, integer *, real
        *, integer *, real *, real *, integer *), slarfb_(char *, char *,
        char *, char *, integer *, integer *, integer *, real *, integer *
        , real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORGQR generates an M-by-N real matrix Q with orthonormal columns,
    which is defined as the first N columns of a product of K elementary
    reflectors of order M

          Q  =  H(1) H(2) . . . H(k)

    as returned by SGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
*/


这段代码的注释主要是针对 LAPACK 中的 SORGQR 函数，用于生成一个 M×N 的实矩阵 Q，其列正交，由 K 个初等反射变换的乘积的前 N 列构成。
    # A 是一个输入输出参数，是一个实数数组，维度为 (LDA,N)。
    # 在进入函数时，每一列 i 必须包含由 SGEQRF 返回的第 i 个 elementary reflector H(i) 的向量。
    # 在函数返回时，存储了 M×N 矩阵 Q。
    A       (input/output) REAL array, dimension (LDA,N)
    
    # LDA 是一个输入参数，是数组 A 的第一个维度。要求 LDA >= max(1,M)。
    LDA     (input) INTEGER
    
    # TAU 是一个输入参数，是一个实数数组，维度为 (K)。
    # TAU(i) 包含由 SGEQRF 返回的第 i 个 elementary reflector H(i) 的标量因子。
    TAU     (input) REAL array, dimension (K)
    
    # WORK 是一个工作空间数组，维度为 (MAX(1,LWORK))，输入输出参数。
    # 如果 INFO = 0，函数返回时，WORK(1) 返回最优 LWORK 的值。
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
    
    # LWORK 是一个输入参数，是数组 WORK 的维度。要求 LWORK >= max(1,N)。
    # 为了获得最佳性能，通常要求 LWORK >= N*NB，其中 NB 是最优的块大小。
    # 如果 LWORK = -1，则假定为工作空间查询；函数只计算 WORK 数组的最优大小，并将此值作为 WORK 数组的第一个条目返回，同时不会因 LWORK 相关的错误而发出 XERBLA 函数的错误消息。
    LWORK   (input) INTEGER
    
    # INFO 是一个输出参数，整数类型。
    # INFO = 0 表示函数成功完成。
    # INFO < 0 表示第 -INFO 个参数具有非法值。
    INFO    (output) INTEGER
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "SORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    lwkopt = max(1,*n) * nb;
    work[1] = (real) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0 || *n > *m) {
        *info = -2;
    } else if (*k < 0 || *k > *n) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORGQR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*n <= 0) {
        work[1] = 1.f;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *n;
    if (nb > 1 && nb < *k) {

/* 
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
        i__1 = 0, i__2 = ilaenv_(&c__3, "SORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *k) {

/* 
           Determine if workspace is large enough for blocked code.
*/
            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

/* 
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/
                nb = *lwork / ldwork;
/* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "SORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/* 
          Use blocked code after the last block.
          The first kk columns are handled by the block method.
*/
        ki = (*k - nx - 1) / nb * nb;
/* Computing MIN */
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);

/* 
        Set A(1:kk,kk+1:n) to zero.
*/
        i__1 = *n;
        for (j = kk + 1; j <= i__1; ++j) {
            i__2 = kk;
            for (i__ = 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] = 0.f;
                /* L10: */
            }
            /* L20: */
        }
    } else {
        kk = 0;
    }

/* 
     Use unblocked code for the last or only block.
*/
    if (kk < *n) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        sorg2r_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/* 
        Use blocked code
*/
        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);
            if (i__ + ib <= *n) {

/* 
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/
                i__2 = *m - i__ + 1;
                slarft_("Forward", "Columnwise", &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &ldwork);
/*              Apply H to A(i:m,i+ib:n) from the left */

        i__2 = *m - i__ + 1;
        i__3 = *n - i__ - ib + 1;
        slarfb_("Left", "No transpose", "Forward", "Columnwise", &
            i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
            1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &
            work[ib + 1], &ldwork);
        }

/*           Apply H to rows i:m of current block */

        i__2 = *m - i__ + 1;
        sorg2r_(&i__2, &ib, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
            work[1], &iinfo);

/*           Set rows 1:i-1 of current block to zero */

        i__2 = i__ + ib - 1;
        for (j = i__; j <= i__2; ++j) {
        i__3 = i__ - 1;
        for (l = 1; l <= i__3; ++l) {
            a[l + j * a_dim1] = 0.f;
/* L30: */
        }
/* L40: */
        }
/* L50: */
    }
    }

    work[1] = (real) iws;
    return 0;

/*     End of SORGQR */

} /* sorgqr_ */

/* Subroutine */ int sorm2l_(char *side, char *trans, integer *m, integer *n,
    integer *k, real *a, integer *lda, real *tau, real *c__, integer *ldc,
     real *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, i1, i2, i3, mi, ni, nq;
    static real aii;
    static logical left;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *,
        integer *, real *, real *, integer *, real *), xerbla_(
        char *, integer *);
    static logical notran;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORM2L overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'T', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'T',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q' (Transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.


注释：
    A       (input) REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.



# 输入参数 A，实数数组，维度为 (LDA,K)
# 每列 i 必须包含向量，定义了第 i 个初等反射器 H(i)，i = 1,2,...,k，由 SGEQLF 在其参数数组 A 的最后 k 列返回。
# 算法会修改 A，但在退出时会恢复。

LDA     (input) INTEGER
        The leading dimension of the array A.
        If SIDE = 'L', LDA >= max(1,M);
        if SIDE = 'R', LDA >= max(1,N).



# 输入参数 LDA，整数
# 数组 A 的主维度。
# 如果 SIDE = 'L'，则要求 LDA >= max(1,M)；
# 如果 SIDE = 'R'，则要求 LDA >= max(1,N)。

TAU     (input) REAL array, dimension (K)
        TAU(i) must contain the scalar factor of the elementary
        reflector H(i), as returned by SGEQLF.



# 输入参数 TAU，实数数组，维度为 (K)
# TAU(i) 必须包含初等反射器 H(i) 的标量因子，由 SGEQLF 返回。

C       (input/output) REAL array, dimension (LDC,N)
        On entry, the m by n matrix C.
        On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.



# 输入/输出参数 C，实数数组，维度为 (LDC,N)
# 在输入时，是 m 行 n 列的矩阵 C。
# 在退出时，C 被 Q*C 或 Q'*C 或 C*Q' 或 C*Q 覆盖。

LDC     (input) INTEGER
        The leading dimension of the array C. LDC >= max(1,M).



# 输入参数 LDC，整数
# 数组 C 的主维度，要求 LDC >= max(1,M)。

WORK    (workspace) REAL array, dimension
                                 (N) if SIDE = 'L',
                                 (M) if SIDE = 'R'



# 输入参数 WORK，工作空间，实数数组，维度为
# (N)，如果 SIDE = 'L'；
# (M)，如果 SIDE = 'R'。

INFO    (output) INTEGER
        = 0: successful exit
        < 0: if INFO = -i, the i-th argument had an illegal value



# 输出参数 INFO，整数
# = 0：成功退出。
# < 0：如果 INFO = -i，则第 i 个参数的值非法。

=====================================================================


   Test the input arguments



# 测试输入参数的有效性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

参数调整：
- 设置数组 `a` 的维度和偏移量。
- 减小指针 `tau` 以及二维数组 `c__` 和一维数组 `work`。


    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

函数主体：
- 将 `*info` 初始化为 `0`。
- 使用 `lsame_` 函数检查 `side` 是否为 `"L"` 并将结果赋给 `left`。
- 使用 `lsame_` 函数检查 `trans` 是否为 `"N"` 并将结果赋给 `notran`。


/*     NQ is the order of Q */

    if (left) {
    nq = *m;
    } else {
    nq = *n;
    }

`NQ` 是 `Q` 的阶数：
- 如果 `left` 为真，则 `nq` 被设为 `*m`。
- 否则，`nq` 被设为 `*n`。


    if (! left && ! lsame_(side, "R")) {
    *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
    *info = -2;
    } else if (*m < 0) {
    *info = -3;
    } else if (*n < 0) {
    *info = -4;
    } else if (*k < 0 || *k > nq) {
    *info = -5;
    } else if (*lda < max(1,nq)) {
    *info = -7;
    } else if (*ldc < max(1,*m)) {
    *info = -10;
    }

检查输入参数有效性：
- 如果 `side` 不是 `"R"` 且 `left` 为假，则将 `*info` 设为 `-1`。
- 如果 `trans` 不是 `"T"` 且 `notran` 为假，则将 `*info` 设为 `-2`。
- 如果 `*m` 小于 `0`，则将 `*info` 设为 `-3`。
- 如果 `*n` 小于 `0`，则将 `*info` 设为 `-4`。
- 如果 `*k` 小于 `0` 或大于 `nq`，则将 `*info` 设为 `-5`。
- 如果 `*lda` 小于 `max(1, nq)`，则将 `*info` 设为 `-7`。
- 如果 `*ldc` 小于 `max(1, *m)`，则将 `*info` 设为 `-10`。


    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SORM2L", &i__1);
    return 0;
    }

如果 `*info` 不等于 `0`，则调用 `xerbla_` 函数报错并返回。


/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
    return 0;
    }

如果 `*m`、`*n` 或 `*k` 中任何一个为 `0`，则立即返回。


    if (left && notran || ! left && ! notran) {
    i1 = 1;
    i2 = *k;
    i3 = 1;
    } else {
    i1 = *k;
    i2 = 1;
    i3 = -1;
    }

根据 `side` 和 `trans` 的值设置循环的起始、结束和步长。


    if (left) {
    ni = *n;
    } else {
    mi = *m;
    }

根据 `left` 的值设置 `ni` 或 `mi`。


    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    if (left) {

循环开始，根据 `left` 设置 `mi` 或 `ni`。


/*           H(i) is applied to C(1:m-k+i,1:n) */

        mi = *m - *k + i__;
    } else {

如果 `left` 为假，则应用 `H(i)` 到 `C(1:m,1:n-k+i)`。


/*           H(i) is applied to C(1:m,1:n-k+i) */

        ni = *n - *k + i__;
    }

如果 `left` 为真，则应用 `H(i)` 到 `C(1:m-k+i,1:n)`。


/*        Apply H(i) */

    aii = a[nq - *k + i__ + i__ * a_dim1];
    a[nq - *k + i__ + i__ * a_dim1] = 1.f;
    slarf_(side, &mi, &ni, &a[i__ * a_dim1 + 1], &c__1, &tau[i__], &c__[
        c_offset], ldc, &work[1]);
    a[nq - *k + i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

应用 `H(i)`，并恢复 `a` 的值。


/*     End of SORM2L */

} /* sorm2l_ */

子程序 `sorm2l_` 的结束。
    # 测试输入参数的合法性
    IF (M.LT.0) THEN
        INFO = -3
    ELSE IF (N.LT.0) THEN
        INFO = -4
    ELSE IF (K.LT.0) THEN
        INFO = -5
    ELSE IF (LDA.LT.MAX(1,M)) THEN
        INFO = -7
    ELSE IF (LDC.LT.MAX(1,M)) THEN
        INFO = -10
    ELSE IF ((SIDE.NE.'L').AND.(SIDE.NE.'R')) THEN
        INFO = -1
    ELSE IF ((TRANS.NE.'N').AND.(TRANS.NE.'T')) THEN
        INFO = -2
    ELSE
        INFO = 0
    END IF
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
c_dim1 = *ldc;
c_offset = 1 + c_dim1;
c__ -= c_offset;
--work;


/* Function Body */
*info = 0;
left = lsame_(side, "L");
notran = lsame_(trans, "N");

/* NQ is the order of Q */
if (left) {
    nq = *m;
} else {
    nq = *n;
}

if (! left && ! lsame_(side, "R")) {
    *info = -1;
} else if (! notran && ! lsame_(trans, "T")) {
    *info = -2;
} else if (*m < 0) {
    *info = -3;
} else if (*n < 0) {
    *info = -4;
} else if (*k < 0 || *k > nq) {
    *info = -5;
} else if (*lda < max(1,nq)) {
    *info = -7;
} else if (*ldc < max(1,*m)) {
    *info = -10;
}

if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SORM2R", &i__1);
    return 0;
}

/* Quick return if possible */
if (*m == 0 || *n == 0 || *k == 0) {
    return 0;
}

if (left && ! notran || ! left && notran) {
    i1 = 1;
    i2 = *k;
    i3 = 1;
} else {
    i1 = *k;
    i2 = 1;
    i3 = -1;
}

if (left) {
    ni = *n;
    jc = 1;
} else {
    mi = *m;
    ic = 1;
}

i__1 = i2;
i__2 = i3;
for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    if (left) {
        
/* H(i) is applied to C(i:m,1:n) */
        mi = *m - i__ + 1;
        ic = i__;
    } else {
        
/* H(i) is applied to C(1:m,i:n) */
        ni = *n - i__ + 1;
        jc = i__;
    }

/* Apply H(i) */
    aii = a[i__ + i__ * a_dim1];
    a[i__ + i__ * a_dim1] = 1.f;
    slarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &tau[i__], &c__[
        ic + jc * c_dim1], ldc, &work[1]);
    a[i__ + i__ * a_dim1] = aii;
/* L10: */
}

return 0;

/* End of SORM2R */
    # 定义外部声明的子例程 sormqr_，该子例程接受多个参数，包括字符、整数和实数数组，用于进行矩阵乘法的相关计算
    extern /* Subroutine */ int sormqr_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,
       Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
       November 2006

    Purpose
    =======
    
    If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      P * C          C * P
    TRANS = 'T':      P**T * C       C * P**T

    Here Q and P**T are the orthogonal matrices determined by SGEBRD when
    reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
    P**T are defined as products of elementary reflectors H(i) and G(i)
    respectively.

    Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
    order of the orthogonal matrix Q or P**T that is applied.

    If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
    if nq >= k, Q = H(1) H(2) . . . H(k);
    if nq < k, Q = H(1) H(2) . . . H(nq-1).

    If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
    if k < nq, P = G(1) G(2) . . . G(k);
    if k >= nq, P = G(1) G(2) . . . G(nq-1).

    Arguments
    ==========
    
    VECT    (input) CHARACTER*1
            = 'Q': apply Q or Q**T;
            = 'P': apply P or P**T.

    SIDE    (input) CHARACTER*1
            = 'L': apply Q, Q**T, P or P**T from the Left;
            = 'R': apply Q, Q**T, P or P**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q  or P;
            = 'T':  Transpose, apply Q**T or P**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by SGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by SGEBRD.
            K >= 0.

    A       (input) REAL array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by SGEBRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).

    TAU     (input) REAL array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by SGEBRD in the array argument TAUQ or TAUP.
*/
    ! 测试输入参数

    C       (input/output) REAL array, dimension (LDC,N)
            ! 输入参数: M × N 矩阵 C。
            ! 输出参数: C 被 Q*C、Q**T*C、C*Q**T、C*Q、P*C、P**T*C、C*P 或 C*P**T 覆盖。

    LDC     (input) INTEGER
            ! 输入参数: 数组 C 的第一个维度。要求 LDC >= max(1,M)。

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            ! 工作空间: 在 INFO = 0 时，WORK(1) 返回最优 LWORK。

    LWORK   (input) INTEGER
            ! 输入参数: 数组 WORK 的维度。
            ! 如果 SIDE = 'L'，要求 LWORK >= max(1,N)；
            ! 如果 SIDE = 'R'，要求 LWORK >= max(1,M)。
            ! 对于最佳性能，如果 SIDE = 'L'，则要求 LWORK >= N*NB；
            ! 如果 SIDE = 'R'，则要求 LWORK >= M*NB，其中 NB 是最优的块大小。
            ! 如果 LWORK = -1，则假定为工作空间查询；函数仅计算 WORK 数组的最佳大小，
            ! 并将此值作为 WORK 数组的第一个条目返回，同时 XERBLA 不会报告与 LWORK 相关的错误消息。

    INFO    (output) INTEGER
            ! 输出参数:
            ! = 0: 成功退出。
            ! < 0: 如果 INFO = -i，则第 i 个参数的值非法。

    =====================================================================
    
       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    applyq = lsame_(vect, "Q");
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q or P and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }

    if (! applyq && ! lsame_(vect, "P")) {
        *info = -1;
    } else if (! left && ! lsame_(side, "R")) {
        *info = -2;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -3;
    } else if (*m < 0) {
        *info = -4;
    } else if (*n < 0) {
        *info = -5;
    } else if (*k < 0) {
        *info = -6;
    } else {
        /* Computing MAX */
        i__1 = 1, i__2 = min(nq,*k);
        if (applyq && *lda < max(1,nq) || ! applyq && *lda < max(i__1,i__2)) {
            *info = -8;
        } else if (*ldc < max(1,*m)) {
            *info = -11;
        } else if (*lwork < max(1,nw) && ! lquery) {
            *info = -13;
        }
    }

    if (*info == 0) {
        if (applyq) {
            if (left) {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "SORMQR", ch__1, &i__1, n, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "SORMQR", ch__1, m, &i__1, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        } else {
            if (left) {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "SORMLQ", ch__1, &i__1, n, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Writing concatenation */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "SORMLQ", ch__1, m, &i__1, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        }
        lwkopt = max(1,nw) * nb;
        work[1] = (real) lwkopt;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORMBR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    work[1] = 1.f;
    if (*m == 0 || *n == 0) {
        return 0;
    }

    if (applyq) {

        /* Apply Q */

        if (nq >= *k) {
/*           Q was determined by a call to SGEBRD with nq >= k */
sormqr_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
    c_offset], ldc, &work[1], lwork, &iinfo);




/*           Q was determined by a call to SGEBRD with nq < k */
if (nq > 1) {
    if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
    } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
    }
    i__1 = nq - 1;
    sormqr_(side, trans, &mi, &ni, &i__1, &a[a_dim1 + 2], lda, &tau[1]
        , &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
}




/*        Apply P */
if (notran) {
    *(unsigned char *)transt = 'T';
} else {
    *(unsigned char *)transt = 'N';
}




/*           P was determined by a call to SGEBRD with nq > k */
if (nq > *k) {
    sormlq_(side, transt, m, n, k, &a[a_offset], lda, &tau[1], &c__[
        c_offset], ldc, &work[1], lwork, &iinfo);
} else if (nq > 1) {
    if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
    } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
    }
    i__1 = nq - 1;
    sormlq_(side, transt, &mi, &ni, &i__1, &a[(a_dim1 << 1) + 1], lda,
         &tau[1], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &
        iinfo);
}




work[1] = (real) lwkopt;
return 0;

/*     End of SORMBR */

} /* sormbr_ */




/* Subroutine */ int sormhr_(char *side, char *trans, integer *m, integer *n,
    integer *ilo, integer *ihi, real *a, integer *lda, real *tau, real *
    c__, integer *ldc, real *work, integer *lwork, integer *info)
{


注释：
    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    IHI-ILO elementary reflectors, as returned by SGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    ILO     (input) INTEGER
            IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of SGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.

    A       (input) REAL array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by SGEHRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.

    TAU     (input) REAL array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEHRD.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    =====================================================================
    # 进行输入参数的测试和验证

       if len(sys.argv) != 2:
    # 检查命令行参数的数量是否为2，如果不是，说明参数数量错误
           print("Usage: python script.py <filename>")
    # 打印提示信息，说明正确的使用方式
           sys.exit(1)
    # 退出程序，返回状态码1表示错误退出

       filename = sys.argv[1]
    # 从命令行参数中获取文件名，这里假设第二个参数是文件名

    # =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

参数调整：对输入参数进行调整，这些参数是用于指定数组维度和偏移量的。


    /* Function Body */
    *info = 0;
    nh = *ihi - *ilo;
    left = lsame_(side, "L");
    lquery = *lwork == -1;

函数体：设置初始值，计算变量 `nh` 和 `left`，并检查是否需要查询工作空间大小。


/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
    nq = *m;
    nw = *n;
    } else {
    nq = *n;
    nw = *m;
    }

`NQ` 是矩阵 Q 的阶数，`NW` 是工作空间的最小维度，根据 `side` 的值设置这些变量。


    if (! left && ! lsame_(side, "R")) {
    *info = -1;
    } else if (! lsame_(trans, "N") && ! lsame_(trans,
        "T")) {
    *info = -2;
    } else if (*m < 0) {
    *info = -3;
    } else if (*n < 0) {
    *info = -4;
    } else if (*ilo < 1 || *ilo > max(1,nq)) {
    *info = -5;
    } else if (*ihi < min(*ilo,nq) || *ihi > nq) {
    *info = -6;
    } else if (*lda < max(1,nq)) {
    *info = -8;
    } else if (*ldc < max(1,*m)) {
    *info = -11;
    } else if (*lwork < max(1,nw) && ! lquery) {
    *info = -13;
    }

检查输入参数的有效性，根据不同情况设置错误代码到 `info`。


    if (*info == 0) {
    if (left) {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        nb = ilaenv_(&c__1, "SORMQR", ch__1, &nh, n, &nh, &c_n1, (ftnlen)
            6, (ftnlen)2);
    } else {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        nb = ilaenv_(&c__1, "SORMQR", ch__1, m, &nh, &nh, &c_n1, (ftnlen)
            6, (ftnlen)2);
    }
    lwkopt = max(1,nw) * nb;
    work[1] = (real) lwkopt;
    }

如果输入参数有效，则计算所需的工作空间大小 `lwkopt`，并将其存储在 `work` 数组中。


    if (*info != 0) {
    i__2 = -(*info);
    xerbla_("SORMHR", &i__2);
    return 0;
    } else if (lquery) {
    return 0;
    }

如果有错误，调用错误处理程序；如果是查询状态，则直接返回。


/*     Quick return if possible */

    if (*m == 0 || *n == 0 || nh == 0) {
    work[1] = 1.f;
    return 0;
    }

如果 `m` 或 `n` 的某些值为零，或者 `nh` 为零，则快速返回。


    if (left) {
    mi = nh;
    ni = *n;
    i1 = *ilo + 1;
    i2 = 1;
    } else {
    mi = *m;
    ni = nh;
    i1 = 1;
    i2 = *ilo + 1;
    }

根据 `side` 的值设置 `mi`、`ni`、`i1` 和 `i2` 的值。


    sormqr_(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &
        tau[*ilo], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);

    work[1] = (real) lwkopt;
    return 0;

/*     End of SORMHR */

} /* sormhr_ */

调用 LAPACK 中的 `sormqr_` 子程序执行实际操作，然后更新工作空间的大小，并返回结果。

/* Subroutine */ int sorml2_(char *side, char *trans, integer *m, integer *n,
    integer *k, real *a, integer *lda, real *tau, real *c__, integer *ldc,
     real *work, integer *info)
{
    /* System generated locals */
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORML2 overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'T', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'T',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by SGELQF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q' (Transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) REAL array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) REAL array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

    /* NQ is the order of Q */
    if (left) {
        nq = *m;
    } else {
        nq = *n;
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,*k)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORML2", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        return 0;
    }

    if (left && notran || ! left && ! notran) {
        i1 = 1;
        i2 = *k;
        i3 = 1;
    } else {
        i1 = *k;
        i2 = 1;
        i3 = -1;
    }

    if (left) {
        ni = *n;
        jc = 1;
    } else {
        mi = *m;
        ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
        if (left) {
            /* H(i) is applied to C(i:m,1:n) */
            mi = *m - i__ + 1;
            ic = i__;
        } else {
            /* H(i) is applied to C(1:m,i:n) */
            ni = *n - i__ + 1;
            jc = i__;
        }

        /* Apply H(i) */
        aii = a[i__ + i__ * a_dim1];
        a[i__ + i__ * a_dim1] = 1.f;
        slarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], lda, &tau[i__], &c__[
            ic + jc * c_dim1], ldc, &work[1]);
        a[i__ + i__ * a_dim1] = aii;
    }
    return 0;

/* End of SORML2 */
    # 声明一个外部的子程序 `slarft_`，该子程序接受一些参数并执行某些功能
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);

    # 声明一个静态逻辑变量 `notran`，用于标识是否进行转置操作
    static logical notran;

    # 声明一个静态整数变量 `ldwork`，用于指定工作数组的维度
    static integer ldwork;

    # 声明一个静态字符数组 `transt`，长度为1，用于存储转置类型的标志
    static char transt[1];

    # 声明一个静态整数变量 `lwkopt`，用于存储可选工作数组的大小
    static integer lwkopt;

    # 声明一个静态逻辑变量 `lquery`，用于查询工作数组大小的标志
    static logical lquery;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORMLQ overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) REAL array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGELQF.

    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            工作数组 WORK 的维度。
            如果 SIDE = 'L'，则要求 LWORK >= max(1,N);
            如果 SIDE = 'R'，则要求 LWORK >= max(1,M)。
            为了达到最佳性能，如果 SIDE = 'L'，则推荐 LWORK >= N*NB；
            如果 SIDE = 'R'，则推荐 LWORK >= M*NB，其中 NB 是最优块大小。

            如果 LWORK = -1，则假定为工作空间查询；该例程只计算 WORK 数组的最优大小，
            并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会因为 LWORK 相关的错误而发出错误消息。

    INFO    (output) INTEGER
            = 0:  成功退出
            < 0:  如果 INFO = -i，则第 i 个参数的值非法

    =====================================================================


       测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;   /* 调整数组 a 的指针，使其指向正确的起始位置 */
    --tau;   /* 将 tau 数组的指针前移一位 */

    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;   /* 调整数组 c__ 的指针，使其指向正确的起始位置 */
    --work;   /* 将 work 数组的指针前移一位 */

    /* Function Body */
    *info = 0;   /* 将 info 参数初始化为 0 */
    left = lsame_(side, "L");   /* 检查 side 是否为 "L"，返回布尔值给 left */
    notran = lsame_(trans, "N");   /* 检查 trans 是否为 "N"，返回布尔值给 notran */
    lquery = *lwork == -1;   /* 检查 lwork 是否为 -1，返回布尔值给 lquery */

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;   /* 如果 side 是 "L"，则 nq 为 m */
        nw = *n;   /* 如果 side 是 "L"，则 nw 为 n */
    } else {
        nq = *n;   /* 否则 nq 为 n */
        nw = *m;   /* 否则 nw 为 m */
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;   /* 如果 side 既不是 "L" 也不是 "R"，则设置错误代码 -1 */
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;   /* 如果 trans 既不是 "N" 也不是 "T"，则设置错误代码 -2 */
    } else if (*m < 0) {
        *info = -3;   /* 如果 m 小于 0，设置错误代码 -3 */
    } else if (*n < 0) {
        *info = -4;   /* 如果 n 小于 0，设置错误代码 -4 */
    } else if (*k < 0 || *k > nq) {
        *info = -5;   /* 如果 k 小于 0 或者大于 nq，设置错误代码 -5 */
    } else if (*lda < max(1,*k)) {
        *info = -7;   /* 如果 lda 小于 max(1, k)，设置错误代码 -7 */
    } else if (*ldc < max(1,*m)) {
        *info = -10;  /* 如果 ldc 小于 max(1, m)，设置错误代码 -10 */
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;  /* 如果 lwork 小于 max(1, nw) 且不是查询模式，设置错误代码 -12 */
    }

    if (*info == 0) {
        /* Determine the block size. NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);   /* 连接 side 和 trans 字符串 */
        i__1 = 64, i__2 = ilaenv_(&c__1, "SORMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);   /* 计算并设置合适的块大小 nb */
        lwkopt = max(1,nw) * nb;
        work[1] = (real) lwkopt;   /* 将所需的工作空间大小存入 work[1] */
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORMLQ", &i__1);   /* 如果有错误，调用错误处理函数 xerbla_ */
        return 0;   /* 返回 0 */
    } else if (lquery) {
        return 0;   /* 如果是查询模式，直接返回 0 */
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1] = 1.f;   /* 如果 m、n 或 k 中有任何一个为 0，则将 work[1] 设为 1.0 并返回 */
        return 0;
    }

    nbmin = 2;   /* 设置最小块大小为 2 */
    ldwork = nw;   /* 设置 ldwork 为 nw */
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;   /* 如果 lwork 不够大，重新计算 nb */
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "SORMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);   /* 重新计算最小块大小 nbmin */
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        sorml2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        if (notran) {
            *(unsigned char *)transt = 'T';   /* 如果不是转置模式，设置 transt 为 'T' */
        } else {
            *(unsigned char *)transt = 'N';   /* 否则设置 transt 为 'N' */
        }

        /* Loop over blocks */
        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);   /* 计算当前块的大小 ib */
/*
             Form the triangular factor of the block reflector
             H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__4 = nq - i__ + 1;
        slarft_("Forward", "Rowwise", &i__4, &ib, &a[i__ + i__ * a_dim1],
            lda, &tau[i__], t, &c__65);
        if (left) {

/*              H or H' is applied to C(i:m,1:n) */

        mi = *m - i__ + 1;
        ic = i__;
        } else {

/*              H or H' is applied to C(1:m,i:n) */

        ni = *n - i__ + 1;
        jc = i__;
        }

/*           Apply H or H' */

        slarfb_(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__
            + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1],
            ldc, &work[1], &ldwork);
/* L10: */
    }
    }
    work[1] = (real) lwkopt;
    return 0;

/*     End of SORMLQ */

} /* sormlq_ */

/* Subroutine */ int sormql_(char *side, char *trans, integer *m, integer *n,
    integer *k, real *a, integer *lda, real *tau, real *c__, integer *ldc,
     real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static real t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int sorm2l_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *), slarfb_(char *, char *, char *, char *
        , integer *, integer *, integer *, real *, integer *, real *,
        integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORMQL overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.


*/
    ! 定义字符型输入 TRANS，表示是否对矩阵 C 进行转置操作
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    ! 定义整型输入 M，表示矩阵 C 的行数，要求 M >= 0
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    ! 定义整型输入 N，表示矩阵 C 的列数，要求 N >= 0
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    ! 定义整型输入 K，表示定义矩阵 Q 的元素反射器的数量
    ! 如果 SIDE = 'L'，要求 M >= K >= 0；
    ! 如果 SIDE = 'R'，要求 N >= K >= 0
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    ! 定义实型数组输入 A，维度为 (LDA,K)
    ! 每列包含由 SGEQLF 返回的第 i 列向量，定义了元素反射器 H(i)
    ! A 在程序执行过程中被修改，但在退出时被恢复
    A       (input) REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.

    ! 定义整型输入 LDA，数组 A 的主维度
    ! 如果 SIDE = 'L'，要求 LDA >= max(1,M)；
    ! 如果 SIDE = 'R'，要求 LDA >= max(1,N)
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).

    ! 定义实型数组输入 TAU，维度为 (K)
    ! TAU(i) 包含由 SGEQLF 返回的元素反射器 H(i) 的标量因子
    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQLF.

    ! 定义实型数组输入/输出 C，维度为 (LDC,N)
    ! 在输入时，为 MxN 的矩阵 C
    ! 在输出时，可能被 Q*C、Q**T*C、C*Q**T 或 C*Q 覆盖
    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    ! 定义整型输入 LDC，数组 C 的主维度，要求 LDC >= max(1,M)
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    ! 定义实型数组工作空间输出 WORK，维度为 (MAX(1,LWORK))
    ! 如果 INFO = 0，那么 WORK(1) 返回最优 LWORK
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    ! 定义整型输入 LWORK，工作数组 WORK 的维度
    ! 如果 SIDE = 'L'，要求 LWORK >= max(1,N)；
    ! 如果 SIDE = 'R'，要求 LWORK >= max(1,M)
    ! 为了最佳性能，如果 SIDE = 'L'，推荐 LWORK >= N*NB；
    ! 如果 SIDE = 'R'，推荐 LWORK >= M*NB，其中 NB 是最优块大小
    ! 如果 LWORK = -1，那么假设进行工作空间查询；函数计算最优的 WORK 数组大小
    ! 返回第一个 WORK 数组条目作为 LWORK，且 XERBLA 不会因 LWORK 相关的错误信息而发出错误消息
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    ! 定义整型输出 INFO
    ! INFO = 0 表示成功退出
    ! INFO < 0 表示第 -INFO 个参数有非法值
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    ! 分割线，测试输入参数的有效性
    =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = max(1,*n);
    } else {
        nq = *n;
        nw = max(1,*m);
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }

    if (*info == 0) {
        if (*m == 0 || *n == 0) {
            lwkopt = 1;
        } else {
            /* Determine the block size. NB may be at most NBMAX, where NBMAX is used to define the local array T. */
            char ch__1[2];
            snprintf(ch__1, sizeof(ch__1), "%c%c", *side, *trans);
            i__1 = 64, i__2 = ilaenv_(&c__1, "SORMQL", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nb = min(i__1,i__2);
            lwkopt = nw * nb;
        }
        work[1] = (real) lwkopt;

        if (*lwork < nw && ! lquery) {
            *info = -12;
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORMQL", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            char ch__1[2];
            snprintf(ch__1, sizeof(ch__1), "%c%c", *side, *trans);
            i__1 = 2, i__2 = ilaenv_(&c__2, "SORMQL", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        sorm2l_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
        } else {
            mi = *m;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);

            /* Call to the blocked routine */
            sorm2r_(side, trans, &mi, &ni, &ib, &a[i__ + a_dim1], lda, &tau[i__], &c__[i__ + c_dim1], ldc, &work[1], &iinfo);
        }
    }
/*
             Form the triangular factor of the block reflector
             H = H(i+ib-1) . . . H(i+1) H(i)
*/

        i__4 = nq - *k + i__ + ib - 1;
        slarft_("Backward", "Columnwise", &i__4, &ib, &a[i__ * a_dim1 + 1]
            , lda, &tau[i__], t, &c__65);
        if (left) {

/*              H or H' is applied to C(1:m-k+i+ib-1,1:n) */

        mi = *m - *k + i__ + ib - 1;
        } else {

/*              H or H' is applied to C(1:m,1:n-k+i+ib-1) */

        ni = *n - *k + i__ + ib - 1;
        }

/*           Apply H or H' */

        slarfb_(side, trans, "Backward", "Columnwise", &mi, &ni, &ib, &a[
            i__ * a_dim1 + 1], lda, t, &c__65, &c__[c_offset], ldc, &
            work[1], &ldwork);
/* L10: */
    }
    }
    work[1] = (real) lwkopt;
    return 0;

/*     End of SORMQL */

} /* sormql_ */

/* Subroutine */ int sormqr_(char *side, char *trans, integer *m, integer *n,
    integer *k, real *a, integer *lda, real *tau, real *c__, integer *ldc,
     real *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static real t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int sorm2r_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *), slarfb_(char *, char *, char *, char *
        , integer *, integer *, integer *, real *, integer *, real *,
        integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *,
        real *, integer *, real *, real *, integer *);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SORMQR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

*/


注释部分已经超过了允许的长度限制。在这种情况下，务必将其分为两部分
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
    A       (input) REAL array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            SGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
    TAU     (input) REAL array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SGEQRF.
    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    =====================================================================

    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        /* Determine the block size.  NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "SORMQR", ch__1, m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1] = (real) lwkopt;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SORMQR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1] = 1.f;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "SORMQR", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        sorm2r_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && ! notran || ! left && notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);

            /* Form the triangular factor of the block reflector
               H = H(i) H(i+1) . . . H(i+ib-1) */
        i__4 = nq - i__ + 1;
        slarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], t, &c__65)
            ;


# 计算对称三角矩阵乘积
计算对称三角矩阵的乘积，以准备用于后续的乘法操作。



        if (left) {


# 判断是否左乘
如果 `left` 为真，则表示需要将变换应用到 C(i:m,1:n) 区域。



        mi = *m - i__ + 1;
        ic = i__;
        } else {


# 设置右乘参数
如果 `left` 为假，则表示需要将变换应用到 C(1:m,i:n) 区域。



        ni = *n - i__ + 1;
        jc = i__;
        }


# 设置右乘参数（续）
根据 `left` 的值，设置对右乘操作的参数 `ni` 和 `jc`。



        slarfb_(side, trans, "Forward", "Columnwise", &mi, &ni, &ib, &a[
            i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc *
            c_dim1], ldc, &work[1], &ldwork);


# 应用变换矩阵
根据给定的参数应用前面计算的变换矩阵到矩阵 C 的指定子区域。



    }
    }
    work[1] = (real) lwkopt;
    return 0;


# 设置工作空间大小
将计算得到的最优工作空间大小保存在 `work` 数组的第一个位置，并返回执行成功。



} /* sormqr_ */


# 结束 SORMQR
标记 SORMQR 子程序的结束。



/* Subroutine */ int sormtr_(char *side, char *uplo, char *trans, integer *m,
    integer *n, real *a, integer *lda, real *tau, real *c__, integer *ldc,
     real *work, integer *lwork, integer *info)
{


# SORMTR 子程序
SORMTR 子程序开始，用于实现矩阵乘法的一般实现。



    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2, i__3;
    char ch__1[2];


# 系统生成的本地变量
定义了一些系统生成的本地变量和数组，用于支持后续的计算和操作。



    /* Local variables */
    static integer i1, i2, nb, mi, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    static logical upper;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int sormql_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);
    static integer lwkopt;
    static logical lquery;
    extern /* Subroutine */ int sormqr_(char *, char *, integer *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *);


# 本地变量和外部子程序声明
定义了一些本地变量，并声明了用于 LAPACK 计算的一些外部子程序。



/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


# LAPACK 版本信息
这段注释描述了 LAPACK 软件包的版本和提供者信息。



    Purpose
    =======


# 功能
SORMTR 的功能说明部分开始。



    SORMTR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T


# SORMTR 功能说明（续）
描述了 SORMTR 如何用变换矩阵 Q 或其转置 Q**T 来覆盖一般的实数 M-by-N 矩阵 C。



    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    nq-1 elementary reflectors, as returned by SSYTRD:

    if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

    if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).


# 变换矩阵 Q 的定义
详细描述了变换矩阵 Q 是如何通过 nq-1 个初等反射器的乘积来定义的，这些反射器由 SSYTRD 返回：

- 如果 UPLO = 'U'，则 Q = H(nq-1) . . . H(2) H(1);
- 如果 UPLO = 'L'，则 Q = H(1) H(2) . . . H(nq-1)。



    Arguments
    =========


# 参数
下面是 SORMTR 的输入参数说明。



    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.


# SIDE 参数说明
指定了是从左边应用变换 Q 或 Q**T 还是从右边应用。



    UPLO    (input) CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from SSYTRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from SSYTRD.


# UPLO 参数说明
指定了矩阵 A 中存储的元素反射器是位于上三角还是下三角。



    TRANS   (input) CHARACTER*1
            = 'N': No transpose, apply Q;
            = 'T': Transpose, apply Q**T.


# TRANS 参数说明
指定了是应用变换 Q 还是其转置 Q**T。



    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.


# M 参数说明
矩阵 C 的行数。



    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.


# N 参数说明
矩阵 C 的列数。



    A       (input) REAL array, dimension
                               (LDA,M) if SIDE = 'L'
                               (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors,
            as returned by SSYTRD. On entry, the diagonal
            and first superdiagonal of A are set to contain
            the diagonal and first superdiagonal of the
            tridiagonal matrix T. If UPLO = 'U', the first
            superdiagonal is stored in A(2:nq,1), and the
            diagonal in A(1:nq,2). If UPLO = 'L', the
            subdiagonal is stored in A(1:nq-1,2), and the
    UPLO    (input) CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from SSYTRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from SSYTRD.
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    A       (input) REAL array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by SSYTRD.
    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
    TAU     (input) REAL array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by SSYTRD.
    C       (input/output) REAL array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    =====================================================================
       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! upper && ! lsame_(uplo, "L")) {
        *info = -2;
    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
        *info = -3;
    } else if (*m < 0) {
        *info = -4;
    } else if (*n < 0) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        if (upper) {
            if (left) {
                /* Constructing a string concatenation for ILAENV function */
                i__1[0] = 1, a__1[0] = side;
                i__1[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *m - 1;
                i__3 = *m - 1;
                nb = ilaenv_(&c__1, "SORMQL", ch__1, &i__2, n, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Constructing a string concatenation for ILAENV function */
                i__1[0] = 1, a__1[0] = side;
                i__1[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *n - 1;
                i__3 = *n - 1;
                nb = ilaenv_(&c__1, "SORMQL", ch__1, m, &i__2, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        } else {
            if (left) {
                /* Constructing a string concatenation for ILAENV function */
                i__1[0] = 1, a__1[0] = side;
                i__1[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *m - 1;
                i__3 = *m - 1;
                nb = ilaenv_(&c__1, "SORMQR", ch__1, &i__2, n, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Constructing a string concatenation for ILAENV function */
                i__1[0] = 1, a__1[0] = side;
                i__1[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *n - 1;
                i__3 = *n - 1;
                nb = ilaenv_(&c__1, "SORMQR", ch__1, m, &i__2, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        }
        lwkopt = max(1,nw) * nb;
        work[1] = (real) lwkopt;
    }

    if (*info != 0) {
        i__2 = -(*info);
        xerbla_("SORMTR", &i__2);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || nq == 1) {
        work[1] = 1.f;
        return 0;
    }

    if (left) {
        mi = *m - 1;
        ni = *n;
    } else {
        mi = *m;
        ni = *n - 1;
    }

    if (upper) {
        /* Q was determined by a call to SSYTRD with UPLO = 'U' */
        i__2 = nq - 1;
        sormql_(side, trans, &mi, &ni, &i__2, &a[(a_dim1 << 1) + 1], lda, &tau[1], &c__[c_offset], ldc, &work[1], lwork, &iinfo);
    } else {
/*        Q was determined by a call to SSYTRD with UPLO = 'L' */

if (left) {
    i1 = 2;
    i2 = 1;
} else {
    i1 = 1;
    i2 = 2;
}
i__2 = nq - 1;
sormqr_(side, trans, &mi, &ni, &i__2, &a[a_dim1 + 2], lda, &tau[1], &
    c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
}
work[1] = (real) lwkopt;
return 0;

/*     End of SORMTR */

} /* sormtr_ */

/* Subroutine */ int spotf2_(char *uplo, integer *n, real *a, integer *lda,
    integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;
real r__1;

/* Local variables */
static integer j;
static real ajj;
extern doublereal sdot_(integer *, real *, integer *, real *, integer *);
extern logical lsame_(char *, char *);
extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
    sgemv_(char *, integer *, integer *, real *, real *, integer *,
    real *, integer *, real *, real *, integer *);
static logical upper;
extern /* Subroutine */ int xerbla_(char *, integer *);
extern logical sisnan_(real *);

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

SPOTF2 computes the Cholesky factorization of a real symmetric
positive definite matrix A.

The factorization has the form
   A = U' * U ,  if UPLO = 'U', or
   A = L  * L',  if UPLO = 'L',
where U is an upper triangular matrix and L is lower triangular.

This is the unblocked version of the algorithm, calling Level 2 BLAS.

Arguments
=========

UPLO    (input) CHARACTER*1
        Specifies whether the upper or lower triangular part of the
        symmetric matrix A is stored.
        = 'U':  Upper triangular
        = 'L':  Lower triangular

N       (input) INTEGER
        The order of the matrix A.  N >= 0.

A       (input/output) REAL array, dimension (LDA,N)
        On entry, the symmetric matrix A.  If UPLO = 'U', the leading
        n by n upper triangular part of A contains the upper
        triangular part of the matrix A, and the strictly lower
        triangular part of A is not referenced.  If UPLO = 'L', the
        leading n by n lower triangular part of A contains the lower
        triangular part of the matrix A, and the strictly upper
        triangular part of A is not referenced.

        On exit, if INFO = 0, the factor U or L from the Cholesky
        factorization A = U'*U  or A = L*L'.

LDA     (input) INTEGER
        The leading dimension of the array A.  LDA >= max(1,N).
    # INFO (output) INTEGER
    # 返回的整数表示程序运行的状态：
    #   = 0：成功退出
    #   < 0：如果 INFO = -k，第 k 个参数具有非法值
    #   > 0：如果 INFO = k，阶数为 k 的主子阵不是正定的，因此无法完成因子分解

    # =====================================================================

    # 检查输入参数是否合法
    # 这部分代码用于测试输入参数的有效性。
/*

    /* Parameter adjustments */
    // 对参数进行调整
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 函数体开始
    *info = 0;
    // 初始化 info 为 0
    upper = lsame_(uplo, "U");
    // 判断是否为上三角矩阵
    if (! upper && ! lsame_(uplo, "L")) {
    // 如果既不是上三角也不是下三角，则设置 info 为 -1
    *info = -1;
    } else if (*n < 0) {
    // 如果 n 小于 0，则设置 info 为 -2
    *info = -2;
    } else if (*lda < max(1,*n)) {
    // 如果 lda 小于 max(1, n)，则设置 info 为 -4
    *info = -4;
    }
    // 如果 info 不为 0，则调用 xerbla_ 函数报错并返回 0
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("SPOTF2", &i__1);
    return 0;
    }

/*     Quick return if possible */

    // 如果 n 为 0，则直接返回 0
    if (*n == 0) {
    return 0;
    }

    // 如果是上三角矩阵
    if (upper) {

/*        Compute the Cholesky factorization A = U'*U. */

    // 计算 Cholesky 分解 A = U'*U

    i__1 = *n;
    // 循环从 1 到 n
    for (j = 1; j <= i__1; ++j) {

/*           Compute U(J,J) and test for non-positive-definiteness. */

        // 计算 U(J,J) 并检查是否为非正定
        i__2 = j - 1;
        ajj = a[j + j * a_dim1] - sdot_(&i__2, &a[j * a_dim1 + 1], &c__1,
            &a[j * a_dim1 + 1], &c__1);
        // 如果 ajj <= 0 或者为 NaN，则将 a[j + j * a_dim1] 赋值为 ajj，并跳转到 L30
        if (ajj <= 0.f || sisnan_(&ajj)) {
        a[j + j * a_dim1] = ajj;
        goto L30;
        }
        ajj = sqrt(ajj);
        a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of row J. */

        // 计算第 J 行的元素 J+1 到 N
        if (j < *n) {
        i__2 = j - 1;
        i__3 = *n - j;
        sgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(j + 1) *
            a_dim1 + 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b15, &
            a[j + (j + 1) * a_dim1], lda);
        i__2 = *n - j;
        r__1 = 1.f / ajj;
        sscal_(&i__2, &r__1, &a[j + (j + 1) * a_dim1], lda);
        }
/* L10: */
    }
    } else {

/*        Compute the Cholesky factorization A = L*L'. */

    // 计算 Cholesky 分解 A = L*L'

    i__1 = *n;
    // 循环从 1 到 n
    for (j = 1; j <= i__1; ++j) {

/*           Compute L(J,J) and test for non-positive-definiteness. */

        // 计算 L(J,J) 并检查是否为非正定
        i__2 = j - 1;
        ajj = a[j + j * a_dim1] - sdot_(&i__2, &a[j + a_dim1], lda, &a[j
            + a_dim1], lda);
        // 如果 ajj <= 0 或者为 NaN，则将 a[j + j * a_dim1] 赋值为 ajj，并跳转到 L30
        if (ajj <= 0.f || sisnan_(&ajj)) {
        a[j + j * a_dim1] = ajj;
        goto L30;
        }
        ajj = sqrt(ajj);
        a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of column J. */

        // 计算第 J 列的元素 J+1 到 N
        if (j < *n) {
        i__2 = *n - j;
        i__3 = j - 1;
        sgemv_("No transpose", &i__2, &i__3, &c_b151, &a[j + 1 +
            a_dim1], lda, &a[j + a_dim1], lda, &c_b15, &a[j + 1 +
            j * a_dim1], &c__1);
        i__2 = *n - j;
        r__1 = 1.f / ajj;
        sscal_(&i__2, &r__1, &a[j + 1 + j * a_dim1], &c__1);
        }
/* L20: */
    }
    }
    // 跳转到 L40
    goto L40;

L30:
    // 设置 info 为 j
    *info = j;

L40:
    // 返回 0
    return 0;

/*     End of SPOTF2 */

} /* spotf2_ */

/* Subroutine */ int spotrf_(char *uplo, integer *n, real *a, integer *lda,
    integer *info)
{
    /* System generated locals */
    // 系统生成的本地变量
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    // 本地变量
    static integer j, jb, nb;
    // 是否为上三角矩阵
    static logical upper;
    // 判断字符相等
    extern logical lsame_(char *, char *);
    // 矩阵乘法
    extern /* Subroutine */ int sgemm_(char *, 
        char *, 
        integer *, 
        integer *,
        integer *, 
        real *, 
        real *, 
        integer *, 
        real *, 
        integer *, 
        real *,
        real *, 
        integer *);
    # 外部声明的几个 Fortran 子程序和函数的原型

    extern /* Subroutine */ int strsm_(char *, char *, char *, char *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        ),
        # strsm_ 子程序原型，用于矩阵运算
        ssyrk_(char *, char *, integer *, integer *, real *, real *, integer *, real *, real *, integer *
        ),
        # ssyrk_ 子程序原型，用于矩阵运算
        spotf2_(char *, integer *, real *, integer *,
        integer *),
        # spotf2_ 子程序原型，用于 Cholesky 分解
        xerbla_(char *, integer *);
        # xerbla_ 子程序原型，用于处理错误信息

    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
        # ilaenv_ 函数原型，用于确定特定环境的参数
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SPOTRF computes the Cholesky factorization of a real symmetric
    positive definite matrix A.

    The factorization has the form
       A = U**T * U,  if UPLO = 'U', or
       A = L  * L**T,  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the block version of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.

    =====================================================================


       Test the input parameters.
*/
    // 调整参数的偏移量和维度
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    // 函数体开始
    *info = 0;  // 初始化 info 为 0
    upper = lsame_(uplo, "U");  // 检查 UPLO 是否为 'U'，返回布尔值
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 UPLO 既不是 'U' 也不是 'L'
    *info = -1;  // 设置 info 为 -1，表示 UPLO 参数非法
    } else if (*n < 0) {  // 如果 N 小于 0
    *info = -2;  // 设置 info 为 -2，表示 N 参数非法
    } else if (*lda < max(1,*n)) {  // 如果 LDA 小于 max(1, N)
    *info = -4;  // 设置 info 为 -4，表示 LDA 参数非法
    }
    if (*info != 0) {  // 如果出现非法参数情况
    i__1 = -(*info);
    xerbla_("SPOTRF", &i__1);  // 调用错误处理程序 xerbla_
    return 0;  // 返回
    }

/*     Quick return if possible */

    if (*n == 0) {  // 如果 N 为 0
    return 0;  // 直接返回
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "SPOTRF", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);  // 确定适合当前环境的块大小 nb

    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code. */

    spotf2_(uplo, n, &a[a_offset], lda, info);  // 调用不带块的 Cholesky 分解函数
    } else {

/*        Use blocked code. */

    if (upper) {  // 如果是上三角存储

/*           Compute the Cholesky factorization A = U'*U. */

        i__1 = *n;
        i__2 = nb;
        for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/*
                Update and factorize the current diagonal block and test
                for non-positive-definiteness.

   Computing MIN
*/
        i__3 = nb, i__4 = *n - j + 1;
        jb = min(i__3,i__4);  // 计算当前块的大小，取 nb 和 (*n - j + 1) 的较小值
        i__3 = j - 1;
        ssyrk_("Upper", "Transpose", &jb, &i__3, &c_b151, &a[j *
            a_dim1 + 1], lda, &c_b15, &a[j + j * a_dim1], lda);  // 执行矩阵乘法和更新，计算 A(j,j)
        spotf2_("Upper", &jb, &a[j + j * a_dim1], lda, info);  // 对 A(j,j) 进行 Cholesky 分解
        if (*info != 0) {
            goto L30;  // 如果 Cholesky 分解失败，跳转到 L30
        }
        if (j + jb <= *n) {

/*                 Compute the current block row. */

            i__3 = *n - j - jb + 1;
            i__4 = j - 1;
            sgemm_("Transpose", "No transpose", &jb, &i__3, &i__4, &
                c_b151, &a[j * a_dim1 + 1], lda, &a[(j + jb) *
                a_dim1 + 1], lda);  // 执行矩阵乘法，计算当前块行的乘积
            i__3 = *n - j - jb + 1;
            strsm_("Left", "Upper", "Transpose", "Non-unit", &jb, &
                i__3, &c_b15, &a[j + j * a_dim1], lda, &a[j + (j
                + jb) * a_dim1], lda);  // 执行矩阵除法，计算当前块行的解
        }
/* L10: */
        }

    } else {

/*           Compute the Cholesky factorization A = L*L'. */

        i__2 = *n;
        i__1 = nb;
        for (j = 1; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*
                Update and factorize the current diagonal block and test
                for non-positive-definiteness.

   Computing MIN
*/
        i__3 = nb, i__4 = *n - j + 1;
        jb = min(i__3,i__4);  // 计算当前块的大小，取 nb 和 (*n - j + 1) 的较小值
        i__3 = j - 1;
        ssyrk_("Lower", "No transpose", &jb, &i__3, &c_b151, &a[j +
            a_dim1], lda, &c_b15, &a[j + j * a_dim1], lda);  // 执行矩阵乘法和更新，计算 A(j,j)
        spotf2_("Lower", &jb, &a[j + j * a_dim1], lda, info);  // 对 A(j,j) 进行 Cholesky 分解
        if (*info != 0) {
            goto L30;  // 如果 Cholesky 分解失败，跳转到 L30
        }
        if (j + jb <= *n) {

/*                 Compute the current block column. */

            i__3 = *n - j - jb + 1;
            i__4 = j - 1;
            sgemm_("No transpose", "Transpose", &i__3, &jb, &i__4, &
                c_b151, &a[j + jb + a_dim1], lda, &a[j + a_dim1],
                lda, &c_b15, &a[j + jb + j * a_dim1], lda);  // 执行矩阵乘法，计算当前块列的乘积
            i__3 = *n - j - jb + 1;
            strsm_("Right", "Lower", "Transpose", "Non-unit", &i__3, &
                jb, &c_b15, &a[j + j * a_dim1], lda, &a[j + jb +
                j * a_dim1], lda);  // 执行矩阵除法，计算当前块列的解
        }
/* L20: */
        }
    }
    }
    goto L40;

L30:
    *info = *info + j - 1;  // 更新 info 的值

L40:
    return 0;  // 返回 0 表示正常结束

/*     End of SPOTRF */

} /* spotrf_ */

/* Subroutine */ int spotri_(char *uplo, integer *n, real *a, integer *lda,
    integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1;

    /* Local variables */
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int xerbla_(char *, integer *), slauum_(
        char *, integer *, real *, integer *, integer *), strtri_(
        char *, char *, integer *, real *, integer *, integer *);

/*
    -- LAPACK routine (version 3.2) --
*/
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    # LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，发布于2006年11月。
    # 这段注释说明了 LAPACK 软件包的提供者和发布日期。



    Purpose
    =======


    # 本函数的目的说明部分开始



    SPOTRI computes the inverse of a real symmetric positive definite
    matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    computed by SPOTRF.


    # SPOTRI 函数计算实对称正定矩阵 A 的逆，使用由 SPOTRF 计算得到的 Cholesky 分解 A = U**T*U 或 A = L*L**T。
    # 这段说明了函数的计算目标和依赖的数学原理。



    Arguments
    =========


    # 以下是函数的参数说明部分



    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.


    # UPLO（输入参数） CHARACTER*1
    #       = 'U':  存储 A 的上三角部分;
    #       = 'L':  存储 A 的下三角部分。
    # 这段注释解释了参数 UPLO 的作用和可能的取值。



    N       (input) INTEGER
            The order of the matrix A.  N >= 0.


    # N（输入参数） INTEGER
    #       矩阵 A 的阶数。N >= 0。
    # 这段说明了参数 N 的作用和输入限制。



    A       (input/output) REAL array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T, as computed by
            SPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.


    # A（输入/输出参数） REAL array, dimension (LDA,N)
    #       在输入时，是 Cholesky 分解 A = U**T*U 或 A = L*L**T 的三角因子 U 或 L。
    #       在输出时，是 A 的逆矩阵的上三角部分或下三角部分，覆盖了输入的 U 或 L。
    # 这段详细说明了参数 A 的作用和在函数调用前后的状态变化。



    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).


    # LDA（输入参数） INTEGER
    #       数组 A 的主维度。LDA >= max(1,N)。
    # 这段说明了参数 LDA 的作用和输入限制。



    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.


    # INFO（输出参数） INTEGER
    #       = 0:  成功退出
    #       < 0:  如果 INFO = -i，第 i 个参数具有非法值
    #       > 0:  如果 INFO = i，因子 U 或 L 的 (i,i) 元素为零，无法计算逆矩阵。
    # 这段说明了参数 INFO 的输出值代表的不同情况及其含义。



    =====================================================================


    # 分隔线，标志着参数说明部分的结束和函数实现部分的开始。



       Test the input parameters.


    # 测试输入参数的有效性。
    # 这段注释说明了函数实现中对输入参数进行验证的步骤。
    /* Parameter adjustments */
    // 对参数进行调整

    a_dim1 = *lda;
    // 将 a_dim1 设置为 lda 的值

    a_offset = 1 + a_dim1;
    // 计算 a_offset，偏移量为 1 + a_dim1

    a -= a_offset;
    // 对数组 a 进行偏移，使得数组从偏移后的位置开始

    /* Function Body */
    // 函数体开始

    *info = 0;
    // 将 info 设置为 0

    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
    // 如果 uplo 不是 'U' 且不是 'L'
    *info = -1;
    // 将 info 设置为 -1
    } else if (*n < 0) {
    // 否则如果 n 小于 0
    *info = -2;
    // 将 info 设置为 -2
    } else if (*lda < max(1,*n)) {
    // 否则如果 lda 小于 max(1, n)
    *info = -4;
    // 将 info 设置为 -4
    }
    if (*info != 0) {
    // 如果 info 不等于 0
    i__1 = -(*info);
    // 将 i__1 设置为 -info
    xerbla_("SPOTRI", &i__1);
    // 调用错误处理程序 xerbla_
    return 0;
    // 返回 0
    }

/*     Quick return if possible */
// 可能的话，快速返回

    if (*n == 0) {
    // 如果 n 等于 0
    return 0;
    // 返回 0
    }

/*     Invert the triangular Cholesky factor U or L. */
// 反转三角形 Cholesky 因子 U 或 L

    strtri_(uplo, "Non-unit", n, &a[a_offset], lda, info);
    // 调用 strtri_ 函数，计算逆矩阵

    if (*info > 0) {
    // 如果 info 大于 0
    return 0;
    // 返回 0
    }

/*     Form inv(U)*inv(U)' or inv(L)'*inv(L). */
// 形成 inv(U)*inv(U)' 或者 inv(L)'*inv(L)

    slauum_(uplo, n, &a[a_offset], lda, info);
    // 调用 slauum_ 函数，计算逆矩阵的上三角部分

    return 0;

/*     End of SPOTRI */
// SPOTRI 的结束

} /* spotri_ */

/* Subroutine */ int spotrs_(char *uplo, integer *n, integer *nrhs, real *a,
    integer *lda, real *b, integer *ldb, integer *info)
{
    /* System generated locals */
    // 系统生成的局部变量

    integer a_dim1, a_offset, b_dim1, b_offset, i__1;
    // 定义整型局部变量

    /* Local variables */
    // 局部变量

    extern logical lsame_(char *, char *);
    // 外部 lsame_ 函数声明

    static logical upper;
    // 静态逻辑变量 upper

    extern /* Subroutine */ int strsm_(char *, char *, char *, char *,
        integer *, integer *, real *, real *, integer *, real *, integer *
        );
    // 外部 strsm_ 函数声明

    extern /* Subroutine */ int xerbla_(char *, integer *);
    // 外部 xerbla_ 函数声明

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    // 目的

    SPOTRS solves a system of linear equations A*X = B with a symmetric
    positive definite matrix A using the Cholesky factorization
    A = U**T*U or A = L*L**T computed by SPOTRF.
    // SPOTRS 解一个线性方程组 A*X = B，其中 A 是对称正定矩阵，使用由 SPOTRF 计算的 Cholesky 分解 A = U**T*U 或 A = L*L**T。

    Arguments
    =========
    // 参数

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
    // A 的存储格式：'U' 表示存储 A 的上三角部分；'L' 表示存储 A 的下三角部分。

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    // 矩阵 A 的阶数，必须大于等于 0。

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
    // 右侧矩阵 B 的列数，即右手边的个数，必须大于等于 0。

    A       (input) REAL array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T, as computed by SPOTRF.
    // 经由 SPOTRF 计算得到的 Cholesky 分解的三角形因子 U 或 L。

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    // 数组 A 的主维度，必须大于等于 max(1, N)。

    B       (input/output) REAL array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
    // 输入时为右侧矩阵 B，输出时为解矩阵 X。

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
    // 数组 B 的主维度，必须大于等于 max(1, N)。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    // 返回值：0 表示成功退出，小于 0 表示第 i 个参数的值非法。

    =====================================================================


       Test the input parameters.
*/
    # 获取指针 ldb 指向的值，即 b_dim1
    b_dim1 = *ldb;
    # 计算 b 数组的偏移量，1 + b_dim1
    b_offset = 1 + b_dim1;
    # 调整 b 指针，使其指向正确的数组起始位置
    b -= b_offset;

    /* Function Body */
    # 设置 info 初始值为 0，表示没有错误
    *info = 0;
    # 检查 uplo 是否为 "U"，若是则 upper 为真
    upper = lsame_(uplo, "U");
    # 如果 uplo 不是 "U" 且不是 "L"，则设置 info 为 -1
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {  # 如果 n 小于 0，则设置 info 为 -2
        *info = -2;
    } else if (*nrhs < 0) {  # 如果 nrhs 小于 0，则设置 info 为 -3
        *info = -3;
    } else if (*lda < max(1,*n)) {  # 如果 lda 小于 1 和 n 的最大值，则设置 info 为 -5
        *info = -5;
    } else if (*ldb < max(1,*n)) {  # 如果 ldb 小于 1 和 n 的最大值，则设置 info 为 -7
        *info = -7;
    }
    # 如果 info 不为 0，表示有错误发生
    if (*info != 0) {
        # 调用错误处理函数 xerbla_，并传递负值的 info
        i__1 = -(*info);
        xerbla_("SPOTRS", &i__1);
        # 函数返回，结束当前函数调用
        return 0;
    }
/*     Quick return if possible */
/* 如果 n 或 nrhs 为 0，则快速返回 */
if (*n == 0 || *nrhs == 0) {
    return 0;
}

if (upper) {

/*
      Solve A*X = B where A = U'*U.

      Solve U'*X = B, overwriting B with X.
*/
/* 解方程 A*X = B，其中 A = U'*U */
/* 解 U'*X = B，将结果直接覆盖到 B 中 */

strsm_("Left", "Upper", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);

/*        Solve U*X = B, overwriting B with X. */
/* 解 U*X = B，将结果直接覆盖到 B 中 */

strsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b15, &
    a[a_offset], lda, &b[b_offset], ldb);
} else {

/*
      Solve A*X = B where A = L*L'.

      Solve L*X = B, overwriting B with X.
*/
/* 解方程 A*X = B，其中 A = L*L' */
/* 解 L*X = B，将结果直接覆盖到 B 中 */

strsm_("Left", "Lower", "No transpose", "Non-unit", n, nrhs, &c_b15, &
    a[a_offset], lda, &b[b_offset], ldb);

/*        Solve L'*X = B, overwriting B with X. */
/* 解 L'*X = B，将结果直接覆盖到 B 中 */

strsm_("Left", "Lower", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);
}

return 0;

/*     End of SPOTRS */
/* SPOTRS 结束 */

} /* spotrs_ */

/* Subroutine */ int sstedc_(char *compz, integer *n, real *d__, real *e,
    real *z__, integer *ldz, real *work, integer *lwork, integer *iwork,
    integer *liwork, integer *info)
{
/* LAPACK 的主要驱动程序（版本 3.2） */
/* System generated locals */
integer z_dim1, z_offset, i__1, i__2;
real r__1, r__2;

/* Local variables */
static integer i__, j, k, m;
static real p;
static integer ii, lgn;
static real eps, tiny;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
    integer *, real *, real *, integer *, real *, integer *, real *,
    real *, integer *);
static integer lwmin, start;
extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *,
    integer *), slaed0_(integer *, integer *, integer *, real *, real
    *, real *, integer *, real *, integer *, real *, integer *,
    integer *);
extern doublereal slamch_(char *);
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static integer finish;
extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
    real *, integer *, integer *, real *, integer *, integer *);
extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, integer *,
    real *, integer *), slaset_(char *, integer *, integer *,
    real *, real *, real *, integer *);
static integer liwmin, icompz;
static real orgnrm;
extern doublereal slanst_(char *, integer *, real *, real *);
extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *),
     slasrt_(char *, integer *, real *, integer *);
static logical lquery;
static integer smlsiz;
extern /* Subroutine */ int ssteqr_(char *, integer *, real *, real *,
    real *, integer *, real *, integer *);
static integer storez, strtrw;
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    
    SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.
    The eigenvectors of a full or band real symmetric matrix can also be
    found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
    matrix to tridiagonal form.


    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See SLAED3 for details.


    Arguments
    =========
    
    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original dense symmetric
                    matrix also.  On entry, Z contains the orthogonal
                    matrix used to reduce the original matrix to
                    tridiagonal form.


    N       (input) INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.


    D       (input/output) REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.


    E       (input/output) REAL array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.


    Z       (input/output) REAL array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.


    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).


    WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or N <= 1 then LWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LWORK must be at least
                           ( 1 + 3*N + 2*N*lg N + 3*N**2 ),
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1 then LWORK must be at least
                           ( 1 + 4*N + N**2 ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be max(1,2*(N-1)).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.

    LIWORK  (input) INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N <= 1 then LIWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LIWORK must be at least
                           ( 6 + 6*N + 5*N*lg N ).
            If COMPZ = 'I' and N > 1 then LIWORK must be at least
                           ( 3 + 5*N ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.

            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal size of the IWORK array,
            returns this value as the first entry of the IWORK array, and
            no error message related to LIWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).

    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA
    Modified by Francoise Tisseur, University of Tennessee.

    =====================================================================

    Test the input parameters.
/* Parameter adjustments */
    --d__;                      ! 指向数组 d__ 的指针
    --e;                        ! 指向数组 e 的指针
    z_dim1 = *ldz;              ! z_dim1 表示二维数组 z 的第一维长度
    z_offset = 1 + z_dim1;      ! z_offset 为 z 数组的偏移量
    z__ -= z_offset;            ! 将 z__ 指针调整为正确的起始位置
    --work;                     ! 指向工作数组 work 的指针
    --iwork;                    ! 指向整型工作数组 iwork 的指针

    /* Function Body */
    *info = 0;                  ! 初始化 info 参数为 0
    lquery = *lwork == -1 || *liwork == -1;   ! 检查是否需要查询工作空间大小

    if (lsame_(compz, "N")) {       ! 检查 COMPZ 参数是否为 'N'
    icompz = 0;                     ! 设置 icompz 为 0
    } else if (lsame_(compz, "V")) {    ! 检查 COMPZ 参数是否为 'V'
    icompz = 1;                     ! 设置 icompz 为 1
    } else if (lsame_(compz, "I")) {    ! 检查 COMPZ 参数是否为 'I'
    icompz = 2;                     ! 设置 icompz 为 2
    } else {
    icompz = -1;                    ! 否则设置 icompz 为 -1
    }
    if (icompz < 0) {               ! 如果 icompz 小于 0
    *info = -1;                     ! 设置 info 为 -1，表示参数错误
    } else if (*n < 0) {            ! 如果 n 小于 0
    *info = -2;                     ! 设置 info 为 -2，表示参数错误
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {   ! 检查 ldz 参数是否有效
    *info = -6;                     ! 设置 info 为 -6，表示参数错误
    }

    if (*info == 0) {

/*        Compute the workspace requirements */

    smlsiz = ilaenv_(&c__9, "SSTEDC", " ", &c__0, &c__0, &c__0, &c__0, (ftnlen)6, (ftnlen)1);   ! 计算工作空间的最小大小
    if (*n <= 1 || icompz == 0) {       ! 如果 n 小于等于 1 或者 icompz 为 0
        liwmin = 1;                     ! 设置整型工作数组的最小大小为 1
        lwmin = 1;                      ! 设置工作数组的最小大小为 1
    } else if (*n <= smlsiz) {          ! 如果 n 小于等于 smlsiz
        liwmin = 1;                     ! 设置整型工作数组的最小大小为 1
        lwmin = *n - 1 << 1;            ! 设置工作数组的最小大小为 (n - 1) * 2
    } else {                            ! 否则
        lgn = (integer) (log((real) (*n)) / log(2.f));     ! 计算 log2(n)
        if (pow_ii(&c__2, &lgn) < *n) {                     ! 计算 2 的 lgn 次方小于 n
        ++lgn;                          ! lgn 加一
        }
        if (pow_ii(&c__2, &lgn) < *n) {                     ! 再次检查
        ++lgn;                          ! 如果条件成立，lgn 再加一
        }
        if (icompz == 1) {              ! 如果 icompz 为 1
/* Computing 2nd power */
        i__1 = *n;                      ! 计算 n 的平方
        lwmin = *n * 3 + 1 + (*n << 1) * lgn + i__1 * i__1 * 3;    ! 计算工作数组的大小需求
        liwmin = *n * 6 + 6 + *n * 5 * lgn;                       ! 计算整型工作数组的大小需求
        } else if (icompz == 2) {       ! 如果 icompz 为 2
/* Computing 2nd power */
        i__1 = *n;                      ! 计算 n 的平方
        lwmin = (*n << 2) + 1 + i__1 * i__1;                      ! 计算工作数组的大小需求
        liwmin = *n * 5 + 3;            ! 计算整型工作数组的大小需求
        }
    }
    work[1] = (real) lwmin;             ! 设置工作数组的实际大小
    iwork[1] = liwmin;                  ! 设置整型工作数组的实际大小

    if (*lwork < lwmin && ! lquery) {   ! 如果输入的工作数组大小小于所需大小且非查询模式
        *info = -8;                     ! 设置 info 为 -8，表示工作数组大小不足
    } else if (*liwork < liwmin && ! lquery) {    ! 如果输入的整型工作数组大小小于所需大小且非查询模式
        *info = -10;                    ! 设置 info 为 -10，表示整型工作数组大小不足
    }
    }

    if (*info != 0) {                   ! 如果 info 不为 0
    i__1 = -(*info);                    ! 计算负数的 info 值
    xerbla_("SSTEDC", &i__1);            ! 调用错误处理程序 xerbla_
    return 0;                           ! 返回
    } else if (lquery) {                ! 如果是查询模式
    return 0;                           ! 直接返回
    }

/*     Quick return if possible */

    if (*n == 0) {                      ! 如果 n 为 0
    return 0;                           ! 直接返回
    }
    if (*n == 1) {                      ! 如果 n 为 1
    if (icompz != 0) {                  ! 如果 icompz 不为 0
        z__[z_dim1 + 1] = 1.f;          ! 设置 z 矩阵的第一个元素为 1
    }
    return 0;                           ! 返回
    }

/*
       If the following conditional clause is removed, then the routine
       will use the Divide and Conquer routine to compute only the
       eigenvalues, which requires (3N + 3N**2) real workspace and
       (2 + 5N + 2N lg(N)) integer workspace.
       Since on many architectures SSTERF is much faster than any other
       algorithm for finding eigenvalues only, it is used here
       as the default. If the conditional clause is removed, then
       information on the size of workspace needs to be changed.

       If COMPZ = 'N', use SSTERF to compute the eigenvalues.
*/

    if (icompz == 0) {                  ! 如果 icompz 为 0
    ssterf_(n, &d__[1], &e[1], info);   ! 调用 SSTERF 计算特征值
    goto L50;                           ! 跳转到 L50 标签
    }

/*
       If N is smaller than the minimum divide size (SMLSIZ+1), then
       solve the problem with another solver.
*/

    if (*n <= smlsiz) {                 ! 如果 n 小于等于最小的分割大小
    ssteqr_(compz, n, &d__[1], &e[1], &z__[z_offset], ldz, &work[1], info);    ! 调用 SSTEQR 解特征值问题
    } else {                            ! 否则
/*
          If COMPZ = 'V', the Z matrix must be stored elsewhere for later
          use.
*/
    # 如果 icompz 等于 1，计算存储位置的起始索引
    if (icompz == 1) {
        storez = *n * *n + 1;
    # 如果 icompz 不等于 1，计算存储位置的起始索引
    } else {
        storez = 1;
    }

    # 如果 icompz 等于 2，初始化矩阵 z__ 为特定值
    if (icompz == 2) {
        slaset_("Full", n, n, &c_b29, &c_b15, &z__[z_offset], ldz);
    }
/*        Scale. */

orgnrm = slanst_("M", n, &d__[1], &e[1]);
/* 计算矩阵的无穷范数，用于后续的矩阵操作 */
if (orgnrm == 0.f) {
    goto L50;
}

eps = slamch_("Epsilon");
/* 获取机器精度 */

start = 1;

/*        while ( START <= N ) */

L10:
if (start <= *n) {

/*
         Let FINISH be the position of the next subdiagonal entry
         such that E( FINISH ) <= TINY or FINISH = N if no such
         subdiagonal exists.  The matrix identified by the elements
         between START and FINISH constitutes an independent
         sub-problem.
*/
finish = start;
L20:
if (finish < *n) {
tiny = eps * sqrt((r__1 = d__[finish], dabs(r__1))) * sqrt((
    r__2 = d__[finish + 1], dabs(r__2)));
/* 计算 TINY，用于确定矩阵的独立子问题 */
if ((r__1 = e[finish], dabs(r__1)) > tiny) {
    ++finish;
    goto L20;
}
}

/*           (Sub) Problem determined.  Compute its size and solve it. */

m = finish - start + 1;
/* 计算子问题的大小 */
if (m == 1) {
start = finish + 1;
goto L10;
}
if (m > smlsiz) {

/*              Scale. */

orgnrm = slanst_("M", &m, &d__[start], &e[start]);
/* 计算子问题矩阵的无穷范数 */
slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &m, &c__1, &d__[
    start], &m, info);
/* 缩放子问题矩阵的对角线元素 */
i__1 = m - 1;
i__2 = m - 1;
slascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &i__1, &c__1, &e[
    start], &i__2, info);
/* 缩放子问题矩阵的次对角线元素 */

if (icompz == 1) {
    strtrw = 1;
} else {
    strtrw = start;
}
/* 确定对 Z 矩阵的起始行 */

slaed0_(&icompz, n, &m, &d__[start], &e[start], &z__[strtrw +
    start * z_dim1], ldz, &work[1], n, &work[storez], &
    iwork[1], info);
/* 解子问题并更新特征向量矩阵 Z */
if (*info != 0) {
    *info = (*info / (m + 1) + start - 1) * (*n + 1) + *info %
         (m + 1) + start - 1;
    goto L50;
}

/*              Scale back. */

slascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &m, &c__1, &d__[
    start], &m, info);
/* 对解出的特征值进行逆缩放 */

} else {
if (icompz == 1) {

/*
           Since QR won't update a Z matrix which is larger than
           the length of D, we must solve the sub-problem in a
           workspace and then multiply back into Z.
*/
ssteqr_("I", &m, &d__[start], &e[start], &work[1], &m, &
    work[m * m + 1], info);
/* 解子问题的特征值问题 */
slacpy_("A", n, &m, &z__[start * z_dim1 + 1], ldz, &work[
    storez], n);
/* 复制 Z 矩阵的一部分到工作空间 */
sgemm_("N", "N", n, &m, &m, &c_b15, &work[storez], n, &
    work[1], &m, &c_b29, &z__[start * z_dim1 + 1],
    ldz);
/* 将解出的特征向量乘回 Z 矩阵 */
} else if (icompz == 2) {
ssteqr_("I", &m, &d__[start], &e[start], &z__[start +
    start * z_dim1], ldz, &work[1], info);
/* 解子问题的特征值问题并更新 Z 矩阵 */
} else {
ssterf_(&m, &d__[start], &e[start], info);
/* 计算子问题的特征值 */
}
if (*info != 0) {
*info = start * (*n + 1) + finish;
goto L50;
}
}

start = finish + 1;
goto L10;
}
    /*
          endwhile

          If the problem split any number of times, then the eigenvalues
          will not be properly ordered.  Here we permute the eigenvalues
          (and the associated eigenvectors) into ascending order.
    */

    if (m != *n) {  // 检查分裂次数是否与矩阵维度相等
        if (icompz == 0) {  // 如果不需要计算特征向量

/*              Use Quick Sort */
            使用快速排序算法对特征值进行排序

        slasrt_("I", n, &d__[1], info);  // 调用 LAPACK 的 slasrt 函数进行整数排序

        } else {

/*              Use Selection Sort to minimize swaps of eigenvectors */
            使用选择排序算法来最小化特征向量的交换次数

        i__1 = *n;  // 循环遍历所有特征值
        for (ii = 2; ii <= i__1; ++ii) {
            i__ = ii - 1;
            k = i__;
            p = d__[i__];  // 保存当前位置的特征值
            i__2 = *n;
            for (j = ii; j <= i__2; ++j) {
            if (d__[j] < p) {  // 如果找到更小的特征值
                k = j;
                p = d__[j];
            }
/* L30: */
            }
            if (k != i__) {  // 如果需要交换特征值及其对应的特征向量
            d__[k] = d__[i__];
            d__[i__] = p;
            sswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k *
                z_dim1 + 1], &c__1);  // 交换特征向量
            }
/* L40: */
        }
        }
    }
    }

L50:
    work[1] = (real) lwmin;  // 将工作数组中的第一个元素设置为 lwmin 的实数形式
    iwork[1] = liwmin;  // 将整型工作数组中的第一个元素设置为 liwmin

    return 0;

/*     End of SSTEDC */

} /* sstedc_ */

/* Subroutine */ int ssteqr_(char *compz, integer *n, real *d__, real *e,
    real *z__, integer *ldz, real *work, integer *info)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2;
    real r__1, r__2;

    /* Local variables */
    static real b, c__, f, g;
    static integer i__, j, k, l, m;
    static real p, r__, s;
    static integer l1, ii, mm, lm1, mm1, nm1;
    static real rt1, rt2, eps;
    static integer lsv;
    static real tst, eps2;
    static integer lend, jtot;
    extern /* Subroutine */ int slae2_(real *, real *, real *, real *, real *)
        ;
    extern logical lsame_(char *, char *);
    static real anorm;
    extern /* Subroutine */ int slasr_(char *, char *, char *, integer *,
        integer *, real *, real *, real *, integer *), sswap_(integer *, real *, integer *, real *, integer *);
    static integer lendm1, lendp1;
    extern /* Subroutine */ int slaev2_(real *, real *, real *, real *, real *
        , real *, real *);
    extern doublereal slapy2_(real *, real *);
    static integer iscale;
    extern doublereal slamch_(char *);
    static real safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static real safmax;
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);
    static integer lendsv;
    extern /* Subroutine */ int slartg_(real *, real *, real *, real *, real *
        ), slaset_(char *, integer *, integer *, real *, real *, real *,
        integer *);
    static real ssfmin;
    static integer nmaxit, icompz;
    static real ssfmax;
    extern doublereal slanst_(char *, integer *, real *, real *);
    extern /* Subroutine */ int slasrt_(char *, integer *, real *, integer *);

/*
    -- LAPACK routine (version 3.2) --
*/
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006



-- LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包。--
-- 2006年11月



    Purpose
    =======

    SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the implicit QL or QR method.
    The eigenvectors of a full or band symmetric matrix can also be found
    if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
    tridiagonal form.



-- SSTEQR计算对称三对角矩阵的所有特征值及其可选的特征向量，使用隐式QL或QR方法。--
-- 如果使用SSYTRD、SSPTRD或SSBTRD将该矩阵转化为三对角形式，则还可以找到完整或带状对称矩阵的特征向量。--



    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    Z       (input/output) REAL array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).

    WORK    (workspace) REAL array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.



-- 参数说明

COMPZ   (输入) CHARACTER*1
        = 'N': 仅计算特征值。
        = 'V': 计算原始对称矩阵的特征值和特征向量。输入时，Z必须包含用于将原始矩阵转化为三对角形式的正交矩阵。
        = 'I': 计算三对角矩阵的特征值和特征向量。Z被初始化为单位矩阵。

N       (输入) INTEGER
        矩阵的阶数。N >= 0。

D       (输入/输出) REAL 数组，维度为 (N)
        输入时，三对角矩阵的对角线元素。
        输出时，如果 INFO = 0，则为升序排列的特征值。

E       (输入/输出) REAL 数组，维度为 (N-1)
        输入时，三对角矩阵的次对角线元素。
        输出时，E已被破坏。

Z       (输入/输出) REAL 数组，维度为 (LDZ, N)
        输入时，如果 COMPZ = 'V'，则Z包含用于将矩阵转化为三对角形式的正交矩阵。
        输出时，如果 INFO = 0，并且 COMPZ = 'V'，则Z包含原始对称矩阵的正交归一化特征向量；
        如果 COMPZ = 'I'，则Z包含对称三对角矩阵的正交归一化特征向量。
        如果 COMPZ = 'N'，则Z不被引用。

LDZ     (输入) INTEGER
        数组Z的第一维度。LDZ >= 1，并且如果需要特征向量，则 LDZ >= max(1,N)。

WORK    (工作空间) REAL 数组，维度为 (max(1,2*N-2))
        如果 COMPZ = 'N'，则不引用 WORK。

INFO    (输出) INTEGER
        = 0: 成功退出
        < 0: 如果 INFO = -i，则第i个参数具有非法值
        > 0: 算法在总共30*N次迭代中未能找到所有特征值；
             如果 INFO = i，则E的i个元素未收敛到零；
             在退出时，D和E包含与原矩阵正交相似的对称三对角矩阵的元素。



    =====================================================================


       Test the input parameters.



=====================================================================

测试输入参数。
    /* Parameter adjustments */
    --d__;
    --e;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;

    if (lsame_(compz, "N")) {
        icompz = 0;
    } else if (lsame_(compz, "V")) {
        icompz = 1;
    } else if (lsame_(compz, "I")) {
        icompz = 2;
    } else {
        icompz = -1;
    }

    if (icompz < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {
        *info = -6;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SSTEQR", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    if (*n == 1) {
        if (icompz == 2) {
            z__[z_dim1 + 1] = 1.f;
        }
        return 0;
    }

    /* Determine the unit roundoff and over/underflow thresholds. */
    eps = slamch_("E");
    /* Computing 2nd power */
    r__1 = eps;
    eps2 = r__1 * r__1;
    safmin = slamch_("S");
    safmax = 1.f / safmin;
    ssfmax = sqrt(safmax) / 3.f;
    ssfmin = sqrt(safmin) / eps2;

    /*
       Compute the eigenvalues and eigenvectors of the tridiagonal
       matrix.
    */
    if (icompz == 2) {
        slaset_("Full", n, n, &c_b29, &c_b15, &z__[z_offset], ldz);
    }

    nmaxit = *n * 30;
    jtot = 0;

    /*
       Determine where the matrix splits and choose QL or QR iteration
       for each block, according to whether top or bottom diagonal
       element is smaller.
    */
    l1 = 1;
    nm1 = *n - 1;

L10:
    if (l1 > *n) {
        goto L160;
    }
    if (l1 > 1) {
        e[l1 - 1] = 0.f;
    }
    if (l1 <= nm1) {
        i__1 = nm1;
        for (m = l1; m <= i__1; ++m) {
            tst = (r__1 = e[m], dabs(r__1));
            if (tst == 0.f) {
                goto L30;
            }
            if (tst <= sqrt((r__1 = d__[m], dabs(r__1))) * sqrt((r__2 = d__[m
                + 1], dabs(r__2))) * eps) {
                e[m] = 0.f;
                goto L30;
            }
            /* L20: */
        }
    }
    m = *n;

L30:
    l = l1;
    lsv = l;
    lend = m;
    lendsv = lend;
    l1 = m + 1;
    if (lend == l) {
        goto L10;
    }

    /* Scale submatrix in rows and columns L to LEND */
    i__1 = lend - l + 1;
    anorm = slanst_("I", &i__1, &d__[l], &e[l]);
    iscale = 0;
    if (anorm == 0.f) {
        goto L10;
    }
    if (anorm > ssfmax) {
        iscale = 1;
        i__1 = lend - l + 1;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n,
            info);
        i__1 = lend - l;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n,
            info);
    } else if (anorm < ssfmin) {
        iscale = 2;
        i__1 = lend - l + 1;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n,
            info);
        i__1 = lend - l;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n,
            info);
    }

    /* Choose between QL and QR iteration */
    if ((r__1 = d__[lend], dabs(r__1)) < (r__2 = d__[l], dabs(r__2))) {
        lend = lsv;
        l = lendsv;
    }

    if (lend > l) {
/*
          QL Iteration

          Look for small subdiagonal element.
*/
L40:
    // 如果 l 不等于 lend，则进行以下循环
    if (l != lend) {
        lendm1 = lend - 1;
        // 对于 m 从 l 到 lend-1 进行循环
        i__1 = lendm1;
        for (m = l; m <= i__1; ++m) {
            // 计算 e[m] 的绝对值的平方
            /* Computing 2nd power */
            r__2 = (r__1 = e[m], dabs(r__1));
            tst = r__2 * r__2;
            // 如果满足此条件，则跳转到 L60
            if (tst <= eps2 * (r__1 = d__[m], dabs(r__1)) * (r__2 = d__[m
                + 1], dabs(r__2)) + safmin) {
                goto L60;
            }
            // L50: 标号
        }
    }

    // 设置 m 为 lend
    m = lend;

L60:
    // 如果 m 小于 lend，则将 e[m] 设为 0
    if (m < lend) {
        e[m] = 0.f;
    }
    // 将 p 设为 d__[l]
    p = d__[l];
    // 如果 m 等于 l，则跳转到 L80
    if (m == l) {
        goto L80;
    }

/*
          If remaining matrix is 2-by-2, use SLAE2 or SLAEV2
          to compute its eigensystem.
*/

    // 如果剩余的矩阵是 2x2 的，则使用 SLAE2 或 SLAEV2 计算其特征系统
    if (m == l + 1) {
        // 如果 icompz 大于 0，则使用 slaev2_ 计算特征值
        if (icompz > 0) {
            slaev2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2, &c__, &s);
            work[l] = c__;
            work[*n - 1 + l] = s;
            // 对右边特征向量进行应用
            slasr_("R", "V", "B", n, &c__2, &work[l], &work[*n - 1 + l], &
                z__[l * z_dim1 + 1], ldz);
        } else {
            // 否则使用 slae2_ 计算特征值
            slae2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2);
        }
        // 更新特征值和对应的超对角元素
        d__[l] = rt1;
        d__[l + 1] = rt2;
        e[l] = 0.f;
        // l 增加 2
        l += 2;
        // 如果 l 小于等于 lend，则跳转到 L40
        if (l <= lend) {
            goto L40;
        }
        // 否则跳转到 L140
        goto L140;
    }

    // 如果 jtot 等于 nmaxit，则跳转到 L140
    if (jtot == nmaxit) {
        goto L140;
    }
    // jtot 加 1
    ++jtot;

/*        Form shift. */

    // 计算 g
    g = (d__[l + 1] - p) / (e[l] * 2.f);
    r__ = slapy2_(&g, &c_b15);
    // 计算 g
    g = d__[m] - p + e[l] / (g + r_sign(&r__, &g));

    // 初始化 s, c, p
    s = 1.f;
    c__ = 1.f;
    p = 0.f;

/*        Inner loop */

    // 对于 i 从 m-1 到 l 进行循环
    mm1 = m - 1;
    i__1 = l;
    for (i__ = mm1; i__ >= i__1; --i__) {
        // 计算 f 和 b
        f = s * e[i__];
        b = c__ * e[i__];
        // 计算旋转参数
        slartg_(&g, &f, &c__, &s, &r__);
        // 如果 i 不等于 m-1，则更新 e[i+1]
        if (i__ != m - 1) {
            e[i__ + 1] = r__;
        }
        // 计算 g 和 r__
        g = d__[i__ + 1] - p;
        r__ = (d__[i__] - g) * s + c__ * 2.f * b;
        p = s * r__;
        d__[i__ + 1] = g + p;
        g = c__ * r__ - b;

/*           If eigenvectors are desired, then save rotations. */

        // 如果需要特征向量，则保存旋转参数
        if (icompz > 0) {
            work[i__] = c__;
            work[*n - 1 + i__] = -s;
        }

        // L70: 标号
    }

/*        If eigenvectors are desired, then apply saved rotations. */

    // 如果需要特征向量，则对保存的旋转参数进行应用
    if (icompz > 0) {
        // 计算 mm
        mm = m - l + 1;
        slasr_("R", "V", "B", n, &mm, &work[l], &work[*n - 1 + l], &z__[l
            * z_dim1 + 1], ldz);
    }

    // 更新 d[l] 和 e[l]
    d__[l] -= p;
    e[l] = g;
    // 跳转到 L40
    goto L40;

/*        Eigenvalue found. */

L80:
    // 将 d[l] 设为 p
    d__[l] = p;

    // l 加 1
    ++l;
    // 如果 l 小于等于 lend，则跳转到 L40
    if (l <= lend) {
        goto L40;
    }
    // 否则跳转到 L140
    goto L140;

    } else {

/*
          QR Iteration

          Look for small superdiagonal element.
*/

L90:
    // 如果 l 不等于 lend，则进行以下循环
    if (l != lend) {
        lendp1 = lend + 1;
        // 对于 m 从 l 到 lend+1 进行循环
        i__1 = lendp1;
        for (m = l; m >= i__1; --m) {
            // 计算 e[m-1] 的绝对值的平方
            /* Computing 2nd power */
            r__2 = (r__1 = e[m - 1], dabs(r__1));
            tst = r__2 * r__2;
            // 如果满足此条件，则跳转到 L110
            if (tst <= eps2 * (r__1 = d__[m], dabs(r__1)) * (r__2 = d__[m
                - 1], dabs(r__2)) + safmin) {
                goto L110;
            }
            // L100: 标号
        }
    }

    // 设置 m 为 lend
    m = lend;

L110:
    # 如果 m 大于 lend，则将 e 数组中索引为 m-1 的元素设为 0.0
    if (m > lend) {
        e[m - 1] = 0.f;
    }
    # 将数组 d__ 中索引为 l 的元素赋给变量 p
    p = d__[l];
    # 如果 m 等于 l，则跳转到标签 L130 处执行相应操作
    if (m == l) {
        goto L130;
    }
/*
     如果剩余的矩阵是2x2的，则使用SLAE2或SLAEV2计算其特征系统。
*/
if (m == l - 1) {
    if (icompz > 0) {
        // 使用SLAEV2计算2x2矩阵的特征值和特征向量
        slaev2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2, &c__, &s);
        // 将计算得到的旋转角度存储到工作数组中
        work[m] = c__;
        work[*n - 1 + m] = s;
        // 应用旋转到矩阵Z的特定列
        slasr_("R", "V", "F", n, &c__2, &work[m], &work[*n - 1 + m], &
            z__[(l - 1) * z_dim1 + 1], ldz);
    } else {
        // 使用SLAE2计算2x2矩阵的特征值
        slae2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2);
    }
    // 更新特征值数组和对角元素
    d__[l - 1] = rt1;
    d__[l] = rt2;
    e[l - 1] = 0.f;
    l += -2;
    if (l >= lend) {
        goto L90;
    }
    goto L140;
}

if (jtot == nmaxit) {
    goto L140;
}
++jtot;

/*        计算位移量 */

g = (d__[l - 1] - p) / (e[l - 1] * 2.f);
r__ = slapy2_(&g, &c_b15);
g = d__[m] - p + e[l - 1] / (g + r_sign(&r__, &g));

s = 1.f;
c__ = 1.f;
p = 0.f;

/*        内部循环 */

lm1 = l - 1;
i__1 = lm1;
for (i__ = m; i__ <= i__1; ++i__) {
    f = s * e[i__];
    b = c__ * e[i__];
    // 计算Givens旋转，更新对角元素和下对角元素
    slartg_(&g, &f, &c__, &s, &r__);
    if (i__ != m) {
        e[i__ - 1] = r__;
    }
    g = d__[i__] - p;
    r__ = (d__[i__ + 1] - g) * s + c__ * 2.f * b;
    p = s * r__;
    d__[i__] = g + p;
    g = c__ * r__ - b;

    /* 如果需要特征向量，则保存旋转角度 */
    if (icompz > 0) {
        work[i__] = c__;
        work[*n - 1 + i__] = s;
    }
}

/*        如果需要特征向量，则应用保存的旋转角度 */

if (icompz > 0) {
    mm = l - m + 1;
    slasr_("R", "V", "F", n, &mm, &work[m], &work[*n - 1 + m], &z__[m
        * z_dim1 + 1], ldz);
}

d__[l] -= p;
e[lm1] = g;
goto L90;

/*        找到特征值 */

L130:
d__[l] = p;

--l;
if (l >= lend) {
    goto L90;
}
goto L140;

}

/*     如有必要，取消缩放 */

L140:
if (iscale == 1) {
i__1 = lendsv - lsv + 1;
// 恢复缩放前的特征值和下对角元素
slascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv],
    n, info);
i__1 = lendsv - lsv;
slascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &e[lsv], n,
    info);
} else if (iscale == 2) {
i__1 = lendsv - lsv + 1;
// 恢复缩放前的特征值和下对角元素
slascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv],
    n, info);
i__1 = lendsv - lsv;
slascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &e[lsv], n,
    info);
}

/*
   如果经过N*MAXIT次迭代仍未收敛到一个特征值，则认为没有收敛。
*/

if (jtot < nmaxit) {
goto L10;
}
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
if (e[i__] != 0.f) {
    ++(*info);
}
}

L190:
goto L190;
/*        Use Selection Sort to minimize swaps of eigenvectors */

/* 使用选择排序来最小化特征向量的交换次数 */

    i__1 = *n;
    for (ii = 2; ii <= i__1; ++ii) {
        i__ = ii - 1;
        k = i__;
        p = d__[i__];
        i__2 = *n;
        for (j = ii; j <= i__2; ++j) {
        if (d__[j] < p) {
            k = j;
            p = d__[j];
        }
/* L170: */
        }
        if (k != i__) {
        d__[k] = d__[i__];
        d__[i__] = p;
        sswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1 + 1],
             &c__1);
        }
/* L180: */
    }
    }

/*     End of SSTEQR */

/* SSTEQR 的结束 */

L190:
    return 0;

/* 返回值为 0 */

/*     End of SSTEQR */

/* SSTEQR 的结束 */

} /* ssteqr_ */

/* Subroutine */ int ssterf_(integer *n, real *d__, real *e, integer *info)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2, r__3;

    /* Local variables */
    static real c__;
    static integer i__, l, m;
    static real p, r__, s;
    static integer l1;
    static real bb, rt1, rt2, eps, rte;
    static integer lsv;
    static real eps2, oldc;
    static integer lend, jtot;
    extern /* Subroutine */ int slae2_(real *, real *, real *, real *, real *)
        ;
    static real gamma, alpha, sigma, anorm;
    extern doublereal slapy2_(real *, real *);
    static integer iscale;
    static real oldgam;
    extern doublereal slamch_(char *);
    static real safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static real safmax;
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);
    static integer lendsv;
    static real ssfmin;
    static integer nmaxit;
    static real ssfmax;
    extern doublereal slanst_(char *, integer *, real *, real *);
    extern /* Subroutine */ int slasrt_(char *, integer *, real *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

/* LAPACK 程序包（版本 3.2） */
/* LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包。 */
/* 2006年11月 */

    Purpose
    =======
/* 目的 */

    SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
    using the Pal-Walker-Kahan variant of the QL or QR algorithm.
/* SSTERF 计算对称三对角矩阵的所有特征值，使用Pal-Walker-Kahan变体的QL或QR算法。 */

    Arguments
    =========
/* 参数 */

    N       (input) INTEGER
            The order of the matrix.  N >= 0.
/* 矩阵的阶数。N >= 0。 */

    D       (input/output) REAL array, dimension (N)
            On entry, the n diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
/* 输入时，三对角矩阵的n个对角元素。
   输出时，如果INFO = 0，则为升序排列的特征值。 */

    E       (input/output) REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
/* 输入时，三对角矩阵的(n-1)个次对角元素。
   输出时，E已被破坏。 */

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm failed to find all of the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero.
/* 返回值：
   = 0：成功完成
   < 0：如果INFO = -i，则第i个参数具有非法值
   > 0：算法在30*N次迭代中未能找到所有特征值；
        如果INFO = i，则有i个E元素未收敛到零。 */
    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --e;
    --d__;

    /* Function Body */
    *info = 0;

    /* Quick return if possible */
    if (*n < 0) {
        *info = -1;
        i__1 = -(*info);
        xerbla_("SSTERF", &i__1);
        return 0;
    }
    if (*n <= 1) {
        return 0;
    }

    /* Determine the unit roundoff for this environment. */
    eps = slamch_("E");
    /* Computing 2nd power */
    r__1 = eps;
    eps2 = r__1 * r__1;
    safmin = slamch_("S");
    safmax = 1.f / safmin;
    ssfmax = sqrt(safmax) / 3.f;
    ssfmin = sqrt(safmin) / eps2;

    /* Compute the eigenvalues of the tridiagonal matrix. */
    nmaxit = *n * 30;
    sigma = 0.f;
    jtot = 0;

    /*
       Determine where the matrix splits and choose QL or QR iteration
       for each block, according to whether top or bottom diagonal
       element is smaller.
    */
    l1 = 1;

L10:
    if (l1 > *n) {
        goto L170;
    }
    if (l1 > 1) {
        e[l1 - 1] = 0.f;
    }
    i__1 = *n - 1;
    for (m = l1; m <= i__1; ++m) {
        if ((r__3 = e[m], dabs(r__3)) <= sqrt((r__1 = d__[m], dabs(r__1))) *
            sqrt((r__2 = d__[m + 1], dabs(r__2))) * eps) {
            e[m] = 0.f;
            goto L30;
        }
        /* L20: */
    }
    m = *n;

L30:
    l = l1;
    lsv = l;
    lend = m;
    lendsv = lend;
    l1 = m + 1;
    if (lend == l) {
        goto L10;
    }

    /* Scale submatrix in rows and columns L to LEND */
    i__1 = lend - l + 1;
    anorm = slanst_("I", &i__1, &d__[l], &e[l]);
    iscale = 0;
    if (anorm > ssfmax) {
        iscale = 1;
        i__1 = lend - l + 1;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n,
            info);
        i__1 = lend - l;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n,
            info);
    } else if (anorm < ssfmin) {
        iscale = 2;
        i__1 = lend - l + 1;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n,
            info);
        i__1 = lend - l;
        slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n,
            info);
    }

    i__1 = lend - 1;
    for (i__ = l; i__ <= i__1; ++i__) {
        /* Computing 2nd power */
        r__1 = e[i__];
        e[i__] = r__1 * r__1;
        /* L40: */
    }

    /* Choose between QL and QR iteration */
    if ((r__1 = d__[lend], dabs(r__1)) < (r__2 = d__[l], dabs(r__2))) {
        lend = lsv;
        l = lendsv;
    }

    if (lend >= l) {

        /*
          QL Iteration

          Look for small subdiagonal element.
        */

L50:
        if (l != lend) {
            i__1 = lend - 1;
            for (m = l; m <= i__1; ++m) {
                if ((r__2 = e[m], dabs(r__2)) <= eps2 * (r__1 = d__[m] * d__[
                    m + 1], dabs(r__1))) {
                    goto L70;
                }
                /* L60: */
            }
        }
        m = lend;

L70:
        if (m < lend) {
            e[m] = 0.f;
        }
        p = d__[l];
        if (m == l) {
            goto L90;
        }

        /*
          If remaining matrix is 2 by 2, use SLAE2 to compute its
          eigenvalues.
        */
    # 如果 m 等于 l + 1，则执行以下操作
    if (m == l + 1) {
        # 计算 e[l] 的平方根并赋值给 rte
        rte = sqrt(e[l]);
        # 调用 slae2_ 函数，处理 d[l], rte, d[l+1], 返回结果给 rt1 和 rt2
        slae2_(&d__[l], &rte, &d__[l + 1], &rt1, &rt2);
        # 更新 d[l] 和 d[l+1] 的值为 slae2_ 函数返回的结果
        d__[l] = rt1;
        d__[l + 1] = rt2;
        # 将 e[l] 设为 0
        e[l] = 0.f;
        # l 增加 2
        l += 2;
        # 如果 l 仍小于等于 lend，则跳转到标号 L50 处继续执行
        if (l <= lend) {
            goto L50;
        }
        # 否则跳转到标号 L150 处
        goto L150;
    }

    # 如果 jtot 等于 nmaxit，则跳转到标号 L150 处
    if (jtot == nmaxit) {
        goto L150;
    }
    # jtot 增加 1
    ++jtot;
/*        Form shift. */
/* 形成位移 */

    rte = sqrt(e[l]);
    /* 计算平方根并赋值给 rte */

    sigma = (d__[l + 1] - p) / (rte * 2.f);
    /* 计算 sigma */

    r__ = slapy2_(&sigma, &c_b15);
    /* 调用 slapy2 函数计算并赋值给 r__ */

    sigma = p - rte / (sigma + r_sign(&r__, &sigma));
    /* 更新 sigma */

    c__ = 1.f;
    /* 初始化 c__ */

    s = 0.f;
    /* 初始化 s */

    gamma = d__[m] - sigma;
    /* 计算 gamma */

    p = gamma * gamma;
    /* 计算 p */

/*        Inner loop */
/* 内循环 */

    i__1 = l;
    /* 设置循环上限 */

    for (i__ = m - 1; i__ >= i__1; --i__) {
        /* 循环迭代从 m-1 到 l */

        bb = e[i__];
        /* 获取 e[i__] 的值赋给 bb */

        r__ = p + bb;
        /* 计算 r__ */

        if (i__ != m - 1) {
        e[i__ + 1] = s * r__;
        /* 更新 e[i__+1] */
        }

        oldc = c__;
        /* 记录旧值给 oldc */

        c__ = p / r__;
        /* 计算并更新 c__ */

        s = bb / r__;
        /* 计算并更新 s */

        oldgam = gamma;
        /* 记录旧值给 oldgam */

        alpha = d__[i__];
        /* 获取 d__[i__] 的值赋给 alpha */

        gamma = c__ * (alpha - sigma) - s * oldgam;
        /* 计算并更新 gamma */

        d__[i__ + 1] = oldgam + (alpha - gamma);
        /* 更新 d__[i__+1] */

        if (c__ != 0.f) {
        p = gamma * gamma / c__;
        /* 计算 p */
        } else {
        p = oldc * bb;
        /* 更新 p */
        }

/* L80: */
/* L80 标签 */
    }

    e[l] = s * p;
    /* 更新 e[l] */

    d__[l] = sigma + gamma;
    /* 更新 d__[l] */

    goto L50;

/*        Eigenvalue found. */
/* 找到特征值 */

L90:
/* L90 标签 */

    d__[l] = p;
    /* 更新 d__[l] */

    ++l;
    /* l 自增 */

    if (l <= lend) {
    goto L50;
    /* 转到 L50 标签 */
    }

    goto L150;

    } else {

/*
          QR Iteration

          Look for small superdiagonal element.
*/

L100:
/* L100 标签 */

    i__1 = lend + 1;
    /* 设置循环上限 */

    for (m = l; m >= i__1; --m) {
        /* 循环迭代从 l 到 lend+1 */

        if ((r__2 = e[m - 1], dabs(r__2)) <= eps2 * (r__1 = d__[m] * d__[
            m - 1], dabs(r__1))) {
        goto L120;
        /* 如果条件成立，转到 L120 标签 */
        }

/* L110: */
/* L110 标签 */
    }

    m = lend;
    /* 更新 m */

L120:
/* L120 标签 */

    if (m > lend) {
    e[m - 1] = 0.f;
    /* 更新 e[m-1] */
    }

    p = d__[l];
    /* 获取 d__[l] 的值赋给 p */

    if (m == l) {
    goto L140;
    /* 如果条件成立，转到 L140 标签 */
    }

/*
          If remaining matrix is 2 by 2, use SLAE2 to compute its
          eigenvalues.
*/

    if (m == l - 1) {
    /* 如果条件成立，执行以下操作 */

        rte = sqrt(e[l - 1]);
        /* 计算平方根并赋值给 rte */

        slae2_(&d__[l], &rte, &d__[l - 1], &rt1, &rt2);
        /* 调用 slae2 函数 */

        d__[l] = rt1;
        /* 更新 d__[l] */

        d__[l - 1] = rt2;
        /* 更新 d__[l-1] */

        e[l - 1] = 0.f;
        /* 更新 e[l-1] */

        l += -2;
        /* l 减去 2 */

        if (l >= lend) {
        goto L100;
        /* 如果条件成立，转到 L100 标签 */
        }

        goto L150;
        /* 转到 L150 标签 */
    }

    if (jtot == nmaxit) {
    goto L150;
    /* 如果条件成立，转到 L150 标签 */
    }

    ++jtot;
    /* jtot 自增 */

/*        Form shift. */
/* 形成位移 */

    rte = sqrt(e[l - 1]);
    /* 计算平方根并赋值给 rte */

    sigma = (d__[l - 1] - p) / (rte * 2.f);
    /* 计算 sigma */

    r__ = slapy2_(&sigma, &c_b15);
    /* 调用 slapy2 函数计算并赋值给 r__ */

    sigma = p - rte / (sigma + r_sign(&r__, &sigma));
    /* 更新 sigma */

    c__ = 1.f;
    /* 初始化 c__ */

    s = 0.f;
    /* 初始化 s */

    gamma = d__[m] - sigma;
    /* 计算 gamma */

    p = gamma * gamma;
    /* 计算 p */

/*        Inner loop */
/* 内循环 */

    i__1 = l - 1;
    /* 设置循环上限 */

    for (i__ = m; i__ <= i__1; ++i__) {
        /* 循环迭代从 m 到 l-1 */

        bb = e[i__];
        /* 获取 e[i__] 的值赋给 bb */

        r__ = p + bb;
        /* 计算 r__ */

        if (i__ != m) {
        e[i__ - 1] = s * r__;
        /* 更新 e[i__-1] */
        }

        oldc = c__;
        /* 记录旧值给 oldc */

        c__ = p / r__;
        /* 计算并更新 c__ */

        s = bb / r__;
        /* 计算并更新 s */

        oldgam = gamma;
        /* 记录旧值给 oldgam */

        alpha = d__[i__ + 1];
        /* 获取 d__[i__+1] 的值赋给 alpha */

        gamma = c__ * (alpha - sigma) - s * oldgam;
        /* 计算并更新 gamma */

        d__[i__] = oldgam + (alpha - gamma);
        /* 更新 d__[i__] */

        if (c__ != 0.f) {
        p = gamma * gamma / c__;
        /* 计算 p */
        } else {
        p = oldc * bb;
        /* 更新 p */
        }

/* L130: */
/* L130 标签 */
    }

    e[l - 1] = s * p;
    /* 更新 e[l-1] */

    d__[l] = sigma + gamma;
    /* 更新 d__[l] */

    goto L100;
    /* 转到 L100 标签 */

/*        Eigenvalue found. */
/* 找到特征值 */

L140:
/* L140 标签 */

    d__[l] = p;
    /* 更新 d__[l] */

    --l;
    /* l 自减 */

    if (l >= lend) {
    goto L100;
    /* 如果条件成立，转到 L100 标签 */
    }

    goto L150;
    /* 转到 L150 标签 */

    }

/*     Undo scaling if necessary */
/* 如有必要，取消缩放 */

L150:
/* L150 标签 */

    if (iscale == 1) {
    /* 如果条件成立，执行以下操作 */

    i__1 = lendsv - lsv + 1;
    /* 计算 i__1 */
    # 调用 LAPACK 中的 slascl 函数，对数组 d__ 中的一部分元素进行缩放
    slascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv],
            n, info);
    }
    # 如果 iscale 等于 2，执行以下语句块
    if (iscale == 2) {
        # 计算需要缩放的元素数量
        i__1 = lendsv - lsv + 1;
        # 调用 LAPACK 中的 slascl 函数，对数组 d__ 中的一部分元素进行缩放
        slascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv],
                n, info);
    }
/*
       如果在总共进行了 N*MAXIT 次迭代后仍未收敛到一个特征值。
*/

    if (jtot < nmaxit) {
    goto L10;
    }
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    if (e[i__] != 0.f) {
        ++(*info);
    }
/* L160: */
    }
    goto L180;

/*     将特征值按升序排序。 */

L170:
    slasrt_("I", n, &d__[1], info);

L180:
    return 0;

/*     SSTERF 的结束 */

} /* ssterf_ */

/* 子程序 */ int ssyevd_(char *jobz, char *uplo, integer *n, real *a,
    integer *lda, real *w, real *work, integer *lwork, integer *iwork,
    integer *liwork, integer *info)
{
    /* 系统生成的本地变量 */
    integer a_dim1, a_offset, i__1, i__2;
    real r__1;

    /* 本地变量 */
    static real eps;
    static integer inde;
    static real anrm, rmin, rmax;
    static integer lopt;
    static real sigma;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* 子程序 */ int sscal_(integer *, real *, real *, integer *);
    static integer lwmin, liopt;
    static logical lower, wantz;
    static integer indwk2, llwrk2, iscale;
    extern doublereal slamch_(char *);
    static real safmin;
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* 子程序 */ int xerbla_(char *, integer *);
    static real bignum;
    extern /* 子程序 */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);
    static integer indtau;
    extern /* 子程序 */ int slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *);
    static integer indwrk, liwmin;
    extern /* 子程序 */ int sstedc_(char *, integer *, real *, real *,
        real *, integer *, real *, integer *, integer *, integer *,
        integer *), slacpy_(char *, integer *, integer *, real *,
        integer *, real *, integer *);
    static integer indwrk, liwmin;
    extern /* 子程序 */ int ssterf_(integer *, real *, real *, integer *);
    extern doublereal slansy_(char *, char *, integer *, real *, integer *,
        real *);
    static integer llwork;
    static real smlnum;
    static logical lquery;
    extern /* 子程序 */ int sormtr_(char *, char *, char *, integer *,
        integer *, real *, integer *, real *, real *, integer *, real *,
        integer *, integer *), ssytrd_(char *,
        integer *, real *, integer *, real *, real *, real *, real *,
        integer *, integer *);


/*
    -- LAPACK 驱动程序例程 (版本 3.2) --
    -- LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。--
       2006 年 11 月


    目的
    =======

    SSYEVD 计算实对称矩阵 A 的所有特征值，并可选地计算特征向量。
    如果需要特征向量，它使用分治算法。

    分治算法对浮点运算做了非常温和的假设。它适用于带有保护位的机器。
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Because of large use of BLAS of level 3, SSYEVD needs N**2 more
    workspace than SSYEVX.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) REAL array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) REAL array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.

    WORK    (workspace/output) REAL array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If N <= 1,               LWORK must be at least 1.
            If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
            If JOBZ = 'V' and N > 1, LWORK must be at least
                                                  1 + 6*N + 2*N**2.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK and IWORK
            arrays, returns these values as the first entries of the WORK
            and IWORK arrays, and no error message related to LWORK or
            LIWORK is issued by XERBLA.

    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
    # LIWORK（输入）整数
    #     数组IWORK的维度。
    #     如果N <= 1，则LIWORK至少为1。
    #     如果JOBZ = 'N'且N > 1，则LIWORK必须至少为1。
    #     如果JOBZ = 'V'且N > 1，则LIWORK必须至少为3 + 5*N。
    #     
    #     如果LIWORK = -1，则假定进行工作空间查询；例程仅计算WORK和IWORK数组的最佳大小，
    #     并将这些值作为WORK和IWORK数组的第一个条目返回，XERBLA不会输出与LWORK或LIWORK相关的错误消息。

    INFO（输出）整数
        = 0：成功退出
        < 0：如果INFO = -i，则第i个参数具有非法值
        > 0：如果INFO = i且JOBZ = 'N'，则算法未能收敛；
             中间三对角形式的i个非对角元素未收敛为零；
             如果INFO = i且JOBZ = 'V'，则算法未能在处理子矩阵时计算特征值，
             该子矩阵位于INFO/(N+1)至mod(INFO,N+1)的行和列中。
    
    # 更多细节
    # ===============
    # 基于以下贡献：
    #    Jeff Rutter，加州大学伯克利分校，计算机科学系，美国
    #    Francoise Tisseur修改，田纳西大学。
    # 
    # INFO描述修改。Sven，05年2月16日。
    # =====================================================================

    # 测试输入参数。
    /* Parameter adjustments */
    a_dim1 = *lda;  // a_dim1指向矩阵A的第一维的维数（通常是行数）
    a_offset = 1 + a_dim1;  // a_offset用于计算A的偏移量
    a -= a_offset;  // 将A的指针偏移到正确的位置
    --w;  // 将数组w的指针向前移动一个位置
    --work;  // 将数组work的指针向前移动一个位置
    --iwork;  // 将数组iwork的指针向前移动一个位置

    /* Function Body */
    wantz = lsame_(jobz, "V");  // 判断是否需要计算特征向量
    lower = lsame_(uplo, "L");  // 判断矩阵是否为下三角形式
    lquery = *lwork == -1 || *liwork == -1;  // 判断是否是查询工作空间大小

    *info = 0;  // 初始化info为0
    if (! (wantz || lsame_(jobz, "N"))) {
        *info = -1;  // 如果jobz不是"V"或"N"，则设置info为-1
    } else if (! (lower || lsame_(uplo, "U"))) {
        *info = -2;  // 如果uplo不是"L"或"U"，则设置info为-2
    } else if (*n < 0) {
        *info = -3;  // 如果n小于0，则设置info为-3
    } else if (*lda < max(1,*n)) {
        *info = -5;  // 如果lda小于1或者n，则设置info为-5
    }

    if (*info == 0) {
        if (*n <= 1) {
            liwmin = 1;
            lwmin = 1;
            lopt = lwmin;
            liopt = liwmin;
        } else {
            if (wantz) {
                liwmin = *n * 5 + 3;  // 计算最小的iwork数组大小
                /* Computing 2nd power */
                i__1 = *n;
                lwmin = *n * 6 + 1 + (i__1 * i__1 << 1);  // 计算最小的work数组大小
            } else {
                liwmin = 1;  // 不需要计算特征向量时，最小iwork数组大小为1
                lwmin = (*n << 1) + 1;  // 不需要计算特征向量时，最小work数组大小
            }
            /* Computing MAX */
            i__1 = lwmin, i__2 = (*n << 1) + ilaenv_(&c__1, "SSYTRD", uplo, n,
                 &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
            lopt = max(i__1,i__2);  // 计算最优的work数组大小
            liopt = liwmin;  // 最优的iwork数组大小等于最小的iwork数组大小
        }
        work[1] = (real) lopt;  // 将计算得到的最优工作空间大小存入work数组的第一个元素
        iwork[1] = liopt;  // 将计算得到的最优iwork空间大小存入iwork数组的第一个元素

        if (*lwork < lwmin && ! lquery) {
            *info = -8;  // 如果提供的工作空间小于最小需要空间且不是查询状态，则设置info为-8
        } else if (*liwork < liwmin && ! lquery) {
            *info = -10;  // 如果提供的iwork空间小于最小需要空间且不是查询状态，则设置info为-10
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SSYEVD", &i__1);  // 如果info不为0，则调用错误处理函数xerbla_
        return 0;  // 返回0
    } else if (lquery) {
        return 0;  // 如果是查询状态，则直接返回0
    }

/*     Quick return if possible */

    if (*n == 0) {
        return 0;  // 如果n为0，则直接返回0
    }

    if (*n == 1) {
        w[1] = a[a_dim1 + 1];  // 将特征值存入w数组的第一个元素
        if (wantz) {
            a[a_dim1 + 1] = 1.f;  // 如果需要计算特征向量，则将单位矩阵存入a数组的第一个元素
        }
        return 0;  // 返回0
    }

/*     Get machine constants. */

    safmin = slamch_("Safe minimum");  // 获取机器的安全最小值
    eps = slamch_("Precision");  // 获取机器的精度
    smlnum = safmin / eps;  // 计算小数值范围
    bignum = 1.f / smlnum;  // 计算大数值范围
    rmin = sqrt(smlnum);  // 计算小数值的平方根
    rmax = sqrt(bignum);  // 计算大数值的平方根

/*     Scale matrix to allowable range, if necessary. */

    anrm = slansy_("M", uplo, n, &a[a_offset], lda, &work[1]);  // 计算矩阵A的范数
    iscale = 0;  // 初始化缩放指示符为0
    if (anrm > 0.f && anrm < rmin) {
        iscale = 1;  // 如果范数在小数值范围内，则设置缩放指示符为1
        sigma = rmin / anrm;  // 计算缩放因子
    } else if (anrm > rmax) {
        iscale = 1;  // 如果范数超过大数值范围，则设置缩放指示符为1
        sigma = rmax / anrm;  // 计算缩放因子
    }
    if (iscale == 1) {
        slascl_(uplo, &c__0, &c__0, &c_b15, &sigma, n, n, &a[a_offset], lda,
            info);  // 根据计算得到的缩放因子对矩阵A进行缩放
    }

/*     Call SSYTRD to reduce symmetric matrix to tridiagonal form. */

    inde = 1;  // inde用于存储工作数组的起始位置
    indtau = inde + *n;  // indtau用于存储存储元素的位置
    indwrk = indtau + *n;  // indwrk用于存储工作数组的位置
    llwork = *lwork - indwrk + 1;  // llwork计算工作数组的长度
    indwk2 = indwrk + *n * *n;  // indwk2用于存储工作数组的另一位置
    llwrk2 = *lwork - indwk2 + 1;  // llwrk2计算工作数组的另一长度

    ssytrd_(uplo, n, &a[a_offset], lda, &w[1], &work[inde], &work[indtau], &
        work[indwrk], &llwork, &iinfo);  // 调用SSYTRD将对称矩阵转化为三对角矩阵

/*
       For eigenvalues only, call SSTERF.  For eigenvectors, first call
       SSTEDC to generate the eigenvector matrix, WORK(INDWRK), of the
       tridiagonal matrix, then call SORMTR to multiply it by the
       Householder transformations stored in A.
*/

    if (! wantz) {
        ssterf_(n, &w[1], &work[inde], info);  // 如果不需要计算特征向量，则调用SSTERF计算特征值
    } else {
        // 如果需要计算特征向量，则进行以下步骤
        /* (略) */
    }
    sstedc_("I", n, &w[1], &work[inde], &work[indwrk], n, &work[indwk2], &
        llwrk2, &iwork[1], liwork, info);
    # 调用 LAPACK 函数 sstedc 执行特征值计算和特征向量重构
    # 参数说明：
    #   "I" 表示计算所有特征值和对应的特征向量
    #   n 表示矩阵的阶数
    #   &w[1] 是输出参数，返回计算得到的特征值数组
    #   &work[inde] 是输入/输出参数，用于存储 LAPACK 计算中间结果
    #   &work[indwrk] 是工作数组，存储 LAPACK 执行过程中的工作空间
    #   n 是传递矩阵维度的参数
    #   &work[indwk2] 是额外的工作空间
    #   &llwrk2 是工作空间大小的输出参数
    #   &iwork[1] 是整型工作数组，用于 LAPACK 内部计算
    #   liwork 是整型工作数组的大小
    #   info 是输出参数，返回 LAPACK 函数的执行信息

    sormtr_("L", uplo, "N", n, n, &a[a_offset], lda, &work[indtau], &work[
        indwrk], n, &work[indwk2], &llwrk2, &iinfo);
    # 调用 LAPACK 函数 sormtr 执行矩阵乘法
    # 参数说明：
    #   "L" 表示左侧乘以单位正交（Householder）或反正交矩阵
    #   uplo 表示矩阵 a 的存储方式（上三角或下三角）
    #   "N" 表示不传输转置的矩阵
    #   n 表示矩阵的阶数
    #   &a[a_offset] 是输入矩阵 a 的存储位置
    #   lda 是矩阵 a 的第一个维度
    #   &work[indtau] 是输入的元素数组，包含存储上述 LAPACK 函数所需的数据
    #   &work[indwrk] 是工作数组，用于存储 LAPACK 执行过程中的工作空间
    #   n 是传递矩阵维度的参数
    #   &work[indwk2] 是额外的工作空间
    #   &llwrk2 是工作空间大小的输出参数
    #   &iinfo 是输出参数，返回 LAPACK 函数的执行信息

    slacpy_("A", n, n, &work[indwrk], n, &a[a_offset], lda);
    # 调用 LAPACK 函数 slacpy 复制矩阵
    # 参数说明：
    #   "A" 表示复制整个矩阵
    #   n 表示矩阵的阶数
    #   &work[indwrk] 是输入矩阵的存储位置
    #   n 是传递矩阵维度的参数
    #   &a[a_offset] 是目标矩阵的存储位置
    #   lda 是目标矩阵的第一个维度
/*     If matrix was scaled, then rescale eigenvalues appropriately. */
/*     如果矩阵已经被缩放过，则相应地重新缩放特征值。 */

if (iscale == 1) {
/*  如果 iscale 等于 1，则进行以下操作 */
r__1 = 1.f / sigma;
/* 计算缩放比例 */
sscal_(n, &r__1, &w[1], &c__1);
/* 对 w 数组中的元素进行缩放操作 */
}

work[1] = (real) lopt;
/* 将 lopt 赋值给 work 数组的第一个元素 */
iwork[1] = liopt;
/* 将 liopt 赋值给 iwork 数组的第一个元素 */

return 0;
/* 返回值为 0，函数结束 */

/*     End of SSYEVD */
/*     SSYEVD 函数结束 */

} /* ssyevd_ */
/* ssyevd_ 子程序结束 */

/* Subroutine */ int ssytd2_(char *uplo, integer *n, real *a, integer *lda,
    real *d__, real *e, real *tau, integer *info)
{
/* 子程序 ssytd2_ 的声明 */

/* System generated locals */
/* 系统自动生成的本地变量声明 */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
/* 本地变量声明 */
static integer i__;
static real taui;
extern doublereal sdot_(integer *, real *, integer *, real *, integer *);
extern /* Subroutine */ int ssyr2_(char *, integer *, real *, real *,
    integer *, real *, integer *, real *, integer *);
static real alpha;
extern logical lsame_(char *, char *);
static logical upper;
extern /* Subroutine */ int saxpy_(integer *, real *, real *, integer *,
    real *, integer *), ssymv_(char *, integer *, real *, real *,
    integer *, real *, integer *, real *, real *, integer *),
    xerbla_(char *, integer *), slarfg_(integer *, real *,
    real *, integer *, real *);

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

Purpose
=======
目的
SSYTD2 将一个实对称矩阵 A 通过正交相似变换约化为对称三对角形式 T：Q' * A * Q = T。

Arguments
=========
参数
UPLO    (input) CHARACTER*1
        Specifies whether the upper or lower triangular part of the
        symmetric matrix A is stored:
        = 'U':  Upper triangular
        = 'L':  Lower triangular
指定存储的实对称矩阵 A 的上三角部分还是下三角部分。

N       (input) INTEGER
        The order of the matrix A.  N >= 0.
        矩阵 A 的阶数。N >= 0。

...
    A       (input/output) REAL array, dimension (LDA,N)
            # 输入/输出参数，存储对称矩阵 A
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            # 如果 UPLO = 'U'，A 的上三角部分为输入矩阵的上三角部分
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            # 如果 UPLO = 'L'，A的下三角部分为输入矩阵的下三角部分
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            # 如果 UPLO = 'U'，结果存储在 A 的对角线和第一超对角线
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the orthogonal
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            # 如果 UPLO = 'L'，结果存储在 A 的对角线和第一次亚对角线
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the orthogonal matrix Q as a product
            of elementary reflectors. See Further Details.

    LDA     (input) INTEGER
            # 输入参数，数组 A 的维度
            The leading dimension of the array A.  LDA >= max(1,N).

    D       (output) REAL array, dimension (N)
            # 输出参数，存储三对角矩阵 T 的对角线元素
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).

    E       (output) REAL array, dimension (N-1)
            # 输出参数，存储三对角矩阵 T 的非对角线元素
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

    TAU     (output) REAL array, dimension (N-1)
            # 输出参数，存储元素反射的标量因子
            The scalar factors of the elementary reflectors (see Further
            Details).

    INFO    (output) INTEGER
            # 输出参数，返回状态信息
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    # 如果 UPLO = 'U'，矩阵 Q 被表示为一系列基本反射变换的乘积
    reflectors
       Q = H(n-1) . . . H(2) H(1).

    Each H(i) has the form
       # 每个 H(i) 的形式
       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    # 这里 tau 是实数标量，v 是实数向量
    v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    A(1:i-1,i+1), and tau in TAU(i).

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    # 如果 UPLO = 'L'，矩阵 Q 被表示为一系列基本反射变换的乘积
    reflectors
       Q = H(1) H(2) . . . H(n-1).

    Each H(i) has the form
       # 每个 H(i) 的形式
       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    # 这里 tau 是实数标量，v 是实数向量
    v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    and tau in TAU(i).

    The contents of A on exit are illustrated by the following examples
    with n = 5:
    # 如果 UPLO 被赋值为 'U'：
    if UPLO = 'U':

      # 返回矩阵 T 的对角线元素和第二到最后一行对角线下的元素
      (  d   e   v2  v3  v4 )

      # 返回矩阵 T 的第二到最后一列，第三到最后一行的对角线元素和第三到最后一行对角线下的元素
      (      d   e   v3  v4 )

      # 返回矩阵 T 的第三到最后一列，第四到最后一行的对角线元素和第四到最后一行对角线下的元素
      (          d   e   v4 )

      # 返回矩阵 T 的第四到最后一列，最后一行的对角线元素和最后一行对角线下的元素
      (              d   e  )

      # 返回矩阵 T 的最后一列，最后一行的对角线元素
      (                  d  )

    where d and e denote diagonal and off-diagonal elements of T, and vi
    denotes an element of the vector defining H(i).

    =====================================================================


       Test the input parameters
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SSYTD2", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n <= 0) {
        return 0;
    }

    if (upper) {

        /* Reduce the upper triangle of A */
        for (i__ = *n - 1; i__ >= 1; --i__) {

            /* Generate elementary reflector H(i) = I - tau * v * v'
               to annihilate A(1:i-1,i+1) */
            slarfg_(&i__, &a[i__ + (i__ + 1) * a_dim1], &a[(i__ + 1) * a_dim1 + 1], &c__1, &taui);
            e[i__] = a[i__ + (i__ + 1) * a_dim1];

            if (taui != 0.f) {

                /* Apply H(i) from both sides to A(1:i,1:i) */
                a[i__ + (i__ + 1) * a_dim1] = 1.f;

                /* Compute  x := tau * A * v  storing x in TAU(1:i) */
                ssymv_(uplo, &i__, &taui, &a[a_offset], lda, &a[(i__ + 1) * a_dim1 + 1], &c__1, &c_b29, &tau[1], &c__1);

                /* Compute  w := x - 1/2 * tau * (x'*v) * v */
                alpha = taui * -.5f * sdot_(&i__, &tau[1], &c__1, &a[(i__ + 1) * a_dim1 + 1], &c__1);
                saxpy_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &tau[1], &c__1);

                /* Apply the transformation as a rank-2 update:
                   A := A - v * w' - w * v' */
                ssyr2_(uplo, &i__, &c_b151, &a[(i__ + 1) * a_dim1 + 1], &c__1, &tau[1], &c__1, &a[a_offset], lda);

                a[i__ + (i__ + 1) * a_dim1] = e[i__];
            }
            d__[i__ + 1] = a[i__ + 1 + (i__ + 1) * a_dim1];
            tau[i__] = taui;
            /* L10: */
        }
        d__[1] = a[a_dim1 + 1];
    } else {

        /* Reduce the lower triangle of A */
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {

            /* Generate elementary reflector H(i) = I - tau * v * v'
               to annihilate A(i+2:n,i) */
            i__2 = *n - i__;
            /* Computing MIN */
            i__3 = i__ + 2;
            slarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*n) + i__ * a_dim1], &c__1, &taui);
            e[i__] = a[i__ + 1 + i__ * a_dim1];

            if (taui != 0.f) {

                /* Apply H(i) from both sides to A(i+1:n,i+1:n) */
                a[i__ + 1 + i__ * a_dim1] = 1.f;

                /* Compute  x := tau * A * v  storing y in TAU(i:n-1) */
                i__2 = *n - i__;
                ssymv_(uplo, &i__2, &taui, &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &tau[i__], &c__1);
/*              Compute  w := x - 1/2 * tau * (x'*v) * v */

        i__2 = *n - i__;
        alpha = taui * -.5f * sdot_(&i__2, &tau[i__], &c__1, &a[i__ +
            1 + i__ * a_dim1], &c__1);
        i__2 = *n - i__;
        saxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &c__1);

/*
                Apply the transformation as a rank-2 update:
                   A := A - v * w' - w * v'
*/

        i__2 = *n - i__;
        ssyr2_(uplo, &i__2, &c_b151, &a[i__ + 1 + i__ * a_dim1], &
            c__1, &tau[i__], &c__1, &a[i__ + 1 + (i__ + 1) *
            a_dim1], lda);

        a[i__ + 1 + i__ * a_dim1] = e[i__];
        }
        d__[i__] = a[i__ + i__ * a_dim1];
        tau[i__] = taui;
/* L20: */
    }
    d__[*n] = a[*n + *n * a_dim1];
    }

    return 0;

/*     End of SSYTD2 */

} /* ssytd2_ */

/* Subroutine */ int ssytrd_(char *uplo, integer *n, real *a, integer *lda,
    real *d__, real *e, real *tau, real *work, integer *lwork, integer *
    info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, nb, kk, nx, iws;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    static logical upper;
    extern /* Subroutine */ int ssytd2_(char *, integer *, real *, integer *,
        real *, real *, real *, integer *), ssyr2k_(char *, char *
        , integer *, integer *, real *, real *, integer *, real *,
        integer *, real *, real *, integer *), xerbla_(
        char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int slatrd_(char *, integer *, integer *, real *,
        integer *, real *, real *, real *, integer *);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    SSYTRD reduces a real symmetric matrix A to real symmetric
    tridiagonal form T by an orthogonal similarity transformation:
    Q**T * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    ! A       (input/output) REAL array, dimension (LDA,N)
    !         On entry, the symmetric matrix A.  If UPLO = 'U', the leading
    !         N-by-N upper triangular part of A contains the upper
    !         triangular part of the matrix A, and the strictly lower
    !         triangular part of A is not referenced.  If UPLO = 'L', the
    !         leading N-by-N lower triangular part of A contains the lower
    !         triangular part of the matrix A, and the strictly upper
    !         triangular part of A is not referenced.
    !         On exit, if UPLO = 'U', the diagonal and first superdiagonal
    !         of A are overwritten by the corresponding elements of the
    !         tridiagonal matrix T, and the elements above the first
    !         superdiagonal, with the array TAU, represent the orthogonal
    !         matrix Q as a product of elementary reflectors; if UPLO
    !         = 'L', the diagonal and first subdiagonal of A are over-
    !         written by the corresponding elements of the tridiagonal
    !         matrix T, and the elements below the first subdiagonal, with
    !         the array TAU, represent the orthogonal matrix Q as a product
    !         of elementary reflectors. See Further Details.

    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(1,N).

    ! D       (output) REAL array, dimension (N)
    !         The diagonal elements of the tridiagonal matrix T:
    !         D(i) = A(i,i).

    ! E       (output) REAL array, dimension (N-1)
    !         The off-diagonal elements of the tridiagonal matrix T:
    !         E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

    ! TAU     (output) REAL array, dimension (N-1)
    !         The scalar factors of the elementary reflectors (see Further
    !         Details).

    ! WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    ! LWORK   (input) INTEGER
    !         The dimension of the array WORK.  LWORK >= 1.
    !         For optimum performance LWORK >= N*NB, where NB is the
    !         optimal blocksize.
    !
    !         If LWORK = -1, then a workspace query is assumed; the routine
    !         only calculates the optimal size of the WORK array, returns
    !         this value as the first entry of the WORK array, and no error
    !         message related to LWORK is issued by XERBLA.

    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument had an illegal value

    ! Further Details
    ! ===============

    ! If UPLO = 'U', the matrix Q is represented as a product of elementary
    ! reflectors

    !    Q = H(n-1) . . . H(2) H(1).

    ! Each H(i) has the form

    !    H(i) = I - tau * v * v'

    ! where tau is a real scalar, and v is a real vector with
    ! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    ! A(1:i-1,i+1), and tau in TAU(i).

    ! If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(n-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    and tau in TAU(i).

    The contents of A on exit are illustrated by the following examples
    with n = 5:

    if UPLO = 'U':                       if UPLO = 'L':

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    where d and e denote diagonal and off-diagonal elements of T, and vi
    denotes an element of the vector defining H(i).

    =====================================================================


       Test the input parameters


注释：


# reflectors
# 反射器说明，描述了Q的构成方式和每个H(i)的形式

# Q = H(1) H(2) . . . H(n-1).
# Q由H(1)到H(n-1)的乘积构成

# Each H(i) has the form
# 每个H(i)的形式为

# H(i) = I - tau * v * v'
# 其中tau是一个实数标量，v是一个实向量，满足v(1:i)=0，v(i+1)=1；退出时，v(i+2:n)存储在A(i+2:n,i)中，tau存储在TAU(i)中。

# The contents of A on exit are illustrated by the following examples with n = 5:
# 当n = 5时，A退出时的内容如下示例所示：

# if UPLO = 'U':                       if UPLO = 'L':
# 如果UPLO = 'U'：                      如果UPLO = 'L'：

#   (  d   e   v2  v3  v4 )              (  d                  )
#   (      d   e   v3  v4 )              (  e   d              )
#   (          d   e   v4 )              (  v1  e   d          )
#   (              d   e  )              (  v1  v2  e   d      )
#   (                  d  )              (  v1  v2  v3  e   d  )
# 上述是A的内容示例，其中d和e表示T的对角线和非对角线元素，vi表示定义H(i)的向量的元素。

# =====================================================================

# Test the input parameters
# 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*lwork < 1 && ! lquery) {
        *info = -9;
    }

    if (*info == 0) {

/*        Determine the block size. */

        nb = ilaenv_(&c__1, "SSYTRD", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6,
                     (ftnlen)1);
        lwkopt = *n * nb;
        work[1] = (real) lwkopt;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("SSYTRD", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        work[1] = 1.f;
        return 0;
    }

    nx = *n;
    iws = 1;
    if (nb > 1 && nb < *n) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code).

   Computing MAX
*/
        i__1 = nb, i__2 = ilaenv_(&c__3, "SSYTRD", uplo, n, &c_n1, &c_n1, &
                                  c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *n) {

/*           Determine if workspace is large enough for blocked code. */

            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code by setting NX = N.

   Computing MAX
*/
                i__1 = *lwork / ldwork;
                nb = max(i__1,1);
                nbmin = ilaenv_(&c__2, "SSYTRD", uplo, n, &c_n1, &c_n1, &c_n1,
                                 (ftnlen)6, (ftnlen)1);
                if (nb < nbmin) {
                    nx = *n;
                }
            }
        } else {
            nx = *n;
        }
    } else {
        nb = 1;
    }

    if (upper) {

/*
          Reduce the upper triangle of A.
          Columns 1:kk are handled by the unblocked method.
*/

        kk = *n - (*n - nx + nb - 1) / nb * nb;
        i__1 = kk + 1;
        i__2 = -nb;
        for (i__ = *n - nb + 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
             i__2) {

/*
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix
*/

            i__3 = i__ + nb - 1;
            slatrd_(uplo, &i__3, &nb, &a[a_offset], lda, &e[1], &tau[1], &
                    work[1], &ldwork);

/*
             Update the unreduced submatrix A(1:i-1,1:i-1), using an
             update of the form:  A := A - V*W' - W*V'
*/

            i__3 = i__ - 1;
            ssyr2k_(uplo, "No transpose", &i__3, &nb, &c_b151, &a[i__ *
                    a_dim1 + 1], lda, &work[1], &ldwork, &c_b15, &a[a_offset],
                    lda);

/*
             Copy superdiagonal elements back into A, and diagonal
             elements into D
*/
/* 

        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
        a[j - 1 + j * a_dim1] = e[j - 1];
        d__[j] = a[j + j * a_dim1];
*/

        /* 将数组 a 的对角线和数组 d__ 的元素赋值为数组 e 的部分元素 */
        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
            a[j - 1 + j * a_dim1] = e[j - 1];
            d__[j] = a[j + j * a_dim1];
/* L10: */
        }
/* L20: */
    }

/*        Use unblocked code to reduce the last or only block */

    /* 如果只剩最后一个或唯一的块，则使用非块状代码来减少它 */
    ssytd2_(uplo, &kk, &a[a_offset], lda, &d__[1], &e[1], &tau[1], &iinfo);
    } else {

/*        Reduce the lower triangle of A */

    /* 减少 A 的下三角部分 */
    i__2 = *n - nx;
    i__1 = nb;
    for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {

/*
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix
*/

        /* 将列 i 到 i+nb-1 缩减为三对角形式，并形成矩阵 W，用于更新未缩减部分的矩阵 */
        i__3 = *n - i__ + 1;
        slatrd_(uplo, &i__3, &nb, &a[i__ + i__ * a_dim1], lda, &e[i__], &
            tau[i__], &work[1], &ldwork);

/*
             Update the unreduced submatrix A(i+ib:n,i+ib:n), using
             an update of the form:  A := A - V*W' - W*V'
*/

        /* 使用更新形式 A := A - V*W' - W*V' 来更新未缩减子矩阵 A(i+ib:n,i+ib:n) */
        i__3 = *n - i__ - nb + 1;
        ssyr2k_(uplo, "No transpose", &i__3, &nb, &c_b151, &a[i__ + nb +
            i__ * a_dim1], lda, &work[nb + 1], &ldwork, &c_b15, &a[
            i__ + nb + (i__ + nb) * a_dim1], lda);

/*
             Copy subdiagonal elements back into A, and diagonal
             elements into D
*/

        /* 将副对角线元素复制回 A，将对角线元素复制到 D 中 */
        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
            a[j + 1 + j * a_dim1] = e[j];
            d__[j] = a[j + j * a_dim1];
/* L30: */
        }
/* L40: */
    }

/*        Use unblocked code to reduce the last or only block */

    /* 如果只剩最后一个或唯一的块，则使用非块状代码来减少它 */
    i__1 = *n - i__ + 1;
    ssytd2_(uplo, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__],
        &tau[i__], &iinfo);
    }

    work[1] = (real) lwkopt;
    return 0;

/*     End of SSYTRD */

} /* ssytrd_ */

/* Subroutine */ int strevc_(char *side, char *howmny, logical *select,
    integer *n, real *t, integer *ldt, real *vl, integer *ldvl, real *vr,
    integer *ldvr, integer *mm, integer *m, real *work, integer *info)
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
        i__2, i__3;
    real r__1, r__2, r__3, r__4;

    /* Local variables */
    static integer i__, j, k;
    static real x[4]    /* was [2][2] */;
    static integer j1, j2, n2, ii, ki, ip, is;
    static real wi, wr, rec, ulp, beta, emax;
    static logical pair, allv;
    static integer ierr;
    static real unfl, ovfl, smin;
    extern doublereal sdot_(integer *, real *, integer *, real *, integer *);
    static logical over;
    static real vmax;
    static integer jnxt;
    static real scale;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
    static real remax;
    static logical leftv;
    extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *,
        real *, integer *, real *, integer *, real *, real *, integer *);
    static logical bothv;
    static real vcrit;
    static logical somev;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    ! 声明外部子程序 scopy_
    static real xnorm;
    ! 静态变量 xnorm，用于存储实数类型的数值
    extern /* Subroutine */ int saxpy_(integer *, real *, real *, integer *,
        real *, integer *);
    ! 声明外部子程序 saxpy_
    extern /* Subroutine */ int slaln2_(logical *, integer *, integer *, real
        *, real *, real *, integer *, real *, real *, real *, integer *,
        real *, real *, real *, integer *, real *, real *, integer *);
    ! 声明外部子程序 slaln2_
    extern /* Subroutine */ int slabad_(real *, real *);
    ! 声明外部子程序 slabad_
    extern doublereal slamch_(char *);
    ! 声明外部函数 slamch_
    extern /* Subroutine */ int xerbla_(char *, integer *);
    ! 声明外部子程序 xerbla_
    static real bignum;
    ! 静态变量 bignum，用于存储实数类型的数值
    extern integer isamax_(integer *, real *, integer *);
    ! 声明外部函数 isamax_
    static logical rightv;
    ! 静态逻辑变量 rightv，用于存储逻辑值
    static real smlnum;
    ! 静态变量 smlnum，用于存储实数类型的数值
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

STREVC computes some or all of the right and/or left eigenvectors of
a real upper quasi-triangular matrix T.
Matrices of this type are produced by the Schur factorization of
a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.

The right eigenvector x and the left eigenvector y of T corresponding
to an eigenvalue w are defined by:

   T*x = w*x,     (y**H)*T = w*(y**H)

where y**H denotes the conjugate transpose of y.
The eigenvalues are not input to this routine, but are read directly
from the diagonal blocks of T.

This routine returns the matrices X and/or Y of right and left
eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
input matrix.  If Q is the orthogonal factor that reduces a matrix
A to Schur form T, then Q*X and Q*Y are the matrices of right and
left eigenvectors of A.

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'R':  compute right eigenvectors only;
        = 'L':  compute left eigenvectors only;
        = 'B':  compute both right and left eigenvectors.

HOWMNY  (input) CHARACTER*1
        = 'A':  compute all right and/or left eigenvectors;
        = 'B':  compute all right and/or left eigenvectors,
                backtransformed by the matrices in VR and/or VL;
        = 'S':  compute selected right and/or left eigenvectors,
                as indicated by the logical array SELECT.

SELECT  (input/output) LOGICAL array, dimension (N)
        If HOWMNY = 'S', SELECT specifies the eigenvectors to be
        computed.
        If w(j) is a real eigenvalue, the corresponding real
        eigenvector is computed if SELECT(j) is .TRUE..
        If w(j) and w(j+1) are the real and imaginary parts of a
        complex eigenvalue, the corresponding complex eigenvector is
        computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
        on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
        .FALSE..
        Not referenced if HOWMNY = 'A' or 'B'.

N       (input) INTEGER
        The order of the matrix T. N >= 0.

T       (input) REAL array, dimension (LDT,N)
        The upper quasi-triangular matrix T in Schur canonical form.

LDT     (input) INTEGER
        The leading dimension of the array T. LDT >= max(1,N).
"""
    ! VL 是一个输出参数，用于存储左特征向量矩阵
    !     如果 SIDE = 'L' 或 'B' 并且 HOWMNY = 'B'，则 VL 必须包含由 SHSEQR 返回的 N × N 矩阵 Q（通常是 Schur 向量 Q）
    !     如果 SIDE = 'L' 或 'B'，退出时：
    !         如果 HOWMNY = 'A'，VL 包含矩阵 T 的左特征向量 Y
    !         如果 HOWMNY = 'B'，VL 包含矩阵 Q*Y
    !         如果 HOWMNY = 'S'，VL 包含 T 的左特征向量（由 SELECT 指定），按其特征值的顺序依次存储在 VL 的列中
    !     对于复特征值对应的复特征向量，实部存储在第一列，虚部存储在第二列
    !     如果 SIDE = 'R'，则不使用 VL

    ! LDVL 是 VL 数组的 leading dimension，LDVL >= 1，并且如果 SIDE = 'L' 或 'B'，LDVL >= N

    ! VR 是一个输入/输出参数，用于存储右特征向量矩阵
    !     如果 SIDE = 'R' 或 'B' 并且 HOWMNY = 'B'，则 VR 必须包含由 SHSEQR 返回的 N × N 矩阵 Q（通常是 Schur 向量 Q）
    !     如果 SIDE = 'R' 或 'B'，退出时：
    !         如果 HOWMNY = 'A'，VR 包含矩阵 T 的右特征向量 X
    !         如果 HOWMNY = 'B'，VR 包含矩阵 Q*X
    !         如果 HOWMNY = 'S'，VR 包含 T 的右特征向量（由 SELECT 指定），按其特征值的顺序依次存储在 VR 的列中
    !     对于复特征值对应的复特征向量，实部存储在第一列，虚部存储在第二列
    !     如果 SIDE = 'L'，则不使用 VR

    ! LDVR 是 VR 数组的 leading dimension，LDVR >= 1，并且如果 SIDE = 'R' 或 'B'，LDVR >= N

    ! MM 是数组 VL 和/或 VR 的列数，MM >= M

    ! M 是输出参数，用于表示实际用于存储特征向量的列数
    !     如果 HOWMNY = 'A' 或 'B'，则 M 被设置为 N
    !     每个选定的实特征向量占据一列，每个选定的复特征向量占据两列

    ! WORK 是工作空间数组，维度为 3*N

    ! INFO 是输出参数
    !     = 0：成功退出
    !     < 0：如果 INFO = -i，则第 i 个参数具有非法值

    ! 进一步详情
    ! ===============
    ! 该程序中使用的算法基本上是反向（向前）替换，带有缩放以使代码对可能的溢出具有鲁棒性

    ! 每个特征向量被归一化，使得具有最大元素的部分为
    # magnitude has magnitude 1; here the magnitude of a complex number
    # (x,y) is taken to be |x| + |y|.
    # 这里讨论复数的大小，假设一个复数为 (x, y)，其大小被定义为 |x| + |y|。

    # =====================================================================

    # Decode and test the input parameters
    # 解码并测试输入参数
    /* 调整参数 */
    --select;  // 调整选择数组的起始位置
    t_dim1 = *ldt;  // 设置矩阵T的第一维度大小
    t_offset = 1 + t_dim1;  // 计算矩阵T的偏移量
    t -= t_offset;  // 调整矩阵T的起始位置
    vl_dim1 = *ldvl;  // 设置左特征向量矩阵VL的第一维度大小
    vl_offset = 1 + vl_dim1;  // 计算左特征向量矩阵VL的偏移量
    vl -= vl_offset;  // 调整左特征向量矩阵VL的起始位置
    vr_dim1 = *ldvr;  // 设置右特征向量矩阵VR的第一维度大小
    vr_offset = 1 + vr_dim1;  // 计算右特征向量矩阵VR的偏移量
    vr -= vr_offset;  // 调整右特征向量矩阵VR的起始位置
    --work;  // 调整工作数组的起始位置

    /* 函数体 */
    bothv = lsame_(side, "B");  // 检查是否需要计算左右特征向量
    rightv = lsame_(side, "R") || bothv;  // 检查是否需要计算右特征向量
    leftv = lsame_(side, "L") || bothv;  // 检查是否需要计算左特征向量

    allv = lsame_(howmny, "A");  // 检查是否需要计算所有特征向量
    over = lsame_(howmny, "B");  // 检查是否需要计算所选特征向量
    somev = lsame_(howmny, "S");  // 检查是否需要计算部分特征向量

    *info = 0;  // 初始化信息代码为0
    if (!rightv && !leftv) {  // 检查特征向量计算标志的合法性
        *info = -1;  // 如果非法，设置信息代码为-1
    } else if (!allv && !over && !somev) {  // 检查特征向量计算方式的合法性
        *info = -2;  // 如果非法，设置信息代码为-2
    } else if (*n < 0) {  // 检查矩阵维度的合法性
        *info = -4;  // 如果非法，设置信息代码为-4
    } else if (*ldt < max(1,*n)) {  // 检查矩阵T的第一维度大小的合法性
        *info = -6;  // 如果非法，设置信息代码为-6
    } else if (*ldvl < 1 || leftv && *ldvl < *n) {  // 检查左特征向量矩阵VL的第一维度大小的合法性
        *info = -8;  // 如果非法，设置信息代码为-8
    } else if (*ldvr < 1 || rightv && *ldvr < *n) {  // 检查右特征向量矩阵VR的第一维度大小的合法性
        *info = -10;  // 如果非法，设置信息代码为-10
    } else {
        /*
          计算所需列数M以存储选定的特征向量，
          标准化选择数组（SELECT）如果需要，并测试MM。
        */
        if (somev) {  // 如果需要计算部分特征向量
            *m = 0;  // 初始化特征向量数量为0
            pair = FALSE_;  // 初始化复数特征值标志为假
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                if (pair) {  // 如果前一个特征值是复数
                    pair = FALSE_;  // 重置复数特征值标志
                    select[j] = FALSE_;  // 取消选择当前特征向量
                } else {
                    if (j < *n) {
                        if (t[j + 1 + j * t_dim1] == 0.f) {  // 如果下一个特征值为实数且非零
                            if (select[j]) {  // 如果选择当前特征向量
                                ++(*m);  // 增加特征向量计数
                            }
                        } else {  // 如果下一个特征值为复数
                            pair = TRUE_;  // 设置复数特征值标志
                            if (select[j] || select[j + 1]) {  // 如果选择当前或下一个特征向量
                                select[j] = TRUE_;  // 选择当前特征向量
                                *m += 2;  // 增加特征向量计数
                            }
                        }
                    } else {
                        if (select[*n]) {  // 如果最后一个特征向量被选择
                            ++(*m);  // 增加特征向量计数
                        }
                    }
                }
                /* L10: */
            }
        } else {
            *m = *n;  // 如果需要计算所有或选定特征向量，设置特征向量数量为N
        }

        if (*mm < *m) {  // 检查输出数组MM的大小是否足够
            *info = -11;  // 如果不足够，设置信息代码为-11
        }
    }
    if (*info != 0) {  // 如果信息代码非零
        i__1 = -(*info);  // 计算负信息代码
        xerbla_("STREVC", &i__1);  // 调用错误处理例程
        return 0;  // 返回
    }

    /* 若可能，快速返回 */
    if (*n == 0) {  // 如果矩阵维度为零
        return 0;  // 直接返回
    }

    /* 设置常量以控制溢出 */
    unfl = slamch_("Safe minimum");  // 获取安全最小值
    ovfl = 1.f / unfl;  // 计算溢出阈值
    slabad_(&unfl, &ovfl);  // 校正溢出和下溢界限
    ulp = slamch_("Precision");  // 获取机器精度
    smlnum = unfl * (*n / ulp);  // 计算小数值的阈值
    bignum = (1.f - ulp) / smlnum;  // 计算大数值的阈值

    /*
       计算T的严格上三角部分每列的1-范数，
       以控制三角求解器中的溢出。
    */
    work[1] = 0.f;  // 初始化工作数组的第一个元素为零
    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {  // 遍历T的每一列
        work[j] = 0.f;  // 初始化当前列的1-范数为零
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            work[j] += (r__1 = t[i__ + j * t_dim1], dabs(r__1));  // 计算当前列的1-范数
            /* L20: */
        }
        /* L30: */
    }

    /*
       索引IP用于指定实数或复数特征值：
         IP = 0，实特征值，
              1，共轭复特征值对的第一个: (wr,wi)
             -1，共轭复特征值对的第二个: (wr,wi)
    */
    n2 = *n << 1;  // 计算N的两倍

    if (rightv) {  // 如果需要计算右特征向量

        /* 计算右特征向
    # 从 n 指向的值开始循环递减，直到 1
    for (ki = *n; ki >= 1; --ki) {

        # 如果 ip 等于 1，跳转到标签 L130
        if (ip == 1) {
        goto L130;
        }
        # 如果 ki 等于 1，跳转到标签 L40
        if (ki == 1) {
        goto L40;
        }
        # 如果 t 中的特定元素为 0.0，跳转到标签 L40
        if (t[ki + (ki - 1) * t_dim1] == 0.f) {
        goto L40;
        }
        # 将 ip 设为 -1
        ip = -1;
L40:
        if (somev) {  # 如果条件 somev 成立，则执行以下代码块
        if (ip == 0) {  # 如果 ip 等于 0
            if (! select[ki]) {  # 如果 select[ki] 不为真
            goto L130;  # 跳转到标签 L130 处
            }
        } else {
            if (! select[ki - 1]) {  # 如果 select[ki - 1] 不为真
            goto L130;  # 跳转到标签 L130 处
            }
        }
        }

/*           Compute the KI-th eigenvalue (WR,WI). */
/* 计算第 ki 个特征值 (WR,WI) */

        wr = t[ki + ki * t_dim1];  # 将矩阵 t 的第 ki 行、第 ki 列的元素赋给 wr
        wi = 0.f;  # 初始化 wi 为 0
        if (ip != 0) {  # 如果 ip 不等于 0
        wi = sqrt((r__1 = t[ki + (ki - 1) * t_dim1], dabs(r__1))) *
            sqrt((r__2 = t[ki - 1 + ki * t_dim1], dabs(r__2)));  # 计算复数部分的模
        }
/* Computing MAX */
        r__1 = ulp * (dabs(wr) + dabs(wi));  # 计算 ulp 乘以 wr 和 wi 的绝对值之和
        smin = dmax(r__1,smlnum);  # smin 取 r__1 和 smlnum 中的较大值

        if (ip == 0) {

/*              Real right eigenvector */
/*              实数右特征向量 */

        work[ki + *n] = 1.f;  # 将 work 数组中第 ki + *n 位置设为 1

/*              Form right-hand side */
/*              形成右手边 */

        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
            work[k + *n] = -t[k + ki * t_dim1];  # 将 -t[k + ki * t_dim1] 赋给 work 数组对应位置
/* L50: */
        }

/*
                Solve the upper quasi-triangular system:
                   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
*/
/* 解上三角伪三角系统：(T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK. */

        jnxt = ki - 1;  # 将 ki - 1 赋给 jnxt
        for (j = ki - 1; j >= 1; --j) {  # 从 ki - 1 循环到 1，步长为 -1
            if (j > jnxt) {
            goto L60;  # 如果 j 大于 jnxt，则跳转到标签 L60 处
            }
            j1 = j;  # 将 j 赋给 j1
            j2 = j;  # 将 j 赋给 j2
            jnxt = j - 1;  # 将 j - 1 赋给 jnxt
            if (j > 1) {
            if (t[j + (j - 1) * t_dim1] != 0.f) {  # 如果 t[j + (j - 1) * t_dim1] 不等于 0
                j1 = j - 1;  # 将 j - 1 赋给 j1
                jnxt = j - 2;  # 将 j - 2 赋给 jnxt
            }
            }

            if (j1 == j2) {

/*                    1-by-1 diagonal block */
/*                    1×1 对角块 */

            slaln2_(&c_false, &c__1, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*
                      Scale X(1,1) to avoid overflow when updating
                      the right-hand side.
*/
/* 缩放 X(1,1) 以避免更新右手边时的溢出 */

            if (xnorm > 1.f) {
                if (work[j] > bignum / xnorm) {
                x[0] /= xnorm;  # 将 x[0] 除以 xnorm
                scale /= xnorm;  # 将 scale 除以 xnorm
                }
            }

/*                    Scale if necessary */
/*                    必要时进行缩放 */

            if (scale != 1.f) {
                sscal_(&ki, &scale, &work[*n + 1], &c__1);  # 调用 sscal 函数，对 work[*n + 1] 进行缩放
            }
            work[j + *n] = x[0];  # 将 x[0] 赋给 work[j + *n]

/*                    Update right-hand side */
/*                    更新右手边 */

            i__1 = j - 1;
            r__1 = -x[0];
            saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);

            } else {

/*                    2-by-2 diagonal block */
/*                    2×2 对角块 */

            slaln2_(&c_false, &c__2, &c__1, &smin, &c_b15, &t[j -
                1 + (j - 1) * t_dim1], ldt, &c_b15, &c_b15, &
                work[j - 1 + *n], n, &wr, &c_b29, x, &c__2, &
                scale, &xnorm, &ierr);

/*
                      Scale X(1,1) and X(2,1) to avoid overflow when
                      updating the right-hand side.
*/
/* 缩放 X(1,1) 和 X(2,1) 以避免更新右手边时的溢出 */

            if (xnorm > 1.f) {
/* 计算最大值 */
r__1 = work[j - 1], r__2 = work[j];  // 从数组 work 中获取 j-1 和 j 位置的值
beta = dmax(r__1,r__2);  // 计算 r__1 和 r__2 的最大值并赋给 beta
if (beta > bignum / xnorm) {  // 如果 beta 大于 bignum / xnorm
    x[0] /= xnorm;  // 将 x[0] 除以 xnorm
    x[1] /= xnorm;  // 将 x[1] 除以 xnorm
    scale /= xnorm;  // 将 scale 除以 xnorm
}

/* 如果有必要，进行缩放 */
if (scale != 1.f) {  // 如果 scale 不等于 1
    sscal_(&ki, &scale, &work[*n + 1], &c__1);  // 调用 sscal_ 函数，将 work[*n+1] 中的 ki 个元素乘以 scale
}
work[j - 1 + *n] = x[0];  // 将 x[0] 赋值给 work[j-1+*n]
work[j + *n] = x[1];  // 将 x[1] 赋值给 work[j+*n]

/* 更新右侧向量 */
i__1 = j - 2;  // 设置循环上限为 j-2
r__1 = -x[0];  // 将 -x[0] 赋给 r__1
saxpy_(&i__1, &r__1, &t[(j - 1) * t_dim1 + 1], &c__1, &work[*n + 1], &c__1);  // 调用 saxpy_ 函数，更新 work[*n+1] 的值
i__1 = j - 2;  // 设置循环上限为 j-2
r__1 = -x[1];  // 将 -x[1] 赋给 r__1
saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[*n + 1], &c__1);  // 调用 saxpy_ 函数，再次更新 work[*n+1] 的值

}  // 结束 j 的循环

L60:  // 定义标签 L60

/* 将向量 x 或 Q*x 复制到 VR 并进行归一化 */
if (! over) {  // 如果不是 over 模式
    scopy_(&ki, &work[*n + 1], &c__1, &vr[is * vr_dim1 + 1], &c__1);  // 调用 scopy_ 函数，将 work[*n+1] 复制到 vr[is*vr_dim1+1]
    
    ii = isamax_(&ki, &vr[is * vr_dim1 + 1], &c__1);  // 获取 vr[is*vr_dim1+1] 中绝对值最大元素的索引
    remax = 1.f / (r__1 = vr[ii + is * vr_dim1], dabs(r__1));  // 计算归一化系数 remax
    sscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);  // 调用 sscal_ 函数，将 vr[is*vr_dim1+1] 归一化
    
    i__1 = *n;  // 设置循环上限为 *n
    for (k = ki + 1; k <= i__1; ++k) {  // 循环遍历 k 从 ki+1 到 *n
        vr[k + is * vr_dim1] = 0.f;  // 将 vr[k+is*vr_dim1] 设置为 0
    }
} else {  // 如果是 over 模式
    if (ki > 1) {  // 如果 ki 大于 1
        i__1 = ki - 1;  // 设置循环上限为 ki-1
        sgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &work[*n + 1], &c__1, &work[ki + *n], &vr[ki * vr_dim1 + 1], &c__1);  // 调用 sgemv_ 函数，进行矩阵向量乘法
    }
    
    ii = isamax_(n, &vr[ki * vr_dim1 + 1], &c__1);  // 获取 vr[ki*vr_dim1+1] 中绝对值最大元素的索引
    remax = 1.f / (r__1 = vr[ii + ki * vr_dim1], dabs(r__1));  // 计算归一化系数 remax
    sscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);  // 调用 sscal_ 函数，将 vr[ki*vr_dim1+1] 归一化
}

} else {  // 如果是复数右特征向量的情况

/* 复数右特征向量。初始求解 */
/* [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0. */
/* [ (T(KI,KI-1)   T(KI,KI)   )               ] */

if ((r__1 = t[ki - 1 + ki * t_dim1], dabs(r__1)) >= (r__2 = t[ki + (ki - 1) * t_dim1], dabs(r__2))) {  // 如果绝对值大于等于
    work[ki - 1 + *n] = 1.f;  // 设置 work[ki-1+*n] 为 1
    work[ki + n2] = wi / t[ki - 1 + ki * t_dim1];  // 计算 work[ki+n2]
} else {  // 否则
    work[ki - 1 + *n] = -wi / t[ki + (ki - 1) * t_dim1];  // 设置 work[ki-1+*n]
    work[ki + n2] = 1.f;  // 设置 work[ki+n2] 为 1
}
work[ki + *n] = 0.f;  // 设置 work[ki+*n] 为 0
work[ki - 1 + n2] = 0.f;  // 设置 work[ki-1+n2] 为 0

/* 形成右侧向量 */
i__1 = ki - 2;  // 设置循环上限为 ki-2
for (k = 1; k <= i__1; ++k) {  // 循环遍历 k 从 1 到 ki-2
    work[k + *n] = -work[ki - 1 + *n] * t[k + (ki - 1) * t_dim1];  // 计算 work[k+*n]
    work[k + n2] = -work[ki + n2] * t[k + ki * t_dim1];  // 计算 work[k+n2]
}
        jnxt = ki - 2;
        for (j = ki - 2; j >= 1; --j) {
            if (j > jnxt) {
            goto L90;
            }
            j1 = j;
            j2 = j;
            jnxt = j - 1;
            if (j > 1) {
            if (t[j + (j - 1) * t_dim1] != 0.f) {
                j1 = j - 1;
                jnxt = j - 2;
            }
            }

            if (j1 == j2) {

/*                    1-by-1 diagonal block */

            slaln2_(&c_false, &c__1, &c__2, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &wi, x, &c__2, &scale, &xnorm, &
                ierr);

/*
                      将 X(1,1) 和 X(1,2) 缩放，以避免更新右侧时的溢出。
*/

            if (xnorm > 1.f) {
                if (work[j] > bignum / xnorm) {
                x[0] /= xnorm;
                x[2] /= xnorm;
                scale /= xnorm;
                }
            }

/*                    如果需要，进行缩放 */

            if (scale != 1.f) {
                sscal_(&ki, &scale, &work[*n + 1], &c__1);
                sscal_(&ki, &scale, &work[n2 + 1], &c__1);
            }
            work[j + *n] = x[0];
            work[j + n2] = x[2];

/*                    更新右侧 */

            i__1 = j - 1;
            r__1 = -x[0];
            saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);
            i__1 = j - 1;
            r__1 = -x[2];
            saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[
                n2 + 1], &c__1);

            } else {

/*                    2-by-2 diagonal block */

            slaln2_(&c_false, &c__2, &c__2, &smin, &c_b15, &t[j -
                1 + (j - 1) * t_dim1], ldt, &c_b15, &c_b15, &
                work[j - 1 + *n], n, &wr, &wi, x, &c__2, &
                scale, &xnorm, &ierr);

/*
                      缩放 X 以避免更新右侧时的溢出。
*/

            if (xnorm > 1.f) {
/* 计算最大值 */
                r__1 = work[j - 1], r__2 = work[j];
                beta = dmax(r__1,r__2);
                if (beta > bignum / xnorm) {
                rec = 1.f / xnorm;
                x[0] *= rec;
                x[2] *= rec;
                x[1] *= rec;
                x[3] *= rec;
                scale *= rec;
                }
            }

/*                    如果需要，进行缩放 */

            if (scale != 1.f) {
                sscal_(&ki, &scale, &work[*n + 1], &c__1);
                sscal_(&ki, &scale, &work[n2 + 1], &c__1);
            }
            work[j - 1 + *n] = x[0];
            work[j + *n] = x[1];
            work[j - 1 + n2] = x[2];
            work[j + n2] = x[3];
/*                    Update the right-hand side */

/* 循环计算 j 从 2 到 j-1 */
i__1 = j - 2;
/* 计算 -x[0] 乘以 t[(j-1)*t_dim1+1]，结果加到 work[*n+1] 上 */
r__1 = -x[0];
saxpy_(&i__1, &r__1, &t[(j - 1) * t_dim1 + 1], &c__1,
    &work[*n + 1], &c__1);
/* 计算 -x[1] 乘以 t[j*t_dim1+1]，结果加到 work[*n+1] 上 */
i__1 = j - 2;
r__1 = -x[1];
saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[
    *n + 1], &c__1);
/* 计算 -x[2] 乘以 t[(j-1)*t_dim1+1]，结果加到 work[n2+1] 上 */
i__1 = j - 2;
r__1 = -x[2];
saxpy_(&i__1, &r__1, &t[(j - 1) * t_dim1 + 1], &c__1,
    &work[n2 + 1], &c__1);
/* 计算 -x[3] 乘以 t[j*t_dim1+1]，结果加到 work[n2+1] 上 */
i__1 = j - 2;
r__1 = -x[3];
saxpy_(&i__1, &r__1, &t[j * t_dim1 + 1], &c__1, &work[
    n2 + 1], &c__1);
}

L90:
;

/*              Copy the vector x or Q*x to VR and normalize. */

/* 如果不是过渡状态（over == false） */
if (! over) {
    /* 复制 work[*n+1] 到 vr[(is-1)*vr_dim1+1] */
    scopy_(&ki, &work[*n + 1], &c__1, &vr[(is - 1) * vr_dim1
        + 1], &c__1);
    /* 复制 work[n2+1] 到 vr[is*vr_dim1+1] */
    scopy_(&ki, &work[n2 + 1], &c__1, &vr[is * vr_dim1 + 1], &
        c__1);

    /* 计算 emax 的初值为 0 */
    emax = 0.f;
    /* 循环计算 k 从 1 到 ki */
    i__1 = ki;
    for (k = 1; k <= i__1; ++k) {
        /* 计算 vr[k+(is-1)*vr_dim1] 和 vr[k+is*vr_dim1] 的绝对值之和，更新 emax */
        /* Computing MAX */
        r__3 = emax, r__4 = (r__1 = vr[k + (is - 1) * vr_dim1]
            , dabs(r__1)) + (r__2 = vr[k + is * vr_dim1],
            dabs(r__2));
        emax = dmax(r__3,r__4);
        /* L100: */
    }

    /* 计算 remax 为 1/emax */
    remax = 1.f / emax;
    /* 将 vr[(is-1)*vr_dim1+1] 的每个元素乘以 remax，归一化 */
    sscal_(&ki, &remax, &vr[(is - 1) * vr_dim1 + 1], &c__1);
    /* 将 vr[is*vr_dim1+1] 的每个元素乘以 remax，归一化 */
    sscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);

    /* 循环计算 k 从 ki+1 到 *n，将 vr[k+(is-1)*vr_dim1] 和 vr[k+is*vr_dim1] 置为 0 */
    i__1 = *n;
    for (k = ki + 1; k <= i__1; ++k) {
        vr[k + (is - 1) * vr_dim1] = 0.f;
        vr[k + is * vr_dim1] = 0.f;
        /* L110: */
    }

} else {

    /* 如果 ki > 2 */
    if (ki > 2) {
        /* 使用 sgemv_ 函数计算矩阵乘向量操作 */
        i__1 = ki - 2;
        sgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &
            work[*n + 1], &c__1, &work[ki - 1 + *n], &vr[(
            ki - 1) * vr_dim1 + 1], &c__1);
        sgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &
            work[n2 + 1], &c__1, &work[ki + n2], &vr[ki *
            vr_dim1 + 1], &c__1);
    } else {
        /* 如果 ki <= 2，直接使用 sscal_ 函数 */
        sscal_(n, &work[ki - 1 + *n], &vr[(ki - 1) * vr_dim1
            + 1], &c__1);
        sscal_(n, &work[ki + n2], &vr[ki * vr_dim1 + 1], &
            c__1);
    }

    /* 计算 emax 的初值为 0 */
    emax = 0.f;
    /* 循环计算 k 从 1 到 *n */
    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
        /* 计算 vr[k+(ki-1)*vr_dim1] 和 vr[k+ki*vr_dim1] 的绝对值之和，更新 emax */
        /* Computing MAX */
        r__3 = emax, r__4 = (r__1 = vr[k + (ki - 1) * vr_dim1]
            , dabs(r__1)) + (r__2 = vr[k + ki * vr_dim1],
            dabs(r__2));
        emax = dmax(r__3,r__4);
        /* L120: */
    }
    /* 计算 remax 为 1/emax */
    remax = 1.f / emax;
    /* 将 vr[(ki-1)*vr_dim1+1] 的每个元素乘以 remax，归一化 */
    sscal_(n, &remax, &vr[(ki - 1) * vr_dim1 + 1], &c__1);
    /* 将 vr[ki*vr_dim1+1] 的每个元素乘以 remax，归一化 */
    sscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
}

/* is 减一 */
--is;
/* 如果 ip 不等于 0，is 再减一 */
if (ip != 0) {
    --is;
}
L130:
        if (ip == 1) {
        ip = 0;
        }
        if (ip == -1) {
        ip = 1;
        }
/* L140: */
    }
    }

    if (leftv) {

/*        Compute left eigenvectors. */

    ip = 0;
    is = 1;
    i__1 = *n;
    for (ki = 1; ki <= i__1; ++ki) {

        if (ip == -1) {
        goto L250;
        }
        if (ki == *n) {
        goto L150;
        }
        if (t[ki + 1 + ki * t_dim1] == 0.f) {
        goto L150;
        }
        ip = 1;

L150:
        if (somev) {
        if (! select[ki]) {
            goto L250;
        }
        }

/*           Compute the KI-th eigenvalue (WR,WI). */

        wr = t[ki + ki * t_dim1];
        wi = 0.f;
        if (ip != 0) {
        wi = sqrt((r__1 = t[ki + (ki + 1) * t_dim1], dabs(r__1))) *
            sqrt((r__2 = t[ki + 1 + ki * t_dim1], dabs(r__2)));
        }
/* Computing MAX */
        r__1 = ulp * (dabs(wr) + dabs(wi));
        smin = dmax(r__1,smlnum);

        if (ip == 0) {

/*              Real left eigenvector. */

        work[ki + *n] = 1.f;

/*              Form right-hand side */

        i__2 = *n;
        for (k = ki + 1; k <= i__2; ++k) {
            work[k + *n] = -t[ki + k * t_dim1];
/* L160: */
        }

/*
                Solve the quasi-triangular system:
                   (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
*/

        vmax = 1.f;
        vcrit = bignum;

        jnxt = ki + 1;
        i__2 = *n;
        for (j = ki + 1; j <= i__2; ++j) {
            if (j < jnxt) {
            goto L170;
            }
            j1 = j;
            j2 = j;
            jnxt = j + 1;
            if (j < *n) {
            if (t[j + 1 + j * t_dim1] != 0.f) {
                j2 = j + 1;
                jnxt = j + 2;
            }
            }

            if (j1 == j2) {

/*
                      1-by-1 diagonal block

                      Scale if necessary to avoid overflow when forming
                      the right-hand side.
*/

            if (work[j] > vcrit) {
                rec = 1.f / vmax;
                i__3 = *n - ki + 1;
                sscal_(&i__3, &rec, &work[ki + *n], &c__1);
                vmax = 1.f;
                vcrit = bignum;
            }

            i__3 = j - ki - 1;
            work[j + *n] -= sdot_(&i__3, &t[ki + 1 + j * t_dim1],
                &c__1, &work[ki + 1 + *n], &c__1);

/*                    Solve (T(J,J)-WR)'*X = WORK */

            slaln2_(&c_false, &c__1, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*                    Scale if necessary */

            if (scale != 1.f) {
                i__3 = *n - ki + 1;
                sscal_(&i__3, &scale, &work[ki + *n], &c__1);
            }
            work[j + *n] = x[0];
/* Computing MAX */
            r__2 = (r__1 = work[j + *n], dabs(r__1));
            vmax = dmax(r__2,vmax);
            vcrit = bignum / vmax;

            } else {


注释：

L130:
        if (ip == 1) {
        ip = 0;
        }
        if (ip == -1) {
        ip = 1;
        }
/* L140: */
    }
    }

    if (leftv) {

/*        Compute left eigenvectors. */

    ip = 0;
    is = 1;
    i__1 = *n;
    for (ki = 1; ki <= i__1; ++ki) {

        if (ip == -1) {  // 如果 ip 等于 -1，跳转到 L250
        goto L250;
        }
        if (ki == *n) {  // 如果 ki 等于 n，跳转到 L150
        goto L150;
        }
        if (t[ki + 1 + ki * t_dim1] == 0.f) {  // 如果对角线下方元素为零，跳转到 L150
        goto L150;
        }
        ip = 1;  // 设置 ip 为 1

L150:
        if (somev) {
        if (! select[ki]) {  // 如果 select[ki] 为假，跳转到 L250
            goto L250;
        }
        }

/*           计算第 ki 个特征值 (WR, WI) */

        wr = t[ki + ki * t_dim1];  // 获取实部特征值
        wi = 0.f;
        if (ip != 0) {  // 如果 ip 不为 0，计算虚部特征值
        wi = sqrt((r__1 = t[ki + (ki + 1) * t_dim1], dabs(r__1))) *
            sqrt((r__2 = t[ki + 1 + ki * t_dim1], dabs(r__2)));
        }
/* Computing MAX */  // 计算 smin，确保它不小于 ulp * (|wr| + |wi|)
        r__1 = ulp * (dabs(wr) + dabs(wi));
        smin = dmax(r__1,smlnum);

        if (ip == 0) {

/*              实数左特征向量。 */

        work[ki + *n] = 1.f;  // 左特征向量的第 ki 个元素设置为 1

/*              构造右手边 */

        i__2 = *n;
        for (k = ki + 1; k <= i__2; ++k) {
            work[k + *n] = -t[ki + k * t_dim1];  // 计算右手边向量
/* L160: */
        }

/*
                解决准上三角系统:
                   (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
*/

        vmax = 1.f;  // 设置最大值的初始值
        vcrit = bignum;  // 设置临界值

        jnxt = ki + 1;  // 下一个 j 的起始位置
        i__2 = *n;
        for (j = ki + 1; j <= i__2; ++j) {
            if (j < jnxt) {
            goto L170;  // 跳转到 L170
            }
            j1 = j;
            j2 = j;
            jnxt = j + 1;
            if (j < *n) {
            if (t[j + 1 + j * t_dim1] != 0.f) {
                j2 = j + 1;
                jnxt = j + 2;
            }
            }

            if (j1 == j2) {

/*
                      1-by-1 对角块

                      如有必要，进行缩放，以避免形成右手边时的溢出。
*/

            if (work[j] > vcrit) {
                rec = 1.f / vmax;
                i__3 = *n - ki + 1;
                sscal_(&i__3, &rec, &work[ki + *n], &c__1);  // 对 work 进行缩放
                vmax = 1.f;  // 重置最大值
                vcrit = bignum;  // 重置临界值
            }

            i__3 = j - ki - 1;
            work[j + *n] -= sdot_(&i__3, &t[ki + 1 + j * t_dim1],
                &c__1, &work[
/*
                      2-by-2 diagonal block

                      Scale if necessary to avoid overflow when forming
                      the right-hand side.

   Computing MAX
*/
            // 获取当前工作区间的两个元素
            r__1 = work[j], r__2 = work[j + 1];
            // 计算它们的绝对值最大值，作为 beta
            beta = dmax(r__1,r__2);
            // 如果 beta 超过阈值 vcrit，则进行缩放以避免溢出
            if (beta > vcrit) {
                // 计算缩放系数
                rec = 1.f / vmax;
                // 将从 ki 到末尾的元素进行缩放
                i__3 = *n - ki + 1;
                sscal_(&i__3, &rec, &work[ki + *n], &c__1);
                // 重置 vmax 和 vcrit
                vmax = 1.f;
                vcrit = bignum;
            }

            // 更新 work[j+n]，减去特定部分的点积
            i__3 = j - ki - 1;
            work[j + *n] -= sdot_(&i__3, &t[ki + 1 + j * t_dim1],
                &c__1, &work[ki + 1 + *n], &c__1);

            // 更新 work[j+1+n]，减去特定部分的点积
            i__3 = j - ki - 1;
            work[j + 1 + *n] -= sdot_(&i__3, &t[ki + 1 + (j + 1) *
                 t_dim1], &c__1, &work[ki + 1 + *n], &c__1);

/*
                      Solve
                        [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
                        [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
*/
            // 调用 slaln2_ 函数解线性方程组
            slaln2_(&c_true, &c__2, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*                    Scale if necessary */
            // 如果缩放系数不为 1，则对 work 进行缩放
            if (scale != 1.f) {
                i__3 = *n - ki + 1;
                sscal_(&i__3, &scale, &work[ki + *n], &c__1);
            }
            // 更新 work[j+n] 和 work[j+1+n]
            work[j + *n] = x[0];
            work[j + 1 + *n] = x[1];

/* Computing MAX */
            // 计算 work[j+n] 和 work[j+1+n] 的绝对值最大值
            r__3 = (r__1 = work[j + *n], dabs(r__1)), r__4 = (
                r__2 = work[j + 1 + *n], dabs(r__2)), r__3 =
                max(r__3,r__4);
            // 更新 vmax
            vmax = dmax(r__3,vmax);
            // 更新 vcrit
            vcrit = bignum / vmax;

            }
L170:
            ;
        }

/*              Copy the vector x or Q*x to VL and normalize. */

        // 如果不是溢出情况，将 work 中的向量复制到 VL 并进行归一化
        if (! over) {
            // 复制 work 中的部分到 VL
            i__2 = *n - ki + 1;
            scopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is *
                vl_dim1], &c__1);

            // 找到向量中的最大值索引
            i__2 = *n - ki + 1;
            ii = isamax_(&i__2, &vl[ki + is * vl_dim1], &c__1) + ki -
                1;
            // 计算归一化系数
            remax = 1.f / (r__1 = vl[ii + is * vl_dim1], dabs(r__1));
            // 对 VL 中的向量进行归一化
            i__2 = *n - ki + 1;
            sscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);

            // 将 ki 之前的部分置零
            i__2 = ki - 1;
            for (k = 1; k <= i__2; ++k) {
                vl[k + is * vl_dim1] = 0.f;
/* L180: */
            }

        } else {

            // 如果是溢出情况，计算 Q*x 并更新 VL
            if (ki < *n) {
                i__2 = *n - ki;
                sgemv_("N", n, &i__2, &c_b15, &vl[(ki + 1) * vl_dim1
                    + 1], ldvl, &work[ki + 1 + *n], &c__1, &work[
                    ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
            }

            // 找到向量中的最大值索引
            ii = isamax_(n, &vl[ki * vl_dim1 + 1], &c__1);
            // 计算归一化系数
            remax = 1.f / (r__1 = vl[ii + ki * vl_dim1], dabs(r__1));
            // 对 VL 中的向量进行归一化
            sscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);

        }

        } else {
        /*
                        复数左特征向量。

                         初始求解：
                           ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
                           ((T(KI+1,KI) T(KI+1,KI+1))                )
        */
        if ((r__1 = t[ki + (ki + 1) * t_dim1], dabs(r__1)) >= (r__2 =
            t[ki + 1 + ki * t_dim1], dabs(r__2))) {
            // 如果绝对值较大的元素是 T(KI,KI)，则计算复数除法得到 X 的第一个分量
            work[ki + *n] = wi / t[ki + (ki + 1) * t_dim1];
            // X 的第二个分量设为 1
            work[ki + 1 + n2] = 1.f;
        } else {
            // 如果绝对值较大的元素是 T(KI+1,KI)，则计算复数除法得到 X 的第二个分量
            work[ki + *n] = 1.f;
            // X 的第一个分量设为 -wi / T(KI+1,KI)
            work[ki + 1 + n2] = -wi / t[ki + 1 + ki * t_dim1];
        }
        // X 的其余两个分量设为 0
        work[ki + 1 + *n] = 0.f;
        work[ki + n2] = 0.f;

        /*              形成右侧向量 */
        i__2 = *n;
        for (k = ki + 2; k <= i__2; ++k) {
            // 计算右侧向量的第一个分量
            work[k + *n] = -work[ki + *n] * t[ki + k * t_dim1];
            // 计算右侧向量的第二个分量
            work[k + n2] = -work[ki + 1 + n2] * t[ki + 1 + k * t_dim1];
            // L190:
        }

        /*
                        解复数准三角系统：
                        ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
        */
        vmax = 1.f;
        vcrit = bignum;

        jnxt = ki + 2;
        i__2 = *n;
        for (j = ki + 2; j <= i__2; ++j) {
            if (j < jnxt) {
            goto L200;
            }
            j1 = j;
            j2 = j;
            jnxt = j + 1;
            if (j < *n) {
                // 如果下一个元素不为零，则将 j2 设置为 j+1，并将 jnxt 设置为 j+2
                if (t[j + 1 + j * t_dim1] != 0.f) {
                    j2 = j + 1;
                    jnxt = j + 2;
                }
            }

            if (j1 == j2) {

    /*
                          1x1 对角块

                          如有必要，进行缩放，以避免形成右侧元素时溢出。
    */
                if (work[j] > vcrit) {
                    // 如果 work[j] 超过阈值 vcrit，则对向量进行缩放
                    rec = 1.f / vmax;
                    i__3 = *n - ki + 1;
                    sscal_(&i__3, &rec, &work[ki + *n], &c__1);
                    i__3 = *n - ki + 1;
                    sscal_(&i__3, &rec, &work[ki + n2], &c__1);
                    vmax = 1.f;
                    vcrit = bignum;
                }

                i__3 = j - ki - 2;
                // 计算 WK 的实部
                work[j + *n] -= sdot_(&i__3, &t[ki + 2 + j * t_dim1],
                    &c__1, &work[ki + 2 + *n], &c__1);
                // 计算 WK 的虚部
                work[j + n2] -= sdot_(&i__3, &t[ki + 2 + j * t_dim1],
                    &c__1, &work[ki + 2 + n2], &c__1);

    /*                        解 (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2 */
                r__1 = -wi;
                slaln2_(&c_false, &c__1, &c__2, &smin, &c_b15, &t[j +
                    j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                    n], n, &wr, &r__1, x, &c__2, &scale, &xnorm, &
                    ierr);

                // 如果有必要，进行缩放
                if (scale != 1.f) {
                    i__3 = *n - ki + 1;
                    sscal_(&i__3, &scale, &work[ki + *n], &c__1);
                    i__3 = *n - ki + 1;
                    sscal_(&i__3, &scale, &work[ki + n2], &c__1);
                }
                // 将结果放入向量中
                work[j + *n] = x[0];
                work[j + n2] = x[2];

                /* 进入下一次迭代 */
                L200: ;
            }
        }
            /* Computing MAX */
            /* 计算最大值 */

            r__3 = (r__1 = work[j + *n], dabs(r__1)), r__4 = (
                r__2 = work[j + n2], dabs(r__2)), r__3 = max(
                r__3,r__4);
            /* 计算两个绝对值的最大值 */
            vmax = dmax(r__3,vmax);
            /* 更新最大值 */

            vcrit = bignum / vmax;
            /* 计算临界值 */

            } else {

                /*
                      2-by-2 diagonal block

                      Scale if necessary to avoid overflow when forming
                      the right-hand side elements.

                      2x2 对角块

                      如果需要，在形成右侧元素时进行缩放以避免溢出
                */

                r__1 = work[j], r__2 = work[j + 1];
                /* 获取工作数组中的两个值 */

                beta = dmax(r__1,r__2);
                /* 计算这两个值的最大值 */

                if (beta > vcrit) {
                    /* 如果最大值超过了临界值 */

                    rec = 1.f / vmax;
                    /* 计算缩放系数 */

                    i__3 = *n - ki + 1;
                    /* 计算要处理的数组长度 */

                    sscal_(&i__3, &rec, &work[ki + *n], &c__1);
                    /* 对部分工作数组进行缩放 */

                    i__3 = *n - ki + 1;
                    /* 再次计算要处理的数组长度 */

                    sscal_(&i__3, &rec, &work[ki + n2], &c__1);
                    /* 对另一部分工作数组进行缩放 */

                    vmax = 1.f;
                    /* 重置最大值 */

                    vcrit = bignum;
                    /* 重置临界值 */
                }

                i__3 = j - ki - 2;
                /* 计算需要处理的数组长度 */

                work[j + *n] -= sdot_(&i__3, &t[ki + 2 + j * t_dim1],
                    &c__1, &work[ki + 2 + *n], &c__1);
                /* 计算工作数组中的元素 */

                i__3 = j - ki - 2;
                /* 再次计算需要处理的数组长度 */

                work[j + n2] -= sdot_(&i__3, &t[ki + 2 + j * t_dim1],
                    &c__1, &work[ki + 2 + n2], &c__1);
                /* 计算工作数组中的元素 */

                i__3 = j - ki - 2;
                /* 再次计算需要处理的数组长度 */

                work[j + 1 + *n] -= sdot_(&i__3, &t[ki + 2 + (j + 1) *
                     t_dim1], &c__1, &work[ki + 2 + *n], &c__1);
                /* 计算工作数组中的元素 */

                i__3 = j - ki - 2;
                /* 再次计算需要处理的数组长度 */

                work[j + 1 + n2] -= sdot_(&i__3, &t[ki + 2 + (j + 1) *
                     t_dim1], &c__1, &work[ki + 2 + n2], &c__1);
                /* 计算工作数组中的元素 */

                /*
                      Solve 2-by-2 complex linear equation
                        ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
                        ([T(j+1,j) T(j+1,j+1)]             )

                      解 2x2 复数线性方程
                        ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
                        ([T(j+1,j) T(j+1,j+1)]             )
                */

                r__1 = -wi;
                /* 计算复数部分 */

                slaln2_(&c_true, &c__2, &c__2, &smin, &c_b15, &t[j +
                    j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                    n], n, &wr, &r__1, x, &c__2, &scale, &xnorm, &
                    ierr);
                /* 调用特定函数解方程 */

                /* Scale if necessary */
                /* 如果需要，进行缩放 */

                if (scale != 1.f) {
                    /* 如果缩放因子不为1 */

                    i__3 = *n - ki + 1;
                    /* 计算要处理的数组长度 */

                    sscal_(&i__3, &scale, &work[ki + *n], &c__1);
                    /* 对工作数组中的部分元素进行缩放 */

                    i__3 = *n - ki + 1;
                    /* 再次计算要处理的数组长度 */

                    sscal_(&i__3, &scale, &work[ki + n2], &c__1);
                    /* 对工作数组中的另一部分元素进行缩放 */
                }

                work[j + *n] = x[0];
                /* 更新工作数组中的元素 */
                work[j + n2] = x[2];
                /* 更新工作数组中的元素 */
                work[j + 1 + *n] = x[1];
                /* 更新工作数组中的元素 */
                work[j + 1 + n2] = x[3];
                /* 更新工作数组中的元素 */

                /* Computing MAX */
                /* 计算最大值 */

                r__1 = dabs(x[0]), r__2 = dabs(x[2]), r__1 = max(r__1,
                    r__2), r__2 = dabs(x[1]), r__1 = max(r__1,
                    r__2), r__2 = dabs(x[3]), r__1 = max(r__1,
                    r__2);
                /* 计算四个绝对值的最大值 */
                vmax = dmax(r__1,vmax);
                /* 更新最大值 */
                vcrit = bignum / vmax;
                /* 计算临界值 */

            }
L200:
            /* 标签，表示代码位置 */
            ;
        }
/*              Copy the vector x or Q*x to VL and normalize. */
/* 将向量 x 或 Q*x 复制到 VL 并进行归一化 */

if (! over) {
/* 如果不是过渡状态 */

    i__2 = *n - ki + 1;
    scopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is *
        vl_dim1], &c__1);
    /* 复制 work 数组中的一部分到 VL 数组中，并确保正确的缩放 */

    i__2 = *n - ki + 1;
    scopy_(&i__2, &work[ki + n2], &c__1, &vl[ki + (is + 1) *
        vl_dim1], &c__1);
    /* 继续复制 work 数组中的一部分到 VL 数组中，确保正确的缩放 */

    emax = 0.f;
    i__2 = *n;
    for (k = ki; k <= i__2; ++k) {
    /* 计算最大绝对值，并更新 emax */
/* 计算最大的绝对值，并更新 emax */
        r__3 = emax, r__4 = (r__1 = vl[k + is * vl_dim1],
            dabs(r__1)) + (r__2 = vl[k + (is + 1) *
            vl_dim1], dabs(r__2));
        emax = dmax(r__3,r__4);
    /* 更新 emax 为最大值 */
    }

    remax = 1.f / emax;
    i__2 = *n - ki + 1;
    sscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);
    /* 对 VL 数组中的一部分进行缩放，确保归一化 */

    i__2 = *n - ki + 1;
    sscal_(&i__2, &remax, &vl[ki + (is + 1) * vl_dim1], &c__1);
    /* 继续对 VL 数组中的一部分进行缩放，确保归一化 */

    i__2 = ki - 1;
    for (k = 1; k <= i__2; ++k) {
    /* 将 VL 数组中的一部分置为零 */
    vl[k + is * vl_dim1] = 0.f;
    vl[k + (is + 1) * vl_dim1] = 0.f;
    }
    /* 更新 VL 数组中的值为零 */
} else {
/* 否则 */

    if (ki < *n - 1) {
    /* 如果 ki 小于 n-1 */

        i__2 = *n - ki - 1;
        sgemv_("N", n, &i__2, &c_b15, &vl[(ki + 2) * vl_dim1
            + 1], ldvl, &work[ki + 2 + *n], &c__1, &work[
            ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
        /* 执行矩阵-向量乘法操作 */

        i__2 = *n - ki - 1;
        sgemv_("N", n, &i__2, &c_b15, &vl[(ki + 2) * vl_dim1
            + 1], ldvl, &work[ki + 2 + n2], &c__1, &work[
            ki + 1 + n2], &vl[(ki + 1) * vl_dim1 + 1], &
            c__1);
        /* 继续执行矩阵-向量乘法操作 */
    } else {

        sscal_(n, &work[ki + *n], &vl[ki * vl_dim1 + 1], &
            c__1);
        /* 对 VL 数组中的一部分进行缩放 */

        sscal_(n, &work[ki + 1 + n2], &vl[(ki + 1) * vl_dim1
            + 1], &c__1);
        /* 继续对 VL 数组中的一部分进行缩放 */
    }

    emax = 0.f;
    i__2 = *n;
    for (k = 1; k <= i__2; ++k) {
    /* 计算最大绝对值，并更新 emax */
    r__3 = emax, r__4 = (r__1 = vl[k + ki * vl_dim1],
        dabs(r__1)) + (r__2 = vl[k + (ki + 1) *
        vl_dim1], dabs(r__2));
    emax = dmax(r__3,r__4);
    }

    remax = 1.f / emax;
    sscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
    /* 对 VL 数组中的一部分进行缩放，确保归一化 */

    sscal_(n, &remax, &vl[(ki + 1) * vl_dim1 + 1], &c__1);
    /* 继续对 VL 数组中的一部分进行缩放，确保归一化 */
}

}

++is;
if (ip != 0) {
++is;
}
/* 增加 is 的值 */

L250:
if (ip == -1) {
ip = 0;
}
if (ip == 1) {
ip = -1;
}
/* 检查 ip 的值，并相应地修改它 */

/* L260: */
}

}

return 0;
/* 返回 0，表示成功 */

/*     End of STREVC */

} /* strevc_ */

/* Subroutine */ int strexc_(char *compq, integer *n, real *t, integer *ldt,
real *q, integer *ldq, integer *ifst, integer *ilst, real *work,
integer *info)
{
/* 过渡的子程序 */
/* System generated locals */
integer q_dim1, q_offset, t_dim1, t_offset, i__1;

/* Local variables */
static integer nbf, nbl, here;
extern logical lsame_(char *, char *);
static logical wantq;
/* 本地变量定义 */
    # 外部子程序声明，xerbla_ 和 slaexc_ 是在其他地方定义的外部子程序
    extern /* Subroutine */ int xerbla_(char *, integer *), slaexc_(
        logical *, integer *, real *, integer *, real *, integer *,
        integer *, integer *, integer *, real *, integer *);
    # 静态整数变量声明，用于存储下一个块的大小
    static integer nbnext;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    STREXC reorders the real Schur factorization of a real matrix
    A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
    moved to row ILST.

    The real Schur form T is reordered by an orthogonal similarity
    transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
    is updated by postmultiplying it with Z.

    T must be in Schur canonical form (as returned by SHSEQR), that is,
    block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
    2-by-2 diagonal block has its diagonal elements equal and its
    off-diagonal elements of opposite sign.

    Arguments
    =========

    COMPQ   (input) CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input/output) REAL array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            Schur canonical form.
            On exit, the reordered upper quasi-triangular matrix, again
            in Schur canonical form.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    Q       (input/output) REAL array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            orthogonal transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    IFST    (input/output) INTEGER
            Specify the reordering of the diagonal blocks of T.
            The block with row index IFST is moved to row ILST, by a
            sequence of transpositions between adjacent blocks.
            On exit, if IFST pointed on entry to the second row of a
            2-by-2 block, it is changed to point to the first row; ILST
            always points to the first row of the block in its final
            position (which may differ from its input value by +1 or -1).
            1 <= IFST <= N; 1 <= ILST <= N.

    WORK    (workspace) REAL array, dimension (N)

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            = 1:  two adjacent blocks were too close to swap (the problem
                  is very ill-conditioned); T may have been partially
                  reordered, and ILST points to the first row of the
                  current position of the block being moved.
*/
    =====================================================================
    # 分割线注释，用于在代码中标识不同部分或功能块


       Decode and test the input arguments.
    # 解码和测试输入参数
    /* 参数调整 */
    t_dim1 = *ldt;  // t 的第一维度大小
    t_offset = 1 + t_dim1;  // t 数组的偏移量
    t -= t_offset;  // 调整 t 指针位置，使其指向正确的内存位置
    q_dim1 = *ldq;  // q 的第一维度大小
    q_offset = 1 + q_dim1;  // q 数组的偏移量
    q -= q_offset;  // 调整 q 指针位置，使其指向正确的内存位置
    --work;  // 将 work 指针向前移动一位，使其指向正确的内存位置

    /* 函数主体 */
    *info = 0;  // 初始化 info 变量为 0
    wantq = lsame_(compq, "V");  // 判断是否需要计算 Q 矩阵，根据 compq 参数
    if (! wantq && ! lsame_(compq, "N")) {  // 如果 compq 参数既不是 "V" 也不是 "N"
        *info = -1;  // 将 info 设置为 -1
    } else if (*n < 0) {  // 如果 n 参数小于 0
        *info = -2;  // 将 info 设置为 -2
    } else if (*ldt < max(1,*n)) {  // 如果 ldt 参数小于 1 或者小于 n
        *info = -4;  // 将 info 设置为 -4
    } else if (*ldq < 1 || wantq && *ldq < max(1,*n)) {  // 如果 ldq 小于 1 或者小于 n，并且要求计算 Q 矩阵
        *info = -6;  // 将 info 设置为 -6
    } else if (*ifst < 1 || *ifst > *n) {  // 如果 ifst 参数不在合理范围内
        *info = -7;  // 将 info 设置为 -7
    } else if (*ilst < 1 || *ilst > *n) {  // 如果 ilst 参数不在合理范围内
        *info = -8;  // 将 info 设置为 -8
    }
    if (*info != 0) {  // 如果 info 不等于 0，则出现错误
        i__1 = -(*info);  // 计算错误码的负值
        xerbla_("STREXC", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0 表示函数执行结束
    }

/*     如果可能的话，快速返回 */

    if (*n <= 1) {  // 如果 n 小于等于 1，直接返回
        return 0;  // 返回 0 表示函数执行结束
    }

/*
       确定指定块的第一行，并确定其大小是 1x1 还是 2x2。
*/

    if (*ifst > 1) {  // 如果 ifst 大于 1
        if (t[*ifst + (*ifst - 1) * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
            --(*ifst);  // 如果不为 0，则将 ifst 减一
        }
    }
    nbf = 1;  // 初始化 nbf 为 1
    if (*ifst < *n) {  // 如果 ifst 小于 n
        if (t[*ifst + 1 + *ifst * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
            nbf = 2;  // 如果不为 0，则将 nbf 设置为 2
        }
    }

/*
       确定最后一个块的第一行，并确定其大小是 1x1 还是 2x2。
*/

    if (*ilst > 1) {  // 如果 ilst 大于 1
        if (t[*ilst + (*ilst - 1) * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
            --(*ilst);  // 如果不为 0，则将 ilst 减一
        }
    }
    nbl = 1;  // 初始化 nbl 为 1
    if (*ilst < *n) {  // 如果 ilst 小于 n
        if (t[*ilst + 1 + *ilst * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
            nbl = 2;  // 如果不为 0，则将 nbl 设置为 2
        }
    }

    if (*ifst == *ilst) {  // 如果 ifst 等于 ilst，直接返回
        return 0;  // 返回 0 表示函数执行结束
    }

    if (*ifst < *ilst) {  // 如果 ifst 小于 ilst

/*        更新 ilst */

        if (nbf == 2 && nbl == 1) {  // 如果当前块是 2x2 而下一个块是 1x1
            --(*ilst);  // 将 ilst 减一
        }
        if (nbf == 1 && nbl == 2) {  // 如果当前块是 1x1 而下一个块是 2x2
            ++(*ilst);  // 将 ilst 加一
        }

        here = *ifst;  // 将 here 初始化为 ifst

L10:

/*        与下面的块交换 */

        if (nbf == 1 || nbf == 2) {  // 如果当前块是 1x1 或者 2x2

/*           当前块是 1x1 或者 2x2 */

            nbnext = 1;  // 初始化 nbnext 为 1
            if (here + nbf + 1 <= *n) {  // 如果当前块加上下一个块不超过 n
                if (t[here + nbf + 1 + (here + nbf) * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
                    nbnext = 2;  // 如果不为 0，则将 nbnext 设置为 2
                }
            }
            slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &here, &
                nbf, &nbnext, &work[1], info);  // 调用 slaexc 函数进行块交换
            if (*info != 0) {  // 如果出现错误
                *ilst = here;  // 设置 ilst 为当前位置 here
                return 0;  // 返回 0 表示函数执行结束
            }
            here += nbnext;  // 更新 here 的位置

/*           检测 2x2 块是否能拆分成两个 1x1 块 */

            if (nbf == 2) {  // 如果当前块是 2x2
                if (t[here + 1 + here * t_dim1] == 0.f) {  // 检查指定位置的元素是否为 0
                    nbf = 3;  // 如果为 0，则将 nbf 设置为 3
                }
            }

        } else {

/*
             当前块由两个 1x1 块组成，每个都必须单独交换
*/

            nbnext = 1;  // 初始化 nbnext 为 1
            if (here + 3 <= *n) {  // 如果当前位置加上 3 不超过 n
                if (t[here + 3 + (here + 2) * t_dim1] != 0.f) {  // 检查指定位置的元素是否为 0
                    nbnext = 2;  // 如果不为 0，则将 nbnext 设置为 2
                }
            }
            i__1 = here + 1;  // 设置参数值 i__1
            slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
                c__1, &nbnext, &work[1], info);  // 调用 slaexc 函数进行块交换
            if (*info != 0) {  // 如果出现错误
                *ilst = here;  // 设置 il
/*              Swap two 1 by 1 blocks, no problems possible */

slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    here, &c__1, &nbnext, &work[1], info);
// 调用 slaexc 函数，交换两个大小为 1 的块，无问题可能发生
++here;
// 更新 here 变量，指向下一个块
} else {

/*              Recompute NBNEXT in case 2 by 2 split */

// 如果是 2x2 分块，则重新计算 nbnext
if (t[here + 2 + (here + 1) * t_dim1] == 0.f) {
    nbnext = 1;
}
if (nbnext == 2) {

/*                 2 by 2 Block did not split */

// 2x2 块未分裂
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    here, &c__1, &nbnext, &work[1], info);
// 调用 slaexc 函数处理 2x2 块
if (*info != 0) {
*ilst = here;
return 0;
}
here += 2;
} else {

/*                 2 by 2 Block did split */

// 2x2 块已分裂
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    here, &c__1, &c__1, &work[1], info);
// 调用 slaexc 函数处理已分裂的 2x2 块
i__1 = here + 1;
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    i__1, &c__1, &c__1, &work[1], info);
// 调用 slaexc 函数处理已分裂的 2x2 块的第二部分
here += 2;
}
}
}
if (here < *ilst) {
goto L10;
}

} else {

here = *ifst;
L20:

/*        Swap block with next one above */

// 与上面的块交换
if (nbf == 1 || nbf == 2) {

/*           Current block either 1 by 1 or 2 by 2 */

// 当前块为 1x1 或 2x2
nbnext = 1;
if (here >= 3) {
if (t[here - 1 + (here - 2) * t_dim1] != 0.f) {
    nbnext = 2;
}
}
i__1 = here - nbnext;
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
    nbnext, &nbf, &work[1], info);
// 调用 slaexc 函数，交换当前块与上面块，考虑到块的类型
if (*info != 0) {
*ilst = here;
return 0;
}
here -= nbnext;

/*           Test if 2 by 2 block breaks into two 1 by 1 blocks */

// 测试是否 2x2 块分裂成两个 1x1 块
if (nbf == 2) {
if (t[here + 1 + here * t_dim1] == 0.f) {
    nbf = 3;
}
}

} else {

/*
         Current block consists of two 1 by 1 blocks each of which
         must be swapped individually
*/

// 当前块由两个 1x1 块组成，每个块必须单独交换
nbnext = 1;
if (here >= 3) {
if (t[here - 1 + (here - 2) * t_dim1] != 0.f) {
    nbnext = 2;
}
}
i__1 = here - nbnext;
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
    nbnext, &c__1, &work[1], info);
// 调用 slaexc 函数，交换当前块与上面块，考虑到块的类型
if (*info != 0) {
*ilst = here;
return 0;
}
if (nbnext == 1) {

/*              Swap two 1 by 1 blocks, no problems possible */

// 交换两个 1x1 块，无问题可能发生
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    here, &nbnext, &c__1, &work[1], info);
--here;
} else {

/*              Recompute NBNEXT in case 2 by 2 split */

// 如果是 2x2 分块，则重新计算 nbnext
if (t[here + (here - 1) * t_dim1] == 0.f) {
nbnext = 1;
}
if (nbnext == 2) {
/*                 2 by 2 Block did not split */

/* 在这里执行2x2块未分裂的情况 */

i__1 = here - 1;
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    i__1, &c__2, &c__1, &work[1], info);
/* 调用SLAEXC函数处理不需要分裂的2x2块，更新矩阵T和Q */

if (*info != 0) {
/* 如果SLAEXC函数返回错误信息 */
*ilst = here;
/* 更新ilst的值为当前块的位置 */
return 0;
/* 返回0表示未成功 */
}
here += -2;
/* 更新here的值，准备处理下一个块 */

} else {

/*                 2 by 2 Block did split */

/* 处理2x2块分裂的情况 */

slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    here, &c__1, &c__1, &work[1], info);
/* 调用SLAEXC函数处理需要分裂的2x2块，更新矩阵T和Q */

i__1 = here - 1;
slaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
    i__1, &c__1, &c__1, &work[1], info);
/* 继续处理分裂的2x2块中的另一部分 */

here += -2;
/* 更新here的值，准备处理下一个块 */
}
}
}

if (here > *ilst) {
/* 检查当前处理的块位置是否超过ilst指定的位置 */
goto L20;
/* 如果超过，跳转到标号L20处 */
}
}
*ilst = here;
/* 更新ilst的值为当前处理的块位置 */

return 0;

/*     End of STREXC */

} /* strexc_ */

/* Subroutine */ int strti2_(char *uplo, char *diag, integer *n, real *a,
    integer *lda, integer *info)
{
/* STRTI2子程序开始 */

/* System generated locals */
integer a_dim1, a_offset, i__1, i__2;

/* Local variables */
static integer j;
static real ajj;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
static logical upper;
extern /* Subroutine */ int strmv_(char *, char *, char *, integer *,
    real *, integer *, real *, integer *),
    xerbla_(char *, integer *);
static logical nounit;

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

Purpose
=======

STRTI2计算实数上三角或下三角矩阵的逆矩阵。

This is the Level 2 BLAS version of the algorithm.

Arguments
=========

UPLO    (input) CHARACTER*1
        指定矩阵A是上三角还是下三角。
        = 'U':  上三角
        = 'L':  下三角

DIAG    (input) CHARACTER*1
        指定矩阵A是单位三角还是非单位三角。
        = 'N':  非单位三角
        = 'U':  单位三角

N       (input) INTEGER
        矩阵A的阶数。N >= 0.
*/
    ! 测试输入参数的有效性。
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;

/* Function Body */
*info = 0;
upper = lsame_(uplo, "U");
nounit = lsame_(diag, "N");
if (! upper && ! lsame_(uplo, "L")) {
    *info = -1;
} else if (! nounit && ! lsame_(diag, "U")) {
    *info = -2;
} else if (*n < 0) {
    *info = -3;
} else if (*lda < max(1,*n)) {
    *info = -5;
}
if (*info != 0) {
    i__1 = -(*info);
    xerbla_("STRTI2", &i__1);
    return 0;
}

if (upper) {

/*        Compute inverse of upper triangular matrix. */

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    if (nounit) {
        a[j + j * a_dim1] = 1.f / a[j + j * a_dim1];
        ajj = -a[j + j * a_dim1];
    } else {
        ajj = -1.f;
    }

/*           Compute elements 1:j-1 of j-th column. */

    i__2 = j - 1;
    strmv_("Upper", "No transpose", diag, &i__2, &a[a_offset], lda, &
        a[j * a_dim1 + 1], &c__1);
    i__2 = j - 1;
    sscal_(&i__2, &ajj, &a[j * a_dim1 + 1], &c__1);
    /* L10: */
}
} else {

/*        Compute inverse of lower triangular matrix. */

for (j = *n; j >= 1; --j) {
    if (nounit) {
        a[j + j * a_dim1] = 1.f / a[j + j * a_dim1];
        ajj = -a[j + j * a_dim1];
    } else {
        ajj = -1.f;
    }
    if (j < *n) {

/*              Compute elements j+1:n of j-th column. */

    i__1 = *n - j;
    strmv_("Lower", "No transpose", diag, &i__1, &a[j + 1 + (j +
        1) * a_dim1], lda, &a[j + 1 + j * a_dim1], &c__1);
    i__1 = *n - j;
    sscal_(&i__1, &ajj, &a[j + 1 + j * a_dim1], &c__1);
    }
    /* L20: */
}
}

return 0;

/*     End of STRTI2 */

} /* strti2_ */

/* Subroutine */ int strtri_(char *uplo, char *diag, integer *n, real *a,
integer *lda, integer *info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, i__1, i__2[2], i__3, i__4, i__5;
char ch__1[2];

/* Local variables */
static integer j, jb, nb, nn;
extern logical lsame_(char *, char *);
static logical upper;
extern /* Subroutine */ int strmm_(char *, char *, char *, char *,
    integer *, integer *, real *, real *, integer *, real *, integer *
    ), strsm_(char *, char *, char *,
    char *, integer *, integer *, real *, real *, integer *, real *,
    integer *), strti2_(char *, char *
    , integer *, real *, integer *, integer *),
    xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static logical nounit;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
November 2006


Purpose
=======

STRTRI computes the inverse of a real upper or lower triangular
    # 检查输入参数是否合法
    # 如果 N 小于 0，则返回参数错误
    if N < 0:
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;  // 设置 info 初始值为 0
    upper = lsame_(uplo, "U");  // 判断 uplo 是否为 "U"，并赋值给 upper
    nounit = lsame_(diag, "N");  // 判断 diag 是否为 "N"，并赋值给 nounit
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 uplo 不是 "U" 且不是 "L"
        *info = -1;  // 设置 info 为 -1
    } else if (! nounit && ! lsame_(diag, "U")) {  // 如果 diag 不是 "N" 且不是 "U"
        *info = -2;  // 设置 info 为 -2
    } else if (*n < 0) {  // 如果 n 小于 0
        *info = -3;  // 设置 info 为 -3
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 1 和 n 中的最大值
        *info = -5;  // 设置 info 为 -5
    }
    if (*info != 0) {  // 如果 info 不为 0
        i__1 = -(*info);  // 计算 -info
        xerbla_("STRTRI", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0
    }

    /* Quick return if possible */
    if (*n == 0) {  // 如果 n 等于 0
        return 0;  // 返回 0
    }

    /* Check for singularity if non-unit. */
    if (nounit) {  // 如果非单位矩阵
        i__1 = *n;
        for (*info = 1; *info <= i__1; ++(*info)) {  // 循环遍历矩阵的对角线元素
            if (a[*info + *info * a_dim1] == 0.f) {  // 如果对角线元素为零
                return 0;  // 返回 0
            }
            /* L10: */
        }
        *info = 0;  // 将 info 重新设为 0
    }

    /* Determine the block size for this environment. */
    i__2[0] = 1, a__1[0] = uplo;  // 设置数组 a__1 的值
    i__2[1] = 1, a__1[1] = diag;
    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);  // 合并字符串 uplo 和 diag
    nb = ilaenv_(&c__1, "STRTRI", ch__1, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv_ 函数确定块大小
    if (nb <= 1 || nb >= *n) {  // 如果块大小不合适
        /* Use unblocked code */
        strti2_(uplo, diag, n, &a[a_offset], lda, info);  // 调用未块化的求逆函数
    } else {
        /* Use blocked code */
        if (upper) {  // 如果是上三角矩阵
            /* Compute inverse of upper triangular matrix */
            i__1 = *n;
            i__3 = nb;
            for (j = 1; i__3 < 0 ? j >= i__1 : j <= i__1; j += i__3) {  // 循环计算每个块
                /* Computing MIN */
                i__4 = nb, i__5 = *n - j + 1;
                jb = min(i__4, i__5);  // 计算当前块的大小

                /* Compute rows 1:j-1 of current block column */
                i__4 = j - 1;
                strmm_("Left", "Upper", "No transpose", diag, &i__4, &jb,
                    &c_b15, &a[a_offset], lda, &a[j * a_dim1 + 1], lda);  // 对当前块上部进行乘法运算
                i__4 = j - 1;
                strsm_("Right", "Upper", "No transpose", diag, &i__4, &jb,
                    &c_b151, &a[j + j * a_dim1], lda, &a[j * a_dim1 + 1],
                    lda);  // 对当前块进行求解

                /* Compute inverse of current diagonal block */
                strti2_("Upper", diag, &jb, &a[j + j * a_dim1], lda, info);  // 对当前对角块求逆
                /* L20: */
            }
        } else {  // 如果是下三角矩阵
            /* Compute inverse of lower triangular matrix */
            nn = (*n - 1) / nb * nb + 1;
            i__3 = -nb;
            for (j = nn; i__3 < 0 ? j >= 1 : j <= 1; j += i__3) {  // 循环计算每个块
                /* Computing MIN */
                i__1 = nb, i__4 = *n - j + 1;
                jb = min(i__1, i__4);  // 计算当前块的大小
                if (j + jb <= *n) {  // 如果当前块不是最后一个块

                    /* Compute rows j+jb:n of current block column */
                    i__1 = *n - j - jb + 1;
                    strmm_("Left", "Lower", "No transpose", diag, &i__1, &jb,
                        &c_b15, &a[j + jb + (j + jb) * a_dim1], lda, &a[j
                        + jb + j * a_dim1], lda);  // 对当前块下部进行乘法运算
                    i__1 = *n - j - jb + 1;
                    strsm_("Right", "Lower", "No transpose", diag, &i__1, &jb,
                        &c_b151, &a[j + j * a_dim1], lda, &a[j + jb + j *
                        a_dim1], lda);  // 对当前块进行求解
                }
                /* L30: */
            }
        }
    }
}
/* 计算当前对角块的逆矩阵 */

strti2_("Lower", diag, &jb, &a[j + j * a_dim1], lda, info);
/* 调用名为 strti2_ 的子程序，用于计算下三角矩阵的逆。
   参数说明：
   - "Lower": 指定要处理的是下三角部分
   - diag: 指定对角元素的处理方式（如是否单位对角）
   - &jb: 当前块的尺寸
   - &a[j + j * a_dim1]: 当前对角块的起始地址
   - lda: 矩阵 a 的 leading dimension
   - info: 输出参数，返回操作的执行情况
*/

/* 结束当前函数 strtri_ */
} /* strtri_ */

/* 返回操作成功 */
return 0;
```