# `.\numpy\numpy\random\src\legacy\legacy-distributions.c`

```
/*
 * This file contains generation code for distribution that have been modified
 * since Generator was introduced. These are preserved using identical code
 * to what was in NumPy 1.16 so that the stream of values generated by
 * RandomState is not changed when there are changes that affect Generator.
 *
 * These functions should not be changed except if they contain code that
 * cannot be compiled. They should not be changed for bug fixes, performance
 * improvements that can change the values produced, or enhancements to precision.
 */
#include "include/legacy-distributions.h"

// 返回一个在 [0, 1) 范围内的随机双精度浮点数
static inline double legacy_double(aug_bitgen_t *aug_state) {
  return aug_state->bit_generator->next_double(aug_state->bit_generator->state);
}

// 生成服从标准正态分布的随机数
double legacy_gauss(aug_bitgen_t *aug_state) {
  if (aug_state->has_gauss) {
    const double temp = aug_state->gauss;
    aug_state->has_gauss = false;
    aug_state->gauss = 0.0;
    return temp;
  } else {
    double f, x1, x2, r2;

    do {
      x1 = 2.0 * legacy_double(aug_state) - 1.0;
      x2 = 2.0 * legacy_double(aug_state) - 1.0;
      r2 = x1 * x1 + x2 * x2;
    } while (r2 >= 1.0 || r2 == 0.0);

    /* Polar method, a more efficient version of the Box-Muller approach. */
    f = sqrt(-2.0 * log(r2) / r2);
    /* Keep for next call */
    aug_state->gauss = f * x1;
    aug_state->has_gauss = true;
    return f * x2;
  }
}

// 生成服从标准指数分布的随机数
double legacy_standard_exponential(aug_bitgen_t *aug_state) {
  /* We use -log(1-U) since U is [0, 1) */
  return -log(1.0 - legacy_double(aug_state));
}

// 生成服从标准 Gamma 分布的随机数
double legacy_standard_gamma(aug_bitgen_t *aug_state, double shape) {
  double b, c;
  double U, V, X, Y;

  if (shape == 1.0) {
    return legacy_standard_exponential(aug_state);
  }
  else if (shape == 0.0) {
    return 0.0;
  } else if (shape < 1.0) {
    for (;;) {
      U = legacy_double(aug_state);
      V = legacy_standard_exponential(aug_state);
      if (U <= 1.0 - shape) {
        X = pow(U, 1. / shape);
        if (X <= V) {
          return X;
        }
      } else {
        Y = -log((1 - U) / shape);
        X = pow(1.0 - shape + shape * Y, 1. / shape);
        if (X <= (V + Y)) {
          return X;
        }
      }
    }
  } else {
    b = shape - 1. / 3.;
    c = 1. / sqrt(9 * b);
    for (;;) {
      do {
        X = legacy_gauss(aug_state);
        V = 1.0 + c * X;
      } while (V <= 0.0);

      V = V * V * V;
      U = legacy_double(aug_state);
      if (U < 1.0 - 0.0331 * (X * X) * (X * X))
        return (b * V);
      if (log(U) < 0.5 * X * X + b * (1. - V + log(V)))
        return (b * V);
    }
  }
}

// 生成服从 Gamma 分布的随机数
double legacy_gamma(aug_bitgen_t *aug_state, double shape, double scale) {
  return scale * legacy_standard_gamma(aug_state, shape);
}

// 生成服从 Pareto 分布的随机数
double legacy_pareto(aug_bitgen_t *aug_state, double a) {
  return exp(legacy_standard_exponential(aug_state) / a) - 1;
}

// 生成服从 Weibull 分布的随机数
double legacy_weibull(aug_bitgen_t *aug_state, double a) {
  if (a == 0.0) {
    return 0.0;
  }
  return pow(legacy_standard_exponential(aug_state), 1. / a);
}
double legacy_power(aug_bitgen_t *aug_state, double a) {
  // 使用 legacy_standard_exponential 函数计算指数分布，并结合 a 计算幂次方
  return pow(1 - exp(-legacy_standard_exponential(aug_state)), 1. / a);
}

double legacy_chisquare(aug_bitgen_t *aug_state, double df) {
  // 使用 legacy_standard_gamma 函数计算 Gamma 分布的值，并返回卡方分布的结果
  return 2.0 * legacy_standard_gamma(aug_state, df / 2.0);
}

double legacy_rayleigh(bitgen_t *bitgen_state, double mode) {
  // 使用 next_double 函数生成随机数，并计算 Rayleigh 分布的结果
  return mode * sqrt(-2.0 * npy_log1p(-next_double(bitgen_state)));
}

double legacy_noncentral_chisquare(aug_bitgen_t *aug_state, double df,
                                   double nonc) {
  double out;
  if (nonc == 0) {
    // 如果非中心参数 nonc 为零，返回标准卡方分布的结果
    return legacy_chisquare(aug_state, df);
  }
  if (1 < df) {
    // 使用 legacy_gauss 函数生成高斯分布随机数，并计算非中心卡方分布的结果
    const double Chi2 = legacy_chisquare(aug_state, df - 1);
    const double n = legacy_gauss(aug_state) + sqrt(nonc);
    return Chi2 + n * n;
  } else {
    const long i = random_poisson(aug_state->bit_generator, nonc / 2.0);
    out = legacy_chisquare(aug_state, df + 2 * i);
    /* 在此处插入 NaN 保护，以避免更改数据流 */
    if (npy_isnan(nonc)){
      // 如果 nonc 是 NaN，则返回 NaN
      return NPY_NAN;
    } else {
      return out;
    }
  }
}

double legacy_noncentral_f(aug_bitgen_t *aug_state, double dfnum, double dfden,
                           double nonc) {
  // 计算非中心 F 分布的结果
  double t = legacy_noncentral_chisquare(aug_state, dfnum, nonc) * dfden;
  return t / (legacy_chisquare(aug_state, dfden) * dfnum);
}

double legacy_wald(aug_bitgen_t *aug_state, double mean, double scale) {
  double U, X, Y;
  double mu_2l;

  mu_2l = mean / (2 * scale);
  Y = legacy_gauss(aug_state);
  Y = mean * Y * Y;
  X = mean + mu_2l * (Y - sqrt(4 * scale * Y + Y * Y));
  U = legacy_double(aug_state);
  if (U <= mean / (mean + X)) {
    return X;
  } else {
    return mean * mean / X;
  }
}

double legacy_normal(aug_bitgen_t *aug_state, double loc, double scale) {
  // 返回正态分布的结果
  return loc + scale * legacy_gauss(aug_state);
}

double legacy_lognormal(aug_bitgen_t *aug_state, double mean, double sigma) {
  // 返回对数正态分布的结果
  return exp(legacy_normal(aug_state, mean, sigma));
}

double legacy_standard_t(aug_bitgen_t *aug_state, double df) {
  double num, denom;

  num = legacy_gauss(aug_state);
  denom = legacy_standard_gamma(aug_state, df / 2);
  return sqrt(df / 2) * num / sqrt(denom);
}

int64_t legacy_negative_binomial(aug_bitgen_t *aug_state, double n, double p) {
  // 使用 legacy_gamma 函数计算 Gamma 分布的值，并返回负二项分布的结果
  double Y = legacy_gamma(aug_state, n, (1 - p) / p);
  return (int64_t)random_poisson(aug_state->bit_generator, Y);
}

double legacy_standard_cauchy(aug_bitgen_t *aug_state) {
  // 返回标准 Cauchy 分布的结果
  return legacy_gauss(aug_state) / legacy_gauss(aug_state);
}

double legacy_beta(aug_bitgen_t *aug_state, double a, double b) {
  double Ga, Gb;

  if ((a <= 1.0) && (b <= 1.0)) {
    double U, V, X, Y;
    /* 使用 Johnk's 算法 */
    // TODO: 补充 Johnk's 算法的详细解释
  }
  // 返回 Beta 分布的结果
  return Ga / (Ga + Gb);
}
    // 进入循环，使用 legacy_double 函数生成两个均匀分布的随机数 U 和 V
    while (1) {
      // 从增强状态生成一个双精度浮点数 U
      U = legacy_double(aug_state);
      // 从增强状态生成一个双精度浮点数 V
      V = legacy_double(aug_state);
      
      // 计算 X 和 Y，分别为 U 的 a 次方根和 V 的 b 次方根
      X = pow(U, 1.0 / a);
      Y = pow(V, 1.0 / b);

      // 如果 X + Y 小于或等于 1.0
      if ((X + Y) <= 1.0) {
        // 如果 X + Y 大于 0
        if (X + Y > 0) {
          // 返回 X / (X + Y)
          return X / (X + Y);
        } else {
          // 计算对数值 logX 和 logY，分别为 log(U) / a 和 log(V) / b
          double logX = log(U) / a;
          double logY = log(V) / b;
          // 计算最大的 logX 和 logY
          double logM = logX > logY ? logX : logY;
          // 对 logX 和 logY 进行调整
          logX -= logM;
          logY -= logM;

          // 返回 exp(logX - log(exp(logX) + exp(logY)))
          return exp(logX - log(exp(logX) + exp(logY)));
        }
      }
    }
  } else {
    // 使用增强状态和参数 a 生成 Ga
    Ga = legacy_standard_gamma(aug_state, a);
    // 使用增强状态和参数 b 生成 Gb
    Gb = legacy_standard_gamma(aug_state, b);
    // 返回 Ga / (Ga + Gb)
    return Ga / (Ga + Gb);
  }
}

// 计算自由度为 dfnum 和 dfden 的卡方分布变量比值
double legacy_f(aug_bitgen_t *aug_state, double dfnum, double dfden) {
    return ((legacy_chisquare(aug_state, dfnum) * dfden) /
            (legacy_chisquare(aug_state, dfden) * dfnum));
}

// 计算指数分布变量，使用给定的比例尺度
double legacy_exponential(aug_bitgen_t *aug_state, double scale) {
    return scale * legacy_standard_exponential(aug_state);
}

// 原始的随机二项分布生成器
static RAND_INT_TYPE legacy_random_binomial_original(bitgen_t *bitgen_state,
                                                     double p,
                                                     RAND_INT_TYPE n,
                                                     binomial_t *binomial) {
    double q;

    if (p <= 0.5) {
        // 当成功概率 p*n 小于等于 30 时使用反转法生成二项分布
        if (p * n <= 30.0) {
            return random_binomial_inversion(bitgen_state, n, p, binomial);
        } else {
            // 否则使用 BTPE 算法生成二项分布
            return random_binomial_btpe(bitgen_state, n, p, binomial);
        }
    } else {
        q = 1.0 - p;
        // 当失败概率 q*n 小于等于 30 时使用反转法生成二项分布
        if (q * n <= 30.0) {
            return n - random_binomial_inversion(bitgen_state, n, q, binomial);
        } else {
            // 否则使用 BTPE 算法生成二项分布
            return n - random_binomial_btpe(bitgen_state, n, q, binomial);
        }
    }
}

// 随机生成二项分布，返回整数类型结果
int64_t legacy_random_binomial(bitgen_t *bitgen_state, double p,
                               int64_t n, binomial_t *binomial) {
    return (int64_t) legacy_random_binomial_original(bitgen_state, p,
                                                     (RAND_INT_TYPE) n,
                                                     binomial);
}

// HYP 算法生成超几何分布的随机变量
static RAND_INT_TYPE random_hypergeometric_hyp(bitgen_t *bitgen_state,
                                               RAND_INT_TYPE good,
                                               RAND_INT_TYPE bad,
                                               RAND_INT_TYPE sample) {
    RAND_INT_TYPE d1, k, z;
    double d2, u, y;

    d1 = bad + good - sample;
    d2 = (double) MIN(bad, good);

    y = d2;
    k = sample;
    while (y > 0.0) {
        u = next_double(bitgen_state);
        y -= (RAND_INT_TYPE) floor(u + y / (d1 + k));
        k--;
        if (k == 0)
            break;
    }
    z = (RAND_INT_TYPE) (d2 - y);
    if (good > bad)
        z = sample - z;
    return z;
}

// 常量定义，用于计算超几何分布的变量
/* D1 = 2*sqrt(2/e) */
/* D2 = 3 - 2*sqrt(3/e) */
#define D1 1.7155277699214135
#define D2 0.8989161620588988
/*
 * 使用 HRUA 算法生成超几何分布的随机数
 * 使用指定的随机数生成器状态、好品质物品数、坏品质物品数和样本数
 */
static RAND_INT_TYPE random_hypergeometric_hrua(bitgen_t *bitgen_state,
                                                RAND_INT_TYPE good,
                                                RAND_INT_TYPE bad,
                                                RAND_INT_TYPE sample) {
  // 计算好品质和坏品质中的最小值
  RAND_INT_TYPE mingoodbad, maxgoodbad, popsize, m, d9;
  double d4, d5, d6, d7, d8, d10, d11;
  RAND_INT_TYPE Z;
  double T, W, X, Y;

  mingoodbad = MIN(good, bad);  // 计算最小的好品质和坏品质数量
  popsize = good + bad;         // 总物品数量
  maxgoodbad = MAX(good, bad);  // 计算最大的好品质和坏品质数量
  m = MIN(sample, popsize - sample);  // 样本数和剩余物品数中较小的值
  d4 = ((double)mingoodbad) / popsize;  // 好品质物品在总物品中所占比例
  d5 = 1.0 - d4;  // 坏品质物品在总物品中所占比例
  d6 = m * d4 + 0.5;  // 期望值的修正
  d7 = sqrt((double)(popsize - m) * sample * d4 * d5 / (popsize - 1) + 0.5);  // 标准差的估算
  d8 = D1 * d7 + D2;  // 修正因子
  d9 = (RAND_INT_TYPE)floor((double)(m + 1) * (mingoodbad + 1) / (popsize + 2));  // 计算随机数
  d10 = (random_loggam(d9 + 1) + random_loggam(mingoodbad - d9 + 1) +
         random_loggam(m - d9 + 1) + random_loggam(maxgoodbad - m + d9 + 1));  // 计算随机数
  d11 = MIN(MIN(m, mingoodbad) + 1.0, floor(d6 + 16 * d7));  // 计算阈值

  /* 16 for 16-decimal-digit precision in D1 and D2 */
  /* 16 用于 D1 和 D2 的 16 位小数精度 */

  while (1) {
    X = next_double(bitgen_state);  // 生成随机数
    Y = next_double(bitgen_state);  // 生成随机数
    W = d6 + d8 * (Y - 0.5) / X;  // 计算 W 值

    /* fast rejection: */
    /* 快速拒绝： */
    if ((W < 0.0) || (W >= d11))
      continue;  // 如果 W 超出范围则重新生成

    Z = (RAND_INT_TYPE)floor(W);  // 转换 W 为整数
    T = d10 - (random_loggam(Z + 1) + random_loggam(mingoodbad - Z + 1) +
               random_loggam(m - Z + 1) + random_loggam(maxgoodbad - m + Z + 1));  // 计算 T 值

    /* fast acceptance: */
    /* 快速接受： */
    if ((X * (4.0 - X) - 3.0) <= T)
      break;  // 如果接受条件成立则接受

    /* fast rejection: */
    /* 快速拒绝： */
    if (X * (X - T) >= 1)
      continue;  // 如果拒绝条件成立则重新生成
    /* log(0.0) is ok here, since always accept */
    /* 这里使用 log(0.0) 是可以的，因为总是接受 */
    if (2.0 * log(X) <= T)
      break; /* acceptance */  // 如果接受条件成立则接受
  }

  /* this is a correction to HRUA* by Ivan Frohne in rv.py */
  /* 这是在 rv.py 中对 HRUA* 的修正 */

  if (good > bad)
    Z = m - Z;  // 根据好品质和坏品质的比较修正 Z 值

  /* another fix from rv.py to allow sample to exceed popsize/2 */
  /* 另一个修复，允许样本数超过总物品数量的一半 */

  if (m < sample)
    Z = good - Z;  // 根据样本数和好品质修正 Z 值

  return Z;  // 返回生成的随机数
}
#undef D1
#undef D2

/*
 * 使用原始超几何分布生成器
 * 根据样本数的大小选择使用 HRUA 算法或者其他方法
 */
static RAND_INT_TYPE random_hypergeometric_original(bitgen_t *bitgen_state,
                                                    RAND_INT_TYPE good,
                                                    RAND_INT_TYPE bad,
                                                    RAND_INT_TYPE sample)
{
  if (sample > 10) {
    return random_hypergeometric_hrua(bitgen_state, good, bad, sample);  // 如果样本数大于 10 使用 HRUA 算法
  } else if (sample > 0) {
    return random_hypergeometric_hyp(bitgen_state, good, bad, sample);  // 如果样本数大于 0 使用其他算法
  } else {
    return 0;  // 否则返回 0
  }
}

/*
 * 这是一个包装函数，与预期的模板匹配。
 * 在旧生成器中，所有 int 类型都是 long，因此这里接受 int64 然后将其转换为 long。
 * 这些值必须在 long 的范围内，并且这在函数外部检查。
 *
 * 其余部分仅包括返回类型
 */
// 使用给定的随机数生成器和参数，调用原始超几何分布生成函数来生成一个随机数
int64_t legacy_random_hypergeometric(bitgen_t *bitgen_state, int64_t good,
                                     int64_t bad, int64_t sample) {
  return (int64_t)random_hypergeometric_original(bitgen_state,
                                                 (RAND_INT_TYPE)good,
                                                 (RAND_INT_TYPE)bad,
                                                 (RAND_INT_TYPE)sample);
}

// 使用给定的随机数生成器和参数，调用原始泊松分布生成函数来生成一个随机数
int64_t legacy_random_poisson(bitgen_t *bitgen_state, double lam) {
  return (int64_t)random_poisson(bitgen_state, lam);
}

// 使用给定的随机数生成器和参数，调用原始 Zipf 分布生成函数来生成一个随机数
int64_t legacy_random_zipf(bitgen_t *bitgen_state, double a) {
  return (int64_t)random_zipf(bitgen_state, a);
}

// 使用给定的随机数生成器和参数，通过几何分布的反函数方法来生成一个随机数
static long legacy_geometric_inversion(bitgen_t *bitgen_state, double p) {
  return (long)ceil(npy_log1p(-next_double(bitgen_state)) / log(1 - p));
}

// 使用给定的随机数生成器和参数，根据概率 p 的大小选择使用不同的几何分布生成方法来生成一个随机数
int64_t legacy_random_geometric(bitgen_t *bitgen_state, double p) {
  if (p >= 0.333333333333333333333333) {
    return (int64_t)random_geometric_search(bitgen_state, p);
  } else {
    return (int64_t)legacy_geometric_inversion(bitgen_state, p);
  }
}

// 使用给定的随机数生成器和参数，调用原始多项分布生成函数来生成多项式分布的随机数
void legacy_random_multinomial(bitgen_t *bitgen_state, RAND_INT_TYPE n,
                               RAND_INT_TYPE *mnix, double *pix, npy_intp d,
                               binomial_t *binomial) {
  return random_multinomial(bitgen_state, n, mnix, pix, d, binomial);
}

// 使用给定的随机数生成器和参数，根据 von Mises 分布的参数 mu 和 kappa 生成一个随机数
double legacy_vonmises(bitgen_t *bitgen_state, double mu, double kappa) {
  double s;
  double U, V, W, Y, Z;
  double result, mod;
  int neg;
  if (npy_isnan(kappa)) {
    return NPY_NAN;
  }
  if (kappa < 1e-8) {
    return M_PI * (2 * next_double(bitgen_state) - 1);
  } else {
    /* with double precision rho is zero until 1.4e-8 */
    if (kappa < 1e-5) {
      /*
       * second order taylor expansion around kappa = 0
       * precise until relatively large kappas as second order is 0
       */
      s = (1. / kappa + kappa);
    } else {
        /* Path for 1e-5 <= kappa <= 1e6 */
        double r = 1 + sqrt(1 + 4 * kappa * kappa);
        double rho = (r - sqrt(2 * r)) / (2 * kappa);
        s = (1 + rho * rho) / (2 * rho);
    }

    while (1) {
      U = next_double(bitgen_state);
      Z = cos(M_PI * U);
      W = (1 + s * Z) / (s + Z);
      Y = kappa * (s - W);
      V = next_double(bitgen_state);
      /*
       * V==0.0 is ok here since Y >= 0 always leads
       * to accept, while Y < 0 always rejects
       */
      if ((Y * (2 - Y) - V >= 0) || (log(Y / V) + 1 - Y >= 0)) {
        break;
      }
    }

    U = next_double(bitgen_state);

    result = acos(W);
    if (U < 0.5) {
      result = -result;
    }
    result += mu;
    neg = (result < 0);
    mod = fabs(result);
    mod = (fmod(mod + M_PI, 2 * M_PI) - M_PI);
    if (neg) {
      mod *= -1;
    }

    return mod;
  }
}

// 使用给定的随机数生成器和参数，调用原始对数系列分布生成函数来生成一个随机数
int64_t legacy_logseries(bitgen_t *bitgen_state, double p) {
  double q, r, U, V;
  long result;

  r = log(1.0 - p);

  while (1) {
    V = next_double(bitgen_state);
    if (V >= p) {
      return 1;
    }
    # 生成一个均匀分布的双精度随机数 U
    U = next_double(bitgen_state);
    # 计算概率 q，用于判断返回结果
    q = 1.0 - exp(r * U);
    # 如果 V 小于等于 q 的平方，则返回一个数值 result
    if (V <= q * q) {
      # 计算 result，即 log(V) / log(q) 的向下取整再加一
      result = (long)floor(1 + log(V) / log(q));
      # 如果 result 小于 1 或者 V 等于 0.0，则继续循环
      if ((result < 1) || (V == 0.0)) {
        continue;
      } else {
        # 否则返回 result 的整数类型值
        return (int64_t)result;
      }
    }
    # 如果 V 大于等于 q，则返回 1
    if (V >= q) {
      return 1;
    }
    # 其他情况返回 2
    return 2;
}


注释：

# 这行代码表示一个代码块的结束，通常与一个以关键字开始（如if、for、def等）的代码块配对。
```