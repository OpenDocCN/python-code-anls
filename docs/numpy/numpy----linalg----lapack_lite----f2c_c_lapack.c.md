# `.\numpy\numpy\linalg\lapack_lite\f2c_c_lapack.c`

```py
/*
 * NOTE: This is generated code. Look in numpy/linalg/lapack_lite for
 *       information on remaking this file.
 */
#include "f2c.h"

#ifdef HAVE_CONFIG
#include "config.h"
#else
extern doublereal dlamch_(char *);
#define EPSILON dlamch_("Epsilon")
#define SAFEMINIMUM dlamch_("Safe minimum")
#define PRECISION dlamch_("Precision")
#define BASE dlamch_("Base")
#endif

extern doublereal dlapy2_(doublereal *x, doublereal *y);

/*
f2c knows the exact rules for precedence, and so omits parentheses where not
strictly necessary. Since this is generated code, we don't really care if
it's readable, and we know what is written is correct. So don't warn about
them.
*/
#if defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

/* Table of constant values */

static integer c__1 = 1;
static singlecomplex c_b56 = {0.f,0.f};
static singlecomplex c_b57 = {1.f,0.f};
static integer c_n1 = -1;
static integer c__3 = 3;
static integer c__2 = 2;
static integer c__0 = 0;
static integer c__65 = 65;
static integer c__9 = 9;
static integer c__6 = 6;
static real c_b328 = 0.f;
static real c_b1034 = 1.f;
static integer c__12 = 12;
static integer c__49 = 49;
static real c_b1276 = -1.f;
static integer c__13 = 13;
static integer c__15 = 15;
static integer c__14 = 14;
static integer c__16 = 16;
static logical c_false = FALSE_;
static logical c_true = TRUE_;
static real c_b2435 = .5f;

/* Subroutine */ int cgebak_(char *job, char *side, integer *n, integer *ilo,
    integer *ihi, real *scale, integer *m, singlecomplex *v, integer *ldv,
    integer *info)
{
    /* System generated locals */
    integer v_dim1, v_offset, i__1;

    /* Local variables */
    static integer i__, k;
    static real s;
    static integer ii;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int cswap_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    static logical leftv;
    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
        *), xerbla_(char *, integer *);
    static logical rightv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    CGEBAK forms the right or left eigenvectors of a complex general
    matrix by backward transformation on the computed eigenvectors of the
    balanced matrix output by CGEBAL.

    Arguments
    ==========
    JOB     (input) CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to CGEBAL.
*/
    SIDE    (input) CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.
            # 输入参数，指定 V 包含右特征向量 ('R') 还是左特征向量 ('L')

    N       (input) INTEGER
            The number of rows of the matrix V.  N >= 0.
            # 输入参数，矩阵 V 的行数，必须大于等于 0

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            The integers ILO and IHI determined by CGEBAL.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
            # 输入参数，由 CGEBAL 确定的整数值 ILO 和 IHI 的范围

    SCALE   (input) REAL array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by CGEBAL.
            # 输入参数，包含置换和缩放因子的详细信息，由 CGEBAL 返回

    M       (input) INTEGER
            The number of columns of the matrix V.  M >= 0.
            # 输入参数，矩阵 V 的列数，必须大于等于 0

    V       (input/output) COMPLEX array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by CHSEIN or CTREVC.
            On exit, V is overwritten by the transformed eigenvectors.
            # 输入/输出参数，入口时为要转换的右或左特征向量矩阵，由 CHSEIN 或 CTREVC 返回。
            # 离开时，V 被转换后的特征向量所覆盖

    LDV     (input) INTEGER
            The leading dimension of the array V. LDV >= max(1,N).
            # 输入参数，矩阵 V 的前导维度，必须大于等于 max(1, N)

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            # 输出参数，返回状态信息：
            # INFO = 0：成功退出
            # INFO < 0：若 INFO = -i，则第 i 个参数具有非法值
/* Parameter adjustments */
/* 调整参数 */
--scale;
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;

/* Function Body */
/* 函数体 */

rightv = lsame_(side, "R");
leftv = lsame_(side, "L");

*info = 0;
/* 初始化 info 为 0 */
if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
    && ! lsame_(job, "B")) {
/* 检查 job 参数的合法性 */
*info = -1;
} else if (! rightv && ! leftv) {
/* 检查 side 参数的合法性 */
*info = -2;
} else if (*n < 0) {
/* 检查 n 参数的合法性 */
*info = -3;
} else if (*ilo < 1 || *ilo > max(1,*n)) {
/* 检查 ilo 参数的合法性 */
*info = -4;
} else if (*ihi < min(*ilo,*n) || *ihi > *n) {
/* 检查 ihi 参数的合法性 */
*info = -5;
} else if (*m < 0) {
/* 检查 m 参数的合法性 */
*info = -7;
} else if (*ldv < max(1,*n)) {
/* 检查 ldv 参数的合法性 */
*info = -9;
}
if (*info != 0) {
/* 如果出现错误，调用错误处理函数并返回 */
i__1 = -(*info);
xerbla_("CGEBAK", &i__1);
return 0;
}

/* Quick return if possible */
/* 如果可能的话，快速返回 */
if (*n == 0) {
/* 当 n 为 0 时直接返回 */
return 0;
}
if (*m == 0) {
/* 当 m 为 0 时直接返回 */
return 0;
}
if (lsame_(job, "N")) {
/* 当 job 为 "N" 时直接返回 */
return 0;
}

if (*ilo == *ihi) {
/* 如果 ilo 等于 ihi，跳转到 L30 */
goto L30;
}

/* Backward balance */
/* 向后平衡 */

if (lsame_(job, "S") || lsame_(job, "B")) {

if (rightv) {
/* 如果 side 为 "R" */
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
    /* 循环遍历 ilo 到 ihi */
    s = scale[i__];
    /* 获取 scale 数组的元素 */
    csscal_(m, &s, &v[i__ + v_dim1], ldv);
    /* 调用 csscal 函数 */
    /* L10: */
    }
}

if (leftv) {
/* 如果 side 为 "L" */
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
    /* 循环遍历 ilo 到 ihi */
    s = 1.f / scale[i__];
    /* 计算倒数 */
    csscal_(m, &s, &v[i__ + v_dim1], ldv);
    /* 调用 csscal 函数 */
    /* L20: */
    }
}

}

/*
   Backward permutation

   For  I = ILO-1 step -1 until 1,
            IHI+1 step 1 until N do --
*/
/*
   向后置换

   对于 I = ILO-1 递减至 1,
            IHI+1 递增至 N --
*/

L30:
if (lsame_(job, "P") || lsame_(job, "B")) {
/* 如果 job 为 "P" 或 "B" */

if (rightv) {
/* 如果 side 为 "R" */
    i__1 = *n;
    for (ii = 1; ii <= i__1; ++ii) {
    /* 循环遍历 1 到 n */
    i__ = ii;
    if (i__ >= *ilo && i__ <= *ihi) {
        goto L40;
    }
    if (i__ < *ilo) {
        i__ = *ilo - ii;
    }
    k = scale[i__];
    /* 获取 scale 数组的元素 */
    if (k == i__) {
        goto L40;
    }
    cswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
    /* 调用 cswap 函数 */
L40:
    ;
    }
}

if (leftv) {
/* 如果 side 为 "L" */
    i__1 = *n;
    for (ii = 1; ii <= i__1; ++ii) {
    /* 循环遍历 1 到 n */
    i__ = ii;
    if (i__ >= *ilo && i__ <= *ihi) {
        goto L50;
    }
    if (i__ < *ilo) {
        i__ = *ilo - ii;
    }
    k = scale[i__];
    /* 获取 scale 数组的元素 */
    if (k == i__) {
        goto L50;
    }
    cswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
    /* 调用 cswap 函数 */
L50:
    ;
    }
}
}

return 0;

/* End of CGEBAK */

} /* cgebak_ */

/* Subroutine */ int cgebal_(char *job, integer *n, singlecomplex *a, integer *lda,
integer *ilo, integer *ihi, real *scale, integer *info)
{
/* 子程序 cgebal */

/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, i__1, i__2, i__3;
real r__1, r__2;

/* Local variables */
/* 本地变量 */
static real c__, f, g;
static integer i__, j, k, l, m;
static real r__, s, ca, ra;
static integer ica, ira, iexc;
extern logical lsame_(char *, char *);
/* 外部函数 lsame_ */
    extern /* Subroutine */ int cswap_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    # 外部声明，引用名为 cswap_ 的子程序，参数分别为整数、单精度复数数组、整数、单精度复数数组、整数

    static real sfmin1, sfmin2, sfmax1, sfmax2;
    # 静态声明，定义四个实数变量 sfmin1, sfmin2, sfmax1, sfmax2

    extern integer icamax_(integer *, singlecomplex *, integer *);
    # 外部声明，引用名为 icamax_ 的函数，参数为整数、单精度复数数组、整数，返回整数类型

    extern doublereal slamch_(char *);
    # 外部声明，引用名为 slamch_ 的函数，参数为字符指针，返回双精度实数类型

    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
        *);
    # 外部声明，引用名为 csscal_ 的子程序，参数为整数、实数、单精度复数数组、整数

    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 外部声明，引用名为 xerbla_ 的子程序，参数为字符指针、整数

    extern logical sisnan_(real *);
    # 外部声明，引用名为 sisnan_ 的函数，参数为实数，返回逻辑类型

    static logical noconv;
    # 静态声明，定义逻辑变量 noconv
"""
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    CGEBAL balances a general complex matrix A.  This involves, first,
    permuting A by a similarity transformation to isolate eigenvalues
    in the first 1 to ILO-1 and last IHI+1 to N elements on the
    diagonal; and second, applying a diagonal similarity transformation
    to rows and columns ILO to IHI to make the rows and columns as
    close in norm as possible.  Both steps are optional.

    Balancing may reduce the 1-norm of the matrix, and improve the
    accuracy of the computed eigenvalues and/or eigenvectors.

    Arguments
    =========

    JOB     (input) CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    ILO     (output) INTEGER
    IHI     (output) INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.

    SCALE   (output) REAL array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The permutations consist of row and column interchanges which put
    the matrix in the form

               ( T1   X   Y  )
       P A P = (  0   B   Z  )
               (  0   0   T2 )

    where T1 and T2 are upper triangular matrices whose eigenvalues lie
    along the diagonal.  The column indices ILO and IHI mark the starting
    and ending columns of the submatrix B. Balancing consists of applying
    a diagonal similarity transformation inv(D) * B * D to make the
"""

# CGEBAL function for balancing a general complex matrix A
def cgebal(JOB, N, A, LDA, ILO, IHI, SCALE, INFO):
    """
    Arguments:
    JOB     (input) CHARACTER*1
            Specifies the operations to be performed on A.
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit, A is overwritten by the balanced matrix.
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    ILO     (output) INTEGER
            Set to integer such that A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
    IHI     (output) INTEGER
            Set to integer such that A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
    SCALE   (output) REAL array, dimension (N)
            Details of the permutations and scaling factors applied to A.
    INFO    (output) INTEGER
            = 0: successful exit.
            < 0: if INFO = -i, the i-th argument had an illegal value.
    """
    pass  # Placeholder for the actual implementation of CGEBAL
    # 计算矩阵 B 每行的1-范数以及对应列的1-范数几乎相等。
    # 输出的矩阵如下所示：
    # 
    #    ( T1     X*D          Y    )
    #    (  0  inv(D)*B*D  inv(D)*Z ).
    #    (  0      0           T2   )
    # 
    # 返回排列 P 和对角矩阵 D 的信息存储在向量 SCALE 中。
    # 
    # 此子程序基于 EISPACK 库的 CBAL 程序。
    # 
    # 修改者：Tzu-Yi Chen，加利福尼亚大学伯克利分校，美国计算机科学部门
    
    =====================================================================
    
    # 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --scale;

    /* Function Body */
    *info = 0;
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CGEBAL", &i__1);
        return 0;
    }

    k = 1;
    l = *n;

    if (*n == 0) {
        goto L210;
    }

    if (lsame_(job, "N")) {
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scale[i__] = 1.f;
            /* L10: */
        }
        goto L210;
    }

    if (lsame_(job, "S")) {
        goto L120;
    }

    /* Permutation to isolate eigenvalues if possible */
    goto L50;

    /* Row and column exchange. */
L20:
    scale[m] = (real) j;
    if (j == m) {
        goto L30;
    }

    cswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    i__1 = *n - k + 1;
    cswap_(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

L30:
    switch (iexc) {
        case 1:  goto L40;
        case 2:  goto L80;
    }

    /* Search for rows isolating an eigenvalue and push them down. */
L40:
    if (l == 1) {
        goto L210;
    }
    --l;

L50:
    for (j = l; j >= 1; --j) {

        i__1 = l;
        for (i__ = 1; i__ <= i__1; ++i__) {
            if (i__ == j) {
                goto L60;
            }
            i__2 = j + i__ * a_dim1;
            if (a[i__2].r != 0.f || r_imag(&a[j + i__ * a_dim1]) != 0.f) {
                goto L70;
            }
L60:
            ;
        }

        m = l;
        iexc = 1;
        goto L20;
L70:
        ;
    }

    goto L90;

    /* Search for columns isolating an eigenvalue and push them left. */
L80:
    ++k;

L90:
    i__1 = l;
    for (j = k; j <= i__1; ++j) {

        i__2 = l;
        for (i__ = k; i__ <= i__2; ++i__) {
            if (i__ == j) {
                goto L100;
            }
            i__3 = i__ + j * a_dim1;
            if (a[i__3].r != 0.f || r_imag(&a[i__ + j * a_dim1]) != 0.f) {
                goto L110;
            }
L100:
            ;
        }

        m = k;
        iexc = 2;
        goto L20;
L110:
        ;
    }

    /* Set scale factors for rows K to L */
L120:
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        scale[i__] = 1.f;
        /* L130: */
    }

    if (lsame_(job, "P")) {
        goto L210;
    }

    /*
       Balance the submatrix in rows K to L.

       Iterative loop for norm reduction
    */
L140:
    sfmin1 = slamch_("S") / slamch_("P");
    sfmax1 = 1.f / sfmin1;
    sfmin2 = sfmin1 * 2.f;
    sfmax2 = 1.f / sfmin2;

    noconv = FALSE_;

    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        c__ = 0.f;
        r__ = 0.f;

        i__2 = l;
        for (j = k; j <= i__2; ++j) {
            if (j == i__) {
                goto L150;
            }
            i__3 = j + i__ * a_dim1;
            c__ += (r__1 = a[i__3].r, dabs(r__1)) + (r__2 = r_imag(&a[j + i__ * a_dim1]), dabs(r__2));
            i__3 = i__ + j * a_dim1;
            r__ += (r__1 = a[i__3].r, dabs(r__1)) + (r__2 = r_imag(&a[i__ + j * a_dim1]), dabs(r__2));
L150:
            ;
        }
        /* L160: */
    }
    # 调用外部函数 icamax_，返回最大绝对值的元素在一维数组中的索引
    ica = icamax_(&l, &a[i__ * a_dim1 + 1], &c__1);
    # 计算复数数组 a 中索引为 ica 的元素的绝对值
    ca = c_abs(&a[ica + i__ * a_dim1]);
    # 计算数组 a 中第 i__ 行，从列 k 开始到末尾的部分的维度
    i__2 = *n - k + 1;
    # 调用外部函数 icamax_，返回最大绝对值的元素在一维数组中的索引
    ira = icamax_(&i__2, &a[i__ + k * a_dim1], lda);
    # 计算复数数组 a 中第 i__ 行，从列 ira+k-1 处的元素的绝对值
    ra = c_abs(&a[i__ + (ira + k - 1) * a_dim1]);
/*        Guard against zero C or R due to underflow. */

if (c__ == 0.f || r__ == 0.f) {
    goto L200;
}
g = r__ / 2.f;
f = 1.f;
s = c__ + r__;
L160:
/* Computing MAX */
r__1 = max(f,c__);
/* Computing MIN */
r__2 = min(r__,g);
if (c__ >= g || dmax(r__1,ca) >= sfmax2 || dmin(r__2,ra) <= sfmin2) {
    goto L170;
}
r__1 = c__ + f + ca + r__ + g + ra;
if (sisnan_(&r__1)) {

/*           Exit if NaN to avoid infinite loop */

    *info = -3;
    i__2 = -(*info);
    xerbla_("CGEBAL", &i__2);
    return 0;
}
f *= 2.f;
c__ *= 2.f;
ca *= 2.f;
r__ /= 2.f;
g /= 2.f;
ra /= 2.f;
goto L160;

L170:
g = c__ / 2.f;
L180:
/* Computing MIN */
r__1 = min(f,c__), r__1 = min(r__1,g);
if (g < r__ || dmax(r__,ra) >= sfmax2 || dmin(r__1,ca) <= sfmin2) {
    goto L190;
}
f /= 2.f;
c__ /= 2.f;
g /= 2.f;
ca /= 2.f;
r__ *= 2.f;
ra *= 2.f;
goto L180;

/*        Now balance. */

L190:
if (c__ + r__ >= s * .95f) {
    goto L200;
}
if (f < 1.f && scale[i__] < 1.f) {
    if (f * scale[i__] <= sfmin1) {
    goto L200;
    }
}
if (f > 1.f && scale[i__] > 1.f) {
    if (scale[i__] >= sfmax1 / f) {
    goto L200;
    }
}
g = 1.f / f;
scale[i__] *= f;
noconv = TRUE_;

i__2 = *n - k + 1;
csscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
csscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
;
}

if (noconv) {
goto L140;
}

L210:
*ilo = k;
*ihi = l;

return 0;

/*     End of CGEBAL */

} /* cgebal_ */

/* Subroutine */ int cgebd2_(integer *m, integer *n, singlecomplex *a, integer *lda,
 real *d__, real *e, singlecomplex *tauq, singlecomplex *taup, singlecomplex *work,
 integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;
singlecomplex q__1;

/* Local variables */
static integer i__;
static singlecomplex alpha;
extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
 , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
 clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
 clacgv_(integer *, singlecomplex *, integer *), xerbla_(char *, integer
 *);


注释：


/*        Guard against zero C or R due to underflow. */

// 如果 c__ 或 r__ 为零，跳转到 L200 标签
if (c__ == 0.f || r__ == 0.f) {
    goto L200;
}
// 计算 g 为 r__ 的一半，初始化 f 为 1，计算 s 为 c__ + r__
g = r__ / 2.f;
f = 1.f;
s = c__ + r__;

L160:
/* Computing MAX */
// 计算 f 和 c__ 的最大值
r__1 = max(f,c__);
/* Computing MIN */
// 计算 r__ 和 g 的最小值
r__2 = min(r__,g);
// 如果 c__ >= g 或者 max(f,ca) >= sfmax2 或者 min(r__,ra) <= sfmin2，则跳转到 L170
if (c__ >= g || dmax(r__1,ca) >= sfmax2 || dmin(r__2,ra) <= sfmin2) {
    goto L170;
}
// 如果计算结果中包含 NaN，避免无限循环，设置 *info = -3 并调用 xerbla 函数报错
r__1 = c__ + f + ca + r__ + g + ra;
if (sisnan_(&r__1)) {
    *info = -3;
    i__2 = -(*info);
    xerbla_("CGEBAL", &i__2);
    return 0;
}
// f 值翻倍，同时 c__、ca、r__、g、ra 值也分别翻倍或减半
f *= 2.f;
c__ *= 2.f;
ca *= 2.f;
r__ /= 2.f;
g /= 2.f;
ra /= 2.f;
// 回到 L160 标签处继续执行

L170:
// 计算 g 为 c__ 的一半
g = c__ / 2.f;

L180:
/* Computing MIN */
// 计算 f、c__、g 的最小值
r__1 = min(f,c__), r__1 = min(r__1,g);
// 如果 g < r__ 或者 max(r__,ra) >= sfmax2 或者 min(f,c__,g) <= sfmin2，则跳转到 L190
if (g < r__ || dmax(r__,ra) >= sfmax2 || dmin(r__1,ca) <= sfmin2) {
    goto L190;
}
// f、c__、g 减半，同时 ca、r__、ra 值翻倍或减半
f /= 2.f;
c__ /= 2.f;
g /= 2.f;
ca /= 2.f;
r__ *= 2.f;
ra *= 2.f;
// 回到 L180 标签处继续执行

/*        Now balance. */

L190:
// 如果 c__ + r__ >= s * .95f，则跳转到 L200
if (c__ + r__ >= s * .95f) {
    goto L200;
}
// 如果 f < 1 且 scale[i__] < 1，且 f * scale[i__] <= sfmin1，则跳转到 L200
if (f < 1.f && scale[i__] < 1.f) {
    if (f * scale[i__] <= sfmin1) {
        goto L200;
    }
}
// 如果 f > 1 且 scale[i__] > 1，且 scale[i__] >= sfmax1 / f，则跳转到 L200
if (f > 1.f && scale[i__] > 1.f) {
    if (scale[i__] >= sfmax1 / f) {
        goto L200;
    }
}
// 计算 g 为 1/f，更新 scale[i__] 为 scale[i__] * f，设置 noconv 为 TRUE_
g = 1.f / f;
scale[i__] *= f;
noconv = TRUE_;

// 对矩阵部分元素进行缩放
i__2 = *n - k + 1;
csscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
csscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
// 空语句，标记 L200 处的结束

}

// 如果 noconv 为真，则跳转到 L140
if (noconv) {
    goto L140;
}

L210:
// 设置 *ilo 和 *ihi 的值，函数正常结束
*ilo = k;
*ihi = l;

return 0;

/*     End of CGEBAL */

} /* cgebal_ */

/* Subroutine */ int cgebd2_(integer *m, integer *n, singlecomplex *a, integer *lda,
 real *d__, real *e, singlecomplex *tauq, singlecomplex *taup, singlecomplex *work,
 integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;
singlecomplex q__1;

/* Local variables */
static integer i__;
static singlecomplex alpha;
extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
 , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
 clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
 clacgv_(integer *, singlecomplex *, integer *), x
    N       (input) INTEGER
            The number of columns in the matrix A.  N >= 0.
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    D       (output) REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).

    E       (output) REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

    TAUQ    (output) COMPLEX array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.

    TAUP    (output) COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.

    WORK    (workspace) COMPLEX array, dimension (max(M,N))

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

    If m >= n,

       Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are complex scalars, and v and u are complex
    vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
    A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
    A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    If m < n,

       Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are complex scalars, v and u are complex vectors;
    v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
    u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
    tauq is stored in TAUQ(i) and taup in TAUP(i).


    The contents of A on exit are illustrated by the following examples:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
      (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
      (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
      (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
      (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
      (  v1  v2  v3  v4  v5 )


    where d and e denote diagonal and off-diagonal elements of B, vi
    denotes an element of the vector defining H(i), and ui an element of
    the vector defining G(i).


    =====================================================================

       Test the input parameters
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    if (*m < 0) {  // 检查 m 是否小于 0
        *info = -1;  // 若是，设置 info 参数为 -1
    } else if (*n < 0) {  // 检查 n 是否小于 0
        *info = -2;  // 若是，设置 info 参数为 -2
    } else if (*lda < max(1,*m)) {  // 检查 lda 是否小于 max(1, m)
        *info = -4;  // 若是，设置 info 参数为 -4
    }
    if (*info < 0) {  // 若 info 参数小于 0，则调用错误处理函数并返回
        i__1 = -(*info);
        xerbla_("CGEBD2", &i__1);
        return 0;
    }

    if (*m >= *n) {

/*        Reduce to upper bidiagonal form */

        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {

/*           Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

            i__2 = i__ + i__ * a_dim1;
            alpha.r = a[i__2].r, alpha.i = a[i__2].i;  // 提取 A(i,i) 的值作为 alpha
            i__2 = *m - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            clarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1, &
                tauq[i__]);  // 生成 Householder 变换 H(i)，存储在 tauq[i] 中
            i__2 = i__;
            d__[i__2] = alpha.r;  // 将生成的对角元素存入 d 数组中
            i__2 = i__ + i__ * a_dim1;
            a[i__2].r = 1.f, a[i__2].i = 0.f;  // 将 A(i,i) 设置为单位矩阵

/*           Apply H(i)' to A(i:m,i+1:n) from the left */

            if (i__ < *n) {
                i__2 = *m - i__ + 1;
                i__3 = *n - i__;
                r_cnjg(&q__1, &tauq[i__]);
                clarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &
                    q__1, &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);  // 应用 Householder 变换到 A 的左侧子矩阵
            }
            i__2 = i__ + i__ * a_dim1;
            i__3 = i__;
            a[i__2].r = d__[i__3], a[i__2].i = 0.f;  // 恢复 A(i,i) 的原始值

            if (i__ < *n) {

/*                Generate elementary reflector G(i) to annihilate
                A(i,i+2:n) */

                i__2 = *n - i__;
                clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);  // 对 A(i,i+1:n) 进行共轭处理
                i__2 = i__ + (i__ + 1) * a_dim1;
                alpha.r = a[i__2].r, alpha.i = a[i__2].i;  // 提取 A(i,i+1) 的值作为 alpha
                i__2 = *n - i__;
                /* Computing MIN */
                i__3 = i__ + 2;
                clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
                    taup[i__]);  // 生成 Householder 变换 G(i)，存储在 taup[i] 中
                i__2 = i__;
                e[i__2] = alpha.r;  // 将生成的对角元素存入 e 数组中
                i__2 = i__ + (i__ + 1) * a_dim1;
                a[i__2].r = 1.f, a[i__2].i = 0.f;  // 将 A(i,i+1) 设置为单位矩阵

/*              Apply G(i) to A(i+1:m,i+1:n) from the right */

                i__2 = *m - i__;
                i__3 = *n - i__;
                clarf_("Right", &i__2, &i__3, &a[i__ + (i__ + 1) * a_dim1],
                    lda, &taup[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
                    lda, &work[1]);  // 应用 Householder 变换到 A 的右侧子矩阵
                i__2 = *n - i__;
                clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);  // 恢复 A(i,i+1:n) 的原始值的共轭
                i__2 = i__ + (i__ + 1) * a_dim1;
                i__3 = i__;
                a[i__2].r = e[i__3], a[i__2].i = 0.f;  // 恢复 A(i,i+1) 的原始值
            } else {
                i__2 = i__;
                taup[i__2].r = 0.f, taup[i__2].i = 0.f;  // 如果 i >= n，将 taup[i] 设置为零向量
            }
/* L10: */
        }
    } else {

/*        Reduce to lower bidiagonal form */

        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {

/*           Generate elementary reflector G(i) to annihilate A(i,i+1:n) */

            i__2 = *n - i__ + 1;
            clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);  // 对 A(i,i+1:n) 进行共轭处理
            i__2 = i__ + i__ * a_dim1;
            alpha.r = a[i__2].r, alpha.i = a[i__2].i;  // 提取 A(i,i) 的值作为 alpha
            i__2 = *n - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
                taup[i__]);  // 生成 Householder 变换 G(i)，存储在 taup[i] 中
            i__2 = i__;
            e[i__2] = alpha.r;  // 将生成的对角元素存入 e 数组中
/* Computing MIN */
/* 计算最小值 */
        i__3 = i__ + 1;  /* 计算 i__ + 1 */
        clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
            taup[i]);  /* 调用 clarfg 函数 */

        i__2 = i__;  /* 设置索引 i__2 为 i__ */
        d__[i__2] = alpha.r;  /* 将 alpha 的实部赋值给 d__[i__2] */

        i__2 = i__ + i__ * a_dim1;  /* 计算索引 i__2 */
        a[i__2].r = 1.f, a[i__2].i = 0.f;  /* 将复数值 (1.f, 0.f) 赋给 a[i__2] */

/*           Apply G(i) to A(i+1:m,i:n) from the right */
/*           将 G(i) 应用于 A(i+1:m,i:n)，从右边开始 */

        if (i__ < *m) {  /* 如果 i__ 小于 *m */

        i__2 = *m - i__;  /* 计算 *m - i__ */
        i__3 = *n - i__ + 1;  /* 计算 *n - i__ + 1 */
        clarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &
            taup[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);  /* 调用 clarf 函数 */

        }

        i__2 = *n - i__ + 1;  /* 计算 *n - i__ + 1 */
        clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);  /* 调用 clacgv 函数 */

        i__2 = i__ + i__ * a_dim1;  /* 计算索引 i__2 */
        i__3 = i__;  /* 设置索引 i__3 为 i__ */
        a[i__2].r = d__[i__3], a[i__2].i = 0.f;  /* 将 d__[i__3] 的值赋给 a[i__2] */

        if (i__ < *m) {  /* 如果 i__ 小于 *m */

/*
                Generate elementary reflector H(i) to annihilate
                A(i+2:m,i)
*/
/* 生成用于消除 A(i+2:m,i) 的基本反射器 H(i) */

        i__2 = i__ + 1 + i__ * a_dim1;  /* 计算索引 i__2 */
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;  /* 设置 alpha 的实部和虚部 */

        i__2 = *m - i__;  /* 计算 *m - i__ */
/* Computing MIN */
        i__3 = i__ + 2;  /* 计算 i__ + 2 */
        clarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1,
             &tauq[i__]);  /* 调用 clarfg 函数 */

        i__2 = i__;  /* 设置索引 i__2 为 i__ */
        e[i__2] = alpha.r;  /* 将 alpha 的实部赋值给 e[i__2] */

        i__2 = i__ + 1 + i__ * a_dim1;  /* 计算索引 i__2 */
        a[i__2].r = 1.f, a[i__2].i = 0.f;  /* 将复数值 (1.f, 0.f) 赋给 a[i__2] */

/*              Apply H(i)' to A(i+1:m,i+1:n) from the left */
/*              将 H(i)' 应用于 A(i+1:m,i+1:n)，从左边开始 */

        i__2 = *m - i__;  /* 计算 *m - i__ */
        i__3 = *n - i__;  /* 计算 *n - i__ */
        r_cnjg(&q__1, &tauq[i__]);  /* 计算 tauq[i__] 的共轭 */
        clarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &
            c__1, &q__1, &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &
            work[1]);  /* 调用 clarf 函数 */

        i__2 = i__ + 1 + i__ * a_dim1;  /* 计算索引 i__2 */
        i__3 = i__;  /* 设置索引 i__3 为 i__ */
        a[i__2].r = e[i__3], a[i__2].i = 0.f;  /* 将 e[i__3] 的值赋给 a[i__2] */

        } else {
        i__2 = i__;  /* 设置索引 i__2 为 i__ */
        tauq[i__2].r = 0.f, tauq[i__2].i = 0.f;  /* 将复数值 (0.f, 0.f) 赋给 tauq[i__2] */
        }
/* L20: */
/* 设置标签 L20 */
    }
    }
    return 0;  /* 返回值 0 */

/*     End of CGEBD2 */
/* CGEBD2 结束 */

} /* cgebd2_ */

/* Subroutine */ int cgebrd_(integer *m, integer *n, singlecomplex *a, integer *lda,
     real *d__, real *e, singlecomplex *tauq, singlecomplex *taup, singlecomplex *work,
    integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    real r__1;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, nb, nx;
    static real ws;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    static integer nbmin, iinfo, minmn;
    extern /* Subroutine */ int cgebd2_(integer *, integer *, singlecomplex *,
        integer *, real *, real *, singlecomplex *, singlecomplex *, singlecomplex *,
        integer *), clabrd_(integer *, integer *, integer *, singlecomplex *,
        integer *, real *, real *, singlecomplex *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *), xerbla_(char *, integer *);
    # 声明一个外部函数 ilaenv_，用于在 Fortran 中调用
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    # 声明静态整型变量 ldwrkx, ldwrky, lwkopt
    static integer ldwrkx, ldwrky, lwkopt;
    # 声明静态逻辑变量 lquery
    static logical lquery;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,
       Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
       November 2006

    Purpose
    =======
    
    CGEBRD reduces a general complex M-by-N matrix A to upper or lower
    bidiagonal form B by a unitary transformation: Q**H * A * P = B.
    
    If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
    
    Arguments
    =========
    
    M       (input) INTEGER
            The number of rows in the matrix A.  M >= 0.
    
    N       (input) INTEGER
            The number of columns in the matrix A.  N >= 0.
    
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
    
    D       (output) REAL array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
    
    E       (output) REAL array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
    
    TAUQ    (output) COMPLEX array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
    
    TAUP    (output) COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
    
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            工作数组 WORK 的长度。LWORK >= max(1,M,N)。
            对于最佳性能，建议 LWORK >= (M+N)*NB，其中 NB 是最佳块大小。

            如果 LWORK = -1，则假定为工作空间查询；函数仅计算 WORK 数组的最佳大小，
            将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会因 LWORK 相关的
            任何错误而发出错误消息。

    INFO    (output) INTEGER
            返回状态信息：
            = 0:  执行成功。
            < 0:  如果 INFO = -i，则第 i 个参数的值非法。

    Further Details
    ===============

    矩阵 Q 和 P 被表示为初等反射器的乘积：

    如果 m >= n，

       Q = H(1) H(2) . . . H(n)  和  P = G(1) G(2) . . . G(n-1)

    每个 H(i) 和 G(i) 的形式为：

       H(i) = I - tauq * v * v'  和  G(i) = I - taup * u * u'

    其中 tauq 和 taup 是复数标量，v 和 u 是复向量；v(1:i-1) = 0, v(i) = 1，
    并且 v(i+1:m) 在退出时存储在 A(i+1:m,i) 中；u(1:i) = 0, u(i+1) = 1，
    并且 u(i+2:n) 在退出时存储在 A(i,i+2:n) 中；tauq 存储在 TAUQ(i) 中，
    taup 存储在 TAUP(i) 中。

    如果 m < n，

       Q = H(1) H(2) . . . H(m-1)  和  P = G(1) G(2) . . . G(m)

    每个 H(i) 和 G(i) 的形式为：

       H(i) = I - tauq * v * v'  和  G(i) = I - taup * u * u'

    其中 tauq 和 taup 是复数标量，v 和 u 是复向量；v(1:i) = 0, v(i+1) = 1，
    并且 v(i+2:m) 在退出时存储在 A(i+2:m,i) 中；u(1:i-1) = 0, u(i) = 1，
    并且 u(i+1:n) 在退出时存储在 A(i,i+1:n) 中；tauq 存储在 TAUQ(i) 中，
    taup 存储在 TAUP(i) 中。

    A 在退出时的内容可以通过以下示例说明：

    当 m = 6 且 n = 5 (m > n) 时：         当 m = 5 且 n = 6 (m < n) 时：

      (  d   e   u1  u1  u1 )                (  d   u1  u1  u1  u1  u1 )
      (  v1  d   e   u2  u2 )                (  e   d   u2  u2  u2  u2 )
      (  v1  v2  d   e   u3 )                (  v1  e   d   u3  u3  u3 )
      (  v1  v2  v3  d   e  )                (  v1  v2  e   d   u4  u4 )
      (  v1  v2  v3  v4  d  )                (  v1  v2  v3  e   d   u5 )
      (  v1  v2  v3  v4  v5 )                (  v1  v2  v3  v4  v5  d  )

    其中 d 和 e 表示 B 的对角线和非对角线元素，vi 表示定义 H(i) 的向量元素，
    ui 表示定义 G(i) 的向量元素。

    =====================================================================


       检测输入参数的有效性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    --work;

    /* Function Body */
    *info = 0;
/* Computing MAX */
    i__1 = 1, i__2 = ilaenv_(&c__1, "CGEBRD", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = max(i__1,i__2);
    lwkopt = (*m + *n) * nb;
    r__1 = (real) lwkopt;
    work[1].r = r__1, work[1].i = 0.f;
    lquery = *lwork == -1;
    if (*m < 0) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*lda < max(1,*m)) {
    *info = -4;
    } else /* if(complicated condition) */ {
/* Computing MAX */
    i__1 = max(1,*m);
    if (*lwork < max(i__1,*n) && ! lquery) {
        *info = -10;
    }
    }
    if (*info < 0) {
    i__1 = -(*info);
    xerbla_("CGEBRD", &i__1);
    return 0;
    } else if (lquery) {
    return 0;
    }

/*     Quick return if possible */

    minmn = min(*m,*n);
    if (minmn == 0) {
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

    ws = (real) max(*m,*n);
    ldwrkx = *m;
    ldwrky = *n;

    if (nb > 1 && nb < minmn) {

/*
          Set the crossover point NX.

   Computing MAX
*/
    i__1 = nb, i__2 = ilaenv_(&c__3, "CGEBRD", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);

/*        Determine when to switch from blocked to unblocked code. */

    if (nx < minmn) {
        ws = (real) ((*m + *n) * nb);
        if ((real) (*lwork) < ws) {

/*
                Not enough work space for the optimal NB, consider using
                a smaller block size.
*/

        nbmin = ilaenv_(&c__2, "CGEBRD", " ", m, n, &c_n1, &c_n1, (
            ftnlen)6, (ftnlen)1);
        if (*lwork >= (*m + *n) * nbmin) {
            nb = *lwork / (*m + *n);
        } else {
            nb = 1;
            nx = minmn;
        }
        }
    }
    } else {
    nx = minmn;
    }

    i__1 = minmn - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {

/*
          Reduce rows and columns i:i+ib-1 to bidiagonal form and return
          the matrices X and Y which are needed to update the unreduced
          part of the matrix
*/

    i__3 = *m - i__ + 1;
    i__4 = *n - i__ + 1;
    clabrd_(&i__3, &i__4, &nb, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[
        i__], &tauq[i__], &taup[i__], &work[1], &ldwrkx, &work[ldwrkx
        * nb + 1], &ldwrky);

/*
          Update the trailing submatrix A(i+ib:m,i+ib:n), using
          an update of the form  A := A - V*Y' - X*U'
*/

    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    q__1.r = -1.f, q__1.i = -0.f;
    cgemm_("No transpose", "Conjugate transpose", &i__3, &i__4, &nb, &
        q__1, &a[i__ + nb + i__ * a_dim1], lda, &work[ldwrkx * nb +
        nb + 1], &ldwrky, &c_b57, &a[i__ + nb + (i__ + nb) * a_dim1],
        lda);
    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    q__1.r = -1.f, q__1.i = -0.f;
    ```
    # 调用名为 "cgemm_" 的函数，执行矩阵乘法操作
    # 第一个参数："No transpose"，指示第一个矩阵不进行转置操作
    # 第二个参数："No transpose"，指示第二个矩阵不进行转置操作
    # 第三个参数：指定矩阵操作的行数，由变量 i__3 指定
    # 第四个参数：指定矩阵操作的列数，由变量 i__4 指定
    # 第五个参数：指定矩阵操作中的列数或者行数（具体由上下文确定），由变量 nb 指定
    # 第六个参数：指定矩阵乘法的系数，由变量 q__1 指定
    # 第七个参数：第一个矩阵的数据起始地址，由变量 work[nb + 1] 指定
    # 第八个参数：第一个矩阵的列数（或行数，具体由上下文确定），由变量 ldwrkx 指定
    # 第九个参数：第二个矩阵的数据起始地址，由变量 a[i__ + (i__ + nb) * a_dim1] 指定
    # 第十个参数：第二个矩阵的列数（或行数，具体由上下文确定），由变量 lda 指定
    # 第十一个参数：矩阵乘法的加法运算的系数，由常量 c_b57 指定
    # 第十二个参数：指定存储结果的矩阵的起始地址，由变量 a[i__ + nb + (i__ + nb) * a_dim1] 指定
    # 第十三个参数：存储结果的矩阵的列数（或行数，具体由上下文确定），由变量 lda 指定
/*        Copy diagonal and off-diagonal elements of B back into A */

/* 检查矩阵维度，确定复制的范围 */
if (*m >= *n) {
    /* 复制 B 的对角线和非对角线元素到 A 中 */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 复制对角线元素 */
        i__4 = j + j * a_dim1;
        i__5 = j;
        a[i__4].r = d__[i__5], a[i__4].i = 0.f;
        /* 复制非对角线元素 */
        i__4 = j + (j + 1) * a_dim1;
        i__5 = j;
        a[i__4].r = e[i__5], a[i__4].i = 0.f;
        /* L10: */
    }
} else {
    /* 复制 B 的对角线和非对角线元素到 A 中 */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 复制对角线元素 */
        i__4 = j + j * a_dim1;
        i__5 = j;
        a[i__4].r = d__[i__5], a[i__4].i = 0.f;
        /* 复制非对角线元素 */
        i__4 = j + 1 + j * a_dim1;
        i__5 = j;
        a[i__4].r = e[i__5], a[i__4].i = 0.f;
        /* L20: */
    }
}
/* L30: */
}

/*     Use unblocked code to reduce the remainder of the matrix */

/* 使用未块化的代码来处理矩阵的剩余部分 */
i__2 = *m - i__ + 1;
i__1 = *n - i__ + 1;
cgebd2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__], &
    tauq[i__], &taup[i__], &work[1], &iinfo);
work[1].r = ws, work[1].i = 0.f;
return 0;

/*     End of CGEBRD */

} /* cgebrd_ */

/* Subroutine */ int cgeev_(char *jobvl, char *jobvr, integer *n, singlecomplex *a,
    integer *lda, singlecomplex *w, singlecomplex *vl, integer *ldvl, singlecomplex *vr,
    integer *ldvr, singlecomplex *work, integer *lwork, real *rwork, integer *
    info)
{
/* 计算矩阵的特征值和（可选）特征向量 */

/* System generated locals */
integer a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
    i__2, i__3;
real r__1, r__2;
singlecomplex q__1, q__2;

/* Local variables */
static integer i__, k, ihi;
static real scl;
static integer ilo;
static real dum[1], eps;
static singlecomplex tmp;
static integer ibal;
static char side[1];
static real anrm;
static integer ierr, itau, iwrk, nout;
extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
    integer *);
extern logical lsame_(char *, char *);
extern doublereal scnrm2_(integer *, singlecomplex *, integer *);
extern /* Subroutine */ int cgebak_(char *, char *, integer *, integer *,
    integer *, real *, integer *, singlecomplex *, integer *, integer *), cgebal_(char *, integer *, singlecomplex *, integer *,
    integer *, integer *, real *, integer *), slabad_(real *,
    real *);
static logical scalea;
extern doublereal clange_(char *, integer *, integer *, singlecomplex *,
    integer *, real *);
static real cscale;
extern /* Subroutine */ int cgehrd_(integer *, integer *, integer *,
    singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer *),
     clascl_(char *, integer *, integer *, real *, real *, integer *,
    integer *, singlecomplex *, integer *, integer *);
extern doublereal slamch_(char *);
extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
    *), clacpy_(char *, integer *, integer *, singlecomplex *, integer *,
    singlecomplex *, integer *), xerbla_(char *, integer *);
    # 外部函数声明，用于调用 ilaenv_ 函数，返回一个整数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    # 静态逻辑数组，长度为 1
    static logical select[1];
    # 静态实数变量，用于存储一个大数值
    static real bignum;
    # 外部函数声明，用于调用 isamax_ 函数，返回一个整数
    extern integer isamax_(integer *, real *, integer *);
    # 外部子程序声明，用于调用 chseqr_ 子程序
    extern /* Subroutine */ int chseqr_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);
    # 外部子程序声明，用于调用 ctrevc_ 子程序
    extern /* Subroutine */ int ctrevc_(char *,
        char *, logical *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, integer *, integer *, singlecomplex *,
        real *, integer *);
    # 外部子程序声明，用于调用 cunghr_ 子程序
    extern /* Subroutine */ int cunghr_(integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        integer *);
    # 静态整数变量，用于存储最小和最大工作空间要求
    static integer minwrk, maxwrk;
    # 静态逻辑变量，指示是否需要计算左特征向量和右特征向量
    static logical wantvl;
    # 静态实数变量，用于存储一个很小的数值
    static real smlnum;
    # 静态整数变量，用于存储Hessenberg矩阵的工作空间大小
    static integer hswork, irwork;
    # 静态逻辑变量，指示是否需要查询工作空间大小
    static logical lquery, wantvr;
"""
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) COMPLEX array, dimension (N)
            W contains the computed eigenvalues.

    VL      (output) COMPLEX array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.

    VR      (output) COMPLEX array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
"""
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK.  LWORK >= max(1,2*N).
    #         For good performance, LWORK must generally be larger.
    # 
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the WORK array, returns
    #         this value as the first entry of the WORK array, and no error
    #         message related to LWORK is issued by XERBLA.
    LWORK   (input) INTEGER

    # RWORK   (workspace) REAL array, dimension (2*N)
    RWORK   (workspace) REAL array, dimension (2*N)

    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value.
    #         > 0:  if INFO = i, the QR algorithm failed to compute all the
    #               eigenvalues, and no eigenvectors have been computed;
    #               elements and i+1:N of W contain eigenvalues which have
    #               converged.
    INFO    (output) INTEGER
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --w;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;
    --rwork;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    wantvl = lsame_(jobvl, "V");
    wantvr = lsame_(jobvr, "V");
    if (! wantvl && ! lsame_(jobvl, "N")) {
        *info = -1;
    } else if (! wantvr && ! lsame_(jobvr, "N")) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
        *info = -8;
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
        *info = -10;
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         CWorkspace refers to complex workspace, and RWorkspace to real
         workspace. NB refers to the optimal block size for the
         immediately following subroutine, as returned by ILAENV.
         HSWORK refers to the workspace preferred by CHSEQR, as
         calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
         the worst case.)
*/

    if (*info == 0) {
        if (*n == 0) {
            minwrk = 1;
            maxwrk = 1;
        } else {
            maxwrk = *n + *n * ilaenv_(&c__1, "CGEHRD", " ", n, &c__1, n, &
                c__0, (ftnlen)6, (ftnlen)1);
            minwrk = *n << 1;
            if (wantvl) {
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + (*n - 1) * ilaenv_(&c__1, "CUNGHR",
                     " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                chseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1], &vl[
                    vl_offset], ldvl, &work[1], &c_n1, info);
            } else if (wantvr) {
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n + (*n - 1) * ilaenv_(&c__1, "CUNGHR",
                     " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                chseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1], &vr[
                    vr_offset], ldvr, &work[1], &c_n1, info);
            } else {
                chseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &w[1], &vr[
                    vr_offset], ldvr, &work[1], &c_n1, info);
            }
            hswork = work[1].r;
            /* Computing MAX */
            i__1 = max(maxwrk,hswork);
            maxwrk = max(i__1,minwrk);
        }
        work[1].r = (real) maxwrk, work[1].i = 0.f;

        if (*lwork < minwrk && ! lquery) {
            *info = -12;
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CGEEV ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        return 0;
    }

/*     Get machine constants */

    eps = slamch_("P");
    smlnum = slamch_("S");
    bignum = 1.f / smlnum;
    slabad_(&smlnum, &bignum);
    # 调用 slabad_ 函数，传入 smlnum 和 bignum 的地址，用于计算并更新它们的值

    smlnum = sqrt(smlnum) / eps;
    # 计算 smlnum 的平方根，并将结果除以 eps，更新 smlnum 的值

    bignum = 1.f / smlnum;
    # 计算 1 除以 smlnum 的值，并将结果赋给 bignum
/*     Scale A if max element outside range [SMLNUM,BIGNUM] */
/*     如果矩阵 A 中的最大元素超出范围 [SMLNUM,BIGNUM]，则对 A 进行缩放 */

    anrm = clange_("M", n, n, &a[a_offset], lda, dum);
    // 计算矩阵 A 的范数，使用 'M' 表示最大范数
    scalea = FALSE_;
    // 初始化标志变量 scalea 为假
    if (anrm > 0.f && anrm < smlnum) {
    // 如果 A 的范数大于 0 且小于 smlnum
        scalea = TRUE_;
        // 设置 scalea 为真
        cscale = smlnum;
        // 将缩放因子 cscale 设置为 smlnum
    } else if (anrm > bignum) {
    // 否则如果 A 的范数大于 bignum
        scalea = TRUE_;
        // 设置 scalea 为真
        cscale = bignum;
        // 将缩放因子 cscale 设置为 bignum
    }
    if (scalea) {
    // 如果需要进行缩放
        clascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
            ierr);
        // 调用 clascl 函数进行矩阵缩放，将 A 缩放到指定的范围内
    }

/*
       Balance the matrix
       (CWorkspace: none)
       (RWorkspace: need N)
*/
/*     对矩阵进行平衡处理 */

    ibal = 1;
    // 设置平衡处理的参数 ibal 为 1
    cgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &rwork[ibal], &ierr);
    // 调用 cgebal 函数对矩阵进行平衡处理，'B' 表示平衡整个矩阵

/*
       Reduce to upper Hessenberg form
       (CWorkspace: need 2*N, prefer N+N*NB)
       (RWorkspace: none)
*/
/*     将矩阵约化为上 Hessenberg 形式 */

    itau = 1;
    // 设置用于存储 Householder 变换信息的工作空间的起始位置 itau 为 1
    iwrk = itau + *n;
    // 计算用于工作空间的结束位置 iwrk
    i__1 = *lwork - iwrk + 1;
    // 计算工作空间的剩余可用大小
    cgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
         &ierr);
    // 调用 cgehrd 函数将矩阵约化为上 Hessenberg 形式

    if (wantvl) {

/*
          Want left eigenvectors
          Copy Householder vectors to VL
*/
/*         需要计算左特征向量，将 Householder 向量复制到 VL */

    *(unsigned char *)side = 'L';
    // 将字符 'L' 赋值给 side，表示计算左特征向量
    clacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl)
        ;
    // 调用 clacpy 函数将矩阵 A 的左部分复制到 VL

/*
          Generate unitary matrix in VL
          (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
          (RWorkspace: none)
*/
/*         在 VL 中生成单位阵 */

    i__1 = *lwork - iwrk + 1;
    // 计算剩余工作空间的大小
    cunghr_(n, &ilo, &ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk],
         &i__1, &ierr);
    // 调用 cunghr 函数生成单位阵在 VL 中

/*
          Perform QR iteration, accumulating Schur vectors in VL
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/
/*         执行 QR 迭代，将 Schur 向量累积到 VL 中 */

    iwrk = itau;
    // 设置工作空间的起始位置为 itau
    i__1 = *lwork - iwrk + 1;
    // 计算剩余工作空间的大小
    chseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vl[
        vl_offset], ldvl, &work[iwrk], &i__1, info);
    // 调用 chseqr 函数执行 QR 迭代，累积 Schur 向量到 VL 中

    if (wantvr) {

/*
             Want left and right eigenvectors
             Copy Schur vectors to VR
*/
/*           需要计算左右特征向量，将 Schur 向量复制到 VR */

        *(unsigned char *)side = 'B';
        // 将字符 'B' 赋值给 side，表示计算左右特征向量
        clacpy_("F", n, n, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr);
        // 调用 clacpy 函数将 VL 中的矩阵复制到 VR 中
    }

    } else if (wantvr) {

/*
          Want right eigenvectors
          Copy Householder vectors to VR
*/
/*         需要计算右特征向量，将 Householder 向量复制到 VR */

    *(unsigned char *)side = 'R';
    // 将字符 'R' 赋值给 side，表示计算右特征向量
    clacpy_("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr)
        ;
    // 调用 clacpy 函数将矩阵 A 的左部分复制到 VR

/*
          Generate unitary matrix in VR
          (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
          (RWorkspace: none)
*/
/*         在 VR 中生成单位阵 */

    i__1 = *lwork - iwrk + 1;
    // 计算剩余工作空间的大小
    cunghr_(n, &ilo, &ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk],
         &i__1, &ierr);
    // 调用 cunghr 函数生成单位阵在 VR 中

/*
          Perform QR iteration, accumulating Schur vectors in VR
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/
/*         执行 QR 迭代，将 Schur 向量累积到 VR 中 */

    iwrk = itau;
    // 设置工作空间的起始位置为 itau
    i__1 = *lwork - iwrk + 1;
    // 计算剩余工作空间的大小
    chseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vr[
        vr_offset], ldvr, &work[iwrk], &i__1, info);

    } else {

/*
          Compute eigenvalues only
          (CWorkspace: need 1, prefer HSWORK (see comments) )
          (RWorkspace: none)
*/
/*         仅计算特征值 */

    iwrk = itau;
    // 设置工作空间的起始位置为 itau
    i__1 = *lwork - iwrk + 1;
    // 计算剩余工作空间的大小
    chseqr_("E", "N", n, &ilo, &ihi, &a[a_offset], lda, &w[1], &vr[
        vr_offset], ldvr, &work[iwrk], &i__1, info);
    # 调用名为 chseqr_ 的外部函数，执行特定的 QR 算法操作，用于计算特征值和（可选）特征向量
    # 参数解析：
    # "E": 表示计算所有特征值
    # "N": 表示不计算特征向量
    # n: 矩阵的阶数
    # &ilo, &ihi: 整数参数，用于指定操作的矩阵的子矩阵范围
    # &a[a_offset]: 矩阵 A 的数据，可能通过偏移量 a_offset 访问
    # lda: 矩阵 A 的第一个维度大小
    # &w[1]: 存储计算得到的特征值数组的起始位置
    # &vr[vr_offset]: 存储计算得到的右特征向量的起始位置
    # ldvr: 右特征向量矩阵的第一个维度大小
    # &work[iwrk]: 工作数组的起始位置，用于算法执行中的临时存储
    # &i__1: 用于控制函数内部计算过程的整数参数
    # info: 用于返回函数执行状态的整数指针
    /* 如果 CHSEQR 返回的 INFO > 0，则直接跳转到 L50 */
    if (*info > 0) {
        goto L50;
    }

    /* 如果需要计算左特征向量或右特征向量 */
    if (wantvl || wantvr) {

/*
          计算左和/或右特征向量
          (CWorkspace: 需要 2*N)
          (RWorkspace: 需要 2*N)
*/

        irwork = ibal + *n;
        ctrevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
                &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &rwork[irwork],
                &ierr);
    }

    /* 如果需要计算左特征向量 */
    if (wantvl) {

/*
          撤销左特征向量的平衡
          (CWorkspace: 无需额外空间)
          (RWorkspace: 需要 N)
*/

        cgebak_("B", "L", n, &ilo, &ihi, &rwork[ibal], n, &vl[vl_offset],
                ldvl, &ierr);

/*        对左特征向量进行归一化并使最大分量为实数 */

        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scl = 1.f / scnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
            csscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
            i__2 = *n;
            for (k = 1; k <= i__2; ++k) {
                i__3 = k + i__ * vl_dim1;
/* Computing 2nd power */
                r__1 = vl[i__3].r;
/* Computing 2nd power */
                r__2 = r_imag(&vl[k + i__ * vl_dim1]);
                rwork[irwork + k - 1] = r__1 * r__1 + r__2 * r__2;
/* L10: */
            }
            k = isamax_(n, &rwork[irwork], &c__1);
            r_cnjg(&q__2, &vl[k + i__ * vl_dim1]);
            r__1 = sqrt(rwork[irwork + k - 1]);
            q__1.r = q__2.r / r__1, q__1.i = q__2.i / r__1;
            tmp.r = q__1.r, tmp.i = q__1.i;
            cscal_(n, &tmp, &vl[i__ * vl_dim1 + 1], &c__1);
            i__2 = k + i__ * vl_dim1;
            i__3 = k + i__ * vl_dim1;
            r__1 = vl[i__3].r;
            q__1.r = r__1, q__1.i = 0.f;
            vl[i__2].r = q__1.r, vl[i__2].i = q__1.i;
/* L20: */
        }
    }

    /* 如果需要计算右特征向量 */
    if (wantvr) {

/*
          撤销右特征向量的平衡
          (CWorkspace: 无需额外空间)
          (RWorkspace: 需要 N)
*/

        cgebak_("B", "R", n, &ilo, &ihi, &rwork[ibal], n, &vr[vr_offset],
                ldvr, &ierr);

/*        对右特征向量进行归一化并使最大分量为实数 */

        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scl = 1.f / scnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
            csscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
            i__2 = *n;
            for (k = 1; k <= i__2; ++k) {
                i__3 = k + i__ * vr_dim1;
/* Computing 2nd power */
                r__1 = vr[i__3].r;
/* Computing 2nd power */
                r__2 = r_imag(&vr[k + i__ * vr_dim1]);
                rwork[irwork + k - 1] = r__1 * r__1 + r__2 * r__2;
/* L30: */
            }
            k = isamax_(n, &rwork[irwork], &c__1);
            r_cnjg(&q__2, &vr[k + i__ * vr_dim1]);
            r__1 = sqrt(rwork[irwork + k - 1]);
            q__1.r = q__2.r / r__1, q__1.i = q__2.i / r__1;
            tmp.r = q__1.r, tmp.i = q__1.i;
            cscal_(n, &tmp, &vr[i__ * vr_dim1 + 1], &c__1);
            i__2 = k + i__ * vr_dim1;
            i__3 = k + i__ * vr_dim1;
            r__1 = vr[i__3].r;
            q__1.r = r__1, q__1.i = 0.f;
            vr[i__2].r = q__1.r, vr[i__2].i = q__1.i;
/* L40: */
        }
    }
/*     Undo scaling if necessary */

L50:
    // 如果需要，取消缩放
    if (scalea) {
        // 计算要处理的元素个数
        i__1 = *n - *info;
        // 计算最大值
        i__3 = *n - *info;
        i__2 = max(i__3,1);
        // 根据缩放参数 cscale 和 anrm 取消缩放矩阵 w[*info + 1]
        clascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &w[*info + 1]
            , &i__2, &ierr);
        // 如果 info > 0，对 w[1] 到 w[ilo-1] 之间的元素取消缩放
        if (*info > 0) {
            i__1 = ilo - 1;
            clascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &w[1], n,
                 &ierr);
        }
    }

    // 将工作区域的第一个元素设置为 maxwrk
    work[1].r = (real) maxwrk, work[1].i = 0.f;
    // 返回正常退出状态码
    return 0;

/*     End of CGEEV */

} /* cgeev_ */

/* Subroutine */ int cgehd2_(integer *n, integer *ilo, integer *ihi, singlecomplex *
    a, integer *lda, singlecomplex *tau, singlecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    singlecomplex q__1;

    /* Local variables */
    static integer i__;
    static singlecomplex alpha;
    extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
        , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
        clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
        xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CGEHD2 reduces a complex general matrix A to upper Hessenberg form H
    by a unitary similarity transformation:  Q' * A * Q = H .

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to CGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= max(1,N).

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the n by n general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).

    WORK    (workspace) COMPLEX array, dimension (N)

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

*/
    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:

    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    =====================================================================


       Test the input parameters


注释：
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    // 检查参数 *n 的有效性
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) { // 检查参数 *ilo 的有效性
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) { // 检查参数 *ihi 的有效性
        *info = -3;
    } else if (*lda < max(1,*n)) { // 检查参数 *lda 的有效性
        *info = -5;
    }
    // 如果有无效参数，调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CGEHD2", &i__1);
        return 0;
    }

    // 循环处理从 *ilo 到 *ihi-1 的每一列
    i__1 = *ihi - 1;
    for (i__ = *ilo; i__ <= i__1; ++i__) {

/*        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) */

        // 计算第 i 列的第 i+1 行的元素 alpha，用于生成反射向量
        i__2 = i__ + 1 + i__ * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
        // 计算生成的反射向量 H(i)，并将结果保存在 A 中
        i__2 = *ihi - i__;
        /* Computing MIN */
        i__3 = i__ + 2;
        clarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1, &tau[
            i__]);
        i__2 = i__ + 1 + i__ * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;

/*        Apply H(i) to A(1:ihi,i+1:ihi) from the right */

        // 应用反射向量 H(i) 到 A 的右侧区域
        i__2 = *ihi - i__;
        clarf_("Right", ihi, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &a[(i__ + 1) * a_dim1 + 1], lda, &work[1]);

/*        Apply H(i)' to A(i+1:ihi,i+1:n) from the left */

        // 应用反射向量 H(i)' 到 A 的左侧区域
        i__2 = *ihi - i__;
        i__3 = *n - i__;
        r_cnjg(&q__1, &tau[i__]);
        clarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &q__1,
             &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);

        // 恢复 A 中的原始值
        i__2 = i__ + 1 + i__ * a_dim1;
        a[i__2].r = alpha.r, a[i__2].i = alpha.i;
/* L10: */
    }

    return 0;

/*     End of CGEHD2 */

} /* cgehd2_ */

/* Subroutine */ int cgehrd_(integer *n, integer *ilo, integer *ihi, singlecomplex *
    a, integer *lda, singlecomplex *tau, singlecomplex *work, integer *lwork, integer
    *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j;
    static singlecomplex t[4160]    /* was [65][64] */;
    static integer ib;
    static singlecomplex ei;
    static integer nb, nh, nx, iws;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int ctrmm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), caxpy_(integer *,
        singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *);

外部函数声明：声明了两个外部的 Fortran 子程序 `ctrmm_` 和 `caxpy_`，这些子程序通常由其他库或模块提供实现。


        cgehd2_(
        integer *, integer *, integer *, singlecomplex *, integer *, singlecomplex *,
        singlecomplex *, integer *), clahr2_(integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarfb_(char *, char *, char *, char *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *);

继续声明了四个额外的外部 Fortran 子程序 `cgehd2_`, `clahr2_`, 和 `clarfb_`，这些子程序可能用于执行特定的线性代数或数值计算操作。


    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

声明了一个外部函数 `ilaenv_`，它通常用于查询环境参数的函数，可以返回与机器和库实现相关的配置信息。


    static integer ldwork, lwkopt;

声明了两个静态（即局部静态）整型变量 `ldwork` 和 `lwkopt`，这些变量在程序运行期间保持其值不变。


    static logical lquery;

声明了一个静态逻辑型（布尔型）变量 `lquery`，用于表示一个查询的状态或结果的逻辑值。
"""
    -- LAPACK routine (version 3.2.1)                                  --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --


    Purpose
    =======
    
    CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
    an unitary similarity transformation:  Q' * A * Q = H .
    
    Arguments
    =========
    
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    
    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to CGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
    
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    
    TAU     (output) COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
    
    WORK    (workspace/output) COMPLEX array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
    
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
    
    Further Details
    ===============
    
    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors
    
       Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    
    Each H(i) has the form
    
       H(i) = I - tau * v * v'
    
    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).
    
    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:
"""

# This block contains the header comments and purpose description of the CGEHRD routine from LAPACK.
# It describes the function's purpose, arguments, and further details about the matrix transformations performed.
    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This file is a slight modification of LAPACK-3.0's DGEHRD
    subroutine incorporating improvements proposed by Quintana-Orti and
    Van de Geijn (2006). (See DLAHR2.)

    =====================================================================


       Test the input parameters


注释：

# 输入时的矩阵状态和输出时的状态对比图示：
#
# 在进入函数时，矩阵A包含如上形式的元素；在退出函数时，形成的上Hessenberg矩阵H如上所示。
#
# 这里，a代表原始矩阵A中的元素，h代表上Hessenberg矩阵H中的修改后的元素，vi代表定义H(i)的向量中的元素。
#
# 这个文件是对LAPACK-3.0中DGEHRD子程序的轻微修改，这些修改包含了Quintana-Orti和Van de Geijn（2006年）提出的改进。（见DLAHR2。）
#
# =====================================================================
#
# 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

    /* Computing MIN */
    i__1 = 64, i__2 = ilaenv_(&c__1, "CGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);  // 计算 nb，取 i__1 和 i__2 的最小值作为 nb 的值
    lwkopt = *n * nb;  // 计算工作空间的最优大小
    work[1].r = (real) lwkopt, work[1].i = 0.f;  // 设置工作数组的第一个元素为计算得到的工作空间大小，虚部为 0
    lquery = *lwork == -1;  // 判断是否为查询模式

    if (*n < 0) {  // 检查输入参数的合法性
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;
    }

    if (*info != 0) {  // 若有错误信息，则调用错误处理函数并返回
        i__1 = -(*info);
        xerbla_("CGEHRD", &i__1);
        return 0;
    } else if (lquery) {  // 若为查询模式，则直接返回
        return 0;
    }

/*     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero */

    i__1 = *ilo - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        tau[i__2].r = 0.f, tau[i__2].i = 0.f;  // 将 tau 的前 *ilo-1 个元素置为零
    }

    i__1 = *n - 1;
    for (i__ = max(1,*ihi); i__ <= i__1; ++i__) {
        i__2 = i__;
        tau[i__2].r = 0.f, tau[i__2].i = 0.f;  // 将 tau 的后 *n-1 个元素置为零
    }

/*     Quick return if possible */

    nh = *ihi - *ilo + 1;  // 计算 nh
    if (nh <= 1) {  // 如果 nh <= 1，直接返回
        work[1].r = 1.f, work[1].i = 0.f;  // 设置 work 的第一个元素为 1，虚部为 0
        return 0;
    }

/*
       Determine the block size

   Computing MIN
*/
    i__1 = 64, i__2 = ilaenv_(&c__1, "CGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);  // 再次计算 nb，取 i__1 和 i__2 的最小值作为 nb 的值
    nbmin = 2;  // 设置最小的 block size
    iws = 1;  // 初始化工作空间大小为 1

    if (nb > 1 && nb < nh) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code)

   Computing MAX
*/
        i__1 = nb, i__2 = ilaenv_(&c__3, "CGEHRD", " ", n, ilo, ihi, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);  // 计算 nx

        if (nx < nh) {

/*           Determine if workspace is large enough for blocked code */

            iws = *n * nb;  // 计算要求的工作空间大小
            if (*lwork < iws) {  // 若当前工作空间小于需求，则进一步调整 block size
/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code

   Computing MAX
*/
                i__1 = 2, i__2 = ilaenv_(&c__2, "CGEHRD", " ", n, ilo, ihi, &
                    c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);  // 计算最小的 block size
                if (*lwork >= *n * nbmin) {
                    nb = *lwork / *n;  // 根据当前工作空间大小调整 block size
                } else {
                    nb = 1;  // 若仍然不足，则强制使用 unblocked code
                }
            }
        }
    }

    ldwork = *n;  // 设置 ldwork 为 *n

    if (nb < nbmin || nb >= nh) {

/*        Use unblocked code below */

        i__ = *ilo;  // 设置循环初始值为 *ilo

    } else {

/*        Use blocked code */

        i__1 = *ihi - 1 - nx;  // 计算循环终止值
        i__2 = nb;  // 设置步长为 nb
        for (i__ = *ilo; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
            i__3 = nb, i__4 = *ihi - i__;  // 计算当前 block 的大小
            ib = min(i__3,i__4);  // 取 i__3 和 i__4 的最小值作为当前 block 的大小
/*
             Reduce columns i:i+ib-1 to Hessenberg form, returning the
             matrices V and T of the block reflector H = I - V*T*V'
             which performs the reduction, and also the matrix Y = A*V*T
*/
clahr2_(ihi, &i__, &ib, &a[i__ * a_dim1 + 1], lda, &tau[i__], t, &
    c__65, &work[1], &ldwork);

/*
             Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
             right, computing  A := A - Y * V'. V(i+ib,ib-1) must be set
             to 1
*/
i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
ei.r = a[i__3].r, ei.i = a[i__3].i;
i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
a[i__3].r = 1.f, a[i__3].i = 0.f;
i__3 = *ihi - i__ - ib + 1;
q__1.r = -1.f, q__1.i = -0.f;
cgemm_("No transpose", "Conjugate transpose", ihi, &i__3, &ib, &
    q__1, &work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda,
     &c_b57, &a[(i__ + ib) * a_dim1 + 1], lda);
i__3 = i__ + ib + (i__ + ib - 1) * a_dim1;
a[i__3].r = ei.r, a[i__3].i = ei.i;

/*
             Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
             right
*/
i__3 = ib - 1;
ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &i__, &
    i__3, &c_b57, &a[i__ + 1 + i__ * a_dim1], lda, &work[1], &
    ldwork);
i__3 = ib - 2;
for (j = 0; j <= i__3; ++j) {
q__1.r = -1.f, q__1.i = -0.f;
caxpy_(&i__, &q__1, &work[ldwork * j + 1], &c__1, &a[(i__ + j
    + 1) * a_dim1 + 1], &c__1);
/* L30: */
}

/*
             Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
             left
*/
i__3 = *ihi - i__;
i__4 = *n - i__ - ib + 1;
clarfb_("Left", "Conjugate transpose", "Forward", "Columnwise", &
    i__3, &i__4, &ib, &a[i__ + 1 + i__ * a_dim1], lda, t, &
    c__65, &a[i__ + 1 + (i__ + ib) * a_dim1], lda, &work[1], &
    ldwork);
/* L40: */
}

}

/*     Use unblocked code to reduce the rest of the matrix */

cgehd2_(n, &i__, ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
work[1].r = (real) iws, work[1].i = 0.f;

return 0;

/*     End of CGEHRD */

} /* cgehrd_ */

/* Subroutine */ int cgelq2_(integer *m, integer *n, singlecomplex *a, integer *lda,
 singlecomplex *tau, singlecomplex *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
static integer i__, k;
static singlecomplex alpha;
extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
    , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
    clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
    clacgv_(integer *, singlecomplex *, integer *), xerbla_(char *, integer
    *);
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


# LAPACK是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，版本为2010年6月。



    Purpose
    =======


# 功能



    CGELQ2 computes an LQ factorization of a complex m by n matrix A:
    A = L * Q.


# CGELQ2计算复数矩阵A的LQ分解：
# A = L * Q。



    Arguments
    =========


# 参数



    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.


# M       (输入) 整数
#         矩阵A的行数。要求 M >= 0。



    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.


# N       (输入) 整数
#         矩阵A的列数。要求 N >= 0。



    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m <= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).


# A       (输入/输出) 复数数组，维度为 (LDA,N)
#         输入时，是一个 m 行 n 列的矩阵 A。
#         输出时，数组的对角线及其以下的元素包含了 m 行 min(m,n) 列的下梯形矩阵 L
#         （如果 m <= n，则 L 是下三角矩阵）；对角线以上的元素和数组 TAU 一起表示了单位矩阵 Q，
#         它是一系列初等反射的乘积（详见 Further Details）。



    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).


# LDA     (输入) 整数
#         数组 A 的主维度。要求 LDA >= max(1,M)。



    TAU     (output) COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).


# TAU     (输出) 复数数组，维度为 (min(M,N))
#         初等反射的标量因子（详见 Further Details）。



    WORK    (workspace) COMPLEX array, dimension (M)


# WORK    (工作空间) 复数数组，维度为 (M)



    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value


# INFO    (输出) 整数
#         = 0：成功退出
#         < 0：如果 INFO = -i，则第 i 个参数的值非法



    Further Details
    ===============


# 更多细节



    The matrix Q is represented as a product of elementary reflectors

       Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).


# 矩阵 Q 被表示为一系列初等反射的乘积

       Q = H(k)' . . . H(2)' H(1)', 其中 k = min(m,n)。



    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
    A(i,i+1:n), and tau in TAU(i).


# 每个 H(i) 的形式为

       H(i) = I - tau * v * v'

    其中 tau 是一个复数标量，v 是一个复向量，满足
    v(1:i-1) = 0 且 v(i) = 1；conjg(v(i+1:n)) 存储在退出时的 A(i,i+1:n) 中，
    而 tau 存储在 TAU(i) 中。



    =====================================================================


# =====================================================================



       Test the input arguments


# 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*lda < max(1,*m)) {
    *info = -4;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("CGELQ2", &i__1);
    return 0;
    }

    k = min(*m,*n);

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i,i+1:n) */

    i__2 = *n - i__ + 1;
    clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
    i__2 = i__ + i__ * a_dim1;
    alpha.r = a[i__2].r, alpha.i = a[i__2].i;
    i__2 = *n - i__ + 1;
/* Computing MIN */
    i__3 = i__ + 1;
    clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &tau[i__]
        );
    if (i__ < *m) {

/*           Apply H(i) to A(i+1:m,i:n) from the right */

        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;
        i__2 = *m - i__;
        i__3 = *n - i__ + 1;
        clarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[
            i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
    }
    i__2 = i__ + i__ * a_dim1;
    a[i__2].r = alpha.r, a[i__2].i = alpha.i;
    i__2 = *n - i__ + 1;
    clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
/* L10: */
    }
    return 0;

/*     End of CGELQ2 */

} /* cgelq2_ */

/* Subroutine */ int cgelqf_(integer *m, integer *n, singlecomplex *a, integer *lda,
     singlecomplex *tau, singlecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int cgelq2_(integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *), clarfb_(char *, char
        *, char *, char *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarft_(char *, char *
        , integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CGELQF computes an LQ factorization of a complex M-by-N matrix A:
    A = L * Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.


    lda     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m <= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    TAU     (output) COMPLEX array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,M).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.


    Further Details
    ===============

    The total number of blocks is IB, where IB is the local
    block size. If A is greater than the local
    block size, then it will be split into NB blocks,
    where NB is the local block size.

    =====================================================================

    */
    ! Test the input arguments
    ! 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    nb = ilaenv_(&c__1, "CGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 调用 ilaenv 函数确定最优的块大小 nb
    lwkopt = *m * nb;  // 计算所需的工作空间大小
    work[1].r = (real) lwkopt, work[1].i = 0.f;  // 设置工作数组中第一个元素的大小
    lquery = *lwork == -1;  // 判断是否进行查询工作空间大小的操作
    if (*m < 0) {  // 如果 m 小于 0，设置错误码并返回
    *info = -1;
    } else if (*n < 0) {  // 如果 n 小于 0，设置错误码并返回
    *info = -2;
    } else if (*lda < max(1,*m)) {  // 如果 lda 小于 1 和 m 中较大的值，设置错误码并返回
    *info = -4;
    } else if (*lwork < max(1,*m) && ! lquery) {  // 如果 lwork 小于 1 和 m 中较大的值，并且不是查询模式，设置错误码并返回
    *info = -7;
    }
    if (*info != 0) {  // 如果 info 不为 0，调用错误处理函数并返回
    i__1 = -(*info);
    xerbla_("CGELQF", &i__1);
    return 0;
    } else if (lquery) {  // 如果是查询模式，直接返回
    return 0;
    }

/*     Quick return if possible */

    k = min(*m,*n);  // 计算 k 的最小值
    if (k == 0) {  // 如果 k 为 0，设置工作数组中第一个元素的值并返回
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

    nbmin = 2;  // 设置最小的块大小为 2
    nx = 0;  // 初始化 nx 为 0
    iws = *m;  // 设置工作空间大小为 m
    if (nb > 1 && nb < k) {  // 如果块大小大于 1 并且小于 k

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "CGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算 nx 的值
    if (nx < k) {  // 如果 nx 小于 k

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *m;  // 设置 ldwork 为 m
        iws = ldwork * nb;  // 计算工作空间大小
        if (*lwork < iws) {  // 如果 lwork 小于所需的工作空间大小

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        nb = *lwork / ldwork;  // 重新计算可用的块大小
/* Computing MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "CGELQF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);  // 计算最小块大小
        }
    }
    }

    if (nb >= nbmin && nb < k && nx < k) {  // 如果块大小大于等于最小块大小并且小于 k，并且 nx 小于 k

/*        Use blocked code initially */

    i__1 = k - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {  // 循环使用块算法
/* Computing MIN */
        i__3 = k - i__ + 1;
        ib = min(i__3,nb);  // 计算当前块的大小

/*
             Compute the LQ factorization of the current block
             A(i:i+ib-1,i:n)
*/

        i__3 = *n - i__ + 1;
        cgelq2_(&ib, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);  // 调用 cgelq2 函数进行 LQ 分解
        if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__3 = *n - i__ + 1;
        clarft_("Forward", "Rowwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);  // 计算块反射器的三角因子

/*              Apply H to A(i+ib:m,i:n) from the right */

        i__3 = *m - i__ - ib + 1;
        i__4 = *n - i__ + 1;
        clarfb_("Right", "No transpose", "Forward", "Rowwise", &i__3,
            &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
            ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib +
            1], &ldwork);  // 应用块反射器到 A 的右侧部分
        }
/* L10: */
    }
    } else {
    i__ = 1;  // 设置 i 的初始值为 1
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {  // 如果 i 小于等于 k

    i__2 = *m - i__ + 1;
    i__1 = *n - i__ + 1;
    # 调用 LAPACK 中的 CGELQ2 子程序，执行低阶化函数 LQ 分解
    cgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &iinfo);
    # 结束循环，继续处理下一个循环迭代
    
    }
    
    # 将工作数组中的第一个元素设置为整数 iws 的实部，虚部为 0
    work[1].r = (real) iws, work[1].i = 0.f;
    # 返回值 0，表示函数执行成功
    return 0;
/*     End of CGELQF */

} /* cgelqf_ */

/* Subroutine */ int cgelsd_(integer *m, integer *n, integer *nrhs, singlecomplex *
    a, integer *lda, singlecomplex *b, integer *ldb, real *s, real *rcond,
    integer *rank, singlecomplex *work, integer *lwork, real *rwork, integer *
    iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer ie, il, mm;
    static real eps, anrm, bnrm;
    static integer itau, nlvl, iascl, ibscl;
    static real sfmin;
    static integer minmn, maxmn, itaup, itauq, mnthr, nwork;
    extern /* Subroutine */ int cgebrd_(integer *, integer *, singlecomplex *,
        integer *, real *, real *, singlecomplex *, singlecomplex *, singlecomplex *,
        integer *, integer *), slabad_(real *, real *);
    extern doublereal clange_(char *, integer *, integer *, singlecomplex *,
        integer *, real *);
    extern /* Subroutine */ int cgelqf_(integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *, integer *), clalsd_(
        char *, integer *, integer *, integer *, real *, real *, singlecomplex *
        , integer *, real *, integer *, singlecomplex *, real *, integer *,
        integer *);
    extern /* Subroutine */ int clascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, singlecomplex *, integer *, integer *), cgeqrf_(integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *, integer *);
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex
        *, integer *, singlecomplex *, integer *), claset_(char *,
        integer *, integer *, singlecomplex *, singlecomplex *, singlecomplex *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static real bignum;
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *), cunmbr_(char *, char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *), slaset_(
        char *, integer *, integer *, real *, real *, real *, integer *), cunmlq_(char *, char *, integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int cunmqr_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);
    static integer liwork, minwrk, maxwrk;
    static real smlnum;
    static integer lrwork;
    static logical lquery;



注释：
    # 定义静态整数变量 nrwork 和 smlsiz
    static integer nrwork, smlsiz;
"""
-- LAPACK driver routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

CGELSD computes the minimum-norm solution to a real linear least
squares problem:
    minimize 2-norm(| b - A*x |)
using the singular value decomposition (SVD) of A. A is an M-by-N
matrix which may be rank-deficient.

Several right hand side vectors b and solution vectors x can be
handled in a single call; they are stored as the columns of the
M-by-NRHS right hand side matrix B and the N-by-NRHS solution
matrix X.

The problem is solved in three steps:
(1) Reduce the coefficient matrix A to bidiagonal form with
    Householder transformations, reducing the original problem
    into a "bidiagonal least squares problem" (BLS)
(2) Solve the BLS using a divide and conquer approach.
(3) Apply back all the Householder transformations to solve
    the original least squares problem.

The effective rank of A is determined by treating as zero those
singular values which are less than RCOND times the largest singular
value.

The divide and conquer algorithm makes very mild assumptions about
floating point arithmetic. It will work on machines with a guard
digit in add/subtract, or on those binary machines without guard
digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
Cray-2. It could conceivably fail on hexadecimal or decimal machines
without guard digits, but we know of none.

Arguments
=========

M       (input) INTEGER
        The number of rows of the matrix A. M >= 0.

N       (input) INTEGER
        The number of columns of the matrix A. N >= 0.

NRHS    (input) INTEGER
        The number of right hand sides, i.e., the number of columns
        of the matrices B and X. NRHS >= 0.

A       (input/output) COMPLEX array, dimension (LDA,N)
        On entry, the M-by-N matrix A.
        On exit, A has been destroyed.

LDA     (input) INTEGER
        The leading dimension of the array A. LDA >= max(1,M).

B       (input/output) COMPLEX array, dimension (LDB,NRHS)
        On entry, the M-by-NRHS right hand side matrix B.
        On exit, B is overwritten by the N-by-NRHS solution matrix X.
        If m >= n and RANK = n, the residual sum-of-squares for
        the solution in the i-th column is given by the sum of
        squares of the modulus of elements n+1:m in that column.

LDB     (input) INTEGER
        The leading dimension of the array B.  LDB >= max(1,M,N).

S       (output) REAL array, dimension (min(M,N))
        The singular values of A in decreasing order.
        The condition number of A in the 2-norm = S(1)/S(min(m,n)).
"""
    # RCOND   (input) REAL
    #         RCOND is used to determine the effective rank of A.
    #         Singular values S(i) <= RCOND*S(1) are treated as zero.
    #         If RCOND < 0, machine precision is used instead.
    
    # RANK    (output) INTEGER
    #         The effective rank of A, i.e., the number of singular values
    #         which are greater than RCOND*S(1).
    
    # WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
    #         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK. LWORK must be at least 1.
    #         The exact minimum amount of workspace needed depends on M,
    #         N and NRHS. As long as LWORK is at least
    #             2 * N + N * NRHS
    #         if M is greater than or equal to N or
    #             2 * M + M * NRHS
    #         if M is less than N, the code will execute correctly.
    #         For good performance, LWORK should generally be larger.
    #
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the array WORK and the
    #         minimum sizes of the arrays RWORK and IWORK, and returns
    #         these values as the first entries of the WORK, RWORK and
    #         IWORK arrays, and no error message related to LWORK is issued
    #         by XERBLA.
    
    # RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))
    #         LRWORK >=
    #            10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
    #            MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )
    #         if M is greater than or equal to N or
    #            10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
    #            MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )
    #         if M is less than N, the code will execute correctly.
    #         SMLSIZ is returned by ILAENV and is equal to the maximum
    #         size of the subproblems at the bottom of the computation
    #         tree (usually about 25), and
    #            NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
    #         On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK.
    
    # IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
    #         LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),
    #         where MINMN = MIN( M,N ).
    #         On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.
    
    # INFO    (output) INTEGER
    #         = 0: successful exit
    #         < 0: if INFO = -i, the i-th argument had an illegal value.
    #         > 0:  the algorithm for computing the SVD failed to converge;
    #               if INFO = i, i off-diagonal elements of an intermediate
    #               bidiagonal form did not converge to zero.
    
    # Further Details
    # ===============
    # Based on contributions by
    #    Ming Gu and Ren-Cang Li, Computer Science Division, University of
    #      California at Berkeley, USA
    #    Osni Marques, LBNL/NERSC, USA
    =====================================================================
    # 进行输入参数的测试

       if __name__ == '__main__':
    # 如果当前脚本作为主程序运行
           import sys
    # 导入 sys 模块，用于访问系统相关的功能
           if len(sys.argv) != 2:
    # 检查命令行参数的数量是否为 2，即除了脚本名之外还有一个参数
               print("Usage: python script.py <input>")
    # 如果参数数量不对，打印使用说明
               sys.exit(1)
    # 退出程序，返回状态码 1 表示错误

           input_file = sys.argv[1]
    # 获取命令行参数中的输入文件名

           # Call the main function.
    # 调用主函数（假设的主函数）

           result = main(input_file)
    # 调用主函数处理输入文件，并获取返回结果

           print("Result:", result)
    # 打印处理结果
    ```py
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --s;
    --work;
    --rwork;
    --iwork;

    /* Function Body */
    *info = 0;
    minmn = min(*m,*n);
    maxmn = max(*m,*n);
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*nrhs < 0) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*ldb < max(1,maxmn)) {
        *info = -7;
    }

/*
       Compute workspace.
       (Note: Comments in the code beginning "Workspace:" describe the
       minimal amount of workspace needed at that point in the code,
       as well as the preferred amount for good performance.
       NB refers to the optimal block size for the immediately
       following subroutine, as returned by ILAENV.)
*/

    if (*info == 0) {
        minwrk = 1;
        maxwrk = 1;
        liwork = 1;
        lrwork = 1;
        if (minmn > 0) {
            smlsiz = ilaenv_(&c__9, "CGELSD", " ", &c__0, &c__0, &c__0, &c__0,
                             (ftnlen)6, (ftnlen)1);
            mnthr = ilaenv_(&c__6, "CGELSD", " ", m, n, nrhs, &c_n1, (ftnlen)6, (ftnlen)1);
            /* Computing MAX */
            i__1 = (integer) (log((real) minmn / (real) (smlsiz + 1)) / log(2.f)) + 1;
            nlvl = max(i__1,0);
            liwork = minmn * 3 * nlvl + minmn * 11;
            mm = *m;
            if (*m >= *n && *m >= mnthr) {

/*
                Path 1a - overdetermined, with many more rows than
                          columns.
*/

                mm = *n;
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *n * ilaenv_(&c__1, "CGEQRF", " ", m, n,
                                                  &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = *nrhs * ilaenv_(&c__1, "CUNMQR", "LC",
                                                      m, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)2);
                maxwrk = max(i__1,i__2);
            }
            if (*m >= *n) {

/*
                Path 1 - overdetermined or exactly determined.

   Computing MAX
   Computing 2nd power
*/
                i__3 = smlsiz + 1;
                i__1 = i__3 * i__3, i__2 = *n * (*nrhs + 1) + (*nrhs << 1);
                lrwork = *n * 10 + (*n << 1) * smlsiz + (*n << 3) * nlvl +
                    smlsiz * 3 * *nrhs + max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (mm + *n) * ilaenv_(&c__1,
                                                                       "CGEBRD", " ", &mm, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + *nrhs * ilaenv_(&c__1,
                                                                  "CUNMBR", "QLC", &mm, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                                                                    "CUNMBR", "PLN", n, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);
                maxwrk = max(i__1,i__2);
            }
        }
    }
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = (*n << 1) + *n * *nrhs;
maxwrk = max(i__1,i__2);

/* Computing MAX */
/* 计算两个值的最大值，更新 minwrk 的值 */
i__1 = (*n << 1) + mm, i__2 = (*n << 1) + *n * *nrhs;
minwrk = max(i__1,i__2);
}

if (*n > *m) {

/*
   Computing MAX
   Computing 2nd power
*/
/* 计算 smlsiz+1 的平方和 *n * (*nrhs+1) + (*nrhs<<1) 的最大值，更新 lrwork 的值 */
i__3 = smlsiz + 1;
i__1 = i__3 * i__3, i__2 = *n * (*nrhs + 1) + (*nrhs << 1);
lrwork = *m * 10 + (*m << 1) * smlsiz + (*m << 3) * nlvl +
    smlsiz * 3 * *nrhs + max(i__1,i__2);

if (*n >= mnthr) {

/*
   Path 2a - underdetermined, with many more columns
             than rows.
*/

/* 根据特定条件计算 maxwrk 的值，用于路径 2a 的情况 */
maxwrk = *m + *m * ilaenv_(&c__1, "CGELQF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m << 1) *
    ilaenv_(&c__1, "CGEBRD", " ", m, m, &c_n1, &c_n1,
    (ftnlen)6, (ftnlen)1);
maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *nrhs *
    ilaenv_(&c__1, "CUNMBR", "QLC", m, nrhs, m, &c_n1,
     (ftnlen)6, (ftnlen)3);
maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m - 1) *
    ilaenv_(&c__1, "CUNMLQ", "LC", n, nrhs, m, &c_n1,
    (ftnlen)6, (ftnlen)2);
maxwrk = max(i__1,i__2);
if (*nrhs > 1) {
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + *m + *m * *nrhs;
maxwrk = max(i__1,i__2);
} else {
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + (*m << 1);
maxwrk = max(i__1,i__2);
}
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *m * *nrhs;
maxwrk = max(i__1,i__2);
/*
   XXX: Ensure the Path 2a case below is triggered.  The workspace
   calculation should use queries for all routines eventually.
   Computing MAX
   Computing MAX
*/
/* 复杂计算，用于更新 maxwrk 的值 */
i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4),
    i__3 = max(i__3,*nrhs), i__4 = *n - *m * 3;
i__1 = maxwrk, i__2 = (*m << 2) + *m * *m + max(i__3,i__4)
    ;
maxwrk = max(i__1,i__2);
} else {

/* Path 2 - underdetermined. */

/* 根据特定条件计算 maxwrk 的值，用于路径 2 的情况 */
maxwrk = (*m << 1) + (*n + *m) * ilaenv_(&c__1, "CGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = (*m << 1) + *nrhs * ilaenv_(&c__1,
    "CUNMBR", "QLC", m, nrhs, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算两个值的最大值，更新 maxwrk 的值 */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNMBR", "PLN", n, nrhs, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* Computing MAX */
/* 计算最大值 */
            i__1 = maxwrk, i__2 = (*m << 1) + *m * *nrhs;
            maxwrk = max(i__1,i__2);
        }
/* Computing MAX */
/* 计算最大值 */
        i__1 = (*m << 1) + *n, i__2 = (*m << 1) + *m * *nrhs;
        minwrk = max(i__1,i__2);
        }
    }
    minwrk = min(minwrk,maxwrk);
    work[1].r = (real) maxwrk, work[1].i = 0.f;
    iwork[1] = liwork;
    rwork[1] = (real) lrwork;

    if (*lwork < minwrk && ! lquery) {
        *info = -12;
    }
    }

    if (*info != 0) {
    i__1 = -(*info);
/* 根据错误信息调用错误处理程序 */
    xerbla_("CGELSD", &i__1);
    return 0;
    } else if (lquery) {
/* 如果是查询模式，直接返回 */
    return 0;
    }

/*     Quick return if possible. */
/* 如果可能的话，快速返回 */

    if (*m == 0 || *n == 0) {
/* 如果 m 或 n 为零，返回 rank 为零 */
    *rank = 0;
    return 0;
    }

/*     Get machine parameters. */
/* 获取机器参数 */

    eps = slamch_("P");
    sfmin = slamch_("S");
    smlnum = sfmin / eps;
    bignum = 1.f / smlnum;
    slabad_(&smlnum, &bignum);

/*     Scale A if max entry outside range [SMLNUM,BIGNUM]. */
/* 如果 A 中的最大条目超出范围 [SMLNUM,BIGNUM]，则对其进行缩放 */

    anrm = clange_("M", m, n, &a[a_offset], lda, &rwork[1]);
    iascl = 0;
    if (anrm > 0.f && anrm < smlnum) {

/*        Scale matrix norm up to SMLNUM */
/* 将矩阵范数缩放至 SMLNUM */

    clascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda,
        info);
    iascl = 1;
    } else if (anrm > bignum) {

/*        Scale matrix norm down to BIGNUM. */
/* 将矩阵范数缩放至 BIGNUM */

    clascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda,
        info);
    iascl = 2;
    } else if (anrm == 0.f) {

/*        Matrix all zero. Return zero solution. */
/* 矩阵全为零，返回零解 */

    i__1 = max(*m,*n);
    claset_("F", &i__1, nrhs, &c_b56, &c_b56, &b[b_offset], ldb);
    slaset_("F", &minmn, &c__1, &c_b328, &c_b328, &s[1], &c__1)
        ;
    *rank = 0;
    goto L10;
    }

/*     Scale B if max entry outside range [SMLNUM,BIGNUM]. */
/* 如果 B 中的最大条目超出范围 [SMLNUM,BIGNUM]，则对其进行缩放 */

    bnrm = clange_("M", m, nrhs, &b[b_offset], ldb, &rwork[1]);
    ibscl = 0;
    if (bnrm > 0.f && bnrm < smlnum) {

/*        Scale matrix norm up to SMLNUM. */
/* 将矩阵范数缩放至 SMLNUM */

    clascl_("G", &c__0, &c__0, &bnrm, &smlnum, m, nrhs, &b[b_offset], ldb,
         info);
    ibscl = 1;
    } else if (bnrm > bignum) {

/*        Scale matrix norm down to BIGNUM. */
/* 将矩阵范数缩放至 BIGNUM */

    clascl_("G", &c__0, &c__0, &bnrm, &bignum, m, nrhs, &b[b_offset], ldb,
         info);
    ibscl = 2;
    }

/*     If M < N make sure B(M+1:N,:) = 0 */
/* 如果 M < N，则确保 B(M+1:N,:) = 0 */

    if (*m < *n) {
    i__1 = *n - *m;
    claset_("F", &i__1, nrhs, &c_b56, &c_b56, &b[*m + 1 + b_dim1], ldb);
    }

/*     Overdetermined case. */
/* 超定情况 */

    if (*m >= *n) {

/*        Path 1 - overdetermined or exactly determined. */
/*        路径 1 - 超定或完全确定。 */

    mm = *m;
    if (*m >= mnthr) {

/*           Path 1a - overdetermined, with many more rows than columns */
/*           路径 1a - 超定，行数远大于列数 */

        mm = *n;
        itau = 1;
        nwork = itau + *n;

/*
             Compute A=Q*R.
             (RWorkspace: need N)
             (CWorkspace: need N, prefer N*NB)
*/

        i__1 = *lwork - nwork + 1;
        cgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
             info);
/*
             Multiply B by transpose(Q).
             (RWorkspace: need N)
             (CWorkspace: need NRHS, prefer NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
cunmqr_("L", "C", m, nrhs, n, &a[a_offset], lda, &work[itau], &b[
    b_offset], ldb, &work[nwork], &i__1, info);

/*           Zero out below R. */
if (*n > 1) {
    i__1 = *n - 1;
    i__2 = *n - 1;
    claset_("L", &i__1, &i__2, &c_b56, &c_b56, &a[a_dim1 + 2],
        lda);
}



/*
          Bidiagonalize R in A.
          (RWorkspace: need N)
          (CWorkspace: need 2*N+MM, prefer 2*N+(MM+N)*NB)
*/
i__1 = *lwork - nwork + 1;
cgebrd_(&mm, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq], &
    work[itaup], &work[nwork], &i__1, info);

/*
          Multiply B by transpose of left bidiagonalizing vectors of R.
          (CWorkspace: need 2*N+NRHS, prefer 2*N+NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
cunmbr_("Q", "L", "C", &mm, nrhs, n, &a[a_offset], lda, &work[itauq],
    &b[b_offset], ldb, &work[nwork], &i__1, info);

/*        Solve the bidiagonal least squares problem. */
clalsd_("U", &smlsiz, n, nrhs, &s[1], &rwork[ie], &b[b_offset], ldb,
    rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1], info);
if (*info != 0) {
    goto L10;
}

/*        Multiply B by right bidiagonalizing vectors of R. */
i__1 = *lwork - nwork + 1;
cunmbr_("P", "L", "N", n, nrhs, n, &a[a_offset], lda, &work[itaup], &
    b[b_offset], ldb, &work[nwork], &i__1, info);



} else /* if(complicated condition) */ {
/* Computing MAX */
i__1 = *m, i__2 = (*m << 1) - 4, i__1 = max(i__1,i__2), i__1 = max(
    i__1,*nrhs), i__2 = *n - *m * 3;
if (*n >= mnthr && *lwork >= (*m << 2) + *m * *m + max(i__1,i__2)) {

/*
          Path 2a - underdetermined, with many more columns than rows
          and sufficient workspace for an efficient algorithm.
*/
ldwork = *m;
/*
   Computing MAX
   Computing MAX
*/
i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4), i__3 =
    max(i__3,*nrhs), i__4 = *n - *m * 3;
i__1 = (*m << 2) + *m * *lda + max(i__3,i__4), i__2 = *m * *lda +
    *m + *m * *nrhs;
if (*lwork >= max(i__1,i__2)) {
    ldwork = *lda;
}
itau = 1;
nwork = *m + 1;

/*
          Compute A=L*Q.
          (CWorkspace: need 2*M, prefer M+M*NB)
*/
i__1 = *lwork - nwork + 1;
cgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
     info);
il = nwork;
/*        Copy L to WORK(IL), zeroing out above its diagonal. */
/* 将L复制到WORK(IL)，并将其对角线以上的部分清零。 */

clacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwork);
/* 调用BLAS库函数clacpy_，将矩阵L复制到WORK(IL)中，使用'L'表示复制下三角部分。
   m为矩阵的维度，a为原始矩阵，work为目标矩阵，lda和ldwork分别是a和work的leading dimension。 */

i__1 = *m - 1;
i__2 = *m - 1;
claset_("U", &i__1, &i__2, &c_b56, &c_b56, &work[il + ldwork], &ldwork);
/* 调用BLAS库函数claset_，将WORK(IL)矩阵上三角部分清零。
   'U'表示操作上三角部分，i__1和i__2为矩阵的维度，c_b56是一个常数，work[il + ldwork]是操作的起始地址，ldwork是leading dimension。 */

itauq = il + ldwork * *m;
/* 计算itauq的位置索引，用于存储Q矩阵的tau参数。 */

itaup = itauq + *m;
/* 计算itaup的位置索引，用于存储P矩阵的tau参数。 */

nwork = itaup + *m;
/* 计算nwork的位置索引，用于存储临时工作区数组的起始位置。 */

ie = 1;
/* 初始化ie，用于存储实数工作数组的起始位置。 */

nrwork = ie + *m;
/* 计算nrwork的位置索引，用于存储实数工作数组的起始位置。 */

/*
  Bidiagonalize L in WORK(IL).
  (RWorkspace: need M)
  (CWorkspace: need M*M+4*M, prefer M*M+4*M+2*M*NB)
*/
/* 在WORK(IL)中对L进行双对角化处理。
   RWorkspace需要M个空间，CWorkspace需要M*M+4*M的空间，推荐使用M*M+4*M+2*M*NB的空间。 */

i__1 = *lwork - nwork + 1;
cgebrd_(m, m, &work[il], &ldwork, &s[1], &rwork[ie], &work[itauq],
         &work[itaup], &work[nwork], &i__1, info);
/* 调用LAPACK库函数cgebrd_，对WORK(IL)中的矩阵L进行双对角化处理。
   m为矩阵维度，work[il]为L矩阵的起始地址，ldwork为leading dimension，s为双对角元素数组，rwork为实数工作数组，itauq和itaup为存储tau参数的数组，
   work[nwork]为实数工作数组，i__1为工作数组的长度，info为返回状态码。 */

/*
  Multiply B by transpose of left bidiagonalizing vectors of L.
  (CWorkspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
*/
/* 将B乘以L的左双对角化向量的转置。
   CWorkspace需要M*M+4*M+NRHS的空间，推荐使用M*M+4*M+NRHS*NB的空间。 */

i__1 = *lwork - nwork + 1;
cunmbr_("Q", "L", "C", m, nrhs, m, &work[il], &ldwork, &work[itauq], &b[b_offset],
       ldb, &work[nwork], &i__1, info);
/* 调用LAPACK库函数cunmbr_，将B乘以L的左双对角化向量的转置。
   'Q'表示使用Q矩阵，'L'表示左乘，'C'表示使用复数共轭转置。
   m为矩阵L的维度，nrhs为右侧矩阵B的列数，work[il]为L矩阵的起始地址，ldwork为leading dimension，work[itauq]为Q矩阵的tau参数数组，
   b[b_offset]为右侧矩阵B的起始地址，ldb为B矩阵的leading dimension，work[nwork]为实数工作数组，i__1为工作数组的长度，info为返回状态码。 */

/*        Solve the bidiagonal least squares problem. */
/* 解决双对角最小二乘问题。 */

clalsd_("U", &smlsiz, m, nrhs, &s[1], &rwork[ie], &b[b_offset],
        ldb, rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1], info);
/* 调用LAPACK库函数clalsd_，解决双对角最小二乘问题。
   'U'表示使用上三角部分，smlsiz为小矩阵的维度，m为矩阵维度，nrhs为右侧矩阵B的列数，s为双对角元素数组，rwork为实数工作数组，b[b_offset]为右侧矩阵B的起始地址，
   ldb为B矩阵的leading dimension，rcond为条件数截断值，rank为返回的秩，work[nwork]为实数工作数组，rwork[nrwork]为实数工作数组，iwork为整数工作数组，info为返回状态码。 */

if (*info != 0) {
    goto L10;
}

/*        Multiply B by right bidiagonalizing vectors of L. */
/* 将B乘以L的右双对角化向量。 */

i__1 = *lwork - nwork + 1;
cunmbr_("P", "L", "N", m, nrhs, m, &work[il], &ldwork, &work[itaup], &b[b_offset],
       ldb, &work[nwork], &i__1, info);
/* 调用LAPACK库函数cunmbr_，将B乘以L的右双对角化向量。
   'P'表示使用P矩阵，'L'表示左乘，'N'表示不使用共轭转置。
   m为矩阵L的维度，nrhs为右侧矩阵B的列数，work[il]为L矩阵的起始地址，ldwork为leading dimension，work[itaup]为P矩阵的tau参数数组，
   b[b_offset]为右侧矩阵B的起始地址，ldb为B矩阵的leading dimension，work[nwork]为实数工作数组，i__1为工作数组的长度，info为返回状态码。 */

/*        Zero out below first M rows of B. */
/* 将B的前M行以下的部分清零。 */

i__1 = *n - *m;
claset_("F", &i__1, nrhs, &c_b56, &c_b56, &b[*m + 1 + b_dim1],
        ldb);
/* 调用BLAS库函数claset_，将矩阵B的前M行以下的部分清零。
   'F'表示操作整个矩阵，i__1为矩阵B的行数，nrhs为右侧矩阵B的列数，c_b56是一个常数，b[*m + 1 + b_dim1]为操作的起始地址，ldb为B矩阵的leading dimension。 */

nwork = itau + *m;
/* 更新nwork的位置索引，用于存储临时工作区数组的起始位置。 */

/*
  Multiply transpose(Q) by B.
  (CWorkspace: need NRHS, prefer NRHS*NB)
*/
/* 将Q的转置乘以B。 
   CWorkspace需要NRHS的空间，推荐使用NRHS*NB的空间。 */

i__1 = *lwork - nwork + 1;
cunmlq_("L
/*        Solve the bidiagonal least squares problem. */
/* 解决双对角最小二乘问题。 */

clalsd_("L", &smlsiz, m, nrhs, &s[1], &rwork[ie], &b[b_offset],
    ldb, rcond, rank, &work[nwork], &rwork[nrwork], &iwork[1],
    info);
/* 调用 LAPACK 函数 clalsd_ 来解决双对角最小二乘问题。参数解释如下：
   - "L": 指示 LAPACK 库使用的算法类型。
   - smlsiz: 控制 LAPACK 算法中的细节参数。
   - m: 矩阵 A 的行数。
   - nrhs: 右侧矩阵 B 的列数。
   - &s[1]: 双对角元素的数组。
   - &rwork[ie]: 工作数组。
   - &b[b_offset]: 存储右侧矩阵 B 的数组。
   - ldb: 右侧矩阵 B 的列数。
   - rcond: 控制条件数的阈值。
   - rank: 矩阵 A 的秩。
   - &work[nwork]: 工作空间数组。
   - &rwork[nrwork]: 工作空间的实型数组。
   - &iwork[1]: 工作数组。
   - info: 返回的信息代码。 */

if (*info != 0) {
goto L10;
}

/*        Multiply B by right bidiagonalizing vectors of A. */
/* 用 A 的右侧双对角化向量乘以 B。 */

i__1 = *lwork - nwork + 1;
cunmbr_("P", "L", "N", n, nrhs, m, &a[a_offset], lda, &work[itaup],
    &b[b_offset], ldb, &work[nwork], &i__1, info);
/* 调用 LAPACK 函数 cunmbr_ 来进行矩阵乘法运算。参数解释如下：
   - "P": 指示 LAPACK 使用的矩阵类型。
   - "L": 指示应用于矩阵 A 左侧。
   - "N": 指示不进行转置。
   - n: 矩阵 A 的列数。
   - nrhs: 右侧矩阵 B 的列数。
   - m: 矩阵 A 的行数。
   - &a[a_offset]: 矩阵 A 的数组。
   - lda: 矩阵 A 的列数。
   - &work[itaup]: 工作数组。
   - &b[b_offset]: 存储右侧矩阵 B 的数组。
   - ldb: 右侧矩阵 B 的列数。
   - &work[nwork]: 工作空间数组。
   - &i__1: 工作空间大小。
   - info: 返回的信息代码。 */
}

/*     Undo scaling. */
/* 恢复尺度。 */

if (iascl == 1) {
clascl_("G", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb,
    info);
slascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &
    minmn, info);
} else if (iascl == 2) {
clascl_("G", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb,
    info);
slascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
    minmn, info);
}
if (ibscl == 1) {
clascl_("G", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb,
    info);
} else if (ibscl == 2) {
clascl_("G", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb,
    info);
}

L10:
work[1].r = (real) maxwrk, work[1].i = 0.f;
iwork[1] = liwork;
rwork[1] = (real) lrwork;
return 0;

/*     End of CGELSD */
/* CGELSD 的结束 */

} /* cgelsd_ */

/* Subroutine */ int cgeqr2_(integer *m, integer *n, singlecomplex *a, integer *lda,
 singlecomplex *tau, singlecomplex *work, integer *info)
{
/* 子程序 cgeqr2_ */

/* System generated locals */
/* 系统生成的本地变量 */

integer a_dim1, a_offset, i__1, i__2, i__3;
singlecomplex q__1;

/* Local variables */
/* 本地变量 */

static integer i__, k;
static singlecomplex alpha;
extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
    , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
    clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
    xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======
    目的

    CGEQR2 computes a QR factorization of a complex m by n matrix A:
    A = Q * R.
    计算复数 m 行 n 列矩阵 A 的 QR 分解：A = Q * R。

    Arguments
    =========
    参数

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.
            矩阵 A 的行数。M >= 0。

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.
            矩阵 A 的列数。N >= 0。
*/
    # 测试输入参数的合法性
    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0，用于存储函数执行状态信息
    if (*m < 0) {  // 检查输入参数 m 是否小于 0
        *info = -1;  // 若 m 小于 0，则将 info 设置为 -1
    } else if (*n < 0) {  // 检查输入参数 n 是否小于 0
        *info = -2;  // 若 n 小于 0，则将 info 设置为 -2
    } else if (*lda < max(1,*m)) {  // 检查输入参数 lda 是否小于 max(1, m)
        *info = -4;  // 若 lda 小于 max(1, m)，则将 info 设置为 -4
    }
    if (*info != 0) {  // 如果 info 不等于 0，表示有错误发生
        i__1 = -(*info);
        xerbla_("CGEQR2", &i__1);  // 调用错误处理例程 xerbla_，报告错误信息
        return 0;  // 返回，函数执行结束
    }

    k = min(*m,*n);  // 计算 k 为 m 和 n 中的较小值

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {  // 开始循环，生成和应用 Householder 变换

/*        Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

        i__2 = *m - i__ + 1;
        /* Computing MIN */
        i__3 = i__ + 1;
        clarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ * a_dim1]
            , &c__1, &tau[i__]);  // 生成 Householder 变换，消除 A(i+1:m,i) 中的元素

        if (i__ < *n) {  // 如果 i 小于 n，则需要应用 Householder 变换到 A 的右侧部分

/*           Apply H(i)' to A(i:m,i+1:n) from the left */

            i__2 = i__ + i__ * a_dim1;
            alpha.r = a[i__2].r, alpha.i = a[i__2].i;  // 存储 A(i,i) 的值
            i__2 = i__ + i__ * a_dim1;
            a[i__2].r = 1.f, a[i__2].i = 0.f;  // 将 A(i,i) 设置为单位矩阵的一部分
            i__2 = *m - i__ + 1;
            i__3 = *n - i__;
            r_cnjg(&q__1, &tau[i__]);  // 对 tau[i__] 求共轭
            clarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &q__1,
                 &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);  // 应用 Householder 变换到 A(i:m,i+1:n)
            i__2 = i__ + i__ * a_dim1;
            a[i__2].r = alpha.r, a[i__2].i = alpha.i;  // 恢复 A(i,i) 的原始值
        }
/* L10: */
    }
    return 0;

/*     End of CGEQR2 */

} /* cgeqr2_ */

/* Subroutine */ int cgeqrf_(integer *m, integer *n, singlecomplex *a, integer *lda,
     singlecomplex *tau, singlecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int cgeqr2_(integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *), clarfb_(char *, char
        *, char *, char *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarft_(char *, char *
        , integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;

    /* Purpose */
    /* ======= */

    /* CGEQRF computes a QR factorization of a complex M-by-N matrix A: */
    /* A = Q * R. */

    /* Arguments */
    /* ========= */

    /* M       (input) INTEGER */
    /*         The number of rows of the matrix A.  M >= 0. */

    /* N       (input) INTEGER */
    /*         The number of columns of the matrix A.  N >= 0. */
    # Test the input arguments

    A       (input/output) COMPLEX array, dimension (LDA,N)
            # On entry, the M-by-N matrix A.
            # On exit, the elements on and above the diagonal of the array
            # contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            # upper triangular if m >= n); the elements below the diagonal,
            # with the array TAU, represent the unitary matrix Q as a
            # product of min(m,n) elementary reflectors (see Further
            # Details).

    LDA     (input) INTEGER
            # The leading dimension of the array A.  LDA >= max(1,M).

    TAU     (output) COMPLEX array, dimension (min(M,N))
            # The scalar factors of the elementary reflectors (see Further
            # Details).

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            # On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            # The dimension of the array WORK.  LWORK >= max(1,N).
            # For optimum performance LWORK >= N*NB, where NB is
            # the optimal blocksize.

            # If LWORK = -1, then a workspace query is assumed; the routine
            # only calculates the optimal size of the WORK array, returns
            # this value as the first entry of the WORK array, and no error
            # message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            # = 0:  successful exit
            # < 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).

    =====================================================================
    /* 参数调整 */
    a_dim1 = *lda;                              // a_dim1 指定为 lda，维度偏移设置为 1 + a_dim1
    a_offset = 1 + a_dim1;                      // a_offset 计算为 1 + a_dim1
    a -= a_offset;                              // a 指针调整为 a - a_offset
    --tau;                                      // tau 指针前移一位
    --work;                                     // work 指针前移一位

    /* 函数体 */
    *info = 0;                                   // info 初始化为 0
    nb = ilaenv_(&c__1, "CGEQRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算块大小 nb
    lwkopt = *n * nb;                            // 计算工作空间的最优大小
    work[1].r = (real) lwkopt, work[1].i = 0.f;  // work 的第一个元素设定为工作空间大小
    lquery = *lwork == -1;                       // 检查是否为查询工作空间大小的标记
    if (*m < 0) {                                // 检查 m 的合法性
    *info = -1;
    } else if (*n < 0) {                         // 检查 n 的合法性
    *info = -2;
    } else if (*lda < max(1,*m)) {                // 检查 lda 的合法性
    *info = -4;
    } else if (*lwork < max(1,*n) && ! lquery) {  // 检查工作空间大小的合法性
    *info = -7;
    }
    if (*info != 0) {                            // 如果出现错误信息，调用错误处理函数并返回
    i__1 = -(*info);
    xerbla_("CGEQRF", &i__1);
    return 0;
    } else if (lquery) {                         // 如果是查询工作空间大小的请求，直接返回
    return 0;
    }

/*     如果可能的话，快速返回 */

    k = min(*m,*n);                              // 计算 k，为 m 和 n 的最小值
    if (k == 0) {                                // 如果 k 为 0，直接返回
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

    nbmin = 2;                                   // 设置最小块大小
    nx = 0;                                      // 初始化 nx
    iws = *n;                                    // 设置工作空间大小
    if (nb > 1 && nb < k) {

/*
          确定从阻塞代码到非阻塞代码切换的时机。

   计算 MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "CGEQRF", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);                         // 计算 nx
    if (nx < k) {

/*           检查工作空间是否足够支持阻塞代码。 */

        ldwork = *n;                             // 设置 ldwork
        iws = ldwork * nb;                       // 计算实际需要的工作空间大小
        if (*lwork < iws) {

/*
                工作空间不足以使用最优的块大小 NB：减小 NB 并
                确定最小的 NB 值。
*/

        nb = *lwork / ldwork;                    // 调整块大小 NB
/* 计算 MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "CGEQRF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);                  // 计算最小块大小 NBMIN
        }
    }
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        首先使用阻塞代码 */

    i__1 = k - nx;
    i__2 = nb;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* 计算 MIN */
        i__3 = k - i__ + 1;
        ib = min(i__3,nb);

/*
             计算当前块 A(i:m,i:i+ib-1) 的 QR 分解
*/

        i__3 = *m - i__ + 1;
        cgeqr2_(&i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);
        if (i__ + ib <= *n) {

/*
                形成块反射器的上三角因子
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__3 = *m - i__ + 1;
        clarft_("Forward", "Columnwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              从左侧应用 H' 到 A(i:m,i+ib:n) */

        i__3 = *m - i__ + 1;
        i__4 = *n - i__ - ib + 1;
        clarfb_("Left", "Conjugate transpose", "Forward", "Columnwise"
            , &i__3, &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &
            work[1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda,
            &work[ib + 1], &ldwork);
        }
/* L10: */
    }
    } else {
    i__ = 1;
    }

/*     使用非阻塞代码来因式分解最后一个或唯一的块。 */

    if (i__ <= k) {
    i__2 = *m - i__ + 1;
    i__1 = *n - i__ + 1;
    # 调用 LAPACK 库中的 cgeqr2_ 函数，对矩阵 a 的子块进行 QR 分解
    cgeqr2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    }
    
    # 将工作数组 work 的第一个元素设置为整数 iws 的实部，虚部为 0
    work[1].r = (real) iws, work[1].i = 0.f;
    
    # 返回整数值 0，表示函数执行成功结束
    return 0;
/* End of CGEQRF */

} /* cgeqrf_ */

/* Subroutine cgesdd_ takes parameters and computes singular value decomposition (SVD) of a complex matrix A.
   Parameters:
   - jobz: Specifies options for computation ('N', 'A', 'S', 'O').
   - m: Number of rows of matrix A.
   - n: Number of columns of matrix A.
   - a: Complex matrix A of dimension (lda, n).
   - lda: Leading dimension of A.
   - s: Array of singular values of length min(m,n).
   - u: Left singular vectors matrix of dimension (ldu, m) if jobz='A' or 'S'.
   - ldu: Leading dimension of U.
   - vt: Right singular vectors matrix of dimension (ldvt, n) if jobz='A'.
   - ldvt: Leading dimension of VT.
   - work: Workspace array.
   - lwork: Length of the work array.
   - rwork: Real workspace array.
   - iwork: Integer workspace array.
   - info: Status parameter (output).

   Note: This subroutine performs SVD decomposition using LAPACK routines and is used for complex matrices.
*/
{
    /* System generated locals */
    integer a_dim1, a_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2, i__3;

    /* Local variables */
    static integer i__, ie, il, ir, iu, blk;
    static real dum[1], eps;
    static integer iru, ivt, iscl;
    static real anrm;
    static integer idum[1], ierr, itau, irvt;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    extern logical lsame_(char *, char *);
    static integer chunk, minmn, wrkbl, itaup, itauq;
    static logical wntqa;
    static integer nwork;
    extern /* Subroutine */ int clacp2_(char *, integer *, integer *, real *,
        integer *, singlecomplex *, integer *);
    static logical wntqn, wntqo, wntqs;
    static integer mnthr1, mnthr2;
    extern /* Subroutine */ int cgebrd_(integer *, integer *, singlecomplex *,
        integer *, real *, real *, singlecomplex *, singlecomplex *, singlecomplex *,
        integer *, integer *);
    extern doublereal clange_(char *, integer *, integer *, singlecomplex *,
        integer *, real *);
    extern /* Subroutine */ int cgelqf_(integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *, integer *), clacrm_(
        integer *, integer *, singlecomplex *, integer *, real *, integer *,
        singlecomplex *, integer *, real *), clarcm_(integer *, integer *, real
        *, integer *, singlecomplex *, integer *, singlecomplex *, integer *, real *),
         clascl_(char *, integer *, integer *, real *, real *, integer *,
        integer *, singlecomplex *, integer *, integer *);
    extern /* Subroutine */ int sbdsdc_(char *, char *, integer *, real *, real *, real *, integer *, real *,
        integer *, real *, integer *, real *, integer *, integer *);
    extern /* Subroutine */ int cgeqrf_(integer *, integer *, singlecomplex *, integer
        *, singlecomplex *, singlecomplex *, integer *, integer *);
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex
        *, integer *, singlecomplex *, integer *), claset_(char *,
        integer *, integer *, singlecomplex *, singlecomplex *, singlecomplex *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int cungbr_(char *, integer *, integer *, integer
        *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer
        *);
    static real bignum;
    /* 定义外部的数学函数 slascl 和线性代数函数 cunmbr、cunglq、cungqr */
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *), cunmbr_(char *, char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *), cunglq_(
        integer *, integer *, integer *, singlecomplex *, integer *, singlecomplex *,
        singlecomplex *, integer *, integer *);
    /* 定义静态变量 ldwrkl，用于存储工作矩阵的行数 */
    static integer ldwrkl;
    /* 定义外部的线性代数函数 cungqr */
    extern /* Subroutine */ int cungqr_(integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer *);
    /* 定义静态变量 ldwrkr，用于存储工作矩阵的行数 */
    static integer ldwrkr, minwrk, ldwrku, maxwrk, ldwkvt;
    /* 定义静态变量 smlnum，用于存储一个小的数值 */
    static real smlnum;
    /* 定义静态变量 wntqas，逻辑变量，表示是否要求转置和复共轭转置 */
    static logical wntqas;
    /* 定义静态变量 nrwork，用于存储工作向量的长度 */
    static integer nrwork;
"""
    -- LAPACK driver routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010
       8-15-00:  Improve consistency of WS calculations (eca)


    Purpose
    =======

    CGESDD computes the singular value decomposition (SVD) of a complex
    M-by-N matrix A, optionally computing the left and/or right singular
    vectors, by using divide-and-conquer method. The SVD is written

         A = U * SIGMA * conjugate-transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
    V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns VT = V**H, not V.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**H are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**H are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V**H are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**H are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**H are computed.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N >= 0.
"""
    A       (input/output) COMPLEX array, dimension (LDA,N)
            ! On entry, the M-by-N matrix A.
            ! On exit:
            !   if JOBZ = 'O',  A is overwritten with the first N columns
            !                     of U (left singular vectors, stored columnwise) if M >= N;
            !                     or with the first M rows of V**H (right singular vectors, stored rowwise) otherwise.
            !   if JOBZ .ne. 'O', the contents of A are destroyed.

    LDA     (input) INTEGER
            ! The leading dimension of the array A. LDA >= max(1,M).

    S       (output) REAL array, dimension (min(M,N))
            ! The singular values of A, sorted so that S(i) >= S(i+1).

    U       (output) COMPLEX array, dimension (LDU,UCOL)
            ! UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
            ! UCOL = min(M,N) if JOBZ = 'S'.
            ! If JOBZ = 'A' or 'O' and M < N, U contains the M-by-M unitary matrix U;
            ! If JOBZ = 'S', U contains the first min(M,N) columns of U (left singular vectors, stored columnwise);
            ! If JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.

    LDU     (input) INTEGER
            ! The leading dimension of the array U. LDU >= 1;
            ! If JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.

    VT      (output) COMPLEX array, dimension (LDVT,N)
            ! If JOBZ = 'A' or 'O' and M >= N, VT contains the N-by-N unitary matrix V**H;
            ! If JOBZ = 'S', VT contains the first min(M,N) rows of V**H (right singular vectors, stored rowwise);
            ! If JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.

    LDVT    (input) INTEGER
            ! The leading dimension of the array VT. LDVT >= 1;
            ! If JOBZ = 'A' or 'O' and M >= N, LDVT >= N;
            ! If JOBZ = 'S', LDVT >= min(M,N).

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            ! On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            ! The dimension of the array WORK. LWORK >= 1.
            ! Depending on JOBZ:
            !   if JOBZ = 'N', LWORK >= 2*min(M,N) + max(M,N).
            !   if JOBZ = 'O', LWORK >= 2*min(M,N)*min(M,N) + 2*min(M,N) + max(M,N).
            !   if JOBZ = 'S' or 'A', LWORK >= min(M,N)*min(M,N) + 2*min(M,N) + max(M,N).
            ! For optimal performance, LWORK should generally be larger.
            ! If LWORK = -1, a workspace query is assumed. The optimal size for the WORK array is calculated and stored in WORK(1).

    RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))
            ! If JOBZ = 'N', LRWORK >= 5*min(M,N).
            ! Otherwise, LRWORK >= min(M,N)*max(5*min(M,N) + 7, 2*max(M,N) + 2*min(M,N) + 1).
    # IWORK 是一个整数数组，用作工作空间，其长度为 8*min(M,N)
    IWORK   (workspace) INTEGER array, dimension (8*min(M,N))

    # INFO 是输出参数，返回函数执行的状态信息：
    # - 0：执行成功
    # - < 0：某个参数的值非法，具体是第 i 个参数非法时 INFO = -i
    # - > 0：SBDSDC 更新过程未收敛
    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The updating process of SBDSDC did not converge.

    # 进一步的细节说明
    # ==================

    # 以下是由以下贡献者提供的基础信息：
    #    Ming Gu 和 Huan Ren, 计算机科学部, 加利福尼亚大学伯克利分校, 美国
    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    # =====================================================================


    # 测试输入参数的有效性
    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --s;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --work;
    --rwork;
    --iwork;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    minmn = min(*m,*n);  // 计算 m 和 n 的最小值
    mnthr1 = (integer) (minmn * 17.f / 9.f);  // 计算阈值 mnthr1
    mnthr2 = (integer) (minmn * 5.f / 3.f);   // 计算阈值 mnthr2
    wntqa = lsame_(jobz, "A");  // 判断 jobz 是否为 "A"
    wntqs = lsame_(jobz, "S");  // 判断 jobz 是否为 "S"
    wntqas = wntqa || wntqs;    // 判断 jobz 是否为 "A" 或 "S"
    wntqo = lsame_(jobz, "O");   // 判断 jobz 是否为 "O"
    wntqn = lsame_(jobz, "N");   // 判断 jobz 是否为 "N"
    minwrk = 1;                  // 初始化 minwrk 为 1
    maxwrk = 1;                  // 初始化 maxwrk 为 1

    if (! (wntqa || wntqs || wntqo || wntqn)) {
        *info = -1;  // 若 jobz 不是 "A", "S", "O", "N" 中的一个，设置 info 为 -1
    } else if (*m < 0) {
        *info = -2;  // 若 m 小于 0，设置 info 为 -2
    } else if (*n < 0) {
        *info = -3;  // 若 n 小于 0，设置 info 为 -3
    } else if (*lda < max(1,*m)) {
        *info = -5;  // 若 lda 小于 max(1, m)，设置 info 为 -5
    } else if (*ldu < 1 || wntqas && *ldu < *m || wntqo && *m < *n && *ldu < *m) {
        *info = -8;  // 根据不同条件设置 info 为 -8
    } else if (*ldvt < 1 || wntqa && *ldvt < *n || wntqs && *ldvt < minmn ||
               wntqo && *m >= *n && *ldvt < *n) {
        *info = -10;  // 根据不同条件设置 info 为 -10
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         CWorkspace refers to complex workspace, and RWorkspace to
         real workspace. NB refers to the optimal block size for the
         immediately following subroutine, as returned by ILAENV.)
*/

    if (*info == 0 && *m > 0 && *n > 0) {
        if (*m >= *n) {

/*
             There is no complex work space needed for bidiagonal SVD
             The real work space needed for bidiagonal SVD is BDSPAC
             for computing singular values and singular vectors; BDSPAN
             for computing singular values only.
             BDSPAC = 5*N*N + 7*N
             BDSPAN = MAX(7*N+4, 3*N+2+SMLSIZ*(SMLSIZ+8))
*/

            if (*m >= mnthr1) {
                if (wntqn) {

/*                 Path 1 (M much larger than N, JOBZ='N') */

                    maxwrk = *n + *n * ilaenv_(&c__1, "CGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
                    i__1 = maxwrk, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
                        c__1, "CGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
                        6, (ftnlen)1);
                    maxwrk = max(i__1,i__2);
                    minwrk = *n * 3;
                } else if (wntqo) {

/*                 Path 2 (M much larger than N, JOBZ='O') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "CGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Computing MAX */
                    i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "CUNGQR",
                        " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
                    wrkbl = max(i__1,i__2);
                    maxwrk = *m * *n + *n * 3;
                }
            }
        }
    }
/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + (*n << 1) * ilaenv_(&
    c__1, "CGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
/* 计算第一个可能的工作空间大小 */

wrkbl = max(i__1,i__2);
/* 更新工作空间大小为以上两者的较大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "QLN", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算第二个可能的工作空间大小 */

wrkbl = max(i__1,i__2);
/* 更新工作空间大小为以上两者的较大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算第三个可能的工作空间大小 */

wrkbl = max(i__1,i__2);
/* 更新工作空间大小为以上两者的较大值 */

maxwrk = *m * *n + *n * *n + wrkbl;
/* 计算需要的最大工作空间大小 */

minwrk = (*n << 1) * *n + *n * 3;
/* 计算需要的最小工作空间大小 */
/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算第一个可能的工作空间大小 */

wrkbl = max(i__1,i__2);
/* 取两者之间的最大值，并更新工作空间大小 */

maxwrk = *n * *n + wrkbl;
/* 计算最大工作空间大小 */

minwrk = *n * *n + (*n << 1) + *m;
/* 计算最小工作空间大小 */

} else if (*m >= mnthr2) {

/* Path 5 (M much larger than N, but not as much as MNTHR1) */
/* 路径 5（M 比 N 大很多，但不如 MNTHR1 那么大）*/

maxwrk = (*n << 1) + (*m + *n) * ilaenv_(&c__1, "CGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算最大工作空间大小 */

minwrk = (*n << 1) + *m;
/* 计算最小工作空间大小 */

if (wntqo) {
/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "Q", m, n, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

maxwrk += *m * *n;
/* 更新最大工作空间大小 */

minwrk += *n * *n;
/* 更新最小工作空间大小 */

} else if (wntqs) {
/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "Q", m, n, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

} else if (wntqa) {
/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "P", n, n, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

}

} else {

/* Path 6 (M at least N, but not much larger) */
/* 路径 6（M 至少等于 N，但不大）*/

maxwrk = (*n << 1) + (*m + *n) * ilaenv_(&c__1, "CGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算最大工作空间大小 */

minwrk = (*n << 1) + *m;
/* 计算最小工作空间大小 */

if (wntqo) {
/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "QLN", m, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

maxwrk += *m * *n;
/* 更新最大工作空间大小 */

minwrk += *n * *n;
/* 更新最小工作空间大小 */

} else if (wntqs) {
/* Computing MAX */
/* 计算最大值 */

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
/* 计算可能的工作空间大小 */

maxwrk = max(i__1,i__2);
/* 取两者之间的最大值，并更新最大工作空间大小 */

}
/* Computing MAX */
计算最大工作空间需求。这部分代码用于确定所需的最大工作空间大小。

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNMBR", "QLN", m, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
第一段计算最大工作空间需求，基于条件 wntqa。

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
第二段计算最大工作空间需求，基于条件 wntqa。

i__1 = maxwrk, i__2 = (*n << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
第三段计算最大工作空间需求，基于条件 wntqa。

这些计算主要是为了确定在不同条件下所需的最大工作空间大小。
*/

else if (wntqa) {
条件 wntqa 的分支，继续计算最大工作空间需求。

/* Computing MAX */
计算最大工作空间需求。

i__1 = maxwrk, i__2 = (*n << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "PRC", n, n, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
计算第一部分的最大工作空间需求，基于条件 wntqa。

i__1 = maxwrk, i__2 = (*n << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
计算第二部分的最大工作空间需求，基于条件 wntqa。
*/

/* There is no complex work space needed for bidiagonal SVD
   The real work space needed for bidiagonal SVD is BDSPAC
   for computing singular values and singular vectors; BDSPAN
   for computing singular values only.
   BDSPAC = 5*M*M + 7*M
   BDSPAN = MAX(7*M+4, 3*M+2+SMLSIZ*(SMLSIZ+8))
*/
在这里，对于双对角奇异值分解（SVD），不需要复杂的工作空间。实际所需的工作空间大小由 BDSPAC 和 BDSPAN 决定，用于计算奇异值及奇异向量。具体的计算公式如上所示。

if (*n >= mnthr1) {
如果 n 大于等于 mnthr1，则执行以下分支。

if (wntqn) {
如果条件 wntqn 为真，则执行以下分支，表示 JOBZ='N'。

/* Path 1t (N much larger than M, JOBZ='N') */
路径 1t，即当 n 远大于 m 且 JOBZ='N' 的情况。

maxwrk = *m + *m * ilaenv_(&c__1, "CGELQF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
计算所需的最大工作空间，用于 CGELQF 函数调用。

/* Computing MAX */
计算最大工作空间需求。

i__1 = maxwrk, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
    c__1, "CGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
maxwrk = max(i__1,i__2);
计算第二部分的最大工作空间需求。
*/

else if (wntqo) {
如果条件 wntqo 为真，则执行以下分支，表示 JOBZ='O'。

/* Path 2t (N much larger than M, JOBZ='O') */
路径 2t，即当 n 远大于 m 且 JOBZ='O' 的情况。

wrkbl = *m + *m * ilaenv_(&c__1, "CGELQF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
计算所需的工作空间下界，用于 CGELQF 函数调用。

/* Computing MAX */
计算最大工作空间需求。

i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "CUNGLQ",
    " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
wrkbl = max(i__1,i__2);
计算第二部分的最大工作空间需求。

/* Computing MAX */
计算最大工作空间需求。

i__1 = wrkbl, i__2 = (*m << 1) + (*m << 1) * ilaenv_(&
    c__1, "CGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)
    6, (ftnlen)1);
wrkbl = max(i__1,i__2);
计算第三部分的最大工作空间需求。

/* Computing MAX */
计算最大工作空间需求。

i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
wrkbl = max(i__1,i__2);
计算第四部分的最大工作空间需求。

/* Computing MAX */
计算最大工作空间需求。

i__1 = wrkbl, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
wrkbl = max(i__1,i__2);
计算第五部分的最大工作空间需求。

maxwrk = *m * *n + *m * *m + wrkbl;
计算总的最大工作空间需求。

minwrk = (*m << 1) * *m + *m * 3;
计算最小工作空间需求。
*/

else if (wntqs) {
如果条件 wntqs 为真，则执行以下分支，表示 JOBZ='S'。

/* Path 3t (N much larger than M, JOBZ='S') */
路径 3t，即当 n 远大于 m 且 JOBZ='S' 的情况。

wrkbl = *m + *m * ilaenv_(&c__1, "CGELQF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
计算所需的工作空间下界，用于 CGELQF 函数调用。
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, *m + *m * ilaenv_(&c__1, "CUNGLQ", " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + (*m << 1) * ilaenv_(&c__1, "CGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1));
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + *m * ilaenv_(&c__1, "CUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3));
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + *m * ilaenv_(&c__1, "CUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3));
maxwrk = *m * *m + wrkbl; /* 计算最大工作区大小 */
minwrk = *m * *m + *m * 3; /* 计算最小工作区大小 */
} else if (wntqa) {

/* Path 4t (N 远大于 M，JOBZ='A') */

wrkbl = *m + *m * ilaenv_(&c__1, "CGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, *m + *n * ilaenv_(&c__1, "CUNGLQ", " ", n, n, m, &c_n1, (ftnlen)6, (ftnlen)1));
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + (*m << 1) * ilaenv_(&c__1, "CGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1));
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + *m * ilaenv_(&c__1, "CUNMBR", "PRC", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3));
/* 计算 wrkbl 的最大值，wrkbl 是工作区数组的大小 */
wrkbl = max(wrkbl, (*m << 1) + *m * ilaenv_(&c__1, "CUNMBR", "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3));
maxwrk = *m * *m + wrkbl; /* 计算最大工作区大小 */
minwrk = *m * *m + (*m << 1) + *n; /* 计算最小工作区大小 */
} else if (*n >= mnthr2) {

/* Path 5t (N 远大于 M，但不及 MNTHR1) */

maxwrk = (*m << 1) + (*m + *n) * ilaenv_(&c__1, "CGEBRD", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
minwrk = (*m << 1) + *n; /* 计算最小工作区大小 */
if (wntqo) {
/* 计算 maxwrk 的最大值，maxwrk 是工作区数组的大小 */
maxwrk = max(maxwrk, (*m << 1) + *m * ilaenv_(&c__1, "CUNGBR", "P", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1));
/* 计算 maxwrk 的最大值，maxwrk 是工作区数组的大小 */
maxwrk = max(maxwrk, (*m << 1) + *m * ilaenv_(&c__1, "CUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)1));
maxwrk += *m * *n; /* 调整 maxwrk 大小 */
minwrk += *m * *m; /* 调整 minwrk 大小 */
} else if (wntqs) {
/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "P", m, n, m, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CUNGBR" 函数调用时所需的工作空间大小。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 继续计算 maxwrk 的值，根据不同的运行时环境条件决定所需的工作空间大小。 */

} else if (wntqa) {
/* 如果 wntqa 为真，则执行以下操作。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "P", n, n, m, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CUNGBR" 函数调用时所需的工作空间大小。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "Q", m, m, n, &c_n1, (ftnlen)6, (ftnlen)
    1);
maxwrk = max(i__1,i__2);
/* 继续计算 maxwrk 的值，根据不同的运行时环境条件决定所需的工作空间大小。 */
}

} else {

/* Path 6t (N greater than M, but not much larger) */

maxwrk = (*m << 1) + (*m + *n) * ilaenv_(&c__1, "CGEBRD",
    " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CGEBRD" 函数调用时所需的工作空间大小。 */

minwrk = (*m << 1) + *n;
/* 计算 minwrk 的值，为最小工作空间大小决定做准备。 */

if (wntqo) {
/* 如果 wntqo 为真，则执行以下操作。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNMBR", "PRC", m, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CUNMBR" 函数调用时所需的工作空间大小。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNMBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 继续计算 maxwrk 的值，根据不同的运行时环境条件决定所需的工作空间大小。 */

maxwrk += *m * *n;
minwrk += *m * *m;
} else if (wntqs) {
/* 如果 wntqs 为真，则执行以下操作。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "PRC", m, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CUNGBR" 函数调用时所需的工作空间大小。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 继续计算 maxwrk 的值，根据不同的运行时环境条件决定所需的工作空间大小。 */
} else if (wntqa) {
/* 如果 wntqa 为真，则执行以下操作。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *n * ilaenv_(&c__1,
    "CUNGBR", "PRC", n, n, m, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 计算 maxwrk 的值，为下一步的工作空间大小决定做准备。该表达式使用 ilaenv 函数获取运行时环境信息，以确定对 "CUNGBR" 函数调用时所需的工作空间大小。 */

/* Computing MAX */
i__1 = maxwrk, i__2 = (*m << 1) + *m * ilaenv_(&c__1,
    "CUNGBR", "QLN", m, m, n, &c_n1, (ftnlen)6, (
    ftnlen)3);
maxwrk = max(i__1,i__2);
/* 继续计算 maxwrk 的值，根据不同的运行时环境条件决定所需的工作空间大小。 */
}

maxwrk = max(maxwrk,minwrk);
/* 最终确定 maxwrk 的值，确保它不低于 minwrk。 */

}

if (*info == 0) {
/* 如果 info 等于 0，则执行以下操作。 */

work[1].r = (real) maxwrk, work[1].i = 0.f;
/* 将 maxwrk 转换为实数后赋值给 work[1]，虚部为 0。 */

if (*lwork < minwrk && *lwork != -1) {
/* 如果 lwork 小于 minwrk 且不为 -1，则执行以下操作。 */

*info = -13;
/* 设置 info 为 -13，表示 lwork 的值太小。 */
}
}

/* Quick returns */

if (*info != 0) {
/* 如果 info 不等于 0，则执行以下操作。 */

i__1 = -(*info);
xerbla_("CGESDD", &i__1);
/* 调用 xerbla 函数报告错误。 */

return 0;
/* 返回 0，结束函数。 */
}

if (*lwork == -1) {
/* 如果 lwork 等于 -1，则执行以下操作。 */

return 0;
/* 返回 0，结束函数。 */
}

if (*m == 0 || *n == 0) {
/* 如果 m 等于 0 或 n 等于 0，则执行以下操作。 */

return 0;
/* 返回
    # 调用 `slamch_` 函数，获取机器精度参数 `eps`，通常表示最小正数与1之间的最小距离
    eps = slamch_("P");
    
    # 调用 `slamch_` 函数，获取机器精度参数 `S`，计算其平方根，然后除以 `eps`，得到小数值 `smlnum`
    smlnum = sqrt(slamch_("S")) / eps;
    
    # 计算大数值 `bignum`，其为 `1` 与 `smlnum` 的倒数
    bignum = 1.f / smlnum;
/*     根据矩阵的最大元素是否在指定范围之外对矩阵 A 进行缩放 */

anrm = clange_("M", m, n, &a[a_offset], lda, dum);
// 计算矩阵 A 的最大范数，M 表示使用一致无穷大范数
iscl = 0;
if (anrm > 0.f && anrm < smlnum) {
    iscl = 1;
    // 若 anrm 在 (0, smlnum) 范围内，则进行缩放
    clascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, &ierr);
} else if (anrm > bignum) {
    iscl = 1;
    // 若 anrm 大于 bignum，则进行缩放
    clascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, &ierr);
}

if (*m >= *n) {

/*
          A 至少有和列数相等的行数。如果 A 的行数比列数多得足够多，可以使用 QR 分解
          （如果有足够的工作空间的话）
*/

    if (*m >= mnthr1) {

        if (wntqn) {

/*
                Path 1 (M 远大于 N，JOBZ='N')
                不需要计算奇异向量
*/

        itau = 1;
        nwork = itau + *n;

/*
                计算 A=Q*R
                (CWorkspace: 需要 2*N，更倾向于 N+N*NB)
                (RWorkspace: 需要 0)
*/

        i__1 = *lwork - nwork + 1;
        cgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);

/*              将 R 的下方置零 */

        i__1 = *n - 1;
        i__2 = *n - 1;
        claset_("L", &i__1, &i__2, &c_b56, &c_b56, &a[a_dim1 + 2],
            lda);
        ie = 1;
        itauq = 1;
        itaup = itauq + *n;
        nwork = itaup + *n;

/*
                对 A 中的 R 进行双对角化
                (CWorkspace: 需要 3*N，更倾向于 2*N+2*N*NB)
                (RWorkspace: 需要 N)
*/

        i__1 = *lwork - nwork + 1;
        cgebrd_(n, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);
        nrwork = ie + *n;

/*
                执行双对角 SVD，仅计算奇异值
                (CWorkspace: 0)
                (RWorkspace: 需要 BDSPAN)
*/

        sbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

        } else if (wntqo) {

/*
                Path 2 (M 远大于 N，JOBZ='O')
                需要在 A 上覆盖 N 个左奇异向量，并在 VT 中计算 N 个右奇异向量
*/

        iu = 1;

/*              WORK(IU) 是 N*N 的矩阵 */

        ldwrku = *n;
        ir = iu + ldwrku * *n;
        if (*lwork >= *m * *n + *n * *n + *n * 3) {

/*                 WORK(IR) 是 M*N 的矩阵 */

            ldwrkr = *m;
        } else {
            ldwrkr = (*lwork - *n * *n - *n * 3) / *n;
        }
        itau = ir + ldwrkr * *n;
        nwork = itau + *n;

/*
                计算 A=Q*R
                (CWorkspace: 需要 N*N+2*N，更倾向于 M*N+N+N*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        cgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);
/*              将矩阵 A 的上三角部分复制到 WORK(IR)，下三角部分清零 */

        clacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
        // 复制矩阵 A 的上三角到 WORK(IR)，使用 'U' 表示复制上三角
        // n 是矩阵的维度，a 是输入矩阵 A，work 是目标工作区域，ir 是工作区索引
        // lda 是矩阵 A 的列数
        i__1 = *n - 1;
        i__2 = *n - 1;
        claset_("L", &i__1, &i__2, &c_b56, &c_b56, &work[ir + 1], &
            ldwrkr);
        // 设置 WORK(IR) 的下三角部分为零矩阵
        // 使用 'L' 表示设置下三角，i__1 和 i__2 分别是行和列的维度
        // c_b56 是常量，表示零
        // ir + 1 是下三角的起始位置，ldwrkr 是工作区的列数

/*
                在矩阵 A 中生成 Q
                (CWorkspace: 需要 2*N，更喜欢 N+N*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        cungqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__1, &ierr);
        // 生成 Q 矩阵，存储在 A 中
        // m 是矩阵 A 的行数，n 是列数
        // a 是输入矩阵 A，work[itau] 是工作数组，nwork 是工作区域索引
        // lwork 是工作区域的长度，ierr 是错误码

        ie = 1;
        itauq = itau;
        itaup = itauq + *n;
        nwork = itaup + *n;

/*
                在 WORK(IR) 中将 R 矩阵进行双对角化
                (CWorkspace: 需要 N*N+3*N，更喜欢 M*N+2*N+2*N*NB)
                (RWorkspace: 需要 N)
*/

        i__1 = *lwork - nwork + 1;
        cgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);
        // 对 WORK(IR) 中的矩阵进行双对角化
        // n 是矩阵维度，work[ir] 是输入工作区域，ldwrkr 是工作区的列数
        // s 是输出的对角线元素，rwork[ie] 是工作区的实数部分
        // itauq, itaup 是工作数组的索引，nwork 是工作区域索引

/*
                执行双对角 SVD，计算 R 的左奇异向量存储在 WORK(IRU)，
                右奇异向量存储在 WORK(IRVT)
                (CWorkspace: 需要 0)
                (RWorkspace: 需要 BDSPAC)
*/

        iru = ie + *n;
        irvt = iru + *n * *n;
        nrwork = irvt + *n * *n;
        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);
        // 执行双对角 SVD 分解
        // n 是矩阵的维度，s 是输入的对角线元素
        // rwork 和 iwork 是工作区域，info 是输出的信息码

/*
                将实数矩阵 RWORK(IRU) 复制到复数矩阵 WORK(IU)
                重写 WORK(IU) 为 R 的左奇异向量
                (CWorkspace: 需要 2*N*N+3*N，更喜欢 M*N+N*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
        // 将实数矩阵复制到复数矩阵
        // 'F' 表示复制整个矩阵，n 是矩阵的维度
        i__1 = *lwork - nwork + 1;
        cunmbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
            itauq], &work[iu], &ldwrku, &work[nwork], &i__1, &
            ierr);
        // 生成 Q 矩阵，并存储在 WORK(IU) 中
        // 'Q' 表示生成 Q 矩阵，'L' 表示左乘矩阵，n 是矩阵的维度
        // work[ir] 是输入的工作区域，itauq 是工作数组索引，work[iu] 是输出的矩阵

/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                重写 VT 为 R 的右奇异向量
                (CWorkspace: 需要 N*N+3*N，更喜欢 M*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 将实数矩阵复制到复数矩阵 VT
        // 'F' 表示复制整个矩阵，n 是矩阵的维度
        i__1 = *lwork - nwork + 1;
        cunmbr_("P", "R", "C", n, n, n, &work[ir], &ldwrkr, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        // 生成 P 矩阵，并存储在 VT 中
        // 'P' 表示生成 P 矩阵，'R' 表示右乘矩阵，'C' 表示共轭转置
        // work[ir] 是输入的工作区域，itaup 是工作数组索引，vt 是输出的矩阵

/*
                将 A 中的 Q 矩阵与 R 的左奇异向量在 WORK(IU) 中相乘，
                将结果存储在 WORK(IR) 中并复制到 A 中
                (CWorkspace: 需要 2*N*N，更喜欢 N*N+M*N)
                (RWorkspace: 0)
*/

        i__1 = *m;
        i__2 = ldwrkr;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
            i__2) {
        // 循环计算矩阵乘法，按块处理
/* Computing MIN */
            i__3 = *m - i__ + 1;  // 计算用于当前循环迭代的有效行数
            chunk = min(i__3,ldwrkr);  // 计算本次循环迭代的实际处理行数，取i__3和ldwrkr的较小值
            cgemm_("N", "N", &chunk, n, n, &c_b57, &a[i__ + a_dim1],
                lda, &work[iu], &ldwrku, &c_b56, &work[ir], &
                ldwrkr);  // 执行矩阵乘法运算：计算 A[i__:i__+chunk-1, :] * work[iu:iu+ldwrku-1, :] 并将结果存储在 work[ir:ir+chunk-1, :]
            clacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ +
                a_dim1], lda);  // 复制工作区中的数据到矩阵 A 中的相应位置
/* L10: */
        }

        } else if (wntqs) {

/*
                Path 3 (M much larger than N, JOBZ='S')
                N left singular vectors to be computed in U and
                N right singular vectors to be computed in VT
*/

        ir = 1;  // 设置工作区索引 IR 为 1

/*              WORK(IR) is N by N */

        ldwrkr = *n;  // 设置工作区行数 LDWRKR 为输入参数 n
        itau = ir + ldwrkr * *n;  // 计算 ITAU 的起始位置
        nwork = itau + *n;  // 计算额外工作区域的起始位置

/*
                Compute A=Q*R
                (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                (RWorkspace: 0)
*/

        i__2 = *lwork - nwork + 1;  // 计算可用的工作区长度
        cgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);  // 执行 QR 分解，计算矩阵 A 的 QR 分解并存储在 A 中

/*              Copy R to WORK(IR), zeroing out below it */

        clacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);  // 复制矩阵 A 的上三角部分到工作区 IR 中
        i__2 = *n - 1;
        i__1 = *n - 1;
        claset_("L", &i__2, &i__1, &c_b56, &c_b56, &work[ir + 1], &
            ldwrkr);  // 将工作区 IR 的下三角部分置零

/*
                Generate Q in A
                (CWorkspace: need 2*N, prefer N+N*NB)
                (RWorkspace: 0)
*/

        i__2 = *lwork - nwork + 1;
        cungqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__2, &ierr);  // 从 QR 分解中生成矩阵 Q 并存储在 A 中
        ie = 1;
        itauq = itau;
        itaup = itauq + *n;
        nwork = itaup + *n;

/*
                Bidiagonalize R in WORK(IR)
                (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                (RWorkspace: need N)
*/

        i__2 = *lwork - nwork + 1;
        cgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);  // 对工作区 IR 中的矩阵进行双对角化处理

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *n;  // 计算工作区 IRU 的起始位置
        irvt = iru + *n * *n;  // 计算工作区 IRVT 的起始位置
        nrwork = irvt + *n * *n;  // 计算额外的实数工作区起始位置
        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);  // 执行双对角奇异值分解，计算左奇异向量和右奇异向量

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of R
                (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", n, n, &rwork[iru], n, &u[u_offset], ldu);  // 复制实数工作区 IRU 中的数据到复数矩阵 U 中
        i__2 = *lwork - nwork + 1;
        cunmbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);  // 从 QR 分解中生成左奇异向量并存储在矩阵 U 中
/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                用矩阵 R 的右奇异向量覆盖 VT
                (CWorkspace: 需要 N*N+3*N，最好 N*N+2*N+N*NB)
                (RWorkspace: 0)
*/

clacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", n, n, n, &work[ir], &ldwrkr, &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);

/*
                将矩阵 A 中的 Q 乘以 R 的左奇异向量，结果存储在 U 中
                (CWorkspace: 需要 N*N)
                (RWorkspace: 0)
*/

clacpy_("F", n, n, &u[u_offset], ldu, &work[ir], &ldwrkr);
cgemm_("N", "N", m, n, n, &c_b57, &a[a_offset], lda, &work[ir], &ldwrkr, &c_b56, &u[u_offset], ldu);

} else if (wntqa) {

/*
                路径 4 (M 远大于 N，JOBZ='A')
                在 U 中计算 M 个左奇异向量，在 VT 中计算 N 个右奇异向量
*/

iu = 1;

/*              WORK(IU) 是一个 N*N 的矩阵 */

ldwrku = *n;
itau = iu + ldwrku * *n;
nwork = itau + *n;

/*
                计算 A=Q*R，并将结果复制到 U 中
                (CWorkspace: 需要 2*N，最好 N+N*NB)
                (RWorkspace: 0)
*/

i__2 = *lwork - nwork + 1;
cgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);
clacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);

/*
                在 U 中生成 Q
                (CWorkspace: 需要 N+M，最好 N+M*NB)
                (RWorkspace: 0)
*/

i__2 = *lwork - nwork + 1;
cungqr_(m, m, n, &u[u_offset], ldu, &work[itau], &work[nwork], &i__2, &ierr);

/*              在 A 中生成 R，并将其下方置零 */

i__2 = *n - 1;
i__1 = *n - 1;
claset_("L", &i__2, &i__1, &c_b56, &c_b56, &a[a_dim1 + 2], lda);
ie = 1;
itauq = itau;
itaup = itauq + *n;
nwork = itaup + *n;

/*
                对 A 中的 R 进行双对角化
                (CWorkspace: 需要 3*N，最好 2*N+2*N*NB)
                (RWorkspace: 需要 N)
*/

i__2 = *lwork - nwork + 1;
cgebrd_(n, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);
iru = ie + *n;
irvt = iru + *n * *n;
nrwork = irvt + *n * *n;

/*
                执行双对角 SVD，计算双对角矩阵的左奇异向量在 RWORK(IRU) 中，
                计算右奇异向量在 RWORK(IRVT) 中
                (CWorkspace: 需要 0)
                (RWorkspace: 需要 BDSPAC)
*/

sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);
/*
                将实数矩阵 RWORK(IRU) 复制到复数矩阵 WORK(IU)
                使用 R 的左奇异向量覆盖 WORK(IU)
                (CWorkspace: 需要 N*N+3*N，更倾向于 N*N+2*N+N*NB)
                (RWorkspace: 0)
*/
clacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
i__2 = *lwork - nwork + 1;
cunmbr_("Q", "L", "N", n, n, n, &a[a_offset], lda, &work[
    itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &
    ierr);

/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                使用 R 的右奇异向量覆盖 VT
                (CWorkspace: 需要 3*N，更倾向于 2*N+N*NB)
                (RWorkspace: 0)
*/
clacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

/*
                使用 WORK(IU) 中 R 的左奇异向量乘以 U 中的 Q，结果存储在 A 中
                (CWorkspace: 需要 N*N)
                (RWorkspace: 0)
*/
cgemm_("N", "N", m, n, n, &c_b57, &u[u_offset], ldu, &work[iu]
    , &ldwrku, &c_b56, &a[a_offset], lda);

/*
                将 A 中的左奇异向量复制到 U 中
*/
clacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
}

} else if (*m >= mnthr2) {

/*
             MNTHR2 <= M < MNTHR1

             Path 5 (M 比 N 大得多，但不像 MNTHR1 那样大)
             将 A 降为双对角形式，不使用 QR 分解，使用 CUNGBR 和矩阵乘法计算奇异向量
*/

ie = 1;
nrwork = ie + *n;
itauq = 1;
itaup = itauq + *n;
nwork = itaup + *n;

/*
             对 A 进行双对角化
             (CWorkspace: 需要 2*N+M，更倾向于 2*N+(M+N)*NB)
             (RWorkspace: 需要 N)
*/
i__2 = *lwork - nwork + 1;
cgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
    &work[itaup], &work[nwork], &i__2, &ierr);
if (wntqn) {

/*
                只计算奇异值
                (CWorkspace: 0)
                (RWorkspace: 需要 BDSPAN)
*/
sbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &
    c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
} else if (wntqo) {
iu = nwork;
iru = nrwork;
irvt = iru + *n * *n;
nrwork = irvt + *n * *n;

/*
                复制 A 到 VT，生成 P**H
                (CWorkspace: 需要 2*N，更倾向于 N+N*NB)
                (RWorkspace: 0)
*/
clacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
cungbr_("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &
    work[nwork], &i__2, &ierr);

/*
                在 A 中生成 Q
                (CWorkspace: 需要 2*N，更倾向于 N+N*NB)
                (RWorkspace: 0)
*/
        i__2 = *lwork - nwork + 1;
        cungbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &work[
            nwork], &i__2, &ierr);


        # 调用 LAPACK 函数 cungbr_，使用 Q 矩阵生成单位正交/酉矩阵，用于计算左奇异向量
        # 参数说明：
        # - "Q": 指定生成的正交/酉矩阵的类型为 Q
        # - m, n, n: 矩阵的行数、列数以及 Q 矩阵的列数
        # - &a[a_offset], lda: 输入矩阵 A 及其 leading dimension
        # - &work[itauq], &work[nwork], &i__2, &ierr: LAPACK 所需的工作空间及错误信息输出


        if (*lwork >= *m * *n + *n * 3) {


            # 若可用工作空间足够大以存放矩阵的复制，则执行以下代码块
            ldwrku = *m;


        } else {


            # 若工作空间不够大，执行以下代码块
            ldwrku = (*lwork - *n * 3) / *n;


        nwork = iu + ldwrku * *n;


            # 计算需要的工作空间大小并更新 nwork


        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);


        # 调用 LAPACK 函数 sbdsdc_，执行对角化 SVD，计算奇异值和左右奇异向量
        # 参数说明：
        # - "U": 指示仅计算右奇异向量
        # - "I": 指示求解过程使用带内插的 Jacobi 过程
        # - n: 矩阵的阶数
        # - &s[1]: 奇异值数组
        # - &rwork[ie], &rwork[iru], &rwork[irvt]: 工作空间
        # - n: 工作空间数组的长度
        # - dum, idum: 临时变量数组
        # - &rwork[nrwork], &iwork[1]: 工作空间和整型工作数组
        # - info: 返回的状态信息


        clarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &work[iu]
            , &ldwrku, &rwork[nrwork]);
        clacpy_("F", n, n, &work[iu], &ldwrku, &vt[vt_offset], ldvt);


        # 调用 LAPACK 函数 clarcm_ 和 clacpy_，对右奇异向量矩阵 VT 进行转置乘法并复制
        # 参数说明：
        # - n, n: 矩阵的行数和列数
        # - &rwork[irvt]: 右奇异向量的存储位置
        # - &vt[vt_offset], ldvt: 输出矩阵 VT 及其 leading dimension
        # - &work[iu], &ldwrku: 工作数组和其 leading dimension
        # - &rwork[nrwork]: 工作空间


        nrwork = irvt;
        i__2 = *m;
        i__1 = ldwrku;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
            i__1) {


            # 循环对左奇异向量矩阵 A 进行转置乘法和复制
            # 参数说明：
            # - &a[i__ + a_dim1], lda: 输入矩阵 A 及其 leading dimension
            # - &rwork[iru]: 左奇异向量的存储位置
            # - &work[iu], &ldwrku: 工作数组和其 leading dimension
            # - &rwork[nrwork]: 工作空间


        } else if (wntqs) {


            # 如果 wntqs 为真，执行以下代码块


        clacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
        i__1 = *lwork - nwork + 1;
        cungbr_("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &
            work[nwork], &i__1, &ierr);


        # 调用 LAPACK 函数 clacpy_ 和 cungbr_，将矩阵 A 复制到 VT 并生成 P**H
        # 参数说明：
        # - "U": 指示复制 A 的上三角部分到 VT
        # - n, n: 矩阵的行数和列数
        # - &a[a_offset], lda: 输入矩阵 A 及其 leading dimension
        # - &vt[vt_offset], ldvt: 输出矩阵 VT 及其 leading dimension
        # - &work[itaup], &work[nwork], &i__1, &ierr: 工作空间和错误信息输出


        clacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        i__1 = *lwork - nwork + 1;
        cungbr_("Q", m, n, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);


        # 调用 LAPACK 函数 clacpy_ 和 cungbr_，将矩阵 A 复制到 U 并生成 Q
        # 参数说明：
        # - "L": 指示复制 A 的下三角部分到 U
        # - m, n, n: 矩阵的行数、列数以及 Q 矩阵的列数
        # - &u[u_offset], ldu: 输出矩阵 U 及其 leading dimension
        # - &work[itauq], &work[nwork], &i__1, &ierr: 工作空间和错误信息输出
/*
        iru = nrwork;
        irvt = iru + *n * *n;
        nrwork = irvt + *n * *n;
        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

                Perform singular value decomposition (SVD) of a bidiagonal matrix
                using divide and conquer method. Compute singular values in S,
                and optionally compute the left and right singular vectors stored
                in RWORK(IRU) and RWORK(IRVT), respectively.
                (CWorkspace: 0)
                (RWorkspace: need BDSPAC)
*/

        clarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);

/*
                Multiply real matrix RWORK(IRVT) by the conjugate transpose of P
                (P**H) in VT, storing the result in A, and then copy to VT.
                (Cworkspace: need 0)
                (Rworkspace: need 3*N*N)
*/

        clacpy_("F", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

/*
                Copy matrix A to VT, used in subsequent computation of P**H.
                (Cworkspace: 0)
                (Rworkspace: 0)
*/

        clacpy_("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

/*
                Multiply Q in U by real matrix RWORK(IRU), storing the
                result in A, and then copy to U.
                (CWorkspace: 0)
                (Rworkspace: need 3*N*N)
*/

        clacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);

/*
                Copy matrix A to U, used in subsequent computation of Q.
                (Cworkspace: 0)
                (Rworkspace: 0)
*/

        clacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);

/*
                Perform singular value decomposition (SVD) of a bidiagonal matrix
                using divide and conquer method. Compute singular values in S,
                and optionally compute the left and right singular vectors stored
                in RWORK(IRU) and RWORK(IRVT), respectively.
                (CWorkspace: 0)
                (RWorkspace: need BDSPAC)
*/

        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Multiply real matrix RWORK(IRVT) by the conjugate transpose of P
                (P**H) in VT, storing the result in A, and then copy to VT.
                (Cworkspace: 0)
                (Rworkspace: need 3*N*N)
*/

        clarcm_(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[
            a_offset], lda, &rwork[nrwork]);

/*
                Multiply Q in U by real matrix RWORK(IRU), storing the
                result in A, and then copy to U.
                (CWorkspace: 0)
                (Rworkspace: need 3*N*N)
*/
        nrwork = irvt;
        // 设置 nrwork 为 irvt，用于存储右奇异向量的工作空间

        clacrm_(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset],
             lda, &rwork[nrwork]);
        // 调用 clacrm 函数，将 A 的复制存储在 u 中，同时计算所需的工作空间

        clacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
        // 复制 A 到 u

        }
    } else {

/*
             M .LT. MNTHR2

             Path 6 (M at least N, but not much larger)
             Reduce to bidiagonal form without QR decomposition
             Use CUNMBR to compute singular vectors
*/

        ie = 1;
        // 设置 ie 为 1，表示 rwork 数组的起始索引

        nrwork = ie + *n;
        // 计算 nrwork，用于存储右奇异向量计算的工作空间索引

        itauq = 1;
        // 设置 itauq 为 1，表示存储左奇异向量计算所需的工作空间的起始索引

        itaup = itauq + *n;
        // 计算 itaup，表示存储右奇异向量计算所需的工作空间的起始索引

        nwork = itaup + *n;
        // 计算 nwork，表示存储其他工作空间所需的起始索引

/*
             Bidiagonalize A
             (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
             (RWorkspace: need N)
*/

        i__1 = *lwork - nwork + 1;
        // 计算剩余工作空间的大小

        cgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, &ierr);
        // 调用 cgebrd 函数，将 A 变为双对角矩阵，并计算奇异值和奇异向量

        if (wntqn) {

/*
                Compute singular values only
                (Cworkspace: 0)
                (Rworkspace: need BDSPAN)
*/

        sbdsdc_("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
        // 调用 sbdsdc 函数，计算 A 的奇异值，不计算奇异向量

        } else if (wntqo) {
        iu = nwork;
        // 设置 iu 为存储左奇异向量计算的工作空间的起始索引

        iru = nrwork;
        // 设置 iru 为存储右奇异向量计算的工作空间的起始索引

        irvt = iru + *n * *n;
        // 计算 irvt，用于存储右奇异向量计算的工作空间的起始索引

        nrwork = irvt + *n * *n;
        // 更新 nrwork，表示存储其他工作空间所需的起始索引

        if (*lwork >= *m * *n + *n * 3) {

/*                 WORK( IU ) is M by N */

            ldwrku = *m;
        } else {

/*                 WORK( IU ) is LDWRKU by N */

            ldwrku = (*lwork - *n * 3) / *n;
        }
        // 根据工作空间的大小设置 ldwrku，用于存储左奇异向量计算的工作空间的行数

        nwork = iu + ldwrku * *n;

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by right singular vectors of A
                (Cworkspace: need 2*N, prefer N+N*NB)
                (Rworkspace: need 0)
*/

        clacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT

        i__1 = *lwork - nwork + 1;
        // 计算剩余工作空间的大小

        cunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);

        if (*lwork >= *m * *n + *n * 3) {

/*
                Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                Overwrite WORK(IU) by left singular vectors of A, copying
                to A
                (Cworkspace: need M*N+2*N, prefer M*N+N+N*NB)
                (Rworkspace: need 0)
*/
            cl`
            claset_("F", m, n, &c_b56, &c_b56, &work[iu], &ldwrku);
            // 初始化工作区中的部分矩阵为零
            clacp2_("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
            // 将实数矩阵 RWORK(IRU) 复制到复数矩阵 WORK(IU)
            i__1 = *lwork - nwork + 1;
            // 计算剩余可用工作区大小
            cunmbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
                itauq], &work[iu], &ldwrku, &work[nwork], &i__1, &
                ierr);
            // 生成左侧矩阵 Q 并存储在 WORK(IU)，然后将其乘以 A 并复制回 A
            clacpy_("F", m, n, &work[iu], &ldwrku, &a[a_offset], lda);
            // 将工作区中的矩阵复制回 A
        } else {

/*
                   生成 A 中的矩阵 Q
                   (Cworkspace: 需要 2*N，更喜欢 N+N*NB)
                   (Rworkspace: 需要 0)
*/

            i__1 = *lwork - nwork + 1;
            // 计算剩余可用工作区大小
            cungbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &
                work[nwork], &i__1, &ierr);

/*
                   将 A 中的矩阵 Q 乘以实数矩阵 RWORK(IRU)，结果存储在 WORK(IU)，然后复制回 A
                   (CWorkspace: 需要 N*N，更喜欢 M*N)
                   (Rworkspace: 需要 3*N*N，更喜欢 N*N+2*M*N)
*/

            nrwork = irvt;
            // 更新 RWORK 索引以便使用右奇异向量
            i__1 = *m;
            i__2 = ldwrku;
            // 循环计算 A 中乘积的每个块
            for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
                 i__2) {
/* Computing MIN */
            i__3 = *m - i__ + 1;
            chunk = min(i__3,ldwrku);
            // 将 A 中的块乘以 RWORK(IRU)，结果存储在 WORK(IU)，然后复制回 A
            clacrm_(&chunk, n, &a[i__ + a_dim1], lda, &rwork[iru],
                 n, &work[iu], &ldwrku, &rwork[nrwork]);
            clacpy_("F", &chunk, n, &work[iu], &ldwrku, &a[i__ +
                a_dim1], lda);
/* L30: */
            }
        }

        } else if (wntqs) {

/*
                执行双对角奇异值分解（SVD），计算双对角矩阵的左奇异向量存储在 RWORK(IRU) 中，右奇异向量存储在 RWORK(IRVT) 中
                (CWorkspace: 需要 0)
                (RWorkspace: 需要 BDSPAC)
*/

        iru = nrwork;
        irvt = iru + *n * *n;
        // 调用 LAPACK 中的双对角奇异值分解函数 SBDSDC
        nrwork = irvt + *n * *n;
        sbdsdc_("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n, &
            rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                将实数矩阵 RWORK(IRU) 复制到复数矩阵 U
                使用 A 中的左奇异向量覆盖 U
                (CWorkspace: 需要 3*N，更喜欢 2*N+N*NB)
                (RWorkspace: 0)
*/

        claset_("F", m, n, &c_b56, &c_b56, &u[u_offset], ldu);
        // 初始化 U 矩阵中的部分矩阵为零
        clacp2_("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
        // 将实数矩阵 RWORK(IRU) 复制到复数矩阵 U
        i__2 = *lwork - nwork + 1;
        // 计算剩余可用工作区大小
        cunmbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                使用 A 中的右奇异向量覆盖 VT
                (CWorkspace: 需要 3*N，更喜欢 2*N+N*NB)
                (RWorkspace: 0)
*/
        clacp2_("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
        // 将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
        // 将 VT 覆盖为 A 的右奇异向量
        // (CWorkspace: 需要 3*N，优先 2*N+N*NB)
        // (RWorkspace: 0)

        i__2 = *lwork - nwork + 1;
        // 计算剩余可用工作空间大小

        cunmbr_("P", "R", "C", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);
        // 根据给定的 A，应用 MBR 转换来计算右奇异向量
        // (CWorkspace: 需要 3*N，优先 2*N+N*NB)
        // (RWorkspace: 0)
/*              Zero out above L */
/* 将 L 的上方元素置零 */

        i__2 = *m - 1;
        i__1 = *m - 1;
        claset_("U", &i__2, &i__1, &c_b56, &c_b56, &a[(a_dim1 << 1) +
            1], lda);
        /* 初始化矩阵 A 的上三角部分为零 */

        ie = 1;
        itauq = 1;
        itaup = itauq + *m;
        nwork = itaup + *m;
        /* 设置工作区域的起始索引和大小 */

/*
                Bidiagonalize L in A
                (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                (RWorkspace: need M)
*/
/* 在 A 中对 L 进行双对角化 */
/* (CWorkspace: 需要 3*M，最好是 2*M+2*M*NB)
   (RWorkspace: 需要 M) */

        i__2 = *lwork - nwork + 1;
        cgebrd_(m, m, &a[a_offset], lda, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
        /* 对矩阵 A 中的 L 进行双对角化，并存储结果 */

        nrwork = ie + *m;
        /* 更新实数工作区域的大小 */

/*
                Perform bidiagonal SVD, compute singular values only
                (CWorkspace: 0)
                (RWorkspace: need BDSPAN)
*/
/* 执行双对角 SVD 分解，仅计算奇异值 */
/* (CWorkspace: 0)
   (RWorkspace: 需要 BDSPAN) */

        sbdsdc_("U", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

        } else if (wntqo) {

/*
                Path 2t (N much larger than M, JOBZ='O')
                M right singular vectors to be overwritten on A and
                M left singular vectors to be computed in U
*/
/* 选取 Path 2t（当 N 远大于 M，且 JOBZ='O'） */
/* M 个右奇异向量将覆盖在 A 上，且 M 个左奇异向量将在 U 中计算 */

        ivt = 1;
        ldwkvt = *m;

/*              WORK(IVT) is M by M */
/* WORK(IVT) 是 M 行 M 列 */

        il = ivt + ldwkvt * *m;
        if (*lwork >= *m * *n + *m * *m + *m * 3) {

/*                 WORK(IL) M by N */
/* WORK(IL) 是 M 行 N 列 */

            ldwrkl = *m;
            chunk = *n;
        } else {

/*                 WORK(IL) is M by CHUNK */
/* WORK(IL) 是 M 行 CHUNK 列 */

            ldwrkl = *m;
            chunk = (*lwork - *m * *m - *m * 3) / *m;
        }
        itau = il + ldwrkl * chunk;
        nwork = itau + *m;

/*
                Compute A=L*Q
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/
/* 计算 A = L * Q */
/* (CWorkspace: 需要 2*M，最好是 M+M*NB)
   (RWorkspace: 0) */

        i__2 = *lwork - nwork + 1;
        cgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);
        /* 使用 GELQF 进行 LQ 分解，计算矩阵 A */

/*              Copy L to WORK(IL), zeroing about above it */
/* 将 L 复制到 WORK(IL)，并将其上方置零 */

        clacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
        /* 复制矩阵 A 的下三角部分到 WORK(IL) */

        i__2 = *m - 1;
        i__1 = *m - 1;
        claset_("U", &i__2, &i__1, &c_b56, &c_b56, &work[il + ldwrkl],
             &ldwrkl);
        /* 将 WORK(IL) 的上三角部分置零 */

/*
                Generate Q in A
                (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                (RWorkspace: 0)
*/
/* 在 A 中生成 Q */
/* (CWorkspace: 需要 M*M+2*M，最好是 M*M+M+M*NB)
   (RWorkspace: 0) */

        i__2 = *lwork - nwork + 1;
        cunglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
             &i__2, &ierr);
        /* 使用 UNGLQ 生成 Q */

        ie = 1;
        itauq = itau;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
                Bidiagonalize L in WORK(IL)
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/
/* 在 WORK(IL) 中对 L 进行双对角化 */
/* (CWorkspace: 需要 M*M+3*M，最好是 M*M+2*M+2*M*NB)
   (RWorkspace: 需要 M) */

        i__2 = *lwork - nwork + 1;
        cgebrd_(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
        /* 对 WORK(IL) 中的 L 进行双对角化，并存储结果 */
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *m;
        irvt = iru + *m * *m;
        nrwork = irvt + *m * *m;
        sbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                Overwrite WORK(IU) by the left singular vectors of L
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
        i__2 = *lwork - nwork + 1;
        cunmbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by the right singular vectors of L
                (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
        i__2 = *lwork - nwork + 1;
        cunmbr_("P", "R", "C", m, m, m, &work[il], &ldwrkl, &work[
            itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &
            ierr);

/*
                Multiply right singular vectors of L in WORK(IL) by Q
                in A, storing result in WORK(IL) and copying to A
                (CWorkspace: need 2*M*M, prefer M*M+M*N))
                (RWorkspace: 0)
*/

        i__2 = *n;
        i__1 = chunk;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
            i__1) {
/* Computing MIN */
            i__3 = *n - i__ + 1;
            blk = min(i__3,chunk);
            cgemm_("N", "N", m, &blk, m, &c_b57, &work[ivt], m, &a[
                i__ * a_dim1 + 1], lda, &c_b56, &work[il], &
                ldwrkl);
            clacpy_("F", m, &blk, &work[il], &ldwrkl, &a[i__ * a_dim1
                + 1], lda);
/* L40: */
        }

        } else if (wntqs) {

/*
               Path 3t (N much larger than M, JOBZ='S')
               M right singular vectors to be computed in VT and
               M left singular vectors to be computed in U
*/

        il = 1;

/*              WORK(IL) is M by M */

        ldwrkl = *m;
        itau = il + ldwrkl * *m;
        nwork = itau + *m;

/*
                Compute A=L*Q
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        cgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);
/*              Copy L to WORK(IL), zeroing out above it */

/* 将 L 复制到 WORK(IL)，并将其上面的部分清零 */
clacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);

/* Zero out the upper triangle of WORK(IL) */
i__1 = *m - 1;
i__2 = *m - 1;
claset_("U", &i__1, &i__2, &c_b56, &c_b56, &work[il + ldwrkl],
       &ldwrkl);

/*
                Generate Q in A
                (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                (RWorkspace: 0)
*/

/* 在 A 中生成 Q
   (CWorkspace 需要 M*M+2*M, 最好 M*M+M+M*NB)
   (RWorkspace: 0) */
i__1 = *lwork - nwork + 1;
cunglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
       &i__1, &ierr);
ie = 1;
itauq = itau;
itaup = itauq + *m;
nwork = itaup + *m;

/*
                Bidiagonalize L in WORK(IL)
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/

/* 在 WORK(IL) 中使 L 成为双对角矩阵
   (CWorkspace 需要 M*M+3*M, 最好 M*M+2*M+2*M*NB)
   (RWorkspace 需要 M) */
i__1 = *lwork - nwork + 1;
cgebrd_(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie], &work[itauq],
        &work[itaup], &work[nwork], &i__1, &ierr);

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

/* 执行双对角 SVD，计算双对角矩阵的左奇异向量存储在 RWORK(IRU)，
   右奇异向量存储在 RWORK(IRVT)
   (CWorkspace 需要 0)
   (RWorkspace 需要 BDSPAC) */
iru = ie + *m;
irvt = iru + *m * *m;
nrwork = irvt + *m * *m;
sbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
        rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
        info);

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/

/* 将实矩阵 RWORK(IRU) 复制到复矩阵 U
   用 L 的左奇异向量覆盖 U
   (CWorkspace 需要 M*M+3*M, 最好 M*M+2*M+M*NB)
   (RWorkspace: 0) */
clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
i__1 = *lwork - nwork + 1;
cunmbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
        itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

/*
                Copy real matrix RWORK(IRVT) to complex matrix VT
                Overwrite VT by left singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/

/* 将实矩阵 RWORK(IRVT) 复制到复矩阵 VT
   用 L 的左奇异向量覆盖 VT
   (CWorkspace 需要 M*M+3*M, 最好 M*M+2*M+M*NB)
   (RWorkspace: 0) */
clacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
i__1 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", m, m, m, &work[il], &ldwrkl, &work[
        itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
        ierr);

/*
                Copy VT to WORK(IL), multiply right singular vectors of L
                in WORK(IL) by Q in A, storing result in VT
                (CWorkspace: need M*M)
                (RWorkspace: 0)
*/

/* 将 VT 复制到 WORK(IL)，将 L 的右奇异向量乘以 Q 在 A 中，结果存储在 VT
   (CWorkspace 需要 M*M)
   (RWorkspace: 0) */
clacpy_("F", m, m, &vt[vt_offset], ldvt, &work[il], &ldwrkl);
cgemm_("N", "N", m, n, m, &c_b57, &work[il], &ldwrkl, &a[
        a_offset], lda, &c_b56, &vt[vt_offset], ldvt);

        } else if (wntqa) {
/*
                Path 9t (N much larger than M, JOBZ='A')
                N right singular vectors to be computed in VT and
                M left singular vectors to be computed in U
*/

        ivt = 1;

/*              WORK(IVT) is M by M */

        ldwkvt = *m;
        itau = ivt + ldwkvt * *m;
        nwork = itau + *m;

/*
                Compute A=L*Q, copying result to VT
                (CWorkspace: need 2*M, prefer M+M*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        cgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__1, &ierr);
        clacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

/*
                Generate Q in VT
                (CWorkspace: need M+N, prefer M+N*NB)
                (RWorkspace: 0)
*/

        i__1 = *lwork - nwork + 1;
        cunglq_(n, n, m, &vt[vt_offset], ldvt, &work[itau], &work[
            nwork], &i__1, &ierr);

/*              Produce L in A, zeroing out above it */

        i__1 = *m - 1;
        i__2 = *m - 1;
        claset_("U", &i__1, &i__2, &c_b56, &c_b56, &a[(a_dim1 << 1) +
            1], lda);
        ie = 1;
        itauq = itau;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
                Bidiagonalize L in A
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                (RWorkspace: need M)
*/

        i__1 = *lwork - nwork + 1;
        cgebrd_(m, m, &a[a_offset], lda, &s[1], &rwork[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__1, &ierr);

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/

        iru = ie + *m;
        irvt = iru + *m * *m;
        nrwork = irvt + *m * *m;
        sbdsdc_("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
            rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
            info);

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of L
                (CWorkspace: need 3*M, prefer 2*M+M*NB)
                (RWorkspace: 0)
*/

        clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
        i__1 = *lwork - nwork + 1;
        cunmbr_("Q", "L", "N", m, m, m, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by right singular vectors of L
                (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                (RWorkspace: 0)
*/
/*
        clacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
*/

        // 调用 LAPACK 子程序 clacp2_，将 rwork[irvt] 复制到 work[ivt]
        clacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);

/*
        i__1 = *lwork - nwork + 1;
        cunmbr_("P", "R", "C", m, m, m, &a[a_offset], lda, &work[
            itaup], &work[ivt], &ldwkvt, &work[nwork], &i__1, &
            ierr);
*/

        // 调用 LAPACK 子程序 cunmbr_，应用 Householder 变换生成矩阵 P**H 并存储在 A 中
        // 该过程涉及工作数组 work[itaup], work[ivt], work[nwork]
        i__1 = *lwork - nwork + 1;
        cunmbr_("P", "R", "C", m, m, m, &a[a_offset], lda, &work[itaup], &work[ivt], &ldwkvt, &work[nwork], &i__1, &ierr);

/*
        cgemm_("N", "N", m, n, m, &c_b57, &work[ivt], &ldwkvt, &vt[
            vt_offset], ldvt, &c_b56, &a[a_offset], lda);
*/

        // 调用 BLAS 子程序 cgemm_，计算 work[ivt] 和 vt 的矩阵乘积，并存储在 A 中
        // 结果矩阵的大小为 m × n
        cgemm_("N", "N", m, n, m, &c_b57, &work[ivt], &ldwkvt, &vt[vt_offset], ldvt, &c_b56, &a[a_offset], lda);

/*
        clacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
*/

        // 调用 LAPACK 子程序 clacpy_，复制矩阵 A 到矩阵 vt
        clacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

/*
        ie = 1;
        nrwork = ie + *m;
        itauq = 1;
        itaup = itauq + *m;
        nwork = itaup + *m;
*/

        // 初始化工作变量 ie, nrwork, itauq, itaup, nwork，用于后续的 LAPACK 子程序调用

/*
        i__1 = *lwork - nwork + 1;
        cgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
            &work[itaup], &work[nwork], &i__1, &ierr);
*/

        // 调用 LAPACK 子程序 cgebrd_，将矩阵 A 转化为其对角元为非负实数的双对角矩阵
        // 这个过程需要使用工作数组 work[itauq], work[itaup], work[nwork], rwork[ie]

/*
        sbdsdc_("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
            c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
*/

        // 调用 LAPACK 子程序 sbdsdc_，计算矩阵的奇异值，但不生成奇异向量

/*
        irvt = nrwork;
        iru = irvt + *m * *m;
        nrwork = iru + *m * *m;
        ivt = nwork;
*/

        // 初始化工作变量 irvt, iru, ivt，用于后续的 LAPACK 子程序调用

/*
        clacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
        i__1 = *lwork - nwork + 1;
        cungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
            nwork], &i__1, &ierr);
*/

        // 调用 LAPACK 子程序 clacpy_，复制矩阵 A 到矩阵 U
        // 调用 LAPACK 子程序 cungbr_，应用 Householder 变换生成矩阵 Q 并存储在 U 中

/*
        i__1 = *lwork - nwork + 1;
        cungbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &work[
            nwork], &i__1, &ierr);
*/

        // 调用 LAPACK 子程序 cungbr_，应用 Householder 变换生成矩阵 P**H 并存储在 A 中

/*
        if (*lwork >= *m * *n + *m * 3) {
*/

        // 检查是否有足够的工作空间来存储工作数组 ivt，根据不同情况分配工作空间

/*
            WORK( IVT ) is M by N
*/

            // 设置工作数组 ivt 的大小为 M × N

/*
            WORK( IVT ) is M by CHUNK
*/

            // 设置工作数组 ivt 的大小为 M × CHUNK
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Multiply Q in U by real matrix RWORK(IRVT)
                storing the result in WORK(IVT), copying to U
                (Cworkspace: need 0)
                (Rworkspace: need 2*M*M)
*/
clacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &work[ivt], &
    ldwkvt, &rwork[nrwork]);
clacpy_("F", m, m, &work[ivt], &ldwkvt, &u[u_offset], ldu);

/*
                Multiply RWORK(IRVT) by P**H in A, storing the
                result in WORK(IVT), copying to A
                (CWorkspace: need M*M, prefer M*N)
                (Rworkspace: need 2*M*M, prefer 2*M*N)
*/
nrwork = iru;
i__1 = *n;
i__2 = chunk;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
    i__2) {
    /* Computing MIN */
    i__3 = *n - i__ + 1;
    blk = min(i__3,chunk);
    clarcm_(m, &blk, &rwork[irvt], m, &a[i__ * a_dim1 + 1],
        lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
    clacpy_("F", m, &blk, &work[ivt], &ldwkvt, &a[i__ *
        a_dim1 + 1], lda);
    /* L50: */
}
} else if (wntqs) {

/*
                Copy A to U, generate Q
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: 0)
*/
clacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
i__2 = *lwork - nwork + 1;
cungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[
    nwork], &i__2, &ierr);

/*
                Copy A to VT, generate P**H
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: 0)
*/
clacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
i__2 = *lwork - nwork + 1;
cungbr_("P", m, n, m, &vt[vt_offset], ldvt, &work[itaup], &
    work[nwork], &i__2, &ierr);

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
irvt = nrwork;
iru = irvt + *m * *m;
nrwork = iru + *m * *m;
sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Multiply Q in U by real matrix RWORK(IRU), storing the
                result in A, copying to U
                (CWorkspace: need 0)
                (Rworkspace: need 3*M*M)
*/
/*
    Perform compact WY bidiagonalization of matrix A:
    - Computes compact WY representation of A using Householder transformations
    - A is overwritten by the bidiagonal matrix B
    - U and VT store orthogonal matrices Q and P**H respectively

    (Input/Output: A, U, VT)
    (Input: M, N, LDA, LDU, LDVT)
    (Workspace: RWORK(IRU), RWORK(IRVT), RWORK(IE), RWORK(NRWORK), WORK(ITAUQ), WORK(ITRUP))
*/

clacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset], lda, &rwork[nrwork]);
// Multiply Q in U by real matrix RWORK(IRU), storing the result in A, copying to U

clacpy_("F", m, m, &a[a_offset], lda, &u[u_offset], ldu);
// Copy the resulting matrix A to U

nrwork = iru;
// Update NRWORK pointer to IRU

clarcm_(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
// Multiply real matrix RWORK(IRVT) by P**H in VT, storing the result in A, copying to VT

clacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
// Copy the resulting matrix A to VT

} else {
/*
    Path when N <= M or when N > M but not significantly larger
    Perform bidiagonal SVD on A without LQ decomposition, using CUNGBR for singular vector computation

    (Input/Output: A, U, VT)
    (Input: M, N, LDA, LDU, LDVT, LWORK, IWORK)
    (Workspace: RWORK(IRU), RWORK(IRVT), RWORK(IE), WORK(ITAUQ), WORK(ITAUP), WORK(NWORK), IWORK)
*/

clacpy_("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
// Copy A to U

i__2 = *lwork - nwork + 1;
cungbr_("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__2, &ierr);
// Generate orthogonal matrix Q using CUNGBR

clacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
// Copy A to VT

i__2 = *lwork - nwork + 1;
cungbr_("P", n, n, m, &vt[vt_offset], ldvt, &work[itaup], &work[nwork], &i__2, &ierr);
// Generate orthogonal matrix P**H using CUNGBR

irvt = nrwork;
// Update IRVT pointer

iru = irvt + *m * *m;
// Update IRU pointer

nrwork = iru + *m * *m;
// Update NRWORK pointer

sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);
// Perform bidiagonal SVD on B, computing left and right singular vectors

clacrm_(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset], lda, &rwork[nrwork]);
// Multiply Q in U by real matrix RWORK(IRU), storing the result in A, copying to U

clacpy_("F", m, m, &a[a_offset], lda, &u[u_offset], ldu);
// Copy the resulting matrix A to U

clarcm_(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
// Multiply real matrix RWORK(IRVT) by P**H in VT, storing the result in A, copying to VT

clacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
// Copy the resulting matrix A to VT
}
/*
    End of subroutine
*/
/*
             Bidiagonalize A
             (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
             (RWorkspace: M)
*/
i__2 = *lwork - nwork + 1;
cgebrd_(m, n, &a[a_offset], lda, &s[1], &rwork[ie], &work[itauq],
    &work[itaup], &work[nwork], &i__2, &ierr);
if (wntqn) {

/*
                Compute singular values only
                (Cworkspace: 0)
                (Rworkspace: need BDSPAN)
*/
sbdsdc_("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum, &
    c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
} else if (wntqo) {
ldwkvt = *m;
ivt = nwork;
if (*lwork >= *m * *n + *m * 3) {

/*                 WORK( IVT ) is M by N */
claset_("F", m, n, &c_b56, &c_b56, &work[ivt], &ldwkvt);
nwork = ivt + ldwkvt * *n;
} else {

/*                 WORK( IVT ) is M by CHUNK */
chunk = (*lwork - *m * 3) / *m;
nwork = ivt + ldwkvt * chunk;
}

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in RWORK(IRU) and computing right
                singular vectors of bidiagonal matrix in RWORK(IRVT)
                (CWorkspace: need 0)
                (RWorkspace: need BDSPAC)
*/
irvt = nrwork;
iru = irvt + *m * *m;
nrwork = iru + *m * *m;
sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &
    rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1],
    info);

/*
                Copy real matrix RWORK(IRU) to complex matrix U
                Overwrite U by left singular vectors of A
                (Cworkspace: need 2*M, prefer M+M*NB)
                (Rworkspace: need 0)
*/
clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
i__2 = *lwork - nwork + 1;
cunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

if (*lwork >= *m * *n + *m * 3) {

/*
                Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                Overwrite WORK(IVT) by right singular vectors of A,
                copying to A
                (Cworkspace: need M*N+2*M, prefer M*N+M+M*NB)
                (Rworkspace: need 0)
*/
clacp2_("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
i__2 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", m, n, m, &a[a_offset], lda, &work[
    itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2,
    &ierr);
clacpy_("F", m, n, &work[ivt], &ldwkvt, &a[a_offset], lda);
} else {

/*
                   Generate P**H in A
                   (Cworkspace: need 2*M, prefer M+M*NB)
                   (Rworkspace: need 0)
*/
i__2 = *lwork - nwork + 1;
cungbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &
    work[nwork], &i__2, &ierr);
}
/*
   Multiply Q in A by real matrix RWORK(IRU), storing the
   result in WORK(IU), copying to A
   (CWorkspace: need M*M, prefer M*N)
   (Rworkspace: need 3*M*M, prefer M*M+2*M*N)
*/
nrwork = iru;  // 设置 nrwork 为 iru 的值，用于后续计算
i__2 = *n;  // 设置循环上限为 *n
i__1 = chunk;  // 设置每次循环的块大小为 chunk
for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {
    /* Computing MIN */
    i__3 = *n - i__ + 1;  // 计算可处理的剩余列数
    blk = min(i__3,chunk);  // blk 为 chunk 和剩余列数的最小值
    clarcm_(m, &blk, &rwork[irvt], m, &a[i__ * a_dim1 + 1], lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
    clacpy_("F", m, &blk, &work[ivt], &ldwkvt, &a[i__ * a_dim1 + 1], lda);  // 将结果复制回 A
    /* L60: */
}
} else if (wntqs) {
/*
   Perform bidiagonal SVD, computing left singular vectors
   of bidiagonal matrix in RWORK(IRU) and computing right
   singular vectors of bidiagonal matrix in RWORK(IRVT)
   (CWorkspace: need 0)
   (RWorkspace: need BDSPAC)
*/
irvt = nrwork;  // 设置 irvt 为 nrwork 的值
iru = irvt + *m * *m;  // 设置 iru 为 irvt 加上 *m * *m
nrwork = iru + *m * *m;  // 更新 nrwork 的值
sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);
/*
   Copy real matrix RWORK(IRU) to complex matrix U
   Overwrite U by left singular vectors of A
   (CWorkspace: need 3*M, prefer 2*M+M*NB)
   (RWorkspace: M*M)
*/
clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);  // 复制 RWORK(IRU) 到 U
i__1 = *lwork - nwork + 1;
cunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
/*
   Copy real matrix RWORK(IRVT) to complex matrix VT
   Overwrite VT by right singular vectors of A
   (CWorkspace: need 3*M, prefer 2*M+M*NB)
   (RWorkspace: M*M)
*/
claset_("F", m, n, &c_b56, &c_b56, &vt[vt_offset], ldvt);
clacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);  // 复制 RWORK(IRVT) 到 VT
i__1 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", m, n, m, &a[a_offset], lda, &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);
} else {
/*
   Perform bidiagonal SVD, computing left singular vectors
   of bidiagonal matrix in RWORK(IRU) and computing right
   singular vectors of bidiagonal matrix in RWORK(IRVT)
   (CWorkspace: need 0)
   (RWorkspace: need BDSPAC)
*/
irvt = nrwork;  // 设置 irvt 为 nrwork 的值
iru = irvt + *m * *m;  // 设置 iru 为 irvt 加上 *m * *m
nrwork = iru + *m * *m;  // 更新 nrwork 的值
sbdsdc_("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m, &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);
/*
                将实数矩阵 RWORK(IRU) 复制到复数矩阵 U
                使用 A 的左奇异向量覆盖 U
                (CWorkspace: 需要 3*M，优先 2*M+M*NB)
                (RWorkspace: M*M)
*/
clacp2_("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
i__1 = *lwork - nwork + 1;
cunmbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

/*              将 VT 的所有元素设置为单位矩阵 */
claset_("F", n, n, &c_b56, &c_b57, &vt[vt_offset], ldvt);

/*
                将实数矩阵 RWORK(IRVT) 复制到复数矩阵 VT
                使用 A 的右奇异向量覆盖 VT
                (CWorkspace: 需要 2*M+N，优先 2*M+N*NB)
                (RWorkspace: M*M)
*/
clacp2_("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
i__1 = *lwork - nwork + 1;
cunmbr_("P", "R", "C", n, n, m, &a[a_offset], lda, &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);
}

}

/*     如果需要，恢复缩放 */

if (iscl == 1) {
if (anrm > bignum) {
slascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
    minmn, &ierr);
}
if (*info != 0 && anrm > bignum) {
i__1 = minmn - 1;
slascl_("G", &c__0, &c__0, &bignum, &anrm, &i__1, &c__1, &rwork[
    ie], &minmn, &ierr);
}
if (anrm < smlnum) {
slascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &
    minmn, &ierr);
}
if (*info != 0 && anrm < smlnum) {
i__1 = minmn - 1;
slascl_("G", &c__0, &c__0, &smlnum, &anrm, &i__1, &c__1, &rwork[
    ie], &minmn, &ierr);
}
}

/*     返回 WORK(1) 中的最优工作空间 */

work[1].r = (real) maxwrk, work[1].i = 0.f;

return 0;

/*     CGESDD 的结束 */

} /* cgesdd_ */

/* 子程序 cgesv_ */

/* Subroutine */ int cgesv_(integer *n, integer *nrhs, singlecomplex *a, integer *
lda, integer *ipiv, singlecomplex *b, integer *ldb, integer *info)
{
/* 系统生成的本地变量 */
integer a_dim1, a_offset, b_dim1, b_offset, i__1;

/* 本地子程序 */
extern /* Subroutine */ int cgetrf_(integer *, integer *, singlecomplex *,
integer *, integer *, integer *), xerbla_(char *, integer *), cgetrs_(char *, integer *, integer *, singlecomplex *, integer
*, integer *, singlecomplex *, integer *, integer *);

/*
-- LAPACK 驱动程序例程 (版本 3.2) --
-- LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。--
   2006年11月
*/

/* 
Purpose
=======
CGESV 计算复线性方程组的解
   A * X = B,
其中 A 是一个 N*N 矩阵，X 和 B 是 N*NRHS 矩阵。

使用 LU 分解和部分选主与行交换来分解 A 为
   A = P * L * U,
*/
    where P is a permutation matrix, L is unit lower triangular, and U is
    upper triangular.  The factored form of A is then used to solve the
    system of equations A * X = B.

    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the N-by-N coefficient matrix A.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) COMPLEX array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, so the solution could not be computed.

    =====================================================================
    /* Parameter adjustments */
    // 调整参数
    a_dim1 = *lda;
    // 计算数组 a 的第一维长度
    a_offset = 1 + a_dim1;
    // 计算 a 的偏移量
    a -= a_offset;
    // 调整数组 a 的指针，使其指向正确的起始位置
    --ipiv;
    // 将 ipiv 指针向前移动一个位置
    b_dim1 = *ldb;
    // 计算数组 b 的第一维长度
    b_offset = 1 + b_dim1;
    // 计算 b 的偏移量
    b -= b_offset;
    // 调整数组 b 的指针，使其指向正确的起始位置

    /* Function Body */
    // 函数体开始
    *info = 0;
    // 初始化 info 为 0
    if (*n < 0) {
    // 如果 n 小于 0
    *info = -1;
    // 将 info 设置为 -1
    } else if (*nrhs < 0) {
    // 否则如果 nrhs 小于 0
    *info = -2;
    // 将 info 设置为 -2
    } else if (*lda < max(1,*n)) {
    // 否则如果 lda 小于 max(1,n)
    *info = -4;
    // 将 info 设置为 -4
    } else if (*ldb < max(1,*n)) {
    // 否则如果 ldb 小于 max(1,n)
    *info = -7;
    // 将 info 设置为 -7
    }
    if (*info != 0) {
    // 如果 info 不等于 0
    i__1 = -(*info);
    // 计算 -info
    xerbla_("CGESV ", &i__1);
    // 调用错误处理函数 xerbla_
    return 0;
    // 返回 0
    }

/*     Compute the LU factorization of A. */
// 计算 A 的 LU 分解

    cgetrf_(n, n, &a[a_offset], lda, &ipiv[1], info);
    // 调用 LAPACK 的 cgetrf_ 函数进行 LU 分解

    if (*info == 0) {

/*        Solve the system A*X = B, overwriting B with X. */
// 解方程组 A*X = B，用 X 覆盖 B

    cgetrs_("No transpose", n, nrhs, &a[a_offset], lda, &ipiv[1], &b[
        b_offset], ldb, info);
    // 调用 LAPACK 的 cgetrs_ 函数解方程组
    }

    return 0;

/*     End of CGESV */

} /* cgesv_ */

/* Subroutine */ int cgetf2_(integer *m, integer *n, singlecomplex *a, integer *lda,
     integer *ipiv, integer *info)
{
    /* System generated locals */
    // 系统生成的本地变量
    integer a_dim1, a_offset, i__1, i__2, i__3;
    singlecomplex q__1;

    /* Local variables */
    // 局部变量
    static integer i__, j, jp;
    // 静态整数变量 i, j, jp
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *), cgeru_(integer *, integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *);
    // 外部函数声明
    static real sfmin;
    // 静态实数变量 sfmin
    extern /* Subroutine */ int cswap_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    // 外部函数声明
    extern integer icamax_(integer *, singlecomplex *, integer *);
    // 外部函数声明
    extern doublereal slamch_(char *);
    // 外部函数声明
    extern /* Subroutine */ int xerbla_(char *, integer *);
    // 外部函数声明

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CGETF2 computes an LU factorization of a general m-by-n matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 2 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
    # IPIV 是输出参数，是一个整数数组，大小为 min(M,N)
    # 它包含了主元素的索引；对于 1 <= i <= min(M,N)，第 i 行与行 IPIV(i) 进行了交换。

    # INFO 是输出参数，是一个整数
    # = 0：成功退出
    # < 0：如果 INFO = -k，则第 k 个参数具有非法值
    # > 0：如果 INFO = k，则 U(k,k) 恰好为零。分解已完成，但因子 U 恰好是奇异的，
    #      如果用于解一个方程组，将会出现除以零的情况。

    # =====================================================================

    # 检验输入参数。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*lda < max(1,*m)) {
    *info = -4;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("CGETF2", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
    return 0;
    }

/*     Compute machine safe minimum */

    sfmin = slamch_("S");

    i__1 = min(*m,*n);
    for (j = 1; j <= i__1; ++j) {

/*        Find pivot and test for singularity. */

    i__2 = *m - j + 1;
    jp = j - 1 + icamax_(&i__2, &a[j + j * a_dim1], &c__1);
    ipiv[j] = jp;
    i__2 = jp + j * a_dim1;
    if (a[i__2].r != 0.f || a[i__2].i != 0.f) {

/*           Apply the interchange to columns 1:N. */

        if (jp != j) {
        cswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);
        }

/*           Compute elements J+1:M of J-th column. */

        if (j < *m) {
        if (c_abs(&a[j + j * a_dim1]) >= sfmin) {
            i__2 = *m - j;
            c_div(&q__1, &c_b57, &a[j + j * a_dim1]);
            cscal_(&i__2, &q__1, &a[j + 1 + j * a_dim1], &c__1);
        } else {
            i__2 = *m - j;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = j + i__ + j * a_dim1;
            c_div(&q__1, &a[j + i__ + j * a_dim1], &a[j + j *
                a_dim1]);
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L20: */
            }
        }
        }

    } else if (*info == 0) {

        *info = j;
    }

    if (j < min(*m,*n)) {

/*           Update trailing submatrix. */

        i__2 = *m - j;
        i__3 = *n - j;
        q__1.r = -1.f, q__1.i = -0.f;
        cgeru_(&i__2, &i__3, &q__1, &a[j + 1 + j * a_dim1], &c__1, &a[j +
            (j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1], lda)
            ;
    }
/* L10: */
    }
    return 0;

/*     End of CGETF2 */

} /* cgetf2_ */

/* Subroutine */ int cgetrf_(integer *m, integer *n, singlecomplex *a, integer *lda,
     integer *ipiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, jb, nb;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    static integer iinfo;
    extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), cgetf2_(integer *,
        integer *, singlecomplex *, integer *, integer *, integer *), xerbla_(
        char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);



注释：
    extern /* Subroutine */ int claswp_(integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *);



    extern /* Subroutine */ int claswp_(integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *);



extern: 声明一个外部函数或变量，表示该函数或变量在当前文件之外定义。

/* Subroutine */: 标记 claswp_ 是一个 Fortran 子程序（subroutine），用于说明它的类型和返回值。

int 类型参数: 第一个参数是整数类型，用于传递整数值给 claswp_。

singlecomplex 类型参数: 第二个参数是 singlecomplex 类型，用于传递单精度复数给 claswp_。

integer * 参数: 接下来的五个参数都是整型数组的指针，用于传递整数数组给 claswp_。

claswp_: 函数名，表示调用的外部 Fortran 子程序，用于实现一些特定的操作或计算。
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.

    =====================================================================


       Test the input parameters.
*/
        i__3 = *m - j + 1;
        cgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);

```    
        // 调用 LAPACK 的 cgetf2_ 函数进行 LU 分解，分解矩阵的子块
        // i__3 是子块的行数，jb 是子块的列数
        // a[j + j * a_dim1] 是要分解的子块的起始地址
        // lda 是矩阵 a 的 leading dimension
        // ipiv[j] 存储主元的索引，iinfo 返回分解的结果信息
        cgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);



        if (*info == 0 && iinfo > 0) {
        *info = iinfo + j - 1;
        }


        // 如果 *info == 0 并且 iinfo > 0，说明 LU 分解出现问题
        // 更新 *info 为首个出现问题的主元索引位置
        if (*info == 0 && iinfo > 0) {
            *info = iinfo + j - 1;
        }



        i__3 = min(*m, j + jb - 1);
        for (i__ = j; i__ <= i__3; ++i__) {
        ipiv[i__] = j - 1 + ipiv[i__];
        }


        // 将主元索引 ipiv 中的值进行调整，使其相对于整个矩阵的正确位置
        // 调整范围从 j 到 min(*m, j + jb - 1)
        i__3 = min(*m, j + jb - 1);
        for (i__ = j; i__ <= i__3; ++i__) {
            ipiv[i__] = j - 1 + ipiv[i__];
        }



        i__3 = j - 1;
        i__4 = j + jb - 1;
        claswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);


        // 应用主元交换到列 1 到 J-1
        i__3 = j - 1;
        i__4 = j + jb - 1;
        claswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);



        if (j + jb <= *n) {


        // 如果 J+JB 小于等于 N，则需要继续处理剩余的列
        if (j + jb <= *n) {



        i__3 = *n - j - jb + 1;
        i__4 = j + jb - 1;
        claswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
            ipiv[1], &c__1);


        // 应用主元交换到列 J+JB 到 N
        i__3 = *n - j - jb + 1;
        i__4 = j + jb - 1;
        claswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
            ipiv[1], &c__1);



        i__3 = *n - j - jb + 1;
        ctrsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
            c_b57, &a[j + j * a_dim1], lda, &a[j + (j + jb) *
            a_dim1], lda);


        // 使用 LAPACK 的 ctrsm 函数解左下三角矩阵方程
        // "Left", "Lower", "No transpose", "Unit" 是参数
        // jb 是子块的列数，i__3 是子块的行数
        // c_b57 是一个常数参数
        // a[j + j * a_dim1] 是左下角的子块
        // a[j + (j + jb) * a_dim1] 是右侧的矩阵块
        ctrsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
            c_b57, &a[j + j * a_dim1], lda, &a[j + (j + jb) *
            a_dim1], lda);



            i__3 = *m - j - jb + 1;
            i__4 = *n - j - jb + 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "No transpose", &i__3, &i__4, &jb,
                &q__1, &a[j + jb + j * a_dim1], lda, &a[j + (j +
                jb) * a_dim1], lda, &c_b57, &a[j + jb + (j + jb) *
                 a_dim1], lda);


            // 使用 LAPACK 的 cgemm 函数进行矩阵乘法
            // "No transpose", "No transpose" 是参数
            // i__3 是左矩阵的行数，i__4 是右矩阵的列数，jb 是公共维度
            // q__1 是一个常数参数
            // a[j + jb + j * a_dim1] 和 a[j + (j + jb) * a_dim1] 是乘法的两个矩阵
            // a[j + jb + (j + jb) * a_dim1] 是结果矩阵
            cgemm_("No transpose", "No transpose", &i__3, &i__4, &jb,
                &q__1, &a[j + jb + j * a_dim1], lda, &a[j + (j +
                jb) * a_dim1], lda, &c_b57, &a[j + jb + (j + jb) *
                 a_dim1], lda);



        }


        // 如果 J+JB 大于 M，则没有剩余的列需要处理
        }



    }
    }
    return 0;


    // 子程序结束，返回 0 表示正常执行
    }
    }
    return 0;



} /* cgetrf_ */


// 结束 cgetrf_ 子程序的定义
} /* cgetrf_ */



/* Subroutine */ int cgetrs_(char *trans, integer *n, integer *nrhs, singlecomplex *
    a, integer *lda, integer *ipiv, singlecomplex *b, integer *ldb, integer *
    info)
{


// cgetrs_ 子程序开始
/* Subroutine */ int cgetrs_(char *trans, integer *n, integer *nrhs, singlecomplex *
    a, integer *lda, integer *ipiv, singlecomplex *b, integer *ldb, integer *
    info)
{



    // 定义局部变量和外部函数
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;


    // 定义本地变量
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;



    // 外部函数 lsame_ 和子程序 ctrsm_、xerbla_、claswp_ 的声明
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), xerbla_(char *,
        integer *), claswp_(integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *);


    // 外部函数 lsame_ 和子程序 ctrsm_、xerbla_、claswp_ 的声明
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), xerbla_(char *,
        integer *), claswp_(integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *);



    // 逻辑变量 notran 初始化为真
    static logical notran;

``
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input) COMPLEX array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by CGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from CGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================

    ! 测试输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0，用于记录函数执行状态
    notran = lsame_(trans, "N");  // 判断是否为非转置操作
    if (! notran && ! lsame_(trans, "T") && ! lsame_(
        trans, "C")) {
        *info = -1;  // 如果 trans 参数不是 'N', 'T', 'C' 中的一个，将 info 设置为 -1
    } else if (*n < 0) {
        *info = -2;  // 如果 n 参数小于 0，将 info 设置为 -2
    } else if (*nrhs < 0) {
        *info = -3;  // 如果 nrhs 参数小于 0，将 info 设置为 -3
    } else if (*lda < max(1,*n)) {
        *info = -5;  // 如果 lda 小于 1 或 n，将 info 设置为 -5
    } else if (*ldb < max(1,*n)) {
        *info = -8;  // 如果 ldb 小于 1 或 n，将 info 设置为 -8
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CGETRS", &i__1);  // 根据 info 的值报告错误并退出
        return 0;  // 返回
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {
        return 0;  // 如果 n 或 nrhs 为 0，直接返回
    }

    if (notran) {

/*
          Solve A * X = B.

          Apply row interchanges to the right hand sides.
*/

        claswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c__1);  // 对 B 应用行置换

/*        Solve L*X = B, overwriting B with X. */

        ctrsm_("Left", "Lower", "No transpose", "Unit", n, nrhs, &c_b57, &a[
            a_offset], lda, &b[b_offset], ldb);  // 解方程 L*X = B，结果保存在 B 中

/*        Solve U*X = B, overwriting B with X. */

        ctrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b57, &
            a[a_offset], lda, &b[b_offset], ldb);  // 解方程 U*X = B，结果保存在 B 中
    } else {

/*
          Solve A**T * X = B  or A**H * X = B.

          Solve U'*X = B, overwriting B with X.
*/

        ctrsm_("Left", "Upper", trans, "Non-unit", n, nrhs, &c_b57, &a[
            a_offset], lda, &b[b_offset], ldb);  // 解方程 U'*X = B，结果保存在 B 中

/*        Solve L'*X = B, overwriting B with X. */

        ctrsm_("Left", "Lower", trans, "Unit", n, nrhs, &c_b57, &a[a_offset],
            lda, &b[b_offset], ldb);  // 解方程 L'*X = B，结果保存在 B 中

/*        Apply row interchanges to the solution vectors. */

        claswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c_n1);  // 对解向量应用行置换
    }

    return 0;

/*     End of CGETRS */

} /* cgetrs_ */

/* Subroutine */ int cheevd_(char *jobz, char *uplo, integer *n, singlecomplex *a,
    integer *lda, real *w, singlecomplex *work, integer *lwork, real *rwork,
    integer *lrwork, integer *iwork, integer *liwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static real eps;
    static integer inde;
    static real anrm;
    static integer imax;
    static real rmin, rmax;
    static integer lopt;
    static real sigma;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
    static integer lwmin, liopt;
    static logical lower;
    static integer llrwk, lropt;
    static logical wantz;
    static integer indwk2, llwrk2;
    extern doublereal clanhe_(char *, char *, integer *, singlecomplex *, integer *,
         real *);
    static integer iscale;


注释：这段代码是一个 Fortran 子程序 `cgetrs_` 的实现，用于解线性方程组 `A * X = B` 或 `A^T * X = B` 或 `A^H * X = B`。代码中包含了参数调整、错误检查、解方程组和行置换等步骤。
    ! 声明外部 Fortran 子程序 clascl_ 和 cstedc_
    extern /* Subroutine */ int clascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, singlecomplex *, integer *, integer *), cstedc_(char *, integer *, real *, real *, singlecomplex *,
        integer *, singlecomplex *, integer *, real *, integer *, integer *,
        integer *, integer *);

    ! 声明外部 Fortran 函数 slamch_
    extern doublereal slamch_(char *);

    ! 声明外部 Fortran 子程序 chetrd_、clacpy_、xerbla_、ssterf_、cunmtr_
    extern /* Subroutine */ int chetrd_(char *, integer *, singlecomplex *, integer
        *, real *, real *, singlecomplex *, singlecomplex *, integer *, integer *), clacpy_(char *, integer *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *),
        xerbla_(char *, integer *),
        ssterf_(integer *, real *, real *, integer *),
        cunmtr_(char *, char *, char *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);

    ! 声明静态变量 safmin、bignum、indtau、indrwk、indwrk、lrwmin、llwork、smlnum 和 lquery
    static real safmin;
    static real bignum;
    static integer indtau, indrwk, indwrk, liwmin;
    static integer lrwmin;
    static integer llwork;
    static real smlnum;
    static logical lquery;
/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
    complex Hermitian matrix A.  If eigenvectors are desired, it uses a
    divide and conquer algorithm.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) REAL array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.
            If N <= 1,                LWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
            If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
*/
    # RWORK是用于存储实数类型工作空间或输出的数组，维度为LRWORK。
    # 如果INFO = 0，则RWORK(1)返回最优LRWORK。

    # LRWORK是RWORK数组的维度，作为输入参数。
    # 如果N <= 1，则LRWORK至少必须为1。
    # 如果JOBZ = 'N'且N > 1，则LRWORK必须至少为N。
    # 如果JOBZ = 'V'且N > 1，则LRWORK必须至少为1 + 5*N + 2*N**2。
    # 如果LRWORK = -1，则假定进行工作空间查询；该子例程仅计算WORK、RWORK和IWORK数组的最佳大小，
    # 并将这些值作为WORK、RWORK和IWORK数组的第一个条目返回，XERBLA不会发出与LWORK、LRWORK或LIWORK相关的错误消息。

    # IWORK是用于存储整数类型工作空间或输出的数组，维度为MAX(1, LIWORK)。
    # 如果INFO = 0，则IWORK(1)返回最优LIWORK。

    # LIWORK是IWORK数组的维度，作为输入参数。
    # 如果N <= 1，则LIWORK至少必须为1。
    # 如果JOBZ = 'N'且N > 1，则LIWORK必须至少为1。
    # 如果JOBZ = 'V'且N > 1，则LIWORK必须至少为3 + 5*N。
    # 如果LIWORK = -1，则假定进行工作空间查询；该子例程仅计算WORK、RWORK和IWORK数组的最佳大小，
    # 并将这些值作为WORK、RWORK和IWORK数组的第一个条目返回，XERBLA不会发出与LWORK、LRWORK或LIWORK相关的错误消息。

    # INFO是输出参数，整数类型。
    # INFO的值表示程序的退出状态：
    # = 0：成功退出。
    # < 0：如果INFO = -i，则第i个参数具有非法值。
    # > 0：如果INFO = i且JOBZ = 'N'，则算法未能收敛；
    #      如果INFO = i且JOBZ = 'V'，则算法未能计算子矩阵的特征值。

    # 进一步细节：
    # 基于Jeff Rutter在加州大学伯克利分校的计算机科学部门的贡献。
    # INFO描述的修改。Sven, 2005年2月16日。

    # 测试输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --w;
    --work;
    --rwork;
    --iwork;

    /* Function Body */
    wantz = lsame_(jobz, "V");  // 检查是否需要计算特征向量
    lower = lsame_(uplo, "L");  // 检查是否是下三角矩阵
    lquery = *lwork == -1 || *lrwork == -1 || *liwork == -1;  // 检查是否为查询模式

    *info = 0;  // 初始化错误信息为0
    if (! (wantz || lsame_(jobz, "N"))) {  // 如果不是要计算特征向量也不是不计算特征向量
        *info = -1;  // 设置错误码为-1
    } else if (! (lower || lsame_(uplo, "U"))) {  // 如果不是下三角矩阵也不是上三角矩阵
        *info = -2;  // 设置错误码为-2
    } else if (*n < 0) {  // 如果矩阵维度小于0
        *info = -3;  // 设置错误码为-3
    } else if (*lda < max(1,*n)) {  // 如果leading dimension小于1或者矩阵维度
        *info = -5;  // 设置错误码为-5
    }

    if (*info == 0) {  // 如果没有错误信息
        if (*n <= 1) {  // 如果矩阵维度小于等于1
            lwmin = 1;
            lrwmin = 1;
            liwmin = 1;
            lopt = lwmin;
            lropt = lrwmin;
            liopt = liwmin;
        } else {
            if (wantz) {  // 如果要计算特征向量
                lwmin = (*n << 1) + *n * *n;  // 设置工作数组最小大小
                /* Computing 2nd power */
                i__1 = *n;
                lrwmin = *n * 5 + 1 + (i__1 * i__1 << 1);  // 设置实际工作数组最小大小
                liwmin = *n * 5 + 3;  // 设置整型工作数组最小大小
            } else {
                lwmin = *n + 1;  // 设置工作数组最小大小
                lrwmin = *n;  // 设置实际工作数组最小大小
                liwmin = 1;  // 设置整型工作数组最小大小
            }
            /* Computing MAX */
            i__1 = lwmin, i__2 = *n + ilaenv_(&c__1, "CHETRD", uplo, n, &c_n1,
                 &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
            lopt = max(i__1,i__2);  // 计算出最优工作数组大小
            lropt = lrwmin;
            liopt = liwmin;
        }
        work[1].r = (real) lopt, work[1].i = 0.f;  // 设置工作数组大小
        rwork[1] = (real) lropt;  // 设置实际工作数组大小
        iwork[1] = liopt;  // 设置整型工作数组大小

        if (*lwork < lwmin && ! lquery) {  // 如果实际工作数组大小小于最小需要大小且非查询模式
            *info = -8;  // 设置错误码为-8
        } else if (*lrwork < lrwmin && ! lquery) {  // 如果实际工作数组大小小于实际最小需要大小且非查询模式
            *info = -10;  // 设置错误码为-10
        } else if (*liwork < liwmin && ! lquery) {  // 如果整型工作数组大小小于最小需要大小且非查询模式
            *info = -12;  // 设置错误码为-12
        }
    }

    if (*info != 0) {  // 如果存在错误信息
        i__1 = -(*info);  // 计算错误信息的负值
        xerbla_("CHEEVD", &i__1);  // 调用错误处理函数
        return 0;  // 返回
    } else if (lquery) {  // 如果是查询模式
        return 0;  // 返回
    }

    /*     Quick return if possible */

    if (*n == 0) {  // 如果矩阵维度为0
        return 0;  // 直接返回
    }

    if (*n == 1) {  // 如果矩阵维度为1
        i__1 = a_dim1 + 1;
        w[1] = a[i__1].r;  // 存储特征值
        if (wantz) {  // 如果要计算特征向量
            i__1 = a_dim1 + 1;
            a[i__1].r = 1.f, a[i__1].i = 0.f;  // 设置单位特征向量
        }
        return 0;  // 返回
    }

    /*     Get machine constants. */

    safmin = slamch_("Safe minimum");  // 获取安全最小值
    eps = slamch_("Precision");  // 获取精度
    smlnum = safmin / eps;  // 计算小数与精度的比值
    bignum = 1.f / smlnum;  // 计算大数与小数的比值
    rmin = sqrt(smlnum);  // 计算平方根
    rmax = sqrt(bignum);  // 计算平方根

    /*     Scale matrix to allowable range, if necessary. */

    anrm = clanhe_("M", uplo, n, &a[a_offset], lda, &rwork[1]);  // 计算矩阵范数
    iscale = 0;  // 初始化是否需要缩放矩阵的标志
    if (anrm > 0.f && anrm < rmin) {  // 如果矩阵范数在安全范围内
        iscale = 1;  // 设置需要缩放标志
        sigma = rmin / anrm;  // 计算缩放系数
    } else if (anrm > rmax) {  // 如果矩阵范数超出大数范围
        iscale = 1;  // 设置需要缩放标志
        sigma = rmax / anrm;  // 计算缩放系数
    }
    if (iscale == 1) {  // 如果需要缩放
        clascl_(uplo, &c__0, &c__0, &c_b1034, &sigma, n, n, &a[a_offset], lda,
             info);  // 调用缩放函数
    }

    /*     Call CHETRD to reduce Hermitian matrix to tridiagonal form. */

    inde = 1;  // 设置工作数组起始索引
    indtau = 1;  // 设置工作数组起始索引
    indwrk = indtau + *n;  // 设置工作数组起始索引
    indrwk = inde + *n;  // 设置实际工作数组起始索引
    indwk2 = indwrk + *n * *n;  // 设置工作数组起始索引
    llwork = *lwork - indwrk + 1;  // 计算工作数组大小
    llwrk2 = *lwork - indwk2 + 1;  // 计算工作数组大小
    llrwk = *lrwork - indrwk + 1;  // 计算实际工作数组大小
    chetrd_(uplo, n, &a[a_offset], lda, &w[1], &rwork[inde], &work[indtau], &
        work[indwrk], &llwork, &iinfo);  // 调用矩阵约化函数
/*
    For eigenvalues only, call SSTERF.  For eigenvectors, first call
    CSTEDC to generate the eigenvector matrix, WORK(INDWRK), of the
    tridiagonal matrix, then call CUNMTR to multiply it to the
    Householder transformations represented as Householder vectors in
    A.
*/
if (! wantz) {
    // 调用 SSTERF 计算特征值
    ssterf_(n, &w[1], &rwork[inde], info);
} else {
    // 调用 CSTEDC 生成特征向量矩阵，然后调用 CUNMTR 将其与 Householder 变换相乘
    cstedc_("I", n, &w[1], &rwork[inde], &work[indwrk], n, &work[indwk2],
            &llwrk2, &rwork[indrwk], &llrwk, &iwork[1], liwork, info);
    cunmtr_("L", uplo, "N", n, n, &a[a_offset], lda, &work[indtau], &work[indwrk],
            n, &work[indwk2], &llwrk2, &iinfo);
    // 将结果复制回 A 矩阵
    clacpy_("A", n, n, &work[indwrk], n, &a[a_offset], lda);
}

/* If matrix was scaled, then rescale eigenvalues appropriately. */
if (iscale == 1) {
    if (*info == 0) {
        imax = *n;
    } else {
        imax = *info - 1;
    }
    // 根据缩放因子 sigma 重新缩放特征值
    r__1 = 1.f / sigma;
    sscal_(&imax, &r__1, &w[1], &c__1);
}

// 设置工作数组和信息数组的首个元素
work[1].r = (real) lopt, work[1].i = 0.f;
rwork[1] = (real) lropt;
iwork[1] = liopt;

// 返回 0 表示成功完成 CHEEVD
return 0;

/* End of CHEEVD */

} /* cheevd_ */

/* Subroutine */ int chetd2_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     real *d__, real *e, singlecomplex *tau, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    real r__1;
    singlecomplex q__1, q__2, q__3, q__4;

    /* Local variables */
    static integer i__;
    static singlecomplex taui;
    extern /* Subroutine */ int cher2_(char *, integer *, singlecomplex *, singlecomplex *
        , integer *, singlecomplex *, integer *, singlecomplex *, integer *);
    static singlecomplex alpha;
    extern /* Complex */ VOID cdotc_(singlecomplex *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int chemv_(char *, integer *, singlecomplex *, singlecomplex *
        , integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *
        ), caxpy_(integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    static logical upper;
    extern /* Subroutine */ int clarfg_(integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *), xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    CHETD2 reduces a complex Hermitian matrix A to real symmetric
    tridiagonal form T by a unitary similarity transformation:
    Q' * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
*/
    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
    
    D       (output) REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
    
    E       (output) REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
    
    TAU     (output) COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
    
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
    
    Further Details
    ===============
    
    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors
    
       Q = H(n-1) . . . H(2) H(1).
    
    Each H(i) has the form
    
       H(i) = I - tau * v * v'
    
    where tau is a complex scalar, and v is a complex vector with
    v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    A(1:i-1,i+1), and tau in TAU(i).
    
    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors
    
       Q = H(1) H(2) . . . H(n-1).
    
    Each H(i) has the form
    
       H(i) = I - tau * v * v'
    
    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    and tau in TAU(i).
    
    The contents of A on exit are illustrated by the following examples
    with n = 5:
    # 如果 UPLO = 'U'，执行以下操作：
    if UPLO = 'U':

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    # d 和 e 表示 T 的对角线和非对角线元素，vi 表示定义 H(i) 的向量中的元素。

    =====================================================================


       # 检测输入参数是否合法
       Test the input parameters
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CHETD2", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n <= 0) {
        return 0;
    }

    if (upper) {

        /* Reduce the upper triangle of A */

        i__1 = *n + *n * a_dim1;
        i__2 = *n + *n * a_dim1;
        r__1 = a[i__2].r;
        a[i__1].r = r__1, a[i__1].i = 0.f;
        for (i__ = *n - 1; i__ >= 1; --i__) {

            /*
                 Generate elementary reflector H(i) = I - tau * v * v'
                 to annihilate A(1:i-1,i+1)
            */

            i__1 = i__ + (i__ + 1) * a_dim1;
            alpha.r = a[i__1].r, alpha.i = a[i__1].i;
            clarfg_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &taui);
            i__1 = i__;
            e[i__1] = alpha.r;

            if (taui.r != 0.f || taui.i != 0.f) {

                /* Apply H(i) from both sides to A(1:i,1:i) */

                i__1 = i__ + (i__ + 1) * a_dim1;
                a[i__1].r = 1.f, a[i__1].i = 0.f;

                /* Compute  x := tau * A * v  storing x in TAU(1:i) */

                chemv_(uplo, &i__, &taui, &a[a_offset], lda, &a[(i__ + 1) *
                    a_dim1 + 1], &c__1, &c_b56, &tau[1], &c__1);

                /* Compute  w := x - 1/2 * tau * (x'*v) * v */

                q__3.r = -.5f, q__3.i = -0.f;
                q__2.r = q__3.r * taui.r - q__3.i * taui.i, q__2.i = q__3.r *
                    taui.i + q__3.i * taui.r;
                cdotc_(&q__4, &i__, &tau[1], &c__1, &a[(i__ + 1) * a_dim1 + 1]
                    , &c__1);
                q__1.r = q__2.r * q__4.r - q__2.i * q__4.i, q__1.i = q__2.r *
                    q__4.i + q__2.i * q__4.r;
                alpha.r = q__1.r, alpha.i = q__1.i;
                caxpy_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &tau[
                    1], &c__1);

                /*
                    Apply the transformation as a rank-2 update:
                    A := A - v * w' - w * v'
                */

                q__1.r = -1.f, q__1.i = -0.f;
                cher2_(uplo, &i__, &q__1, &a[(i__ + 1) * a_dim1 + 1], &c__1, &
                    tau[1], &c__1, &a[a_offset], lda);

            } else {
                i__1 = i__ + i__ * a_dim1;
                i__2 = i__ + i__ * a_dim1;
                r__1 = a[i__2].r;
                a[i__1].r = r__1, a[i__1].i = 0.f;
            }
            i__1 = i__ + (i__ + 1) * a_dim1;
            i__2 = i__;
            a[i__1].r = e[i__2], a[i__1].i = 0.f;
            i__1 = i__ + 1;
            i__2 = i__ + 1 + (i__ + 1) * a_dim1;
            d__[i__1] = a[i__2].r;
            i__1 = i__;
            tau[i__1].r = taui.r, tau[i__1].i = taui.i;
        }
        i__1 = a_dim1 + 1;
        d__[1] = a[i__1].r;
    } else {

        /* Reduce the lower triangle of A */

        i__1 = a_dim1 + 1;
        i__2 = a_dim1 + 1;
        r__1 = a[i__2].r;
        a[i__1].r = r__1, a[i__1].i = 0.f;
        i__1 = *n - 1;
    # 循环开始：从 i__ = 1 开始循环，直到 i__ <= i__1 结束循环
    for (i__ = 1; i__ <= i__1; ++i__) {
/*
     生成元反射器 H(i) = I - tau * v * v'
     用于消除 A(i+2:n,i)
*/
{
    /* a 的第 (i+1+i*a_dim1) 元素的实部赋值给 alpha.r，虚部赋值给 alpha.i */
    i__2 = i__ + 1 + i__ * a_dim1;
    alpha.r = a[i__2].r, alpha.i = a[i__2].i;
    
    /* 计算需要参与反射的元素个数 */
    i__2 = *n - i__;
    /* 使用 MIN 函数计算 i+2 和 *n 之间的最小值 */
    i__3 = i__ + 2;
    clarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1, &
        taui);
    
    /* 将 alpha.r 存储到 e 数组中 */
    i__2 = i__;
    e[i__2] = alpha.r;

    /* 如果 taui.r 或者 taui.i 不等于 0，则执行下面的操作 */
    if (taui.r != 0.f || taui.i != 0.f) {

        /* 将 H(i) 从两侧应用到 A(i+1:n,i+1:n) */
        i__2 = i__ + 1 + i__ * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;

        /* 计算 x := tau * A * v，并将结果存储在 TAU(i:n-1) 中 */
        i__2 = *n - i__;
        chemv_(uplo, &i__2, &taui, &a[i__ + 1 + (i__ + 1) * a_dim1],
            lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b56, &tau[
            i__], &c__1);

        /* 计算 w := x - 1/2 * tau * (x'*v) * v */
        q__3.r = -.5f, q__3.i = -0.f;
        q__2.r = q__3.r * taui.r - q__3.i * taui.i, q__2.i = q__3.r *
            taui.i + q__3.i * taui.r;
        i__2 = *n - i__;
        cdotc_(&q__4, &i__2, &tau[i__], &c__1, &a[i__ + 1 + i__ *
            a_dim1], &c__1);
        q__1.r = q__2.r * q__4.r - q__2.i * q__4.i, q__1.i = q__2.r *
            q__4.i + q__2.i * q__4.r;
        alpha.r = q__1.r, alpha.i = q__1.i;
        i__2 = *n - i__;
        caxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &c__1);

        /*
            将变换应用为秩-2更新：
            A := A - v * w' - w * v'
        */
        i__2 = *n - i__;
        q__1.r = -1.f, q__1.i = -0.f;
        cher2_(uplo, &i__2, &q__1, &a[i__ + 1 + i__ * a_dim1], &c__1,
            &tau[i__], &c__1, &a[i__ + 1 + (i__ + 1) * a_dim1],
            lda);

    } else {
        /* 如果 taui.r 和 taui.i 都等于 0，则执行下面的操作 */
        i__2 = i__ + 1 + (i__ + 1) * a_dim1;
        i__3 = i__ + 1 + (i__ + 1) * a_dim1;
        r__1 = a[i__3].r;
        a[i__2].r = r__1, a[i__2].i = 0.f;
    }

    /* 将 e[i__3] 存储到 a[i__2] 中 */
    i__2 = i__ + 1 + i__ * a_dim1;
    i__3 = i__;
    a[i__2].r = e[i__3], a[i__2].i = 0.f;

    /* 将 a[i__+i__*a_dim1] 的实部赋值给 d__[i__2] */
    i__2 = i__;
    i__3 = i__ + i__ * a_dim1;
    d__[i__2] = a[i__3].r;

    /* 将 taui.r 和 taui.i 分别赋值给 tau[i__2] */
    i__2 = i__;
    tau[i__2].r = taui.r, tau[i__2].i = taui.i;

    /* 标签 L20：用于循环的结束 */
/* L20: */
}
/* 将 a[*n+*n*a_dim1] 的实部赋值给 d__[*n] */
i__1 = *n;
i__2 = *n + *n * a_dim1;
d__[i__1] = a[i__2].r;

}

/* 返回 0 表示成功执行 */

/* CHETD2 的结束 */

} /* chetd2_ */

/* 子程序 chetrd_ */
{
    /* 系统生成的本地变量声明 */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
    singlecomplex q__1;

    /* 本地变量声明 */
    static integer i__, j, nb, kk, nx, iws;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    static logical upper;
    ! 声明外部子程序 chetd2、cher2k、clatrd 和 xerbla
    extern /* Subroutine */ int chetd2_(char *, integer *, singlecomplex *, integer
        *, real *, real *, singlecomplex *, integer *), cher2k_(char *,
        char *, integer *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, real *, singlecomplex *, integer *), clatrd_(char *, integer *, integer *, singlecomplex *, integer
        *, real *, singlecomplex *, singlecomplex *, integer *), xerbla_(char
        *, integer *);
    ! 声明外部函数 ilaenv
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 声明静态变量 ldwork、lwkopt 和 lquery
    static integer ldwork, lwkopt;
    static logical lquery;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CHETRD reduces a complex Hermitian matrix A to real symmetric
    tridiagonal form T by a unitary similarity transformation:
    Q**H * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            指定 A 的存储方式，'U' 表示上三角部分存储，'L' 表示下三角部分存储。

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
            矩阵 A 的阶数，必须大于等于 0。

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            在入口处，A 是一个 Hermitian 矩阵。如果 UPLO = 'U'，则 A 的上三角部分包含 A 的上三角部分，
            A 的严格下三角部分未被引用。如果 UPLO = 'L'，则 A 的下三角部分包含 A 的下三角部分，
            A 的严格上三角部分未被引用。在退出时，如果 UPLO = 'U'，A 的对角线和第一个超对角线被 T 的相应
            元素覆盖，并且上第一个超对角线的元素，通过数组 TAU 表示为初等反射器的乘积的单位矩阵 Q；
            如果 UPLO = 'L'，A 的对角线和第一个次对角线被 T 的相应元素覆盖，并且下第一个次对角线的元素，
            通过数组 TAU 表示为初等反射器的乘积的单位矩阵 Q。详见详细说明。

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            数组 A 的领先维度。LDA 必须大于等于 max(1,N)。

    D       (output) REAL array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            T 的对角线元素。

    E       (output) REAL array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            T 的非对角线元素。如果 UPLO = 'U'，则 E(i) = A(i,i+1)；如果 UPLO = 'L'，则 E(i) = A(i+1,i)。

    TAU     (output) COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            初等反射器的标量因子。详见详细说明。

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            退出时，如果 INFO = 0，WORK(1) 返回最佳 LWORK。
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            如果 LWORK = -1，表示需要查询工作空间大小；函数将只计算 WORK 数组的最优大小，并将此值作为 WORK 数组的第一个条目返回，同时不会由 XERBLA 函数生成与 LWORK 相关的错误信息。

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            返回值说明：
            = 0：成功退出
            < 0：如果 INFO = -i，则第 i 个参数的值不合法

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n-1) . . . H(2) H(1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    A(1:i-1,i+1), and tau in TAU(i).

    如果 UPLO = 'L'，矩阵 Q 被表示为一系列基本反射变换的乘积

       Q = H(1) H(2) . . . H(n-1).

    每个 H(i) 的形式为

       H(i) = I - tau * v * v'

    其中 tau 是一个复数标量，v 是一个复向量，满足 v(1:i) = 0 和 v(i+1) = 1；在退出时，v(i+2:n) 存储在 A(i+2:n,i) 中，tau 存储在 TAU(i) 中。

    The contents of A on exit are illustrated by the following examples
    with n = 5:

    退出时 A 的内容可以通过以下示例说明，假设 n = 5:

    if UPLO = 'U':                       if UPLO = 'L':

      (  d   e   v2  v3  v4 )              (  d                  )
      (      d   e   v3  v4 )              (  e   d              )
      (          d   e   v4 )              (  v1  e   d          )
      (              d   e  )              (  v1  v2  e   d      )
      (                  d  )              (  v1  v2  v3  e   d  )

    这里 d 和 e 分别表示 T 的对角线和非对角线元素，vi 表示定义 H(i) 的向量的元素。
    
    =====================================================================


       Test the input parameters
    测试输入参数的有效性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*lwork < 1 && ! lquery) {
        *info = -9;
    }

    if (*info == 0) {

/*        Determine the block size. */

        nb = ilaenv_(&c__1, "CHETRD", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6,
                     (ftnlen)1);
        lwkopt = *n * nb;
        work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CHETRD", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    nx = *n;
    iws = 1;
    if (nb > 1 && nb < *n) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code).

   Computing MAX
*/

        i__1 = nb, i__2 = ilaenv_(&c__3, "CHETRD", uplo, n, &c_n1, &c_n1, &
                                  c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *n) {

/*           Determine if workspace is large enough for blocked code. */

            ldwork = *n;
            iws = ldwork * nb;
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code by setting NX = N.

   Computing MAX
*/

                i__1 = *lwork / ldwork;
                nb = max(i__1,1);
                nbmin = ilaenv_(&c__2, "CHETRD", uplo, n, &c_n1, &c_n1, &c_n1,
                                 (ftnlen)6, (ftnlen)1);
                if (nb < nbmin) {
                    nx = *n;
                }
            }
        } else {
            nx = *n;
        }
    } else {
        nb = 1;
    }

    if (upper) {

/*
          Reduce the upper triangle of A.
          Columns 1:kk are handled by the unblocked method.
*/

        kk = *n - (*n - nx + nb - 1) / nb * nb;
        i__1 = kk + 1;
        i__2 = -nb;
        for (i__ = *n - nb + 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
             i__2) {

/*
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix
*/

            i__3 = i__ + nb - 1;
            clatrd_(uplo, &i__3, &nb, &a[a_offset], lda, &e[1], &tau[1], &
                    work[1], &ldwork);

/*
             Update the unreduced submatrix A(1:i-1,1:i-1), using an
             update of the form:  A := A - V*W' - W*V'
*/

            i__3 = i__ - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cher2k_(uplo, "No transpose", &i__3, &nb, &q__1, &a[i__ * a_dim1
                    + 1], lda, &work[1], &ldwork, &c_b1034, &a[a_offset], lda);
/*
             Copy superdiagonal elements back into A, and diagonal
             elements into D
*/
```py  
将超对角元素复制回 A 矩阵，并将对角元素复制到 D 数组中。

```  
        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
```py  
循环遍历列索引 `i__` 到 `i__ + nb - 1` 之间的列。

```  
        i__4 = j - 1 + j * a_dim1;
        i__5 = j - 1;
        a[i__4].r = e[i__5], a[i__4].i = 0.f;
```py  
将超对角元素 `e[j-1]` 复制到 A 矩阵的 `(j-1, j)` 位置，并将虚部设为 0。

```  
        i__4 = j;
        i__5 = j + j * a_dim1;
        d__[i__4] = a[i__5].r;
```py  
将对角元素 `a[j, j]` 的实部复制到 D 数组的 `j` 位置。

```  
/* L10: */
        }
/* L20: */
    }
```py  
循环结束标签。

```  
    chetd2_(uplo, &kk, &a[a_offset], lda, &d__[1], &e[1], &tau[1], &iinfo);
    } else {
```py  
调用 `chetd2_` 函数来处理带有给定参数的矩阵操作。

```  
/*
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix
*/
```py  
将列 `i:i+nb-1` 缩减为三对角形式，并形成矩阵 W，以更新矩阵的未减少部分。

```  
        i__3 = *n - i__ + 1;
        clatrd_(uplo, &i__3, &nb, &a[i__ + i__ * a_dim1], lda, &e[i__], &
            tau[i__], &work[1], &ldwork);
```py  
调用 `clatrd_` 函数来处理特定部分的带有给定参数的矩阵操作。

```  
/*
             Update the unreduced submatrix A(i+nb:n,i+nb:n), using
             an update of the form:  A := A - V*W' - W*V'
*/
```py  
使用形式为 `A := A - V*W' - W*V'` 的更新来更新未减少的子矩阵 `A(i+nb:n,i+nb:n)`。

```  
        i__3 = *n - i__ - nb + 1;
        q__1.r = -1.f, q__1.i = -0.f;
        cher2k_(uplo, "No transpose", &i__3, &nb, &q__1, &a[i__ + nb +
            i__ * a_dim1], lda, &work[nb + 1], &ldwork, &c_b1034, &a[
            i__ + nb + (i__ + nb) * a_dim1], lda);
```py  
调用 `cher2k_` 函数来执行 Hermitian rank-2k 更新操作。

```  
/*
             Copy subdiagonal elements back into A, and diagonal
             elements into D
*/
```py  
将次对角线元素复制回 A 矩阵，并将对角元素复制到 D 数组中。

```  
        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
```py  
循环遍历列索引 `i__` 到 `i__ + nb - 1` 之间的列。

```  
        i__4 = j + 1 + j * a_dim1;
        i__5 = j;
        a[i__4].r = e[i__5], a[i__4].i = 0.f;
```py  
将次对角线元素 `e[j]` 复制到 A 矩阵的 `(j+1, j)` 位置，并将虚部设为 0。

```  
        i__4 = j;
        i__5 = j + j * a_dim1;
        d__[i__4] = a[i__5].r;
```py  
将对角元素 `a[j, j]` 的实部复制到 D 数组的 `j` 位置。

```  
/* L30: */
        }
/* L40: */
    }
```py  
循环结束标签。

```  
    i__1 = *n - i__ + 1;
    chetd2_(uplo, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__],
        &tau[i__], &iinfo);
```py  
调用 `chetd2_` 函数来处理带有给定参数的矩阵操作。

```  
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;
```py  
设置工作数组的第一个元素为 `lwkopt` 的实部，并返回 0。

```  
/*     End of CHETRD */
```py  
`CHETRD` 函数的结束标记。

```  
} /* chetrd_ */
```py  
`chetrd_` 子程序的结束标记。

```  
/* Subroutine */ int chseqr_(char *job, char *compz, integer *n, integer *ilo,
     integer *ihi, singlecomplex *h__, integer *ldh, singlecomplex *w, singlecomplex *z__,
    integer *ldz, singlecomplex *work, integer *lwork, integer *info)
{
```py  
`chseqr_` 子程序的开始标记。

```  
    /* System generated locals */
    address a__1[2];
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3[2];
    real r__1, r__2, r__3;
    singlecomplex q__1;
    char ch__1[2];
```py  
声明系统生成的本地变量。

```  
    /* Local variables */
    static singlecomplex hl[2401]    /* was [49][49] */;
    static integer kbot, nmin;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    static logical initz;
    static singlecomplex workl[49];
    static logical wantt, wantz;
```py  
声明本地变量和外部函数。

```  
    # 声明外部子程序 claqr0_, clahqr_, clacpy_, claset_, xerbla_
    # 这些子程序通常由外部库提供，用于特定的线性代数和数组操作
    extern /* Subroutine */ int claqr0_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, integer *),
         clahqr_(logical *, logical *, integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *, integer *, singlecomplex *,
        integer *, integer *), clacpy_(char *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *), claset_(char
        *, integer *, integer *, singlecomplex *, singlecomplex *, singlecomplex *, integer
        *), xerbla_(char *, integer *);
    
    # 声明一个整数变量 ilaenv_，用于调用外部函数获取特定的环境参数
    # ilaenv_ 函数根据调用时传入的参数和环境设置返回一个整数值
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    # 声明一个静态逻辑变量 lquery，通常用于指示是否进行查询或测试
    static logical lquery;
    /* Parameter adjustments */
    h_dim1 = *ldh;  // 计算h_dim1为ldh，即h的第一维长度
    h_offset = 1 + h_dim1;  // 计算h_offset为1 + h_dim1，用于访问h数组的偏移量
    h__ -= h_offset;  // 调整h数组的起始地址，使其指向正确的内存位置
    --w;  // 将w指针前移，使其指向正确的内存位置
    z_dim1 = *ldz;  // 计算z_dim1为ldz，即z的第一维长度
    z_offset = 1 + z_dim1;  // 计算z_offset为1 + z_dim1，用于访问z数组的偏移量
    z__ -= z_offset;  // 调整z数组的起始地址，使其指向正确的内存位置
    --work;  // 将work指针前移，使其指向正确的内存位置

    /* Function Body */
    wantt = lsame_(job, "S");  // 判断job是否为"S"，并将结果存储在wantt中
    initz = lsame_(compz, "I");  // 判断compz是否为"I"，并将结果存储在initz中
    wantz = initz || lsame_(compz, "V");  // 判断compz是否为"I"或"V"，并将结果存储在wantz中
    r__1 = (real) max(1,*n);  // 计算r__1为max(1,*n)的实数形式
    q__1.r = r__1, q__1.i = 0.f;  // 将r__1作为复数结构体的实部，虚部为0，存储在q__1中
    work[1].r = q__1.r, work[1].i = q__1.i;  // 将q__1中的值存储在work数组的第一个元素中
    lquery = *lwork == -1;  // 判断*lwork是否为-1，将结果存储在lquery中

    *info = 0;  // 将info指向的值设为0
    if (! lsame_(job, "E") && ! wantt) {  // 如果job不是"E"且wantt为假
        *info = -1;  // 将info指向的值设为-1
    } else if (! lsame_(compz, "N") && ! wantz) {  // 如果compz不是"N"且wantz为假
        *info = -2;  // 将info指向的值设为-2
    } else if (*n < 0) {  // 如果n小于0
        *info = -3;  // 将info指向的值设为-3
    } else if (*ilo < 1 || *ilo > max(1,*n)) {  // 如果ilo小于1或大于max(1,*n)
        *info = -4;  // 将info指向的值设为-4
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {  // 如果ihi小于min(*ilo,*n)或大于*n
        *info = -5;  // 将info指向的值设为-5
    } else if (*ldh < max(1,*n)) {  // 如果ldh小于max(1,*n)
        *info = -7;  // 将info指向的值设为-7
    } else if (*ldz < 1 || wantz && *ldz < max(1,*n)) {  // 如果ldz小于1或者wantz为真且ldz小于max(1,*n)
        *info = -10;  // 将info指向的值设为-10
    } else if (*lwork < max(1,*n) && ! lquery) {  // 如果lwork小于max(1,*n)且不是lquery
        *info = -12;  // 将info指向的值设为-12
    }

    if (*info != 0) {

        /* ==== Quick return in case of invalid argument. ==== */

        i__1 = -(*info);  // 将-info的值存储在i__1中
        xerbla_("CHSEQR", &i__1);  // 调用xerbla_函数处理异常情况
        return 0;  // 返回0结束函数执行

    } else if (*n == 0) {

        /* ==== Quick return in case N = 0; nothing to do. ==== */

        return 0;  // 返回0结束函数执行

    } else if (lquery) {

        /* ==== Quick return in case of a workspace query ==== */

        claqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1], ilo,
            ihi, &z__[z_offset], ldz, &work[1], lwork, info);
        /*
              ==== Ensure reported workspace size is backward-compatible with
              .    previous LAPACK versions. ====
           Computing MAX
        */
        r__2 = work[1].r, r__3 = (real) max(1,*n);  // 计算r__2为work[1].r和max(1,*n)的最大值，r__3为max(1,*n)
        r__1 = dmax(r__2,r__3);  // 取r__2和r__3的最大值，存储在r__1中
        q__1.r = r__1, q__1.i = 0.f;  // 将r__1作为复数结构体的实部，虚部为0，存储在q__1中
        work[1].r = q__1.r, work[1].i = q__1.i;  // 将q__1中的值存储在work数组的第一个元素中
        return 0;  // 返回0结束函数执行

    } else {

        /* ==== copy eigenvalues isolated by CGEBAL ==== */

        if (*ilo > 1) {  // 如果ilo大于1
            i__1 = *ilo - 1;  // 计算i__1为*ilo - 1
            i__2 = *ldh + 1;  // 计算i__2为*ldh + 1
            ccopy_(&i__1, &h__[h_offset], &i__2, &w[1], &c__1);  // 调用ccopy_函数复制h数组中的部分数据到w数组中
        }
        if (*ihi < *n) {  // 如果ihi小于*n
            i__1 = *n - *ihi;  // 计算i__1为*n - *ihi
            i__2 = *ldh + 1;  // 计算i__2为*ldh + 1
            ccopy_(&i__1, &h__[*ihi + 1 + (*ihi + 1) * h_dim1], &i__2, &w[*ihi + 1], &c__1);  // 调用ccopy_函数复制h数组中的部分数据到w数组中
        }

        /* ==== Initialize Z, if requested ==== */

        if (initz) {  // 如果initz为真
            claset_("A", n, n, &c_b56, &c_b57, &z__[z_offset], ldz);  // 调用claset_函数初始化z数组
        }

        /* ==== Quick return if possible ==== */

        if (*ilo == *ihi) {  // 如果ilo等于ihi
            i__1 = *ilo;  // 将*ilo存储在i__1中
            i__2 = *ilo + *ilo * h_dim1;  // 计算i__2为*ilo + *ilo * h_dim1
            w[i__1].r = h__[i__2].r, w[i__1].i = h__[i__2].i;  // 将h数组中的值赋给w数组
            return 0;  // 返回0结束函数执行
        }

        /*
              ==== CLAHQR/CLAQR0 crossover point ====

           Writing concatenation
        */
        i__3[0] = 1, a__1[0] = job;  // 将job存储在a__1数组中
        i__3[1] = 1, a__1[1
    # 如果 n 大于 nmin，则执行以下代码块
    if (*n > nmin) {
        # 调用 claqr0_ 函数进行特定计算，参数说明如下：
        # - wantt: 控制是否计算Schur向量（T），传递给claqr0_函数
        # - wantz: 控制是否计算Schur变换（Z），传递给claqr0_函数
        # - n: 矩阵H的阶数，传递给claqr0_函数
        # - ilo, ihi: H的Schur分解的下标范围，传递给claqr0_函数
        # - &h__[h_offset]: 输入矩阵H，传递给claqr0_函数
        # - ldh: H的第一个维度（行数），传递给claqr0_函数
        # - &w[1]: 存储计算后的特征值，传递给claqr0_函数
        # - ilo, ihi: 与前面相同，指示计算范围，传递给claqr0_函数
        # - &z__[z_offset]: 如果wantz非零，存储Schur向量的矩阵Z，传递给claqr0_函数
        # - ldz: Z的第一个维度（行数），传递给claqr0_函数
        # - &work[1]: 工作数组，用于内部计算，传递给claqr0_函数
        # - lwork: work数组的长度，传递给claqr0_函数
        # - info: 输出参数，用于返回执行情况，传递给claqr0_函数
        claqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
                ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
    } else {
/*           ==== Small matrix ==== */

        clahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
            ilo, ihi, &z__[z_offset], ldz, info);
/* 调用 LAPACK 子程序 CLAHQR 对小型矩阵进行 Hessenberg QR 分解 */

        if (*info > 0) {

/*
                ==== A rare CLAHQR failure!  CLAQR0 sometimes succeeds
                .    when CLAHQR fails. ====
*/

        kbot = *info;
/* 将 CLAHQR 返回的失败信息存储到 kbot 变量 */

        if (*n >= 49) {

/*
                   ==== Larger matrices have enough subdiagonal scratch
                   .    space to call CLAQR0 directly. ====
*/

            claqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset],
                ldh, &w[1], ilo, ihi, &z__[z_offset], ldz, &work[
                1], lwork, info);
/* 对于大型矩阵直接调用 CLAQR0 进行 Hessenberg-矩阵对应的 Schur 分解 */

        } else {

/*
                   ==== Tiny matrices don't have enough subdiagonal
                   .    scratch space to benefit from CLAQR0.  Hence,
                   .    tiny matrices must be copied into a larger
                   .    array before calling CLAQR0. ====
*/

            clacpy_("A", n, n, &h__[h_offset], ldh, hl, &c__49);
/* 复制小型矩阵 h__ 到更大的 hl 矩阵以便调用 CLAQR0 */

            i__1 = *n + 1 + *n * 49 - 50;
            hl[i__1].r = 0.f, hl[i__1].i = 0.f;
/* 将 hl 矩阵的一个特定位置设为零 */

            i__1 = 49 - *n;
            claset_("A", &c__49, &i__1, &c_b56, &c_b56, &hl[(*n + 1) *
                 49 - 49], &c__49);
/* 初始化 hl 矩阵的一部分 */

            claqr0_(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49, &
                w[1], ilo, ihi, &z__[z_offset], ldz, workl, &
                c__49, info);
/* 对扩展后的大型矩阵 hl 进行 Hessenberg-矩阵对应的 Schur 分解 */

            if (wantt || *info != 0) {
            clacpy_("A", n, n, hl, &c__49, &h__[h_offset], ldh);
            }
/* 如果需要计算所有特征向量或者分解失败，则将结果拷贝回原始矩阵 h__ */
        }
        }
    }

/*        ==== Clear out the trash, if necessary. ==== */

    if ((wantt || *info != 0) && *n > 2) {
        i__1 = *n - 2;
        i__2 = *n - 2;
        claset_("L", &i__1, &i__2, &c_b56, &c_b56, &h__[h_dim1 + 3], ldh);
/* 将 h__ 的下三角部分设为零 */
    }

/*
          ==== Ensure reported workspace size is backward-compatible with
          .    previous LAPACK versions. ====

   Computing MAX
*/
    r__2 = (real) max(1,*n), r__3 = work[1].r;
    r__1 = dmax(r__2,r__3);
    q__1.r = r__1, q__1.i = 0.f;
    work[1].r = q__1.r, work[1].i = q__1.i;
/* 确保报告的工作空间大小与之前的 LAPACK 版本兼容 */

    }

/*     ==== End of CHSEQR ==== */

    return 0;
} /* chseqr_ */

/* Subroutine */ int clabrd_(integer *m, integer *n, integer *nb, singlecomplex *a,
    integer *lda, real *d__, real *e, singlecomplex *tauq, singlecomplex *taup,
    singlecomplex *x, integer *ldx, singlecomplex *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    singlecomplex q__1;

    /* Local variables */
    static integer i__;
    static singlecomplex alpha;
/* 定义局部变量 */
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *), cgemv_(char *, integer *, integer *, singlecomplex *,
        singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *,
        integer *), clarfg_(integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *), clacgv_(integer *, singlecomplex *, integer *);
"""
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLABRD reduces the first NB rows and columns of a complex general
    m by n matrix A to upper or lower real bidiagonal form by a unitary
    transformation Q' * A * P, and returns the matrices X and Y which
    are needed to apply the transformation to the unreduced part of A.

    If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
    bidiagonal form.

    This is an auxiliary routine called by CGEBRD

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.

    N       (input) INTEGER
            The number of columns in the matrix A.

    NB      (input) INTEGER
            The number of leading rows and columns of A to be reduced.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the unitary matrix P as a product
              of elementary reflectors.
            If m < n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    D       (output) REAL array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).

    E       (output) REAL array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.

    TAUQ    (output) COMPLEX array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.

    TAUP    (output) COMPLEX array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.

    X       (output) COMPLEX array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
"""
    LDX     (input) INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
    Y       (output) COMPLEX array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).


    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

       Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)

    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    where tauq and taup are complex scalars, and v and u are complex
    vectors.

    If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
    A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
    A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).


    The elements of the vectors v and u together form the m-by-nb matrix
    V and the nb-by-n matrix U' which are needed, with X and Y, to apply
    the transformation to the unreduced part of the matrix, using a block
    update of the form:  A := A - V*Y' - X*U'.

    The contents of A on exit are illustrated by the following examples
    with nb = 2:

    m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

      (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
      (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
      (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
      (  v1  v2  a   a   a  )

    where a denotes an element of the original matrix which is unchanged,
    vi denotes an element of the vector defining H(i), and ui an element
    of the vector defining G(i).


    =====================================================================


       Quick return if possible
    /* 参数调整 */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tauq;
    --taup;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    y_dim1 = *ldy;
    y_offset = 1 + y_dim1;
    y -= y_offset;

    /* 函数主体 */
    if (*m <= 0 || *n <= 0) {
    return 0;
    }

    if (*m >= *n) {

/*        转化为上（右）对角双对角形式 */

    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*           更新 A(i:m,i) */

        i__2 = i__ - 1;
        clacgv_(&i__2, &y[i__ + y_dim1], ldy);  // 对 y[i+1:m] 执行共轭
        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("No transpose", &i__2, &i__3, &q__1, &a[i__ + a_dim1], lda,
             &y[i__ + y_dim1], ldy, &c_b57, &a[i__ + i__ * a_dim1], &
            c__1);  // 计算 A(i:m,i) -= Y[i+1:m]^H * A(i:m,1:i-1)
        i__2 = i__ - 1;
        clacgv_(&i__2, &y[i__ + y_dim1], ldy);  // 恢复 y[i+1:m] 的值
        i__2 = *m - i__ + 1;
        i__3 = i__ - 1;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("No transpose", &i__2, &i__3, &q__1, &x[i__ + x_dim1], ldx,
             &a[i__ * a_dim1 + 1], &c__1, &c_b57, &a[i__ + i__ *
            a_dim1], &c__1);  // 计算 A(i:m,i) -= X[i+1:m] * A(1:i-1,i)

/*           生成反射 Q(i)，消除 A(i+1:m,i) */

        i__2 = i__ + i__ * a_dim1;
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;  // 获取 A(i,i) 的值
        i__2 = *m - i__ + 1;
        i__3 = i__ + 1;
        clarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1, &
            tauq[i__]);  // 计算反射系数 tauq[i]，并更新 A(i,i)
        i__2 = i__;
        d__[i__2] = alpha.r;  // 将 A(i,i) 的实部存入 d[i]
        if (i__ < *n) {
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;  // 将 A(i,i) 设置为单位阵的元素
/* Compute Y(i+1:n,i) */

/* 计算 Y(i+1:n,i) */

i__2 = *m - i__ + 1;
/* 计算矩阵 A 的行数减去当前行号 i 加一 */
i__3 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ + (
    i__ + 1) * a_dim1], lda, &a[i__ + i__ * a_dim1], &
    c__1, &c_b56, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，计算 Y(i+1:n,i) */

i__2 = *m - i__ + 1;
/* 计算矩阵 A 的行数减去当前行号 i 加一 */
i__3 = i__ - 1;
/* 计算当前列号 i 减一 */
cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
    a_dim1], lda, &a[i__ + i__ * a_dim1], &c__1, &c_b56, &
    y[i__ * y_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，计算 Y(i * y_dim1 + 1) */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
i__3 = i__ - 1;
/* 计算当前列号 i 减一 */
q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 -1.0 */
cgemv_("No transpose", &i__2, &i__3, &q__1, &y[i__ + 1 +
    y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b57, &y[
    i__ + 1 + i__ * y_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，更新 Y(i+1:n,i) */

i__2 = *m - i__ + 1;
/* 计算矩阵 A 的行数减去当前行号 i 加一 */
i__3 = i__ - 1;
/* 计算当前列号 i 减一 */
cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &x[i__ +
    x_dim1], ldx, &a[i__ + i__ * a_dim1], &c__1, &c_b56, &
    y[i__ * y_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，更新 Y(i * y_dim1 + 1) */

i__2 = i__ - 1;
/* 计算当前列号 i 减一 */
i__3 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 -1.0 */
cgemv_("Conjugate transpose", &i__2, &i__3, &q__1, &a[(i__ +
    1) * a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &
    c_b57, &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，更新 Y(i+1:n,i) */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
cscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
/* 调用 BLAS 库中的 cscal 函数，对向量进行缩放操作 */

/* Update A(i,i+1:n) */

/* 更新 A(i,i+1:n) */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭操作 */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
clacgv_(&i__, &a[i__ + a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭操作 */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 -1.0 */
cgemv_("No transpose", &i__2, &i__, &q__1, &y[i__ + 1 +
    y_dim1], ldy, &a[i__ + a_dim1], lda, &c_b57, &a[i__ +
    (i__ + 1) * a_dim1], lda);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，更新 A(i,i+1:n) */

clacgv_(&i__, &a[i__ + a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭操作 */

i__2 = i__ - 1;
/* 计算当前列号 i 减一 */
clacgv_(&i__2, &x[i__ + x_dim1], ldx);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭操作 */

i__2 = i__ - 1;
/* 计算当前列号 i 减一 */
i__3 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 -1.0 */
cgemv_("Conjugate transpose", &i__2, &i__3, &q__1, &a[(i__ +
    1) * a_dim1 + 1], lda, &x[i__ + x_dim1], ldx, &c_b57,
    &a[i__ + (i__ + 1) * a_dim1], lda);
/* 调用 BLAS 库中的 cgemv 函数进行矩阵向量乘法，更新 A(i,i+1:n) */

i__2 = i__ - 1;
/* 计算当前列号 i 减一 */
clacgv_(&i__2, &x[i__ + x_dim1], ldx);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭操作 */

/* Generate reflection P(i) to annihilate A(i,i+2:n) */

/* 生成反射变换 P(i)，使得 A(i,i+2:n) 被置零 */

i__2 = i__ + (i__ + 1) * a_dim1;
/* 计算矩阵 A 中的元素索引 */
alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 获取矩阵 A 中的元素 alpha */

i__2 = *n - i__;
/* 计算矩阵 A 的列数减去当前列号 i */
/* Computing MIN */
i__3 = i__ + 2;
/* 计算 i + 2 和 *n 中的较小值 */
clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
    taup[i__]);
/* 调用 LAPACK 库中的 clarfg 函数，生成反射变换 P(i) */

i__2 = i__;
/* 计算当前列号 i */
e[i__2] = alpha
/*              Compute X(i+1:m,i) */

/* 计算 X(i+1:m,i) */

        i__2 = *m - i__;
/* 计算矩阵维度 */
        i__3 = *n - i__;
/* 计算矩阵维度 */
        cgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ + 1 + (
            i__ + 1) * a_dim1], lda, &a[i__ + (i__ + 1) * a_dim1],
             lda, &c_b56, &x[i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = *n - i__;
/* 计算矩阵维度 */
        cgemv_("Conjugate transpose", &i__2, &i__, &c_b57, &y[i__ + 1
            + y_dim1], ldy, &a[i__ + (i__ + 1) * a_dim1], lda, &
            c_b56, &x[i__ * x_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = *m - i__;
/* 计算矩阵维度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数值 */
        cgemv_("No transpose", &i__2, &i__, &q__1, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        i__3 = *n - i__;
/* 计算矩阵维度 */
        cgemv_("No transpose", &i__2, &i__3, &c_b57, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            c_b56, &x[i__ * x_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = *m - i__;
/* 计算矩阵维度 */
        i__3 = i__ - 1;
/* 计算矩阵维度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数值 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = *m - i__;
/* 计算矩阵维度 */
        cscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cscal 函数，对向量进行缩放 */
        i__2 = *n - i__;
/* 计算矩阵维度 */
        clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对矩阵进行共轭变换 */
        }
/* L10: */
/* 循环结束 */
    }
/* else 分支结束 */
    } else {

/*        Reduce to lower bidiagonal form */

/* 将矩阵约化为下部双对角形式 */

    i__1 = *nb;
/* 计算循环次数 */
    for (i__ = 1; i__ <= i__1; ++i__) {

/*           Update A(i,i:n) */

/* 更新 A(i,i:n) 区块 */

        i__2 = *n - i__ + 1;
/* 计算矩阵维度 */
        clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对矩阵进行共轭变换 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        clacgv_(&i__2, &a[i__ + a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对矩阵进行共轭变换 */
        i__2 = *n - i__ + 1;
/* 计算矩阵维度 */
        i__3 = i__ - 1;
/* 计算矩阵维度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数值 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &y[i__ + y_dim1], ldy,
             &a[i__ + a_dim1], lda, &c_b57, &a[i__ + i__ * a_dim1],
            lda);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        clacgv_(&i__2, &a[i__ + a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对矩阵进行共轭变换 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        clacgv_(&i__2, &x[i__ + x_dim1], ldx);
/* 调用 LAPACK 库中的 clacgv 函数，对矩阵进行共轭变换 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        i__3 = *n - i__ + 1;
/* 计算矩阵维度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数值 */
        cgemv_("Conjugate transpose", &i__2, &i__3, &q__1, &a[i__ *
            a_dim1 + 1], lda, &x[i__ + x_dim1], ldx, &c_b57, &a[i__ +
            i__ * a_dim1], lda);
/* 调用 BLAS 库中的 cgemv 函数，进行矩阵-向量乘法运算 */
        i__2 = i__ - 1;
/* 计算矩阵维度 */
        clacgv_(&i__2, &x[i__ + x_dim1], ldx);

/*           Generate reflection P(i) to annihilate A(i,i+1:n) */

/* 生成反射矩阵 P(i)，将 A(i,i+1:n) 区块化为零 */

        i__2 = i__ + i__ * a_dim1;
/* 计算矩阵元素位置 */
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 获取矩阵元素 */
        i__2 = *n - i__ + 1;
/* 计算矩阵维度 */
/* Computing MIN */
        i__3 = i__ + 1;
/* 计算矩阵维度 */
        clarfg_(&i__2, &alpha, &a[i__ + min(i__3,*n) * a_dim1], lda, &
            taup[i__]);
/* 调用 LAPACK 库中的 clarfg 函数，生成 House
/*              Compute X(i+1:m,i) */

/* 计算 X(i+1:m,i) */

        i__2 = *m - i__;
/* 计算行数 */
        i__3 = *n - i__ + 1;
/* 计算列数 */
        cgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ + 1 + i__
            * a_dim1], lda, &a[i__ + i__ * a_dim1], lda, &c_b56, &
            x[i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，计算 X(i+1:m,i) */

        i__2 = *n - i__ + 1;
/* 计算列数 */
        i__3 = i__ - 1;
/* 计算行数 */
        cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &y[i__ +
            y_dim1], ldy, &a[i__ + i__ * a_dim1], lda, &c_b56, &x[
            i__ * x_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，计算 X(i:i-1) */

        i__2 = *m - i__;
/* 计算行数 */
        i__3 = i__ - 1;
/* 计算列数 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 初始化一个复数 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，计算 X(i+1:m,i) */

        i__2 = i__ - 1;
/* 计算行数 */
        i__3 = *n - i__ + 1;
/* 计算列数 */
        cgemv_("No transpose", &i__2, &i__3, &c_b57, &a[i__ * a_dim1
            + 1], lda, &a[i__ + i__ * a_dim1], lda, &c_b56, &x[
            i__ * x_dim1 + 1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，计算 X(1:i-1) */

        i__2 = *m - i__;
/* 计算行数 */
        i__3 = i__ - 1;
/* 计算列数 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 初始化一个复数 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b57, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，计算 X(i+1:m,i) */

        i__2 = *m - i__;
/* 计算行数 */
        cscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);
/* 调用 BLAS 库中的 cscal 函数，对向量进行缩放 */

        i__2 = *n - i__ + 1;
/* 计算列数 */
        clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭 */

/*              Update A(i+1:m,i) */

/* 更新 A(i+1:m,i) */

        i__2 = i__ - 1;
/* 计算行数 */
        clacgv_(&i__2, &y[i__ + y_dim1], ldy);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭 */

        i__2 = *m - i__;
/* 计算行数 */
        i__3 = i__ - 1;
/* 计算列数 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 初始化一个复数 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &a[i__ + 1 +
            a_dim1], lda, &y[i__ + y_dim1], ldy, &c_b57, &a[i__ +
            1 + i__ * a_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，更新 A(i+1:m,i) */

        i__2 = i__ - 1;
/* 计算行数 */
        clacgv_(&i__2, &y[i__ + y_dim1], ldy);
/* 调用 LAPACK 库中的 clacgv 函数，对向量进行共轭 */

        i__2 = *m - i__;
/* 计算行数 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 初始化一个复数 */
        cgemv_("No transpose", &i__2, &i__, &q__1, &x[i__ + 1 +
            x_dim1], ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b57, &a[
            i__ + 1 + i__ * a_dim1], &c__1);
/* 调用 BLAS 库中的 cgemv 函数，对矩阵进行向量乘法操作，更新 A(i+1:m,i) */

/*              Generate reflection Q(i) to annihilate A(i+2:m,i) */

/* 生成反射变换 Q(i)，使得 A(i+2:m,i) 变为零 */

        i__2 = i__ + 1 + i__ * a_dim1;
/* 计算数组索引 */
        alpha.r = a[i__2].r, alpha.i = a[i__2].i;
/* 从数组中读取 alpha 的值 */

        i__2 = *m - i__;
/* 计算行数 */
/* Computing MIN */
        i__3 = i__ + 2;
/* 计算最小值 */
        clarfg_(&i__2, &alpha, &a[min(i__3,*m) + i__ * a_dim1], &c__1,
             &tauq[i__]);
/* 调用 LAPACK 库中的 clarfg 函数，计算反射系数 tauq[i] */

        i__2 = i__;
/* 计算数组索引 */
        e[i__2] = alpha.r;
/* 将 alpha.r 存入 e[i] */

        i__2 = i__ + 1 + i__ * a_dim1;
/* 计算数组索引 */
        a[i__2].r = 1.f, a[i__2].i = 0.f;
/* 将 A(i+1,i) 设置为单位复数 */
/*              Compute Y(i+1:n,i) */

/* 计算 Y(i+1:n,i) */

        i__2 = *m - i__;
        i__3 = *n - i__;
        cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + (i__ + 1) * a_dim1], lda, &a[i__ + 1 + i__ *
            a_dim1], &c__1, &c_b56, &y[i__ + 1 + i__ * y_dim1], &
            c__1);

/* 使用 CGEMV 函数计算 Y(i+1:n,i)，进行共轭转置操作，其中：
   - 第一个参数 "Conjugate transpose" 表示共轭转置操作
   - i__2 表示行数
   - i__3 表示列数
   - c_b57 为常量
   - a[i__ + 1 + (i__ + 1) * a_dim1] 为操作的矩阵
   - lda 为矩阵 a 的 leading dimension
   - 其他参数类似解释
*/

        i__2 = *m - i__;
        i__3 = i__ - 1;
        cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &y[i__ * y_dim1 + 1], &c__1);

/* 使用 CGEMV 函数计算 Y(i+1:i-1,i)，进行共轭转置操作，参数解释与上述类似 */

        i__2 = *n - i__;
        i__3 = i__ - 1;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("No transpose", &i__2, &i__3, &q__1, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b57, &y[
            i__ + 1 + i__ * y_dim1], &c__1);

/* 使用 CGEMV 函数计算 Y(i+1:n,i) 与 Y(i,i+1:i-1) 的乘积，不进行转置操作，其中：
   - 第一个参数 "No transpose" 表示不进行转置操作
   - 其他参数类似解释
*/

        i__2 = *m - i__;
        cgemv_("Conjugate transpose", &i__2, &i__, &c_b57, &x[i__ + 1
            + x_dim1], ldx, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &y[i__ * y_dim1 + 1], &c__1);

/* 使用 CGEMV 函数计算 X(i+1:m,i) 与 A(i+1:i,i) 的乘积，进行共轭转置操作，参数解释与上述类似 */

        i__2 = *n - i__;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("Conjugate transpose", &i__, &i__2, &q__1, &a[(i__ + 1)
             * a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &
            c_b57, &y[i__ + 1 + i__ * y_dim1], &c__1);

/* 使用 CGEMV 函数计算 A(i+1:i,i+1:n) 与 Y(i,i+1:n) 的乘积，进行共轭转置操作，参数解释与上述类似 */

        i__2 = *n - i__;
        cscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);

/* 使用 CSCAL 函数对 Y(i+1:n,i) 进行缩放，其中：
   - CSCAL 函数用于对复数数组进行缩放操作
   - tauq[i__] 为缩放系数
*/

        } else {
        i__2 = *n - i__ + 1;
        clacgv_(&i__2, &a[i__ + i__ * a_dim1], lda);
        }

/* 如果条件不满足，则调用 CLACGV 函数对 A(i,i+1:n) 进行共轭操作，参数解释如下 */

/* L20: */
    }
    }
    return 0;

/*     End of CLABRD */

/* CLABRD 子程序结束标记 */

} /* clabrd_ */

/* clabrd_ 函数结束 */

/* Subroutine */ int clacgv_(integer *n, singlecomplex *x, integer *incx)
{

/* CLACGV 子程序开始 */

    /* System generated locals */
    integer i__1, i__2;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, ioff;

/* 定义局部变量 */

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    -- LAPACK 辅助程序（版本 3.2） --
    -- LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。--
       2006年11月

    Purpose
    =======

    CLACGV conjugates a complex vector of length N.

    CLACGV 子程序用于共轭一个长度为 N 的复向量。

    Arguments
    =========

    N       (input) INTEGER
            The length of the vector X.  N >= 0.

    N       (输入) 整数
            向量 X 的长度。N >= 0。

    X       (input/output) COMPLEX array, dimension
                           (1+(N-1)*abs(INCX))
            On entry, the vector of length N to be conjugated.
            On exit, X is overwritten with conjg(X).

    X       (输入/输出) 复数数组，维度
                           (1+(N-1)*abs(INCX))
            输入时，长度为 N 的向量进行共轭操作。
            输出时，X 被其共轭值覆盖。

    INCX    (input) INTEGER
            The spacing between successive elements of X.

    INCX    (输入) 整数
            X 中相邻元素之间的间隔。

   =====================================================================
*/

    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*incx == 1) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        r_cnjg(&q__1, &x[i__]);
        x[i__2].r = q__1.r, x[i__2].i = q__1.i;

/* 如果 INCX 等于 1，则遍历向量 X 中的每个元素，将其共轭值赋给相应位置 */

/* L10: */
    }
    } else {
    ioff = 1;
    if (*incx < 0) {
        ioff = 1 - (*n - 1) * *incx;
    }

/* 否则，计算起始索引 ioff，并根据 INCX 的正负调整 */

    i__1 = *n;
    // 循环迭代变量 i__ 从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 设置数组 x 的索引为 ioff 的元素为其自身的共轭
        r_cnjg(&q__1, &x[ioff]);
        x[i__2].r = q__1.r, x[i__2].i = q__1.i;
        // 更新索引 ioff，增量为 incx 指定的值
        ioff += *incx;
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLACP2 copies all or part of a real two-dimensional matrix A to a
    complex matrix B.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input) REAL array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (output) COMPLEX array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).

    =====================================================================
*/

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
b_dim1 = *ldb;
b_offset = 1 + b_dim1;
b -= b_offset;

/* Function Body */
if (lsame_(uplo, "U")) {
    /* Copy upper triangular part of A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
            /* Compute indices for B and A */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            /* Copy real part of A to B, with imaginary part set to 0 */
            b[i__3].r = a[i__4], b[i__3].i = 0.f;
            /* L10: */
        }
        /* L20: */
    }

} else if (lsame_(uplo, "L")) {
    /* Copy lower triangular part of A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = j; i__ <= i__2; ++i__) {
            /* Compute indices for B and A */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            /* Copy real part of A to B, with imaginary part set to 0 */
            b[i__3].r = a[i__4], b[i__3].i = 0.f;
            /* L30: */
        }
        /* L40: */
    }

} else {
    /* Copy entire matrix A to B */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            /* Compute indices for B and A */
            i__3 = i__ + j * b_dim1;
            i__4 = i__ + j * a_dim1;
            /* Copy real part of A to B, with imaginary part set to 0 */
            b[i__3].r = a[i__4], b[i__3].i = 0.f;
            /* L50: */
        }
        /* L60: */
    }
}

return 0;

/*     End of CLACP2 */

} /* clacp2_ */


Explanation:
- **Purpose**: Describes the function of the subroutine `CLACP2`, which copies parts of a real matrix `A` into a complex matrix `B`.
- **Arguments**: Details the parameters `UPLO`, `M`, `N`, `A`, `LDA`, `B`, and `LDB`.
- **Parameter adjustments**: Calculates indices for matrices `A` and `B`.
- **Function Body**: Copies parts of matrix `A` to matrix `B` based on the value of `UPLO`.
- **Return**: Ends the subroutine, returning 0.
/* Subroutine */ int clacpy_(char *uplo, integer *m, integer *n, singlecomplex *a,
    integer *lda, singlecomplex *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLACPY copies all or part of a two-dimensional matrix A to another
    matrix B.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input) COMPLEX array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (output) COMPLEX array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).

    =====================================================================
*/


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    if (lsame_(uplo, "U")) {
        /* Copy upper triangular part of A to B */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = min(j,*m);
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* Copy element A(i,j) to B(i,j) */
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
            }
        }

    } else if (lsame_(uplo, "L")) {
        /* Copy lower triangular part of A to B */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = j; i__ <= i__2; ++i__) {
                /* Copy element A(i,j) to B(i,j) */
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
            }
        }

    } else {
        /* Copy entire matrix A to B */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* Copy element A(i,j) to B(i,j) */
                i__3 = i__ + j * b_dim1;
                i__4 = i__ + j * a_dim1;
                b[i__3].r = a[i__4].r, b[i__3].i = a[i__4].i;
            }
        }
    }

    return 0;

/*     End of CLACPY */

} /* clacpy_ */


注释已添加，按照指定的格式解释了每个语句的作用和功能。
/* Subroutine */ int clacrm_(integer *m, integer *n, singlecomplex *a, integer *lda,
     real *b, integer *ldb, singlecomplex *c__, integer *ldc, real *rwork)
{
    /* System generated locals */
    integer b_dim1, b_offset, a_dim1, a_offset, c_dim1, c_offset, i__1, i__2,
        i__3, i__4, i__5;
    real r__1;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006

        Purpose
        =======

        CLACRM performs a very simple matrix-matrix multiplication:
                 C := A * B,
        where A is M by N and complex; B is N by N and real;
        C is M by N and complex.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A and of the matrix C.
                M >= 0.

        N       (input) INTEGER
                The number of columns and rows of the matrix B and
                the number of columns of the matrix C.
                N >= 0.

        A       (input) COMPLEX array, dimension (LDA, N)
                A contains the M by N matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >=max(1,M).

        B       (input) REAL array, dimension (LDB, N)
                B contains the N by N matrix B.

        LDB     (input) INTEGER
                The leading dimension of the array B. LDB >=max(1,N).

        C       (input) COMPLEX array, dimension (LDC, N)
                C contains the M by N matrix C.

        LDC     (input) INTEGER
                The leading dimension of the array C. LDC >=max(1,N).

        RWORK   (workspace) REAL array, dimension (2*M*N)

        =====================================================================

        Quick return if possible.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --rwork;

    /* Function Body */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    /* Copy real part of matrix A into workspace RWORK */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            rwork[(j - 1) * *m + i__] = a[i__3].r;
        }
    }

    l = *m * *n + 1;
    /* Perform matrix-matrix multiplication C := A * B */
    sgemm_("N", "N", m, n, n, &c_b1034, &rwork[1], m, &b[b_offset], ldb, &
        c_b328, &rwork[l], m);

    /* Copy results from RWORK back into complex matrix C */
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = l + (j - 1) * *m + i__ - 1;
            c__[i__3].r = rwork[i__4], c__[i__3].i = 0.f;
        }
    }

} /* End of clacrm_ subroutine */
    i__1 = *n;
    # 从指针 n 指向的地址中获取值，作为循环的上限
    for (j = 1; j <= i__1; ++j) {
    # 对于 j 从 1 到上限 i__1 进行循环
        i__2 = *m;
        # 从指针 m 指向的地址中获取值，作为内层循环的上限
        for (i__ = 1; i__ <= i__2; ++i__) {
        # 对于 i 从 1 到上限 i__2 进行循环
            rwork[(j - 1) * *m + i__] = r_imag(&a[i__ + j * a_dim1]);
            # 计算 rwork 数组的索引位置并赋值为 a 数组中的虚部值
        }
    }
/* L50: */
    }
/* L60: */
    }
    sgemm_("N", "N", m, n, n, &c_b1034, &rwork[1], m, &b[b_offset], ldb, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * c_dim1;
        i__4 = i__ + j * c_dim1;
        r__1 = c__[i__4].r;
        i__5 = l + (j - 1) * *m + i__ - 1;
        q__1.r = r__1, q__1.i = rwork[i__5];
        c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L70: */
    }
/* L80: */
    }

    return 0;

/*     End of CLACRM */

} /* clacrm_ */

/* Complex */ VOID cladiv_(singlecomplex * ret_val, singlecomplex *x, singlecomplex *y)
{
    /* System generated locals */
    real r__1, r__2, r__3, r__4;
    singlecomplex q__1;

    /* Local variables */
    static real zi, zr;
    extern /* Subroutine */ int sladiv_(real *, real *, real *, real *, real *
        , real *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLADIV := X / Y, where X and Y are complex.  The computation of X / Y
    will not overflow on an intermediary step unless the results
    overflows.

    Arguments
    =========

    X       (input) COMPLEX
    Y       (input) COMPLEX
            The complex scalars X and Y.

    =====================================================================
*/


    r__1 = x->r; /* 获取 X 的实部 */
    r__2 = r_imag(x); /* 获取 X 的虚部 */
    r__3 = y->r; /* 获取 Y 的实部 */
    r__4 = r_imag(y); /* 获取 Y 的虚部 */
    sladiv_(&r__1, &r__2, &r__3, &r__4, &zr, &zi); /* 调用 sladiv 计算复数除法 */
    q__1.r = zr, q__1.i = zi; /* 构造结果复数 */
     ret_val->r = q__1.r,  ret_val->i = q__1.i; /* 将结果复数赋值给 ret_val */

    return ;

/*     End of CLADIV */

} /* cladiv_ */

/* Subroutine */ int claed0_(integer *qsiz, integer *n, real *d__, real *e,
    singlecomplex *q, integer *ldq, singlecomplex *qstore, integer *ldqs, real *rwork,
     integer *iwork, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, qstore_dim1, qstore_offset, i__1, i__2;
    real r__1;

    /* Local variables */
    static integer i__, j, k, ll, iq, lgn, msd2, smm1, spm1, spm2;
    static real temp;
    static integer curr, iperm;
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    static integer indxq, iwrem;
    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *,
        integer *);
    static integer iqptr;
    extern /* Subroutine */ int claed7_(integer *, integer *, integer *,
        integer *, integer *, integer *, real *, singlecomplex *, integer *,
        real *, integer *, real *, integer *, integer *, integer *,
        integer *, integer *, real *, singlecomplex *, real *, integer *,
        integer *);
    static integer tlvls;
    # 外部声明一个名为clacrm的子例程，该子例程接受多个参数并返回void
    extern /* Subroutine */ int clacrm_(integer *, integer *, singlecomplex *,
        integer *, real *, integer *, singlecomplex *, integer *, real *);

    # 静态声明整型变量igivcl
    static integer igivcl;

    # 外部声明一个名为xerbla的子例程，该子例程接受一个字符指针和一个整型参数，返回void
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 外部声明一个名为ilaenv的函数，该函数接受多个参数并返回整型
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 静态声明整型变量igivnm, submat, curprb, subpbs, igivpt, curlvl, matsiz, iprmpt, smlsiz
    static integer igivnm, submat, curprb, subpbs, igivpt, curlvl, matsiz,
        iprmpt, smlsiz;

    # 外部声明一个名为ssteqr的子例程，该子例程接受多个参数并返回void
    extern /* Subroutine */ int ssteqr_(char *, integer *, real *, real *,
        real *, integer *, real *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    Using the divide and conquer method, CLAED0 computes all eigenvalues
    of a symmetric tridiagonal matrix which is one diagonal block of
    those from reducing a dense or band Hermitian matrix and
    corresponding eigenvectors of the dense or band matrix.

    Arguments
    =========

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D      (input/output) REAL array, dimension (N)
           On entry, the diagonal elements of the tridiagonal matrix.
           On exit, the eigenvalues in ascending order.

    E      (input/output) REAL array, dimension (N-1)
           On entry, the off-diagonal elements of the tridiagonal matrix.
           On exit, E has been destroyed.

    Q      (input/output) COMPLEX array, dimension (LDQ,N)
           On entry, Q must contain an QSIZ x N matrix whose columns
           unitarily orthonormal. It is a part of the unitary matrix
           that reduces the full dense Hermitian matrix to a
           (reducible) symmetric tridiagonal matrix.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    IWORK  (workspace) INTEGER array,
           the dimension of IWORK must be at least
                        6 + 6*N + 5*N*lg N
                        ( lg( N ) = smallest integer k
                                    such that 2^k >= N )

    RWORK  (workspace) REAL array,
                                 dimension (1 + 3*N + 2*N*lg N + 3*N**2)
                          ( lg( N ) = smallest integer k
                                      such that 2^k >= N )

    QSTORE (workspace) COMPLEX array, dimension (LDQS, N)
           Used to store parts of
           the eigenvector matrix when the updating matrix multiplies
           take place.

    LDQS   (input) INTEGER
           The leading dimension of the array QSTORE.
           LDQS >= max(1,N).

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).

    =====================================================================

    Warning:      N could be as big as QSIZ!


       Test the input parameters.
*/

    /* Parameter adjustments */
    --d__;          // 将指向数组 d__ 的指针后退一位，即 d__ 指向的是数组 d__ 的首元素
    --e;            // 将指向数组 e 的指针后退一位，即 e 指向的是数组 e 的首元素
    q_dim1 = *ldq;  // 设置二维数组 Q 的第一维长度为 LDQ
    q_offset = 1 + q_dim1;  // 计算 Q 在内存中的偏移量
    q -= q_offset;  // 将 Q 的起始地址调整为正确的地址，使其指向数组 Q 的首元素
    qstore_dim1 = *ldqs;  // 设置二维数组 QSTORE 的第一维长度为 LDQS
    qstore_offset = 1 + qstore_dim1;  // 计算 QSTORE 在内存中的偏移量
    // 从 qstore 中减去 qstore_offset 的值
    qstore -= qstore_offset;
    // 将 rwork 指针向前移动一个位置
    --rwork;
    // 将 iwork 指针向前移动一个位置
    --iwork;

    /* Function Body */
    // 将指针 info 指向的内存位置设置为 0
    *info = 0;
/*
       IF( ICOMPQ .LT. 0 .OR. ICOMPQ .GT. 2 ) THEN
          INFO = -1
       ELSE IF( ( ICOMPQ .EQ. 1 ) .AND. ( QSIZ .LT. MAX( 0, N ) ) )
      $        THEN
*/
    // 检查输入参数的有效性
    if (*qsiz < max(0,*n)) {
        *info = -1;  // 若 QSIZ 小于 max(0, N)，则设置 INFO 为 -1
    } else if (*n < 0) {
        *info = -2;  // 若 N 小于 0，则设置 INFO 为 -2
    } else if (*ldq < max(1,*n)) {
        *info = -6;  // 若 LDQ 小于 max(1, N)，则设置 INFO 为 -6
    } else if (*ldqs < max(1,*n)) {
        *info = -8;  // 若 LDQS 小于 max(1, N)，则设置 INFO 为 -8
    }
    // 若 INFO 不为 0，则调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CLAED0", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 若 N 为 0，则直接返回
    if (*n == 0) {
        return 0;
    }

    // 获取矩阵的最小分块大小
    smlsiz = ilaenv_(&c__9, "CLAED0", " ", &c__0, &c__0, &c__0, &c__0, (
        ftnlen)6, (ftnlen)1);

/*
       Determine the size and placement of the submatrices, and save in
       the leading elements of IWORK.
*/

    // 初始化第一个子块大小为 N
    iwork[1] = *n;
    subpbs = 1;  // 当前子块数量为 1
    tlvls = 0;   // 分割层次初始为 0
L10:
    // 若当前子块大小大于设定的最小分块大小
    if (iwork[subpbs] > smlsiz) {
        // 向下递归分割每个子块
        for (j = subpbs; j >= 1; --j) {
            // 计算每个子块的左右子块大小
            iwork[j * 2] = (iwork[j] + 1) / 2;
            iwork[(j << 1) - 1] = iwork[j] / 2;
        }
        ++tlvls;      // 层次加一
        subpbs <<= 1; // 子块数量加倍
        goto L10;     // 继续处理下一层次的分割
    }
    // 计算每个子块的起始位置
    i__1 = subpbs;
    for (j = 2; j <= i__1; ++j) {
        iwork[j] += iwork[j - 1];
    }

/*
       Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
       using rank-1 modifications (cuts).
*/

    spm1 = subpbs - 1;
    i__1 = spm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 对角线元素减去相邻非对角线元素的绝对值
        submat = iwork[i__] + 1;
        smm1 = submat - 1;
        d__[smm1] -= (r__1 = e[smm1], dabs(r__1));
        d__[submat] -= (r__1 = e[smm1], dabs(r__1));
    }

    indxq = (*n << 2) + 3;

/*
       Set up workspaces for eigenvalues only/accumulate new vectors
       routine
*/

    // 计算使用的工作空间大小
    temp = log((real) (*n)) / log(2.f);
    lgn = (integer) temp;
    if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;
    }
    if (pow_ii(&c__2, &lgn) < *n) {
        ++lgn;
    }
    // 设置工作空间指针
    iprmpt = indxq + *n + 1;
    iperm = iprmpt + *n * lgn;
    iqptr = iperm + *n * lgn;
    igivpt = iqptr + *n + 2;
    igivcl = igivpt + *n * lgn;

    igivnm = 1;
    iq = igivnm + (*n << 1) * lgn;
    // 计算工作空间的末尾位置
    i__1 = *n;
    iwrem = iq + i__1 * i__1 + 1;
/*     Initialize pointers */
    // 初始化工作空间指针
    i__1 = subpbs;
    for (i__ = 0; i__ <= i__1; ++i__) {
        iwork[iprmpt + i__] = 1;
        iwork[igivpt + i__] = 1;
    }

/*
       Solve each submatrix eigenproblem at the bottom of the divide and
       conquer tree.
*/

    curr = 0;   // 当前子块索引初始化为 0
    i__1 = spm1;
    for (i__ = 0; i__ <= i__1; ++i__) {
        if (i__ == 0) {
            submat = 1;
            matsiz = iwork[1];  // 第一个子块的大小
        } else {
            submat = iwork[i__] + 1;
            matsiz = iwork[i__ + 1] - iwork[i__];  // 计算当前子块的大小
        }
        ll = iq - 1 + iwork[iqptr + curr];  // 工作空间的起始位置
        // 解当前子块的特征值问题
        ssteqr_("I", &matsiz, &d__[submat], &e[submat], &rwork[ll], &matsiz, &
            rwork[1], info);
        // 将特征向量从 Q 映射到 QSTORE
        clacrm_(qsiz, &matsiz, &q[submat * q_dim1 + 1], ldq, &rwork[ll], &
            matsiz, &qstore[submat * qstore_dim1 + 1], ldqs, &rwork[iwrem]
            );
        i__2 = matsiz * matsiz;
        iwork[iqptr + curr + 1] = iwork[iqptr + curr] + i__2;  // 更新工作空间指针
        curr++;  // 移动到下一个子块
    }
    # 将指针 curr 的值加一，指向下一个元素
    ++curr;
    # 检查指针 info 指向的值是否大于 0
    if (*info > 0) {
        # 如果条件成立，计算出 *info 的新值，然后返回 0
        *info = submat * (*n + 1) + submat + matsiz - 1;
        return 0;
    }
    # 如果 *info 的值不大于 0，则执行以下操作
    k = 1;
    # 获取 iwork[i__ + 1] 的值，用于循环的上限
    i__2 = iwork[i__ + 1];
    # 循环从 submat 到 i__2
    for (j = submat; j <= i__2; ++j) {
        # 将 k 的值存入 iwork[indxq + j] 中
        iwork[indxq + j] = k;
        # k 值递增
        ++k;
/* L60: */
    }
/* L70: */
    }

/*
       Successively merge eigensystems of adjacent submatrices
       into eigensystem for the corresponding larger matrix.

       while ( SUBPBS > 1 )
*/

    curlvl = 1;
L80:
    if (subpbs > 1) {
    spm2 = subpbs - 2;
    i__1 = spm2;
    for (i__ = 0; i__ <= i__1; i__ += 2) {
        if (i__ == 0) {
        submat = 1;
        matsiz = iwork[2];
        msd2 = iwork[1];
        curprb = 0;
        } else {
        submat = iwork[i__] + 1;
        matsiz = iwork[i__ + 2] - iwork[i__];
        msd2 = matsiz / 2;
        ++curprb;
        }

/*
       Merge lower order eigensystems (of size MSD2 and MATSIZ - MSD2)
       into an eigensystem of size MATSIZ.  CLAED7 handles the case
       when the eigenvectors of a full or band Hermitian matrix (which
       was reduced to tridiagonal form) are desired.

       I am free to use Q as a valuable working space until Loop 150.
*/

        // 调用CLAED7子程序，合并大小为MSD2和MATSIZ-MSD2的特征系统
        claed7_(&matsiz, &msd2, qsiz, &tlvls, &curlvl, &curprb, &d__[
            submat], &qstore[submat * qstore_dim1 + 1], ldqs, &e[
            submat + msd2 - 1], &iwork[indxq + submat], &rwork[iq], &
            iwork[iqptr], &iwork[iprmpt], &iwork[iperm], &iwork[
            igivpt], &iwork[igivcl], &rwork[igivnm], &q[submat *
            q_dim1 + 1], &rwork[iwrem], &iwork[subpbs + 1], info);
        // 如果子程序返回错误信息，则设置info并返回
        if (*info > 0) {
        *info = submat * (*n + 1) + submat + matsiz - 1;
        return 0;
        }
        // 更新iwork数组中的索引值
        iwork[i__ / 2 + 1] = iwork[i__ + 2];
/* L90: */
    }
    // 更新子问题数目并增加当前级别，继续循环处理
    subpbs /= 2;
    ++curlvl;
    goto L80;
    }

/*
       end while

       Re-merge the eigenvalues/vectors which were deflated at the final
       merge step.
*/

    // 将在最终合并步骤中被排除的特征值/特征向量重新合并
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    j = iwork[indxq + i__];
    rwork[i__] = d__[j];
    // 复制Qstore中的数据到Q中
    ccopy_(qsiz, &qstore[j * qstore_dim1 + 1], &c__1, &q[i__ * q_dim1 + 1]
        , &c__1);
/* L100: */
    }
    // 将rwork中的数据复制到d中
    scopy_(n, &rwork[1], &c__1, &d__[1], &c__1);

    // 返回0表示成功完成

    return 0;

/*     End of CLAED0 */

} /* claed0_ */

/* Subroutine */ int claed7_(integer *n, integer *cutpnt, integer *qsiz,
    integer *tlvls, integer *curlvl, integer *curpbm, real *d__, singlecomplex *
    q, integer *ldq, real *rho, integer *indxq, real *qstore, integer *
    qptr, integer *prmptr, integer *perm, integer *givptr, integer *
    givcol, real *givnum, singlecomplex *work, real *rwork, integer *iwork,
    integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;

    /* Local variables */
    static integer i__, k, n1, n2, iq, iw, iz, ptr, indx, curr, indxc, indxp;
    ! 声明外部子程序 claed8_、slaed9_、slaeda_ 和函数 xerbla_、slamrg_
    extern /* Subroutine */ int claed8_(integer *, integer *, integer *,
        singlecomplex *, integer *, real *, real *, integer *, real *, real *,
        singlecomplex *, integer *, real *, integer *, integer *, integer *,
        integer *, integer *, integer *, real *, integer *), slaed9_(
        integer *, integer *, integer *, integer *, real *, real *,
        integer *, real *, real *, real *, real *, integer *, integer *),
        slaeda_(integer *, integer *, integer *, integer *, integer *,
        integer *, integer *, integer *, real *, real *, integer *, real *
        , real *, integer *);
    ! 声明静态整型变量 idlmda 和 coltyp
    static integer idlmda;
    static integer coltyp;
    ! 声明外部子程序 clacrm_ 和 xerbla_，以及函数 slamrg_
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLAED7 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix. This
    routine is used only for the eigenproblem which requires all
    eigenvalues and optionally eigenvectors of a dense or banded
    Hermitian matrix that has been reduced to tridiagonal form.

      T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)

      where Z = Q'u, u is a vector of length N with ones in the
      CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

       The eigenvectors of the original matrix are stored in Q, and the
       eigenvalues are in D.  The algorithm consists of three stages:

          The first stage consists of deflating the size of the problem
          when there are multiple eigenvalues or if there is a zero in
          the Z vector.  For each such occurence the dimension of the
          secular equation problem is reduced by one.  This stage is
          performed by the routine SLAED2.

          The second stage consists of calculating the updated
          eigenvalues. This is done by finding the roots of the secular
          equation via the routine SLAED4 (as called by SLAED3).
          This routine also calculates the eigenvectors of the current
          problem.

          The final stage consists of computing the updated eigenvectors
          directly using the updated eigenvalues.  The eigenvectors for
          the current problem are multiplied with the eigenvectors from
          the overall problem.

    Arguments
    =========

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    CUTPNT (input) INTEGER
           Contains the location of the last eigenvalue in the leading
           sub-matrix.  min(1,N) <= CUTPNT <= N.

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N.

    TLVLS  (input) INTEGER
           The total number of merging levels in the overall divide and
           conquer tree.

    CURLVL (input) INTEGER
           The current level in the overall merge routine,
           0 <= curlvl <= tlvls.

    CURPBM (input) INTEGER
           The current problem in the current level in the overall
           merge routine (counting from upper left to lower right).

    D      (input/output) REAL array, dimension (N)
           On entry, the eigenvalues of the rank-1-perturbed matrix.
           On exit, the eigenvalues of the repaired matrix.

    Q      (input/output) COMPLEX array, dimension (LDQ,N)
           On entry, the eigenvectors of the rank-1-perturbed matrix.
           On exit, the eigenvectors of the repaired tridiagonal matrix.
*/
    ! LDQ是整数，表示数组Q的前导维度，LDQ >= max(1,N)必须满足。
    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    ! RHO是实数，包含用于创建秩-1修改的次对角线元素。
    RHO    (input) REAL
           Contains the subdiagonal element used to create the rank-1
           modification.

    ! INDXQ是整数数组，维度为(N)，存储用于重新整合解决的子问题回到排序顺序的排列。
    INDXQ  (output) INTEGER array, dimension (N)
           This contains the permutation which will reintegrate the
           subproblem just solved back into sorted order,
           ie. D( INDXQ( I = 1, N ) ) will be in ascending order.

    ! IWORK是整数数组，维度为(4*N)，用作工作空间。
    IWORK  (workspace) INTEGER array, dimension (4*N)

    ! RWORK是实数数组，维度为(3*N+2*QSIZ*N)，用作工作空间。
    RWORK  (workspace) REAL array,
                                   dimension (3*N+2*QSIZ*N)

    ! WORK是复数数组，维度为(QSIZ*N)，用作工作空间。
    WORK   (workspace) COMPLEX array, dimension (QSIZ*N)

    ! QSTORE是实数数组，维度为(N**2+1)，用来存储分治过程中遇到的子矩阵的特征向量，紧密排列。
    QSTORE (input/output) REAL array, dimension (N**2+1)
           Stores eigenvectors of submatrices encountered during
           divide and conquer, packed together. QPTR points to
           beginning of the submatrices.

    ! QPTR是整数数组，维度为(N+2)，列表示QSTORE中子矩阵的起始索引。子矩阵从分治树的底部左侧开始，从左到右，从底部到顶部编号。
    QPTR   (input/output) INTEGER array, dimension (N+2)
           List of indices pointing to beginning of submatrices stored
           in QSTORE. The submatrices are numbered starting at the
           bottom left of the divide and conquer tree, from left to
           right and bottom to top.

    ! PRMPTR是整数数组，维度为(N lg N)，包含指针列表，指示PERM中存储的每个级别的置换的位置。
    PRMPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in PERM a
           level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
           indicates the size of the permutation and also the size of
           the full, non-deflated problem.

    ! PERM是整数数组，维度为(N lg N)，包含要应用于每个特征块的置换（从缩减和排序中得到）。
    PERM   (input) INTEGER array, dimension (N lg N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.

    ! GIVPTR是整数数组，维度为(N lg N)，包含指针列表，指示GIVCOL中存储的每个级别的Givens旋转的位置。
    GIVPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in GIVCOL a
           level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
           indicates the number of Givens rotations.

    ! GIVCOL是整数数组，维度为(2, N lg N)，每对数字指示参与Givens旋转的一对列。
    GIVCOL (input) INTEGER array, dimension (2, N lg N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

    ! GIVNUM是实数数组，维度为(2, N lg N)，每个数字指示对应的Givens旋转中要使用的S值。
    GIVNUM (input) REAL array, dimension (2, N lg N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.

    ! INFO是整数，输出参数，指示函数执行结果。
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge

    =====================================================================


       Test the input parameters.
    /* 参数调整 */
    --d__;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --indxq;
    --qstore;
    --qptr;
    --prmptr;
    --perm;
    --givptr;
    givcol -= 3;
    givnum -= 3;
    --work;
    --rwork;
    --iwork;

    /* 函数体 */
    *info = 0;

    /* 检查输入参数的有效性 */
    if (*n < 0) {
        *info = -1;
    } else if (min(1,*n) > *cutpnt || *n < *cutpnt) {
        *info = -2;
    } else if (*qsiz < *n) {
        *info = -3;
    } else if (*ldq < max(1,*n)) {
        *info = -9;
    }

    /* 如果有错误信息，调用错误处理函数并返回 */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CLAED7", &i__1);
        return 0;
    }

    /* 如果 n 为 0，直接返回 */
    if (*n == 0) {
        return 0;
    }

    /*
       以下数值仅用于记录。它们是整数指针，指示 SLAED2 和 SLAED3 中某个数组使用的工作空间部分。
    */

    iz = 1;
    idlmda = iz + *n;
    iw = idlmda + *n;
    iq = iw + *n;

    indx = 1;
    indxc = indx + *n;
    coltyp = indxc + *n;
    indxp = coltyp + *n;

    /*
       形成 z 向量，它由 Q_1 的最后一行和 Q_2 的第一行组成。
    */

    ptr = pow_ii(&c__2, tlvls) + 1;
    i__1 = *curlvl - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = *tlvls - i__;
        ptr += pow_ii(&c__2, &i__2);
        /* L10: */
    }
    curr = ptr + *curpbm;
    slaeda_(n, tlvls, curlvl, curpbm, &prmptr[1], &perm[1], &givptr[1], &
        givcol[3], &givnum[3], &qstore[1], &qptr[1], &rwork[iz], &rwork[
        iz + *n], info);

    /*
       当解决最终问题时，不再需要存储的数据，
       因此将当前级别的数据覆盖到先前使用的存储空间上。
    */

    if (*curlvl == *tlvls) {
        qptr[curr] = 1;
        prmptr[curr] = 1;
        givptr[curr] = 1;
    }

    /* 对特征值进行排序和缩减。 */
    claed8_(&k, n, qsiz, &q[q_offset], ldq, &d__[1], rho, cutpnt, &rwork[iz],
        &rwork[idlmda], &work[1], qsiz, &rwork[iw], &iwork[indxp], &iwork[
        indx], &indxq[1], &perm[prmptr[curr]], &givptr[curr + 1], &givcol[
        (givptr[curr] << 1) + 1], &givnum[(givptr[curr] << 1) + 1], info);
    prmptr[curr + 1] = prmptr[curr] + *n;
    givptr[curr + 1] += givptr[curr];

    /* 解决 Secular 方程。 */
    if (k != 0) {
        slaed9_(&k, &c__1, &k, n, &d__[1], &rwork[iq], &k, rho, &rwork[idlmda]
            , &rwork[iw], &qstore[qptr[curr]], &k, info);
        clacrm_(qsiz, &k, &work[1], qsiz, &qstore[qptr[curr]], &k, &q[
            q_offset], ldq, &rwork[iq]);
        /* 计算 k 的平方 */
        i__1 = k;
        qptr[curr + 1] = qptr[curr] + i__1 * i__1;
        if (*info != 0) {
            return 0;
        }

        /* 准备 INDXQ 排序置换。 */
        n1 = k;
        n2 = *n - k;
        slamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &indxq[1]);
    } else {
        qptr[curr + 1] = qptr[curr];
        i__1 = *n;

        slamrg_(&i__1, &c__0, &d__[1], &c__1, &c_n1, &indxq[1]);
    }
    # 循环遍历索引 i__ 从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 将 indxq 数组中的第 i__ 个元素设置为 i__ 的当前值
        indxq[i__] = i__;
/* L20: */
    }
    }

    return 0;

/*     End of CLAED7 */

} /* claed7_ */

/* Subroutine */ int claed8_(integer *k, integer *n, integer *qsiz, singlecomplex *
    q, integer *ldq, real *d__, real *rho, integer *cutpnt, real *z__,
    real *dlamda, singlecomplex *q2, integer *ldq2, real *w, integer *indxp,
    integer *indx, integer *indxq, integer *perm, integer *givptr,
    integer *givcol, real *givnum, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, q2_dim1, q2_offset, i__1;
    real r__1;

    /* Local variables */
    static real c__;
    static integer i__, j;
    static real s, t;
    static integer k2, n1, n2, jp, n1p1;
    static real eps, tau, tol;
    static integer jlam, imax, jmax;
    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *),
        ccopy_(integer *, singlecomplex *, integer *, singlecomplex *, integer *),
        csrot_(integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        real *, real *), scopy_(integer *, real *, integer *, real *,
        integer *);
    extern doublereal slapy2_(real *, real *), slamch_(char *);
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex
        *, integer *, singlecomplex *, integer *), xerbla_(char *,
        integer *);
    extern integer isamax_(integer *, real *, integer *);
    extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer
        *, integer *, integer *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    CLAED8 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny element in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    K      (output) INTEGER
           Contains the number of non-deflated eigenvalues.
           This is the order of the related secular equation.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    QSIZ   (input) INTEGER
           The dimension of the unitary matrix used to reduce
           the dense or band matrix to tridiagonal form.
           QSIZ >= N if ICOMPQ = 1.

    Q      (input/output) COMPLEX array, dimension (LDQ,N)
           On entry, Q contains the eigenvectors of the partially solved
           system which has been previously updated in matrix
           multiplies with other partially solved eigensystems.
           On exit, Q contains the trailing (N-K) updated eigenvectors
           (those which were deflated) in its last N-K columns.
*/
    ! LDQ 是 Q 数组的前导维度，至少要大于等于 1 和 N 的最大值
    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max( 1, N ).

    ! D 是实数数组，维度为 N。在输入时包含要合并的两个子矩阵的特征值，在输出时包含排序后的剩余 (N-K) 更新后的特征值。
    D      (input/output) REAL array, dimension (N)
           On entry, D contains the eigenvalues of the two submatrices to
           be combined.  On exit, D contains the trailing (N-K) updated
           eigenvalues (those which were deflated) sorted into increasing
           order.

    ! RHO 是实数，包含与原始分割两个子矩阵的秩-1截断相关的非对角元素。在计算过程中被修改为 SLAED3 所需的值。
    RHO    (input/output) REAL
           Contains the off diagonal element associated with the rank-1
           cut which originally split the two submatrices which are now
           being recombined. RHO is modified during the computation to
           the value required by SLAED3.

    ! CUTPNT 是整数，表示前导子矩阵中最后一个特征值的位置。满足 MIN(1,N) <= CUTPNT <= N。
    CUTPNT (input) INTEGER
           Contains the location of the last eigenvalue in the leading
           sub-matrix.  MIN(1,N) <= CUTPNT <= N.

    ! Z 是实数数组，维度为 N。在输入时包含更新向量，即第一个子特征向量矩阵的最后一行和第二个子特征向量矩阵的第一行。在更新过程中，Z 的内容被销毁。
    Z      (input) REAL array, dimension (N)
           On input this vector contains the updating vector (the last
           row of the first sub-eigenvector matrix and the first row of
           the second sub-eigenvector matrix).  The contents of Z are
           destroyed during the updating process.

    ! DLAMDA 是实数数组，维度为 N。在输出时，包含 SLAED3 用来形成标准方程的前 K 个特征值的副本。
    DLAMDA (output) REAL array, dimension (N)
           Contains a copy of the first K eigenvalues which will be used
           by SLAED3 to form the secular equation.

    ! Q2 是复数数组，维度为 (LDQ2,N)。当 ICOMPQ = 0 时，Q2 不被引用。否则，包含 SLAED7 用于矩阵乘法（SGEMM）更新新特征向量的前 K 个特征向量的副本。
    Q2     (output) COMPLEX array, dimension (LDQ2,N)
           If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
           Contains a copy of the first K eigenvectors which will be used
           by SLAED7 in a matrix multiply (SGEMM) to update the new
           eigenvectors.

    ! LDQ2 是 Q2 数组的前导维度，至少要大于等于 1 和 N 的最大值。
    LDQ2   (input) INTEGER
           The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).

    ! W 是实数数组，维度为 N。将保存最终的前 k 个改变后的 z 向量的值，并传递给 SLAED3。
    W      (output) REAL array, dimension (N)
           This will hold the first k values of the final
           deflation-altered z-vector and will be passed to SLAED3.

    ! INDXP 是整数数组，维度为 N，工作空间。将包含用于将 D 的缩减值放置到数组末尾的排列。在输出时，INDXP(1:K) 指向非缩减的 D 值，INDXP(K+1:N) 指向缩减的特征值。
    INDXP  (workspace) INTEGER array, dimension (N)
           This will contain the permutation used to place deflated
           values of D at the end of the array. On output INDXP(1:K)
           points to the nondeflated D-values and INDXP(K+1:N)
           points to the deflated eigenvalues.

    ! INDX 是整数数组，维度为 N，工作空间。将包含用于将 D 的内容排序为升序的排列。
    INDX   (workspace) INTEGER array, dimension (N)
           This will contain the permutation used to sort the contents of
           D into ascending order.

    ! INDXQ 是整数数组，维度为 N，输入。包含用于将 D 的两个子问题分别排序为升序的排列。注意，第二部分排列中的元素必须先加上 CUTPNT 的值以便准确。
    INDXQ  (input) INTEGER array, dimension (N)
           This contains the permutation which separately sorts the two
           sub-problems in D into ascending order.  Note that elements in
           the second half of this permutation must first have CUTPNT
           added to their values in order to be accurate.

    ! PERM 是整数数组，维度为 N，输出。包含应用于每个特征块的（从缩减和排序）排列。
    PERM   (output) INTEGER array, dimension (N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.

    ! GIVPTR 是整数，输出。包含在此子问题中发生的 Givens 旋转的数量。
    GIVPTR (output) INTEGER
           Contains the number of Givens rotations which took place in
           this subproblem.
    # GIVCOL 是一个输出参数，是一个整数数组，大小为 (2, N)，每一对数字表示进行 Givens 旋转时参与的两列索引。
    GIVCOL (output) INTEGER array, dimension (2, N)
           Each pair of numbers indicates a pair of columns to take place
           in a Givens rotation.

    # GIVNUM 是一个输出参数，是一个实数数组，大小为 (2, N)，每个数字表示对应的 Givens 旋转中要使用的 S 值。
    GIVNUM (output) REAL array, dimension (2, N)
           Each number indicates the S value to be used in the
           corresponding Givens rotation.

    # INFO 是一个输出参数，是一个整数，用于指示程序的退出状态。
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    =====================================================================


       # 检验输入参数的合法性。
       Test the input parameters.
    /* Parameter adjustments */
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --d__;
    --z__;
    --dlamda;
    q2_dim1 = *ldq2;
    q2_offset = 1 + q2_dim1;
    q2 -= q2_offset;
    --w;
    --indxp;
    --indx;
    --indxq;
    --perm;
    givcol -= 3;
    givnum -= 3;

    /* Function Body */
    *info = 0;

    if (*n < 0) {
    *info = -2;
    } else if (*qsiz < *n) {
    *info = -3;
    } else if (*ldq < max(1,*n)) {
    *info = -5;
    } else if (*cutpnt < min(1,*n) || *cutpnt > *n) {
    *info = -8;
    } else if (*ldq2 < max(1,*n)) {
    *info = -12;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("CLAED8", &i__1);
    return 0;
    }

/*
       Need to initialize GIVPTR to 0 here in case of quick exit
       to prevent an unspecified code behavior (usually sigfault)
       when IWORK array on entry to *stedc is not zeroed
       (or at least some IWORK entries which used in *laed7 for GIVPTR).
*/

    *givptr = 0;

/*     Quick return if possible */

    if (*n == 0) {
    return 0;
    }

    n1 = *cutpnt;
    n2 = *n - n1;
    n1p1 = n1 + 1;

    if (*rho < 0.f) {
    sscal_(&n2, &c_b1276, &z__[n1p1], &c__1);
    }

/*     Normalize z so that norm(z) = 1 */

    t = 1.f / sqrt(2.f);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
    indx[j] = j;
/* L10: */
    }
    sscal_(n, &t, &z__[1], &c__1);
    *rho = (r__1 = *rho * 2.f, dabs(r__1));

/*     Sort the eigenvalues into increasing order */

    i__1 = *n;
    for (i__ = *cutpnt + 1; i__ <= i__1; ++i__) {
    indxq[i__] += *cutpnt;
/* L20: */
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    dlamda[i__] = d__[indxq[i__]];
    w[i__] = z__[indxq[i__]];
/* L30: */
    }
    i__ = 1;
    j = *cutpnt + 1;
    slamrg_(&n1, &n2, &dlamda[1], &c__1, &c__1, &indx[1]);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    d__[i__] = dlamda[indx[i__]];
    z__[i__] = w[indx[i__]];
/* L40: */
    }

/*     Calculate the allowable deflation tolerance */

    imax = isamax_(n, &z__[1], &c__1);
    jmax = isamax_(n, &d__[1], &c__1);
    eps = slamch_("Epsilon");
    tol = eps * 8.f * (r__1 = d__[jmax], dabs(r__1));

/*
       If the rank-1 modifier is small enough, no more needs to be done
       -- except to reorganize Q so that its columns correspond with the
       elements in D.
*/

    if (*rho * (r__1 = z__[imax], dabs(r__1)) <= tol) {
    *k = 0;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        perm[j] = indxq[indx[j]];
        ccopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1]
            , &c__1);
/* L50: */
    }
    clacpy_("A", qsiz, n, &q2[q2_dim1 + 1], ldq2, &q[q_dim1 + 1], ldq);
    return 0;
    }
/*
       如果存在多个相同的特征值，则问题会收缩。在这里，找到相同特征值的数量。
       每当找到一个相同的特征值时，就计算一个初等反射器，用于旋转相应的特征子空间，
       使得在这个新的基础上，Z 的相应分量为零。
*/

*k = 0;                      // 初始化 k 为 0，用于计数相同特征值的个数
k2 = *n + 1;                 // k2 初始化为 n + 1
i__1 = *n;                   // 循环上限为 n
for (j = 1; j <= i__1; ++j) {
if (*rho * (r__1 = z__[j], dabs(r__1)) <= tol) {

/*           由于 Z 的分量较小而收缩。 */

    --k2;                    // k2 减少 1
    indxp[k2] = j;           // 将当前 j 的索引存入 indxp 数组
    if (j == *n) {
    goto L100;               // 如果 j 等于 n，则跳转到标签 L100
    }
} else {
    jlam = j;                // 否则，将 j 赋给 jlam
    goto L70;                 // 跳转到标签 L70
}
/* L60: */
}
L70:
++j;                         // j 自增
if (j > *n) {
goto L90;                    // 如果 j 大于 n，则跳转到标签 L90
}
if (*rho * (r__1 = z__[j], dabs(r__1)) <= tol) {

/*        由于 Z 的分量较小而收缩。 */

--k2;                        // k2 减少 1
indxp[k2] = j;               // 将当前 j 的索引存入 indxp 数组
} else {

/*        检查特征值是否足够接近以允许收缩。 */

s = z__[jlam];               // 将 z[jlam] 赋给 s
c__ = z__[j];                // 将 z[j] 赋给 c__

/*
          找到 sqrt(a**2+b**2)，避免溢出或破坏性下溢。
*/

tau = slapy2_(&c__, &s);     // 计算 sqrt(c__^2 + s^2)
t = d__[j] - d__[jlam];      // 计算特征值之差
c__ /= tau;                  // c__ 除以 tau
s = -s / tau;                // s 除以 -tau
if ((r__1 = t * c__ * s, dabs(r__1)) <= tol) {

/*           可以进行收缩。 */

    z__[j] = tau;            // 更新 z[j]
    z__[jlam] = 0.f;         // 将 z[jlam] 设为 0

/*           记录适当的 Givens 旋转 */

    ++(*givptr);             // givptr 自增
    givcol[(*givptr << 1) + 1] = indxq[indx[jlam]];     // 记录旋转的列索引
    givcol[(*givptr << 1) + 2] = indxq[indx[j]];        // 记录旋转的列索引
    givnum[(*givptr << 1) + 1] = c__;                   // 记录旋转的参数
    givnum[(*givptr << 1) + 2] = s;                     // 记录旋转的参数
    csrot_(qsiz, &q[indxq[indx[jlam]] * q_dim1 + 1], &c__1, &q[indxq[
        indx[j]] * q_dim1 + 1], &c__1, &c__, &s);       // 应用 Givens 旋转
    t = d__[jlam] * c__ * c__ + d__[j] * s * s;          // 更新特征值
    d__[j] = d__[jlam] * s * s + d__[j] * c__ * c__;     // 更新特征值
    d__[jlam] = t;                                      // 更新特征值
    --k2;                     // k2 减少 1
    i__ = 1;                   // 初始化 i 为 1
L80:
    if (k2 + i__ <= *n) {
    if (d__[jlam] < d__[indxp[k2 + i__]]) {
        indxp[k2 + i__ - 1] = indxp[k2 + i__];         // 交换 indxp 数组的值
        indxp[k2 + i__] = jlam;                        // 将 jlam 存入 indxp 数组
        ++i__;                                         // i 自增
        goto L80;                                      // 跳转到标签 L80
    } else {
        indxp[k2 + i__ - 1] = jlam;                    // 将 jlam 存入 indxp 数组
    }
    } else {
    indxp[k2 + i__ - 1] = jlam;                        // 将 jlam 存入 indxp 数组
    }
    jlam = j;                                          // 更新 jlam
} else {
    ++(*k);                                             // k 自增
    w[*k] = z__[jlam];                                  // 存储特征值到 w 数组
    dlamda[*k] = d__[jlam];                             // 存储特征值到 dlamda 数组
    indxp[*k] = jlam;                                   // 存储索引到 indxp 数组
    jlam = j;                                           // 更新 jlam
}
}
goto L70;                                                // 跳转到标签 L70
L90:

/*     记录最后一个特征值。 */

++(*k);                                                  // k 自增
w[*k] = z__[jlam];                                       // 存储特征值到 w 数组
dlamda[*k] = d__[jlam];                                  // 存储特征值到 dlamda 数组
indxp[*k] = jlam;                                        // 存储索引到 indxp 数组

L100:

/*
       对 DLAMDA 和 Q2 中的特征值和相应的特征向量进行排序。
       没有被收缩的特征值/向量放入 DLAMDA 和 Q2 的前 K 个插槽，
       被收缩的特征值/向量放入后面的 N - K 个插槽。
*/

i__1 = *n;                                                // 循环上限为 n
for (j = 1; j <= i__1; ++j) {
jp = indxp[j];                                            // 获取索引
dlamda[j] = d__[jp];                                      // 从 d 中复制到 dlamda
perm[j] = indxq[indx[jp]];                                // 从 indxq 中复制到 perm
    ccopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1], &
        c__1);



    将 q 数组中从 perm[j] * q_dim1 + 1 开始的连续内存块复制到 q2 数组中，从 j * q2_dim1 + 1 开始，每次步进为 1。
/* L110: */
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

    if (*k < *n) {
        i__1 = *n - *k;
        scopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
        i__1 = *n - *k;
        clacpy_("A", qsiz, &i__1, &q2[(*k + 1) * q2_dim1 + 1], ldq2, &q[(*k +
            1) * q_dim1 + 1], ldq);
    }

    return 0;

/*     End of CLAED8 */

} /* claed8_ */

/* Subroutine */ int clahqr_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, singlecomplex *h__, integer *ldh, singlecomplex *w,
    integer *iloz, integer *ihiz, singlecomplex *z__, integer *ldz, integer *
    info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;
    singlecomplex q__1, q__2, q__3, q__4, q__5, q__6, q__7;

    /* Local variables */
    static integer i__, j, k, l, m;
    static real s;
    static singlecomplex t, u, v[2], x, y;
    static integer i1, i2;
    static singlecomplex t1;
    static real t2;
    static singlecomplex v2;
    static real aa, ab, ba, bb, h10;
    static singlecomplex h11;
    static real h21;
    static singlecomplex h22, sc;
    static integer nh, nz;
    static real sx;
    static integer jhi;
    static singlecomplex h11s;
    static integer jlo, its;
    static real ulp;
    static singlecomplex sum;
    static real tst;
    static singlecomplex temp;
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *), ccopy_(integer *, singlecomplex *, integer *, singlecomplex *,
        integer *);
    static real rtemp;
    extern /* Subroutine */ int slabad_(real *, real *), clarfg_(integer *,
        singlecomplex *, singlecomplex *, integer *, singlecomplex *);
    extern /* Complex */ VOID cladiv_(singlecomplex *, singlecomplex *, singlecomplex *);
    extern doublereal slamch_(char *);
    static real safmin, safmax, smlnum;


/*
*/


    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --w;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */

    if (*n == 0) {
        return 0;
    }
    if (*ilo == *ihi) {
        i__1 = *ilo;
        i__2 = *ilo + *ilo * h_dim1;
        w[i__1].r = h__[i__2].r, w[i__1].i = h__[i__2].i;
        return 0;
    }

/*     ==== clear out the trash ==== */
    i__1 = *ihi - 3;
    for (j = *ilo; j <= i__1; ++j) {
        i__2 = j + 2 + j * h_dim1;
        h__[i__2].r = 0.f, h__[i__2].i = 0.f;
        i__2 = j + 3 + j * h_dim1;
        h__[i__2].r = 0.f, h__[i__2].i = 0.f;
/* L10: */
    }
    if (*ilo <= *ihi - 2) {
        i__1 = *ihi + (*ihi - 2) * h_dim1;
        h__[i__1].r = 0.f, h__[i__1].i = 0.f;
    }
/*     ==== ensure that subdiagonal entries are real ==== */
    if (*wantt) {
        jlo = 1;
        jhi = *n;
    } else {
        jlo = *ilo;
        jhi = *ihi;
    }
    }
    i__1 = *ihi;
    // 遍历 i__ 从 *ilo+1 到 *ihi
    for (i__ = *ilo + 1; i__ <= i__1; ++i__) {
        // 如果矩阵 h__ 中的元素 h__[i__ + (i__ - 1) * h_dim1] 的虚部不为零
        if (r_imag(&h__[i__ + (i__ - 1) * h_dim1]) != 0.f) {
/*
             ==== The following redundant normalization
             .    avoids problems with both gradual and
             .    sudden underflow in ABS(H(I,I-1)) ====
*/
        i__2 = i__ + (i__ - 1) * h_dim1;  // 计算 h[I,I-1] 在一维数组中的索引
        i__3 = i__ + (i__ - 1) * h_dim1;  // 同上，重复的索引计算
        r__3 = (r__1 = h__[i__3].r, dabs(r__1)) + (r__2 = r_imag(&h__[i__
            + (i__ - 1) * h_dim1]), dabs(r__2));  // 计算 ABS(H[I,I-1]) 的大小
        q__1.r = h__[i__2].r / r__3, q__1.i = h__[i__2].i / r__3;  // 根据上述计算结果，对 h[I,I-1] 进行归一化
        sc.r = q__1.r, sc.i = q__1.i;  // 将归一化后的结果保存到 sc 中
        r_cnjg(&q__2, &sc);  // 计算 sc 的共轭复数并保存到 q__2 中
        r__1 = c_abs(&sc);  // 计算 sc 的绝对值
        q__1.r = q__2.r / r__1, q__1.i = q__2.i / r__1;  // 对 sc 的共轭复数进行归一化
        sc.r = q__1.r, sc.i = q__1.i;  // 将归一化后的结果保存到 sc 中
        i__2 = i__ + (i__ - 1) * h_dim1;
        r__1 = c_abs(&h__[i__ + (i__ - 1) * h_dim1]);
        h__[i__2].r = r__1, h__[i__2].i = 0.f;  // 将 h[I,I-1] 的实部设置为其绝对值，虚部设为 0
        i__2 = jhi - i__ + 1;
        cscal_(&i__2, &sc, &h__[i__ + i__ * h_dim1], ldh);  // 对 h[I,I] 到 h[JHI,I] 进行复数乘法，乘数为 sc
/* Computing MIN */
        i__3 = jhi, i__4 = i__ + 1;
        i__2 = min(i__3,i__4) - jlo + 1;  // 计算 min(JHI, I+1) - JLO + 1 的值
        r_cnjg(&q__1, &sc);  // 计算 sc 的共轭复数并保存到 q__1 中
        cscal_(&i__2, &q__1, &h__[jlo + i__ * h_dim1], &c__1);  // 对 h[JLO,I] 到 h[min(JHI, I+1),I] 进行复数乘法，乘数为 sc 的共轭
        if (*wantz) {
        i__2 = *ihiz - *iloz + 1;
        r_cnjg(&q__1, &sc);  // 计算 sc 的共轭复数并保存到 q__1 中
        cscal_(&i__2, &q__1, &z__[*iloz + i__ * z_dim1], &c__1);  // 如果 *wantz 为真，则对 z[*iloz,I] 到 z[*ihiz,I] 进行复数乘法，乘数为 sc 的共轭
        }
    }
/* L20: */
    }

    nh = *ihi - *ilo + 1;  // 计算 nh 的值，即矩阵 H 的维数
    nz = *ihiz - *iloz + 1;  // 计算 nz 的值，即矩阵 Z 的维数

/*     Set machine-dependent constants for the stopping criterion. */

    safmin = slamch_("SAFE MINIMUM");  // 调用 slamch_ 函数设置 safmin，表示安全下限
    safmax = 1.f / safmin;  // 计算 safmax，表示安全上限
    slabad_(&safmin, &safmax);  // 调用 slabad_ 函数，调整 safmin 和 safmax 的值
    ulp = slamch_("PRECISION");  // 调用 slamch_ 函数设置 ulp，表示机器精度
    smlnum = safmin * ((real) nh / ulp);  // 计算 smlnum，表示一个小的数，用于停止判据

/*
       I1 and I2 are the indices of the first row and last column of H
       to which transformations must be applied. If eigenvalues only are
       being computed, I1 and I2 are set inside the main loop.
*/

    if (*wantt) {
    i1 = 1;  // 如果 *wantt 为真，则设置 i1 为 1
    i2 = *n;  // 如果 *wantt 为真，则设置 i2 为 *n
    }

/*
       The main loop begins here. I is the loop index and decreases from
       IHI to ILO in steps of 1. Each iteration of the loop works
       with the active submatrix in rows and columns L to I.
       Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
       H(L,L-1) is negligible so that the matrix splits.
*/

    i__ = *ihi;
L30:
    if (i__ < *ilo) {
    goto L150;  // 如果 i__ 小于 *ilo，则跳转到 L150 标签处
    }

/*
       Perform QR iterations on rows and columns ILO to I until a
       submatrix of order 1 splits off at the bottom because a
       subdiagonal element has become negligible.
*/

    l = *ilo;
    for (its = 0; its <= 30; ++its) {

/*        Look for a single small subdiagonal element. */

    i__1 = l + 1;  // 计算 i__1 的值，即 l + 1
    // 从 i__ 开始向 i__1 方向递减遍历 k
    for (k = i__; k >= i__1; --k) {
        // 计算当前主对角线元素的绝对值和相应虚部的绝对值之和，判断是否小于等于 smlnum
        i__2 = k + (k - 1) * h_dim1;
        if ((r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&h__[k + (k
            - 1) * h_dim1]), dabs(r__2)) <= smlnum) {
        // 如果条件成立，跳转到标签 L50
        goto L50;
        }
        // 计算当前主对角线元素及其相邻元素的绝对值之和
        i__2 = k - 1 + (k - 1) * h_dim1;
        i__3 = k + k * h_dim1;
        tst = (r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&h__[k -
            1 + (k - 1) * h_dim1]), dabs(r__2)) + ((r__3 = h__[i__3]
            .r, dabs(r__3)) + (r__4 = r_imag(&h__[k + k * h_dim1]),
            dabs(r__4)));
        // 如果计算结果为 0
        if (tst == 0.f) {
        // 如果 k-2 大于等于 *ilo
            if (k - 2 >= *ilo) {
                i__2 = k - 1 + (k - 2) * h_dim1;
                // 将 h__ 中第 k-1 行 k-2 列元素的绝对值加到 tst
                tst += (r__1 = h__[i__2].r, dabs(r__1));
            }
        // 如果 k+1 小于等于 *ihi
            if (k + 1 <= *ihi) {
                i__2 = k + 1 + k * h_dim1;
                // 将 h__ 中第 k+1 行 k 列元素的绝对值加到 tst
                tst += (r__1 = h__[i__2].r, dabs(r__1));
            }
        }
/*
             ==== The following is a conservative small subdiagonal
             .    deflation criterion due to Ahues & Tisseur (LAWN 122,
             .    1997). It has better mathematical foundation and
             .    improves accuracy in some examples.  ====
*/
        i__2 = k + (k - 1) * h_dim1;
        // 检查H矩阵的(k,k-1)位置处的实部是否小于或等于阈值ulp乘以tst的绝对值
        if ((r__1 = h__[i__2].r, dabs(r__1)) <= ulp * tst) {
/* Computing MAX */
        i__2 = k + (k - 1) * h_dim1;
        i__3 = k - 1 + k * h_dim1;
        // 计算ab为H矩阵中(k,k-1)和(k-1,k)位置处的实部和虚部绝对值的较大值
        r__5 = (r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&h__[
            k + (k - 1) * h_dim1]), dabs(r__2)), r__6 = (r__3 =
            h__[i__3].r, dabs(r__3)) + (r__4 = r_imag(&h__[k - 1
            + k * h_dim1]), dabs(r__4));
        ab = dmax(r__5,r__6);
/* Computing MIN */
        i__2 = k + (k - 1) * h_dim1;
        i__3 = k - 1 + k * h_dim1;
        // 计算ba为H矩阵中(k,k-1)和(k-1,k)位置处的实部和虚部绝对值的较小值
        r__5 = (r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&h__[
            k + (k - 1) * h_dim1]), dabs(r__2)), r__6 = (r__3 =
            h__[i__3].r, dabs(r__3)) + (r__4 = r_imag(&h__[k - 1
            + k * h_dim1]), dabs(r__4));
        ba = dmin(r__5,r__6);
        i__2 = k - 1 + (k - 1) * h_dim1;
        i__3 = k + k * h_dim1;
        // 计算aa为H矩阵中(k-1,k-1)和(k,k)位置处的实部和虚部之差的绝对值与(k,k)位置处的实部和虚部绝对值的较大值
        q__2.r = h__[i__2].r - h__[i__3].r, q__2.i = h__[i__2].i -
            h__[i__3].i;
        q__1.r = q__2.r, q__1.i = q__2.i;
/* Computing MAX */
        i__4 = k + k * h_dim1;
        // 计算aa为上述结果与(k,k)位置处的实部和虚部绝对值之和的较大值
        r__5 = (r__1 = h__[i__4].r, dabs(r__1)) + (r__2 = r_imag(&h__[
            k + k * h_dim1]), dabs(r__2)), r__6 = (r__3 = q__1.r,
            dabs(r__3)) + (r__4 = r_imag(&q__1), dabs(r__4));
        aa = dmax(r__5,r__6);
        i__2 = k - 1 + (k - 1) * h_dim1;
        i__3 = k + k * h_dim1;
        // 计算bb为H矩阵中(k-1,k-1)和(k,k)位置处的实部和虚部之差的绝对值与(k,k)位置处的实部和虚部绝对值的较小值
        q__2.r = h__[i__2].r - h__[i__3].r, q__2.i = h__[i__2].i -
            h__[i__3].i;
        q__1.r = q__2.r, q__1.i = q__2.i;
/* Computing MIN */
        i__4 = k + k * h_dim1;
        // 计算bb为上述结果与(k,k)位置处的实部和虚部绝对值之和的较小值
        r__5 = (r__1 = h__[i__4].r, dabs(r__1)) + (r__2 = r_imag(&h__[
            k + k * h_dim1]), dabs(r__2)), r__6 = (r__3 = q__1.r,
            dabs(r__3)) + (r__4 = r_imag(&q__1), dabs(r__4));
        bb = dmin(r__5,r__6);
        s = aa + ab;
/* Computing MAX */
        r__1 = smlnum, r__2 = ulp * (bb * (aa / s));
        // 检查小矩阵缩减的条件是否满足
        if (ba * (ab / s) <= dmax(r__1,r__2)) {
            goto L50;
        }
        }
/* L40: */
    }
L50:
    l = k;
    if (l > *ilo) {

/*           H(L,L-1) is negligible */

        i__1 = l + (l - 1) * h_dim1;
        // 将H矩阵中L行L-1列位置的实部和虚部设为0
        h__[i__1].r = 0.f, h__[i__1].i = 0.f;
    }

/*        Exit from loop if a submatrix of order 1 has split off. */

    if (l >= i__) {
        goto L140;
    }

/*
          Now the active submatrix is in rows and columns L to I. If
          eigenvalues only are being computed, only the active submatrix
          need be transformed.
*/

    if (! (*wantt)) {
        i1 = l;
        i2 = i__;
    }

    if (its == 10) {
/*           Exceptional shift. */

        // 计算 h[l+1][l] 元素的索引
        i__1 = l + 1 + l * h_dim1;
        // 计算 s 作为 h[l+1][l] 元素的绝对值的 0.75 倍
        s = (r__1 = h__[i__1].r, dabs(r__1)) * .75f;
        // 将 s 加到 h[l][l] 元素上，并存储到 t 中
        i__1 = l + l * h_dim1;
        q__1.r = s + h__[i__1].r, q__1.i = h__[i__1].i;
        t.r = q__1.r, t.i = q__1.i;
    } else if (its == 20) {

/*           Exceptional shift. */

        // 计算 h[i][i-1] 元素的索引
        i__1 = i__ + (i__ - 1) * h_dim1;
        // 计算 s 作为 h[i][i-1] 元素的绝对值的 0.75 倍
        s = (r__1 = h__[i__1].r, dabs(r__1)) * .75f;
        // 将 s 加到 h[i][i] 元素上，并存储到 t 中
        i__1 = i__ + i__ * h_dim1;
        q__1.r = s + h__[i__1].r, q__1.i = h__[i__1].i;
        t.r = q__1.r, t.i = q__1.i;
    } else {

/*           Wilkinson's shift. */

        // 获取 h[i][i] 元素的值，并存储到 t 中
        i__1 = i__ + i__ * h_dim1;
        t.r = h__[i__1].r, t.i = h__[i__1].i;
        // 计算两个复数的平方根并存储到 u 中
        c_sqrt(&q__2, &h__[i__ - 1 + i__ * h_dim1]);
        c_sqrt(&q__3, &h__[i__ + (i__ - 1) * h_dim1]);
        q__1.r = q__2.r * q__3.r - q__2.i * q__3.i, q__1.i = q__2.r *
            q__3.i + q__2.i * q__3.r;
        u.r = q__1.r, u.i = q__1.i;
        // 计算 u 的模并赋值给 s
        s = (r__1 = u.r, dabs(r__1)) + (r__2 = r_imag(&u), dabs(r__2));
        // 如果 s 不为 0，则继续下面的操作
        if (s != 0.f) {
        // 计算 h[i-1][i-1] 元素与 t 的差的一半，并存储到 x 中
        i__1 = i__ - 1 + (i__ - 1) * h_dim1;
        q__2.r = h__[i__1].r - t.r, q__2.i = h__[i__1].i - t.i;
        q__1.r = q__2.r * .5f, q__1.i = q__2.i * .5f;
        x.r = q__1.r, x.i = q__1.i;
        // 计算 x 的模并赋值给 sx
        sx = (r__1 = x.r, dabs(r__1)) + (r__2 = r_imag(&x), dabs(r__2)
            );
/* Computing MAX */
        // 计算 s 和 sx 的最大值，并赋值给 s
        r__3 = s, r__4 = (r__1 = x.r, dabs(r__1)) + (r__2 = r_imag(&x)
            , dabs(r__2));
        s = dmax(r__3,r__4);
        // 计算 x/s 的平方，并存储到 q__4 中
        q__5.r = x.r / s, q__5.i = x.i / s;
        pow_ci(&q__4, &q__5, &c__2);
        // 计算 u/s 的平方，并存储到 q__6 中
        q__7.r = u.r / s, q__7.i = u.i / s;
        pow_ci(&q__6, &q__7, &c__2);
        // 计算 q__4 与 q__6 的和的平方根，并存储到 q__2 中
        q__3.r = q__4.r + q__6.r, q__3.i = q__4.i + q__6.i;
        c_sqrt(&q__2, &q__3);
        // 计算 s 与 q__2 的乘积，并存储到 q__1 中
        q__1.r = s * q__2.r, q__1.i = s * q__2.i;
        y.r = q__1.r, y.i = q__1.i;
        // 如果 sx > 0，则进行下面的判断
        if (sx > 0.f) {
            // 计算 x/sx，并存储到 q__1 中
            q__1.r = x.r / sx, q__1.i = x.i / sx;
            // 计算 x/sx 的共轭乘以 y 的共轭，并与 0 进行比较
            q__2.r = x.r / sx, q__2.i = x.i / sx;
            if (q__1.r * y.r + r_imag(&q__2) * r_imag(&y) < 0.f) {
            // 如果小于 0，则将 y 取负值
            q__3.r = -y.r, q__3.i = -y.i;
            y.r = q__3.r, y.i = q__3.i;
            }
        }
        // 计算 x 与 y 的和，并进行复数除法，并存储到 q__3 中
        q__4.r = x.r + y.r, q__4.i = x.i + y.i;
        cladiv_(&q__3, &u, &q__4);
        // 计算 t 与 q__3 的差，并存储到 q__1 中
        q__2.r = u.r * q__3.r - u.i * q__3.i, q__2.i = u.r * q__3.i +
            u.i * q__3.r;
        q__1.r = t.r - q__2.r, q__1.i = t.i - q__2.i;
        t.r = q__1.r, t.i = q__1.i;
        }
    }

/*        Look for two consecutive small subdiagonal elements. */

    // 循环查找两个连续的小的次对角线元素
    i__1 = l + 1;
    for (m = i__ - 1; m >= i__1; --m) {

/*
             Determine the effect of starting the single-shift QR
             iteration at row M, and see if this would make H(M,M-1)
             negligible.
        i__2 = m + m * h_dim1;
        h11.r = h__[i__2].r, h11.i = h__[i__2].i;
        i__2 = m + 1 + (m + 1) * h_dim1;
        h22.r = h__[i__2].r, h22.i = h__[i__2].i;
        q__1.r = h11.r - t.r, q__1.i = h11.i - t.i;
        h11s.r = q__1.r, h11s.i = q__1.i;
        i__2 = m + 1 + m * h_dim1;
        h21 = h__[i__2].r;
        s = (r__1 = h11s.r, dabs(r__1)) + (r__2 = r_imag(&h11s), dabs(
            r__2)) + dabs(h21);
        q__1.r = h11s.r / s, q__1.i = h11s.i / s;
        h11s.r = q__1.r, h11s.i = q__1.i;
        h21 /= s;
        v[0].r = h11s.r, v[0].i = h11s.i;
        v[1].r = h21, v[1].i = 0.f;
        i__2 = m + (m - 1) * h_dim1;
        h10 = h__[i__2].r;
        if (dabs(h10) * dabs(h21) <= ulp * (((r__1 = h11s.r, dabs(r__1))
            + (r__2 = r_imag(&h11s), dabs(r__2))) * ((r__3 = h11.r,
            dabs(r__3)) + (r__4 = r_imag(&h11), dabs(r__4)) + ((r__5 =
             h22.r, dabs(r__5)) + (r__6 = r_imag(&h22), dabs(r__6)))))
            ) {
            goto L70;
        }


L60: 
    }
    i__1 = l + l * h_dim1;
    h11.r = h__[i__1].r, h11.i = h__[i__1].i;
    i__1 = l + 1 + (l + 1) * h_dim1;
    h22.r = h__[i__1].r, h22.i = h__[i__1].i;
    q__1.r = h11.r - t.r, q__1.i = h11.i - t.i;
    h11s.r = q__1.r, h11s.i = q__1.i;
    i__1 = l + 1 + l * h_dim1;
    h21 = h__[i__1].r;
    s = (r__1 = h11s.r, dabs(r__1)) + (r__2 = r_imag(&h11s), dabs(r__2))
        + dabs(h21);
    q__1.r = h11s.r / s, q__1.i = h11s.i / s;
    h11s.r = q__1.r, h11s.i = q__1.i;
    h21 /= s;
    v[0].r = h11s.r, v[0].i = h11s.i;
    v[1].r = h21, v[1].i = 0.f;
L70:


        Single-shift QR step

    i__1 = i__ - 1;
    for (k = m; k <= i__1; ++k) {


        if (k > m) {
            ccopy_(&c__2, &h__[k + (k - 1) * h_dim1], &c__1, v, &c__1);
        }
        clarfg_(&c__2, v, &v[1], &c__1, &t1);
        if (k > m) {
            i__2 = k + (k - 1) * h_dim1;
            h__[i__2].r = v[0].r, h__[i__2].i = v[0].i;
            i__2 = k + 1 + (k - 1) * h_dim1;
            h__[i__2].r = 0.f, h__[i__2].i = 0.f;
        }
        v2.r = v[1].r, v2.i = v[1].i;
        q__1.r = t1.r * v2.r - t1.i * v2.i, q__1.i = t1.r * v2.i + t1.i *
            v2.r;
        t2 = q__1.r;


             The first iteration of this loop determines a reflection G
             from the vector V and applies it from left and right to H,
             thus creating a nonzero bulge below the subdiagonal.

             Each subsequent iteration determines a reflection G to
             restore the Hessenberg form in the (K-1)th column, and thus
             chases the bulge one step toward the bottom of the active
             submatrix.

             V(2) is always real before the call to CLARFG, and hence
             after the call T2 ( = T1*V(2) ) is also real.
        i__2 = i2;
        // 循环：对于每个 j 从 k 到 i2
        for (j = k; j <= i__2; ++j) {
        // 计算共轭复数 t1 的复数共轭
        r_cnjg(&q__3, &t1);
        // 计算矩阵 h__ 中的元素索引
        i__3 = k + j * h_dim1;
        // 计算 h__[i3] 的乘积
        q__2.r = q__3.r * h__[i__3].r - q__3.i * h__[i__3].i, q__2.i =
             q__3.r * h__[i__3].i + q__3.i * h__[i__3].r;
        // 计算矩阵 h__ 中的元素索引
        i__4 = k + 1 + j * h_dim1;
        // 计算 h__[i4] 的乘积
        q__4.r = t2 * h__[i__4].r, q__4.i = t2 * h__[i__4].i;
        // 计算 q1 作为两个复数的和
        q__1.r = q__2.r + q__4.r, q__1.i = q__2.i + q__4.i;
        // 将 q1 赋值给 sum
        sum.r = q__1.r, sum.i = q__1.i;
        // 计算矩阵 h__ 中的元素索引
        i__3 = k + j * h_dim1;
        // 计算 h__[i3] 的差
        q__1.r = h__[i__3].r - sum.r, q__1.i = h__[i__3].i - sum.i;
        // 将 q1 赋值给 h__[i3]
        h__[i__3].r = q__1.r, h__[i__3].i = q__1.i;
        // 计算矩阵 h__ 中的元素索引
        i__3 = k + 1 + j * h_dim1;
        // 计算 h__[i3] 的乘积
        i__4 = k + 1 + j * h_dim1;
        q__2.r = sum.r * v2.r - sum.i * v2.i, q__2.i = sum.r * v2.i +
            sum.i * v2.r;
        // 计算 h__[i4] 的差
        q__1.r = h__[i__4].r - q__2.r, q__1.i = h__[i__4].i - q__2.i;
        // 将 q1 赋值给 h__[i4]
        h__[i__3].r = q__1.r, h__[i__3].i = q__1.i;
/* L80: */
        }

/*
             Apply G from the right to transform the columns of the
             matrix in rows I1 to min(K+2,I).

   Computing MIN
*/
        // 计算 MIN(K+2, I)
        i__3 = k + 2;
        i__2 = min(i__3,i__);
        // 循环：对于每个 j 从 i1 到 min(k+2, i__)
        for (j = i1; j <= i__2; ++j) {
        // 计算矩阵 h__ 中的元素索引
        i__3 = j + k * h_dim1;
        // 计算 h__[i3] 的乘积
        q__2.r = t1.r * h__[i__3].r - t1.i * h__[i__3].i, q__2.i =
            t1.r * h__[i__3].i + t1.i * h__[i__3].r;
        // 计算矩阵 h__ 中的元素索引
        i__4 = j + (k + 1) * h_dim1;
        // 计算 h__[i4] 的乘积
        q__3.r = t2 * h__[i__4].r, q__3.i = t2 * h__[i__4].i;
        // 计算 q1 作为两个复数的和
        q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
        // 将 q1 赋值给 sum
        sum.r = q__1.r, sum.i = q__1.i;
        // 计算矩阵 h__ 中的元素索引
        i__3 = j + k * h_dim1;
        // 计算 h__[i3] 的差
        q__1.r = h__[i__3].r - sum.r, q__1.i = h__[i__3].i - sum.i;
        // 将 q1 赋值给 h__[i3]
        h__[i__3].r = q__1.r, h__[i__3].i = q__1.i;
        // 计算矩阵 h__ 中的元素索引
        i__3 = j + (k + 1) * h_dim1;
        // 计算 h__[i3] 的乘积
        i__4 = j + (k + 1) * h_dim1;
        r_cnjg(&q__3, &v2);
        // 计算 q2 作为两个复数的差
        q__2.r = sum.r * q__3.r - sum.i * q__3.i, q__2.i = sum.r *
            q__3.i + sum.i * q__3.r;
        // 计算 h__[i4] 的差
        q__1.r = h__[i__4].r - q__2.r, q__1.i = h__[i__4].i - q__2.i;
        // 将 q1 赋值给 h__[i4]
        h__[i__3].r = q__1.r, h__[i__3].i = q__1.i;
/* L90: */
        }

        if (*wantz) {
/*              Accumulate transformations in the matrix Z */

        /* 循环遍历从 iloz 到 ihiz 的每一列 */
        i__2 = *ihiz;
        for (j = *iloz; j <= i__2; ++j) {
            /* 计算 Z 矩阵中的两个乘积 */
            i__3 = j + k * z_dim1;
            q__2.r = t1.r * z__[i__3].r - t1.i * z__[i__3].i, q__2.i =
                 t1.r * z__[i__3].i + t1.i * z__[i__3].r;
            i__4 = j + (k + 1) * z_dim1;
            q__3.r = t2 * z__[i__4].r, q__3.i = t2 * z__[i__4].i;
            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
            sum.r = q__1.r, sum.i = q__1.i;
            /* 更新 Z 矩阵中的元素 */
            i__3 = j + k * z_dim1;
            i__4 = j + k * z_dim1;
            q__1.r = z__[i__4].r - sum.r, q__1.i = z__[i__4].i -
                sum.i;
            z__[i__3].r = q__1.r, z__[i__3].i = q__1.i;
            i__3 = j + (k + 1) * z_dim1;
            i__4 = j + (k + 1) * z_dim1;
            /* 计算更新后的 Z 矩阵元素 */
            r_cnjg(&q__3, &v2);
            q__2.r = sum.r * q__3.r - sum.i * q__3.i, q__2.i = sum.r *
                 q__3.i + sum.i * q__3.r;
            q__1.r = z__[i__4].r - q__2.r, q__1.i = z__[i__4].i -
                q__2.i;
            z__[i__3].r = q__1.r, z__[i__3].i = q__1.i;
/* L100: */
        }
        }

        /* 如果 k == m 并且 m > l，进行额外的缩放操作 */
        if (k == m && m > l) {

/*
                If the QR step was started at row M > L because two
                consecutive small subdiagonals were found, then extra
                scaling must be performed to ensure that H(M,M-1) remains
                real.
*/

        /* 计算缩放因子 temp */
        q__1.r = 1.f - t1.r, q__1.i = 0.f - t1.i;
        temp.r = q__1.r, temp.i = q__1.i;
        /* 计算缩放因子的模 */
        r__1 = c_abs(&temp);
        /* 根据模值进行缩放 */
        q__1.r = temp.r / r__1, q__1.i = temp.i / r__1;
        temp.r = q__1.r, temp.i = q__1.i;
        /* 更新 H 矩阵的元素 */
        i__2 = m + 1 + m * h_dim1;
        i__3 = m + 1 + m * h_dim1;
        r_cnjg(&q__2, &temp);
        q__1.r = h__[i__3].r * q__2.r - h__[i__3].i * q__2.i, q__1.i =
             h__[i__3].r * q__2.i + h__[i__3].i * q__2.r;
        h__[i__2].r = q__1.r, h__[i__2].i = q__1.i;
        /* 如果条件满足，继续更新 H 矩阵的元素 */
        if (m + 2 <= i__) {
            i__2 = m + 2 + (m + 1) * h_dim1;
            i__3 = m + 2 + (m + 1) * h_dim1;
            q__1.r = h__[i__3].r * temp.r - h__[i__3].i * temp.i,
                q__1.i = h__[i__3].r * temp.i + h__[i__3].i *
                temp.r;
            h__[i__2].r = q__1.r, h__[i__2].i = q__1.i;
        }
        /* 对 H 矩阵的一部分进行缩放操作 */
        i__2 = i__;
        for (j = m; j <= i__2; ++j) {
            /* 如果 j 不等于 m+1，继续缩放操作 */
            if (j != m + 1) {
            /* 根据条件进行不同的缩放操作 */
            if (i2 > j) {
                i__3 = i2 - j;
                cscal_(&i__3, &temp, &h__[j + (j + 1) * h_dim1],
                    ldh);
            }
            /* 继续进行缩放操作 */
            i__3 = j - i1;
            r_cnjg(&q__1, &temp);
            cscal_(&i__3, &q__1, &h__[i1 + j * h_dim1], &c__1);
            /* 如果需要 Z 矩阵也进行缩放操作 */
            if (*wantz) {
                r_cnjg(&q__1, &temp);
                cscal_(&nz, &q__1, &z__[*iloz + j * z_dim1], &
                    c__1);
            }
            }
/* L110: */
        }
        }
/* L120: */
    }

/*        Ensure that H(I,I-1) is real. */

    /* 确保 H(I,I-1) 是实数 */
    i__1 = i__ + (i__ - 1) * h_dim1;
    temp.r = h__[i__1].r, temp.i = h__[i__1].i;
    # 检查 temp 的虚部是否不为零
    if (r_imag(&temp) != 0.f) {
        # 计算 temp 的模长并赋值给 rtemp
        rtemp = c_abs(&temp);
        # 计算 h__ 矩阵中特定位置的索引
        i__1 = i__ + (i__ - 1) * h_dim1;
        # 将 rtemp 赋给 h__ 矩阵中的实部，虚部置零
        h__[i__1].r = rtemp, h__[i__1].i = 0.f;
        # 计算 temp 除以 rtemp 的结果并更新 temp 的值
        q__1.r = temp.r / rtemp, q__1.i = temp.i / rtemp;
        temp.r = q__1.r, temp.i = q__1.i;
        # 如果 i2 大于 i__，则进行下面的操作
        if (i2 > i__) {
            # 计算 temp 的共轭并乘以 h__ 矩阵中的特定列
            i__1 = i2 - i__;
            r_cnjg(&q__1, &temp);
            cscal_(&i__1, &q__1, &h__[i__ + (i__ + 1) * h_dim1], ldh);
        }
        # 计算 i__ - i1，并将 temp 乘以 h__ 矩阵中的特定行
        i__1 = i__ - i1;
        cscal_(&i__1, &temp, &h__[i1 + i__ * h_dim1], &c__1);
        # 如果 *wantz 为真，则将 temp 乘以 z__ 矩阵中的特定列
        if (*wantz) {
            cscal_(&nz, &temp, &z__[*iloz + i__ * z_dim1], &c__1);
        }
    }
/* L130: */
    }

/*     Failure to converge in remaining number of iterations */

    *info = i__;
    return 0;

L140:

/*     H(I,I-1) is negligible: one eigenvalue has converged. */

    i__1 = i__;
    i__2 = i__ + i__ * h_dim1;
    w[i__1].r = h__[i__2].r, w[i__1].i = h__[i__2].i;

/*     return to start of the main loop with new value of I. */

    i__ = l - 1;
    goto L30;

L150:
    return 0;

/*     End of CLAHQR */

} /* clahqr_ */

/* Subroutine */ int clahr2_(integer *n, integer *k, integer *nb, singlecomplex *a,
    integer *lda, singlecomplex *tau, singlecomplex *t, integer *ldt, singlecomplex *y,
    integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    singlecomplex q__1;

    /* Local variables */
    static integer i__;
    static singlecomplex ei;
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *), cgemm_(char *, char *, integer *, integer *, integer *
        , singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *
        , singlecomplex *, integer *), cgemv_(char *, integer *,
         integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
         singlecomplex *, singlecomplex *, integer *), ccopy_(integer *,
        singlecomplex *, integer *, singlecomplex *, integer *), ctrmm_(char *, char *
        , char *, char *, integer *, integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *),
        caxpy_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *), ctrmv_(char *, char *, char *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *), clarfg_(
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *), clacgv_(
        integer *, singlecomplex *, integer *), clacpy_(char *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *);


/*  -- LAPACK auxiliary routine (version 3.2.1)                        -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    --*  -- April 2009
                                 -- */
/*
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    CLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
    matrix A so that elements below the k-th subdiagonal are zero. The
    reduction is performed by an unitary similarity transformation
    Q' * A * Q. The routine returns the matrices V and T which determine
    Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.

    This is an auxiliary routine called by CGEHRD.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.

    K       (input) INTEGER
            The number of columns to be reduced.

    NB      (input) INTEGER
            The number of columns to be blocked together for the
            reduction. NB > 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the (k+nb)-th subdiagonal
            are overwritten with the corresponding elements of the
            reduced matrix Q'*A*Q.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,N).

    T       (output) COMPLEX array, dimension (LDT,NB)
            The upper triangular matrix T produced in reduction by
            blocking NB columns together and doing a unitary
            similarity transformation for the matrix A.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,NB).

    Y       (output) COMPLEX array, dimension (LDY,NB)
            The n-by-nb matrix Y = A * V * T.

    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).

    Further Details
    ===============

    The reduction is performed by a sequence of untary transformations.
    See "Further Details" section of CGEHRD.

    =====================================================================
*/
    # 输入参数 K，表示要进行归约的偏移量。在矩阵 A 的前 NB 列中，位于第 k 条次对角线以下的元素将被归零。
    # 要求 K < N。
    K       (input) INTEGER

    # 输入参数 NB，表示要进行归约的列数。
    NB      (input) INTEGER

    # 输入/输出参数 A，复数数组，维度为 (LDA, N-K+1)。
    # 在输入时，A 是一个 n-by-(n-k+1) 的一般矩阵。
    # 在输出时，A 的前 NB 列中第 k 条次对角线及其以上的元素将被归约为简化矩阵的对应元素；
    # 在第 k 条次对角线以下的元素用数组 TAU 表示，表示矩阵 Q 是一系列初等反射器的乘积。
    A       (input/output) COMPLEX array, dimension (LDA,N-K+1)

    # 输入参数 LDA，参数 A 的行主导维度。要求 LDA >= max(1,N)。
    LDA     (input) INTEGER

    # 输出参数 TAU，复数数组，维度为 (NB)。
    # 存储初等反射器的标量因子。详见 Further Details。
    TAU     (output) COMPLEX array, dimension (NB)

    # 输出参数 T，复数数组，维度为 (LDT,NB)。
    # 上三角矩阵 T。
    T       (output) COMPLEX array, dimension (LDT,NB)

    # 输入参数 LDT，参数 T 的行主导维度。要求 LDT >= NB。
    LDT     (input) INTEGER

    # 输出参数 Y，复数数组，维度为 (LDY,NB)。
    # n-by-nb 矩阵 Y。
    Y       (output) COMPLEX array, dimension (LDY,NB)

    # 输入参数 LDY，参数 Y 的行主导维度。要求 LDY >= N。
    LDY     (input) INTEGER
    performance of reduction to Hessenberg form," ACM Transactions on
    Mathematical Software, 32(2):180-194, June 2006.

    =====================================================================


       Quick return if possible
    /* 调整参数 */
    --tau;              // 将指针 tau 前移一位，使其指向正确的内存位置
    a_dim1 = *lda;      // 从指针 lda 中获取矩阵 a 的第一维度大小
    a_offset = 1 + a_dim1;  // 计算 a 的偏移量
    a -= a_offset;      // 调整 a 的指针，使其指向正确的起始位置
    t_dim1 = *ldt;      // 从指针 ldt 中获取矩阵 t 的第一维度大小
    t_offset = 1 + t_dim1;  // 计算 t 的偏移量
    t -= t_offset;      // 调整 t 的指针，使其指向正确的起始位置
    y_dim1 = *ldy;      // 从指针 ldy 中获取矩阵 y 的第一维度大小
    y_offset = 1 + y_dim1;  // 计算 y 的偏移量
    y -= y_offset;      // 调整 y 的指针，使其指向正确的起始位置

    /* 函数体 */
    if (*n <= 1) {      // 如果 n 小于等于 1，直接返回
        return 0;
    }

    i__1 = *nb;         // 将 nb 存储的值赋给 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {  // 循环执行 nb 次
        if (i__ > 1) {  // 如果 i 大于 1，则执行以下操作

            /* 更新 A(K+1:N,I) */
            i__2 = i__ - 1;
            clacgv_(&i__2, &a[*k + i__ - 1 + a_dim1], lda);  // 对 a[*k + i__ - 1] 执行共轭运算
            i__2 = *n - *k;
            i__3 = i__ - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemv_("NO TRANSPOSE", &i__2, &i__3, &q__1, &y[*k + 1 + y_dim1],
                ldy, &a[*k + i__ - 1 + a_dim1], lda, &c_b57, &a[*k + 1 +
                i__ * a_dim1], &c__1);  // 执行矩阵向量乘法
            i__2 = i__ - 1;
            clacgv_(&i__2, &a[*k + i__ - 1 + a_dim1], lda);  // 再次对 a[*k + i__ - 1] 执行共轭运算

            /* 应用 I - V * T' * V' 到 A(K+1:N,I) 的列上 */
            i__2 = i__ - 1;
            ccopy_(&i__2, &a[*k + 1 + i__ * a_dim1], &c__1, &t[*nb * t_dim1 +
                1], &c__1);  // 复制向量 a[*k + 1 + i__] 到 t[*nb * t_dim1 + 1]
            i__2 = i__ - 1;
            ctrmv_("Lower", "Conjugate transpose", "UNIT", &i__2, &a[*k + 1 +
                a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);  // 对 t[*nb * t_dim1 + 1] 执行矩阵向量乘法

            /* 计算 w := V2'*b2 */
            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[*k + i__ +
                a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b57,
                &t[*nb * t_dim1 + 1], &c__1);  // 执行矩阵向量乘法

            /* 计算 w := T'*w */
            i__2 = i__ - 1;
            ctrmv_("Upper", "Conjugate transpose", "NON-UNIT", &i__2, &t[
                t_offset], ldt, &t[*nb * t_dim1 + 1], &c__1);  // 对 t[*nb * t_dim1 + 1] 执行矩阵向量乘法

            /* 计算 b2 := b2 - V2*w */
            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemv_("NO TRANSPOSE", &i__2, &i__3, &q__1, &a[*k + i__ + a_dim1],
                 lda, &t[*nb * t_dim1 + 1], &c__1, &c_b57, &a[*k + i__ +
                i__ * a_dim1], &c__1);  // 执行矩阵向量乘法

            /* 计算 b1 := b1 - V1*w */
            i__2 = i__ - 1;
            ctrmv_("Lower", "NO TRANSPOSE", "UNIT", &i__2, &a[*k + 1 + a_dim1]
                , lda, &t[*nb * t_dim1 + 1], &c__1);  // 对 t[*nb * t_dim1 + 1] 执行矩阵向量乘法
            i__2 = i__ - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            caxpy_(&i__2, &q__1, &t[*nb * t_dim1 + 1], &c__1, &a[*k + 1 + i__
                * a_dim1], &c__1);  // 执行向量加法

            i__2 = *k + i__ - 1 + (i__ - 1) * a_dim1;
            a[i__2].r = ei.r, a[i__2].i = ei.i;  // 将 ei 赋值给 a[i__2]

        }

        /* 生成第 I 个元素反射变换 H(I)，使得 A(K+I+1:N,I) 变为零 */
        i__2 = *n - *k - i__ + 1;  // 计算要执行反射变换的元素个数
        /* 计算要调用的 clarfg_ 函数的参数 */
        /* Computing MIN */
        i__3 = *k + i__ + 1;
        clarfg_(&i__2, &a[*k + i__ + i__ * a_dim1], &a[min(i__3,*n) + i__ *
            a_dim1], &c__1, &tau[i__]);  // 执行 clarfg_ 函数，生成反射变换 H(I)
    }
    # 计算数组 `a` 中元素的索引，这里假设 `a` 是一个复数数组，`i__`, `i__2`, `*k` 和 `a_dim1` 是已定义的变量。
    i__2 = *k + i__ + i__ * a_dim1;
    # 将数组 `a` 中索引为 `i__2` 的复数元素的实部和虚部保存到变量 `ei` 中。
    ei.r = a[i__2].r, ei.i = a[i__2].i;
    # 将数组 `a` 中索引为 `i__2` 的复数元素设置为 (1.0, 0.0)，即设置为实部为 1.0，虚部为 0.0。
    i__2 = *k + i__ + i__ * a_dim1;
    a[i__2].r = 1.f, a[i__2].i = 0.f;
/*        Compute  Y(K+1:N,I) */

/* 计算 Y(K+1:N,I) */
i__2 = *n - *k;
/* 计算向量的长度 */
i__3 = *n - *k - i__ + 1;
/* 执行矩阵向量乘法，无转置 */
cgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b57, &a[*k + 1 + (i__ + 1) *
    a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b56, &y[*
    k + 1 + i__ * y_dim1], &c__1);
/* 计算矩阵向量乘法，使用共轭转置 */
i__2 = *n - *k - i__ + 1;
/* 计算矩阵向量乘法，无转置 */
i__3 = i__ - 1;
cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[*k + i__ +
    a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b56, &t[
    i__ * t_dim1 + 1], &c__1);
/* 计算矩阵向量乘法，无转置 */
i__2 = *n - *k;
/* 计算矩阵向量乘法 */
i__3 = i__ - 1;
q__1.r = -1.f, q__1.i = -0.f;
cgemv_("NO TRANSPOSE", &i__2, &i__3, &q__1, &y[*k + 1 + y_dim1], ldy,
    &t[i__ * t_dim1 + 1], &c__1, &c_b57, &y[*k + 1 + i__ * y_dim1]
    , &c__1);
/* 计算向量的长度 */
i__2 = *n - *k;
/* 对向量进行缩放 */
cscal_(&i__2, &tau[i__], &y[*k + 1 + i__ * y_dim1], &c__1);

/*        Compute T(1:I,I) */

/* 计算 T(1:I,I) */
i__2 = i__ - 1;
/* 对矩阵列进行缩放 */
i__3 = i__;
q__1.r = -tau[i__3].r, q__1.i = -tau[i__3].i;
cscal_(&i__2, &q__1, &t[i__ * t_dim1 + 1], &c__1);
/* 对上三角矩阵进行矩阵向量乘法 */
i__2 = i__ - 1;
ctrmv_("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
    &t[i__ * t_dim1 + 1], &c__1)
    ;
/* 对矩阵元素进行赋值 */
i__2 = i__ + i__ * t_dim1;
i__3 = i__;
t[i__2].r = tau[i__3].r, t[i__2].i = tau[i__3].i;

/* L10: */
}
/* 对矩阵元素进行赋值 */
i__1 = *k + *nb + *nb * a_dim1;
a[i__1].r = ei.r, a[i__1].i = ei.i;

/*     Compute Y(1:K,1:NB) */

/* 计算 Y(1:K,1:NB) */
clacpy_("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
/* 对三角矩阵进行矩阵向量乘法 */
ctrmm_("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b57, &a[*k + 1
    + a_dim1], lda, &y[y_offset], ldy);
/* 如果条件成立，进行矩阵乘法 */
if (*n > *k + *nb) {
i__1 = *n - *k - *nb;
cgemm_("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b57, &a[(*nb
    + 2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &
    c_b57, &y[y_offset], ldy);
}
/* 对三角矩阵进行矩阵向量乘法 */
ctrmm_("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b57, &t[
    t_offset], ldt, &y[y_offset], ldy);

return 0;

/*     End of CLAHR2 */

} /* clahr2_ */

/* Subroutine */ int clals0_(integer *icompq, integer *nl, integer *nr,
integer *sqre, integer *nrhs, singlecomplex *b, integer *ldb, singlecomplex *bx,
integer *ldbx, integer *perm, integer *givptr, integer *givcol,
integer *ldgcol, real *givnum, integer *ldgnum, real *poles, real *
difl, real *difr, real *z__, integer *k, real *c__, real *s, real *
rwork, integer *info)
{
/* System generated locals */
integer givcol_dim1, givcol_offset, difr_dim1, difr_offset, givnum_dim1,
    givnum_offset, poles_dim1, poles_offset, b_dim1, b_offset,
    bx_dim1, bx_offset, i__1, i__2, i__3, i__4, i__5;
real r__1;
singlecomplex q__1;

/* Local variables */
static integer i__, j, m, n;
static real dj;
static integer nlp1, jcol;
static real temp;
static integer jrow;
extern doublereal snrm2_(integer *, real *, integer *);
static real diflj, difrj, dsigj;
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *), sgemv_(char *, integer *, integer *, real *
        , real *, integer *, real *, integer *, real *, real *, integer *);
    外部函数声明: ccopy_、sgemv_，分别用于复制复数数组和进行矩阵-向量乘法的操作

    extern doublereal slamc3_(real *, real *);
    外部函数声明: slamc3_，用于计算机器精度相关的常数

    extern /* Subroutine */ int clascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, singlecomplex *, integer *, integer *);
    外部函数声明: clascl_，用于矩阵的缩放操作

    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer *);
    外部函数声明: csscal_，用于复数数组的缩放操作

    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    外部函数声明: clacpy_，用于复制矩阵

    extern /* Subroutine */ int xerbla_(char *, integer *);
    外部函数声明: xerbla_，用于处理错误信息输出

    static real dsigjp;
    静态变量声明: dsigjp，用于存储实数类型的值
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLALS0 applies back the multiplying factors of either the left or the
    right singular vector matrix of a diagonal matrix appended by a row
    to the right hand side matrix B in solving the least squares problem
    using the divide-and-conquer SVD approach.

    For the left singular vector matrix, three types of orthogonal
    matrices are involved:

    (1L) Givens rotations: the number of such rotations is GIVPTR; the
         pairs of columns/rows they were applied to are stored in GIVCOL;
         and the C- and S-values of these rotations are stored in GIVNUM.

    (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
         row, and for J=2:N, PERM(J)-th row of B is to be moved to the
         J-th row.

    (3L) The left singular vector matrix of the remaining matrix.

    For the right singular vector matrix, four types of orthogonal
    matrices are involved:

    (1R) The right singular vector matrix of the remaining matrix.

    (2R) If SQRE = 1, one extra Givens rotation to generate the right
         null space.

    (3R) The inverse transformation of (2L).

    (4R) The inverse transformation of (1L).

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether singular vectors are to be computed in
           factored form:
           = 0: Left singular vector matrix.
           = 1: Right singular vector matrix.

    NL     (input) INTEGER
           The row dimension of the upper block. NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block. NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has row dimension N = NL + NR + 1,
           and column dimension M = N + SQRE.

    NRHS   (input) INTEGER
           The number of columns of B and BX. NRHS must be at least 1.

    B      (input/output) COMPLEX array, dimension ( LDB, NRHS )
           On input, B contains the right hand sides of the least
           squares problem in rows 1 through M. On output, B contains
           the solution X in rows 1 through N.

    LDB    (input) INTEGER
           The leading dimension of B. LDB must be at least
           max(1,MAX( M, N ) ).

    BX     (workspace) COMPLEX array, dimension ( LDBX, NRHS )

    LDBX   (input) INTEGER
           The leading dimension of BX.

    PERM   (input) INTEGER array, dimension ( N )
           The permutations (from deflation and sorting) applied
           to the two blocks.

    GIVPTR (input) INTEGER
           The number of Givens rotations which took place in this
           subproblem.
*/
    ! GIVCOL 是一个输入的整数数组，维度为 (LDGCOL, 2)，
    ! 每一对数字表示参与 Givens 旋转的行或列。
    GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )

    ! GIVCOL 数组的主维度，必须至少为 N。
    LDGCOL (input) INTEGER

    ! GIVNUM 是一个输入的实数数组，维度为 (LDGNUM, 2)，
    ! 每个数字表示相应的 Givens 旋转中使用的 C 或 S 值。
    GIVNUM (input) REAL array, dimension ( LDGNUM, 2 )

    ! GIVNUM 数组的主维度，必须至少为 K。
    LDGNUM (input) INTEGER

    ! POLES 是一个输入的实数数组，维度为 (LDGNUM, 2)，
    ! POLES(1:K, 1) 包含解析方程得到的新奇异值，POLES(1:K, 2) 包含解析方程中的极点。
    POLES  (input) REAL array, dimension ( LDGNUM, 2 )

    ! DIFL 是一个输入的实数数组，维度为 (K)，
    ! DIFL(I) 是第 I 个更新的（未缩小的）奇异值与第 I 个（未缩小的）旧奇异值之间的距离。
    DIFL   (input) REAL array, dimension ( K )

    ! DIFR 是一个输入的实数数组，维度为 (LDGNUM, 2)，
    ! DIFR(I, 1) 包含第 I 个更新的（未缩小的）奇异值与第 I+1 个（未缩小的）旧奇异值之间的距离，
    ! DIFR(I, 2) 是第 I 个右奇异向量的归一化因子。
    DIFR   (input) REAL array, dimension ( LDGNUM, 2 ).

    ! Z 是一个输入的实数数组，维度为 (K)，
    ! 包含缩小调整后的更新行向量的分量。
    Z      (input) REAL array, dimension ( K )

    ! K 是一个输入的整数，
    ! 表示非缩小矩阵的维度，这是相关解析方程的顺序。1 <= K <= N。
    K      (input) INTEGER

    ! C 是一个输入的实数，
    ! 如果 SQRE = 0，C 包含无效值；如果 SQRE = 1，C 是与右零空间相关的 Givens 旋转的 C 值。
    C      (input) REAL

    ! S 是一个输入的实数，
    ! 如果 SQRE = 0，S 包含无效值；如果 SQRE = 1，S 是与右零空间相关的 Givens 旋转的 S 值。
    S      (input) REAL

    ! RWORK 是一个工作空间的实数数组，维度为 (K*(1+NRHS) + 2*NRHS)。
    RWORK  (workspace) REAL array, dimension
           ( K*(1+NRHS) + 2*NRHS )

    ! INFO 是一个输出的整数，
    ! = 0 表示成功退出；
    ! < 0 表示如果 INFO = -i，第 i 个参数具有非法值。
    INFO   (output) INTEGER

    ! 进一步的细节说明：
    ! 基于以下贡献：
    !    Ming Gu 和 Ren-Cang Li，加利福尼亚大学伯克利分校，计算机科学系，美国
    !    Osni Marques，LBNL/NERSC，美国
    ! ================================================================

    ! 测试输入参数。
    Test the input parameters.
    /* Parameter adjustments */
    b_dim1 = *ldb;                           // 设置 b 的第一维度为 ldb
    b_offset = 1 + b_dim1;                   // 计算 b 的偏移量
    b -= b_offset;                           // 调整 b 的起始位置为正确的偏移量
    bx_dim1 = *ldbx;                         // 设置 bx 的第一维度为 ldbx
    bx_offset = 1 + bx_dim1;                 // 计算 bx 的偏移量
    bx -= bx_offset;                         // 调整 bx 的起始位置为正确的偏移量
    --perm;                                  // perm 数组索引从 1 开始，减少指针以匹配 Fortran 习惯
    givcol_dim1 = *ldgcol;                   // 设置 givcol 的第一维度为 ldgcol
    givcol_offset = 1 + givcol_dim1;         // 计算 givcol 的偏移量
    givcol -= givcol_offset;                 // 调整 givcol 的起始位置为正确的偏移量
    difr_dim1 = *ldgnum;                     // 设置 difr 的第一维度为 ldgnum
    difr_offset = 1 + difr_dim1;             // 计算 difr 的偏移量
    difr -= difr_offset;                     // 调整 difr 的起始位置为正确的偏移量
    poles_dim1 = *ldgnum;                    // 设置 poles 的第一维度为 ldgnum
    poles_offset = 1 + poles_dim1;           // 计算 poles 的偏移量
    poles -= poles_offset;                   // 调整 poles 的起始位置为正确的偏移量
    givnum_dim1 = *ldgnum;                   // 设置 givnum 的第一维度为 ldgnum
    givnum_offset = 1 + givnum_dim1;         // 计算 givnum 的偏移量
    givnum -= givnum_offset;                 // 调整 givnum 的起始位置为正确的偏移量
    --difl;                                  // 减少指针以匹配 Fortran 习惯
    --z__;                                   // 减少指针以匹配 Fortran 习惯
    --rwork;                                 // 减少指针以匹配 Fortran 习惯

    /* Function Body */
    *info = 0;                               // 初始化 info 为 0

    if (*icompq < 0 || *icompq > 1) {         // 检查 icompq 是否在有效范围内
        *info = -1;                          // 设置错误代码 -1
    } else if (*nl < 1) {                     // 检查 nl 是否小于 1
        *info = -2;                          // 设置错误代码 -2
    } else if (*nr < 1) {                     // 检查 nr 是否小于 1
        *info = -3;                          // 设置错误代码 -3
    } else if (*sqre < 0 || *sqre > 1) {      // 检查 sqre 是否在有效范围内
        *info = -4;                          // 设置错误代码 -4
    }

    n = *nl + *nr + 1;                        // 计算 n 的值

    if (*nrhs < 1) {                          // 检查 nrhs 是否小于 1
        *info = -5;                          // 设置错误代码 -5
    } else if (*ldb < n) {                    // 检查 ldb 是否小于 n
        *info = -7;                          // 设置错误代码 -7
    } else if (*ldbx < n) {                   // 检查 ldbx 是否小于 n
        *info = -9;                          // 设置错误代码 -9
    } else if (*givptr < 0) {                 // 检查 givptr 是否小于 0
        *info = -11;                         // 设置错误代码 -11
    } else if (*ldgcol < n) {                 // 检查 ldgcol 是否小于 n
        *info = -13;                         // 设置错误代码 -13
    } else if (*ldgnum < n) {                 // 检查 ldgnum 是否小于 n
        *info = -15;                         // 设置错误代码 -15
    } else if (*k < 1) {                      // 检查 k 是否小于 1
        *info = -20;                         // 设置错误代码 -20
    }
    if (*info != 0) {                         // 如果 info 不为 0，表示存在错误
        i__1 = -(*info);                     // 计算错误代码的绝对值
        xerbla_("CLALS0", &i__1);             // 调用错误处理函数 xerbla_
        return 0;                            // 返回
    }

    m = n + *sqre;                            // 计算 m 的值
    nlp1 = *nl + 1;                           // 计算 nlp1 的值

    if (*icompq == 0) {                       // 如果 icompq 为 0，则执行下列操作

/*
          Apply back orthogonal transformations from the left.

          Step (1L): apply back the Givens rotations performed.
*/

    i__1 = *givptr;
    for (i__ = 1; i__ <= i__1; ++i__) {
        csrot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &givnum[i__ + givnum_dim1]);
/* L10: */
    }

/*        Step (2L): permute rows of B. */

    ccopy_(nrhs, &b[nlp1 + b_dim1], ldb, &bx[bx_dim1 + 1], ldbx);
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        ccopy_(nrhs, &b[perm[i__] + b_dim1], ldb, &bx[i__ + bx_dim1],
            ldbx);
/* L20: */
    }

/*
          Step (3L): apply the inverse of the left singular vector
          matrix to BX.
*/

    if (*k == 1) {                            // 如果 k 等于 1，则执行以下操作
        ccopy_(nrhs, &bx[bx_offset], ldbx, &b[b_offset], ldb);
        if (z__[1] < 0.f) {                  // 如果 z__ 的第一个元素小于 0
        csscal_(nrhs, &c_b1276, &b[b_offset], ldb);  // 对 b 进行缩放
        }
    } else {
        // 如果不是第一列的情况，进入循环
        i__1 = *k;
        // 对于每个列 j，执行以下循环
        for (j = 1; j <= i__1; ++j) {
        diflj = difl[j];
        dj = poles[j + poles_dim1];
        dsigj = -poles[j + (poles_dim1 << 1)];
        // 如果 j 小于 k，则设置右侧的 difrj 和 dsigjp
        if (j < *k) {
            difrj = -difr[j + difr_dim1];
            dsigjp = -poles[j + 1 + (poles_dim1 << 1)];
        }
        // 如果 z__[j] 或 poles[j + (poles_dim1 << 1)] 为零，将 rwork[j] 设置为 0
        if (z__[j] == 0.f || poles[j + (poles_dim1 << 1)] == 0.f) {
            rwork[j] = 0.f;
        } else {
            // 否则，计算 rwork[j]，根据公式：-poles[j + (poles_dim1 << 1)] * z__[j] / diflj / (poles[j + (poles_dim1 << 1)] + dj)
            rwork[j] = -poles[j + (poles_dim1 << 1)] * z__[j] / diflj
                / (poles[j + (poles_dim1 << 1)] + dj);
        }
        // 对于 j 前的每个 i__，执行以下循环
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            // 如果 z__[i__] 或 poles[i__ + (poles_dim1 << 1)] 为零，将 rwork[i__] 设置为 0
            if (z__[i__] == 0.f || poles[i__ + (poles_dim1 << 1)] ==
                0.f) {
            rwork[i__] = 0.f;
            } else {
                // 否则，计算 rwork[i__]，根据公式：poles[i__ + (poles_dim1 << 1)] * z__[i__] / (slamc3_(&poles[i__ + (poles_dim1 << 1)], &dsigj) - diflj) / (poles[i__ + (poles_dim1 << 1)] + dj)
            rwork[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                 / (slamc3_(&poles[i__ + (poles_dim1 << 1)], &
                dsigj) - diflj) / (poles[i__ + (poles_dim1 <<
                1)] + dj);
            }
/* L30: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            if (z__[i__] == 0.f || poles[i__ + (poles_dim1 << 1)] ==
                0.f) {
            rwork[i__] = 0.f;
            } else {
            // 计算 rwork[i__]，根据给定的复数极点和相关参数
            rwork[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                 / (slamc3_(&poles[i__ + (poles_dim1 << 1)], &
                dsigjp) + difrj) / (poles[i__ + (poles_dim1 <<
                 1)] + dj);
            }
/* L40: */
        }
        // 初始化 rwork[1] 为 -1.0
        rwork[1] = -1.f;
        // 计算 rwork 数组的二范数
        temp = snrm2_(k, &rwork[1], &c__1);

/*
                Since B and BX are complex, the following call to SGEMV
                is performed in two steps (real and imaginary parts).

                CALL SGEMV( 'T', K, NRHS, ONE, BX, LDBX, WORK, 1, ZERO,
      $                     B( J, 1 ), LDB )
*/

        // 计算 rwork 数组的起始索引 i__
        i__ = *k + (*nrhs << 1);
        // 对每列进行循环
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            // 对每行进行循环
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
            // 增加索引 i__
            ++i__;
            // 从复数数组 bx 中提取实部到 rwork 数组
            i__4 = jrow + jcol * bx_dim1;
            rwork[i__] = bx[i__4].r;
/* L50: */
            }
/* L60: */
        }
        // 调用 SGEMV 计算矩阵乘积，将结果存储在 rwork 数组中
        sgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1], &c__1);
        // 重置索引 i__
        i__ = *k + (*nrhs << 1);
        // 对每列进行循环
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            // 对每行进行循环
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
            // 增加索引 i__
            ++i__;
            // 从复数数组 bx 中提取虚部到 rwork 数组
            rwork[i__] = r_imag(&bx[jrow + jcol * bx_dim1]);
/* L70: */
            }
/* L80: */
        }
        // 再次调用 SGEMV 计算矩阵乘积，将结果存储在 rwork 数组中
        sgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1 + *nrhs],
            &c__1);
        // 对每列进行循环
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            // 计算 b 矩阵中的复数值并存储
            i__3 = j + jcol * b_dim1;
            i__4 = jcol + *k;
            i__5 = jcol + *k + *nrhs;
            q__1.r = rwork[i__4], q__1.i = rwork[i__5];
            b[i__3].r = q__1.r, b[i__3].i = q__1.i;
/* L90: */
        }
        // 将矩阵 b 中的值按照指定的范围缩放
        clascl_("G", &c__0, &c__0, &temp, &c_b1034, &c__1, nrhs, &b[j
            + b_dim1], ldb, info);
/* L100: */
        }
    }

/*        Move the deflated rows of BX to B also. */

    // 如果 k < max(m,n)，则将 bx 中的 deflated 行移动到 b 中
    if (*k < max(m,n)) {
        // 使用 clacpy 函数复制部分数组
        i__1 = n - *k;
        clacpy_("A", &i__1, nrhs, &bx[*k + 1 + bx_dim1], ldbx, &b[*k + 1
            + b_dim1], ldb);
    }
    } else {

/*
          Apply back the right orthogonal transformations.

          Step (1R): apply back the new right singular vector matrix
          to B.
*/

    // 如果 k == 1，则执行以下操作
    if (*k == 1) {
        // 将 b 矩阵中的值复制到 bx 矩阵中
        ccopy_(nrhs, &b[b_offset], ldb, &bx[bx_offset], ldbx);
    } else {
        // 如果不是第一个情况，则执行以下循环
        i__1 = *k;
        // 设置循环的上限为 k 的值
        for (j = 1; j <= i__1; ++j) {
            // 迭代 j 从 1 到 i__1
            dsigj = poles[j + (poles_dim1 << 1)];
            // 从 poles 数组中获取 dsigj 的值
            if (z__[j] == 0.f) {
                // 如果 z__[j] 等于 0，则执行以下操作
                rwork[j] = 0.f;
                // 将 rwork[j] 置为 0
            } else {
                // 否则执行以下操作
                rwork[j] = -z__[j] / difl[j] / (dsigj + poles[j +
                    poles_dim1]) / difr[j + (difr_dim1 << 1)];
                // 计算并赋值给 rwork[j]
            }
            i__2 = j - 1;
            // 设置循环的上限为 j - 1
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 迭代 i__ 从 1 到 i__2
                if (z__[j] == 0.f) {
                    // 如果 z__[j] 等于 0，则执行以下操作
                    rwork[i__] = 0.f;
                    // 将 rwork[i__] 置为 0
                } else {
                    // 否则执行以下操作
                    r__1 = -poles[i__ + 1 + (poles_dim1 << 1)];
                    // 从 poles 数组中获取 r__1 的值
                    rwork[i__] = z__[j] / (slamc3_(&dsigj, &r__1) - difr[
                        i__ + difr_dim1]) / (dsigj + poles[i__ +
                        poles_dim1]) / difr[i__ + (difr_dim1 << 1)];
                    // 计算并赋值给 rwork[i__]
                }
/* L110: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            if (z__[j] == 0.f) {
                rwork[i__] = 0.f;
            } else {
                // 计算复数除法结果并存储在工作数组中
                r__1 = -poles[i__ + (poles_dim1 << 1)];
                rwork[i__] = z__[j] / (slamc3_(&dsigj, &r__1) - difl[
                    i__]) / (dsigj + poles[i__ + poles_dim1]) /
                    difr[i__ + (difr_dim1 << 1)];
            }
/* L120: */
        }

/*
                由于 B 和 BX 是复数，以下的 SGEMV 调用分为两步（实部和虚部）。

                CALL SGEMV( 'T', K, NRHS, ONE, B, LDB, WORK, 1, ZERO,
      $                     BX( J, 1 ), LDBX )
*/

        i__ = *k + (*nrhs << 1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
                ++i__;
                // 从复数矩阵 B 中提取实部并存储在工作数组中
                i__4 = jrow + jcol * b_dim1;
                rwork[i__] = b[i__4].r;
/* L130: */
            }
/* L140: */
        }
        // 调用 SGEMV 计算矩阵乘法
        sgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1], &c__1);
        i__ = *k + (*nrhs << 1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            i__3 = *k;
            for (jrow = 1; jrow <= i__3; ++jrow) {
                ++i__;
                // 从复数矩阵 B 中提取虚部并存储在工作数组中
                rwork[i__] = r_imag(&b[jrow + jcol * b_dim1]);
/* L150: */
            }
/* L160: */
        }
        // 调用 SGEMV 计算矩阵乘法
        sgemv_("T", k, nrhs, &c_b1034, &rwork[*k + 1 + (*nrhs << 1)],
            k, &rwork[1], &c__1, &c_b328, &rwork[*k + 1 + *nrhs],
            &c__1);
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
            // 将结果从工作数组复制回复数矩阵 BX
            i__3 = j + jcol * bx_dim1;
            i__4 = jcol + *k;
            i__5 = jcol + *k + *nrhs;
            q__1.r = rwork[i__4], q__1.i = rwork[i__5];
            bx[i__3].r = q__1.r, bx[i__3].i = q__1.i;
/* L170: */
        }
/* L180: */
        }
    }

/*
          Step (2R): if SQRE = 1, apply back the rotation that is
          related to the right null space of the subproblem.
*/

    if (*sqre == 1) {
        // 复制矩阵 B 的部分到矩阵 BX，并应用相关的旋转
        ccopy_(nrhs, &b[m + b_dim1], ldb, &bx[m + bx_dim1], ldbx);
        csrot_(nrhs, &bx[bx_dim1 + 1], ldbx, &bx[m + bx_dim1], ldbx, c__,
            s);
    }
    if (*k < max(m,n)) {
        // 复制矩阵 B 的部分到矩阵 BX
        i__1 = n - *k;
        clacpy_("A", &i__1, nrhs, &b[*k + 1 + b_dim1], ldb, &bx[*k + 1 +
            bx_dim1], ldbx);
    }

/*        Step (3R): permute rows of B. */

    // 复制并重新排列矩阵 BX 的行到矩阵 B
    ccopy_(nrhs, &bx[bx_dim1 + 1], ldbx, &b[nlp1 + b_dim1], ldb);
    if (*sqre == 1) {
        // 如果 SQRE = 1，则复制并重新排列矩阵 BX 的行到矩阵 B
        ccopy_(nrhs, &bx[m + bx_dim1], ldbx, &b[m + b_dim1], ldb);
    }
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        // 根据给定的排列，复制并重新排列矩阵 BX 的行到矩阵 B
        ccopy_(nrhs, &bx[i__ + bx_dim1], ldbx, &b[perm[i__] + b_dim1],
            ldb);
/* L190: */
    }

/*        Step (4R): apply back the Givens rotations performed. */
    // 循环遍历给定的指针数组 *givptr，从其最后一个元素开始向前遍历到第一个元素
    for (i__ = *givptr; i__ >= 1; --i__) {
        // 计算旋转角度的负值，并调用 csrot_ 函数进行列向量的 Givens 变换
        r__1 = -givnum[i__ + givnum_dim1];
        csrot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &r__1);
/* L200: */
    }
    }

    return 0;

/*     End of CLALS0 */

} /* clals0_ */

/* Subroutine */ int clalsa_(integer *icompq, integer *smlsiz, integer *n,
    integer *nrhs, singlecomplex *b, integer *ldb, singlecomplex *bx, integer *ldbx,
    real *u, integer *ldu, real *vt, integer *k, real *difl, real *difr,
    real *z__, real *poles, integer *givptr, integer *givcol, integer *
    ldgcol, integer *perm, real *givnum, real *c__, real *s, real *rwork,
    integer *iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
        difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
        z_dim1, z_offset, b_dim1, b_offset, bx_dim1, bx_offset, i__1,
        i__2, i__3, i__4, i__5, i__6;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, jcol, nlvl, sqre, jrow, jimag, jreal,
        inode, ndiml;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer ndimr;
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *), clals0_(integer *, integer *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, real *, real *, real *,
         integer *), xerbla_(char *, integer *), slasdt_(integer *
        , integer *, integer *, integer *, integer *, integer *, integer *
        );


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by CLALSA.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether the left or the right singular vector
           matrix is involved.
           = 0: Left singular vector matrix
           = 1: Right singular vector matrix

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.
*/

    /* Local variables */
    // 声明整数变量
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, jcol, nlvl, sqre, jrow, jimag, jreal,
        inode, ndiml;
    // 外部函数声明
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer ndimr;
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *), clals0_(integer *, integer *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, real *, real *, real *,
         integer *), xerbla_(char *, integer *), slasdt_(integer *
        , integer *, integer *, integer *, integer *, integer *, integer *
        );


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by CLALSA.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether the left or the right singular vector
           matrix is involved.
           = 0: Left singular vector matrix
           = 1: Right singular vector matrix

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.
*/

    /* System generated locals */
    // 系统生成的局部变量
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
        difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
        z_dim1, z_offset, b_dim1, b_offset, bx_dim1, bx_offset, i__1,
        i__2, i__3, i__4, i__5, i__6;
    singlecomplex q__1;

    /* Local variables */
    // 静态局部变量声明
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, jcol, nlvl, sqre, jrow, jimag, jreal,
        inode, ndiml;
    // 外部函数声明
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);
    static integer ndimr;
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *), clals0_(integer *, integer *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, integer *, integer *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, real *, real *, real *,
         integer *), xerbla_(char *, integer *), slasdt_(integer *
        , integer *, integer *, integer *, integer *, integer *, integer *
        );

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLALSA is an itermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    singular vectors are computed as products of simple orthorgonal
    matrices.).

    If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by CLALSA.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether the left or the right singular vector
           matrix is involved.
           = 0: Left singular vector matrix
           = 1: Right singular vector matrix

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.
*/

    /* Local variables */
    // 静态局部变量声明
    static integer i__, j, i1, ic, lf, nd, ll, nl,
    # N (输入) 整数
    #     上三角双对角矩阵的行列维度。

    # NRHS (输入) 整数
    #     B 和 BX 的列数。NRHS 必须至少为 1。

    # B (输入/输出) 复数数组，维度为 (LDB, NRHS)
    #     在输入时，B 包含最小二乘问题在第 1 至 M 行的右侧向量。
    #     在输出时，B 包含第 1 至 N 行的解 X。

    # LDB (输入) 整数
    #     B 在调用子程序中的领先维度。LDB 必须至少为 max(1, MAX(M, N))。

    # BX (输出) 复数数组，维度为 (LDBX, NRHS)
    #     在退出时，包含将左侧或右侧奇异向量矩阵应用于 B 后的结果。

    # LDBX (输入) 整数
    #     BX 的领先维度。

    # U (输入) 实数数组，维度为 (LDU, SMLSIZ)
    #     在输入时，U 包含底层所有子问题的左奇异向量矩阵。

    # LDU (输入) 整数，LDU >= N。
    #     数组 U、VT、DIFL、DIFR、POLES、GIVNUM 和 Z 的领先维度。

    # VT (输入) 实数数组，维度为 (LDU, SMLSIZ+1)
    #     在输入时，VT' 包含底层所有子问题的右奇异向量矩阵。

    # K (输入) 整数数组，维度为 (N)。

    # DIFL (输入) 实数数组，维度为 (LDU, NLVL)，其中 NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1。
    #     在输入时，DIFL(*, I) 和 DIFR(*, 2 * I -1) 记录第 I 级奇异值与第 (I -1) 级奇异值之间的距离，
    #     DIFR(*, 2 * I) 记录第 I 级子问题右奇异向量矩阵的归一化因子。

    # DIFR (输入) 实数数组，维度为 (LDU, 2 * NLVL)。
    #     在输入时，DIFL(*, I) 和 DIFR(*, 2 * I -1) 记录第 I 级奇异值与第 (I -1) 级奇异值之间的距离，
    #     DIFR(*, 2 * I) 记录第 I 级子问题右奇异向量矩阵的归一化因子。

    # Z (输入) 实数数组，维度为 (LDU, NLVL)。
    #     在输入时，Z(1, I) 包含第 I 级子问题的去除调整更新行向量的组成部分。

    # POLES (输入) 实数数组，维度为 (LDU, 2 * NLVL)。
    #     在输入时，POLES(*, 2 * I -1: 2 * I) 包含第 I 级中所涉及的新旧奇异值，
    #     在第 I 级上的世俗方程中。

    # GIVPTR (输入) 整数数组，维度为 (N)。
    #     在输入时，GIVPTR(I) 记录在计算树的第 I 个问题上执行的 Givens 旋转次数。

    # GIVCOL (输入) 整数数组，维度为 (LDGCOL, 2 * NLVL)。
    #     在输入时，对于每个 I，GIVCOL(*, 2 * I - 1: 2 * I) 记录在计算树的第 I 级上执行的 Givens 旋转的位置。

    # LDGCOL (输入) 整数，LDGCOL >= N。
    #     数组 GIVCOL 和 PERM 的领先维度。
    # PERM（输入）整数数组，维度为（LDGCOL，NLVL）。
    # 在输入时，PERM(*, I) 记录在计算树的第 I 级上执行的排列操作。

    # GIVNUM（输入）实数数组，维度为（LDU，2 * NLVL）。
    # 在输入时，GIVNUM(*, 2 * I - 1 : 2 * I) 记录在计算树的第 I 级上执行的 Givens 旋转的 C 和 S 值。

    # C（输入）实数数组，维度为（N）。
    # 在输入时，如果第 I 个子问题不是方形的，C(I) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 C 值。

    # S（输入）实数数组，维度为（N）。
    # 在输入时，如果第 I 个子问题不是方形的，S(I) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 S 值。

    # RWORK（工作空间）实数数组，至少维度为 MAX((SMLSZ+1)*NRHS*3, N*(1+NRHS) + 2*NRHS)。
    # 工作空间数组，用于存储算法执行期间的临时数据和结果。

    # IWORK（工作空间）整数数组。
    # 维度至少为 3 * N，用于存储算法执行期间的临时整数数据。

    # INFO（输出）整数。
    # = 0：成功退出。
    # < 0：如果 INFO = -i，则第 i 个参数具有非法值。

    # 进一步详细信息
    # ===============
    # 基于以下贡献：
    #    Ming Gu 和 Ren-Cang Li，加州大学伯克利分校，美国计算机科学部门
    #    Osni Marques，LBNL/NERSC，美国

    # =====================================================================

    # 测试输入参数的有效性。
    /* Parameter adjustments */
    // 设置数组 b 的维度和偏移量
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    // 设置数组 bx 的维度和偏移量
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    // 设置数组 givnum 的维度和偏移量
    givnum_dim1 = *ldu;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    // 设置数组 poles 的维度和偏移量
    poles_dim1 = *ldu;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    // 设置数组 z 的维度和偏移量
    z_dim1 = *ldu;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    // 设置数组 difr 的维度和偏移量
    difr_dim1 = *ldu;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    // 设置数组 difl 的维度和偏移量
    difl_dim1 = *ldu;
    difl_offset = 1 + difl_dim1;
    difl -= difl_offset;
    // 设置数组 vt 的维度和偏移量
    vt_dim1 = *ldu;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    // 设置数组 u 的维度和偏移量
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    // 调整指针和数组下标
    --k;
    --givptr;
    // 设置数组 perm 的维度和偏移量
    perm_dim1 = *ldgcol;
    perm_offset = 1 + perm_dim1;
    perm -= perm_offset;
    // 设置数组 givcol 的维度和偏移量
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    // 调整指针
    --c__;
    --s;
    --rwork;
    --iwork;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;

    // 检查输入参数的有效性
    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*smlsiz < 3) {
        *info = -2;
    } else if (*n < *smlsiz) {
        *info = -3;
    } else if (*nrhs < 1) {
        *info = -4;
    } else if (*ldb < *n) {
        *info = -6;
    } else if (*ldbx < *n) {
        *info = -8;
    } else if (*ldu < *n) {
        *info = -10;
    } else if (*ldgcol < *n) {
        *info = -19;
    }

    // 如果有错误信息，则调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CLALSA", &i__1);
        return 0;
    }

/*     Book-keeping and  setting up the computation tree. */

    // 初始化计算树的节点和维度
    inode = 1;
    ndiml = inode + *n;
    ndimr = ndiml + *n;

    // 调用 SLASDT 初始化计算树的结构
    slasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
            smlsiz);

/*
       The following code applies back the left singular vector factors.
       For applying back the right singular vector factors, go to 170.
*/

    // 根据 icompq 的值决定是否应用左奇异向量因子
    if (*icompq == 1) {
        goto L170;
    }

/*
       The nodes on the bottom level of the tree were solved
       by SLASDQ. The corresponding left and right singular vector
       matrices are in explicit form. First apply back the left
       singular vector matrices.
*/

    // 计算底层节点的索引和子问题的行数
    ndb1 = (nd + 1) / 2;
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
          IC : center row of each node
          NL : number of rows of left  subproblem
          NR : number of rows of right subproblem
          NLF: starting row of the left   subproblem
          NRF: starting row of the right  subproblem
*/

    i1 = i__ - 1;
    ic = iwork[inode + i1];
    nl = iwork[ndiml + i1];
    nr = iwork[ndimr + i1];
    nlf = ic - nl;
    nrf = ic + 1;

/*
          Since B and BX are complex, the following call to SGEMM
          is performed in two steps (real and imaginary parts).

          CALL SGEMM( 'T', 'N', NL, NRHS, NL, ONE, U( NLF, 1 ), LDU,
       $               B( NLF, 1 ), LDB, ZERO, BX( NLF, 1 ), LDBX )
*/

    // 计算数组大小和步长
    j = nl * *nrhs << 1;
    i__2 = *nrhs;
    # 循环遍历列 jcol，从 1 到 i__2
    for (jcol = 1; jcol <= i__2; ++jcol) {
        # 计算内部循环的结束条件，i__3 是 nlf 和 nl 的和减 1
        i__3 = nlf + nl - 1;
        # 循环遍历行 jrow，从 nlf 到 i__3
        for (jrow = nlf; jrow <= i__3; ++jrow) {
            # 每循环一次 j 自增 1
            ++j;
            # 计算数组 rwork 的索引，i__4 是 jrow + jcol * b_dim1
            i__4 = jrow + jcol * b_dim1;
            # 将数组 b 的实部值赋给 rwork 数组中的元素
            rwork[j] = b[i__4].r;
/* L10: */
        }
/* L20: */
    }
    sgemm_("T", "N", &nl, nrhs, &nl, &c_b1034, &u[nlf + u_dim1], ldu, &
        rwork[(nl * *nrhs << 1) + 1], &nl);
    j = nl * *nrhs << 1;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = nlf + nl - 1;
        for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L30: */
        }
/* L40: */
    }
    sgemm_("T", "N", &nl, nrhs, &nl, &c_b1034, &u[nlf + u_dim1], ldu, &
        rwork[(nl * *nrhs << 1) + 1], &nl);
    jreal = 0;
    jimag = nl * *nrhs;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = nlf + nl - 1;
        for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        q__1.r = rwork[i__5], q__1.i = rwork[i__6];
        bx[i__4].r = q__1.r, bx[i__4].i = q__1.i;
/* L50: */
        }
/* L60: */
    }

/*
          Since B and BX are complex, the following call to SGEMM
          is performed in two steps (real and imaginary parts).

          CALL SGEMM( 'T', 'N', NR, NRHS, NR, ONE, U( NRF, 1 ), LDU,
      $               B( NRF, 1 ), LDB, ZERO, BX( NRF, 1 ), LDBX )
*/

    j = nr * *nrhs << 1;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        rwork[j] = b[i__4].r;
/* L70: */
        }
/* L80: */
    }
    sgemm_("T", "N", &nr, nrhs, &nr, &c_b1034, &u[nrf + u_dim1], ldu, &
        rwork[(nr * *nrhs << 1) + 1], &nr);
    j = nr * *nrhs << 1;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L90: */
        }
/* L100: */
    }
    sgemm_("T", "N", &nr, nrhs, &nr, &c_b1034, &u[nrf + u_dim1], ldu, &
        rwork[(nr * *nrhs << 1) + 1], &nr);
    jreal = 0;
    jimag = nr * *nrhs;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = nrf + nr - 1;
        for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        q__1.r = rwork[i__5], q__1.i = rwork[i__6];
        bx[i__4].r = q__1.r, bx[i__4].i = q__1.i;
/* L110: */
        }
/* L120: */
    }

/* L130: */
    }

/*
       Next copy the rows of B that correspond to unchanged rows
       in the bidiagonal matrix to BX.
*/

    i__1 = nd;
    for (i__ = 1; i__ <= i__1; ++i__) {
    ic = iwork[inode + i__ - 1];
    ccopy_(nrhs, &b[ic + b_dim1], ldb, &bx[ic + bx_dim1], ldbx);
/* L140: */
    }
/*
       Finally go through the left singular vector matrices of all
       the other subproblems bottom-up on the tree.
*/
j = pow_ii(&c__2, &nlvl);
sqre = 0;

for (lvl = nlvl; lvl >= 1; --lvl) {
lvl2 = (lvl << 1) - 1;

/*
          find the first node LF and last node LL on
          the current level LVL
*/
if (lvl == 1) {
    lf = 1;
    ll = 1;
} else {
    i__1 = lvl - 1;
    lf = pow_ii(&c__2, &i__1);
    ll = (lf << 1) - 1;
}
i__1 = ll;
for (i__ = lf; i__ <= i__1; ++i__) {
    im1 = i__ - 1;
    ic = iwork[inode + im1];
    nl = iwork[ndiml + im1];
    nr = iwork[ndimr + im1];
    nlf = ic - nl;
    nrf = ic + 1;
    --j;
    clals0_(icompq, &nl, &nr, &sqre, nrhs, &bx[nlf + bx_dim1], ldbx, &
        b[nlf + b_dim1], ldb, &perm[nlf + lvl * perm_dim1], &
        givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
        givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
         poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
        lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
        j], &s[j], &rwork[1], info);
/* L150: */
}
/* L160: */
}
goto L330;

/*     ICOMPQ = 1: applying back the right singular vector factors. */

L170:

/*
       First now go through the right singular vector matrices of all
       the tree nodes top-down.
*/
j = 0;
i__1 = nlvl;
for (lvl = 1; lvl <= i__1; ++lvl) {
lvl2 = (lvl << 1) - 1;

/*
          Find the first node LF and last node LL on
          the current level LVL.
*/
if (lvl == 1) {
    lf = 1;
    ll = 1;
} else {
    i__2 = lvl - 1;
    lf = pow_ii(&c__2, &i__2);
    ll = (lf << 1) - 1;
}
i__2 = ll;
for (i__ = ll; i__ >= i__2; --i__) {
    im1 = i__ - 1;
    ic = iwork[inode + im1];
    nl = iwork[ndiml + im1];
    nr = iwork[ndimr + im1];
    nlf = ic - nl;
    nrf = ic + 1;
    if (i__ == ll) {
        sqre = 0;
    } else {
        sqre = 1;
    }
    ++j;
    clals0_(icompq, &nl, &nr, &sqre, nrhs, &b[nlf + b_dim1], ldb, &bx[
        nlf + bx_dim1], ldbx, &perm[nlf + lvl * perm_dim1], &
        givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
        givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
         poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
        lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
        j], &s[j], &rwork[1], info);
/* L180: */
}
/* L190: */
}

/*
       The nodes on the bottom level of the tree were solved
       by SLASDQ. The corresponding right singular vector
       matrices are in explicit form. Apply them back.
*/
ndb1 = (nd + 1) / 2;
i__1 = nd;
for (i__ = ndb1; i__ <= i__1; ++i__) {
i1 = i__ - 1;
ic = iwork[inode + i1];
nl = iwork[ndiml + i1];
nr = iwork[ndimr + i1];
nlp1 = nl + 1;
    # 如果 i__ 等于 nd，则将 nrp1 设为 nr
    if (i__ == nd) {
        nrp1 = nr;
    # 否则，将 nrp1 设为 nr + 1
    } else {
        nrp1 = nr + 1;
    }
    # 计算 nlf，即 ic 减去 nl 的结果
    nlf = ic - nl;
    # 计算 nrf，即 ic 加 1 的结果
    nrf = ic + 1;
/*
      Since B and BX are complex, the following call to SGEMM is
      performed in two steps (real and imaginary parts).

      CALL SGEMM( 'T', 'N', NLP1, NRHS, NLP1, ONE, VT( NLF, 1 ), LDU,
  $               B( NLF, 1 ), LDB, ZERO, BX( NLF, 1 ), LDBX )
*/

j = nlp1 * *nrhs << 1;
// 计算实际工作数组的索引起始位置
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nlf + nlp1 - 1;
    // 循环遍历列
    for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        // 将实部写入工作数组
        rwork[j] = b[i__4].r;
/* L200: */
    }
/* L210: */
}
// 调用 SGEMM 计算实部矩阵乘法
sgemm_("T", "N", &nlp1, nrhs, &nlp1, &c_b1034, &vt[nlf + vt_dim1],
    ldu, &rwork[(nlp1 * *nrhs << 1) + 1], &nlp1, &c_b328, &rwork[
    1], &nlp1);
j = nlp1 * *nrhs << 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nlf + nlp1 - 1;
    // 循环遍历列
    for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++j;
        // 将虚部写入工作数组
        rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L220: */
    }
/* L230: */
}
// 调用 SGEMM 计算虚部矩阵乘法
sgemm_("T", "N", &nlp1, nrhs, &nlp1, &c_b1034, &vt[nlf + vt_dim1],
    ldu, &rwork[(nlp1 * *nrhs << 1) + 1], &nlp1, &c_b328, &rwork[
    nlp1 * *nrhs + 1], &nlp1);
jreal = 0;
jimag = nlp1 * *nrhs;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nlf + nlp1 - 1;
    // 循环遍历列
    for (jrow = nlf; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * bx_dim1;
        i__5 = jreal;
        i__6 = jimag;
        // 将复数结果写入 BX 数组
        q__1.r = rwork[i__5], q__1.i = rwork[i__6];
        bx[i__4].r = q__1.r, bx[i__4].i = q__1.i;
/* L240: */
    }
/* L250: */
}

/*
      Since B and BX are complex, the following call to SGEMM is
      performed in two steps (real and imaginary parts).

      CALL SGEMM( 'T', 'N', NRP1, NRHS, NRP1, ONE, VT( NRF, 1 ), LDU,
  $               B( NRF, 1 ), LDB, ZERO, BX( NRF, 1 ), LDBX )
*/

j = nrp1 * *nrhs << 1;
// 计算实际工作数组的索引起始位置
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nrf + nrp1 - 1;
    // 循环遍历列
    for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        // 将实部写入工作数组
        rwork[j] = b[i__4].r;
/* L260: */
    }
/* L270: */
}
// 调用 SGEMM 计算实部矩阵乘法
sgemm_("T", "N", &nrp1, nrhs, &nrp1, &c_b1034, &vt[nrf + vt_dim1],
    ldu, &rwork[(nrp1 * *nrhs << 1) + 1], &nrp1, &c_b328, &rwork[
    1], &nrp1);
j = nrp1 * *nrhs << 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = nrf + nrp1 - 1;
    // 循环遍历列
    for (jrow = nrf; jrow <= i__3; ++jrow) {
        ++j;
        // 将虚部写入工作数组
        rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L280: */
    }
/* L290: */
}
// 调用 SGEMM 计算虚部矩阵乘法
sgemm_("T", "N", &nrp1, nrhs, &nrp1, &c_b1034, &vt[nrf + vt_dim1],
    ldu, &rwork[(nrp1 * *nrhs << 1) + 1], &nrp1, &c_b328, &rwork[
    nrp1 * *nrhs + 1], &nrp1);
jreal = 0;
jimag = nrp1 * *nrhs;
i__2 = *nrhs;
    // 循环遍历列 jcol 从 1 到 i__2
    for (jcol = 1; jcol <= i__2; ++jcol) {
        // 计算当前循环行数上限 i__3
        i__3 = nrf + nrp1 - 1;
        // 循环遍历行 jrow 从 nrf 到 i__3
        for (jrow = nrf; jrow <= i__3; ++jrow) {
            // 递增 jreal 和 jimag，用于访问 rwork 数组
            ++jreal;
            ++jimag;
            // 计算 bx 数组中的索引 i__4
            i__4 = jrow + jcol * bx_dim1;
            // 从 rwork 数组中取出 jreal 和 jimag 对应的实部和虚部
            i__5 = jreal;
            i__6 = jimag;
            q__1.r = rwork[i__5], q__1.i = rwork[i__6];
            // 将实部和虚部填充到 bx 数组的对应位置
            bx[i__4].r = q__1.r, bx[i__4].i = q__1.i;
/* L300: */
        }
/* L310: */
    }

/* L320: */
    }

/* L330: */
    return 0;

/*     End of CLALSA */

} /* clalsa_ */

/* Subroutine */ int clalsd_(char *uplo, integer *smlsiz, integer *n, integer
    *nrhs, real *d__, real *e, singlecomplex *b, integer *ldb, real *rcond,
    integer *rank, singlecomplex *work, real *rwork, integer *iwork, integer *
    info)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    real r__1;
    singlecomplex q__1;

    /* Local variables */
    static integer c__, i__, j, k;  // 声明局部变量
    static real r__;  // 声明实数类型变量
    static integer s, u, z__;  // 声明整数类型变量
    static real cs;  // 声明实数类型变量
    static integer bx;  // 声明整数类型变量
    static real sn;  // 声明实数类型变量
    static integer st, vt, nm1, st1;  // 声明整数类型变量
    static real eps;  // 声明实数类型变量
    static integer iwk;  // 声明整数类型变量
    static real tol;  // 声明实数类型变量
    static integer difl, difr;  // 声明整数类型变量
    static real rcnd;  // 声明实数类型变量
    static integer jcol, irwb, perm, nsub, nlvl, sqre, bxst, jrow, irwu,
        jimag, jreal;  // 声明整数类型变量
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);  // 引用外部的 sgemm_ 子程序
    static integer irwib;  // 声明整数类型变量
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);  // 引用外部的 ccopy_ 子程序
    static integer poles, sizei, irwrb, nsize;  // 声明整数类型变量
    extern /* Subroutine */ int csrot_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *, real *, real *);  // 引用外部的 csrot_ 子程序
    static integer irwvt, icmpq1, icmpq2;  // 声明整数类型变量
    extern /* Subroutine */ int clalsa_(integer *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, real *,
        integer *, real *, integer *, real *, real *, real *, real *,
        integer *, integer *, integer *, integer *, real *, real *, real *
        , real *, integer *, integer *);  // 引用外部的 clalsa_ 子程序
    extern /* Subroutine */ int clascl_(char *, integer *,
        integer *, real *, real *, integer *, integer *, singlecomplex *,
        integer *, integer *);  // 引用外部的 clascl_ 子程序
    extern doublereal slamch_(char *);  // 引用外部的 slamch_ 函数
    extern /* Subroutine */ int slasda_(integer *, integer *, integer *,
        integer *, real *, real *, real *, integer *, real *, integer *,
        real *, real *, real *, real *, integer *, integer *, integer *,
        integer *, real *, real *, real *, real *, integer *, integer *);  // 引用外部的 slasda_ 子程序
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);  // 引用外部的 clacpy_ 子程序
    extern /* Subroutine */ int claset_(char *, integer *, integer
        *, singlecomplex *, singlecomplex *, singlecomplex *, integer *);  // 引用外部的 claset_ 子程序
    extern /* Subroutine */ int xerbla_(
        char *, integer *);  // 引用外部的 xerbla_ 子程序
    extern /* Subroutine */ int slascl_(char *, integer *, integer *,
        real *, real *, integer *, integer *, real *, integer *, integer *
        );  // 引用外部的 slascl_ 子程序
    extern integer isamax_(integer *, real *, integer *);  // 引用外部的 isamax_ 函数
    ! 外部声明两个子程序 slasdq 和 slaset，以及一个函数 slartg
    extern /* Subroutine */ int slasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, real *, real *, real *, integer *, real *
        , integer *, real *, integer *, real *, integer *),
        slaset_(char *, integer *, integer *, real *, real *, real *,
        integer *), slartg_(real *, real *, real *, real *, real *
        );
    ! 声明静态变量 orgnrm 用于存储原始范数
    static real orgnrm;
    ! 声明静态变量 givnum，用于存储某个数值
    static integer givnum;
    ! 外部函数声明 slanst 用于计算某种范数
    extern doublereal slanst_(char *, integer *, real *, real *);
    ! 外部子程序声明 slasrt，用于对数组进行排序
    extern /* Subroutine */ int slasrt_(char *, integer *, real *, integer *);
    ! 声明静态整型变量 givptr, nrwork, irwwrk, smlszp 用于存储特定值
    static integer givptr, nrwork, irwwrk, smlszp;
"""
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    CLALSD uses the singular value decomposition of A to solve the least
    squares problem of finding X to minimize the Euclidean norm of each
    column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
    are N-by-NRHS. The solution X overwrites B.

    The singular values of A smaller than RCOND times the largest
    singular value are treated as zero in solving the least squares
    problem; in this case a minimum norm solution is returned.
    The actual singular values are returned in D in ascending order.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    UPLO   (input) CHARACTER*1
           = 'U': D and E define an upper bidiagonal matrix.
           = 'L': D and E define a  lower bidiagonal matrix.

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The dimension of the  bidiagonal matrix.  N >= 0.

    NRHS   (input) INTEGER
           The number of columns of B. NRHS must be at least 1.

    D      (input/output) REAL array, dimension (N)
           On entry D contains the main diagonal of the bidiagonal
           matrix. On exit, if INFO = 0, D contains its singular values.

    E      (input/output) REAL array, dimension (N-1)
           Contains the super-diagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    B      (input/output) COMPLEX array, dimension (LDB,NRHS)
           On input, B contains the right hand sides of the least
           squares problem. On output, B contains the solution X.

    LDB    (input) INTEGER
           The leading dimension of B in the calling subprogram.
           LDB must be at least max(1,N).

    RCOND  (input) REAL
           The singular values of A less than or equal to RCOND times
           the largest singular value are treated as zero in solving
           the least squares problem. If RCOND is negative,
           machine precision is used instead.
           For example, if diag(S)*X=B were the least squares problem,
           where diag(S) is a diagonal matrix of singular values, the
           solution would be X(i) = B(i) / S(i) if S(i) is greater than
           RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
           RCOND*max(S).
"""
    RANK   (output) INTEGER
           The number of singular values of A greater than RCOND times
           the largest singular value.

    WORK   (workspace) COMPLEX array, dimension (N * NRHS).
           Complex workspace array used during computation.

    RWORK  (workspace) REAL array, dimension at least
           (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
           MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS ),
           where
           NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
           Real workspace array used during computation, sized based on problem dimensions.

    IWORK  (workspace) INTEGER array, dimension (3*N*NLVL + 11*N).
           Integer workspace array used during computation, sized based on problem dimensions.

    INFO   (output) INTEGER
           = 0:  successful exit.
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  The algorithm failed to compute a singular value while
                 working on the submatrix lying in rows and columns
                 INFO/(N+1) through MOD(INFO,N+1).
           Output parameter indicating success or failure of the algorithm.

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA
           Additional information about the contributors to the algorithm.

    =====================================================================


       Test the input parameters.
           Start of the subroutine to validate the input parameters.
    /* Parameter adjustments */
    --d__;          // 调整指针以访问数组d中的元素
    --e;            // 调整指针以访问数组e中的元素
    b_dim1 = *ldb;  // 设置b的第一维度大小为ldb
    b_offset = 1 + b_dim1;  // 计算b的偏移量
    b -= b_offset;  // 调整指针以访问数组b中的元素
    --work;         // 调整指针以访问数组work中的元素
    --rwork;        // 调整指针以访问数组rwork中的元素
    --iwork;        // 调整指针以访问数组iwork中的元素

    /* Function Body */
    *info = 0;      // 将info所指向的内存位置设置为0，用于存储错误信息代码

    if (*n < 0) {   // 检查n是否小于0
    *info = -3;     // 如果是，将info设置为-3，表示n的值不合法
    } else if (*nrhs < 1) {  // 检查nrhs是否小于1
    *info = -4;     // 如果是，将info设置为-4，表示nrhs的值不合法
    } else if (*ldb < 1 || *ldb < *n) {  // 检查ldb是否小于1或小于n
    *info = -8;     // 如果是，将info设置为-8，表示ldb的值不合法
    }
    if (*info != 0) {   // 如果info不为0，表示有错误信息
    i__1 = -(*info);    // 将错误信息的绝对值取负，作为xerbla函数的参数
    xerbla_("CLALSD", &i__1);  // 调用错误处理函数xerbla，打印错误信息
    return 0;           // 返回0，表示发生了错误
    }

    eps = slamch_("Epsilon");   // 获取机器精度并存储在eps中

/*     Set up the tolerance. */

    if (*rcond <= 0.f || *rcond >= 1.f) {  // 检查rcond是否小于等于0或大于等于1
    rcnd = eps;         // 如果是，则将rcnd设置为eps
    } else {
    rcnd = *rcond;       // 否则将rcnd设置为rcond所指向的值
    }

    *rank = 0;           // 将rank所指向的内存位置设置为0，用于存储矩阵的秩

/*     Quick return if possible. */

    if (*n == 0) {       // 如果n为0
    return 0;            // 直接返回0，表示没有需要处理的情况
    } else if (*n == 1) {  // 如果n为1
    if (d__[1] == 0.f) {  // 检查数组d中的第一个元素是否为0
        claset_("A", &c__1, nrhs, &c_b56, &c_b56, &b[b_offset], ldb);  // 如果是，使用claset初始化矩阵b
    } else {
        *rank = 1;       // 否则将rank设置为1
        clascl_("G", &c__0, &c__0, &d__[1], &c_b1034, &c__1, nrhs, &b[
            b_offset], ldb, info);  // 调用clascl函数，对矩阵b进行缩放
        d__[1] = dabs(d__[1]);  // 计算数组d中第一个元素的绝对值
    }
    return 0;            // 返回0，表示处理完成
    }

/*     Rotate the matrix if it is lower bidiagonal. */

    if (*(unsigned char *)uplo == 'L') {  // 检查uplo指向的字符是否为'L'
    i__1 = *n - 1;        // 设置循环的上界为n-1
    for (i__ = 1; i__ <= i__1; ++i__) {  // 循环遍历矩阵的每一行
        slartg_(&d__[i__], &e[i__], &cs, &sn, &r__);  // 调用slartg函数，计算旋转角度
        d__[i__] = r__;   // 更新数组d中的元素
        e[i__] = sn * d__[i__ + 1];  // 更新数组e中的元素
        d__[i__ + 1] = cs * d__[i__ + 1];  // 更新数组d中的元素
        if (*nrhs == 1) {
        csrot_(&c__1, &b[i__ + b_dim1], &c__1, &b[i__ + 1 + b_dim1], &
            c__1, &cs, &sn);  // 调用csrot函数，对矩阵b进行旋转
        } else {
        rwork[(i__ << 1) - 1] = cs;  // 更新数组rwork中的元素
        rwork[i__ * 2] = sn;         // 更新数组rwork中的元素
        }
/* L10: */
    }
    if (*nrhs > 1) {       // 如果nrhs大于1
        i__1 = *nrhs;      // 设置循环的上界为nrhs
        for (i__ = 1; i__ <= i__1; ++i__) {  // 循环遍历每一个右手边
        i__2 = *n - 1;    // 设置循环的上界为n-1
        for (j = 1; j <= i__2; ++j) {  // 循环遍历矩阵的每一行
            cs = rwork[(j << 1) - 1];   // 获取旋转角度
            sn = rwork[j * 2];          // 获取旋转角度
            csrot_(&c__1, &b[j + i__ * b_dim1], &c__1, &b[j + 1 + i__
                * b_dim1], &c__1, &cs, &sn);  // 调用csrot函数，对矩阵b进行旋转
/* L20: */
        }
/* L30: */
        }
    }

/*     Scale. */

    nm1 = *n - 1;         // 设置nm1为n-1
    orgnrm = slanst_("M", n, &d__[1], &e[1]);  // 计算范数并存储在orgnrm中
    if (orgnrm == 0.f) {  // 检查范数是否为0
    claset_("A", n, nrhs, &c_b56, &c_b56, &b[b_offset], ldb);  // 如果是，使用claset初始化矩阵b
    return 0;             // 返回0，表示处理完成
    }

    slascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, n, &c__1, &d__[1], n, info);  // 调用slascl函数，对数组d进行缩放
    slascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &nm1, &c__1, &e[1], &nm1,
        info);             // 调用slascl函数，对数组e进行缩放

/*
       If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver.
*/

    if (*n <= *smlsiz) {  // 检查n是否小于或等于smlsiz所指向的值
    irwu = 1;            // 设置irwu的值
    irwvt = irwu + *n * *n;  // 计算irwvt的值
    irwwrk = irwvt + *n * *n;  // 计算irwwrk的值
    irwrb = irwwrk;      // 设置irwrb的值
    irwib = irwrb + *n * *nrhs;  // 计算irwib的值
    irwb = irwib + *n
/*
          In the real version, B is passed to SLASDQ and multiplied
          internally by Q'. Here B is complex and that product is
          computed below in two steps (real and imaginary parts).
*/

    j = irwb - 1;
    // Initialize index `j` for accessing `rwork` array
    i__1 = *nrhs;
    // Loop over each right-hand side
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++j;
            // Compute index in `rwork` array
            i__3 = jrow + jcol * b_dim1;
            // Store real part of B(jrow, jcol) in rwork[j]
            rwork[j] = b[i__3].r;
/* L40: */  // End of inner loop
        }
/* L50: */  // End of outer loop
    }
    // Perform matrix multiplication: rwork = Q' * rwork
    sgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwu], n, &rwork[irwb],
        n, &c_b328, &rwork[irwrb], n);

    j = irwb - 1;
    // Reset index `j` for accessing `rwork` array
    i__1 = *nrhs;
    // Loop over each right-hand side
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++j;
            // Store imaginary part of B(jrow, jcol) in rwork[j]
            rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L60: */  // End of inner loop
        }
/* L70: */  // End of outer loop
    }
    // Perform matrix multiplication: rwork = Q' * rwork
    sgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwu], n, &rwork[irwb],
        n, &c_b328, &rwork[irwib], n);

    // Initialize indices for accessing real and imaginary parts
    jreal = irwrb - 1;
    jimag = irwib - 1;
    // Loop over each right-hand side
    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++jreal;
            ++jimag;
            // Compute index in B matrix
            i__3 = jrow + jcol * b_dim1;
            i__4 = jreal;
            i__5 = jimag;
            // Update B(jrow, jcol) with complex product from rwork
            q__1.r = rwork[i__4], q__1.i = rwork[i__5];
            b[i__3].r = q__1.r, b[i__3].i = q__1.i;
/* L80: */  // End of inner loop
        }
/* L90: */  // End of outer loop
    }

    // Compute tolerance for the singular values
    tol = rcnd * (r__1 = d__[isamax_(n, &d__[1], &c__1)], dabs(r__1));
    // Loop over each singular value
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        // Check if the singular value is small
        if (d__[i__] <= tol) {
            // Set elements of B(:, j) to zero
            claset_("A", &c__1, nrhs, &c_b56, &c_b56, &b[i__ + b_dim1],
                ldb);
        } else {
            // Scale the j-th column of B by 1/d[i__]
            clascl_("G", &c__0, &c__0, &d__[i__], &c_b1034, &c__1, nrhs, &
                b[i__ + b_dim1], ldb, info);
            // Increment the rank count
            ++(*rank);
        }
/* L100: */  // End of loop over singular values
    }

/*
          Since B is complex, the following call to SGEMM is performed
          in two steps (real and imaginary parts). That is for V * B
          (in the real version of the code V' is stored in WORK).

          CALL SGEMM( 'T', 'N', N, NRHS, N, ONE, WORK, N, B, LDB, ZERO,
      $               WORK( NWORK ), N )
*/

    j = irwb - 1;
    // Initialize index `j` for accessing `rwork` array
    i__1 = *nrhs;
    // Loop over each right-hand side
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++j;
            // Compute index in `rwork` array
            i__3 = jrow + jcol * b_dim1;
            // Store real part of B(jrow, jcol) in rwork[j]
            rwork[j] = b[i__3].r;
/* L110: */  // End of inner loop
        }
/* L120: */  // End of outer loop
    }
    // Perform matrix multiplication: rwork = V' * rwork
    sgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwvt], n, &rwork[irwb],
         n, &c_b328, &rwork[irwrb], n);

    j = irwb - 1;
    // Reset index `j` for accessing `rwork` array
    i__1 = *nrhs;
    // Loop over each right-hand side
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++j;
            // Store imaginary part of B(jrow, jcol) in rwork[j]
            rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
/* L130: */  // End of inner loop
        }
/* L140: */  // End of outer loop
    }
    // Perform matrix multiplication: rwork = V' * rwork
    sgemm_("T", "N", n, nrhs, n, &c_b1034, &rwork[irwvt], n, &rwork[irwb],
         n, &c_b328, &rwork[irwib], n);

    // Initialize indices for accessing real and imaginary parts
    jreal = irwrb - 1;
    jimag = irwib - 1;
    // Loop over each right-hand side
    i__1 = *nrhs;
    for (jcol = 1; jcol <= i__1; ++jcol) {
        i__2 = *n;
        // Loop over each row of the matrix B
        for (jrow = 1; jrow <= i__2; ++jrow) {
            ++jreal;
            ++jimag;
            // Compute index in B matrix
            i__3 = jrow + jcol * b_dim1;
            i__4 = jreal;
            i__5 = jimag;
            // Update B(jrow, jcol) with complex product from rwork
            q__1.r = rwork[i__4], q__1.i = rwork[i__5];
            b[i__3].r = q__1.r, b[i__3].i = q__1.i;
/* L150: */  // End of inner loop
        }
/* L160: */  // End of outer loop
    }
    // 循环遍历列 jcol，从 1 到 i__1
    for (jcol = 1; jcol <= i__1; ++jcol) {
        // 循环遍历行 jrow，从 1 到 *n
        i__2 = *n;
        for (jrow = 1; jrow <= i__2; ++jrow) {
            // 增加 jreal 和 jimag 的值
            ++jreal;
            ++jimag;
            // 计算 b 数组中元素的索引，行列位置为 jrow 和 jcol
            i__3 = jrow + jcol * b_dim1;
            // 使用 jreal 和 jimag 索引 rwork 数组，构建复数结构 q__1
            i__4 = jreal;
            i__5 = jimag;
            q__1.r = rwork[i__4], q__1.i = rwork[i__5];
            // 将复数结构 q__1 的实部和虚部赋值给 b 数组中的复数元素
            b[i__3].r = q__1.r, b[i__3].i = q__1.i;
    }

/* L160: */
    }

/*        Unscale. */

    // 对角线元素缩放
    slascl_("G", &c__0, &c__0, &c_b1034, &orgnrm, n, &c__1, &d__[1], n,
        info);
    // 对特征值排序
    slasrt_("D", n, &d__[1], info);
    // 对右侧矩阵 b 进行缩放
    clascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, n, nrhs, &b[b_offset],
        ldb, info);

    // 返回执行成功
    return 0;
    }

/*     Book-keeping and setting up some constants. */

    // 计算分层次数
    nlvl = (integer) (log((real) (*n) / (real) (*smlsiz + 1)) / log(2.f)) + 1;

    smlszp = *smlsiz + 1;

    u = 1;
    vt = *smlsiz * *n + 1;
    difl = vt + smlszp * *n;
    difr = difl + nlvl * *n;
    z__ = difr + (nlvl * *n << 1);
    c__ = z__ + nlvl * *n;
    s = c__ + *n;
    poles = s + *n;
    givnum = poles + (nlvl << 1) * *n;
    nrwork = givnum + (nlvl << 1) * *n;
    bx = 1;

    irwrb = nrwork;
    irwib = irwrb + *smlsiz * *nrhs;
    irwb = irwib + *smlsiz * *nrhs;

    sizei = *n + 1;
    k = sizei + *n;
    givptr = k + *n;
    perm = givptr + *n;
    givcol = perm + nlvl * *n;
    iwk = givcol + (nlvl * *n << 1);

    st = 1;
    sqre = 0;
    icmpq1 = 1;
    icmpq2 = 0;
    nsub = 0;

    // 循环遍历矩阵的特征值
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 如果特征值绝对值小于阈值 eps，则对其进行修正
    if ((r__1 = d__[i__], dabs(r__1)) < eps) {
        d__[i__] = r_sign(&eps, &d__[i__]);
    }
/* L170: */
    }

    // 循环遍历矩阵的次对角线元素
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 如果次对角线元素的绝对值小于阈值 eps 或者是最后一个元素，则处理子问题
    if ((r__1 = e[i__], dabs(r__1)) < eps || i__ == nm1) {
        ++nsub;
        iwork[nsub] = st;

/*
             Subproblem found. First determine its size and then
             apply divide and conquer on it.
*/

        if (i__ < nm1) {

/*              A subproblem with E(I) small for I < NM1. */

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else if ((r__1 = e[i__], dabs(r__1)) >= eps) {

/*              A subproblem with E(NM1) not too small but I = NM1. */

        nsize = *n - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else {

/*
                A subproblem with E(NM1) small. This implies an
                1-by-1 subproblem at D(N), which is not solved
                explicitly.
*/

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        ++nsub;
        iwork[nsub] = *n;
        iwork[sizei + nsub - 1] = 1;
        // 将右侧向量 b 的一部分复制到工作区
        ccopy_(nrhs, &b[*n + b_dim1], ldb, &work[bx + nm1], n);
        }
        st1 = st - 1;
        if (nsize == 1) {

/*
                This is a 1-by-1 subproblem and is not solved
                explicitly.
*/

        // 将右侧向量 b 的一部分复制到工作区
        ccopy_(nrhs, &b[st + b_dim1], ldb, &work[bx + st1], n);
        } else if (nsize <= *smlsiz) {
/*
    这是一个小的子问题，由 SLASDQ 解决。
*/

slaset_("A", &nsize, &nsize, &c_b328, &c_b1034, &rwork[vt + st1], n);
/*
    设置矩阵 vt 的大小为 nsize x nsize，初始化为常数 c_b328 和 c_b1034。
*/

slaset_("A", &nsize, &nsize, &c_b328, &c_b1034, &rwork[u + st1], n);
/*
    设置矩阵 u 的大小为 nsize x nsize，初始化为常数 c_b328 和 c_b1034。
*/

slasdq_("U", &c__0, &nsize, &nsize, &nsize, &c__0, &d__[st], &e[st], &rwork[vt + st1], n, &rwork[u + st1], n, &rwork[nrwork], &c__1, &rwork[nrwork], info);
/*
    调用 SLASDQ 函数进行奇异值分解计算，其中 U 是上三角部分的标志，d 和 e 是对角线元素和下对角线元素数组。
*/

if (*info != 0) {
    return 0;
}
/*
    检查 SLASDQ 的返回信息，如果非零则出错，返回 0。
*/

/*
    在实际版本中，B 作为参数传递给 SLASDQ 并在内部与 Q' 相乘。
    这里 B 是复数，下面计算该乘积的两个步骤（实部和虚部）。
*/

j = irwb - 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = st + nsize - 1;
    for (jrow = st; jrow <= i__3; ++jrow) {
        ++j;
        i__4 = jrow + jcol * b_dim1;
        rwork[j] = b[i__4].r;
    }
}
/*
    从复数矩阵 B 中提取实部，存储在 rwork 数组中。
*/

sgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[u + st1], n, &rwork[irwb], &nsize, &c_b328, &rwork[irwrb], &nsize);
/*
    使用 BLAS 中的 sgemm 函数计算实部矩阵乘积。
*/

j = irwb - 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = st + nsize - 1;
    for (jrow = st; jrow <= i__3; ++jrow) {
        ++j;
        rwork[j] = r_imag(&b[jrow + jcol * b_dim1]);
    }
}
/*
    从复数矩阵 B 中提取虚部，存储在 rwork 数组中。
*/

sgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[u + st1], n, &rwork[irwb], &nsize, &c_b328, &rwork[irwib], &nsize);
/*
    使用 BLAS 中的 sgemm 函数计算虚部矩阵乘积。
*/

jreal = irwrb - 1;
jimag = irwib - 1;
i__2 = *nrhs;
for (jcol = 1; jcol <= i__2; ++jcol) {
    i__3 = st + nsize - 1;
    for (jrow = st; jrow <= i__3; ++jrow) {
        ++jreal;
        ++jimag;
        i__4 = jrow + jcol * b_dim1;
        i__5 = jreal;
        i__6 = jimag;
        q__1.r = rwork[i__5], q__1.i = rwork[i__6];
        b[i__4].r = q__1.r, b[i__4].i = q__1.i;
    }
}
/*
    将计算得到的实部和虚部重新组合成复数形式存储回矩阵 B。
*/

clacpy_("A", &nsize, nrhs, &b[st + b_dim1], ldb, &work[bx + st1], n);
/*
    复制部分 B 的结果到工作区数组 work 中，以备后续使用。
*/
/*
    A large problem. Solve it using divide and conquer.
*/

/* Solve a subproblem using SLASDA */
slasda_(&icmpq1, smlsiz, &nsize, &sqre, &d__[st], &e[st], &
    rwork[u + st1], n, &rwork[vt + st1], &iwork[k + st1],
    &rwork[difl + st1], &rwork[difr + st1], &rwork[z__ +
    st1], &rwork[poles + st1], &iwork[givptr + st1], &
    iwork[givcol + st1], n, &iwork[perm + st1], &rwork[
    givnum + st1], &rwork[c__ + st1], &rwork[s + st1], &
    rwork[nrwork], &iwork[iwk], info);
if (*info != 0) {
    return 0;  /* Return if an error occurred */
}

/* Update variables for the next subproblem */
bxst = bx + st1;

/* Solve another subproblem using CLALSA */
clalsa_(&icmpq2, smlsiz, &nsize, nrhs, &b[st + b_dim1], ldb, &
    work[bxst], n, &rwork[u + st1], n, &rwork[vt + st1], &
    iwork[k + st1], &rwork[difl + st1], &rwork[difr + st1]
    , &rwork[z__ + st1], &rwork[poles + st1], &iwork[
    givptr + st1], &iwork[givcol + st1], n, &iwork[perm +
    st1], &rwork[givnum + st1], &rwork[c__ + st1], &rwork[
    s + st1], &rwork[nrwork], &iwork[iwk], info);
if (*info != 0) {
    return 0;  /* Return if an error occurred */
}

/* Iterate over all subproblems */
st = i__ + 1;
/* L240: */
}

/* Apply the singular values and treat the tiny ones as zero. */

tol = rcnd * (r__1 = d__[isamax_(n, &d__[1], &c__1)], dabs(r__1));

/* Iterate over all elements in vector D */
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {

/*
      Some of the elements in D can be negative because 1-by-1
      subproblems were not solved explicitly.
*/

if ((r__1 = d__[i__], dabs(r__1)) <= tol) {
    claset_("A", &c__1, nrhs, &c_b56, &c_b56, &work[bx + i__ - 1], n);
} else {
    ++(*rank);  /* Increment rank */
    clascl_("G", &c__0, &c__0, &d__[i__], &c_b1034, &c__1, nrhs, &
        work[bx + i__ - 1], n, info);
}
d__[i__] = (r__1 = d__[i__], dabs(r__1));
/* L250: */
}

/* Now apply back the right singular vectors. */

icmpq2 = 1;
/* Iterate over all subproblems */
i__1 = nsub;
for (i__ = 1; i__ <= i__1; ++i__) {
st = iwork[i__];
st1 = st - 1;
nsize = iwork[sizei + i__ - 1];
bxst = bx + st1;
if (nsize == 1) {
    ccopy_(nrhs, &work[bxst], n, &b[st + b_dim1], ldb);
} else if (nsize <= *smlsiz) {

/*
         Since B and BX are complex, the following call to SGEMM
         is performed in two steps (real and imaginary parts).

         CALL SGEMM( 'T', 'N', NSIZE, NRHS, NSIZE, ONE,
  $                  RWORK( VT+ST1 ), N, RWORK( BXST ), N, ZERO,
  $                  B( ST, 1 ), LDB )
*/

    j = bxst - *n - 1;
    jreal = irwb - 1;
    i__2 = *nrhs;
    for (jcol = 1; jcol <= i__2; ++jcol) {
    j += *n;
    i__3 = nsize;
    for (jrow = 1; jrow <= i__3; ++jrow) {
        ++jreal;
        i__4 = j + jrow;
        rwork[jreal] = work[i__4].r;
/* L260: */
    }
/*
   L270: */
        }
        sgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[vt + st1],
             n, &rwork[irwb], &nsize, &c_b328, &rwork[irwrb], &nsize);
        j = bxst - *n - 1;
        jimag = irwb - 1;
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
        j += *n;
        i__3 = nsize;
        for (jrow = 1; jrow <= i__3; ++jrow) {
            ++jimag;
            rwork[jimag] = r_imag(&work[j + jrow]);
/* L280: */
        }
/* L290: */
        }
        sgemm_("T", "N", &nsize, nrhs, &nsize, &c_b1034, &rwork[vt + st1],
             n, &rwork[irwb], &nsize, &c_b328, &rwork[irwib], &nsize);
        jreal = irwrb - 1;
        jimag = irwib - 1;
        i__2 = *nrhs;
        for (jcol = 1; jcol <= i__2; ++jcol) {
        i__3 = st + nsize - 1;
        for (jrow = st; jrow <= i__3; ++jrow) {
            ++jreal;
            ++jimag;
            i__4 = jrow + jcol * b_dim1;
            i__5 = jreal;
            i__6 = jimag;
            q__1.r = rwork[i__5], q__1.i = rwork[i__6];
            b[i__4].r = q__1.r, b[i__4].i = q__1.i;
/* L300: */
        }
/* L310: */
        }
    } else {
        clalsa_(&icmpq2, smlsiz, &nsize, nrhs, &work[bxst], n, &b[st +
            b_dim1], ldb, &rwork[u + st1], n, &rwork[vt + st1], &
            iwork[k + st1], &rwork[difl + st1], &rwork[difr + st1], &
            rwork[z__ + st1], &rwork[poles + st1], &iwork[givptr +
            st1], &iwork[givcol + st1], n, &iwork[perm + st1], &rwork[
            givnum + st1], &rwork[c__ + st1], &rwork[s + st1], &rwork[
            nrwork], &iwork[iwk], info);
        if (*info != 0) {
        return 0;
        }
    }
/* L320: */
    }

/*     Unscale and sort the singular values. */

    slascl_("G", &c__0, &c__0, &c_b1034, &orgnrm, n, &c__1, &d__[1], n, info);
    slasrt_("D", n, &d__[1], info);
    clascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, n, nrhs, &b[b_offset], ldb,
        info);

    return 0;

/*     End of CLALSD */

} /* clalsd_ */

doublereal clange_(char *norm, integer *m, integer *n, singlecomplex *a, integer *
    lda, real *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    real ret_val, r__1, r__2;

    /* Local variables */
    static integer i__, j;
    static real sum, scale;
    extern logical lsame_(char *, char *);
    static real value;
    extern /* Subroutine */ int classq_(integer *, singlecomplex *, integer *, real
        *, real *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLANGE  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    singlecomplex matrix A.

    Description
    ===========

*/
    ! CLANGE 返回的值
    ! CLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
    !          (
    !          ( norm1(A),         NORM = '1', 'O' or 'o'
    !          (
    !          ( normI(A),         NORM = 'I' or 'i'
    !          (
    !          ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    ! norm1 表示矩阵的一范数（最大列和）
    ! normI 表示矩阵的无穷范数（最大行和）
    ! normF 表示矩阵的Frobenius范数（平方和的平方根）
    ! 注意 max(abs(A(i,j))) 不是一个一致的矩阵范数。

    ! 参数
    ! =====

    ! NORM    (input) CHARACTER*1
    !         指定返回到 CLANGE 中的值，如上所述。

    ! M       (input) INTEGER
    !         矩阵 A 的行数。M >= 0。当 M = 0 时，CLANGE 被设为零。

    ! N       (input) INTEGER
    !         矩阵 A 的列数。N >= 0。当 N = 0 时，CLANGE 被设为零。

    ! A       (input) COMPLEX array, dimension (LDA,N)
    !         m × n 的矩阵 A。

    ! LDA     (input) INTEGER
    !         数组 A 的领先维度。LDA >= max(M,1)。

    ! WORK    (workspace) REAL array, dimension (MAX(1,LWORK))
    !         当 NORM = 'I' 时，要求 LWORK >= M；否则，WORK 不被引用。
   ```py
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--work;

参数调整部分：调整矩阵 A 和工作数组的参数。


/* Function Body */
if (min(*m,*n) == 0) {
value = 0.f;
} else if (lsame_(norm, "M")) {

/*        Find max(abs(A(i,j))). */

value = 0.f;
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    for (i__ = 1; i__ <= i__2; ++i__) {
/* Computing MAX */
    r__1 = value, r__2 = c_abs(&a[i__ + j * a_dim1]);
    value = dmax(r__1,r__2);
/* L10: */
    }
/* L20: */
}

函数体：根据不同的范数类型计算单精度复数埃尔米特矩阵 A 的范数值。


} else if (lsame_(norm, "O") || *(unsigned char *)
    norm == '1') {

/*        Find norm1(A). */

value = 0.f;
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    sum = 0.f;
    i__2 = *m;
    for (i__ = 1; i__ <= i__2; ++i__) {
    sum += c_abs(&a[i__ + j * a_dim1]);
/* L30: */
    }
    value = dmax(value,sum);
/* L40: */
}

当范数为 "O" 或者 '1' 时：计算 A 的 1-范数。


} else if (lsame_(norm, "I")) {

/*        Find normI(A). */

i__1 = *m;
for (i__ = 1; i__ <= i__1; ++i__) {
    work[i__] = 0.f;
/* L50: */
}
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    for (i__ = 1; i__ <= i__2; ++i__) {
    work[i__] += c_abs(&a[i__ + j * a_dim1]);
/* L60: */
    }
/* L70: */
}
value = 0.f;
i__1 = *m;
for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
    r__1 = value, r__2 = work[i__];
    value = dmax(r__1,r__2);
/* L80: */
}

当范数为 "I" 时：计算 A 的 无穷范数。


} else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

scale = 0.f;
sum = 1.f;
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    classq_(m, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
/* L90: */
}
value = scale * sqrt(sum);
}

ret_val = value;
return ret_val;

/*     End of CLANGE */

} /* clange_ */

当范数为 "F" 或者 "E" 时：计算 A 的 Frobenius 范数。


doublereal clanhe_(char *norm, char *uplo, integer *n, singlecomplex *a, integer *
lda, real *work)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2;
real ret_val, r__1, r__2, r__3;

/* Local variables */
static integer i__, j;
static real sum, absa, scale;
extern logical lsame_(char *, char *);
static real value;
extern /* Subroutine */ int classq_(integer *, singlecomplex *, integer *, real
    *, real *);

/*
-- LAPACK auxiliary routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006

Purpose
=======

CLANHE  returns the value of the one norm,  or the Frobenius norm, or
the  infinity norm,  or the  element of  largest absolute value  of a
singlecomplex hermitian matrix A.

Description
===========

函数签名和描述：计算单精度复数埃尔米特矩阵 A 的各种范数值。
    ! CLANHE returns the value
    ! CLANHE 返回一个值，该值表示不同矩阵范数的计算结果，具体取决于参数NORM的设定。

       CLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
    
    ! where  norm1  denotes the  one norm of a matrix (maximum column sum),
    ! normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    ! normF  denotes the  Frobenius norm of a matrix (square root of sum of
    ! squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    
    ! 在这里，norm1表示矩阵的一范数（列的最大和），
    ! normI表示矩阵的无穷大范数（行的最大和），
    ! normF表示矩阵的Frobenius范数（平方和的平方根）。
    ! 注意，max(abs(A(i,j)))不是一个一致的矩阵范数。

    ! Arguments
    ! =========
    
    ! NORM    (input) CHARACTER*1
    !         Specifies the value to be returned in CLANHE as described
    !         above.
    !         指定返回在CLANHE中的值，具体取决于上面描述的NORM参数。
    
    ! UPLO    (input) CHARACTER*1
    !         Specifies whether the upper or lower triangular part of the
    !         hermitian matrix A is to be referenced.
    !         = 'U':  Upper triangular part of A is referenced
    !         = 'L':  Lower triangular part of A is referenced
    !         指定Hermitian矩阵A的上三角部分或下三角部分是否被引用。

    ! N       (input) INTEGER
    !         The order of the matrix A.  N >= 0.  When N = 0, CLANHE is
    !         set to zero.
    !         矩阵A的阶数N。N >= 0。当N = 0时，CLANHE设定为零。

    ! A       (input) COMPLEX array, dimension (LDA,N)
    !         The hermitian matrix A.  If UPLO = 'U', the leading n by n
    !         upper triangular part of A contains the upper triangular part
    !         of the matrix A, and the strictly lower triangular part of A
    !         is not referenced.  If UPLO = 'L', the leading n by n lower
    !         triangular part of A contains the lower triangular part of
    !         the matrix A, and the strictly upper triangular part of A is
    !         not referenced. Note that the imaginary parts of the diagonal
    !         elements need not be set and are assumed to be zero.
    !         Hermitian矩阵A。如果UPLO = 'U'，则A的n x n上三角部分包含矩阵A的上三角部分，
    !         且不引用严格的下三角部分。如果UPLO = 'L'，则A的n x n下三角部分包含矩阵A的下三角部分，
    !         且不引用严格的上三角部分。注意，对角元素的虚部不需要设置，并假定为零。

    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(N,1).
    !         数组A的主维度。LDA >= max(N,1)。

    ! WORK    (workspace) REAL array, dimension (MAX(1,LWORK)),
    !         where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
    !         WORK is not referenced.
    !         工作空间。当NORM = 'I'或'1'或'O'时，LWORK >= N；否则，不引用WORK。

   ! =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
        value = 0.f;
    } else if (lsame_(norm, "M")) {

        /* Find max(abs(A(i,j))). */

        value = 0.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    r__1 = value, r__2 = c_abs(&a[i__ + j * a_dim1]);
                    value = dmax(r__1,r__2);
                    /* L10: */
                }
                /* Computing MAX */
                i__2 = j + j * a_dim1;
                r__2 = value, r__3 = (r__1 = a[i__2].r, dabs(r__1));
                value = dmax(r__2,r__3);
                /* L20: */
            }
        } else {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                /* Computing MAX */
                i__2 = j + j * a_dim1;
                r__2 = value, r__3 = (r__1 = a[i__2].r, dabs(r__1));
                value = dmax(r__2,r__3);
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    /* Computing MAX */
                    r__1 = value, r__2 = c_abs(&a[i__ + j * a_dim1]);
                    value = dmax(r__1,r__2);
                    /* L30: */
                }
                /* L40: */
            }
        }
    } else if (lsame_(norm, "I") || lsame_(norm, "O") || *(unsigned char *)norm == '1') {

        /* Find normI(A) ( = norm1(A), since A is hermitian). */

        value = 0.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = 0.f;
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    absa = c_abs(&a[i__ + j * a_dim1]);
                    sum += absa;
                    work[i__] += absa;
                    /* L50: */
                }
                i__2 = j + j * a_dim1;
                work[j] = sum + (r__1 = a[i__2].r, dabs(r__1));
                /* L60: */
            }
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                /* Computing MAX */
                r__1 = value, r__2 = work[i__];
                value = dmax(r__1,r__2);
                /* L70: */
            }
        } else {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                work[i__] = 0.f;
                /* L80: */
            }
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j + j * a_dim1;
                sum = work[j] + (r__1 = a[i__2].r, dabs(r__1));
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    absa = c_abs(&a[i__ + j * a_dim1]);
                    sum += absa;
                    work[i__] += absa;
                    /* L90: */
                }
                value = dmax(value,sum);
                /* L100: */
            }
        }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

        /* Find normF(A). */

        scale = 0.f;
        sum = 1.f;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 2; j <= i__1; ++j) {
                i__2 = j - 1;
                classq_(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
                /* L110: */
            }
        } else {
            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                classq_(&i__2, &a[j + 1 + j * a_dim1], &c__1, &scale, &sum);
                /* L120: */
            }
        }
        sum *= 2;
        i__1 = *n;

        for (i__ = 1; i__ <= i__1; ++i__) {
            /* Computing MAX */
            r__1 = value, r__2 = work[i__];
            value = dmax(r__1,r__2);
            /* L130: */
        }
    }
    # 循环遍历 i__ 从 1 到 i__1
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 计算当前元素在数组 a 中的索引
        i__2 = i__ + i__ * a_dim1;
        # 检查数组 a 中当前元素的实部是否为零
        if (a[i__2].r != 0.f) {
            # 再次计算当前元素在数组 a 中的索引
            i__2 = i__ + i__ * a_dim1;
            # 计算当前元素的绝对值，存储在 absa 变量中
            absa = (r__1 = a[i__2].r, dabs(r__1));
            # 检查 absa 是否大于 scale 变量的值
            if (scale < absa) {
/* Computing 2nd power */
            r__1 = scale / absa;
            sum = sum * (r__1 * r__1) + 1.f;
            scale = absa;
        } else {
/* Computing 2nd power */
            r__1 = absa / scale;
            sum += r__1 * r__1;
        }
        }
/* L130: */
    }
    value = scale * sqrt(sum);
    }


    ret_val = value;
    return ret_val;

/*     End of CLANHE */

} /* clanhe_ */


/* Subroutine */ int claqr0_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, singlecomplex *h__, integer *ldh, singlecomplex *w,
    integer *iloz, integer *ihiz, singlecomplex *z__, integer *ldz, singlecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    real r__1, r__2, r__3, r__4, r__5, r__6, r__7, r__8;
    singlecomplex q__1, q__2, q__3, q__4, q__5;

    /* Local variables */
    static integer i__, k;
    static real s;
    static singlecomplex aa, bb, cc, dd;
    static integer ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
    static singlecomplex tr2, det;
    static integer inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot,
        nmin;
    static singlecomplex swap;
    static integer ktop;
    static singlecomplex zdum[1]    /* was [1][1] */;
    static integer kacc22, itmax, nsmax, nwmax, kwtop;
    extern /* Subroutine */ int claqr3_(logical *, logical *, integer *,
        integer *, integer *, integer *, singlecomplex *, integer *, integer *,
        integer *, singlecomplex *, integer *, integer *, integer *, singlecomplex *,
        singlecomplex *, integer *, integer *, singlecomplex *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *), claqr4_(logical *,
        logical *, integer *, integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *, integer *), claqr5_(logical *, logical *, integer *,
        integer *, integer *, integer *, integer *, singlecomplex *, singlecomplex *,
        integer *, integer *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *);
    static integer nibble;
    extern /* Subroutine */ int clahqr_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, integer *), clacpy_(char *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static char jbcmpz[2];
    static singlecomplex rtdisc;
    static integer nwupbd;
    static logical sorted;
    static integer lwkopt;


/*
*/
    /* Parameter adjustments */
    h_dim1 = *ldh;
    // 设置偏移量，h_offset 等于 1 + h_dim1
    h_offset = 1 + h_dim1;
    // 减去 h_offset，即将 h__ 指针向前偏移 h_offset 个位置
    h__ -= h_offset;
    // w 自减一，即将 w 变量的值减一
    --w;
    // 设置 z_dim1 等于 ldz，表示 z 的第一维度大小
    z_dim1 = *ldz;
    // 设置偏移量，z_offset 等于 1 + z_dim1
    z_offset = 1 + z_dim1;
    // 减去 z_offset，即将 z__ 指针向前偏移 z_offset 个位置
    z__ -= z_offset;
    // work 指针自减一，即将 work 指针向前偏移一个位置

    /* 函数体开始 */
    // 将 info 指向的内存位置设置为 0，用于初始化 info
    *info = 0;
/*     ==== Quick return for N = 0: nothing to do. ==== */
if (*n == 0) {
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
}

if (*n <= 11) {
/*        ==== Tiny matrices must use CLAHQR. ==== */

    lwkopt = 1;
    if (*lwork != -1) {
        clahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
            iloz, ihiz, &z__[z_offset], ldz, info);
    }
} else {
/*
          ==== Use small bulge multi-shift QR with aggressive early
          .    deflation on larger-than-tiny matrices. ====

          ==== Hope for the best. ====
*/

    *info = 0;

/*        ==== Set up job flags for ILAENV. ==== */

    if (*wantt) {
        *(unsigned char *)jbcmpz = 'S';
    } else {
        *(unsigned char *)jbcmpz = 'E';
    }
    if (*wantz) {
        *(unsigned char *)&jbcmpz[1] = 'V';
    } else {
        *(unsigned char *)&jbcmpz[1] = 'N';
    }

/*
          ==== NWR = recommended deflation window size.  At this
          .    point,  N .GT. NTINY = 11, so there is enough
          .    subdiagonal workspace for NWR.GE.2 as required.
          .    (In fact, there is enough subdiagonal space for
          .    NWR.GE.3.) ====
*/

    nwr = ilaenv_(&c__13, "CLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
    nwr = max(2,nwr);
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
    nwr = min(i__1,nwr);

/*
          ==== NSR = recommended number of simultaneous shifts.
          .    At this point N .GT. NTINY = 11, so there is at
          .    enough subdiagonal workspace for NSR to be even
          .    and greater than or equal to two as required. ====
*/

    nsr = ilaenv_(&c__15, "CLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;
    nsr = min(i__1,i__2);
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;
    nsr = max(i__1,i__2);

/*
          ==== Estimate optimal workspace ====

          ==== Workspace query call to CLAQR3 ====
*/

    i__1 = nwr + 1;
    claqr3_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[h_offset],
        ldh, n, &h__[h_offset], ldh, n, &h__[h_offset], ldh, &work[1],
         &c_n1);

/*
          ==== Optimal workspace = MAX(CLAQR5, CLAQR3) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1].r;
    lwkopt = max(i__1,i__2);

/*        ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {
        r__1 = (real) lwkopt;
        q__1.r = r__1, q__1.i = 0.f;
        work[1].r = q__1.r, work[1].i = q__1.i;
        return 0;
    }

/*        ==== CLAHQR/CLAQR0 crossover point ==== */

    nmin = ilaenv_(&c__12, "CLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
        6, (ftnlen)2);
    nmin = max(11,nmin);

/*        ==== Nibble crossover point ==== */
    # 调用名为 ilaenv_ 的外部函数，获取返回值赋给变量 nibble
    nibble = ilaenv_(&c__14, "CLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6, (ftnlen)2);
    # 将 nibble 和 0 比较，取较大的值，结果赋给 nibble
    nibble = max(0,nibble);
/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

// 调用 ILAENV 函数确定是否累积反射并使用2×2结构进行矩阵乘法
kacc22 = ilaenv_(&c__16, "CLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6, (ftnlen)2);
// 确保 kacc22 至少为0
kacc22 = max(0, kacc22);
// 确保 kacc22 最大为2
kacc22 = min(2, kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/
// 计算可能的最大缩小窗口大小，确保工作空间足够
i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
nwmax = min(i__1, i__2);
nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/
// 计算同时位移的最大数量，确保工作空间足够
i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
nsmax = min(i__1, i__2);
// 将 nsmax 调整为偶数
nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

// 初始化迭代计数器，用于在缩减时重新开始计数
ndfl = 1;

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/
// 设置迭代的最大次数上限
i__1 = 10, i__2 = *ihi - *ilo + 1;
itmax = max(i__1, i__2) * 30;

/*        ==== Last row and column in the active block ==== */

// 活动块中的最后一行和列
kbot = *ihi;

/*        ==== Main Loop ==== */

// 主循环，迭代直到达到最大迭代次数 itmax
i__1 = itmax;
for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

// 当 kbot 小于 ilo 时结束循环
if (kbot < *ilo) {
goto L80;
}

/*           ==== Locate active block ==== */

// 定位活动块
i__2 = *ilo + 1;
for (k = kbot; k >= i__2; --k) {
i__3 = k + (k - 1) * h_dim1;
// 如果 h__ 的特定位置为零，则跳转到 L20
if (h__[i__3].r == 0.f && h__[i__3].i == 0.f) {
goto L20;
}
// L10 标签处的操作
}
k = *ilo;
L20:
ktop = k;

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

// 计算缩小窗口的大小
nh = kbot - ktop + 1;
nwupbd = min(nh, nwmax);
if (ndfl < 5) {
nw = min(nwupbd, nwr);
} else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
/* 将 nw 设为 nwupbd 和 nw 的两倍中较小的值 */

        }
        if (nw < nwmax) {
/* 如果 nw 小于 nwmax */
        if (nw >= nh - 1) {
/* 如果 nw 大于等于 nh - 1 */
            nw = nh;
/* 将 nw 设为 nh */
        } else {
/* 否则 */
            kwtop = kbot - nw + 1;
/* 计算 kwtop */
            i__2 = kwtop + (kwtop - 1) * h_dim1;
            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
            if ((r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&
                h__[kwtop + (kwtop - 1) * h_dim1]), dabs(r__2)) >
                (r__3 = h__[i__3].r, dabs(r__3)) + (r__4 = r_imag(
                &h__[kwtop - 1 + (kwtop - 2) * h_dim1]), dabs(
                r__4))) {
/* 如果某个条件满足 */
            ++nw;
/* nw 加一 */
            }
        }
        }
        if (ndfl < 5) {
/* 如果 ndfl 小于 5 */
        ndec = -1;
/* 将 ndec 设为 -1 */
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 否则如果 ndec 大于等于 0 或者 nw 大于等于 nwupbd */
        ++ndec;
/* ndec 加一 */
        if (nw - ndec < 2) {
/* 如果 nw 减去 ndec 小于 2 */
            ndec = 0;
/* 将 ndec 设为 0 */
        }
        nw -= ndec;
/* nw 减去 ndec */
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

        kv = *n - nw + 1;
/* 计算 kv */
        kt = nw + 1;
/* 计算 kt */
        nho = *n - nw - 1 - kt + 1;
/* 计算 nho */
        kwv = nw + 2;
/* 计算 kwv */
        nve = *n - nw - kwv + 1;
/* 计算 nve */

/*           ==== Aggressive early deflation ==== */

        claqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[kv
            + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], ldh, &nve, &
            h__[kwv + h_dim1], ldh, &work[1], lwork);
/* 调用 claqr3_ 函数进行计算 */

/*           ==== Adjust KBOT accounting for new deflations. ==== */

        kbot -= ld;
/* 将 kbot 减去 ld */

/*           ==== KS points to the shifts. ==== */

        ks = kbot - ls + 1;
/* 计算 ks */

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if CLAQR3
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
/* 计算 ns */
        ns = min(i__2,i__3);
/* 将 ns 设为 min(i__2, i__3) */
        ns -= ns % 2;
/* ns 减去 ns 与 2 的余数 */
/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    CLAQR3 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
if (ndfl % 6 == 0) {
    // 如果在 KEXSH 的倍数次迭代中没有发生任何消除操作
    // 尝试异常的移位策略
    ks = kbot - ns + 1;
    i__2 = ks + 1;
    for (i__ = kbot; i__ >= i__2; i__ += -2) {
        i__3 = i__;
        i__4 = i__ + i__ * h_dim1;
        i__5 = i__ + (i__ - 1) * h_dim1;
        // 计算新的位移
        r__3 = ((r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
            r_imag(&h__[i__ + (i__ - 1) * h_dim1]), dabs(
            r__2))) * .75f;
        q__1.r = h__[i__4].r + r__3, q__1.i = h__[i__4].i;
        w[i__3].r = q__1.r, w[i__3].i = q__1.i;
        i__3 = i__ - 1;
        i__4 = i__;
        w[i__3].r = w[i__4].r, w[i__3].i = w[i__4].i;
        // L30 标签，用于循环结构
/* L30: */
    }
} else {
    /*
                   ==== Got NS/2 or fewer shifts? Use CLAQR4 or
                   .    CLAHQR on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
    */
    // 如果得到了 NS/2 或更少的位移，使用 CLAQR4 或 CLAHQR 处理尾部主子矩阵
    // 以获取更多的位移
    if (kbot - ks + 1 <= ns / 2) {
        ks = kbot - ns + 1;
        kt = *n - ns + 1;
        // 复制并处理主子矩阵
        clacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
            h__[kt + h_dim1], ldh);
        if (ns > nmin) {
            // 处理大型主子矩阵
            claqr4_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                zdum, &c__1, &work[1], lwork, &inf);
        } else {
            // 处理小型主子矩阵
            clahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                zdum, &c__1, &inf);
        }
        // 更新 ks
        ks += inf;
        /*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  Scale to avoid
                      .    overflows, underflows and subnormals.
                      .    (The scale factor S can not be zero,
                      .    because H(KBOT,KBOT-1) is nonzero.) ====
        */
    }
}
            if (ks >= kbot) {
                // 计算对角块的绝对值之和，用于求解特征值问题的复数判别式
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                i__3 = kbot + (kbot - 1) * h_dim1;
                i__4 = kbot - 1 + kbot * h_dim1;
                i__5 = kbot + kbot * h_dim1;
                s = (r__1 = h__[i__2].r, dabs(r__1)) + (r__2 =
                    r_imag(&h__[kbot - 1 + (kbot - 1) *
                    h_dim1]), dabs(r__2)) + ((r__3 = h__[i__3]
                    .r, dabs(r__3)) + (r__4 = r_imag(&h__[
                    kbot + (kbot - 1) * h_dim1]), dabs(r__4)))
                     + ((r__5 = h__[i__4].r, dabs(r__5)) + (
                    r__6 = r_imag(&h__[kbot - 1 + kbot *
                    h_dim1]), dabs(r__6))) + ((r__7 = h__[
                    i__5].r, dabs(r__7)) + (r__8 = r_imag(&
                    h__[kbot + kbot * h_dim1]), dabs(r__8)));
                // 根据计算的绝对值之和，归一化对角块的四个元素
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                aa.r = q__1.r, aa.i = q__1.i;
                i__2 = kbot + (kbot - 1) * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                cc.r = q__1.r, cc.i = q__1.i;
                i__2 = kbot - 1 + kbot * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                bb.r = q__1.r, bb.i = q__1.i;
                i__2 = kbot + kbot * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                dd.r = q__1.r, dd.i = q__1.i;
                // 计算特征值的实部和虚部
                q__2.r = aa.r + dd.r, q__2.i = aa.i + dd.i;
                q__1.r = q__2.r / 2.f, q__1.i = q__2.i / 2.f;
                tr2.r = q__1.r, tr2.i = q__1.i;
                q__3.r = aa.r - tr2.r, q__3.i = aa.i - tr2.i;
                q__4.r = dd.r - tr2.r, q__4.i = dd.i - tr2.i;
                q__2.r = q__3.r * q__4.r - q__3.i * q__4.i,
                    q__2.i = q__3.r * q__4.i + q__3.i *
                    q__4.r;
                q__5.r = bb.r * cc.r - bb.i * cc.i, q__5.i = bb.r
                    * cc.i + bb.i * cc.r;
                q__1.r = q__2.r - q__5.r, q__1.i = q__2.i -
                    q__5.i;
                det.r = q__1.r, det.i = q__1.i;
                // 计算特征值的平方根
                q__2.r = -det.r, q__2.i = -det.i;
                c_sqrt(&q__1, &q__2);
                rtdisc.r = q__1.r, rtdisc.i = q__1.i;
                // 计算两个特征值
                i__2 = kbot - 1;
                q__2.r = tr2.r + rtdisc.r, q__2.i = tr2.i +
                    rtdisc.i;
                q__1.r = s * q__2.r, q__1.i = s * q__2.i;
                w[i__2].r = q__1.r, w[i__2].i = q__1.i;
                i__2 = kbot;
                q__2.r = tr2.r - rtdisc.r, q__2.i = tr2.i -
                    rtdisc.i;
                q__1.r = s * q__2.r, q__1.i = s * q__2.i;
                w[i__2].r = q__1.r, w[i__2].i = q__1.i;

                // 更新 ks 的值
                ks = kbot - 1;
            }
/*                    ==== Sort the shifts (Helps a little) ==== */

/* 设置排序标志为假 */
            sorted = FALSE_;
/* 循环从 kbot 到 ks+1，反向遍历 */
            i__2 = ks + 1;
            for (k = kbot; k >= i__2; --k) {
/* 如果已经排序完成，则跳转到标签 L60 */
                if (sorted) {
                goto L60;
                }
/* 设置排序标志为真 */
                sorted = TRUE_;
/* 内层循环，从 ks 到 k-1 */
                i__3 = k - 1;
                for (i__ = ks; i__ <= i__3; ++i__) {
/* 比较相邻两个元素的大小 */
                i__4 = i__;
                i__5 = i__ + 1;
/* 如果前一个元素的复数绝对值之和小于后一个元素的复数绝对值之和，则交换它们 */
                if ((r__1 = w[i__4].r, dabs(r__1)) + (r__2 =
                    r_imag(&w[i__]), dabs(r__2)) < (r__3 =
                     w[i__5].r, dabs(r__3)) + (r__4 =
                    r_imag(&w[i__ + 1]), dabs(r__4))) {
/* 设置排序标志为假 */
                    sorted = FALSE_;
/* 交换 w[i__] 和 w[i__+1] */
                    i__4 = i__;
                    swap.r = w[i__4].r, swap.i = w[i__4].i;
                    i__4 = i__;
                    i__5 = i__ + 1;
                    w[i__4].r = w[i__5].r, w[i__4].i = w[i__5]
                        .i;
                    i__4 = i__ + 1;
                    w[i__4].r = swap.r, w[i__4].i = swap.i;
                }
/* L40: 标签 */
                }
/* L50: 标签 */
            }
/* L60: 标签，排序完成 */

/*
                ==== If there are only two shifts, then use
                .    only one.  ====
*/

/* 如果只有两个移位数，则只使用一个 */
        if (kbot - ks + 1 == 2) {
/* 计算 q__1 和 q__3 的值 */
            i__2 = kbot;
            i__3 = kbot + kbot * h_dim1;
            q__2.r = w[i__2].r - h__[i__3].r, q__2.i = w[i__2].i -
                h__[i__3].i;
            q__1.r = q__2.r, q__1.i = q__2.i;
            i__4 = kbot - 1;
            i__5 = kbot + kbot * h_dim1;
            q__4.r = w[i__4].r - h__[i__5].r, q__4.i = w[i__4].i -
                h__[i__5].i;
            q__3.r = q__4.r, q__3.i = q__4.i;
/* 如果 q__1 的复数绝对值之和小于 q__3 的复数绝对值之和，则交换 w[kbot-1] 和 w[kbot] */
            if ((r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&q__1),
                dabs(r__2)) < (r__3 = q__3.r, dabs(r__3)) + (r__4
                = r_imag(&q__3), dabs(r__4))) {
            i__2 = kbot - 1;
            i__3 = kbot;
            w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
            } else {
/* 否则，交换 w[kbot] 和 w[kbot-1] */
            i__2 = kbot;
            i__3 = kbot - 1;
            w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
            }
        }

/*
                ==== Use up to NS of the smallest magnatiude
                .    shifts.  If there aren't NS shifts available,
                .    then use them all, possibly dropping one to
                .    make the number of shifts even. ====

   Computing MIN
*/
/* 计算 ns 和 kbot-ks+1 的最小值 */
        i__2 = ns, i__3 = kbot - ks + 1;
        ns = min(i__2,i__3);
/* 将 ns 调整为偶数 */
        ns -= ns % 2;
/* 更新 ks */
        ks = kbot - ns + 1;
/*
                ==== Small-bulge multi-shift QR sweep:
                .    split workspace under the subdiagonal into
                .    - a KDU-by-KDU work array U in the lower
                .      left-hand-corner,
                .    - a KDU-by-at-least-KDU-but-more-is-better
                .      (KDU-by-NHo) horizontal work array WH along
                .      the bottom edge,
                .    - and an at-least-KDU-but-more-is-better-by-KDU
                .      (NVE-by-KDU) vertical work WV arrow along
                .      the left-hand-edge. ====
*/

        kdu = ns * 3 - 3;  // 计算 KDU 的值
        ku = *n - kdu + 1;  // 计算 KU 的值
        kwh = kdu + 1;  // 计算 KWH 的值
        nho = *n - kdu - 3 - (kdu + 1) + 1;  // 计算 NHO 的值
        kwv = kdu + 4;  // 计算 KWV 的值
        nve = *n - kdu - kwv + 1;  // 计算 NVE 的值

/*              ==== Small-bulge multi-shift QR sweep ==== */

        claqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks], &
            h__[h_offset], ldh, iloz, ihiz, &z__[z_offset], ldz, &
            work[1], &c__3, &h__[ku + h_dim1], ldh, &nve, &h__[
            kwv + h_dim1], ldh, &nho, &h__[ku + kwh * h_dim1],
            ldh);
        }

/*           ==== Note progress (or the lack of it). ==== */

        if (ld > 0) {  // 如果 ld 大于 0
        ndfl = 1;  // 设置 ndfl 为 1
        } else {  // 否则
        ++ndfl;  // ndfl 加一
        }

/*
             ==== End of main loop ====
   L70:
*/
    }

/*
          ==== Iteration limit exceeded.  Set INFO to show where
          .    the problem occurred and exit. ====
*/

    *info = kbot;  // 将 kbot 赋值给 info
L80:
    ;
    }

/*     ==== Return the optimal value of LWORK. ==== */

    r__1 = (real) lwkopt;  // 将 lwkopt 转换为实数，并赋给 r__1
    q__1.r = r__1, q__1.i = 0.f;  // 将 r__1 赋给 work[1] 的实部和虚部
    work[1].r = q__1.r, work[1].i = q__1.i;

/*     ==== End of CLAQR0 ==== */

    return 0;  // 返回值为 0，表示成功
} /* claqr0_ */

/* Subroutine */ int claqr1_(integer *n, singlecomplex *h__, integer *ldh, singlecomplex *
    s1, singlecomplex *s2, singlecomplex *v)
{
    /* System generated locals */
    integer h_dim1, h_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;
    singlecomplex q__1, q__2, q__3, q__4, q__5, q__6, q__7, q__8;

    /* Local variables */
    static real s;
    static singlecomplex h21s, h31s;


/*
    # LAPACK 辅助例程（版本 3.2）
    # 田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司
    # 2006年11月
    
    # 给定一个 2x2 或 3x3 矩阵 H，CLAQR1 函数将 v 设置为乘积的第一列的标量倍数
    # (*)  K = (H - s1*I)*(H - s2*I)
    # 通过缩放来避免溢出和大部分下溢。这对于启动 QR 算法中的双隐式位移膨胀很有用。
    
    N      (input) integer
           矩阵 H 的阶数。N 必须是 2 或 3。
    
    H      (input) COMPLEX 数组，维度为 (LDH,N)
           矩阵 H 在 (*) 中的 2x2 或 3x3 矩阵。
    
    LDH    (input) integer
           在调用过程中声明的矩阵 H 的领先维度。LDH >= N
    
    S1     (input) COMPLEX
    S2     S1 和 S2 是 (*) 中定义 K 的位移。
    
    V      (output) COMPLEX 数组，维度为 N
           矩阵 K (*) 中第一列的标量倍数。
    
    ================================================================
    基于以下贡献
       Karen Braman 和 Ralph Byers，数学系，
       美国堪萨斯大学
    
    ================================================================
    /* Parameter adjustments */
    // 设置第一个维度的大小为ldh，计算偏移量，并将h__指针移至正确位置
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    // 将v数组指针移至正确位置
    --v;

    /* Function Body */
    // 当n等于2时执行以下代码块
    if (*n == 2) {
        // 计算h__[h_dim1 + 1]与s2之差的复数值
        i__1 = h_dim1 + 1;
        q__2.r = h__[i__1].r - s2->r, q__2.i = h__[i__1].i - s2->i;
        q__1.r = q__2.r, q__1.i = q__2.i;
        // 计算s的绝对值
        i__2 = h_dim1 + 2;
        s = (r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&q__1), dabs(r__2))
            + ((r__3 = h__[i__2].r, dabs(r__3)) + (r__4 = r_imag(&h__[
            h_dim1 + 2]), dabs(r__4)));
        // 如果s为0，则将v数组前两个元素置为0
        if (s == 0.f) {
            v[1].r = 0.f, v[1].i = 0.f;
            v[2].r = 0.f, v[2].i = 0.f;
        } else {
            // 否则计算h__[h_dim1 + 2]与s的比值，并将结果存储在h21s中
            i__1 = h_dim1 + 2;
            q__1.r = h__[i__1].r / s, q__1.i = h__[i__1].i / s;
            h21s.r = q__1.r, h21s.i = q__1.i;
            // 计算v[1]的值
            i__1 = (h_dim1 << 1) + 1;
            q__2.r = h21s.r * h__[i__1].r - h21s.i * h__[i__1].i, q__2.i =
                h21s.r * h__[i__1].i + h21s.i * h__[i__1].r;
            i__2 = h_dim1 + 1;
            q__4.r = h__[i__2].r - s1->r, q__4.i = h__[i__2].i - s1->i;
            i__3 = h_dim1 + 1;
            q__6.r = h__[i__3].r - s2->r, q__6.i = h__[i__3].i - s2->i;
            q__5.r = q__6.r / s, q__5.i = q__6.i / s;
            q__3.r = q__4.r * q__5.r - q__4.i * q__5.i, q__3.i = q__4.r *
                q__5.i + q__4.i * q__5.r;
            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
            v[1].r = q__1.r, v[1].i = q__1.i;
            // 计算v[2]的值
            i__1 = h_dim1 + 1;
            i__2 = (h_dim1 << 1) + 2;
            q__4.r = h__[i__1].r + h__[i__2].r, q__4.i = h__[i__1].i + h__[
                i__2].i;
            q__3.r = q__4.r - s1->r, q__3.i = q__4.i - s1->i;
            q__2.r = q__3.r - s2->r, q__2.i = q__3.i - s2->i;
            q__1.r = h21s.r * q__2.r - h21s.i * q__2.i, q__1.i = h21s.r *
                q__2.i + h21s.i * q__2.r;
            v[2].r = q__1.r, v[2].i = q__1.i;
        }
    } else {
        // 当n不等于2时执行以下代码块
        i__1 = h_dim1 + 1;
        q__2.r = h__[i__1].r - s2->r, q__2.i = h__[i__1].i - s2->i;
        q__1.r = q__2.r, q__1.i = q__2.i;
        // 计算s的绝对值，包括三个项
        i__2 = h_dim1 + 2;
        i__3 = h_dim1 + 3;
        s = (r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&q__1), dabs(r__2))
            + ((r__3 = h__[i__2].r, dabs(r__3)) + (r__4 = r_imag(&h__[
            h_dim1 + 2]), dabs(r__4))) + ((r__5 = h__[i__3].r, dabs(r__5))
             + (r__6 = r_imag(&h__[h_dim1 + 3]), dabs(r__6)));
        // 如果s为0，则将v数组前三个元素置为0
        if (s == 0.f) {
            v[1].r = 0.f, v[1].i = 0.f;
            v[2].r = 0.f, v[2].i = 0.f;
            v[3].r = 0.f, v[3].i = 0.f;

            v[1].r = 0.f, v[1].i = 0.f;
            v[2].r = 0.f, v[2].i = 0.f;
            v[3].r = 0.f, v[3].i = 0.f;
        } else {
            // 否则执行以下代码块
            // 计算h__[h_dim1 + 1]与s2之差的复数值
            i__1 = h_dim1 + 1;
            q__2.r = h__[i__1].r - s2->r, q__2.i = h__[i__1].i - s2->i;
            q__1.r = q__2.r, q__1.i = q__2.i;
            // 计算s的绝对值，包括三个项
            i__2 = h_dim1 + 2;
            i__3 = h_dim1 + 3;
            s = (r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&q__1), dabs(r__2))
                + ((r__3 = h__[i__2].r, dabs(r__3)) + (r__4 = r_imag(&h__[
                h_dim1 + 2]), dabs(r__4))) + ((r__5 = h__[i__3].r, dabs(r__5))
                 + (r__6 = r_imag(&h__[h_dim1 + 3]), dabs(r__6)));
            // 计算v[1]的值
            i__1 = (h_dim1 << 1) + 1;
            q__2.r = h21s.r * h__[i__1].r - h21s.i * h__[i__1].i, q__2.i =
                h21s.r * h__[i__1].i + h21s.i * h__[i__1].r;
            i__2 = h_dim1 + 1;
            q__4.r = h__[i__2].r - s1->r, q__4.i = h__[i__2].i - s1->i;
            i__3 = h_dim1 + 1;
            q__6.r = h__[i__3].r - s2->r, q__6.i = h__[i__3].i - s2->i;
            q__5.r = q__6.r / s, q__5.i = q__6.i / s;
            q__3.r = q__4.r * q__5.r - q__4.i * q__5.i, q__3.i = q__4.r *
                q__5.i + q__4.i * q__5.r;
            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
            v[1].r = q__1.r, v[1].i = q__1.i;
            // 计算v[2]的值
            i__1 = h_dim1 + 1;
            i__2 = (h_dim1 << 1) + 2;
            q__4.r = h__[i__1].r + h__[i__2].r, q__4.i = h__[i__1].i + h__[
                i__2].i;
            q__3.r = q__4.r - s1->r, q__3.i = q__4.i - s1->i;
            q__2.r = q__3.r - s2->r, q__2.i = q__3.i - s2->i;
            q__1.r = h21s.r * q__2.r - h21s.i * q__2.i, q__1.i = h21s.r *
                q__2.i + h21s.i * q__2.r;
            v[2].r = q__1.r, v[2].i = q__1.i;
            // 计算v[3]的值
            i__1 = (h_dim1 << 1) + 3;
            q__4.r = h21s.r * h__[i__2].r - h21s.i * h__[i__2].i, q__4.i =
                h21s.r * h__[i__2].i + h21s.i * h__[i__2].r;
            q__6.r = h__[i__1].r - s1->r, q__6.i = h__[i__1].i - s1->i;
            q__5.r = q__6.r - s2->r, q__5.i = q__6.i - s2->i;
            q__3.r = h21s.r * q__5.r - h21s.i * q__5.i, q__3.i = h21s.r *
                q__5.i + h21s.i * q__5.r;
            q__2.r = q__4.r + q__3.r, q__2.i = q__4.i + q__3.i;
            v[3].r = q__2.r, v[3].i = q__2.i;
        }
    }
    } else {
        // 计算 h21s 和 h31s 的值
        i__1 = h_dim1 + 2;
        q__1.r = h__[i__1].r / s, q__1.i = h__[i__1].i / s;
        h21s.r = q__1.r, h21s.i = q__1.i;
        i__1 = h_dim1 + 3;
        q__1.r = h__[i__1].r / s, q__1.i = h__[i__1].i / s;
        h31s.r = q__1.r, h31s.i = q__1.i;
        
        // 计算 v[1] 的值
        i__1 = h_dim1 + 1;
        q__4.r = h__[i__1].r - s1->r, q__4.i = h__[i__1].i - s1->i;
        i__2 = h_dim1 + 1;
        q__6.r = h__[i__2].r - s2->r, q__6.i = h__[i__2].i - s2->i;
        q__5.r = q__6.r / s, q__5.i = q__6.i / s;
        q__3.r = q__4.r * q__5.r - q__4.i * q__5.i, q__3.i = q__4.r * q__5.i + q__4.i * q__5.r;
        i__3 = (h_dim1 << 1) + 1;
        q__7.r = h__[i__3].r * h21s.r - h__[i__3].i * h21s.i, q__7.i = h__[i__3].r * h21s.i + h__[i__3].i * h21s.r;
        q__2.r = q__3.r + q__7.r, q__2.i = q__3.i + q__7.i;
        i__4 = h_dim1 * 3 + 1;
        q__8.r = h__[i__4].r * h31s.r - h__[i__4].i * h31s.i, q__8.i = h__[i__4].r * h31s.i + h__[i__4].i * h31s.r;
        q__1.r = q__2.r + q__8.r, q__1.i = q__2.i + q__8.i;
        v[1].r = q__1.r, v[1].i = q__1.i;
        
        // 计算 v[2] 的值
        i__1 = h_dim1 + 1;
        i__2 = (h_dim1 << 1) + 2;
        q__5.r = h__[i__1].r + h__[i__2].r, q__5.i = h__[i__1].i + h__[i__2].i;
        q__4.r = q__5.r - s1->r, q__4.i = q__5.i - s1->i;
        q__3.r = q__4.r - s2->r, q__3.i = q__4.i - s2->i;
        q__2.r = h21s.r * q__3.r - h21s.i * q__3.i, q__2.i = h21s.r * q__3.i + h21s.i * q__3.r;
        i__3 = h_dim1 * 3 + 2;
        q__6.r = h__[i__3].r * h31s.r - h__[i__3].i * h31s.i, q__6.i = h__[i__3].r * h31s.i + h__[i__3].i * h31s.r;
        q__1.r = q__2.r + q__6.r, q__1.i = q__2.i + q__6.i;
        v[2].r = q__1.r, v[2].i = q__1.i;
        
        // 计算 v[3] 的值
        i__1 = h_dim1 + 1;
        i__2 = h_dim1 * 3 + 3;
        q__5.r = h__[i__1].r + h__[i__2].r, q__5.i = h__[i__1].i + h__[i__2].i;
        q__4.r = q__5.r - s1->r, q__4.i = q__5.i - s1->i;
        q__3.r = q__4.r - s2->r, q__3.i = q__4.i - s2->i;
        q__2.r = h31s.r * q__3.r - h31s.i * q__3.i, q__2.i = h31s.r * q__3.i + h31s.i * q__3.r;
        i__3 = (h_dim1 << 1) + 3;
        q__6.r = h21s.r * h__[i__3].r - h21s.i * h__[i__3].i, q__6.i = h21s.r * h__[i__3].i + h21s.i * h__[i__3].r;
        q__1.r = q__2.r + q__6.r, q__1.i = q__2.i + q__6.i;
        v[3].r = q__1.r, v[3].i = q__1.i;
    }
    // 返回 0 表示正常执行完成
    return 0;
} /* claqr1_ */

/* Subroutine */ int claqr2_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, singlecomplex *h__, integer *ldh,
     integer *iloz, integer *ihiz, singlecomplex *z__, integer *ldz, integer *
    ns, integer *nd, singlecomplex *sh, singlecomplex *v, integer *ldv, integer *nh,
    singlecomplex *t, integer *ldt, integer *nv, singlecomplex *wv, integer *ldwv,
    singlecomplex *work, integer *lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;
    singlecomplex q__1, q__2;

    /* Local variables */
    static integer i__, j; // 声明整数型变量 i 和 j
    static singlecomplex s; // 声明复数型变量 s
    static integer jw; // 声明整数型变量 jw
    static real foo; // 声明实数型变量 foo
    static integer kln; // 声明整数型变量 kln
    static singlecomplex tau; // 声明复数型变量 tau
    static integer knt; // 声明整数型变量 knt
    static real ulp; // 声明实数型变量 ulp
    static integer lwk1, lwk2; // 声明整数型变量 lwk1 和 lwk2
    static singlecomplex beta; // 声明复数型变量 beta
    static integer kcol, info, ifst, ilst, ltop, krow; // 声明整数型变量 kcol, info, ifst, ilst, ltop, krow
    extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
        , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
        // 外部函数声明：对 Hessenberg 矩阵进行 Householder 变换
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *, integer *, singlecomplex *,
         singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *,
         integer *);
        // 外部函数声明：复数矩阵乘法
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
        // 外部函数声明：复制复数向量
    static integer infqr, kwtop; // 声明静态整数型变量 infqr 和 kwtop
    extern /* Subroutine */ int slabad_(real *, real *);
        // 外部函数声明：初始化机器精度相关参数
    extern /* Subroutine */ int cgehrd_(integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *,
        integer *, integer *);
        // 外部函数声明：对复数矩阵进行 Hessenberg 化
    extern /* Subroutine */ int clarfg_(integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *);
        // 外部函数声明：生成复数向量的 Householder 变换
    extern doublereal slamch_(char *);
        // 外部函数声明：返回指定机器参数的值
    extern /* Subroutine */ int clahqr_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, integer *);
        // 外部函数声明：计算复 Hessenberg 矩阵的特征值
    extern /* Subroutine */ int clacpy_(char *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *);
        // 外部函数声明：复制复数矩阵
    extern /* Subroutine */ int claset_(char *, integer *, integer *, singlecomplex *, singlecomplex
        *, singlecomplex *, integer *);
        // 外部函数声明：设置复数矩阵的元素为指定值
    static real safmin, safmax; // 声明静态实数型变量 safmin 和 safmax
    extern /* Subroutine */ int ctrexc_(char *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *, integer *, integer *, integer *);
        // 外部函数声明：交换复数矩阵的行和列
    extern /* Subroutine */ int cunmhr_(char *, char *, integer *, integer *, integer *, integer
        *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex
        *, integer *, integer *);
        // 外部函数声明：对复数矩阵乘以 Householder 变换

/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1; // 设置 h 的偏移量
    // ...


注释部分详细解释了每个变量和函数声明的作用和含义，符合注释要求。
    // 减去 h_offset，更新 h__ 指针位置
    h__ -= h_offset;
    // 获取 z_dim1，即 z 矩阵的列数
    z_dim1 = *ldz;
    // 计算 z__ 在二维数组 z 中的偏移量
    z_offset = 1 + z_dim1;
    // 减去 z_offset，更新 z__ 指针位置
    z__ -= z_offset;
    // 减去 sh 的值，更新 sh 指针位置
    --sh;
    // 获取 v_dim1，即 v 矩阵的列数
    v_dim1 = *ldv;
    // 计算 v 在二维数组 v 中的偏移量
    v_offset = 1 + v_dim1;
    // 减去 v_offset，更新 v 指针位置
    v -= v_offset;
    // 获取 t_dim1，即 t 矩阵的列数
    t_dim1 = *ldt;
    // 计算 t 在二维数组 t 中的偏移量
    t_offset = 1 + t_dim1;
    // 减去 t_offset，更新 t 指针位置
    t -= t_offset;
    // 获取 wv_dim1，即 wv 矩阵的列数
    wv_dim1 = *ldwv;
    // 计算 wv 在二维数组 wv 中的偏移量
    wv_offset = 1 + wv_dim1;
    // 减去 wv_offset，更新 wv 指针位置
    wv -= wv_offset;
    // 减去 work 指针的值，更新 work 指针位置
    --work;
    
    /* 函数主体 */
/* Computing MIN */
/* 计算最小值，选择工作空间的大小 */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    /* 如果 jw 小于等于 2，则设置最小的工作空间大小为 1 */
    if (jw <= 2) {
        lwkopt = 1;
    } else {

/*        ==== Workspace query call to CGEHRD ==== */
/*        ==== 调用 CGEHRD 进行工作空间查询 ==== */

    i__1 = jw - 1;
    /* 调用 CGEHRD 计算 HR 完全反射序列的 HR 格式 */
    cgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
        c_n1, &info);
    lwk1 = (integer) work[1].r;

/*        ==== Workspace query call to CUNMHR ==== */
/*        ==== 调用 CUNMHR 进行工作空间查询 ==== */

    i__1 = jw - 1;
    /* 调用 CUNMHR 以生成正交矩阵 Q 用于多重 QR 算法 */
    cunmhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
         &v[v_offset], ldv, &work[1], &c_n1, &info);
    lwk2 = (integer) work[1].r;

/*        ==== Optimal workspace ==== */
/*        ==== 计算最优工作空间大小 ==== */

    lwkopt = jw + max(lwk1,lwk2);
    }

/*     ==== Quick return in case of workspace query. ==== */
/*     ==== 在工作空间查询的情况下快速返回 ==== */

    if (*lwork == -1) {
    r__1 = (real) lwkopt;
    q__1.r = r__1, q__1.i = 0.f;
    work[1].r = q__1.r, work[1].i = q__1.i;
    return 0;
    }

/*
       ==== Nothing to do ...
       ... for an empty active block ... ====
*/
/*     ==== 对于空活动块没有什么可做... ====
       ... nor for an empty deflation window. ====
       ... 也对于一个空的剔除窗口没有什么可做。 ====
*/
    *ns = 0;
    *nd = 0;
    work[1].r = 1.f, work[1].i = 0.f;
    if (*ktop > *kbot) {
    return 0;
    }
/*     ... nor for an empty deflation window. ==== */
/*     ... 也对于一个空的剔除窗口没有什么可做。 ==== */
    if (*nw < 1) {
    return 0;
    }

/*     ==== Machine constants ==== */
/*     ==== 机器常数 ==== */

    safmin = slamch_("SAFE MINIMUM");
    safmax = 1.f / safmin;
    slabad_(&safmin, &safmax);
    ulp = slamch_("PRECISION");
    smlnum = safmin * ((real) (*n) / ulp);

/*
       ==== Setup deflation window ====

   Computing MIN
*/
/*     ==== 设置剔除窗口大小 ==== */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    kwtop = *kbot - jw + 1;
    if (kwtop == *ktop) {
    s.r = 0.f, s.i = 0.f;
    } else {
    i__1 = kwtop + (kwtop - 1) * h_dim1;
    s.r = h__[i__1].r, s.i = h__[i__1].i;
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */
/*        ==== 1x1 剔除窗口：没有太多要做的 ==== */

    i__1 = kwtop;
    i__2 = kwtop + kwtop * h_dim1;
    sh[i__1].r = h__[i__2].r, sh[i__1].i = h__[i__2].i;
    *ns = 1;
    *nd = 0;
/* Computing MAX */
    i__1 = kwtop + kwtop * h_dim1;
    r__5 = smlnum, r__6 = ulp * ((r__1 = h__[i__1].r, dabs(r__1)) + (r__2
        = r_imag(&h__[kwtop + kwtop * h_dim1]), dabs(r__2)));
    if ((r__3 = s.r, dabs(r__3)) + (r__4 = r_imag(&s), dabs(r__4)) <=
        dmax(r__5,r__6)) {
        *ns = 0;
        *nd = 1;
        if (kwtop > *ktop) {
        i__1 = kwtop + (kwtop - 1) * h_dim1;
        h__[i__1].r = 0.f, h__[i__1].i = 0.f;
        }
    }
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/
/*     ==== 转换为尖峰-三角形式。在罕见的 QR 失败情况下，这个例程继续使用剔除窗口的那部分
       .    通过 INFQR 收敛的内容来进行积极的早期剔除，以便跟踪。 ==== */

    clacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
        ldt);
    i__1 = jw - 1;
    i__2 = *ldh + 1;
    i__3 = *ldt + 1;
    ccopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
        i__3);
    # 调用 claset_ 函数，对矩阵 A 进行初始化设置
    claset_("A", &jw, &jw, &c_b56, &c_b57, &v[v_offset], ldv);
    # 调用 clahqr_ 函数，进行隐式双步 QR 算法计算特征值
    clahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[kwtop],
            &c__1, &jw, &v[v_offset], ldv, &infqr);
/*     ==== Deflation detection loop ==== */

    *ns = jw;  // 设置 *ns 等于 jw
    ilst = infqr + 1;  // 初始化 ilst 为 infqr + 1
    i__1 = jw;
    for (knt = infqr + 1; knt <= i__1; ++knt) {

/*        ==== Small spike tip deflation test ==== */

    i__2 = *ns + *ns * t_dim1;  // 计算索引位置
    foo = (r__1 = t[i__2].r, dabs(r__1)) + (r__2 = r_imag(&t[*ns + *ns *
        t_dim1]), dabs(r__2));  // 计算 foo 值，用于判断小尖峰顶的泄洪测试
    if (foo == 0.f) {  // 如果 foo 等于 0
        foo = (r__1 = s.r, dabs(r__1)) + (r__2 = r_imag(&s), dabs(r__2));  // 则重新计算 foo
    }
    i__2 = *ns * v_dim1 + 1;  // 计算索引位置
/* Computing MAX */
    r__5 = smlnum, r__6 = ulp * foo;  // 计算最大值
    if (((r__1 = s.r, dabs(r__1)) + (r__2 = r_imag(&s), dabs(r__2))) * ((
        r__3 = v[i__2].r, dabs(r__3)) + (r__4 = r_imag(&v[*ns *
        v_dim1 + 1]), dabs(r__4))) <= dmax(r__5,r__6)) {  // 进行条件判断

/*           ==== One more converged eigenvalue ==== */

        --(*ns);  // 减少 *ns
    } else {

/*
             ==== One undeflatable eigenvalue.  Move it up out of the
             .    way.   (CTREXC can not fail in this case.) ====
*/

        ifst = *ns;  // 设置 ifst 等于 *ns
        ctrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &
            ilst, &info);  // 调用 ctrexc 函数
        ++ilst;  // 增加 ilst
    }
/* L10: */
    }

/*        ==== Return to Hessenberg form ==== */

    if (*ns == 0) {  // 如果 *ns 等于 0
    s.r = 0.f, s.i = 0.f;  // 则设置 s 的实部和虚部为 0
    }

    if (*ns < jw) {

/*
          ==== sorting the diagonal of T improves accuracy for
          .    graded matrices.  ====
*/

    i__1 = *ns;  // 设置循环的上限
    for (i__ = infqr + 1; i__ <= i__1; ++i__) {
        ifst = i__;  // 设置 ifst 等于 i
        i__2 = *ns;  // 设置循环的上限
        for (j = i__ + 1; j <= i__2; ++j) {
        i__3 = j + j * t_dim1;  // 计算索引位置
        i__4 = ifst + ifst * t_dim1;  // 计算索引位置
        if ((r__1 = t[i__3].r, dabs(r__1)) + (r__2 = r_imag(&t[j + j *
             t_dim1]), dabs(r__2)) > (r__3 = t[i__4].r, dabs(r__3)
            ) + (r__4 = r_imag(&t[ifst + ifst * t_dim1]), dabs(
            r__4))) {  // 进行条件判断
            ifst = j;  // 更新 ifst
        }
/* L20: */
        }
        ilst = i__;  // 设置 ilst 等于 i
        if (ifst != ilst) {
        ctrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
             &ilst, &info);  // 调用 ctrexc 函数
        }
/* L30: */
    }
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__1 = jw;  // 设置循环的上限
    for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    i__2 = kwtop + i__ - 1;  // 计算索引位置
    i__3 = i__ + i__ * t_dim1;  // 计算索引位置
    sh[i__2].r = t[i__3].r, sh[i__2].i = t[i__3].i;  // 复制 t 的值到 sh
/* L40: */
    }


    if (*ns < jw || s.r == 0.f && s.i == 0.f) {  // 如果 *ns 小于 jw 或者 s 的实部和虚部都为 0
    if (*ns > 1 && (s.r != 0.f || s.i != 0.f)) {

/*           ==== Reflect spike back into lower triangle ==== */

        ccopy_(ns, &v[v_offset], ldv, &work[1], &c__1);  // 复制 v 到 work
        i__1 = *ns;  // 设置循环的上限
        for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;  // 设置索引
        r_cnjg(&q__1, &work[i__]);  // 对 work 中的元素求共轭
        work[i__2].r = q__1.r, work[i__2].i = q__1.i;  // 复制共轭值到 work
        }
        # Store the real part of work[1] in beta.r and imaginary part in beta.i
        beta.r = work[1].r, beta.i = work[1].i;
        # Compute the elementary reflector to reduce the jw-th column of t
        clarfg_(ns, &beta, &work[2], &c__1, &tau);
        # Set work[1] to [1, 0] to prepare for subsequent operations
        work[1].r = 1.f, work[1].i = 0.f;

        # Initialize elements of the trailing submatrix to zero
        i__1 = jw - 2;
        i__2 = jw - 2;
        claset_("L", &i__1, &i__2, &c_b56, &c_b56, &t[t_dim1 + 3], ldt);

        # Apply the elementary reflector to update the trailing submatrix
        r_cnjg(&q__1, &tau);
        clarf_("L", ns, &jw, &work[1], &c__1, &q__1, &t[t_offset], ldt, &
            work[jw + 1]);
        clarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        clarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        # Reduce the first jw columns of t to upper Hessenberg form
        i__1 = *lwork - jw;
        cgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== Copy updated reduced window into place ==== */

    if (kwtop > 1) {
        # Update the (kwtop, kwtop) element of H using s and v
        i__1 = kwtop + (kwtop - 1) * h_dim1;
        r_cnjg(&q__2, &v[v_dim1 + 1]);
        q__1.r = s.r * q__2.r - s.i * q__2.i, q__1.i = s.r * q__2.i + s.i
            * q__2.r;
        h__[i__1].r = q__1.r, h__[i__1].i = q__1.i;
    }
    # Copy the upper triangular part of t to the appropriate place in h
    clacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    # Copy the strictly upper triangular part of t to h
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    ccopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    if (*ns > 1 && (s.r != 0.f || s.i != 0.f)) {
        # Accumulate orthogonal matrix in v to update h and z
        i__1 = *lwork - jw;
        cunmhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== Update vertical slab in H ==== */

    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    # Update the vertical slab of h
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
        # Determine the size of the current vertical slab to update
        /* Computing MIN */
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
        # Perform matrix-matrix multiplication to update h
        cgemm_("N", "N", &kln, &jw, &jw, &c_b57, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b56, &wv[wv_offset],
            ldwv);
        # Copy the result back to h
        clacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L60: */
    }

/*        ==== Update horizontal slab in H ==== */

    if (*wantt) {
        i__2 = *n;
        i__1 = *nh;
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
            /* Computing MIN */
            i__3 = *nh, i__4 = *n - kcol + 1;
            kln = min(i__3,i__4);
            # Perform matrix-matrix multiplication to update h
            cgemm_("C", "N", &jw, &kln, &jw, &c_b57, &v[v_offset], ldv, &
                h__[kwtop + kcol * h_dim1], ldh, &c_b56, &t[t_offset],
                 ldt);
            # Copy the result back to h
            clacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
                 h_dim1], ldh);
/* L70: */
        }
    }

/*        ==== Update vertical slab in Z ==== */
    # 如果 `wantz` 指向的值为真（非零），则进入条件判断
    if (*wantz) {
        # 设置循环变量的初始值为 `iloz`，结束条件为 `ihiz`，步长为 `nv`
        i__1 = *ihiz;
        i__2 = *nv;
        for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
             i__2) {
/* Computing MIN */
/* 计算最小值 */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
/* 设置 kln 为 nv 和 ihiz - krow + 1 中的较小值 */
        kln = min(i__3,i__4);
/* 执行矩阵乘法：z__[krow + kwtop * z_dim1] 和 v[v_offset] 的乘积结果存储在 wv[wv_offset] 中 */
        cgemm_("N", "N", &kln, &jw, &jw, &c_b57, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b56, &wv[
            wv_offset], ldwv);
/* 复制矩阵 wv[wv_offset] 到 z__[krow + kwtop * z_dim1] */
        clacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
/* L80: */
/* 标记位置 L80 */
        }
    }
    }

/*     ==== Return the number of deflations ... ==== */
/* 返回缩小窗口中的值的个数 */

    *nd = jw - *ns;

/*
       ==== ... and the number of shifts. (Subtracting
       .    INFQR from the spike length takes care
       .    of the case of a rare QR failure while
       .    calculating eigenvalues of the deflation
       .    window.)  ====
*/
/*
       返回移位的数量。减去 INFQR 从尖峰长度中取得，
       这样可以处理在计算缩小窗口的特征值时罕见的 QR 失败情况。
*/

    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */
/* 返回最优工作空间 */

    r__1 = (real) lwkopt;
/* 将最优工作空间大小转换为实数 */
    q__1.r = r__1, q__1.i = 0.f;
/* 将结果存储在 work[1] 中 */
    work[1].r = q__1.r, work[1].i = q__1.i;

/*     ==== End of CLAQR2 ==== */
/* CLAQR2 结束 */

    return 0;
} /* claqr2_ */

/* Subroutine */ int claqr3_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, singlecomplex *h__, integer *ldh,
     integer *iloz, integer *ihiz, singlecomplex *z__, integer *ldz, integer *
    ns, integer *nd, singlecomplex *sh, singlecomplex *v, integer *ldv, integer *nh,
    singlecomplex *t, integer *ldt, integer *nv, singlecomplex *wv, integer *ldwv,
    singlecomplex *work, integer *lwork)
{
    /* System generated locals */
/* 系统生成的本地变量 */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    real r__1, r__2, r__3, r__4, r__5, r__6;
    singlecomplex q__1, q__2;

    /* Local variables */
/* 本地变量 */
    static integer i__, j;
    static singlecomplex s;
    static integer jw;
    static real foo;
    static integer kln;
    static singlecomplex tau;
    static integer knt;
    static real ulp;
    static integer lwk1, lwk2, lwk3;
    static singlecomplex beta;
    static integer kcol, info, nmin, ifst, ilst, ltop, krow;
    extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
        , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
        cgemm_(char *, char *, integer *, integer *, integer *, singlecomplex *,
         singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *,
         integer *), ccopy_(integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
/* 外部子程序声明 */
    static integer infqr, kwtop;
    extern /* Subroutine */ int claqr4_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, integer *),
         slabad_(real *, real *), cgehrd_(integer *, integer *, integer *,
         singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer *)
        , clarfg_(integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
/* 外部子程序声明 */
    # 载入外部函数 slamch_
    extern doublereal slamch_(char *);
    # 载入外部子程序 clahqr_, clacpy_, claset_
    extern /* Subroutine */ int clahqr_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, integer *);
    static real safmin;  # 静态变量，用于存储安全最小值
    # 载入外部函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static real safmax;  # 静态变量，用于存储安全最大值
    # 载入外部子程序 ctrexc_, cunmhr_
    extern /* Subroutine */ int ctrexc_(char *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *, integer *, integer *, integer *),
         cunmhr_(char *, char *, integer *, integer *, integer *, integer
        *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex
        *, integer *, integer *);
    static real smlnum;  # 静态变量，用于存储小数值
    static integer lwkopt;  # 静态整数变量，用于存储最佳工作空间大小
/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

    /* Parameter adjustments */
    // 设置矩阵 h__ 的维度参数
    h_dim1 = *ldh;
    // 计算 h__ 的偏移量
    h_offset = 1 + h_dim1;
    // 移动 h__ 到正确的起始位置
    h__ -= h_offset;
    // 设置矩阵 z__ 的维度参数
    z_dim1 = *ldz;
    // 计算 z__ 的偏移量
    z_offset = 1 + z_dim1;
    // 移动 z__ 到正确的起始位置
    z__ -= z_offset;
    // 调整 sh 数组的起始位置
    --sh;
    // 设置矩阵 v 的维度参数
    v_dim1 = *ldv;
    // 计算 v 的偏移量
    v_offset = 1 + v_dim1;
    // 移动 v 到正确的起始位置
    v -= v_offset;
    // 设置矩阵 t 的维度参数
    t_dim1 = *ldt;
    // 计算 t 的偏移量
    t_offset = 1 + t_dim1;
    // 移动 t 到正确的起始位置
    t -= t_offset;
    // 设置矩阵 wv 的维度参数
    wv_dim1 = *ldwv;
    // 计算 wv 的偏移量
    wv_offset = 1 + wv_dim1;
    // 移动 wv 到正确的起始位置
    wv -= wv_offset;
    // 调整 work 数组的起始位置
    --work;

    /* Function Body */
/* Computing MIN */
    // 计算 jw 的值，取 *nw 和 *kbot - *ktop + 1 中较小的一个
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    // 如果 jw 小于等于 2，则设置 lwkopt 为 1
    if (jw <= 2) {
        lwkopt = 1;
    } else {

/*        ==== Workspace query call to CGEHRD ==== */

    // 进行 CGEHRD 的工作空间查询调用
    i__1 = jw - 1;
    cgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
        c_n1, &info);
    // 获取查询到的工作空间大小
    lwk1 = (integer) work[1].r;

/*        ==== Workspace query call to CUNMHR ==== */

    // 进行 CUNMHR 的工作空间查询调用
    i__1 = jw - 1;
    cunmhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
         &v[v_offset], ldv, &work[1], &c_n1, &info);
    // 获取查询到的工作空间大小
    lwk2 = (integer) work[1].r;

/*        ==== Workspace query call to CLAQR4 ==== */

    // 进行 CLAQR4 的工作空间查询调用
    claqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[1],
        &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &infqr);
    // 获取查询到的工作空间大小
    lwk3 = (integer) work[1].r;

/*
          ==== Optimal workspace ====

   Computing MAX
*/
    // 计算 lwkopt 的最优值
    i__1 = jw + max(lwk1,lwk2);
    lwkopt = max(i__1,lwk3);
    }

/*     ==== Quick return in case of workspace query. ==== */

    // 如果 *lwork 为 -1，表示工作空间查询模式，立即返回查询到的最优工作空间大小
    if (*lwork == -1) {
    r__1 = (real) lwkopt;
    q__1.r = r__1, q__1.i = 0.f;
    work[1].r = q__1.r, work[1].i = q__1.i;
    return 0;
    }

/*
       ==== Nothing to do ...
       ... for an empty active block ... ====
*/
    // 如果 *ktop 大于 *kbot，表示活动块为空，设置 *ns 和 *nd 为 0，然后返回
    *ns = 0;
    *nd = 0;
    work[1].r = 1.f, work[1].i = 0.f;
    if (*ktop > *kbot) {
    return 0;
    }
/*     ... nor for an empty deflation window. ==== */
    // 如果 *nw 小于 1，表示要缩小窗口为空，直接返回
    if (*nw < 1) {
    return 0;
    }

/*     ==== Machine constants ==== */

    // 获取机器常数 safmin 和 safmax
    safmin = slamch_("SAFE MINIMUM");
    safmax = 1.f / safmin;
    // 初始化 safmin 和 safmax
    slabad_(&safmin, &safmax);
    // 获取单位舍入误差 ulp
    ulp = slamch_("PRECISION");
    // 计算 smlnum
    smlnum = safmin * ((real) (*n) / ulp);

/*
       ==== Setup deflation window ====

   Computing MIN
*/
    // 计算 jw 的值，取 *nw 和 *kbot - *ktop + 1 中较小的一个
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = min(i__1,i__2);
    // 计算 kwtop
    kwtop = *kbot - jw + 1;
    // 如果 kwtop 等于 *ktop，则 s 初始化为 0
    if (kwtop == *ktop) {
    s.r = 0.f, s.i = 0.f;
    } else {
    // 否则，获取 h__ 的值并赋给 s
    i__1 = kwtop + (kwtop - 1) * h_dim1;
    s.r = h__[i__1].r, s.i = h__[i__1].i;
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

    // 对于 1×1 的缩小窗口，不需要做太多操作
    i__1 = kwtop;
    i__2 = kwtop + kwtop * h_dim1;
    sh[i__1].r = h__[i__2].r, sh[i__1].i = h__[i__2].i;
    // 设置 *ns 为 1，*nd 为 0
    *ns = 1;
    *nd = 0;
/* Computing MAX */
    // 计算 rmax
    i__1 = kwtop + kwtop * h_dim1;
    r__5 = smlnum, r__6 = ulp * ((r__1 = h__[i__1].r, dabs(r__1)) + (r__2
        = r_imag(&h__[kwtop + kwtop * h_dim1]), dabs(r__2)));
    # 检查条件，判断复数 s 的实部与虚部的绝对值之和是否小于或等于给定的阈值 dmax(r__5, r__6)
    if ((r__3 = s.r, dabs(r__3)) + (r__4 = r_imag(&s), dabs(r__4)) <=
        dmax(r__5, r__6)) {
        
        # 如果条件满足，设置 ns 为 0，nd 为 1
        *ns = 0;
        *nd = 1;
        
        # 如果 kwtop 大于 ktop，则执行以下代码块
        if (kwtop > *ktop) {
            # 计算 h__ 中的索引位置 i__1
            i__1 = kwtop + (kwtop - 1) * h_dim1;
            # 将 h__[i__1] 的实部和虚部都设为 0
            h__[i__1].r = 0.f, h__[i__1].i = 0.f;
        }
    }
    
    # 将 work 数组中第一个元素设为复数值 1+0i
    work[1].r = 1.f, work[1].i = 0.f;
    
    # 返回值 0，表示函数执行成功
    return 0;
}
/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/
clacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
    ldt);
// 复制上三角部分到矩阵T
i__1 = jw - 1;
i__2 = *ldh + 1;
i__3 = *ldt + 1;
ccopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
    i__3);
// 复制剩余部分到矩阵T

claset_("A", &jw, &jw, &c_b56, &c_b57, &v[v_offset], ldv);
// 初始化V为单位矩阵
nmin = ilaenv_(&c__12, "CLAQR3", "SV", &jw, &c__1, &jw, lwork, (ftnlen)6,
    (ftnlen)2);
// 确定调用CLAQR4或CLAHQR的最小维度

if (jw > nmin) {
    claqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[
        kwtop], &c__1, &jw, &v[v_offset], ldv, &work[1], lwork, &
        infqr);
} else {
    clahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[
        kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
}
// 调用QR迭代过程

/*     ==== Deflation detection loop ==== */
*ns = jw;
ilst = infqr + 1;
i__1 = jw;
for (knt = infqr + 1; knt <= i__1; ++knt) {

/*        ==== Small spike tip deflation test ==== */
i__2 = *ns + *ns * t_dim1;
foo = (r__1 = t[i__2].r, dabs(r__1)) + (r__2 = r_imag(&t[*ns + *ns *
    t_dim1]), dabs(r__2));
if (foo == 0.f) {
    foo = (r__1 = s.r, dabs(r__1)) + (r__2 = r_imag(&s), dabs(r__2));
}
i__2 = *ns * v_dim1 + 1;
/* Computing MAX */
r__5 = smlnum, r__6 = ulp * foo;
if (((r__1 = s.r, dabs(r__1)) + (r__2 = r_imag(&s), dabs(r__2))) * ((
    r__3 = v[i__2].r, dabs(r__3)) + (r__4 = r_imag(&v[*ns *
    v_dim1 + 1]), dabs(r__4))) <= dmax(r__5,r__6)) {

/*           ==== One more converged eigenvalue ==== */
    --(*ns);
} else {

/*
             ==== One undeflatable eigenvalue.  Move it up out of the
             .    way.   (CTREXC can not fail in this case.) ====
*/
    ifst = *ns;
    ctrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &
        ilst, &info);
    ++ilst;
}
/* L10: */
}

/*        ==== Return to Hessenberg form ==== */
if (*ns == 0) {
s.r = 0.f, s.i = 0.f;
}

if (*ns < jw) {

/*
          ==== sorting the diagonal of T improves accuracy for
          .    graded matrices.  ====
*/
i__1 = *ns;
for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    ifst = i__;
    i__2 = *ns;
    for (j = i__ + 1; j <= i__2; ++j) {
    i__3 = j + j * t_dim1;
    i__4 = ifst + ifst * t_dim1;
    if ((r__1 = t[i__3].r, dabs(r__1)) + (r__2 = r_imag(&t[j + j *
         t_dim1]), dabs(r__2)) > (r__3 = t[i__4].r, dabs(r__3)
        ) + (r__4 = r_imag(&t[ifst + ifst * t_dim1]), dabs(
        r__4))) {
        ifst = j;
    }
/* L20: 结束if块 */
        }
        ilst = i__;  /* 更新ilst为当前循环变量i的值 */
        if (ifst != ilst) {  /* 如果ifst不等于ilst，则需要执行交换操作 */
        ctrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
             &ilst, &info);
        }
/* L30: 结束for循环 */
    }
    }

/*     ==== 从T中恢复移位/特征值数组 ==== */

    i__1 = jw;
    for (i__ = infqr + 1; i__ <= i__1; ++i__) {
    i__2 = kwtop + i__ - 1;
    i__3 = i__ + i__ * t_dim1;
    sh[i__2].r = t[i__3].r, sh[i__2].i = t[i__3].i;
/* L40: 结束for循环 */
    }


    if (*ns < jw || s.r == 0.f && s.i == 0.f) {
    if (*ns > 1 && (s.r != 0.f || s.i != 0.f)) {

/*           ==== 将尖峰反射回下三角形 ==== */

        ccopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        i__1 = *ns;
        for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__;
        r_cnjg(&q__1, &work[i__]);
        work[i__2].r = q__1.r, work[i__2].i = q__1.i;
/* L50: 结束for循环 */
        }
        beta.r = work[1].r, beta.i = work[1].i;
        clarfg_(ns, &beta, &work[2], &c__1, &tau);
        work[1].r = 1.f, work[1].i = 0.f;

        i__1 = jw - 2;
        i__2 = jw - 2;
        claset_("L", &i__1, &i__2, &c_b56, &c_b56, &t[t_dim1 + 3], ldt);

        r_cnjg(&q__1, &tau);
        clarf_("L", ns, &jw, &work[1], &c__1, &q__1, &t[t_offset], ldt, &
            work[jw + 1]);
        clarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        clarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        i__1 = *lwork - jw;
        cgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== 将更新的缩小窗口复制到指定位置 ==== */

    if (kwtop > 1) {
        i__1 = kwtop + (kwtop - 1) * h_dim1;
        r_cnjg(&q__2, &v[v_dim1 + 1]);
        q__1.r = s.r * q__2.r - s.i * q__2.i, q__1.i = s.r * q__2.i + s.i
            * q__2.r;
        h__[i__1].r = q__1.r, h__[i__1].i = q__1.i;
    }
    clacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    ccopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== 累积正交矩阵，以便更新H和Z，如果请求的话。 ====
*/

    if (*ns > 1 && (s.r != 0.f || s.i != 0.f)) {
        i__1 = *lwork - jw;
        cunmhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== 更新H中的垂直块 ==== */

    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    i__1 = kwtop - 1;
    i__2 = *nv;
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
/* 结束for循环 */
/* Computing MIN */
/* 计算两个值的最小值，用于确定 kln 的大小 */
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
/* 调用 BLAS 库中的矩阵乘法函数 cgemm_，执行矩阵乘法操作 */
        cgemm_("N", "N", &kln, &jw, &jw, &c_b57, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b56, &wv[wv_offset],
            ldwv);
/* 复制矩阵函数 clacpy_，将结果复制到 H__ 数组中 */
        clacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L60: */
    }

/*        ==== Update horizontal slab in H ==== */

    if (*wantt) {
/* 循环更新 H 中的水平分片 */
        i__2 = *n;
        i__1 = *nh;
        for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
            kcol += i__1) {
/* Computing MIN */
        i__3 = *nh, i__4 = *n - kcol + 1;
        kln = min(i__3,i__4);
/* 调用 BLAS 库中的矩阵乘法函数 cgemm_，执行矩阵乘法操作 */
        cgemm_("C", "N", &jw, &kln, &jw, &c_b57, &v[v_offset], ldv, &
            h__[kwtop + kcol * h_dim1], ldh, &c_b56, &t[t_offset],
             ldt);
/* 复制矩阵函数 clacpy_，将结果复制到 H__ 数组中 */
        clacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
             h_dim1], ldh);
/* L70: */
        }
    }

/*        ==== Update vertical slab in Z ==== */

    if (*wantz) {
/* 循环更新 Z 中的垂直分片 */
        i__1 = *ihiz;
        i__2 = *nv;
        for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
             i__2) {
/* Computing MIN */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
        kln = min(i__3,i__4);
/* 调用 BLAS 库中的矩阵乘法函数 cgemm_，执行矩阵乘法操作 */
        cgemm_("N", "N", &kln, &jw, &jw, &c_b57, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b56, &wv[
            wv_offset], ldwv);
/* 复制矩阵函数 clacpy_，将结果复制到 Z__ 数组中 */
        clacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
/* L80: */
        }
    }
    }

/*     ==== Return the number of deflations ... ==== */

/* 返回累计的 deflations 数量 */
    *nd = jw - *ns;

/*
       ==== ... and the number of shifts. (Subtracting
       .    INFQR from the spike length takes care
       .    of the case of a rare QR failure while
       .    calculating eigenvalues of the deflation
       .    window.)  ====
*/

/* 返回累计的 shifts 数量，并减去 INFQR 的值 */
    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */

/* 返回优化的工作空间大小 */
    r__1 = (real) lwkopt;
    q__1.r = r__1, q__1.i = 0.f;
    work[1].r = q__1.r, work[1].i = q__1.i;

/*     ==== End of CLAQR3 ==== */

/* CLAQR3 子程序结束 */
    return 0;
} /* claqr3_ */

/* Subroutine */ int claqr4_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, singlecomplex *h__, integer *ldh, singlecomplex *w,
    integer *iloz, integer *ihiz, singlecomplex *z__, integer *ldz, singlecomplex *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    real r__1, r__2, r__3, r__4, r__5, r__6, r__7, r__8;
    singlecomplex q__1, q__2, q__3, q__4, q__5;

    /* Local variables */
    static integer i__, k;
    static real s;
    static singlecomplex aa, bb, cc, dd;
    static integer ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
    static singlecomplex tr2, det;
    static integer inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot,
        nmin;
    static singlecomplex swap;
    static integer ktop;


这样做可以帮助理解每行代码的具体功能和作用。
    ! 声明一个静态的复数数组 zdum，包含一个元素
    static singlecomplex zdum[1]    /* was [1][1] */;
    ! 声明静态整型变量 kacc22, itmax, nsmax, nwmax, kwtop
    static integer kacc22, itmax, nsmax, nwmax, kwtop;
    ! 外部子程序声明：claqr2, claqr5, clahqr, clacpy, ilaenv
    extern /* Subroutine */ int claqr2_(logical *, logical *, integer *,
        integer *, integer *, integer *, singlecomplex *, integer *, integer *,
        integer *, singlecomplex *, integer *, integer *, integer *, singlecomplex *,
        singlecomplex *, integer *, integer *, singlecomplex *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *);
    extern /* Subroutine */ int claqr5_(logical *,
        logical *, integer *, integer *, integer *, integer *, integer *,
        singlecomplex *, singlecomplex *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, integer *,
        singlecomplex *, integer *, integer *, singlecomplex *, integer *);
    extern /* Subroutine */ int clahqr_(logical *, logical *, integer *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        integer *, singlecomplex *, integer *, integer *);
    extern /* Subroutine */ int clacpy_(char *,
        integer *, integer *, singlecomplex *, integer *, singlecomplex *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 声明静态字符数组 jbcmpz，包含两个字符
    static char jbcmpz[2];
    ! 声明静态的单精度复数变量 rtdisc
    static singlecomplex rtdisc;
    ! 声明静态整型变量 nwupbd, lwkopt
    static integer nwupbd;
    static integer lwkopt;
    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --w;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;

    /* ==== Quick return for N = 0: nothing to do. ==== */
    if (*n == 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    if (*n <= 11) {
        /* ==== Tiny matrices must use CLAHQR. ==== */
        lwkopt = 1;
        if (*lwork != -1) {
            clahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &w[1],
                    iloz, ihiz, &z__[z_offset], ldz, info);
        }
    } else {
        /* ==== Use small bulge multi-shift QR with aggressive early
               deflation on larger-than-tiny matrices. ====

           ==== Hope for the best. ==== */
        *info = 0;

        /* ==== Set up job flags for ILAENV. ==== */
        if (*wantt) {
            *(unsigned char *)jbcmpz = 'S';
        } else {
            *(unsigned char *)jbcmpz = 'E';
        }
        if (*wantz) {
            *(unsigned char *)&jbcmpz[1] = 'V';
        } else {
            *(unsigned char *)&jbcmpz[1] = 'N';
        }

        /* ==== NWR = recommended deflation window size.  At this
               point,  N .GT. NTINY = 11, so there is enough
               subdiagonal workspace for NWR.GE.2 as required.
               (In fact, there is enough subdiagonal space for
               NWR.GE.3.) ==== */
        nwr = ilaenv_(&c__13, "CLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
                      (ftnlen)2);
        nwr = max(2,nwr);
        /* Computing MIN */
        i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
        nwr = min(i__1,nwr);

        /* ==== NSR = recommended number of simultaneous shifts.
               At this point N .GT. NTINY = 11, so there is at
               enough subdiagonal workspace for NSR to be even
               and greater than or equal to two as required. ==== */
        nsr = ilaenv_(&c__15, "CLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
                      (ftnlen)2);
        /* Computing MIN */
        i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
            *ilo;
        nsr = min(i__1,i__2);
        /* Computing MAX */
        i__1 = 2, i__2 = nsr - nsr % 2;
        nsr = max(i__1,i__2);

        /* ==== Estimate optimal workspace ==== */

        i__1 = nwr + 1;
        claqr2_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
                ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[h_offset],
                ldh, n, &h__[h_offset], ldh, n, &h__[h_offset], ldh, &work[1],
                &c_n1);

        /* ==== Optimal workspace = MAX(CLAQR5, CLAQR2) ====

           Computing MAX */
        i__1 = nsr * 3 / 2, i__2 = (integer) work[1].r;
        lwkopt = max(i__1,i__2);

        /* ==== Quick return in case of workspace query. ==== */
        if (*lwork == -1) {
            r__1 = (real) lwkopt;
            q__1.r = r__1, q__1.i = 0.f;
            work[1].r = q__1.r, work[1].i = q__1.i;
            return 0;
        }
    }
/*        ==== CLAHQR/CLAQR0 crossover point ==== */

/* 计算 CLAHQR/CLAQR0 方法中的切换点，用于确定最小的处理规模 */
nmin = ilaenv_(&c__12, "CLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
    6, (ftnlen)2);
nmin = max(11,nmin);

/*        ==== Nibble crossover point ==== */

/* 计算用于矩阵小块操作的切换点 */
nibble = ilaenv_(&c__14, "CLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
nibble = max(0,nibble);

/*
      ==== Accumulate reflections during ttswp?  Use block
      .    2-by-2 structure during matrix-matrix multiply? ====
*/

/* 决定是否在 TTSWP 过程中累积反射变换，以及是否在矩阵乘法中使用2×2的块结构 */
kacc22 = ilaenv_(&c__16, "CLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
kacc22 = max(0,kacc22);
kacc22 = min(2,kacc22);

/*
      ==== NWMAX = the largest possible deflation window for
      .    which there is sufficient workspace. ====

   Computing MIN
*/

/* 计算可以进行缩小处理的最大窗口大小，取决于可用的工作空间 */
i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
nwmax = min(i__1,i__2);
nw = nwmax;

/*
      ==== NSMAX = the Largest number of simultaneous shifts
      .    for which there is sufficient workspace. ====

   Computing MIN
*/

/* 计算可以同时进行的最大平移数量，取决于可用的工作空间 */
i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
nsmax = min(i__1,i__2);
nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

/* 迭代计数，从缩小处理重新开始 */
ndfl = 1;

/*
      ==== ITMAX = iteration limit ====

   Computing MAX
*/

/* 计算迭代的上限 */
i__1 = 10, i__2 = *ihi - *ilo + 1;
itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

/* 活动块中的最后行和列 */
kbot = *ihi;

/*        ==== Main Loop ==== */

/* 主循环 */
i__1 = itmax;
for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

/* 当 KBOT 小于 ILO 时结束 */
if (kbot < *ilo) {
    goto L80;
}

/*           ==== Locate active block ==== */

/* 定位活动块 */
i__2 = *ilo + 1;
for (k = kbot; k >= i__2; --k) {
    i__3 = k + (k - 1) * h_dim1;
    if (h__[i__3].r == 0.f && h__[i__3].i == 0.f) {
        goto L20;
    }
    /* L10: */
}
k = *ilo;
L20:
ktop = k;

/*
     ==== Select deflation window size:
     .    Typical Case:
     .      If possible and advisable, nibble the entire
     .      active block.  If not, use size MIN(NWR,NWMAX)
     .      or MIN(NWR+1,NWMAX) depending upon which has
     .      the smaller corresponding subdiagonal entry
     .      (a heuristic).
     .
     .    Exceptional Case:
     .      If there have been no deflations in KEXNW or
     .      more iterations, then vary the deflation window
     .      size.   At first, because, larger windows are,
     .      in general, more powerful than smaller ones,
     .      rapidly increase the window to the maximum possible.
     .      Then, gradually reduce the window size. ====
*/

/* 选择缩小处理窗口的大小 */
nh = kbot - ktop + 1;
nwupbd = min(nh,nwmax);
if (ndfl < 5) {
    nw = min(nwupbd,nwr);
} else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        }
/* 将nw限制在nwupbd和2倍nw中的较小值 */
        if (nw < nwmax) {
/* 如果nw小于nwmax */
        if (nw >= nh - 1) {
/* 如果nw大于等于nh-1 */
            nw = nh;
/* 则将nw设为nh */
        } else {
/* 否则 */
            kwtop = kbot - nw + 1;
/* 计算kwtop */
            i__2 = kwtop + (kwtop - 1) * h_dim1;
            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
/* 计算h__[kwtop][kwtop-1]和h__[kwtop-1][kwtop-2]的绝对值之和 */
            if ((r__1 = h__[i__2].r, dabs(r__1)) + (r__2 = r_imag(&
                h__[kwtop + (kwtop - 1) * h_dim1]), dabs(r__2)) >
                (r__3 = h__[i__3].r, dabs(r__3)) + (r__4 = r_imag(
                &h__[kwtop - 1 + (kwtop - 2) * h_dim1]), dabs(
                r__4))) {
/* 如果绝对值之和大于 */
            ++nw;
/* 则增加nw */
            }
        }
        }
/* 如果ndfl小于5 */
        if (ndfl < 5) {
/* 则设置ndec为-1 */
        ndec = -1;
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 否则如果ndec大于等于0或者nw大于等于nwupbd */
        ++ndec;
/* 增加ndec */
        if (nw - ndec < 2) {
/* 如果nw减去ndec小于2 */
            ndec = 0;
/* 则将ndec设为0 */
        }
        nw -= ndec;
/* nw减去ndec */
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

        kv = *n - nw + 1;
/* 计算kv */
        kt = nw + 1;
/* 计算kt */
        nho = *n - nw - 1 - kt + 1;
/* 计算nho */
        kwv = nw + 2;
/* 计算kwv */
        nve = *n - nw - kwv + 1;
/* 计算nve */

/*           ==== Aggressive early deflation ==== */

        claqr2_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &w[1], &h__[kv
            + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], ldh, &nve, &
            h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

        ks = kbot - ls + 1;

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if CLAQR2
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
        ns = min(i__2,i__3);
/* 计算ns，确保ns是偶数 */
        ns -= ns % 2;
/* 如果ns不是偶数，将其调整为偶数 */
/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    CLAQR2 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
if (ndfl % 6 == 0) {
    // 计算起始索引 ks
    ks = kbot - ns + 1;
    // 从 ks 开始向前遍历，每次递减2
    for (i__ = kbot; i__ >= ks + 1; i__ += -2) {
        // 计算索引 i__
        i__3 = i__;
        // 计算 h[i__, i__] 的索引 i__4
        i__4 = i__ + i__ * h_dim1;
        // 计算 h[i__, i__-1] 的索引 i__5
        i__5 = i__ + (i__ - 1) * h_dim1;
        // 计算新的复数值，基于 h[i__, i__-1] 和 h[i__, i__]
        r__3 = ((r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
            r_imag(&h__[i__ + (i__ - 1) * h_dim1]), dabs(
            r__2))) * .75f;
        q__1.r = h__[i__4].r + r__3, q__1.i = h__[i__4].i;
        // 将计算结果存储在 w[i__] 中
        w[i__3].r = q__1.r, w[i__3].i = q__1.i;
        // 将 w[i__-1] 设置为 w[i__] 的值
        i__3 = i__ - 1;
        i__4 = i__;
        w[i__3].r = w[i__4].r, w[i__3].i = w[i__4].i;
        // 继续下一个迭代
        /* L30: */
    }
} else {

/*
                   ==== Got NS/2 or fewer shifts? Use CLAHQR
                   .    on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
*/

    // 如果 ks 到 kbot 之间的元素不足 NS/2 个，则执行以下操作
    if (kbot - ks + 1 <= ns / 2) {
        // 重新计算 ks 的值
        ks = kbot - ns + 1;
        // 计算 kt 的值
        kt = *n - ns + 1;
        // 复制主子矩阵到另一个位置
        clacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
            h__[kt + h_dim1], ldh);
        // 调用 CLAHQR 计算特征值
        clahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[kt
            + h_dim1], ldh, &w[ks], &c__1, &c__1, zdum, &
            c__1, &inf);
        // 更新 ks 的值
        ks += inf;

/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  Scale to avoid
                      .    overflows, underflows and subnormals.
                      .    (The scale factor S can not be zero,
                      .    because H(KBOT,KBOT-1) is nonzero.) ====
*/
            if (ks >= kbot) {
                // 计算用于双步 QR 算法的旋转因子
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                i__3 = kbot + (kbot - 1) * h_dim1;
                i__4 = kbot - 1 + kbot * h_dim1;
                i__5 = kbot + kbot * h_dim1;
                // 计算 s 的值，用于后续的数值计算
                s = (r__1 = h__[i__2].r, dabs(r__1)) + (r__2 =
                    r_imag(&h__[kbot - 1 + (kbot - 1) *
                    h_dim1]), dabs(r__2)) + ((r__3 = h__[i__3]
                    .r, dabs(r__3)) + (r__4 = r_imag(&h__[
                    kbot + (kbot - 1) * h_dim1]), dabs(r__4)))
                     + ((r__5 = h__[i__4].r, dabs(r__5)) + (
                    r__6 = r_imag(&h__[kbot - 1 + kbot *
                    h_dim1]), dabs(r__6))) + ((r__7 = h__[
                    i__5].r, dabs(r__7)) + (r__8 = r_imag(&
                    h__[kbot + kbot * h_dim1]), dabs(r__8)));
                // 计算旋转因子 aa
                i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                aa.r = q__1.r, aa.i = q__1.i;
                // 计算旋转因子 cc
                i__2 = kbot + (kbot - 1) * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                cc.r = q__1.r, cc.i = q__1.i;
                // 计算旋转因子 bb
                i__2 = kbot - 1 + kbot * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                bb.r = q__1.r, bb.i = q__1.i;
                // 计算旋转因子 dd
                i__2 = kbot + kbot * h_dim1;
                q__1.r = h__[i__2].r / s, q__1.i = h__[i__2].i /
                    s;
                dd.r = q__1.r, dd.i = q__1.i;
                // 计算 tr2，用于后续的数值计算
                q__2.r = aa.r + dd.r, q__2.i = aa.i + dd.i;
                q__1.r = q__2.r / 2.f, q__1.i = q__2.i / 2.f;
                tr2.r = q__1.r, tr2.i = q__1.i;
                q__3.r = aa.r - tr2.r, q__3.i = aa.i - tr2.i;
                q__4.r = dd.r - tr2.r, q__4.i = dd.i - tr2.i;
                q__2.r = q__3.r * q__4.r - q__3.i * q__4.i,
                    q__2.i = q__3.r * q__4.i + q__3.i *
                    q__4.r;
                q__5.r = bb.r * cc.r - bb.i * cc.i, q__5.i = bb.r
                    * cc.i + bb.i * cc.r;
                q__1.r = q__2.r - q__5.r, q__1.i = q__2.i -
                    q__5.i;
                // 计算行列式的值
                det.r = q__1.r, det.i = q__1.i;
                // 计算平方根的值，用于后续的数值计算
                q__2.r = -det.r, q__2.i = -det.i;
                c_sqrt(&q__1, &q__2);
                rtdisc.r = q__1.r, rtdisc.i = q__1.i;
                // 计算 w 数组中的值，用于后续的数值计算
                i__2 = kbot - 1;
                q__2.r = tr2.r + rtdisc.r, q__2.i = tr2.i +
                    rtdisc.i;
                q__1.r = s * q__2.r, q__1.i = s * q__2.i;
                w[i__2].r = q__1.r, w[i__2].i = q__1.i;
                i__2 = kbot;
                q__2.r = tr2.r - rtdisc.r, q__2.i = tr2.i -
                    rtdisc.i;
                q__1.r = s * q__2.r, q__1.i = s * q__2.i;
                w[i__2].r = q__1.r, w[i__2].i = q__1.i;

                // 更新 ks 的值
                ks = kbot - 1;
            }
/*
   ==== Sort the shifts (Helps a little) ====
*/

sorted = FALSE_;
i__2 = ks + 1;
for (k = kbot; k >= i__2; --k) {
    // Check if array is already sorted; if so, skip sorting
    if (sorted) {
        goto L60;
    }
    sorted = TRUE_;
    // Bubble sort the shifts in descending order of magnitude
    i__3 = k - 1;
    for (i__ = ks; i__ <= i__3; ++i__) {
        i__4 = i__;
        i__5 = i__ + 1;
        // Compare the magnitudes of complex numbers w[i__] and w[i__ + 1]
        if ((r__1 = w[i__4].r, dabs(r__1)) + (r__2 =
            r_imag(&w[i__]), dabs(r__2)) < (r__3 =
             w[i__5].r, dabs(r__3)) + (r__4 =
            r_imag(&w[i__ + 1]), dabs(r__4))) {
            // Swap elements if they are out of order
            sorted = FALSE_;
            i__4 = i__;
            swap.r = w[i__4].r, swap.i = w[i__4].i;
            i__4 = i__;
            i__5 = i__ + 1;
            w[i__4].r = w[i__5].r, w[i__4].i = w[i__5]
                .i;
            w[i__5].r = swap.r, w[i__5].i = swap.i;
        }
    }
}

L60: ;

/*
   ==== If there are only two shifts, then use only one. ====
*/

if (kbot - ks + 1 == 2) {
    // Compare magnitudes of two shifts and keep the smaller one
    i__2 = kbot;
    i__3 = kbot + kbot * h_dim1;
    q__2.r = w[i__2].r - h__[i__3].r, q__2.i = w[i__2].i -
        h__[i__3].i;
    q__1.r = q__2.r, q__1.i = q__2.i;
    i__4 = kbot - 1;
    i__5 = kbot + kbot * h_dim1;
    q__4.r = w[i__4].r - h__[i__5].r, q__4.i = w[i__4].i -
        h__[i__5].i;
    q__3.r = q__4.r, q__3.i = q__4.i;
    if ((r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&q__1),
        dabs(r__2)) < (r__3 = q__3.r, dabs(r__3)) + (r__4
        = r_imag(&q__3), dabs(r__4))) {
        i__2 = kbot - 1;
        i__3 = kbot;
        w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
    } else {
        i__2 = kbot;
        i__3 = kbot - 1;
        w[i__2].r = w[i__3].r, w[i__2].i = w[i__3].i;
    }
}

/*
   ==== Use up to NS of the smallest magnitude shifts. If there aren't NS shifts available,
   .    then use them all, possibly dropping one to make the number of shifts even. ====

   Computing MIN
*/

// Determine the number of shifts to use, ensuring an even count
i__2 = ns, i__3 = kbot - ks + 1;
ns = min(i__2,i__3);
ns -= ns % 2; // Make ns even
ks = kbot - ns + 1;
/*
   ==== Small-bulge multi-shift QR sweep:
   .    split workspace under the subdiagonal into
   .    - a KDU-by-KDU work array U in the lower
   .      left-hand-corner,
   .    - a KDU-by-at-least-KDU-but-more-is-better
   .      (KDU-by-NHo) horizontal work array WH along
   .      the bottom edge,
   .    - and an at-least-KDU-but-more-is-better-by-KDU
   .      (NVE-by-KDU) vertical work array WV along
   .      the left-hand-edge. ====
*/
/* 定义一些变量 */
kdu = ns * 3 - 3;  // 计算 KDU 大小
ku = *n - kdu + 1;  // 计算 ku 的值
kwh = kdu + 1;  // 计算 kwh 的值
nho = *n - kdu - 3 - (kdu + 1) + 1;  // 计算 nho 的值
kwv = kdu + 4;  // 计算 kwv 的值
nve = *n - kdu - kwv + 1;  // 计算 nve 的值

/* ==== Small-bulge multi-shift QR sweep ==== */
claqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks], &
    h__[h_offset], ldh, iloz, ihiz, &z__[z_offset], ldz, &
    work[1], &c__3, &h__[ku + h_dim1], ldh, &nve, &h__[
    kwv + h_dim1], ldh, &nho, &h__[ku + kwh * h_dim1],
    ldh);

/* ==== Note progress (or the lack of it). ==== */
if (ld > 0) {
    ndfl = 1;  // ld 大于 0 时的操作
} else {
    ++ndfl;  // ld 小于等于 0 时的操作
}

/*
   ==== End of main loop ====
   L70:
*/
}

/*
   ==== Iteration limit exceeded.  Set INFO to show where
   .    the problem occurred and exit. ====
*/
*info = kbot;
L80:
;

/* ==== Return the optimal value of LWORK. ==== */
r__1 = (real) lwkopt;
q__1.r = r__1, q__1.i = 0.f;
work[1].r = q__1.r, work[1].i = q__1.i;

/* ==== End of CLAQR4 ==== */
return 0;
} /* claqr4_ */

/* Subroutine */ int claqr5_(logical *wantt, logical *wantz, integer *kacc22,
    integer *n, integer *ktop, integer *kbot, integer *nshfts, singlecomplex *s,
    singlecomplex *h__, integer *ldh, integer *iloz, integer *ihiz, singlecomplex *
    z__, integer *ldz, singlecomplex *v, integer *ldv, singlecomplex *u, integer *ldu,
    integer *nv, singlecomplex *wv, integer *ldwv, integer *nh, singlecomplex *wh,
    integer *ldwh)
{
/* System generated locals */
integer h_dim1, h_offset, u_dim1, u_offset, v_dim1, v_offset, wh_dim1,
    wh_offset, wv_dim1, wv_offset, z_dim1, z_offset, i__1, i__2, i__3,
    i__4, i__5, i__6, i__7, i__8, i__9, i__10, i__11;
real r__1, r__2, r__3, r__4, r__5, r__6, r__7, r__8, r__9, r__10;
singlecomplex q__1, q__2, q__3, q__4, q__5, q__6, q__7, q__8;

/* Local variables */
static integer j, k, m, i2, j2, i4, j4, k1;
static real h11, h12, h21, h22;
static integer m22, ns, nu;
static singlecomplex vt[3];
static real scl;
static integer kdu, kms;
static real ulp;
static integer knz, kzs;
static real tst1, tst2;
static singlecomplex beta;
static logical blk22, bmp22;
static integer mend, jcol, jlen, jbot, mbot, jtop, jrow, mtop;
static singlecomplex alpha;
    # 声明静态逻辑变量 `accum`
    static logical accum;
    
    # 外部声明子程序 `cgemm_`，接受一些参数并返回一个整数值
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    
    # 声明静态整型变量 `ndcol`, `incol`, `krcol`, `nbmps`
    static integer ndcol, incol, krcol, nbmps;
    
    # 外部声明子程序 `ctrmm_`，接受一些参数并返回一个整数值
    extern /* Subroutine */ int ctrmm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *);
    
    # 外部声明子程序 `claqr1_`，接受一些参数并返回一个整数值
    extern /* Subroutine */ int claqr1_(integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, singlecomplex *);
    
    # 外部声明子程序 `slabad_`，接受两个实数参数并无返回值
    extern /* Subroutine */ int slabad_(
        real *, real *);
    
    # 外部声明子程序 `clarfg_`，接受一些参数并返回一个实数值
    extern /* Subroutine */ int clarfg_(integer *, singlecomplex *, singlecomplex *, integer
        *, singlecomplex *);
    
    # 外部声明函数 `slamch_`，接受一个字符参数并返回一个双精度实数值
    extern doublereal slamch_(char *);
    
    # 外部声明子程序 `clacpy_`，接受一些参数并无返回值
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex
        *, integer *, singlecomplex *, integer *);
    
    # 外部声明子程序 `claset_`，接受一些参数并无返回值
    extern /* Subroutine */ int claset_(char *,
        integer *, integer *, singlecomplex *, singlecomplex *, singlecomplex *, integer *);
    
    # 声明静态实数变量 `safmin`, `safmax`
    static real safmin, safmax;
    
    # 声明静态复数变量 `refsum`
    static singlecomplex refsum;
    
    # 声明静态整型变量 `mstart`
    static integer mstart;
    
    # 声明静态实数变量 `smlnum`
    static real smlnum;
    /* Parameter adjustments */
    --s;                            // 将数组 s 向前移动一个位置，使其从1开始索引
    h_dim1 = *ldh;                  // h_dim1 表示 h 的第一维大小
    h_offset = 1 + h_dim1;          // 计算偏移量，h__ 的起始位置
    h__ -= h_offset;                // 调整 h__ 的起始地址
    z_dim1 = *ldz;                  // z_dim1 表示 z 的第一维大小
    z_offset = 1 + z_dim1;          // 计算偏移量，z__ 的起始位置
    z__ -= z_offset;                // 调整 z__ 的起始地址
    v_dim1 = *ldv;                  // v_dim1 表示 v 的第一维大小
    v_offset = 1 + v_dim1;          // 计算偏移量，v 的起始位置
    v -= v_offset;                  // 调整 v 的起始地址
    u_dim1 = *ldu;                  // u_dim1 表示 u 的第一维大小
    u_offset = 1 + u_dim1;          // 计算偏移量，u 的起始位置
    u -= u_offset;                  // 调整 u 的起始地址
    wv_dim1 = *ldwv;                // wv_dim1 表示 wv 的第一维大小
    wv_offset = 1 + wv_dim1;        // 计算偏移量，wv 的起始位置
    wv -= wv_offset;                // 调整 wv 的起始地址
    wh_dim1 = *ldwh;                // wh_dim1 表示 wh 的第一维大小
    wh_offset = 1 + wh_dim1;        // 计算偏移量，wh 的起始位置
    wh -= wh_offset;                // 调整 wh 的起始地址

    /* Function Body */
    if (*nshfts < 2) {              // 如果 nshfts 小于 2，直接返回
        return 0;
    }

    /*
       ==== If the active block is empty or 1-by-1, then there
       .    is nothing to do. ====
    */
    if (*ktop >= *kbot) {           // 如果 active block 是空的或者只有一个元素，直接返回
        return 0;
    }

    /*
       ==== NSHFTS is supposed to be even, but if it is odd,
       .    then simply reduce it by one.  ====
    */
    ns = *nshfts - *nshfts % 2;     // 如果 nshfts 是奇数，减少它使其成为偶数

    /*     ==== Machine constants for deflation ==== */
    safmin = slamch_("SAFE MINIMUM");   // 获取安全最小值
    safmax = 1.f / safmin;              // 计算安全最大值
    slabad_(&safmin, &safmax);          // 设置机器常量 safmin 和 safmax
    ulp = slamch_("PRECISION");         // 获取机器精度
    smlnum = safmin * ((real) (*n) / ulp);  // 计算 smlnum

    /*
       ==== Use accumulated reflections to update far-from-diagonal
       .    entries ? ====
    */
    accum = *kacc22 == 1 || *kacc22 == 2;   // 根据 kacc22 决定是否使用积累的反射来更新远离对角线的条目

    /*     ==== If so, exploit the 2-by-2 block structure? ==== */
    blk22 = ns > 2 && *kacc22 == 2;         // 如果 ns 大于 2 且 kacc22 等于 2，则利用2×2块结构

    /*     ==== clear trash ==== */
    if (*ktop + 2 <= *kbot) {               // 如果 active block 至少包含两个元素
        i__1 = *ktop + 2 + *ktop * h_dim1;
        h__[i__1].r = 0.f, h__[i__1].i = 0.f;   // 清除垃圾数据
    }

    /*     ==== NBMPS = number of 2-shift bulges in the chain ==== */
    nbmps = ns / 2;                         // 计算在链中的 2-shift bulges 的数量

    /*     ==== KDU = width of slab ==== */
    kdu = nbmps * 6 - 3;                    // 计算 slab 的宽度

    /*     ==== Create and chase chains of NBMPS bulges ==== */
    i__1 = *kbot - 2;
    i__2 = nbmps * 3 - 2;
    for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 :
        incol <= i__1; incol += i__2) {
        ndcol = incol + kdu;

        if (accum) {
            claset_("ALL", &kdu, &kdu, &c_b56, &c_b57, &u[u_offset], ldu);
        }

        /*
              ==== Near-the-diagonal bulge chase.  The following loop
              .    performs the near-the-diagonal part of a small bulge
              .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
              .    chunk extends from column INCOL to column NDCOL
              .    (including both column INCOL and column NDCOL). The
              .    following loop chases a 3*NBMPS column long chain of
              .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
              .    may be less than KTOP and and NDCOL may be greater than
              .    KBOT indicating phantom columns from which to chase
              .    bulges before they are actually introduced or to which
              .    to chase bulges beyond column KBOT.)  ====

       Computing MIN
        */
        i__4 = incol + nbmps * 3 - 3, i__5 = *kbot - 2;
        i__3 = min(i__4,i__5);
        for (krcol = incol; krcol <= i__3; ++krcol) {
/*
             ==== Bulges number MTOP to MBOT are active double implicit
             .    shift bulges.  There may or may not also be small
             .    2-by-2 bulge, if there is room.  The inactive bulges
             .    (if any) must wait until the active bulges have moved
             .    down the diagonal to make room.  The phantom matrix
             .    paradigm described above helps keep track.  ====

   Computing MAX
*/
        // 计算 MTOP 的值，确保其不小于 1
        i__4 = 1, i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
        mtop = max(i__4,i__5);
/* Computing MIN */
        // 计算 MBOT 的值，确保其不超过 nbmps 和 (*kbot - krcol) / 3 的较小值
        i__4 = nbmps, i__5 = (*kbot - krcol) / 3;
        mbot = min(i__4,i__5);
        // 计算 m22 的值，即 mbot + 1
        m22 = mbot + 1;
        // 检查是否存在 2-by-2 bulge，并且其位置符合条件
        bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

/*
             ==== Generate reflections to chase the chain right
             .    one column.  (The minimum value of K is KTOP-1.) ====
*/
        // 生成反射以追赶右侧的链条，每次处理一列
        i__4 = mbot;
        for (m = mtop; m <= i__4; ++m) {
            k = krcol + (m - 1) * 3;
            if (k == *ktop - 1) {
                // 处理特殊情况：生成一个 Claqr1 反射序列
                claqr1_(&c__3, &h__[*ktop + *ktop * h_dim1], ldh, &s[(m <<
                     1) - 1], &s[m * 2], &v[m * v_dim1 + 1]);
                i__5 = m * v_dim1 + 1;
                alpha.r = v[i__5].r, alpha.i = v[i__5].i;
                // 生成一个 Clarfg 反射
                clarfg_(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m *
                    v_dim1 + 1]);
            } else {
                i__5 = k + 1 + k * h_dim1;
                beta.r = h__[i__5].r, beta.i = h__[i__5].i;
                i__5 = m * v_dim1 + 2;
                i__6 = k + 2 + k * h_dim1;
                v[i__5].r = h__[i__6].r, v[i__5].i = h__[i__6].i;
                i__5 = m * v_dim1 + 3;
                i__6 = k + 3 + k * h_dim1;
                v[i__5].r = h__[i__6].r, v[i__5].i = h__[i__6].i;
                // 生成一个 Clarfg 反射
                clarfg_(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m *
                    v_dim1 + 1]);

/*
                   ==== A Bulge may collapse because of vigilant
                   .    deflation or destructive underflow.  In the
                   .    underflow case, try the two-small-subdiagonals
                   .    trick to try to reinflate the bulge.  ====
*/
                // 检查是否发生 bulge 的崩溃，如果是，则尝试使用 two-small-subdiagonals 技巧来恢复 bulge
                i__5 = k + 3 + k * h_dim1;
                i__6 = k + 3 + (k + 1) * h_dim1;
                i__7 = k + 3 + (k + 2) * h_dim1;
                if (h__[i__5].r != 0.f || h__[i__5].i != 0.f || (h__[i__6]
                    .r != 0.f || h__[i__6].i != 0.f) || h__[i__7].r ==
                     0.f && h__[i__7].i == 0.f) {

/*                    ==== Typical case: not collapsed (yet). ==== */

                    // 普通情况：bulge 尚未崩溃，更新矩阵 h__ 的值
                    i__5 = k + 1 + k * h_dim1;
                    h__[i__5].r = beta.r, h__[i__5].i = beta.i;
                    i__5 = k + 2 + k * h_dim1;
                    h__[i__5].r = 0.f, h__[i__5].i = 0.f;
                    i__5 = k + 3 + k * h_dim1;
                    h__[i__5].r = 0.f, h__[i__5].i = 0.f;
                } else {
/*
                      ==== Atypical case: collapsed.  Attempt to
                      .    reintroduce ignoring H(K+1,K) and H(K+2,K).
                      .    If the fill resulting from the new
                      .    reflector is too large, then abandon it.
                      .    Otherwise, use the new one. ====
*/
claqr1_(&c__3, &h__[k + 1 + (k + 1) * h_dim1], ldh, &
    s[(m << 1) - 1], &s[m * 2], vt);
alpha.r = vt[0].r, alpha.i = vt[0].i;
clarfg_(&c__3, &alpha, &vt[1], &c__1, vt);
r_cnjg(&q__2, vt);
i__5 = k + 1 + k * h_dim1;
r_cnjg(&q__5, &vt[1]);
i__6 = k + 2 + k * h_dim1;
q__4.r = q__5.r * h__[i__6].r - q__5.i * h__[i__6].i,
    q__4.i = q__5.r * h__[i__6].i + q__5.i * h__[
    i__6].r;
q__3.r = h__[i__5].r + q__4.r, q__3.i = h__[i__5].i +
    q__4.i;
q__1.r = q__2.r * q__3.r - q__2.i * q__3.i, q__1.i =
    q__2.r * q__3.i + q__2.i * q__3.r;
refsum.r = q__1.r, refsum.i = q__1.i;

i__5 = k + 2 + k * h_dim1;
q__3.r = refsum.r * vt[1].r - refsum.i * vt[1].i,
    q__3.i = refsum.r * vt[1].i + refsum.i * vt[1]
    .r;
q__2.r = h__[i__5].r - q__3.r, q__2.i = h__[i__5].i -
    q__3.i;
q__1.r = q__2.r, q__1.i = q__2.i;
q__5.r = refsum.r * vt[2].r - refsum.i * vt[2].i,
    q__5.i = refsum.r * vt[2].i + refsum.i * vt[2]
    .r;
q__4.r = q__5.r, q__4.i = q__5.i;
i__6 = k + k * h_dim1;
i__7 = k + 1 + (k + 1) * h_dim1;
i__8 = k + 2 + (k + 2) * h_dim1;
if ((r__1 = q__1.r, dabs(r__1)) + (r__2 = r_imag(&
    q__1), dabs(r__2)) + ((r__3 = q__4.r, dabs(
    r__3)) + (r__4 = r_imag(&q__4), dabs(r__4)))
    > ulp * ((r__5 = h__[i__6].r, dabs(r__5)) + (
    r__6 = r_imag(&h__[k + k * h_dim1]), dabs(
    r__6)) + ((r__7 = h__[i__7].r, dabs(r__7)) + (
    r__8 = r_imag(&h__[k + 1 + (k + 1) * h_dim1]),
     dabs(r__8))) + ((r__9 = h__[i__8].r, dabs(
    r__9)) + (r__10 = r_imag(&h__[k + 2 + (k + 2)
    * h_dim1]), dabs(r__10))))) {

/*
                         ==== Starting a new bulge here would
                         .    create non-negligible fill.  Use
                         .    the old one with trepidation. ====
*/
i__5 = k + 1 + k * h_dim1;
h__[i__5].r = beta.r, h__[i__5].i = beta.i;
i__5 = k + 2 + k * h_dim1;
h__[i__5].r = 0.f, h__[i__5].i = 0.f;
i__5 = k + 3 + k * h_dim1;
h__[i__5].r = 0.f, h__[i__5].i = 0.f;
} else {
/*
   ==== Stating a new bulge here would
   .    create only negligible fill.
   .    Replace the old reflector with
   .    the new one. ====
*/

// 计算 h__[k+1+(k+1)*h_dim1] 的索引
i__5 = k + 1 + k * h_dim1;
// 计算 h__[k+1+(k+1)*h_dim1] 的索引
i__6 = k + 1 + k * h_dim1;
// 计算新的 h__[k+1+(k+1)*h_dim1] 的值
q__1.r = h__[i__6].r - refsum.r, q__1.i = h__[i__6].i - refsum.i;
// 更新 h__[k+1+(k+1)*h_dim1] 的值
h__[i__5].r = q__1.r, h__[i__5].i = q__1.i;
// 将 h__[k+2+k*h_dim1] 设置为 0
i__5 = k + 2 + k * h_dim1;
h__[i__5].r = 0.f, h__[i__5].i = 0.f;
// 将 h__[k+3+k*h_dim1] 设置为 0
i__5 = k + 3 + k * h_dim1;
h__[i__5].r = 0.f, h__[i__5].i = 0.f;
// 将 vt 数组中的值复制到 v 数组对应位置
i__5 = m * v_dim1 + 1;
v[i__5].r = vt[0].r, v[i__5].i = vt[0].i;
i__5 = m * v_dim1 + 2;
v[i__5].r = vt[1].r, v[i__5].i = vt[1].i;
i__5 = m * v_dim1 + 3;
v[i__5].r = vt[2].r, v[i__5].i = vt[2].i;

}

/* L10: */

/* ==== Generate a 2-by-2 reflection, if needed. ==== */

// 计算 k 的值
k = krcol + (m22 - 1) * 3;
// 如果 bmp22 为真，则生成一个 2x2 的反射
if (bmp22) {
    // 如果 k == *ktop - 1，则调用 claqr1 函数
    if (k == *ktop - 1) {
        claqr1_(&c__2, &h__[k + 1 + (k + 1) * h_dim1], ldh, &s[(m22 << 1) - 1], &s[m22 * 2], &v[m22 * v_dim1 + 1]);
        // 更新 beta 的值
        i__4 = m22 * v_dim1 + 1;
        beta.r = v[i__4].r, beta.i = v[i__4].i;
        // 调用 clarfg 函数
        clarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
    } else {
        // 否则更新 beta 的值
        i__4 = k + 1 + k * h_dim1;
        beta.r = h__[i__4].r, beta.i = h__[i__4].i;
        // 更新 v[m22*v_dim1+2] 的值
        i__4 = m22 * v_dim1 + 2;
        i__5 = k + 2 + k * h_dim1;
        v[i__4].r = h__[i__5].r, v[i__4].i = h__[i__5].i;
        // 调用 clarfg 函数
        clarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
        // 更新 h__[k+1+k*h_dim1] 的值
        i__4 = k + 1 + k * h_dim1;
        h__[i__4].r = beta.r, h__[i__4].i = beta.i;
        // 将 h__[k+2+k*h_dim1] 设置为 0
        i__4 = k + 2 + k * h_dim1;
        h__[i__4].r = 0.f, h__[i__4].i = 0.f;
    }
}

/* ==== Multiply H by reflections from the left ==== */

// 根据 accum、*wantt 的值确定 jbot 的值
if (accum) {
    jbot = min(ndcol,*kbot);
} else if (*wantt) {
    jbot = *n;
} else {
    jbot = *kbot;
}
// 循环计算 H 矩阵的乘积
i__4 = jbot;
for (j = max(*ktop,krcol); j <= i__4; ++j) {
/* 计算最小值 */
i__5 = mbot, i__6 = (j - krcol + 2) / 3;
mend = min(i__5, i__6);  // 计算 m 的上限，取 mbot 和 (j - krcol + 2) / 3 的较小值为 mend

i__5 = mend;
for (m = mtop; m <= i__5; ++m) {
    k = krcol + (m - 1) * 3;
    r_cnjg(&q__2, &v[m * v_dim1 + 1]);
    i__6 = k + 1 + j * h_dim1;
    r_cnjg(&q__6, &v[m * v_dim1 + 2]);
    i__7 = k + 2 + j * h_dim1;
    q__5.r = q__6.r * h__[i__7].r - q__6.i * h__[i__7].i,
        q__5.i = q__6.r * h__[i__7].i + q__6.i * h__[i__7].r;
    q__4.r = h__[i__6].r + q__5.r, q__4.i = h__[i__6].i +
        q__5.i;
    r_cnjg(&q__8, &v[m * v_dim1 + 3]);
    i__8 = k + 3 + j * h_dim1;
    q__7.r = q__8.r * h__[i__8].r - q__8.i * h__[i__8].i,
        q__7.i = q__8.r * h__[i__8].i + q__8.i * h__[i__8].r;
    q__3.r = q__4.r + q__7.r, q__3.i = q__4.i + q__7.i;
    q__1.r = q__2.r * q__3.r - q__2.i * q__3.i, q__1.i =
        q__2.r * q__3.i + q__2.i * q__3.r;
    refsum.r = q__1.r, refsum.i = q__1.i;
    i__6 = k + 1 + j * h_dim1;
    i__7 = k + 1 + j * h_dim1;
    q__1.r = h__[i__7].r - refsum.r, q__1.i = h__[i__7].i -
        refsum.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;
    i__6 = k + 2 + j * h_dim1;
    i__7 = k + 2 + j * h_dim1;
    i__8 = m * v_dim1 + 2;
    q__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i,
        q__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8].r;
    q__1.r = h__[i__7].r - q__2.r, q__1.i = h__[i__7].i -
        q__2.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;
    i__6 = k + 3 + j * h_dim1;
    i__7 = k + 3 + j * h_dim1;
    i__8 = m * v_dim1 + 3;
    q__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i,
        q__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8].r;
    q__1.r = h__[i__7].r - q__2.r, q__1.i = h__[i__7].i -
        q__2.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;
/* L20: */
}
/* L30: */
}
if (bmp22) {
k = krcol + (m22 - 1) * 3;
/* 计算 MAX */
i__4 = k + 1;  // 设置 i__4 为 k + 1
i__5 = jbot;   // 设置 i__5 为 jbot
for (j = max(i__4,*ktop); j <= i__5; ++j) {  // 循环 j 从 max(i__4, *ktop) 到 i__5
    r_cnjg(&q__2, &v[m22 * v_dim1 + 1]);  // 计算 v[m22 * v_dim1 + 1] 的共轭并存入 q__2
    i__4 = k + 1 + j * h_dim1;  // 计算索引 i__4
    r_cnjg(&q__5, &v[m22 * v_dim1 + 2]);  // 计算 v[m22 * v_dim1 + 2] 的共轭并存入 q__5
    i__6 = k + 2 + j * h_dim1;  // 计算索引 i__6
    q__4.r = q__5.r * h__[i__6].r - q__5.i * h__[i__6].i,  // 计算 q__4 的实部
        q__4.i = q__5.r * h__[i__6].i + q__5.i * h__[i__6].r;  // 计算 q__4 的虚部
    q__3.r = h__[i__4].r + q__4.r, q__3.i = h__[i__4].i + q__4.i;  // 计算 q__3
    q__1.r = q__2.r * q__3.r - q__2.i * q__3.i, q__1.i = q__2.r * q__3.i + q__2.i * q__3.r;  // 计算 q__1
    refsum.r = q__1.r, refsum.i = q__1.i;  // 将结果存入 refsum
    i__4 = k + 1 + j * h_dim1;  // 计算索引 i__4
    i__6 = k + 1 + j * h_dim1;  // 计算索引 i__6
    q__1.r = h__[i__6].r - refsum.r, q__1.i = h__[i__6].i - refsum.i;  // 计算新的 h__[i__4]
    h__[i__4].r = q__1.r, h__[i__4].i = q__1.i;  // 更新 h__[i__4]
    i__4 = k + 2 + j * h_dim1;  // 计算索引 i__4
    i__6 = k + 2 + j * h_dim1;  // 计算索引 i__6
    i__7 = m22 * v_dim1 + 2;  // 计算索引 i__7
    q__2.r = refsum.r * v[i__7].r - refsum.i * v[i__7].i,  // 计算 q__2 的实部
        q__2.i = refsum.r * v[i__7].i + refsum.i * v[i__7].r;  // 计算 q__2 的虚部
    q__1.r = h__[i__6].r - q__2.r, q__1.i = h__[i__6].i - q__2.i;  // 计算新的 h__[i__4]
    h__[i__4].r = q__1.r, h__[i__4].i = q__1.i;  // 更新 h__[i__4]
/* L40: */
}
}

/*
         ==== 通过右侧的反射来乘以 H。
         .    在警惕性降低检查完成前延迟填充最后一行。 ====
*/

if (accum) {  // 如果 accum 为真
jtop = max(*ktop,incol);  // jtop 为 *ktop 和 incol 中的较大值
} else if (*wantt) {  // 否则如果 *wantt 为真
jtop = 1;  // 设置 jtop 为 1
} else {  // 否则
jtop = *ktop;  // 设置 jtop 为 *ktop
}
i__5 = mbot;  // 设置 i__5 为 mbot
for (m = mtop; m <= i__5; ++m) {  // 循环 m 从 mtop 到 i__5
i__4 = m * v_dim1 + 1;  // 计算索引 i__4
if (v[i__4].r != 0.f || v[i__4].i != 0.f) {  // 如果 v[i__4] 不为零向量
k = krcol + (m - 1) * 3;  // 计算 k
/* Computing MIN */
/* 计算 MIN 函数，确定循环的上限 */
i__6 = *kbot, i__7 = k + 3;
i__4 = min(i__6,i__7);

/* 循环：对于每个 j 从 jtop 到 i__4 */
for (j = jtop; j <= i__4; ++j) {

    /* 计算数组索引 */
    i__6 = m * v_dim1 + 1;
    i__7 = j + (k + 1) * h_dim1;
    i__8 = m * v_dim1 + 2;
    i__9 = j + (k + 2) * h_dim1;

    /* 计算复数乘法 */
    q__4.r = v[i__8].r * h__[i__9].r - v[i__8].i * h__[i__9].i,
    q__4.i = v[i__8].r * h__[i__9].i + v[i__8].i * h__[i__9].r;
    q__3.r = h__[i__7].r + q__4.r, q__3.i = h__[i__7].i + q__4.i;

    i__10 = m * v_dim1 + 3;
    i__11 = j + (k + 3) * h_dim1;

    /* 再次计算复数乘法 */
    q__5.r = v[i__10].r * h__[i__11].r - v[i__10].i * h__[i__11].i,
    q__5.i = v[i__10].r * h__[i__11].i + v[i__10].i * h__[i__11].r;
    q__2.r = q__3.r + q__5.r, q__2.i = q__3.i + q__5.i;

    /* 最后一次复数乘法 */
    q__1.r = v[i__6].r * q__2.r - v[i__6].i * q__2.i,
    q__1.i = v[i__6].r * q__2.i + v[i__6].i * q__2.r;

    /* 更新 refsum */
    refsum.r = q__1.r, refsum.i = q__1.i;

    /* 更新 h__ 数组的值 */
    i__6 = j + (k + 1) * h_dim1;
    i__7 = j + (k + 1) * h_dim1;
    q__1.r = h__[i__7].r - refsum.r, q__1.i = h__[i__7].i - refsum.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;

    i__6 = j + (k + 2) * h_dim1;
    i__7 = j + (k + 2) * h_dim1;
    r_cnjg(&q__3, &v[m * v_dim1 + 2]);
    q__2.r = refsum.r * q__3.r - refsum.i * q__3.i,
    q__2.i = refsum.r * q__3.i + refsum.i * q__3.r;
    q__1.r = h__[i__7].r - q__2.r, q__1.i = h__[i__7].i - q__2.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;

    i__6 = j + (k + 3) * h_dim1;
    i__7 = j + (k + 3) * h_dim1;
    r_cnjg(&q__3, &v[m * v_dim1 + 3]);
    q__2.r = refsum.r * q__3.r - refsum.i * q__3.i,
    q__2.i = refsum.r * q__3.i + refsum.i * q__3.r;
    q__1.r = h__[i__7].r - q__2.r, q__1.i = h__[i__7].i - q__2.i;
    h__[i__6].r = q__1.r, h__[i__6].i = q__1.i;

/* L50: */
}

if (accum) {

/*
          ==== Accumulate U. (If necessary, update Z later
          .    with an efficient matrix-matrix
          .    multiply.) ====
*/

/* 更新 U 矩阵的累加值 */
kms = k - incol;
/* 计算 MAX */
i__4 = 1, i__6 = *ktop - incol;
i__7 = kdu;
for (j = max(i__4,i__6); j <= i__7; ++j) {
    /* 计算矩阵乘积并更新矩阵 U */
    i__4 = m * v_dim1 + 1;
    i__6 = j + (kms + 1) * u_dim1;
    i__8 = m * v_dim1 + 2;
    i__9 = j + (kms + 2) * u_dim1;
    q__4.r = v[i__8].r * u[i__9].r - v[i__8].i * u[i__9].i, q__4.i = v[i__8].r * u[i__9].i +
             v[i__8].i * u[i__9].r;
    q__3.r = u[i__6].r + q__4.r, q__3.i = u[i__6].i + q__4.i;
    i__10 = m * v_dim1 + 3;
    i__11 = j + (kms + 3) * u_dim1;
    q__5.r = v[i__10].r * u[i__11].r - v[i__10].i * u[i__11].i, q__5.i = v[i__10].r * u[i__11].i +
             v[i__10].i * u[i__11].r;
    q__2.r = q__3.r + q__5.r, q__2.i = q__3.i + q__5.i;
    q__1.r = v[i__4].r * q__2.r - v[i__4].i * q__2.i, q__1.i = v[i__4].r * q__2.i +
             v[i__4].i * q__2.r;
    refsum.r = q__1.r, refsum.i = q__1.i;
    i__4 = j + (kms + 1) * u_dim1;
    i__6 = j + (kms + 1) * u_dim1;
    q__1.r = u[i__6].r - refsum.r, q__1.i = u[i__6].i - refsum.i;
    u[i__4].r = q__1.r, u[i__4].i = q__1.i;
    i__4 = j + (kms + 2) * u_dim1;
    i__6 = j + (kms + 2) * u_dim1;
    r_cnjg(&q__3, &v[m * v_dim1 + 2]);
    q__2.r = refsum.r * q__3.r - refsum.i * q__3.i, q__2.i = refsum.r * q__3.i +
             refsum.i * q__3.r;
    q__1.r = u[i__6].r - q__2.r, q__1.i = u[i__6].i - q__2.i;
    u[i__4].r = q__1.r, u[i__4].i = q__1.i;
    i__4 = j + (kms + 3) * u_dim1;
    i__6 = j + (kms + 3) * u_dim1;
    r_cnjg(&q__3, &v[m * v_dim1 + 3]);
    q__2.r = refsum.r * q__3.r - refsum.i * q__3.i, q__2.i = refsum.r * q__3.i +
             refsum.i * q__3.r;
    q__1.r = u[i__6].r - q__2.r, q__1.i = u[i__6].i - q__2.i;
    u[i__4].r = q__1.r, u[i__4].i = q__1.i;
/* L60: */
}
} else if (*wantz) {
    /* 如果需要计算 Z 矩阵的更新，通过右侧的反射来进行 */
            i__7 = *ihiz;
            // 循环遍历 j 从 iloz 到 ihiz
            for (j = *iloz; j <= i__7; ++j) {
                // 计算索引 i__4
                i__4 = m * v_dim1 + 1;
                // 计算索引 i__6
                i__6 = j + (k + 1) * z_dim1;
                // 计算索引 i__8
                i__8 = m * v_dim1 + 2;
                // 计算索引 i__9
                i__9 = j + (k + 2) * z_dim1;
                // 计算乘积并赋值给 q__4
                q__4.r = v[i__8].r * z__[i__9].r - v[i__8].i *
                    z__[i__9].i, q__4.i = v[i__8].r * z__[
                    i__9].i + v[i__8].i * z__[i__9].r;
                // 计算和并赋值给 q__3
                q__3.r = z__[i__6].r + q__4.r, q__3.i = z__[i__6]
                    .i + q__4.i;
                // 计算索引 i__10
                i__10 = m * v_dim1 + 3;
                // 计算索引 i__11
                i__11 = j + (k + 3) * z_dim1;
                // 计算乘积并赋值给 q__5
                q__5.r = v[i__10].r * z__[i__11].r - v[i__10].i *
                    z__[i__11].i, q__5.i = v[i__10].r * z__[
                    i__11].i + v[i__10].i * z__[i__11].r;
                // 计算和并赋值给 q__2
                q__2.r = q__3.r + q__5.r, q__2.i = q__3.i +
                    q__5.i;
                // 计算乘积并赋值给 q__1
                q__1.r = v[i__4].r * q__2.r - v[i__4].i * q__2.i,
                    q__1.i = v[i__4].r * q__2.i + v[i__4].i *
                    q__2.r;
                // 将结果赋值给 refsum
                refsum.r = q__1.r, refsum.i = q__1.i;
                // 计算索引 i__4
                i__4 = j + (k + 1) * z_dim1;
                // 计算索引 i__6
                i__6 = j + (k + 1) * z_dim1;
                // 计算差并赋值给 z__
                q__1.r = z__[i__6].r - refsum.r, q__1.i = z__[
                    i__6].i - refsum.i;
                z__[i__4].r = q__1.r, z__[i__4].i = q__1.i;
                // 计算索引 i__4
                i__4 = j + (k + 2) * z_dim1;
                // 计算索引 i__6
                i__6 = j + (k + 2) * z_dim1;
                // 计算共轭并乘积赋值给 q__3
                r_cnjg(&q__3, &v[m * v_dim1 + 2]);
                q__2.r = refsum.r * q__3.r - refsum.i * q__3.i,
                    q__2.i = refsum.r * q__3.i + refsum.i *
                    q__3.r;
                // 计算差并赋值给 z__
                q__1.r = z__[i__6].r - q__2.r, q__1.i = z__[i__6]
                    .i - q__2.i;
                z__[i__4].r = q__1.r, z__[i__4].i = q__1.i;
                // 计算索引 i__4
                i__4 = j + (k + 3) * z_dim1;
                // 计算索引 i__6
                i__6 = j + (k + 3) * z_dim1;
                // 计算共轭并乘积赋值给 q__3
                r_cnjg(&q__3, &v[m * v_dim1 + 3]);
                q__2.r = refsum.r * q__3.r - refsum.i * q__3.i,
                    q__2.i = refsum.r * q__3.i + refsum.i *
                    q__3.r;
                // 计算差并赋值给 z__
                q__1.r = z__[i__6].r - q__2.r, q__1.i = z__[i__6]
                    .i - q__2.i;
                z__[i__4].r = q__1.r, z__[i__4].i = q__1.i;
                // 继续下一个 j 的循环
/* L70: */
            }
            }
        }
/* L80: */
        }

/*           ==== Special case: 2-by-2 reflection (if needed) ==== */

        // 计算 k 的值
        k = krcol + (m22 - 1) * 3;
        // 计算索引 i__5
        i__5 = m22 * v_dim1 + 1;
        // 如果 bmp22 为真且 v[i__5] 不为零，则执行以下代码
        if (bmp22 && (v[i__5].r != 0.f || v[i__5].i != 0.f)) {
/* Computing MIN */
/* 计算 MIN 函数的结果，选择最小的值作为循环的上限 */
i__7 = *kbot, i__4 = k + 3;  // 获取 *kbot 和 k + 3 的值
i__5 = min(i__7, i__4);  // 计算 *kbot 和 k + 3 的最小值，作为循环的上限
for (j = jtop; j <= i__5; ++j) {  // 循环从 jtop 到 i__5 进行迭代

    /* Update H matrix */
    /* 更新 H 矩阵的部分元素 */
    i__7 = m22 * v_dim1 + 1;  // 计算索引值
    i__4 = j + (k + 1) * h_dim1;  // 计算索引值
    i__6 = m22 * v_dim1 + 2;  // 计算索引值
    i__8 = j + (k + 2) * h_dim1;  // 计算索引值
    q__3.r = v[i__6].r * h__[i__8].r - v[i__6].i * h__[i__8].i, q__3.i = v[i__6].r * h__[i__8].i + v[i__6].i * h__[i__8].r;
    q__2.r = h__[i__4].r + q__3.r, q__2.i = h__[i__4].i + q__3.i;
    q__1.r = v[i__7].r * q__2.r - v[i__7].i * q__2.i, q__1.i = v[i__7].r * q__2.i + v[i__7].i * q__2.r;
    refsum.r = q__1.r, refsum.i = q__1.i;  // 计算 refsum 的值
    i__7 = j + (k + 1) * h_dim1;  // 计算索引值
    i__4 = j + (k + 1) * h_dim1;  // 计算索引值
    q__1.r = h__[i__4].r - refsum.r, q__1.i = h__[i__4].i - refsum.i;
    h__[i__7].r = q__1.r, h__[i__7].i = q__1.i;  // 更新 H 矩阵的元素
    i__7 = j + (k + 2) * h_dim1;  // 计算索引值
    i__4 = j + (k + 2) * h_dim1;  // 计算索引值
    r_cnjg(&q__3, &v[m22 * v_dim1 + 2]);
    q__2.r = refsum.r * q__3.r - refsum.i * q__3.i, q__2.i = refsum.r * q__3.i + refsum.i * q__3.r;
    q__1.r = h__[i__4].r - q__2.r, q__1.i = h__[i__4].i - q__2.i;
    h__[i__7].r = q__1.r, h__[i__7].i = q__1.i;  // 更新 H 矩阵的元素
/* L90: */
}

if (accum) {
    /* Update U matrix */
    /* 更新 U 矩阵的部分元素 */
    kms = k - incol;  // 计算 kms 的值
    i__5 = 1, i__7 = *ktop - incol;  // 获取 1 和 *ktop - incol 的最大值
    i__4 = kdu;
    for (j = max(i__5, i__7); j <= i__4; ++j) {  // 循环从 max(i__5, i__7) 到 i__4 进行迭代
        i__5 = m22 * v_dim1 + 1;  // 计算索引值
        i__7 = j + (kms + 1) * u_dim1;  // 计算索引值
        i__6 = m22 * v_dim1 + 2;  // 计算索引值
        i__8 = j + (kms + 2) * u_dim1;  // 计算索引值
        q__3.r = v[i__6].r * u[i__8].r - v[i__6].i * u[i__8].i, q__3.i = v[i__6].r * u[i__8].i + v[i__6].i * u[i__8].r;
        q__2.r = u[i__7].r + q__3.r, q__2.i = u[i__7].i + q__3.i;
        q__1.r = v[i__5].r * q__2.r - v[i__5].i * q__2.i, q__1.i = v[i__5].r * q__2.i + v[i__5].i * q__2.r;
        refsum.r = q__1.r, refsum.i = q__1.i;  // 计算 refsum 的值
        i__5 = j + (kms + 1) * u_dim1;  // 计算索引值
        i__7 = j + (kms + 1) * u_dim1;  // 计算索引值
        q__1.r = u[i__7].r - refsum.r, q__1.i = u[i__7].i - refsum.i;
        u[i__5].r = q__1.r, u[i__5].i = q__1.i;  // 更新 U 矩阵的元素
        i__5 = j + (kms + 2) * u_dim1;  // 计算索引值
        i__7 = j + (kms + 2) * u_dim1;  // 计算索引值
        r_cnjg(&q__3, &v[m22 * v_dim1 + 2]);
        q__2.r = refsum.r * q__3.r - refsum.i * q__3.i, q__2.i = refsum.r * q__3.i + refsum.i * q__3.r;
        q__1.r = u[i__7].r - q__2.r, q__1.i = u[i__7].i - q__2.i;
        u[i__5].r = q__1.r, u[i__5].i = q__1.i;  // 更新 U 矩阵的元素
    }
}
/* L100: */
            }
        } else if (*wantz) {
            /* 如果需要计算 Z 矩阵 */
            i__4 = *ihiz;
            for (j = *iloz; j <= i__4; ++j) {
            /* 循环遍历列 j */
            i__5 = m22 * v_dim1 + 1;
            /* 计算 v[m22, 1] 和 z[j, k+1] 的乘积 */
            i__7 = j + (k + 1) * z_dim1;
            /* 计算 v[m22, 2] 和 z[j, k+2] 的乘积 */
            i__6 = m22 * v_dim1 + 2;
            i__8 = j + (k + 2) * z_dim1;
            q__3.r = v[i__6].r * z__[i__8].r - v[i__6].i * z__[
                i__8].i, q__3.i = v[i__6].r * z__[i__8].i + v[
                i__6].i * z__[i__8].r;
            q__2.r = z__[i__7].r + q__3.r, q__2.i = z__[i__7].i +
                q__3.i;
            q__1.r = v[i__5].r * q__2.r - v[i__5].i * q__2.i,
                q__1.i = v[i__5].r * q__2.i + v[i__5].i *
                q__2.r;
            /* 计算参考和 */
            refsum.r = q__1.r, refsum.i = q__1.i;
            i__5 = j + (k + 1) * z_dim1;
            /* 更新 z[j, k+1] */
            i__7 = j + (k + 1) * z_dim1;
            q__1.r = z__[i__7].r - refsum.r, q__1.i = z__[i__7].i
                - refsum.i;
            z__[i__5].r = q__1.r, z__[i__5].i = q__1.i;
            /* 更新 z[j, k+2] */
            i__5 = j + (k + 2) * z_dim1;
            i__7 = j + (k + 2) * z_dim1;
            r_cnjg(&q__3, &v[m22 * v_dim1 + 2]);
            q__2.r = refsum.r * q__3.r - refsum.i * q__3.i,
                q__2.i = refsum.r * q__3.i + refsum.i *
                q__3.r;
            q__1.r = z__[i__7].r - q__2.r, q__1.i = z__[i__7].i -
                q__2.i;
            z__[i__5].r = q__1.r, z__[i__5].i = q__1.i;
/* L110: */
            }
        }
        }

/*           ==== Vigilant deflation check ==== */

        mstart = mtop;
        /* 设置起始值 mstart */
        if (krcol + (mstart - 1) * 3 < *ktop) {
        /* 如果 krcol + (mstart - 1) * 3 小于 ktop，增加 mstart */
        ++mstart;
        }
        mend = mbot;
        /* 设置结束值 mend */
        if (bmp22) {
        /* 如果 bmp22 为真，增加 mend */
        ++mend;
        }
        if (krcol == *kbot - 2) {
        /* 如果 krcol 等于 kbot - 2，增加 mend */
        ++mend;
        }
        i__4 = mend;
        /* 循环遍历 mstart 到 mend */
        for (m = mstart; m <= i__4; ++m) {
/* Computing MIN */
        /* 计算最小值 */
        i__5 = *kbot - 1, i__7 = krcol + (m - 1) * 3;
        k = min(i__5,i__7);

/*
                ==== The following convergence test requires that
                .    the tradition small-compared-to-nearby-diagonals
                .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
                .    criteria both be satisfied.  The latter improves
                .    accuracy in some examples. Falling back on an
                .    alternate convergence criterion when TST1 or TST2
                .    is zero (as done here) is traditional but probably
                .    unnecessary. ====
        i__5 = k + 1 + k * h_dim1;
        // 计算 h__(k+1, k) 是否为零
        if (h__[i__5].r != 0.f || h__[i__5].i != 0.f) {
            i__5 = k + k * h_dim1;
            i__7 = k + 1 + (k + 1) * h_dim1;
            // 计算 tst1，包括对角线元素和相应虚部的绝对值之和
            tst1 = (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 = r_imag(&
                h__[k + k * h_dim1]), dabs(r__2)) + ((r__3 = h__[
                i__7].r, dabs(r__3)) + (r__4 = r_imag(&h__[k + 1
                + (k + 1) * h_dim1]), dabs(r__4)));
            // 如果 tst1 为零，继续计算更远的对角线元素
            if (tst1 == 0.f) {
                if (k >= *ktop + 1) {
                    i__5 = k + (k - 1) * h_dim1;
                    // 添加 (k, k-1) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + (k - 1) * h_dim1]), dabs(
                        r__2));
                }
                if (k >= *ktop + 2) {
                    i__5 = k + (k - 2) * h_dim1;
                    // 添加 (k, k-2) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + (k - 2) * h_dim1]), dabs(
                        r__2));
                }
                if (k >= *ktop + 3) {
                    i__5 = k + (k - 3) * h_dim1;
                    // 添加 (k, k-3) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + (k - 3) * h_dim1]), dabs(
                        r__2));
                }
                if (k <= *kbot - 2) {
                    i__5 = k + 2 + (k + 1) * h_dim1;
                    // 添加 (k+2, k+1) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + 2 + (k + 1) * h_dim1]),
                        dabs(r__2));
                }
                if (k <= *kbot - 3) {
                    i__5 = k + 3 + (k + 1) * h_dim1;
                    // 添加 (k+3, k+1) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + 3 + (k + 1) * h_dim1]),
                        dabs(r__2));
                }
                if (k <= *kbot - 4) {
                    i__5 = k + 4 + (k + 1) * h_dim1;
                    // 添加 (k+4, k+1) 元素的绝对值到 tst1
                    tst1 += (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                         r_imag(&h__[k + 4 + (k + 1) * h_dim1]),
                        dabs(r__2));
                }
            }
            i__5 = k + 1 + k * h_dim1;
            // 计算 h__(k+1, k) 元素的绝对值和相应虚部的绝对值之和是否小于给定的阈值
            /* Computing MAX */
            r__3 = smlnum, r__4 = ulp * tst1;
            if ((r__1 = h__[i__5].r, dabs(r__1)) + (r__2 = r_imag(&
                h__[k + 1 + k * h_dim1]), dabs(r__2)) <= dmax(
                r__3,r__4)) {
                i__5 = k + 1 + k * h_dim1;
                i__7 = k + (k + 1) * h_dim1;
                // 计算两个对角线元素的绝对值和相应虚部的绝对值之间的最大值
                r__5 = (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
                    r_imag(&h__[k + 1 + k * h_dim1]), dabs(r__2)),
                     r__6 = (r__3 = h__[i__7].r, dabs(r__3)) + (
                    r__4 = r_imag(&h__[k + (k + 1) * h_dim1]),
                    dabs(r__4));
                h12 = dmax(r__5,r__6);
/* Computing MIN */
/* 计算最小值 */

i__5 = k + 1 + k * h_dim1;
/* 计算数组索引 */
i__7 = k + (k + 1) * h_dim1;
/* 计算数组索引 */
r__5 = (r__1 = h__[i__5].r, dabs(r__1)) + (r__2 =
    r_imag(&h__[k + 1 + k * h_dim1]), dabs(r__2)),
    r__6 = (r__3 = h__[i__7].r, dabs(r__3)) + (
    r__4 = r_imag(&h__[k + (k + 1) * h_dim1]),
    dabs(r__4));
/* 计算两个复数的绝对值并求和 */
h21 = dmin(r__5,r__6);
/* 将计算结果取最小值赋给 h21 */

i__5 = k + k * h_dim1;
/* 计算数组索引 */
i__7 = k + 1 + (k + 1) * h_dim1;
/* 计算数组索引 */
q__2.r = h__[i__5].r - h__[i__7].r, q__2.i = h__[i__5]
    .i - h__[i__7].i;
q__1.r = q__2.r, q__1.i = q__2.i;
/* 计算两个复数的差 */
/* Computing MAX */
/* 计算最大值 */

i__6 = k + 1 + (k + 1) * h_dim1;
/* 计算数组索引 */
r__5 = (r__1 = h__[i__6].r, dabs(r__1)) + (r__2 =
    r_imag(&h__[k + 1 + (k + 1) * h_dim1]), dabs(
    r__2)), r__6 = (r__3 = q__1.r, dabs(r__3)) + (
    r__4 = r_imag(&q__1), dabs(r__4));
/* 计算两个复数的绝对值并求和 */
h11 = dmax(r__5,r__6);
/* 将计算结果取最大值赋给 h11 */

i__5 = k + k * h_dim1;
/* 计算数组索引 */
i__7 = k + 1 + (k + 1) * h_dim1;
/* 计算数组索引 */
q__2.r = h__[i__5].r - h__[i__7].r, q__2.i = h__[i__5]
    .i - h__[i__7].i;
q__1.r = q__2.r, q__1.i = q__2.i;
/* 计算两个复数的差 */
/* Computing MIN */
/* 计算最小值 */

i__6 = k + 1 + (k + 1) * h_dim1;
/* 计算数组索引 */
r__5 = (r__1 = h__[i__6].r, dabs(r__1)) + (r__2 =
    r_imag(&h__[k + 1 + (k + 1) * h_dim1]), dabs(
    r__2)), r__6 = (r__3 = q__1.r, dabs(r__3)) + (
    r__4 = r_imag(&q__1), dabs(r__4));
/* 计算两个复数的绝对值并求和 */
h22 = dmin(r__5,r__6);
/* 将计算结果取最小值赋给 h22 */

scl = h11 + h12;
/* 计算 h11 和 h12 的和并赋给 scl */
tst2 = h22 * (h11 / scl);
/* 计算 h22 乘以 h11/scl 并赋给 tst2 */

/* Computing MAX */
/* 计算最大值 */

r__1 = smlnum, r__2 = ulp * tst2;
/* 计算 smlnum 和 ulp*tst2 的最大值 */
if (tst2 == 0.f || h21 * (h12 / scl) <= dmax(r__1,
    r__2)) {
    i__5 = k + 1 + k * h_dim1;
    h__[i__5].r = 0.f, h__[i__5].i = 0.f;
}
/* 如果 tst2 等于 0 或者 h21*(h12/scl) 小于等于 dmax(r__1, r__2)，则将 h__ 中对应位置置为 0 */
        i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
        mend = min(i__4,i__5);
        i__4 = mend;
        // 循环遍历处理每个小块的索引，m 从 mtop 到 mend
        for (m = mtop; m <= i__4; ++m) {
            // 计算当前小块的起始列索引 k
            k = krcol + (m - 1) * 3;
            // 计算矩阵 H 的元素更新：
            // 计算 v[m,1] 和 v[m,3] 的乘积
            i__5 = m * v_dim1 + 1;
            i__7 = m * v_dim1 + 3;
            q__2.r = v[i__5].r * v[i__7].r - v[i__5].i * v[i__7].i,
                q__2.i = v[i__5].r * v[i__7].i + v[i__5].i * v[i__7].r;
            i__6 = k + 4 + (k + 3) * h_dim1;
            q__1.r = q__2.r * h__[i__6].r - q__2.i * h__[i__6].i, q__1.i =
                 q__2.r * h__[i__6].i + q__2.i * h__[i__6].r;
            refsum.r = q__1.r, refsum.i = q__1.i;
            // 更新 H[k+4,(k+3)]
            i__5 = k + 4 + (k + 3) * h_dim1;
            q__1.r = -refsum.r, q__1.i = -refsum.i;
            h__[i__5].r = q__1.r, h__[i__5].i = q__1.i;
            // 更新 H[k+4,(k+1)]
            i__5 = k + 4 + (k + 1) * h_dim1;
            q__1.r = -refsum.r, q__1.i = -refsum.i;
            r_cnjg(&q__3, &v[m * v_dim1 + 2]);
            q__2.r = q__1.r * q__3.r - q__1.i * q__3.i, q__2.i = q__1.r *
                q__3.i + q__1.i * q__3.r;
            h__[i__5].r = q__2.r, h__[i__5].i = q__2.i;
            // 更新 H[k+4,(k+2)]
            i__5 = k + 4 + (k + 2) * h_dim1;
            i__7 = k + 4 + (k + 2) * h_dim1;
            r_cnjg(&q__3, &v[m * v_dim1 + 3]);
            q__2.r = refsum.r * q__3.r - refsum.i * q__3.i, q__2.i =
                refsum.r * q__3.i + refsum.i * q__3.r;
            q__1.r = h__[i__7].r - q__2.r, q__1.i = h__[i__7].i - q__2.i;
            h__[i__5].r = q__1.r, h__[i__5].i = q__1.i;
/* L130: */
        }

/*
             ==== End of near-the-diagonal bulge chase. ====

   L140:
*/
    }

/*
          ==== Use U (if accumulated) to update far-from-diagonal
          .    entries in H.  If required, use U to update Z as
          .    well. ====
*/

    if (accum) {
        if (*wantt) {
        jtop = 1;
        jbot = *n;
        } else {
        jtop = *ktop;
        jbot = *kbot;
        }
        if (! blk22 || incol < *ktop || ndcol > *kbot || ns <= 2) {

/*
                ==== Updates not exploiting the 2-by-2 block
                .    structure of U.  K1 and NU keep track of
                .    the location and size of U in the special
                .    cases of introducing bulges and chasing
                .    bulges off the bottom.  In these special
                .    cases and in case the number of shifts
                .    is NS = 2, there is no 2-by-2 block
                .    structure to exploit.  ====

   Computing MAX
*/
        i__3 = 1, i__4 = *ktop - incol;
        // 计算 K1，U 的起始索引，考虑到特殊情况
        k1 = max(i__3,i__4);
/* Computing MAX */
        i__3 = 0, i__4 = ndcol - *kbot;
        // 计算 NU，U 的大小，考虑到特殊情况
        nu = kdu - max(i__3,i__4) - k1 + 1;

/*              ==== Horizontal Multiply ==== */

        i__3 = jbot;
        i__4 = *nh;
        // 循环处理每列 jcol 的更新
        for (jcol = min(ndcol,*kbot) + 1; i__4 < 0 ? jcol >= i__3 :
            jcol <= i__3; jcol += i__4) {
/* Computing MIN */
i__5 = *nh, i__7 = jbot - jcol + 1;
jlen = min(i__5,i__7);
/* 计算jlen，即两者中的较小值，用于确定本次循环中处理的列数 */

cgemm_("C", "N", &nu, &jlen, &nu, &c_b57, &u[k1 + k1 *
    u_dim1], ldu, &h__[incol + k1 + jcol * h_dim1],
    ldh, &c_b56, &wh[wh_offset], ldwh);
/* 执行复杂矩阵乘法运算，计算结果存储在wh数组中 */

clacpy_("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h__[
    incol + k1 + jcol * h_dim1], ldh);
/* 将wh数组的内容复制到h数组的指定位置 */

/* L150: */
}

/* ==== Vertical multiply ==== */

i__4 = max(*ktop,incol) - 1;
i__3 = *nv;
for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
    jrow += i__3) {
/* Computing MIN */
i__5 = *nv, i__7 = max(*ktop,incol) - jrow;
jlen = min(i__5,i__7);
/* 计算jlen，即两者中的较小值，用于确定本次循环中处理的行数 */

cgemm_("N", "N", &jlen, &nu, &nu, &c_b57, &h__[jrow + (
    incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1],
    ldu, &c_b56, &wv[wv_offset], ldwv);
/* 执行复杂矩阵乘法运算，计算结果存储在wv数组中 */

clacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h__[
    jrow + (incol + k1) * h_dim1], ldh);
/* 将wv数组的内容复制到h数组的指定位置 */

/* L160: */
}

/* ==== Z multiply (also vertical) ==== */

if (*wantz) {
    i__3 = *ihiz;
    i__4 = *nv;
    for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
         jrow += i__4) {
    /* Computing MIN */
    i__5 = *nv, i__7 = *ihiz - jrow + 1;
    jlen = min(i__5,i__7);
    /* 计算jlen，即两者中的较小值，用于确定本次循环中处理的行数 */

    cgemm_("N", "N", &jlen, &nu, &nu, &c_b57, &z__[jrow +
        (incol + k1) * z_dim1], ldz, &u[k1 + k1 *
        u_dim1], ldu, &c_b56, &wv[wv_offset], ldwv);
    /* 执行复杂矩阵乘法运算，计算结果存储在wv数组中 */

    clacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z__[
        jrow + (incol + k1) * z_dim1], ldz);
    /* 将wv数组的内容复制到z数组的指定位置 */
    /* L170: */
    }
} else {

/*
        ==== Updates exploiting U's 2-by-2 block structure.
        .    (I2, I4, J2, J4 are the last rows and columns
        .    of the blocks.) ====
*/

i2 = (kdu + 1) / 2;
i4 = kdu;
j2 = i4 - i2;
j4 = kdu;

/*
        ==== KZS and KNZ deal with the band of zeros
        .    along the diagonal of one of the triangular
        .    blocks. ====
*/

kzs = j4 - j2 - (ns + 1);
knz = ns + 1;

/* ==== Horizontal multiply ==== */

i__4 = jbot;
i__3 = *nh;
for (jcol = min(ndcol,*kbot) + 1; i__3 < 0 ? jcol >= i__4 :
    jcol <= i__4; jcol += i__3) {
/* Computing MIN */
i__5 = *nh, i__7 = jbot - jcol + 1;
jlen = min(i__5,i__7);
/* 计算jlen，即两者中的较小值，用于确定本次循环中处理的列数 */

/*
   ==== Copy bottom of H to top+KZS of scratch ====
    (The first KZS rows get multiplied by zero.) ====
*/

clacpy_("ALL", &knz, &jlen, &h__[incol + 1 + j2 + jcol *
    h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);
/* 将h数组的指定部分复制到wh数组的指定位置 */
/*                 ==== Multiply by U21' ==== */
在此处对 WH 矩阵的一部分进行乘法操作，使用了 U 矩阵的转置。*/

            claset_("ALL", &kzs, &jlen, &c_b56, &c_b56, &wh[wh_offset]
                , ldwh);
/* 在 WH 矩阵的指定区域设定值为常数。 */

            ctrmm_("L", "U", "C", "N", &knz, &jlen, &c_b57, &u[j2 + 1
                + (kzs + 1) * u_dim1], ldu, &wh[kzs + 1 + wh_dim1]
                , ldwh);
/* 在 WH 矩阵的一部分左乘上三角矩阵 U 的转置。*/

/*                 ==== Multiply top of H by U11' ==== */

            cgemm_("C", "N", &i2, &jlen, &j2, &c_b57, &u[u_offset],
                ldu, &h__[incol + 1 + jcol * h_dim1], ldh, &c_b57,
                 &wh[wh_offset], ldwh);
/* 在 WH 矩阵的顶部区域进行乘法操作，其中 H 矩阵的一部分与 U 矩阵的转置相乘。*/

/*                 ==== Copy top of H to bottom of WH ==== */

            clacpy_("ALL", &j2, &jlen, &h__[incol + 1 + jcol * h_dim1]
                , ldh, &wh[i2 + 1 + wh_dim1], ldwh);
/* 将 H 矩阵的顶部区域复制到 WH 矩阵的底部区域。*/

/*                 ==== Multiply by U21' ==== */

            ctrmm_("L", "L", "C", "N", &j2, &jlen, &c_b57, &u[(i2 + 1)
                 * u_dim1 + 1], ldu, &wh[i2 + 1 + wh_dim1], ldwh);
/* 在 WH 矩阵的一部分左乘下三角矩阵 U 的转置。*/

/*                 ==== Multiply by U22 ==== */

            i__5 = i4 - i2;
            i__7 = j4 - j2;
            cgemm_("C", "N", &i__5, &jlen, &i__7, &c_b57, &u[j2 + 1 +
                (i2 + 1) * u_dim1], ldu, &h__[incol + 1 + j2 +
                jcol * h_dim1], ldh, &c_b57, &wh[i2 + 1 + wh_dim1]
                , ldwh);
/* 在 WH 矩阵的一部分进行乘法操作，其中包括 H 矩阵的一部分与 U 矩阵的一部分相乘。*/

/*                 ==== Copy it back ==== */

            clacpy_("ALL", &kdu, &jlen, &wh[wh_offset], ldwh, &h__[
                incol + 1 + jcol * h_dim1], ldh);
/* 将 WH 矩阵的内容复制回 H 矩阵的指定位置。*/
/* L180: */
        }

/*              ==== Vertical multiply ==== */

        i__3 = max(incol,*ktop) - 1;
        i__4 = *nv;
        for (jrow = jtop; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
            jrow += i__4) {
/* Computing MIN */
            i__5 = *nv, i__7 = max(incol,*ktop) - jrow;
            jlen = min(i__5,i__7);

/*
                   ==== Copy right of H to scratch (the first KZS
                   .    columns get multiplied by zero) ====
*/

            clacpy_("ALL", &jlen, &knz, &h__[jrow + (incol + 1 + j2) *
                 h_dim1], ldh, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);
/* 将 H 矩阵的指定区域复制到临时数组 WV，其中的前 KZS 列会乘以零。*/

/*                 ==== Multiply by U21 ==== */

            claset_("ALL", &jlen, &kzs, &c_b56, &c_b56, &wv[wv_offset]
                , ldwv);
/* 在 Wv 矩阵的指定区域设定值为常数。 */

            ctrmm_("R", "U", "N", "N", &jlen, &knz, &c_b57, &u[j2 + 1
                + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1) *
                wv_dim1 + 1], ldwv);
/* 在 Wv 矩阵的一部分右乘上三角矩阵 U。*/

/*                 ==== Multiply by U11 ==== */

            cgemm_("N", "N", &jlen, &i2, &j2, &c_b57, &h__[jrow + (
                incol + 1) * h_dim1], ldh, &u[u_offset], ldu, &
                c_b57, &wv[wv_offset], ldwv);
/* 在 Wv 矩阵的一部分进行乘法操作，其中包括 H 矩阵的一部分与 U 矩阵的一部分相乘。*/

/*                 ==== Copy left of H to right of scratch ==== */

            clacpy_("ALL", &jlen, &j2, &h__[jrow + (incol + 1) *
                h_dim1], ldh, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);
/* 将 H 矩阵的指定区域复制到 Wv 矩阵的另一部分。*/
/*                 ==== Multiply by U21 ==== */

            i__5 = i4 - i2;
            ctrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b57, &u[(i2 +
                1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * wv_dim1 + 1]
                , ldwv);

/* 
   ==== Multiply by U22 ====

   Perform matrix multiplication of matrix H and matrix U for a specific block.
   Parameters:
   - "N", "N": No transpose for both matrices H and U
   - jlen: Number of rows of matrix H to multiply
   - i__5: Number of columns of matrix H to multiply
   - i__7: Number of columns of matrix U
   - c_b57: Scalar coefficient
   - h__[jrow + (incol + 1 + j2) * h_dim1]: Starting address of matrix H
   - ldh: Leading dimension of matrix H
   - &u[j2 + 1 + (i2 + 1) * u_dim1]: Starting address of matrix U
   - ldu: Leading dimension of matrix U
   - &wv[(i2 + 1) * wv_dim1 + 1]: Starting address of result matrix WV
   - ldwv: Leading dimension of matrix WV
*/
            i__5 = i4 - i2;
            i__7 = j4 - j2;
            cgemm_("N", "N", &jlen, &i__5, &i__7, &c_b57, &h__[jrow +
                (incol + 1 + j2) * h_dim1], ldh, &u[j2 + 1 + (i2
                + 1) * u_dim1], ldu, &c_b57, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/* 
   ==== Copy it back ====

   Copy data from one matrix to another.
   Parameters:
   - "ALL": Copy all elements of the source matrix
   - &jlen: Number of rows to copy
   - &kdu: Number of columns to copy
   - &wv[wv_offset]: Starting address of source matrix WV
   - ldwv: Leading dimension of source matrix WV
   - &h__[jrow + (incol + 1) * h_dim1]: Starting address of destination matrix H
   - ldh: Leading dimension of destination matrix H
*/
            clacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h__[
                jrow + (incol + 1) * h_dim1], ldh);
/* L190: */
        }

/* 
   ==== Multiply Z (also vertical) ====

   Perform multiplication involving matrix Z and matrix U.
*/
        if (*wantz) {
            i__4 = *ihiz;
            i__3 = *nv;
            for (jrow = *iloz; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
                 jrow += i__3) {
/* Computing MIN */
            i__5 = *nv, i__7 = *ihiz - jrow + 1;
            jlen = min(i__5,i__7);

/*
   ==== Copy right of Z to left of scratch (first
        KZS columns get multiplied by zero) ====

   Copy data from one matrix to another.
   Parameters:
   - "ALL": Copy all elements of the source matrix
   - &jlen: Number of rows to copy
   - &knz: Number of columns to copy
   - &z__[jrow + (incol + 1 + j2) * z_dim1]: Starting address of source matrix Z
   - ldz: Leading dimension of source matrix Z
   - &wv[(kzs + 1) * wv_dim1 + 1]: Starting address of destination matrix WV
   - ldwv: Leading dimension of destination matrix WV
*/
            clacpy_("ALL", &jlen, &knz, &z__[jrow + (incol + 1 +
                j2) * z_dim1], ldz, &wv[(kzs + 1) * wv_dim1 +
                1], ldwv);

/* 
   ==== Multiply by U12 ====

   Set all elements of a matrix to a scalar value.
   Parameters:
   - "ALL": Set all elements of the matrix
   - &jlen: Number of rows of the matrix
   - &kzs: Number of columns of the matrix
   - &c_b56: Scalar coefficient
   - &c_b56: Scalar coefficient
   - &wv[wv_offset]: Starting address of matrix WV
   - ldwv: Leading dimension of matrix WV
*/
            claset_("ALL", &jlen, &kzs, &c_b56, &c_b56, &wv[
                wv_offset], ldwv);

/* 
   ==== Multiply by U11 ====

   Perform matrix multiplication of matrix Z and matrix U for a specific block.
   Parameters:
   - "N", "N": No transpose for both matrices Z and U
   - jlen: Number of rows of matrix Z to multiply
   - i2: Number of rows of matrix Z to multiply
   - j2: Number of columns of matrix Z to multiply
   - c_b57: Scalar coefficient
   - &z__[jrow + (incol + 1) * z_dim1]: Starting address of matrix Z
   - ldz: Leading dimension of matrix Z
   - &u[u_offset]: Starting address of matrix U
   - ldu: Leading dimension of matrix U
   - &c_b57: Scalar coefficient
   - &wv[wv_offset]: Starting address of result matrix WV
   - ldwv: Leading dimension of matrix WV
*/
            cgemm_("N", "N", &jlen, &i2, &j2, &c_b57, &z__[jrow +
                (incol + 1) * z_dim1], ldz, &u[u_offset], ldu,
                 &c_b57, &wv[wv_offset], ldwv);

/* 
   ==== Copy left of Z to right of scratch ====

   Copy data from one matrix to another.
   Parameters:
   - "ALL": Copy all elements of the source matrix
   - &jlen: Number of rows to copy
   - &j2: Number of columns to copy
   - &z__[jrow + (incol + 1) * z_dim1]: Starting address of source matrix Z
   - ldz: Leading dimension of source matrix Z
   - &wv[(i2 + 1) * wv_dim1 + 1]: Starting address of destination matrix WV
   - ldwv: Leading dimension of destination matrix WV
*/
            clacpy_("ALL", &jlen, &j2, &z__[jrow + (incol + 1) *
                z_dim1], ldz, &wv[(i2 + 1) * wv_dim1 + 1],
                ldwv);

/* 
   ==== Multiply by U21 ====

   Perform matrix multiplication of matrix U and matrix WV for a specific block.
   Parameters:
   - "R", "L", "N", "N": Right multiplication of WV by U
   - &jlen: Number of rows of matrix WV to multiply
   - &i__5: Number of columns of matrix WV to multiply
   - &c_b57: Scalar coefficient
   - &u[(i2 + 1) * u_dim1 + 1]: Starting address of matrix U
   - ldu: Leading dimension of matrix U
   - &wv[(i2 + 1) * wv_dim1 + 1]: Starting address of matrix WV
   - ldwv: Leading dimension of matrix WV
*/
            i__5 = i4 - i2;
            ctrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b57, &u[(
                i2 + 1) * u_dim1 + 1], ldu, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/* 
   ==== Multiply by U22 ====

   Perform matrix multiplication of matrix Z and matrix U for a specific block.
   Parameters:
   - "N", "N": No transpose for both matrices Z and U
   - &jlen: Number of rows of matrix Z to multiply
   - &i__5: Number of columns of matrix Z to multiply
   - &i__7: Number of columns of matrix U
   - &c_b57: Scalar coefficient
   - &z__[jrow + (incol + 1 + j2) * z_dim1]: Starting address of matrix Z
   - ldz: Leading dimension of matrix Z
   - &u[j2 + 1 + (i2 + 1) * u_dim1]: Starting address of matrix U
   - ldu: Leading dimension of matrix U
   - &c_b57: Scalar coefficient
   - &wv[(i2 +
/* L210: */
    }

/*     ==== End of CLAQR5 ==== */

    return 0;
} /* claqr5_ */

/* Subroutine */ int clarcm_(integer *m, integer *n, real *a, integer *lda,
    singlecomplex *b, integer *ldb, singlecomplex *c__, integer *ldc, real *rwork)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
        i__3, i__4, i__5;
    real r__1;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int sgemm_(char *, char *, integer *, integer *,
        integer *, real *, real *, integer *, real *, integer *, real *,
        real *, integer *);

    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006

        Purpose
        =======

        CLARCM performs a very simple matrix-matrix multiplication:
                 C := A * B,
        where A is M by M and real; B is M by N and complex;
        C is M by N and complex.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A and of the matrix C.
                M >= 0.

        N       (input) INTEGER
                The number of columns and rows of the matrix B and
                the number of columns of the matrix C.
                N >= 0.

        A       (input) REAL array, dimension (LDA, M)
                A contains the M by M matrix A.

        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >=max(1,M).

        B       (input) REAL array, dimension (LDB, N)
                B contains the M by N matrix B.

        LDB     (input) INTEGER
                The leading dimension of the array B. LDB >=max(1,M).

        C       (input) COMPLEX array, dimension (LDC, N)
                C contains the M by N matrix C.

        LDC     (input) INTEGER
                The leading dimension of the array C. LDC >=max(1,M).

        RWORK   (workspace) REAL array, dimension (2*M*N)

        =====================================================================

           Quick return if possible.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --rwork;

    /* Function Body */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * b_dim1;
            rwork[(j - 1) * *m + i__] = b[i__3].r;
/* L10: */
        }
/* L20: */
    }

    l = *m * *n + 1;
    sgemm_("N", "N", m, n, m, &c_b1034, &a[a_offset], lda, &rwork[1], m, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = l + i__ - 1;
            i__5 = i__ + j * b_dim1;
            q__1.r = rwork[i__4] * b[i__5].r;
            q__1.i = rwork[i__4] * b[i__5].i; // Perform complex multiplication
            c__[i__3].r += q__1.r;
            c__[i__3].i += q__1.i;
/* L30: */
        }
/* L40: */
    }

    return 0;
} /* clarcm_ */


注释：
    // 循环迭代变量i__从1到i__2，逐步增加
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 计算复数数组c__中的索引位置 i__ + j * c_dim1
        i__3 = i__ + j * c_dim1;
        // 计算复数数组c__中的索引位置，并赋值为rwork中对应位置的实部值，虚部为0
        i__4 = l + (j - 1) * *m + i__ - 1;
        c__[i__3].r = rwork[i__4], c__[i__3].i = 0.f;
    }
/* L40: */
    }

    i__1 = *n;
    // 循环遍历矩阵的每一列
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    // 循环遍历矩阵的每一行
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 从复数矩阵 b 中提取虚部，存入 rwork 数组
        rwork[(j - 1) * *m + i__] = r_imag(&b[i__ + j * b_dim1]);
/* L50: */
    }
/* L60: */
    }
    // 执行复数矩阵乘法，将结果存入 rwork 数组
    sgemm_("N", "N", m, n, m, &c_b1034, &a[a_offset], lda, &rwork[1], m, &
        c_b328, &rwork[l], m);
    i__1 = *n;
    // 循环遍历矩阵的每一列
    for (j = 1; j <= i__1; ++j) {
    i__2 = *m;
    // 循环遍历矩阵的每一行
    for (i__ = 1; i__ <= i__2; ++i__) {
        // 计算 c__ 矩阵中的元素并存储
        i__3 = i__ + j * c_dim1;
        i__4 = i__ + j * c_dim1;
        r__1 = c__[i__4].r;
        i__5 = l + (j - 1) * *m + i__ - 1;
        q__1.r = r__1, q__1.i = rwork[i__5];
        c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L70: */
    }
/* L80: */
    }

    return 0;

/*     End of CLARCM */

} /* clarcm_ */

/* Subroutine */ int clarf_(char *side, integer *m, integer *n, singlecomplex *v,
    integer *incv, singlecomplex *tau, singlecomplex *c__, integer *ldc, singlecomplex *
    work)
{
    /* System generated locals */
    integer c_dim1, c_offset, i__1;
    singlecomplex q__1;

    /* Local variables */
    static integer i__;
    static logical applyleft;
    extern /* Subroutine */ int cgerc_(integer *, integer *, singlecomplex *,
        singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, integer *),
         cgemv_(char *, integer *, integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *);
    extern logical lsame_(char *, char *);
    static integer lastc, lastv;
    extern integer ilaclc_(integer *, integer *, singlecomplex *, integer *),
        ilaclr_(integer *, integer *, singlecomplex *, integer *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLARF applies a complex elementary reflector H to a complex M-by-N
    matrix C, from either the left or the right. H is represented in the
    form

          H = I - tau * v * v'

    where tau is a complex scalar and v is a complex vector.

    If tau = 0, then H is taken to be the unit matrix.

    To apply H' (the conjugate transpose of H), supply conjg(tau) instead
    tau.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H

    M       (input) INTEGER
            The number of rows of the matrix C.

    N       (input) INTEGER
            The number of columns of the matrix C.

    V       (input) COMPLEX array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.

    INCV    (input) INTEGER
            The increment between elements of v. INCV <> 0.
    # TAU (input) COMPLEX
    #       H的表示中的tau值。

    # C (input/output) COMPLEX array, dimension (LDC,N)
    #   On entry, matrix C with dimensions M-by-N.
    #   On exit, if SIDE = 'L', C is overwritten by the matrix H * C.
    #           if SIDE = 'R', C is overwritten by C * H.
    #   入口时，尺寸为 M-by-N 的矩阵 C。
    #   出口时，若 SIDE = 'L'，则 C 被矩阵 H * C 覆盖。
    #           若 SIDE = 'R'，则 C 被 C * H 覆盖。

    # LDC (input) INTEGER
    #     数组 C 的领导维度。LDC >= max(1, M)。

    # WORK (workspace) COMPLEX array, dimension
    #      (N) if SIDE = 'L'
    #   or (M) if SIDE = 'R'
    #   工作空间数组，尺寸为 N（如果 SIDE = 'L'）或 M（如果 SIDE = 'R'）。
/*
    Parameter adjustments
*/
    --v;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /*
        Function Body
    */
    applyleft = lsame_(side, "L");
    lastv = 0;
    lastc = 0;
    if (tau->r != 0.f || tau->i != 0.f) {
/*
        Set up variables for scanning V.  LASTV begins pointing to the end
        of V.
*/
        if (applyleft) {
            lastv = *m;
        } else {
            lastv = *n;
        }
        if (*incv > 0) {
            i__ = (lastv - 1) * *incv + 1;
        } else {
            i__ = 1;
        }
/*     
        Look for the last non-zero row in V.
*/
        for (;;) { /* while(complicated condition) */
            i__1 = i__;
            if (!(lastv > 0 && (v[i__1].r == 0.f && v[i__1].i == 0.f)))
                break;
            --lastv;
            i__ -= *incv;
        }
        if (applyleft) {
/*     
        Scan for the last non-zero column in C(1:lastv,:).
*/
            lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);
        } else {
/*     
        Scan for the last non-zero row in C(:,1:lastv).
*/
            lastc = ilaclr_(m, &lastv, &c__[c_offset], ldc);
        }
    }
/*
    Note that lastc.eq.0 renders the BLAS operations null; no special
    case is needed at this level.
*/
    if (applyleft) {
/*     
        Form  H * C
*/
        if (lastv > 0) {
/*     
        w(1:lastc,1) := C(1:lastv,1:lastc)' * v(1:lastv,1)
*/
            cgemv_("Conjugate transpose", &lastv, &lastc, &c_b57, &c__[
                c_offset], ldc, &v[1], incv, &c_b56, &work[1], &c__1);
/*     
        C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)'
*/
            q__1.r = -tau->r, q__1.i = -tau->i;
            cgerc_(&lastv, &lastc, &q__1, &v[1], incv, &work[1], &c__1, &c__[
                c_offset], ldc);
        }
    } else {
/*     
        Form  C * H
*/
        if (lastv > 0) {
/*     
        w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)
*/
            cgemv_("No transpose", &lastc, &lastv, &c_b57, &c__[c_offset],
                ldc, &v[1], incv, &c_b56, &work[1], &c__1);
/*     
        C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)'
*/
            q__1.r = -tau->r, q__1.i = -tau->i;
            cgerc_(&lastc, &lastv, &q__1, &work[1], &c__1, &v[1], incv, &c__[
                c_offset], ldc);
        }
    }
    return 0;
/*
     End of CLARF
*/
} /* clarf_ */

/*
    Subroutine clarfb
*/
/* Subroutine */ int clarfb_(char *side, char *trans, char *direct, char *
    storev, integer *m, integer *n, integer *k, singlecomplex *v, integer *ldv,
    singlecomplex *t, integer *ldt, singlecomplex *c__, integer *ldc, singlecomplex *work,
    integer *ldwork)
{
    /*
        System generated locals
    */
    integer c_dim1, c_offset, t_dim1, t_offset, v_dim1, v_offset, work_dim1,
        work_offset, i__1, i__2, i__3, i__4, i__5;
    singlecomplex q__1, q__2;

    /*
        Local variables
    */
    static integer i__, j;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);
    # 外部函数声明，声明一个逻辑函数 lsame_，接受两个字符指针参数
    extern logical lsame_(char *, char *);
    # 静态变量声明，整数类型，用于存储上一个处理的列索引
    static integer lastc;
    # 外部子程序声明，声明一个子程序 ccopy_，接受五个参数：整数、单精度复数指针、整数、单精度复数指针、整数
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    # 外部子程序声明，声明一个子程序 ctrmm_，接受九个参数：字符、字符、字符、字符、整数、整数、单精度复数指针、单精度复数指针、整数
    extern /* Subroutine */ int ctrmm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *);
    # 静态变量声明，整数类型，用于存储上一个处理的向量索引
    static integer lastv;
    # 外部函数声明，声明一个整数函数 ilaclc_，接受四个参数：整数、整数、单精度复数指针、整数
    extern integer ilaclc_(integer *, integer *, singlecomplex *, integer *);
    # 外部子程序声明，声明一个子程序 clacgv_，接受三个参数：整数、单精度复数指针、整数
    extern /* Subroutine */ int clacgv_(integer *, singlecomplex *, integer *);
    # 外部函数声明，声明一个整数函数 ilaclr_，接受四个参数：整数、整数、单精度复数指针、整数
    extern integer ilaclr_(integer *, integer *, singlecomplex *, integer *);
    # 静态字符数组声明，长度为 1，用于存储转置操作的标志
    static char transt[1];
/*
    Parameter adjustments
*/

// 设置矩阵 V 的维度和偏移量
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;

// 设置矩阵 T 的维度和偏移量
t_dim1 = *ldt;
t_offset = 1 + t_dim1;
t -= t_offset;

// 设置矩阵 C 的维度
c_dim1 = *ldc;
    // 计算 c_offset 的值，c_dim1 是列维度，加一后作为偏移量
    c_offset = 1 + c_dim1;
    // 将 c__ 指针向左偏移 c_offset 个位置，调整起始访问位置
    c__ -= c_offset;
    // 计算 work_dim1，即工作数组的列维度
    work_dim1 = *ldwork;
    // 计算 work_offset，工作数组起始元素的偏移量
    work_offset = 1 + work_dim1;
    // 将 work 指针向左偏移 work_offset 个位置，调整工作数组的起始访问位置
    work -= work_offset;

    /* Function Body */
    // 检查 m 或 n 是否小于等于 0，若是则直接返回
    if (*m <= 0 || *n <= 0) {
        return 0;
    }

    // 检查 trans 是否为 "N"，如果是则将 transt 设置为 'C'，否则设置为 'N'
    if (lsame_(trans, "N")) {
        *(unsigned char *)transt = 'C';
    } else {
        *(unsigned char *)transt = 'N';
    }

    // 检查 storev 是否为 "C"
    if (lsame_(storev, "C")) {

        // 如果 direct 也为 "F"，则执行以下代码块
        if (lsame_(direct, "F")) {
/*
   Let V = (V1)   (first K rows)
            (V2)
   where V1 is unit lower triangular.
*/
if (lsame_(side, "L")) {

/*
   Form H * C or H' * C where C = (C1)
                                  (C2)
   Computing MAX
*/
i__1 = *k, i__2 = ilaclr_(m, k, &v[v_offset], ldv);
lastv = max(i__1, i__2);
lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);

/*
   W := C' * V = (C1'*V1 + C2'*V2) (stored in WORK)
   W := C1'
*/
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    ccopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
    clacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
    /* L10: */
}

/* W := W * V1 */
ctrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k,
       &c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
if (lastv > *k) {

   /* W := W + C2'*V2 */
   i__1 = lastv - *k;
   cgemm_("Conjugate transpose", "No transpose", &lastc, k,
          &i__1, &c_b57, &c__[*k + 1 + c_dim1], ldc, &v[*k + 1 + v_dim1], ldv,
          &c_b57, &work[work_offset], ldwork);
}

/* W := W * T' or W * T */
ctrmm_("Right", "Upper", transt, "Non-unit", &lastc, k,
       &c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/* C := C - V * W' */
if (*m > *k) {

   /* C2 := C2 - V2 * W' */
   i__1 = lastv - *k;
   q__1.r = -1.f, q__1.i = -0.f;
   cgemm_("No transpose", "Conjugate transpose", &i__1, &lastc, k,
          &q__1, &v[*k + 1 + v_dim1], ldv, &work[work_offset], ldwork,
          &c_b57, &c__[*k + 1 + c_dim1], ldc);
}

/* W := W * V1' */
ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &lastc, k,
       &c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);

/* C1 := C1 - W' */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = j + i__ * c_dim1;
        i__4 = j + i__ * c_dim1;
        r_cnjg(&q__2, &work[i__ + j * work_dim1]);
        q__1.r = c__[i__4].r - q__2.r, q__1.i = c__[i__4].i - q__2.i;
        c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
        /* L20: */
    }
    /* L30: */
}

} else if (lsame_(side, "R")) {

/*
   Form C * H or C * H' where C = (C1 C2)
   Computing MAX
*/
i__1 = *k, i__2 = ilaclr_(n, k, &v[v_offset], ldv);
lastv = max(i__1, i__2);
lastc = ilaclr_(m, &lastv, &c__[c_offset], ldc);

/*
   W := C * V = (C1*V1 + C2*V2) (stored in WORK)
   W := C1
*/
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            ccopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
                work_dim1 + 1], &c__1);
/* L40: */
        }


        # 将矩阵 C 的列复制到工作数组 W 中
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            # 调用 ccopy_ 函数，将 C 的第 j 列复制到工作数组 W 的第 j 列
            ccopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
                work_dim1 + 1], &c__1);
/* L40: */
        }



/*              W := W * V1 */
        ctrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);


/*              W := W * V1 */
        # 使用 V1 更新工作数组 W
        ctrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);



        if (lastv > *k) {
/*                 W := W + C2 * V2 */
            i__1 = lastv - *k;
            cgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b57, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
                1 + v_dim1], ldv, &c_b57, &work[work_offset],
                ldwork);
        }


        # 如果 lastv 大于 k
        if (lastv > *k) {
/*                 W := W + C2 * V2 */
            # 执行矩阵乘法，计算 W := W + C2 * V2
            i__1 = lastv - *k;
            cgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b57, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
                1 + v_dim1], ldv, &c_b57, &work[work_offset],
                ldwork);
        }



/*              W := W * T  or  W * T' */
        ctrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);


/*              W := W * T  or  W * T' */
        # 使用 T 对工作数组 W 进行左乘
        ctrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);



/*              C := C - W * V' */
        if (lastv > *k) {
/*                 C2 := C2 - W * V2' */
            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "Conjugate transpose", &lastc, &
                i__1, k, &q__1, &work[work_offset], ldwork, &v[*k
                + 1 + v_dim1], ldv, &c_b57, &c__[(*k + 1) *
                c_dim1 + 1], ldc);
        }


/*              C := C - W * V' */
        # 如果 lastv 大于 k
        if (lastv > *k) {
/*                 C2 := C2 - W * V2' */
            # 执行矩阵乘法，计算 C2 := C2 - W * V2'
            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "Conjugate transpose", &lastc, &
                i__1, k, &q__1, &work[work_offset], ldwork, &v[*k
                + 1 + v_dim1], ldv, &c_b57, &c__[(*k + 1) *
                c_dim1 + 1], ldc);
        }



/*              W := W * V1' */
        ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[v_offset], ldv, &work[
            work_offset], ldwork);


/*              W := W * V1' */
        # 使用 V1 的共轭转置更新工作数组 W
        ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[v_offset], ldv, &work[
            work_offset], ldwork);



/*              C1 := C1 - W */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = i__ + j * c_dim1;
            i__5 = i__ + j * work_dim1;
            q__1.r = c__[i__4].r - work[i__5].r, q__1.i = c__[
                i__4].i - work[i__5].i;
            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L50: */
            }
/* L60: */
        }


/*              C1 := C1 - W */
        # 更新矩阵 C1，使其减去工作数组 W 的值
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * c_dim1;
            i__4 = i__ + j * c_dim1;
            i__5 = i__ + j * work_dim1;
            # 执行矩阵减法操作，更新 C1 的元素值
            q__1.r = c__[i__4].r - work[i__5].r, q__1.i = c__[
                i__4].i - work[i__5].i;
            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L50: */
            }
/* L60: */
        }



        } else {

/*             Let  V =  ( V1 )
                       ( V2 )    (last K rows)
             where  V2  is unit upper triangular.
*/


        } else {

/*             Let  V =  ( V1 )
                       ( V2 )    (last K rows)
             where  V2  is unit upper triangular.
*/
        # 如果 side 不是 "L"，说明是 "R"，表示 V 是分块矩阵的一部分



        if (lsame_(side, "L")) {

/*                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaclr_(m, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);


        if (lsame_(side, "L")) {

/*                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        # 如果 side 是 "L"
        # 计算 lastv 和 lastc 的值，用于后续计算
        i__1 = *k, i__2 = ilaclr_(m, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);



/*
/*              W := W * V2 */

/* 使用 BLAS 函数 ctrmm 对右侧矩阵进行矩阵乘法：W := W * V2 */
        ctrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1'*V1 */

/* 如果 lastv 大于 k，则执行下列矩阵乘法：W := W + C1'*V1 */
            i__1 = lastv - *k;
            cgemm_("Conjugate transpose", "No transpose", &lastc, k, &
                i__1, &c_b57, &c__[c_offset], ldc, &v[v_offset],
                ldv, &c_b57, &work[work_offset], ldwork);
        }

/*              W := W * T'  or  W * T */

/* 使用 BLAS 函数 ctrmm 对右侧矩阵进行矩阵乘法：W := W * T' 或 W * T */
        ctrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
            c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V * W' */

/* 如果 lastv 大于 k，则执行下列矩阵乘法和矩阵减法：C := C - V * W' */
        if (lastv > *k) {

/*                 C1 := C1 - V1 * W' */

/* 使用 BLAS 函数 cgemm 对两个矩阵进行乘法和减法：C1 := C1 - V1 * W' */
            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "Conjugate transpose", &i__1, &
                lastc, k, &q__1, &v[v_offset], ldv, &work[
                work_offset], ldwork, &c_b57, &c__[c_offset], ldc);
        }

/*              W := W * V2' */

/* 使用 BLAS 函数 ctrmm 对右侧矩阵进行矩阵乘法：W := W * V2' */
        ctrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &
            work[work_offset], ldwork);

/*              C2 := C2 - W' */

/* 使用循环结构对矩阵进行逐元素更新：C2 := C2 - W' */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = lastv - *k + j + i__ * c_dim1;
            i__4 = lastv - *k + j + i__ * c_dim1;
            r_cnjg(&q__2, &work[i__ + j * work_dim1]);
            q__1.r = c__[i__4].r - q__2.r, q__1.i = c__[i__4].i -
                q__2.i;
            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L80: */
            }
/* L90: */
        }

        } else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
/* 计算 lastv 和 lastc 的值 */
        i__1 = *k, i__2 = ilaclr_(n, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaclr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

                W := C2
*/

/* 将矩阵 C2 复制到工作区域 W */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            ccopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
                 &work[j * work_dim1 + 1], &c__1);
/* L100: */
        }

/*              W := W * V2 */

/* 使用 BLAS 函数 ctrmm 对右侧矩阵进行矩阵乘法：W := W * V2 */
        ctrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1 * V1 */

/* 如果 lastv 大于 k，则执行下列矩阵乘法：W := W + C1 * V1 */
            i__1 = lastv - *k;
            cgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b57, &c__[c_offset], ldc, &v[v_offset], ldv, &
                c_b57, &work[work_offset], ldwork);
        }
/*              W := W * T  or  W * T' */

        ctrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);
/*
             Perform the matrix multiplication W := W * T or W * T', where:
             - trans determines if T should be transposed or not
             - "Right" specifies that T is multiplied on the right side of W
             - "Lower" indicates that T is lower triangular
             - "Non-unit" specifies that T is non-unit triangular
             - lastc is the number of columns in W
             - k is the order of the triangular matrix T
             - c_b57 is a constant scalar factor
             - t[t_offset] is the triangular matrix T
             - ldt is the leading dimension of the array T
             - work[work_offset] is the workspace array for intermediate results
             - ldwork is the leading dimension of the workspace array
*/

/*              C := C - W * V' */

        if (lastv > *k) {

/*                 C1 := C1 - W * V1' */

            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "Conjugate transpose", &lastc, &
                i__1, k, &q__1, &work[work_offset], ldwork, &v[
                v_offset], ldv, &c_b57, &c__[c_offset], ldc);
/*
             Perform the matrix multiplication C1 := C1 - W * V1', where:
             - "No transpose" indicates that W is not transposed
             - "Conjugate transpose" specifies that V1 should be conjugate transposed
             - lastc is the number of columns in C1
             - i__1 is the number of columns in V1'
             - k is the order of the triangular matrix T
             - q__1.r = -1.f and q__1.i = -0.f represent the scalar factor
             - work[work_offset] is the workspace array for intermediate results
             - ldwork is the leading dimension of the workspace array
             - v[v_offset] is the matrix V
             - ldv is the leading dimension of the array V
             - c_b57 is a constant scalar factor
             - c__[c_offset] is the matrix C
             - ldc is the leading dimension of the array C
*/

        }

/*              W := W * V2' */

        ctrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[lastv - *k + 1 + v_dim1], ldv, &
            work[work_offset], ldwork);
/*
             Perform the matrix multiplication W := W * V2', where:
             - "Right" specifies that V2' is multiplied on the right side of W
             - "Upper" indicates that V2' is upper triangular
             - "Conjugate transpose" specifies that V2 should be conjugate transposed
             - "Unit" indicates that V2 is unit triangular
             - lastc is the number of columns in W
             - k is the order of the triangular matrix T
             - c_b57 is a constant scalar factor
             - v[lastv - *k + 1 + v_dim1] is the matrix V2'
             - ldv is the leading dimension of the array V
             - work[work_offset] is the workspace array for intermediate results
             - ldwork is the leading dimension of the workspace array
*/

/*              C2 := C2 - W */

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + (lastv - *k + j) * c_dim1;
            i__4 = i__ + (lastv - *k + j) * c_dim1;
            i__5 = i__ + j * work_dim1;
            q__1.r = c__[i__4].r - work[i__5].r, q__1.i = c__[
                i__4].i - work[i__5].i;
            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L110: */
            }
/* L120: */
        }
/*
         Update C2 := C2 - W, where:
         - *k is the order of the triangular matrix T
         - lastc is the number of columns in C2
         - lastv is the maximum of *k or ilaclc_(*k, m, &v[v_offset], ldv)
         - c__[c_offset] is the matrix C
         - work[work_offset] is the workspace array for intermediate results
*/

    } else if (lsame_(storev, "R")) {

    if (lsame_(direct, "F")) {

/*
             Let  V =  ( V1  V2 )    (V1: first K columns)
             where  V1  is unit upper triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaclc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);
/*
         Determine the dimensions lastv and lastc for matrix C and V, where:
         - *k is the order of the triangular matrix T
         - m is the number of rows in the matrix H
         - v[v_offset] is the matrix V
         - ldv is the leading dimension of the array V
         - n is the number of columns in the matrix C
         - c__[c_offset] is the matrix C
         - ldc is the leading dimension of the array C
*/

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C1'
*/

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            ccopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1
                + 1], &c__1);
            clacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
/* L130: */
        }
/*
         Compute W := C' * V', where:
         - *k is the order of the triangular matrix T
         - lastc is the number of columns in C1
         - c__[c_offset] is the matrix C
         - work[work_offset] is the workspace array for intermediate results
*/

/*              W := W * V1' */

        ctrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[v_offset], ldv, &work[
            work_offset], ldwork);
/*
         Perform the matrix multiplication W := W * V1', where:
         - "Right" specifies that V1' is multiplied on the right side of W
         - "Upper" indicates that V1' is upper triangular
         - "Conjugate transpose" specifies that V1 should be conjugate transposed
         - "Unit" indicates that V1 is unit triangular
         - lastc is the number of columns in W
         - k is the order of the triangular matrix T
         - c_b57 is a constant scalar factor
         - v[v_offset] is the matrix V
         - ldv is the leading dimension of the array V
         - work[work_offset] is the workspace array for intermediate results
         - ldwork is the leading dimension of the workspace array
*/

        if (lastv > *k) {

/*                 W := W + C2'*V2' */

            i__1 = lastv - *k;
            cgemm_("Conjugate transpose", "Conjugate transpose", &
                lastc, k, &i__1, &c_b57, &c__[*k + 1 + c_dim1],
                ldc, &v[(*k + 1) * v_dim1 + 1], ldv, &c_b57, &
                work[work_offset], ldwork)
                ;
/*
             Perform the matrix multiplication W := W + C2'*V2', where:
             - "Conjugate transpose" specifies that C2 and V2 should be conjugate transposed
             - lastc is the number of columns in C2
             - k is the order of the triangular matrix T
             - i__1 is the number of columns in V2'
             - c_b57 is a constant scalar factor
             - c__[*k + 1 + c_dim1] is the matrix C2
             - ldc is the leading dimension of the array
/*                 C2 := C2 - V2' * W' */

/* 计算数组索引的起始位置 */
i__1 = lastv - *k;
/* 创建复数常量 -1 */
q__1.r = -1.f, q__1.i = -0.f;
/* 执行复数矩阵乘法，计算 C2 = C2 - V2' * W' */
cgemm_("Conjugate transpose", "Conjugate transpose", &
    i__1, &lastc, k, &q__1, &v[(*k + 1) * v_dim1 + 1],
     ldv, &work[work_offset], ldwork, &c_b57, &c__[*k
    + 1 + c_dim1], ldc);

/*              W := W * V1 */

/* 执行复数矩阵乘法，计算 W = W * V1 */
ctrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W' */

/* 循环计算 C1 = C1 - W' */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
    /* 计算复数减法 C1 = C1 - W' */
    i__3 = j + i__ * c_dim1;
    i__4 = j + i__ * c_dim1;
    r_cnjg(&q__2, &work[i__ + j * work_dim1]);
    q__1.r = c__[i__4].r - q__2.r, q__1.i = c__[i__4].i -
        q__2.i;
    c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
    /* L140: */
    }
/* L150: */
}

} else if (lsame_(side, "R")) {

/*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

Computing MAX
*/
i__1 = *k, i__2 = ilaclc_(k, n, &v[v_offset], ldv);
lastv = max(i__1,i__2);
lastc = ilaclr_(m, &lastv, &c__[c_offset], ldc);

/*
        W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

        W := C1
*/

/* 循环将 C1 复制到 W */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    ccopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
        work_dim1 + 1], &c__1);
/* L160: */
}

/*              W := W * V1' */

/* 执行复数矩阵乘法，计算 W = W * V1' */
ctrmm_("Right", "Upper", "Conjugate transpose", "Unit", &
    lastc, k, &c_b57, &v[v_offset], ldv, &work[
    work_offset], ldwork);

if (lastv > *k) {

/*                 W := W + C2 * V2' */

/* 执行复数矩阵乘法，计算 W = W + C2 * V2' */
i__1 = lastv - *k;
cgemm_("No transpose", "Conjugate transpose", &lastc, k, &
    i__1, &c_b57, &c__[(*k + 1) * c_dim1 + 1], ldc, &
    v[(*k + 1) * v_dim1 + 1], ldv, &c_b57, &work[
    work_offset], ldwork);
}

/*              W := W * T  or  W * T' */

/* 执行复数矩阵乘法，计算 W = W * T 或者 W * T' */
ctrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b57,
     &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

if (lastv > *k) {

/*                 C2 := C2 - W * V2 */

/* 执行复数矩阵乘法，计算 C2 = C2 - W * V2 */
i__1 = lastv - *k;
q__1.r = -1.f, q__1.i = -0.f;
cgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
    q__1, &work[work_offset], ldwork, &v[(*k + 1) *
    v_dim1 + 1], ldv, &c_b57, &c__[(*k + 1) * c_dim1
    + 1], ldc);
}

/*              W := W * V1 */

/* 执行复数矩阵乘法，计算 W = W * V1 */
ctrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
    c_b57, &v[v_offset], ldv, &work[work_offset], ldwork);
/*              C1 := C1 - W */

        // 循环遍历每列中的每个元素
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            // 循环遍历每行中的每个元素
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 计算数组索引
                i__3 = i__ + j * c_dim1;
                i__4 = i__ + j * c_dim1;
                i__5 = i__ + j * work_dim1;
                // 计算 C1 的新值，减去相应的 W
                q__1.r = c__[i__4].r - work[i__5].r, q__1.i = c__[
                    i__4].i - work[i__5].i;
                c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
                // 继续处理下一个元素
/* L170: */
            }
/* L180: */
        }

        }

    } else {

/*
             Let  V =  ( V1  V2 )    (V2: last K columns)
             where  V2  is unit lower triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        // 计算 lastv 的值，作为 V 和 C 的维度计算的基础
        i__1 = *k, i__2 = ilaclc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        // 计算 lastc 的值，作为 C 的维度计算的基础
        lastc = ilaclc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C2'
*/

        // 计算 W = C2'
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            // 复制 C2 的内容到 WORK 数组中
            ccopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
            // 对 WORK 中的内容进行共轭操作
            clacgv_(&lastc, &work[j * work_dim1 + 1], &c__1);
/* L190: */
        }

/*              W := W * V2' */

        // 计算 W = W * V2'
        ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[(lastv - *k + 1) * v_dim1 + 1],
            ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1'*V1' */

            // 计算 W = W + C1'*V1'
            i__1 = lastv - *k;
            cgemm_("Conjugate transpose", "Conjugate transpose", &
                lastc, k, &i__1, &c_b57, &c__[c_offset], ldc, &v[
                v_offset], ldv, &c_b57, &work[work_offset],
                ldwork);
        }

/*              W := W * T'  or  W * T */

        // 根据 transt 的值计算 W = W * T' 或者 W * T
        ctrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
            c_b57, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */

        // 计算 C = C - V' * W'
        if (lastv > *k) {

/*                 C1 := C1 - V1' * W' */

            // 计算 C1 = C1 - V1' * W'
            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("Conjugate transpose", "Conjugate transpose", &
                i__1, &lastc, k, &q__1, &v[v_offset], ldv, &work[
                work_offset], ldwork, &c_b57, &c__[c_offset], ldc);
        }

/*              W := W * V2 */

        // 计算 W = W * V2
        ctrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);
/*              C2 := C2 - W' */

/* 计算 C2 = C2 - W' 的操作 */

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            /* 遍历列数为 k 的循环 */
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* 遍历行数为 lastc 的循环 */
                i__3 = lastv - *k + j + i__ * c_dim1;
                i__4 = lastv - *k + j + i__ * c_dim1;
                /* 计算索引位置 */
                r_cnjg(&q__2, &work[i__ + j * work_dim1]);
                /* 对 work 数组中的元素进行共轭 */
                q__1.r = c__[i__4].r - q__2.r, q__1.i = c__[i__4].i -
                    q__2.i;
                /* 计算 C2 中的元素减去共轭后的工作数组元素 */
                c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L200: */
            }
/* L210: */
        }

        } else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = ilaclc_(k, n, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = ilaclr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

                W := C2
*/

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            /* 复制 C2 的内容到工作数组中 */
            ccopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
                 &work[j * work_dim1 + 1], &c__1);
/* L220: */
        }

/*              W := W * V2' */

        /* 计算 W = W * V2' */
        ctrmm_("Right", "Lower", "Conjugate transpose", "Unit", &
            lastc, k, &c_b57, &v[(lastv - *k + 1) * v_dim1 + 1],
            ldv, &work[work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1 * V1' */

            /* 如果 lastv > k，则计算 W = W + C1 * V1' */
            i__1 = lastv - *k;
            cgemm_("No transpose", "Conjugate transpose", &lastc, k, &
                i__1, &c_b57, &c__[c_offset], ldc, &v[v_offset],
                ldv, &c_b57, &work[work_offset], ldwork);
        }

/*              W := W * T  or  W * T' */

        /* 计算 W = W * T 或者 W * T' */
        ctrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b57,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

        /* 计算 C = C - W * V */
        if (lastv > *k) {

/*                 C1 := C1 - W * V1 */

            /* 如果 lastv > k，则计算 C1 = C1 - W * V1 */
            i__1 = lastv - *k;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
                q__1, &work[work_offset], ldwork, &v[v_offset],
                ldv, &c_b57, &c__[c_offset], ldc);
        }

/*              W := W * V2 */

        /* 计算 W = W * V2 */
        ctrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
            c_b57, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);

/*              C1 := C1 - W */

        /* 计算 C1 = C1 - W */
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            /* 遍历列数为 k 的循环 */
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* 遍历行数为 lastc 的循环 */
                i__3 = i__ + (lastv - *k + j) * c_dim1;
                i__4 = i__ + (lastv - *k + j) * c_dim1;
                i__5 = i__ + j * work_dim1;
                /* 计算 C1 中的元素减去工作数组中的元素 */
                q__1.r = c__[i__4].r - work[i__5].r, q__1.i = c__[
                    i__4].i - work[i__5].i;
                c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
/* L230: */
            }
/* L240: */
        }

        }

    }
    }

    return 0;

/*     End of CLARFB */

} /* clarfb_ */
/* Subroutine */ int clarfg_(integer *n, singlecomplex *alpha, singlecomplex *x, integer *
    incx, singlecomplex *tau)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2;
    singlecomplex q__1, q__2;

    /* Local variables */
    static integer j, knt;
    static real beta;
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *);
    static real alphi, alphr, xnorm;
    extern doublereal scnrm2_(integer *, singlecomplex *, integer *), slapy3_(real *
        , real *, real *);
    extern /* Complex */ VOID cladiv_(singlecomplex *, singlecomplex *, singlecomplex *);
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
        *);
    static real safmin, rsafmn;


    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006


        Purpose
        =======

        CLARFG generates a complex elementary reflector H of order n, such
        that

              H' * ( alpha ) = ( beta ),   H' * H = I.
                   (   x   )   (   0  )

        where alpha and beta are scalars, with beta real, and x is an
        (n-1)-element complex vector. H is represented in the form

              H = I - tau * ( 1 ) * ( 1 v' ) ,
                            ( v )

        where tau is a complex scalar and v is a complex (n-1)-element
        vector. Note that H is not hermitian.

        If the elements of x are all zero and alpha is real, then tau = 0
        and H is taken to be the unit matrix.

        Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .

        Arguments
        =========

        N       (input) INTEGER
                The order of the elementary reflector.

        ALPHA   (input/output) COMPLEX
                On entry, the value alpha.
                On exit, it is overwritten with the value beta.

        X       (input/output) COMPLEX array, dimension
                               (1+(N-2)*abs(INCX))
                On entry, the vector x.
                On exit, it is overwritten with the vector v.

        INCX    (input) INTEGER
                The increment between elements of X. INCX > 0.

        TAU     (output) COMPLEX
                The value tau.

        =====================================================================
    */


    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 0) {
        /* If N is less than or equal to 0, set tau to zero and return */
        tau->r = 0.f, tau->i = 0.f;
        return 0;
    }

    /* Compute the Euclidean norm of the vector x */
    i__1 = *n - 1;
    xnorm = scnrm2_(&i__1, &x[1], incx);
    alphr = alpha->r;
    alphi = r_imag(alpha);

    if (xnorm == 0.f && alphi == 0.f) {
        /* If xnorm is zero and imaginary part of alpha is zero, set tau to zero */
        tau->r = 0.f, tau->i = 0.f;
    } else {
        /* General case where xnorm is non-zero or alpha has non-zero imaginary part */

        /* Compute beta */
        r__1 = slapy3_(&alphr, &alphi, &xnorm);
        beta = -r_sign(&r__1, &alphr);

        /* Compute safe minimum */
        safmin = slamch_("S") / slamch_("E");
        rsafmn = 1.f / safmin;

        knt = 0;
        if (dabs(beta) < safmin) {
            /* If beta is less than the safe minimum, adjust it */

            /* If beta is less than the safe minimum, adjust it */
/*           XNORM, BETA may be inaccurate; scale X and recompute them */

L10:
        ++knt;  // 增加计数器 knt
        i__1 = *n - 1;  // 计算 *n - 1，表示数组 x 的长度
        csscal_(&i__1, &rsafmn, &x[1], incx);  // 调用 csscal 函数，对数组 x 进行按比例缩放
        beta *= rsafmn;  // 更新 beta 值
        alphi *= rsafmn;  // 更新 alphi 值
        alphr *= rsafmn;  // 更新 alphr 值
        if (dabs(beta) < safmin) {  // 检查 beta 的绝对值是否小于 safmin
        goto L10;  // 如果是，则跳转到标签 L10 继续执行
        }

/*           New BETA is at most 1, at least SAFMIN */

        i__1 = *n - 1;  // 计算 *n - 1，表示数组 x 的长度
        xnorm = scnrm2_(&i__1, &x[1], incx);  // 调用 scnrm2 函数，计算数组 x 的 2-范数
        q__1.r = alphr, q__1.i = alphi;  // 构造复数 q__1，用 alphr 和 alphi 初始化其实部和虚部
        alpha->r = q__1.r, alpha->i = q__1.i;  // 将 q__1 复制给 alpha
        r__1 = slapy3_(&alphr, &alphi, &xnorm);  // 调用 slapy3 函数，计算三个数的平方和的平方根
        beta = -r_sign(&r__1, &alphr);  // 更新 beta 的值
    }
    r__1 = (beta - alphr) / beta;  // 计算 (beta - alphr) / beta 的值
    r__2 = -alphi / beta;  // 计算 -alphi / beta 的值
    q__1.r = r__1, q__1.i = r__2;  // 构造复数 q__1，用 r__1 和 r__2 初始化其实部和虚部
    tau->r = q__1.r, tau->i = q__1.i;  // 将 q__1 复制给 tau
    q__2.r = alpha->r - beta, q__2.i = alpha->i;  // 构造复数 q__2，用 alpha->r - beta 和 alpha->i 初始化其实部和虚部
    cladiv_(&q__1, &c_b57, &q__2);  // 调用 cladiv 函数，计算两个复数的商并将结果复制给 q__1
    alpha->r = q__1.r, alpha->i = q__1.i;  // 将 q__1 复制给 alpha
    i__1 = *n - 1;  // 计算 *n - 1，表示数组 x 的长度
    cscal_(&i__1, alpha, &x[1], incx);  // 调用 cscal 函数，对数组 x 进行按复数 alpha 缩放

/*        If ALPHA is subnormal, it may lose relative accuracy */

    i__1 = knt;  // 将计数器 knt 赋给 i__1
    for (j = 1; j <= i__1; ++j) {  // 循环执行 knt 次
        beta *= safmin;  // 更新 beta 的值
/* L20: */
    }
    alpha->r = beta, alpha->i = 0.f;  // 将 beta 赋给 alpha（作为实数），虚部置为 0

    return 0;

/*     End of CLARFG */

} /* clarfg_ */

/* Subroutine */ int clarft_(char *direct, char *storev, integer *n, integer *
    k, singlecomplex *v, integer *ldv, singlecomplex *tau, singlecomplex *t, integer *ldt)
{
    /* System generated locals */
    integer t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3, i__4;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, prevlastv;
    static singlecomplex vii;
    extern /* Subroutine */ int cgemv_(char *, integer *, integer *, singlecomplex *
        , singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *);
    extern logical lsame_(char *, char *);
    static integer lastv;
    extern /* Subroutine */ int ctrmv_(char *, char *, char *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *), clacgv_(integer *, singlecomplex *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLARFT forms the triangular factor T of a complex block reflector H
    of order n, which is defined as a product of k elementary reflectors.

    If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

    If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

    If STOREV = 'C', the vector which defines the elementary reflector
    H(i) is stored in the i-th column of the array V, and

       H  =  I - V * T * V'

    If STOREV = 'R', the vector which defines the elementary reflector
    H(i) is stored in the i-th row of the array V, and

       H  =  I - V' * T * V

    Arguments
    =========
*/
    # 指定用于形成块反射器的基本反射器的顺序
    DIRECT  (input) CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)

    # 指定定义基本反射器的向量如何存储
    STOREV  (input) CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise

    # 块反射器 H 的阶数
    N       (input) INTEGER
            The order of the block reflector H. N >= 0.

    # 三角因子 T 的阶数（即基本反射器的数量）
    K       (input) INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.

    # 矩阵 V，存储基本反射器的向量
    V       (input/output) COMPLEX array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.

    # 矩阵 V 的主维度
    LDV     (input) INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.

    # 基本反射器 H 的标量因子数组
    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).

    # 块反射器 H 的 k x k 三角因子 T
    T       (output) COMPLEX array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.

    # 数组 T 的主维度
    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= K.

    Further Details
    ===============

    The shape of the matrix V and the storage of the vectors which define
    the H(i) is best illustrated by the following example with n = 5 and
    k = 3. The elements equal to 1 are not stored; the corresponding
    array elements are modified but restored on exit. The rest of the
    array is not used.

    DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                 V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                     ( v1  1    )                     (     1 v2 v2 v2 )
                     ( v1 v2  1 )                     (        1 v3 v3 )
                     ( v1 v2 v3 )
                     ( v1 v2 v3 )

    DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                 V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                     ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                     (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                     (     1 v3 )
                     (        1 )

    =====================================================================


       Quick return if possible
    /* 参数调整 */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;  // 调整 v 数组的起始位置为 v_offset 处
    --tau;          // 将 tau 数组的起始位置向前移动一个位置
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;  // 调整 t 数组的起始位置为 t_offset 处

    /* 函数体 */
    if (*n == 0) {
        return 0;   // 如果 n 为 0，直接返回
    }

    if (lsame_(direct, "F")) {  // 如果 direct 参数为 "F"
        prevlastv = *n;         // 设置 prevlastv 为 n
        i__1 = *k;
        for (i__ = 1; i__ <= i__1; ++i__) {  // 循环 k 次，每次递增 i__
            prevlastv = max(prevlastv,i__);  // 更新 prevlastv 为 prevlastv 和 i__ 中的较大者
            i__2 = i__;
            if (tau[i__2].r == 0.f && tau[i__2].i == 0.f) {

/*              H(i)  =  I */

                i__2 = i__;
                for (j = 1; j <= i__2; ++j) {  // 循环 j 从 1 到 i__
                    i__3 = j + i__ * t_dim1;
                    t[i__3].r = 0.f, t[i__3].i = 0.f;  // 将 t(i,j) 设置为零
                }
            } else {

/*              一般情况 */

                i__2 = i__ + i__ * v_dim1;
                vii.r = v[i__2].r, vii.i = v[i__2].i;  // 复制 v(i,i) 到 vii
                i__2 = i__ + i__ * v_dim1;
                v[i__2].r = 1.f, v[i__2].i = 0.f;  // 设置 v(i,i) 为单位复数值 1

                if (lsame_(storev, "C")) {  // 如果 storev 参数为 "C"，列主存储方式
/*                 跳过任何后续的零元素。 */
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {  // 从 *n 向 i__+1 遍历 lastv
                        i__3 = lastv + i__ * v_dim1;
                        if (v[i__3].r != 0.f || v[i__3].i != 0.f) {  // 如果 v(i,lastv) 不为零
                            goto L15;  // 跳转到标签 L15
                        }
                    }
L15:
                    j = min(lastv,prevlastv);  // j 设置为 lastv 和 prevlastv 中的较小者

/*                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)' * V(i:j,i) */

                    i__2 = j - i__ + 1;  // 计算 V 的列数
                    i__3 = i__ - 1;     // 计算 V 的行数
                    i__4 = i__;
                    q__1.r = -tau[i__4].r, q__1.i = -tau[i__4].i;  // 计算 -tau(i__)
                    cgemv_("Conjugate transpose", &i__2, &i__3, &q__1, &v[i__
                        + v_dim1], ldv, &v[i__ + i__ * v_dim1], &c__1, &
                        c_b56, &t[i__ * t_dim1 + 1], &c__1);  // 执行矩阵向量乘法
                } else {  // 如果 storev 参数为 "R"，行主存储方式
/*                 跳过任何后续的零元素。 */
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {  // 从 *n 向 i__+1 遍历 lastv
                        i__3 = i__ + lastv * v_dim1;
                        if (v[i__3].r != 0.f || v[i__3].i != 0.f) {  // 如果 v(lastv,i) 不为零
                            goto L16;  // 跳转到标签 L16
                        }
                    }
L16:
                    j = min(lastv,prevlastv);  // j 设置为 lastv 和 prevlastv 中的较小者

/*                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)' */

                    if (i__ < j) {  // 如果 i 小于 j
                        i__2 = j - i__;
                        clacgv_(&i__2, &v[i__ + (i__ + 1) * v_dim1], ldv);  // 共轭转置 V 的一部分
                    }
                    i__2 = i__ - 1;  // 计算 T 的行数
                    i__3 = j - i__ + 1;  // 计算 V 的列数
                    i__4 = i__;
                    q__1.r = -tau[i__4].r, q__1.i = -tau[i__4].i;  // 计算 -tau(i__)
                    cgemv_("No transpose", &i__2, &i__3, &q__1, &v[i__ *
                        v_dim1 + 1], ldv, &v[i__ + i__ * v_dim1], ldv, &
                        c_b56, &t[i__ * t_dim1 + 1], &c__1);  // 执行矩阵向量乘法
                    if (i__ < j) {  // 如果 i 小于 j
                        i__2 = j - i__;
                        clacgv_(&i__2, &v[i__ + (i__ + 1) * v_dim1], ldv);  // 恢复 V 的共轭转置
                    }
                }
                i__2 = i__ + i__ * v_dim1;
                v[i__2].r = vii.r, v[i__2].i = vii.i;  // 恢复 v(i,i) 的原始值
                // 继续下一个 i__
/*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) */
/*              将矩阵 T 的第 i 列的上半部分更新为 T 的前 i-1 列与 T 的第 i 列的乘积 */

        i__2 = i__ - 1;
        ctrmv_("Upper", "No transpose", "Non-unit", &i__2, &t[
            t_offset], ldt, &t[i__ * t_dim1 + 1], &c__1);
        /* 调用 BLAS 库函数 ctrmv 执行矩阵向量乘法，更新 T 的第 i 列 */
        i__2 = i__ + i__ * t_dim1;
        i__3 = i__;
        t[i__2].r = tau[i__3].r, t[i__2].i = tau[i__3].i;
        /* 将 tau[i] 的值赋给 T 的第 i 行第 i 列元素 */

        if (i__ > 1) {
            prevlastv = max(prevlastv,lastv);
        } else {
            prevlastv = lastv;
        }
        /* 更新 prevlastv 变量的值，用于下一次迭代 */

/* L20: */
    }
    } else {
    prevlastv = 1;
    /* 初始化 prevlastv 变量的值为 1 */

    for (i__ = *k; i__ >= 1; --i__) {
        i__1 = i__;
        if (tau[i__1].r == 0.f && tau[i__1].i == 0.f) {

/*              H(i)  =  I */
/*              若 tau[i] 为 0，则将矩阵 H 的第 i 行的元素设为单位阵 */

        i__1 = *k;
        for (j = i__; j <= i__1; ++j) {
            i__2 = j + i__ * t_dim1;
            t[i__2].r = 0.f, t[i__2].i = 0.f;
/* L30: */
        }
        } else {

/*              general case */
/*              一般情况 */

        if (i__ < *k) {
            if (lsame_(storev, "C")) {
            i__1 = *n - *k + i__ + i__ * v_dim1;
            vii.r = v[i__1].r, vii.i = v[i__1].i;
            i__1 = *n - *k + i__ + i__ * v_dim1;
            v[i__1].r = 1.f, v[i__1].i = 0.f;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                i__2 = lastv + i__ * v_dim1;
                if (v[i__2].r != 0.f || v[i__2].i != 0.f) {
                goto L35;
                }
            }
L35:
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(j:n-k+i,i+1:k)' * V(j:n-k+i,i)
*/
/*              根据公式更新 T 的子矩阵，涉及矩阵乘法和向量转置 */

            i__1 = *n - *k + i__ - j + 1;
            i__2 = *k - i__;
            i__3 = i__;
            q__1.r = -tau[i__3].r, q__1.i = -tau[i__3].i;
            cgemv_("Conjugate transpose", &i__1, &i__2, &q__1, &v[
                j + (i__ + 1) * v_dim1], ldv, &v[j + i__ *
                v_dim1], &c__1, &c_b56, &t[i__ + 1 + i__ *
                t_dim1], &c__1);
            i__1 = *n - *k + i__ + i__ * v_dim1;
            v[i__1].r = vii.r, v[i__1].i = vii.i;
            } else {
            i__1 = i__ + (*n - *k + i__) * v_dim1;
            vii.r = v[i__1].r, vii.i = v[i__1].i;
            i__1 = i__ + (*n - *k + i__) * v_dim1;
            v[i__1].r = 1.f, v[i__1].i = 0.f;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            for (lastv = 1; lastv <= i__1; ++lastv) {
                i__2 = i__ + lastv * v_dim1;
                if (v[i__2].r != 0.f || v[i__2].i != 0.f) {
                goto L36;
                }
            }
L36:
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)'
*/
/*              根据公式更新 T 的子矩阵，涉及矩阵乘法和向量转置 */
            i__1 = *n - *k + i__ - 1 - j + 1;
            clacgv_(&i__1, &v[i__ + j * v_dim1], ldv);
            // 调用 LAPACK 函数 clacgv，对 v[i__ + j * v_dim1] 进行共轭变换

            i__1 = *k - i__;
            i__2 = *n - *k + i__ - j + 1;
            i__3 = i__;
            q__1.r = -tau[i__3].r, q__1.i = -tau[i__3].i;
            // 计算复数的相反数
            cgemv_("No transpose", &i__1, &i__2, &q__1, &v[i__ +
                1 + j * v_dim1], ldv, &v[i__ + j * v_dim1],
                ldv, &c_b56, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            // 调用 BLAS 函数 cgemv，执行矩阵-向量乘法操作

            i__1 = *n - *k + i__ - 1 - j + 1;
            clacgv_(&i__1, &v[i__ + j * v_dim1], ldv);
            // 再次调用 LAPACK 函数 clacgv，对 v[i__ + j * v_dim1] 进行共轭变换

            i__1 = i__ + (*n - *k + i__) * v_dim1;
            v[i__1].r = vii.r, v[i__1].i = vii.i;
            // 将 vii 赋值给 v[i__ + (*n - *k + i__) * v_dim1]
            }

/*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) */

            i__1 = *k - i__;
            ctrmv_("Lower", "No transpose", "Non-unit", &i__1, &t[i__
                + 1 + (i__ + 1) * t_dim1], ldt, &t[i__ + 1 + i__ *
                 t_dim1], &c__1)
                ;
            // 调用 BLAS 函数 ctrmv，执行矩阵-向量乘法操作

            if (i__ > 1) {
            prevlastv = min(prevlastv,lastv);
            // 如果 i__ 大于 1，则将 prevlastv 设置为 prevlastv 和 lastv 的最小值
            } else {
            prevlastv = lastv;
            // 如果 i__ 等于 1，则将 prevlastv 设置为 lastv
            }
        }
        i__1 = i__ + i__ * t_dim1;
        i__2 = i__;
        t[i__1].r = tau[i__2].r, t[i__1].i = tau[i__2].i;
        // 将 tau[i__2] 赋值给 t[i__ + i__ * t_dim1]
        }
/* L40: */
    }
    }
    return 0;

/*     End of CLARFT */

} /* clarft_ */

/* Subroutine */ int clartg_(singlecomplex *f, singlecomplex *g, real *cs, singlecomplex *sn,
    singlecomplex *r__)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2, r__3, r__4, r__5, r__6, r__7, r__8, r__9, r__10;
    singlecomplex q__1, q__2, q__3;

    /* Local variables */
    static real d__;
    static integer i__;
    static real f2, g2;
    static singlecomplex ff;
    static real di, dr;
    static singlecomplex fs, gs;
    static real f2s, g2s, eps, scale;
    static integer count;
    static real safmn2, safmx2;
    extern doublereal slapy2_(real *, real *), slamch_(char *);
    static real safmin;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLARTG generates a plane rotation so that

       [  CS  SN  ]     [ F ]     [ R ]
       [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
       [ -SN  CS  ]     [ G ]     [ 0 ]

    This is a faster version of the BLAS1 routine CROTG, except for
    the following differences:
       F and G are unchanged on return.
       If G=0, then CS=1 and SN=0.
       If F=0, then CS=0 and SN is chosen so that R is real.

    Arguments
    =========

    F       (input) COMPLEX
            The first component of vector to be rotated.

    G       (input) COMPLEX
            The second component of vector to be rotated.

    CS      (output) REAL
            The cosine of the rotation.

    SN      (output) COMPLEX
            The sine of the rotation.


注释：
    # 输出参数，COMPLEX 类型，表示旋转后向量的非零分量
    R       (output) COMPLEX
            The nonzero component of the rotated vector.

    # 进一步细节说明
    Further Details
    ======= =======

    # 1996年3月5日 - W. Kahan 和 J. Demmel 修改的新算法

    # 本版本中有几个语句被注释以保证线程安全
    (machine parameters are computed on each entry). 10 feb 03, SJH.

    =====================================================================

       # 逻辑变量，用于标记是否是首次进入该代码段
       LOGICAL            FIRST
       # 声明被保存的变量：FIRST, SAFMX2, SAFMIN, SAFMN2
       SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
       # 初始化 FIRST 变量为真
       DATA               FIRST / .TRUE. /

       # 如果是首次进入
       IF( FIRST ) THEN
/*
    获取机器精度中的最小安全数（safmin），使用外部函数slamch_获取
    获取机器精度中的最小正数（eps），使用外部函数slamch_获取
    获取机器基数（r__1），使用外部函数slamch_获取
    计算安全数的平方根（safmn2），通过计算 safmin / eps 的对数和 r__1 的对数的一半次方得到
    计算安全数的倒数（safmx2），即 1 / safmn2
*/
    safmin = slamch_("S");
    eps = slamch_("E");
    r__1 = slamch_("B");
    i__1 = (integer) (log(safmin / eps) / log(slamch_("B")) / 2.f);
    safmn2 = pow_ri(&r__1, &i__1);
    safmx2 = 1.f / safmn2;
/*
    初始化 FIRST 为 FALSE
*/
          FIRST = .FALSE.
/*
    计算向量 f 和 g 的模的最大值
    计算实部和虚部的绝对值
*/
    r__7 = (r__1 = f->r, dabs(r__1)), r__8 = (r__2 = r_imag(f), dabs(r__2));
/* 计算最大值 */
    r__9 = (r__3 = g->r, dabs(r__3)), r__10 = (r__4 = r_imag(g), dabs(r__4));
    r__5 = dmax(r__7,r__8), r__6 = dmax(r__9,r__10);
    scale = dmax(r__5,r__6);
    fs.r = f->r, fs.i = f->i;
    gs.r = g->r, gs.i = g->i;
    count = 0;
    if (scale >= safmx2) {
L10:
    ++count;
/*
    对 f 和 g 进行缩放，直到 scale 小于 safmx2
*/
    q__1.r = safmn2 * fs.r, q__1.i = safmn2 * fs.i;
    fs.r = q__1.r, fs.i = q__1.i;
    q__1.r = safmn2 * gs.r, q__1.i = safmn2 * gs.i;
    gs.r = q__1.r, gs.i = q__1.i;
    scale *= safmn2;
    if (scale >= safmx2) {
        goto L10;
    }
    } else if (scale <= safmn2) {
/*
    如果 scale 小于等于 safmn2
*/
    if (g->r == 0.f && g->i == 0.f) {
/*
    如果 g 为零向量，设置 cs 为 1，sn 为零向量，r__ 为 f，然后返回 0
*/
        *cs = 1.f;
        sn->r = 0.f, sn->i = 0.f;
        r__->r = f->r, r__->i = f->i;
        return 0;
    }
L20:
/*
    如果 scale 大于等于 safmx2
*/
    --count;
    q__1.r = safmx2 * fs.r, q__1.i = safmx2 * fs.i;
    fs.r = q__1.r, fs.i = q__1.i;
    q__1.r = safmx2 * gs.r, q__1.i = safmx2 * gs.i;
    gs.r = q__1.r, gs.i = q__1.i;
    scale *= safmx2;
    if (scale <= safmn2) {
        goto L20;
    }
    }
/* 计算 fs 和 gs 的模的平方 */
    r__1 = fs.r;
    r__2 = r_imag(&fs);
    f2 = r__1 * r__1 + r__2 * r__2;
    r__1 = gs.r;
    r__2 = r_imag(&gs);
/* 计算 gs 的模的平方 */
    g2 = r__1 * r__1 + r__2 * r__2;
    if (f2 <= dmax(g2,1.f) * safmin) {
/*
    如果 f 的模的平方小于等于 g 的模的平方乘以 safmin
*/
/* This is a rare case: F is very small. */
/*
    如果 f 是一个非常小的数，f 的实部和虚部都为零
*/
    if (f->r == 0.f && f->i == 0.f) {
/*
    设置 cs 为 0，计算 g 的模，设置 r__ 为 g 的模，然后返回
*/
        *cs = 0.f;
        r__2 = g->r;
        r__3 = r_imag(g);
        r__1 = slapy2_(&r__2, &r__3);
        r__->r = r__1, r__->i = 0.f;
/* 使用两个实数除法计算复数除法 */
        r__1 = gs.r;
        r__2 = r_imag(&gs);
        d__ = slapy2_(&r__1, &r__2);
        r__1 = gs.r / d__;
        r__2 = -r_imag(&gs) / d__;
        q__1.r = r__1, q__1.i = r__2;
        sn->r = q__1.r, sn->i = q__1.i;
        return 0;
    }
    r__1 = fs.r;
    r__2 = r_imag(&fs);
/* 计算 f 的模 */
    f2s = slapy2_(&r__1, &r__2);
/*
    计算 gs 的模
    g2s 至少为 safmn2
*/
    g2s = sqrt(g2);
/*
    CS 的误差由 f2s 的下溢引起，最多为 sqrt(UNFL*EPS) < EPS
    如果 MAX(G2,ONE)=G2，则 F2 < G2*SAFMIN，因此 CS < sqrt(SAFMIN)
    如果 MAX(G2,ONE)=ONE，则 F2 < SAFMIN，因此 CS < sqrt(SAFMIN)/SAFMN2 = sqrt(EPS)
    因此，CS = F2S / G2S / sqrt( 1 + (F2S / G2S)**2 ) = F2S / G2S
*/
    *cs = f2s / g2s;
/*
    确保 abs(FF) = 1
    使用两个实数除法计算复数除法
*/
    if (dabs(fs.r) <= dabs(fs.i)) {
/*
    计算 fs 的最大模
*/
    } else {
/*
    计算 fs 的最大模
*/
    }
    r__3 = (r__1 = f->r, dabs(r__1)), r__4 = (r__2 = r_imag(f), dabs(r__2)
        );
    // 计算复数 f 的实部和虚部的绝对值
    if (dmax(r__3,r__4) > 1.f) {
        // 如果实部或虚部的绝对值中最大的一个大于 1，进行归一化处理
        r__1 = f->r;
        r__2 = r_imag(f);
        // 计算复数 f 的模长
        d__ = slapy2_(&r__1, &r__2);
        // 对 f 进行归一化处理，得到归一化后的复数 ff
        r__1 = f->r / d__;
        r__2 = r_imag(f) / d__;
        q__1.r = r__1, q__1.i = r__2;
        ff.r = q__1.r, ff.i = q__1.i;
    } else {
        // 如果实部和虚部的绝对值均不大于 1，直接进行缩放处理
        dr = safmx2 * f->r;
        di = safmx2 * r_imag(f);
        // 计算缩放后的复数模长
        d__ = slapy2_(&dr, &di);
        // 对缩放后的复数进行归一化处理，得到归一化后的复数 ff
        r__1 = dr / d__;
        r__2 = di / d__;
        q__1.r = r__1, q__1.i = r__2;
        ff.r = q__1.r, ff.i = q__1.i;
    }
    // 计算复数 ff 与复数 gs/g2s 的乘积，并赋值给 sn
    r__1 = gs.r / g2s;
    r__2 = -r_imag(&gs) / g2s;
    q__2.r = r__1, q__2.i = r__2;
    q__1.r = ff.r * q__2.r - ff.i * q__2.i, q__1.i = ff.r * q__2.i + ff.i
        * q__2.r;
    sn->r = q__1.r, sn->i = q__1.i;
    // 计算 cs 与复数 f 的乘积，并加上 sn 与复数 g 的乘积，赋值给 r__
    q__2.r = *cs * f->r, q__2.i = *cs * f->i;
    q__3.r = sn->r * g->r - sn->i * g->i, q__3.i = sn->r * g->i + sn->i *
        g->r;
    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
    r__->r = q__1.r, r__->i = q__1.i;
    } else {
/*
    This subroutine CLASCL is part of LAPACK (version 3.2) and is used to scale
    a complex matrix A by a real scalar CTO/CFROM, ensuring no over/underflow.
    It handles various matrix types such as full, upper triangular, lower triangular,
    upper Hessenberg, or banded matrices.
*/

/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
singlecomplex q__1;

/* Local variables */
static integer i__, j, k1, k2, k3, k4;
static real mul, cto1;
static logical done;
static real ctoc;
extern logical lsame_(char *, char *);
static integer itype;
static real cfrom1;
extern doublereal slamch_(char *);
static real cfromc;
extern /* Subroutine */ int xerbla_(char *, integer *);
static real bignum;
extern logical sisnan_(real *);
static real smlnum;

/*
    Initialize parameters and constants related to numerical precision
*/

/*
    SLAMCH is a LAPACK function used to determine machine-specific parameters,
    such as the relative machine precision (EPS) and the overflow threshold (OVFL).
*/

/*
    Perform type checking and transformation based on the TYPE parameter
*/

/*
    Handle the general case of scaling a full matrix A
*/

/*
    Handle the case of an upper triangular matrix A
*/

/*
    Handle the case of a lower triangular matrix A
*/

/*
    Handle the case of an upper Hessenberg matrix A
*/

/*
    Handle the case of a general band matrix A
*/

/*
    If the matrix type is unrecognized, raise an error using XERBLA
*/

/*
    Return 0 to indicate successful execution of CLASCL
*/

/* End of CLASCL */
} /* clartg_ */

/* Subroutine */ int clascl_(char *type__, integer *kl, integer *ku, real *
    cfrom, real *cto, integer *m, integer *n, singlecomplex *a, integer *lda,
    integer *info)
{
    ! 定义输入参数的数据类型，指定 A 矩阵的存储类型：
    TYPE    (input) CHARACTER*1
            TYPE indices the storage type of the input matrix.
            = 'G':  A is a full matrix.
            = 'L':  A is a lower triangular matrix.
            = 'U':  A is an upper triangular matrix.
            = 'H':  A is an upper Hessenberg matrix.
            = 'B':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the lower
                    half stored.
            = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the upper
                    half stored.
            = 'Z':  A is a band matrix with lower bandwidth KL and upper
                    bandwidth KU.

    ! 若 TYPE 为 'B', 'Q', 或 'Z'，则引用以下两个参数：
    KL      (input) INTEGER
            The lower bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.

    KU      (input) INTEGER
            The upper bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.

    ! CTO 和 CFROM 用于缩放矩阵 A，确保没有溢出或下溢：
    CFROM   (input) REAL
    CTO     (input) REAL
            The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
            without over/underflow if the final result CTO*A(I,J)/CFROM
            can be represented without over/underflow.  CFROM must be
            nonzero.

    ! M 和 N 分别是矩阵 A 的行数和列数，必须满足非负条件：
    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    ! A 是要进行乘法操作的复数数组，其维度为 (LDA, N)：
    A       (input/output) COMPLEX array, dimension (LDA,N)
            The matrix to be multiplied by CTO/CFROM.  See TYPE for the
            storage type.

    ! LDA 是 A 数组的第一维度长度，至少应为 M 的值：
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    ! INFO 是输出参数，表示函数执行状态：
    INFO    (output) INTEGER
            0  - successful exit
            <0 - if INFO = -i, the i-th argument had an illegal value.

    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;

    if (lsame_(type__, "G")) {
        itype = 0;
    } else if (lsame_(type__, "L")) {
        itype = 1;
    } else if (lsame_(type__, "U")) {
        itype = 2;
    } else if (lsame_(type__, "H")) {
        itype = 3;
    } else if (lsame_(type__, "B")) {
        itype = 4;
    } else if (lsame_(type__, "Q")) {
        itype = 5;
    } else if (lsame_(type__, "Z")) {
        itype = 6;
    } else {
        itype = -1;
    }

    if (itype == -1) {
        *info = -1;
    } else if (*cfrom == 0.f || sisnan_(cfrom)) {
        *info = -4;
    } else if (sisnan_(cto)) {
        *info = -5;
    } else if (*m < 0) {
        *info = -6;
    } else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m) {
        *info = -7;
    } else if (itype <= 3 && *lda < max(1,*m)) {
        *info = -9;
    } else if (itype >= 4) {
        /* Computing MAX */
        i__1 = *m - 1;
        if (*kl < 0 || *kl > max(i__1,0)) {
            *info = -2;
        } else {
            /* Computing MAX */
            i__1 = *n - 1;
            if (*ku < 0 || *ku > max(i__1,0) || (itype == 4 || itype == 5) &&
                *kl != *ku) {
                *info = -3;
            } else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *
                ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1) {
                *info = -9;
            }
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CLASCL", &i__1);
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *m == 0) {
        return 0;
    }

/*     Get machine parameters */

    smlnum = slamch_("S");
    bignum = 1.f / smlnum;

    cfromc = *cfrom;
    ctoc = *cto;

L10:
    cfrom1 = cfromc * smlnum;
    if (cfrom1 == cfromc) {
        /*
          CFROMC is an inf.  Multiply by a correctly signed zero for
          finite CTOC, or a NaN if CTOC is infinite.
        */
        mul = ctoc / cfromc;
        done = TRUE_;
        cto1 = ctoc;
    } else {
        cto1 = ctoc / bignum;
        if (cto1 == ctoc) {
            /*
             CTOC is either 0 or an inf.  In both cases, CTOC itself
             serves as the correct multiplication factor.
            */
            mul = ctoc;
            done = TRUE_;
            cfromc = 1.f;
        } else if (dabs(cfrom1) > dabs(ctoc) && ctoc != 0.f) {
            mul = smlnum;
            done = FALSE_;
            cfromc = cfrom1;
        } else if (dabs(cto1) > dabs(cfromc)) {
            mul = bignum;
            done = FALSE_;
            ctoc = cto1;
        } else {
            mul = ctoc / cfromc;
            done = TRUE_;
        }
    }

    if (itype == 0) {
        /* Full matrix */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                i__4 = i__ + j * a_dim1;
                q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                /* L20: */
            }
            /* L30: */
        }
    } else if (itype == 1) {
        /* Lower triangular matrix */
    i__1 = *n;
    # 循环变量 j 的范围是从 1 到 *n
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        # 循环变量 i__ 的范围是从 j 到 *m
        for (i__ = j; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            i__4 = i__ + j * a_dim1;
            # 计算新的复数值，乘以 mul
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            # 将计算结果赋值给数组 a 的相应元素
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L40: */
        }
/* L50: */
    }

    } else if (itype == 2) {

/*        Upper triangular matrix */

    i__1 = *n;
    // 遍历矩阵的列
    for (j = 1; j <= i__1; ++j) {
        // 计算每列中需要处理的行数，取当前列数和行数的较小值
        i__2 = min(j,*m);
        // 遍历当前列中的每一行
        for (i__ = 1; i__ <= i__2; ++i__) {
            // 计算数组元素在一维数组中的索引
            i__3 = i__ + j * a_dim1;
            // 计算乘法结果并赋值给数组元素
            i__4 = i__ + j * a_dim1;
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L60: */
        }
/* L70: */
    }

    } else if (itype == 3) {

/*        Upper Hessenberg matrix */

    i__1 = *n;
    // 遍历矩阵的列
    for (j = 1; j <= i__1; ++j) {
        // 计算每列中需要处理的行数，取当前列数+1和行数的较小值
        // 这是因为上 Hessenberg 矩阵主对角线以上的元素的特殊位置
        i__3 = j + 1;
        i__2 = min(i__3,*m);
        // 遍历当前列中的每一行
        for (i__ = 1; i__ <= i__2; ++i__) {
            // 计算数组元素在一维数组中的索引
            i__3 = i__ + j * a_dim1;
            // 计算乘法结果并赋值给数组元素
            i__4 = i__ + j * a_dim1;
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L80: */
        }
/* L90: */
    }

    } else if (itype == 4) {

/*        Lower half of a symmetric band matrix */

    k3 = *kl + 1;
    k4 = *n + 1;
    // 遍历矩阵的列
    for (j = 1; j <= i__1; ++j) {
        // 计算每列中需要处理的行数，取较小的值，考虑对称带状矩阵的下半部分
        i__3 = k3, i__4 = k4 - j;
        i__2 = min(i__3,i__4);
        // 遍历当前列中的每一行
        for (i__ = 1; i__ <= i__2; ++i__) {
            // 计算数组元素在一维数组中的索引
            i__3 = i__ + j * a_dim1;
            // 计算乘法结果并赋值给数组元素
            i__4 = i__ + j * a_dim1;
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L100: */
        }
/* L110: */
    }

    } else if (itype == 5) {

/*        Upper half of a symmetric band matrix */

    k1 = *ku + 2;
    k3 = *ku + 1;
    // 遍历矩阵的列
    for (j = 1; j <= i__1; ++j) {
        // 计算当前列中需要处理的行数范围，考虑对称带状矩阵的上半部分
        i__2 = k1 - j;
        i__3 = k3;
        // 遍历当前列中的每一行
        for (i__ = max(i__2,1); i__ <= i__3; ++i__) {
            // 计算数组元素在一维数组中的索引
            i__2 = i__ + j * a_dim1;
            // 计算乘法结果并赋值给数组元素
            i__4 = i__ + j * a_dim1;
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L120: */
        }
/* L130: */
    }

    } else if (itype == 6) {

/*        Band matrix */

    k1 = *kl + *ku + 2;
    k2 = *kl + 1;
    k3 = (*kl << 1) + *ku + 1;
    k4 = *kl + *ku + 1 + *m;
    // 遍历矩阵的列
    for (j = 1; j <= i__1; ++j) {
        // 计算当前列中需要处理的行数范围，考虑带状矩阵的特殊结构
        // 计算边界值，即当前列中第一个元素的行索引
        i__3 = k1 - j;
        // 计算边界值，即当前列中最后一个元素的行索引
        i__4 = k3, i__5 = k4 - j;
        i__2 = min(i__4,i__5);
        // 遍历当前列中的每一行
        for (i__ = max(i__3,k2); i__ <= i__2; ++i__) {
            // 计算数组元素在一维数组中的索引
            i__3 = i__ + j * a_dim1;
            // 计算乘法结果并赋值给数组元素
            i__4 = i__ + j * a_dim1;
            q__1.r = mul * a[i__4].r, q__1.i = mul * a[i__4].i;
            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L140: */
        }
/* L150: */
    }

    }

    // 如果处理未完成，跳转到标签 L10 继续处理
    if (! done) {
    goto L10;
    }

    // 返回 0 表示正常结束
    return 0;

/*     End of CLASCL */

} /* clascl_ */

/* Subroutine */ int claset_(char *uplo, integer *m, integer *n, singlecomplex *
    alpha, singlecomplex *beta, singlecomplex *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
    
    
    
    # LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包，发布于 2006 年 11 月。
    
    
    
    Purpose
    =======
    
    CLASET initializes a 2-D array A to BETA on the diagonal and
    ALPHA on the offdiagonals.
    
    
    
    # CLASET 函数将二维数组 A 的对角线元素设为 BETA，非对角线元素设为 ALPHA。
    
    
    
    Arguments
    =========
    
    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set. The lower triangle
                        is unchanged.
            = 'L':      Lower triangular part is set. The upper triangle
                        is unchanged.
            Otherwise:  All of the matrix A is set.
    
    
    
    # UPLO（输入）字符参数，指定要设置的矩阵 A 的部分。
    # - 'U'：设置上三角部分，下三角部分保持不变。
    # - 'L'：设置下三角部分，上三角部分保持不变。
    # - 其他值：设置整个矩阵 A。
    
    
    
    M       (input) INTEGER
            On entry, M specifies the number of rows of A.
    
    
    
    # M（输入）整数参数，在输入时指定矩阵 A 的行数。
    
    
    
    N       (input) INTEGER
            On entry, N specifies the number of columns of A.
    
    
    
    # N（输入）整数参数，在输入时指定矩阵 A 的列数。
    
    
    
    ALPHA   (input) COMPLEX
            All the offdiagonal array elements are set to ALPHA.
    
    
    
    # ALPHA（输入）复数参数，设置所有非对角线元素为 ALPHA。
    
    
    
    BETA    (input) COMPLEX
            All the diagonal array elements are set to BETA.
    
    
    
    # BETA（输入）复数参数，设置所有对角线元素为 BETA。
    
    
    
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
                     A(i,i) = BETA , 1 <= i <= min(m,n)
    
    
    
    # A（输入/输出）复数数组，维度为 (LDA,N)
    # 在输入时，是一个 m 行 n 列的矩阵 A。
    # 在输出时，A(i,j) = ALPHA，1 <= i <= m，1 <= j <= n，i ≠ j；
    #         A(i,i) = BETA，1 <= i <= min(m,n)。
    
    
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
    
    
    
    # LDA（输入）整数参数，数组 A 的主维度。要求 LDA >= max(1,M)。
    
    
    
    =====================================================================
    
    
    
    # 这里是文档结尾。
    /* Parameter adjustments */
    // 对参数进行调整
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 函数体开始
    if (lsame_(uplo, "U")) {

/*
          Set the diagonal to BETA and the strictly upper triangular
          part of the array to ALPHA.
*/

    i__1 = *n;
    // 循环遍历列
    for (j = 2; j <= i__1; ++j) {
/* Computing MIN */
        // 计算当前列需要更新的行数，取较小值
        i__3 = j - 1;
        i__2 = min(i__3,*m);
        // 循环遍历当前列的严格上三角部分
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        // 将 ALPHA 设置到严格上三角部分
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
/* L10: */
        }
/* L20: */
    }
    // 循环设置对角线元素为 BETA
    i__1 = min(*n,*m);
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = beta->r, a[i__2].i = beta->i;
/* L30: */
    }

    } else if (lsame_(uplo, "L")) {

/*
          Set the diagonal to BETA and the strictly lower triangular
          part of the array to ALPHA.
*/

    i__1 = min(*m,*n);
    // 循环遍历列
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        // 循环遍历当前列的严格下三角部分
        for (i__ = j + 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        // 将 ALPHA 设置到严格下三角部分
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
/* L40: */
        }
/* L50: */
    }
    // 循环设置对角线元素为 BETA
    i__1 = min(*n,*m);
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = beta->r, a[i__2].i = beta->i;
/* L60: */
    }

    } else {

/*
          Set the array to BETA on the diagonal and ALPHA on the
          offdiagonal.
*/

    i__1 = *n;
    // 循环遍历列
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        // 循环遍历当前列
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        // 将 ALPHA 设置到数组的非对角线元素
        a[i__3].r = alpha->r, a[i__3].i = alpha->i;
/* L70: */
        }
/* L80: */
    }
    // 循环设置对角线元素为 BETA
    i__1 = min(*m,*n);
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + i__ * a_dim1;
        a[i__2].r = beta->r, a[i__2].i = beta->i;
/* L90: */
    }
    }

    // 返回操作成功
    return 0;

/*     End of CLASET */

} /* claset_ */

/* Subroutine */ int clasr_(char *side, char *pivot, char *direct, integer *m,
     integer *n, real *c__, real *s, singlecomplex *a, integer *lda)
{
    /* System generated locals */
    // 系统生成的局部变量声明
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    singlecomplex q__1, q__2, q__3;

    /* Local variables */
    // 本地局部变量声明
    static integer i__, j, info;
    static singlecomplex temp;
    extern logical lsame_(char *, char *);
    static real ctemp, stemp;
    extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLASR applies a sequence of real plane rotations to a singlecomplex matrix
    A, from either the left or the right.

    When SIDE = 'L', the transformation takes the form

       A := P*A

    and when SIDE = 'R', the transformation takes the form

       A := A*P**T

    where P is an orthogonal matrix consisting of a sequence of z plane
*/


注释部分详细解释了每个代码块的功能和作用，确保代码的每一行都得到了适当的解释。
    # 定义一个注释区域，解释了如何在不同的情况下使用平面旋转矩阵 P。
    rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
    and P**T is the transpose of P.
    
    When DIRECT = 'F' (Forward sequence), then
    
       P = P(z-1) * ... * P(2) * P(1)
    
    and when DIRECT = 'B' (Backward sequence), then
    
       P = P(1) * P(2) * ... * P(z-1)
    
    where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
    
       R(k) = (  c(k)  s(k) )
            = ( -s(k)  c(k) ).
    
    When PIVOT = 'V' (Variable pivot), the rotation is performed
    for the plane (k,k+1), i.e., P(k) has the form
    
       P(k) = (  1                                            )
              (       ...                                     )
              (              1                                )
              (                   c(k)  s(k)                  )
              (                  -s(k)  c(k)                  )
              (                                1              )
              (                                     ...       )
              (                                            1  )
    
    where R(k) appears as a rank-2 modification to the identity matrix in
    rows and columns k and k+1.
    
    When PIVOT = 'T' (Top pivot), the rotation is performed for the
    plane (1,k+1), so P(k) has the form
    
       P(k) = (  c(k)                    s(k)                 )
              (         1                                     )
              (              ...                              )
              (                     1                         )
              ( -s(k)                    c(k)                 )
              (                                 1             )
              (                                      ...      )
              (                                             1 )
    
    where R(k) appears in rows and columns 1 and k+1.
    
    Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
    performed for the plane (k,z), giving P(k) the form
    
       P(k) = ( 1                                             )
              (      ...                                      )
              (             1                                 )
              (                  c(k)                    s(k) )
              (                         1                     )
              (                              ...              )
              (                                     1         )
              (                 -s(k)                    c(k) )
    
    where R(k) appears in rows and columns k and z.  The rotations are
    performed without ever forming P(k) explicitly.
    
    Arguments
    =========
    
    SIDE    (input) CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
    PIVOT   (input) CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)
    /* Parameter adjustments */
    --c__;               // 调整数组 c__ 的指针，使其指向正确的位置
    --s;                 // 调整数组 s 的指针，使其指向正确的位置
    a_dim1 = *lda;       // 设置 a_dim1 为 lda，即 a 的第一维的大小
    a_offset = 1 + a_dim1;  // 计算 a 的偏移量
    a -= a_offset;        // 调整数组 a 的指针，使其指向正确的位置

    /* Function Body */
    info = 0;             // 初始化 info 为 0
    if (! (lsame_(side, "L") || lsame_(side, "R"))) {  // 检查 side 参数是否为 "L" 或 "R"
        info = 1;         // 若不是，则将 info 设置为 1
    } else if (! (lsame_(pivot, "V") || lsame_(pivot, "T") || lsame_(pivot, "B"))) {
        info = 2;         // 检查 pivot 参数是否为 "V", "T" 或 "B"
    } else if (! (lsame_(direct, "F") || lsame_(direct, "B"))) {
        info = 3;         // 检查 direct 参数是否为 "F" 或 "B"
    } else if (*m < 0) {
        info = 4;         // 检查 m 参数是否小于 0
    } else if (*n < 0) {
        info = 5;         // 检查 n 参数是否小于 0
    } else if (*lda < max(1,*m)) {
        info = 9;         // 检查 lda 参数是否小于 max(1, m)
    }
    if (info != 0) {      // 如果 info 不为 0，则发生了错误，调用错误处理函数 xerbla_
        xerbla_("CLASR ", &info);
        return 0;         // 返回 0 表示出错
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
        return 0;         // 如果 m 或 n 为 0，则直接返回，不进行后续操作
    }
    if (lsame_(side, "L")) {

/*        Form  P * A */

        if (lsame_(pivot, "V")) {  // 如果 pivot 为 "V"
            if (lsame_(direct, "F")) {  // 如果 direct 为 "F"
                i__1 = *m - 1;
                for (j = 1; j <= i__1; ++j) {  // 遍历 P 矩阵的列
                    ctemp = c__[j];       // 获取 c__ 数组中的值
                    stemp = s[j];         // 获取 s 数组中的值
                    if (ctemp != 1.f || stemp != 0.f) {  // 如果 ctemp 不等于 1 或 stemp 不等于 0
                        i__2 = *n;
                        for (i__ = 1; i__ <= i__2; ++i__) {  // 遍历 A 矩阵的行
                            i__3 = j + 1 + i__ * a_dim1;
                            temp.r = a[i__3].r, temp.i = a[i__3].i;  // 临时存储 A(j+1, i)
                            i__3 = j + 1 + i__ * a_dim1;
                            q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;  // 计算 ctemp * A(j+1, i)
                            i__4 = j + i__ * a_dim1;
                            q__3.r = stemp * a[i__4].r, q__3.i = stemp * a[i__4].i;  // 计算 stemp * A(j, i)
                            q__1.r = q__2.r - q__3.r, q__1.i = q__2.i - q__3.i;  // 计算差值
                            a[i__3].r = q__1.r, a[i__3].i = q__1.i;  // 更新 A(j+1, i)
                            i__3 = j + i__ * a_dim1;
                            q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;  // 计算 stemp * A(j+1, i)
                            i__4 = j + i__ * a_dim1;
                            q__3.r = ctemp * a[i__4].r, q__3.i = ctemp * a[i__4].i;  // 计算 ctemp * A(j, i)
                            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;  // 计算和值
                            a[i__3].r = q__1.r, a[i__3].i = q__1.i;  // 更新 A(j, i)
/* L10: */
                        }
                    }
                }
            }
        }
    }
/* L20: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *m - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = j + 1 + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = j + 1 + i__ * a_dim1;
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__3 = j + i__ * a_dim1;
                q__3.r = stemp * a[i__3].r, q__3.i = stemp * a[
                    i__3].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                i__2 = j + i__ * a_dim1;
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__3 = j + i__ * a_dim1;
                q__3.r = ctemp * a[i__3].r, q__3.i = ctemp * a[
                    i__3].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L30: */
            }
            }
/* L40: */
        }
        }
    } else if (lsame_(pivot, "T")) {
        if (lsame_(direct, "F")) {
        i__1 = *m;
        for (j = 2; j <= i__1; ++j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = j + i__ * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                i__3 = j + i__ * a_dim1;
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__4 = i__ * a_dim1 + 1;
                q__3.r = stemp * a[i__4].r, q__3.i = stemp * a[
                    i__4].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                i__3 = i__ * a_dim1 + 1;
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__4 = i__ * a_dim1 + 1;
                q__3.r = ctemp * a[i__4].r, q__3.i = ctemp * a[
                    i__4].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L50: */
            }
            }
/* L60: */
        }
        }
    }


注释：
/* L60: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *m; j >= 2; --j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = j + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = j + i__ * a_dim1;
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__3 = i__ * a_dim1 + 1;
                q__3.r = stemp * a[i__3].r, q__3.i = stemp * a[
                    i__3].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                i__2 = i__ * a_dim1 + 1;
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__3 = i__ * a_dim1 + 1;
                q__3.r = ctemp * a[i__3].r, q__3.i = ctemp * a[
                    i__3].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L70: */
            }
            }
/* L80: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = j + i__ * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                i__3 = j + i__ * a_dim1;
                i__4 = *m + i__ * a_dim1;
                q__2.r = stemp * a[i__4].r, q__2.i = stemp * a[
                    i__4].i;
                q__3.r = ctemp * temp.r, q__3.i = ctemp * temp.i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                i__3 = *m + i__ * a_dim1;
                i__4 = *m + i__ * a_dim1;
                q__2.r = ctemp * a[i__4].r, q__2.i = ctemp * a[
                    i__4].i;
                q__3.r = stemp * temp.r, q__3.i = stemp * temp.i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L90: */
            }
            }
/* L100: */
        }
        } else if (lsame_(direct, "B")) {
        ! 如果 direct 是 "B"，则进行下列循环
        for (j = *m - 1; j >= 1; --j) {
            ! 保存 c[j] 和 s[j] 的值
            ctemp = c__[j];
            stemp = s[j];
            ! 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行下面的操作
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *n;
            ! 遍历列向量 i__ = 1 到 *n
            for (i__ = 1; i__ <= i__1; ++i__) {
                ! temp 保存 a[j + i__ * a_dim1] 的值
                i__2 = j + i__ * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                ! 计算 a[j + i__ * a_dim1] 和 a[*m + i__ * a_dim1] 的更新值
                i__2 = j + i__ * a_dim1;
                i__3 = *m + i__ * a_dim1;
                q__2.r = stemp * a[i__3].r, q__2.i = stemp * a[
                    i__3].i;
                q__3.r = ctemp * temp.r, q__3.i = ctemp * temp.i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                ! 计算 a[*m + i__ * a_dim1] 的更新值
                i__2 = *m + i__ * a_dim1;
                i__3 = *m + i__ * a_dim1;
                q__2.r = ctemp * a[i__3].r, q__2.i = ctemp * a[
                    i__3].i;
                q__3.r = stemp * temp.r, q__3.i = stemp * temp.i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L110: */
            }
            }
/* L120: */
        }
        }
    }
    } else if (lsame_(side, "R")) {

/*        Form A * P' */

    ! 如果 side 是 "R"，则进行下列操作
    if (lsame_(pivot, "V")) {
        ! 如果 pivot 是 "V"，则执行下列操作
        if (lsame_(direct, "F")) {
        ! 如果 direct 是 "F"，则执行下列操作
        i__1 = *n - 1;
        ! 遍历 j = 1 到 *n - 1
        for (j = 1; j <= i__1; ++j) {
            ! 保存 c[j] 和 s[j] 的值
            ctemp = c__[j];
            stemp = s[j];
            ! 如果 ctemp 不等于 1 或者 stemp 不等于 0，则执行下面的操作
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *m;
            ! 遍历行向量 i__ = 1 到 *m
            for (i__ = 1; i__ <= i__2; ++i__) {
                ! temp 保存 a[i__ + (j + 1) * a_dim1] 的值
                i__3 = i__ + (j + 1) * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                ! 计算 a[i__ + (j + 1) * a_dim1] 的更新值
                i__3 = i__ + (j + 1) * a_dim1;
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__4 = i__ + j * a_dim1;
                q__3.r = stemp * a[i__4].r, q__3.i = stemp * a[
                    i__4].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                ! 计算 a[i__ + j * a_dim1] 的更新值
                i__3 = i__ + j * a_dim1;
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__4 = i__ + j * a_dim1;
                q__3.r = ctemp * a[i__4].r, q__3.i = ctemp * a[
                    i__4].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L130: */
            }
            }
/* L140: */
        }
        } else if (lsame_(direct, "B")) {
        // 如果 direct 是 "B"，执行以下循环
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，执行以下循环
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            // 对每个 i 进行循环
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = i__ + (j + 1) * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = i__ + (j + 1) * a_dim1;
                // 计算新的 a[i__+(j+1)*a_dim1]
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__3 = i__ + j * a_dim1;
                q__3.r = stemp * a[i__3].r, q__3.i = stemp * a[
                    i__3].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                i__2 = i__ + j * a_dim1;
                // 计算新的 a[i__+j*a_dim1]
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__3 = i__ + j * a_dim1;
                q__3.r = ctemp * a[i__3].r, q__3.i = ctemp * a[
                    i__3].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L150: */
            }
            }
/* L160: */
        }
        }
    } else if (lsame_(pivot, "T")) {
        // 如果 pivot 是 "T"，执行以下条件
        if (lsame_(direct, "F")) {
        // 如果 direct 是 "F"，执行以下循环
        i__1 = *n;
        // 对每个 j 进行循环
        for (j = 2; j <= i__1; ++j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0，执行以下循环
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *m;
            // 对每个 i 进行循环
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                i__3 = i__ + j * a_dim1;
                // 计算新的 a[i__+j*a_dim1]
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__4 = i__ + a_dim1;
                q__3.r = stemp * a[i__4].r, q__3.i = stemp * a[
                    i__4].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                i__3 = i__ + a_dim1;
                // 计算新的 a[i__+a_dim1]
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__4 = i__ + a_dim1;
                q__3.r = ctemp * a[i__4].r, q__3.i = ctemp * a[
                    i__4].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L170: */
            }
            }
/* L180: */
        }
        } else if (lsame_(direct, "B")) {
        /* 如果 direct 参数为 "B"，则执行以下操作 */
        for (j = *n; j >= 2; --j) {
            /* 保存旋转参数 */
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            /* 如果旋转参数不为标准值（1和0），则进行以下循环 */
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                /* 执行复数矩阵的后置左乘旋转 */
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = i__ + j * a_dim1;
                q__2.r = ctemp * temp.r, q__2.i = ctemp * temp.i;
                i__3 = i__ + a_dim1;
                q__3.r = stemp * a[i__3].r, q__3.i = stemp * a[
                    i__3].i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                i__2 = i__ + a_dim1;
                q__2.r = stemp * temp.r, q__2.i = stemp * temp.i;
                i__3 = i__ + a_dim1;
                q__3.r = ctemp * a[i__3].r, q__3.i = ctemp * a[
                    i__3].i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L190: */
            }
            }
/* L200: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        /* 如果 pivot 参数为 "B"，则执行以下操作 */
        if (lsame_(direct, "F")) {
        /* 如果 direct 参数为 "F"，则执行以下操作 */
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            /* 保存旋转参数 */
            ctemp = c__[j];
            stemp = s[j];
            /* 如果旋转参数不为标准值（1和0），则进行以下循环 */
            if (ctemp != 1.f || stemp != 0.f) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* 执行复数矩阵的前置左乘旋转 */
                i__3 = i__ + j * a_dim1;
                temp.r = a[i__3].r, temp.i = a[i__3].i;
                i__3 = i__ + j * a_dim1;
                i__4 = i__ + *n * a_dim1;
                q__2.r = stemp * a[i__4].r, q__2.i = stemp * a[
                    i__4].i;
                q__3.r = ctemp * temp.r, q__3.i = ctemp * temp.i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
                i__3 = i__ + *n * a_dim1;
                i__4 = i__ + *n * a_dim1;
                q__2.r = ctemp * a[i__4].r, q__2.i = ctemp * a[
                    i__4].i;
                q__3.r = stemp * temp.r, q__3.i = stemp * temp.i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__3].r = q__1.r, a[i__3].i = q__1.i;
/* L210: */
            }
            }
/* L220: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1.f || stemp != 0.f) {
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                i__2 = i__ + j * a_dim1;
                i__3 = i__ + *n * a_dim1;
                q__2.r = stemp * a[i__3].r, q__2.i = stemp * a[
                    i__3].i;
                q__3.r = ctemp * temp.r, q__3.i = ctemp * temp.i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                i__2 = i__ + *n * a_dim1;
                i__3 = i__ + *n * a_dim1;
                q__2.r = ctemp * a[i__3].r, q__2.i = ctemp * a[
                    i__3].i;
                q__3.r = stemp * temp.r, q__3.i = stemp * temp.i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L230: */
            }
            }
/* L240: */
        }
        }
    }
    }

    return 0;

/*     End of CLASR */

} /* clasr_ */

/* Subroutine */ int classq_(integer *n, singlecomplex *x, integer *incx, real *
    scale, real *sumsq)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    real r__1;

    /* Local variables */
    static integer ix;
    static real temp1;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLASSQ returns the values scl and ssq such that

       ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
    assumed to be at least unity and the value of ssq will then satisfy

       1.0 .le. ssq .le. ( sumsq + 2*n ).

    scale is assumed to be non-negative and scl returns the value

       scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
              i

    scale and sumsq must be supplied in SCALE and SUMSQ respectively.
    SCALE and SUMSQ are overwritten by scl and ssq respectively.

    The routine makes only one pass through the vector X.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.

    X       (input) COMPLEX array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.


/* L220: */
        } else if (lsame_(direct, "B")) {
        // 迭代：从最后一个列开始到第一个列
        for (j = *n - 1; j >= 1; --j) {
            // 保存 c[j] 和 s[j]
            ctemp = c__[j];
            stemp = s[j];
            // 如果 ctemp 不等于 1 或者 stemp 不等于 0
            if (ctemp != 1.f || stemp != 0.f) {
            // 对每一行进行操作
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                // 记录 a[i,j] 的值到 temp 中
                i__2 = i__ + j * a_dim1;
                temp.r = a[i__2].r, temp.i = a[i__2].i;
                // 更新 a[i,j] 的值
                i__2 = i__ + j * a_dim1;
                i__3 = i__ + *n * a_dim1;
                q__2.r = stemp * a[i__3].r, q__2.i = stemp * a[
                    i__3].i;
                q__3.r = ctemp * temp.r, q__3.i = ctemp * temp.i;
                q__1.r = q__2.r + q__3.r, q__1.i = q__2.i +
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                // 更新 a[i,n] 的值
                i__2 = i__ + *n * a_dim1;
                i__3 = i__ + *n * a_dim1;
                q__2.r = ctemp * a[i__3].r, q__2.i = ctemp * a[
                    i__3].i;
                q__3.r = stemp * temp.r, q__3.i = stemp * temp.i;
                q__1.r = q__2.r - q__3.r, q__1.i = q__2.i -
                    q__3.i;
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
/* L230: */
            }
            }
/* L240: */
        }
        }
    }
    }

    return 0;

/*     End of CLASR */

} /* clasr_ */

/* Subroutine */ int classq_(integer *n, singlecomplex *x, integer *incx, real *
    scale, real *sumsq)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    real r__1;

    /* Local variables */
    static integer ix;
    static real temp1;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLASSQ returns the values scl and ssq such that

       ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
    assumed to be at least unity and the value of ssq will then satisfy

       1.0 .le. ssq .le. ( sumsq + 2*n ).

    scale is assumed to be non-negative and scl returns the value

       scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
              i

    scale and sumsq must be supplied in SCALE and SUMSQ respectively.
    SCALE and SUMSQ are overwritten by scl and ssq respectively.

    The routine makes only one pass through the vector X.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.

    X       (input) COMPLEX array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.
    SCALE   (input/output) REAL
            输入时，表示上述方程中的 scale 值。
            输出时，被重写为 scl 的值。

    SUMSQ   (input/output) REAL
            输入时，表示上述方程中的 sumsq 值。
            输出时，被重写为 ssq 的值。

   =====================================================================
    /* Parameter adjustments */
    --x;

    /* Function Body */
    // 如果 n 大于 0，则进入循环
    if (*n > 0) {
        // 计算数组 x 的索引范围
        int i__1 = (*n - 1) * *incx + 1;
        int i__2 = *incx;
        for (int ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {
            // 处理实部不为零的情况
            int i__3 = ix;
            if (x[i__3].r != 0.f) {
                // 计算实部的绝对值
                float temp1 = fabs(x[i__3].r);
                // 更新 scale 和 sumsq 的值
                if (*scale < temp1) {
                    float r__1 = *scale / temp1;
                    *sumsq = *sumsq * (r__1 * r__1) + 1;
                    *scale = temp1;
                } else {
                    float r__1 = temp1 / *scale;
                    *sumsq += r__1 * r__1;
                }
            }
            // 处理虚部不为零的情况
            if (r_imag(&x[ix]) != 0.f) {
                float temp1 = fabs(r_imag(&x[ix]));
                // 更新 scale 和 sumsq 的值
                if (*scale < temp1) {
                    float r__1 = *scale / temp1;
                    *sumsq = *sumsq * (r__1 * r__1) + 1;
                    *scale = temp1;
                } else {
                    float r__1 = temp1 / *scale;
                    *sumsq += r__1 * r__1;
                }
            }
            // 循环下一个元素
/* L10: */
        }
    }

    // 返回值 0，表示函数执行成功
    return 0;

/*     End of CLASSQ */

} /* classq_ */

/* Subroutine */ int claswp_(integer *n, singlecomplex *a, integer *lda, integer *
    k1, integer *k2, integer *ipiv, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;

    /* Local variables */
    static integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    static singlecomplex temp;


    /* LAPACK auxiliary routine (version 3.2) */
    // LAPACK 辅助函数，用于实现矩阵 A 的行交换

    /* Purpose */
    // 功能描述：

    // CLASWP 执行矩阵 A 的一系列行交换。
    // 对矩阵 A 的每一行交换从 K1 到 K2。

    /* Arguments */
    // 参数说明：

    // N       (input) INTEGER
    //         矩阵 A 的列数。

    // A       (input/output) COMPLEX array, dimension (LDA,N)
    //         输入时，要进行行交换的列数为 N 的矩阵 A。
    //         输出时，排列后的矩阵。

    // LDA     (input) INTEGER
    //         数组 A 的第一个维度。

    // K1      (input) INTEGER
    //         IPIV 的第一个元素，进行行交换的起始位置。

    // K2      (input) INTEGER
    //         IPIV 的最后一个元素，进行行交换的结束位置。

    // IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
    //         主元索引向量。仅访问 IPIV 的位置 K1 到 K2。
    //         IPIV(K) = L 表示交换行 K 和 L。

    // INCX    (input) INTEGER
    //         IPIV 中连续值之间的增量。如果 INCX 为负，则按相反顺序应用主元。

    /* Further Details */
    // 更多细节说明：
    Modified by
    # 代码被 R. C. Whaley 修改，R. C. Whaley 是位于美国田纳西大学诺克斯维尔分校的计算机科学系的成员

   =====================================================================


       Interchange row I with row IPIV(I) for each of rows K1 through K2.
       # 将第 I 行与 IPIV(I) 行进行交换，对于范围在 K1 到 K2 的每一行
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    if (*incx > 0) {
        ix0 = *k1;
        i1 = *k1;
        i2 = *k2;
        inc = 1;
    } else if (*incx < 0) {
        ix0 = (1 - *k2) * *incx + 1;
        i1 = *k2;
        i2 = *k1;
        inc = -1;
    } else {
        return 0;
    }

    n32 = *n / 32 << 5;
    if (n32 != 0) {
        i__1 = n32;
        for (j = 1; j <= i__1; j += 32) {
            ix = ix0;
            i__2 = i2;
            i__3 = inc;
            for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3) {
                ip = ipiv[ix];
                if (ip != i__) {
                    i__4 = j + 31;
                    for (k = j; k <= i__4; ++k) {
                        i__5 = i__ + k * a_dim1;
                        temp.r = a[i__5].r, temp.i = a[i__5].i;
                        i__5 = i__ + k * a_dim1;
                        i__6 = ip + k * a_dim1;
                        a[i__5].r = a[i__6].r, a[i__5].i = a[i__6].i;
                        i__5 = ip + k * a_dim1;
                        a[i__5].r = temp.r, a[i__5].i = temp.i;
                    }
                }
                ix += *incx;
            }
        }
    }
    if (n32 != *n) {
        ++n32;
        ix = ix0;
        i__1 = i2;
        i__3 = inc;
        for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
            ip = ipiv[ix];
            if (ip != i__) {
                i__2 = *n;
                for (k = n32; k <= i__2; ++k) {
                    i__4 = i__ + k * a_dim1;
                    temp.r = a[i__4].r, temp.i = a[i__4].i;
                    i__4 = i__ + k * a_dim1;
                    i__5 = ip + k * a_dim1;
                    a[i__4].r = a[i__5].r, a[i__4].i = a[i__5].i;
                    i__4 = ip + k * a_dim1;
                    a[i__4].r = temp.r, a[i__4].i = temp.i;
                }
            }
            ix += *incx;
        }
    }

    return 0;

/*     End of CLASWP */

} /* claswp_ */


注释：

    /* Parameter adjustments */
    a_dim1 = *lda;               // 设置 a 的第一维为 lda
    a_offset = 1 + a_dim1;       // 计算 a 的偏移量
    a -= a_offset;               // 调整 a 的起始地址
    --ipiv;                      // 将 ipiv 指针向前移动一个位置

    /* Function Body */
    if (*incx > 0) {             // 根据 incx 的正负决定参数的调整方向
        ix0 = *k1;               // 设置起始 ix 为 k1
        i1 = *k1;                // 设置循环的起始 i1 为 k1
        i2 = *k2;                // 设置循环的终止 i2 为 k2
        inc = 1;                 // 设置循环步长为正向
    } else if (*incx < 0) {
        ix0 = (1 - *k2) * *incx + 1;  // 计算 ix0 的值
        i1 = *k2;                // 设置循环的起始 i1 为 k2
        i2 = *k1;                // 设置循环的终止 i2 为 k1
        inc = -1;                // 设置循环步长为负向
    } else {
        return 0;                // 如果 incx 为零，直接返回
    }

    n32 = *n / 32 << 5;          // 计算 n32，使得 n32 是 *n 的下一个 32 的倍数
    if (n32 != 0) {              // 如果 n32 不为零，执行以下循环
        i__1 = n32;
        for (j = 1; j <= i__1; j += 32) {  // 每次增加 32
            ix = ix0;
            i__2 = i2;
            i__3 = inc;
            for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3) {
                ip = ipiv[ix];  // 获取 ipiv 中的元素
                if (ip != i__) {  // 如果 ip 不等于 i__
                    i__4 = j + 31;
                    for (k = j; k <= i__4; ++k) {  // 每次增加 1
                        i__5 = i__ + k * a_dim1;
                        temp.r = a[i__5].r, temp.i = a[i__5].i;  // 交换元素
                        i__5 = i__ + k * a_dim1;
                        i__6 = ip + k * a_dim1;
                        a[i__5].r = a[i__6].r, a[i__5].i = a[i__6].i;
                        i__5 = ip + k * a_dim1;
                        a[i__5].r = temp.r, a[i__5].i = temp.i;
                    }
                }
                ix += *incx;  // 增加 ix
            }
        }
    }
    if (n32 != *n) {             // 如果 n32 不等于 *n
        ++n32;                   // 增加 n32
        ix = ix0;
        i__1 = i2;
        i__3 = inc;
        for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
            ip = ipiv[ix];
            if (ip != i__) {
                i__2 = *n;
                for (k = n32; k <= i__2; ++k) {
                    i__4 = i__ + k * a_dim1;
                    temp.r = a[i__4].r, temp.i = a[i__4].i;
                    i__4 = i__ + k * a_dim1;
                    i__5 = ip + k * a_dim1;
                    a[i__4].r = a[i__5].r, a[i__4].i = a[i__5].i;
                    i__4 = ip + k * a_dim1;
                    a[i__4].r = temp.r, a[i__4].i = temp.i;
                }
            }
            ix += *incx;
        }
    }

    return 0;                    // 函数返回值为零

/*     End of CLASWP */

} /* claswp_ */



/* Subroutine */ int clatrd_(char *uplo, integer *n, integer *nb, singlecomplex *a,
    integer *lda, real *e, singlecomplex *tau, singlecomplex *w, integer *ldw)
{
    /* System generated locals */
    integer a_dim 1 a Offset ; iœa_offset,iw_offset a Dimw Offset , i__1, i__2, i__3;
    real r__1;
    singlecomplex q__1, q__2, q__
    # 外部声明（external declaration），定义了三个外部子程序：
    # - caxpy_: 执行复数向量的按元素加法
    # - clarfg_: 生成一个 Householder 变换，用于将复数向量中的第一个元素设为一个正数
    # - clacgv_: 对复数向量中的元素取共轭

    extern /* Subroutine */ int caxpy_(integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *);

    # 外部声明的 caxpy_ 子程序接受以下参数：
    # - integer *: 指向整数的指针，用于指定向量中元素的个数
    # - singlecomplex *: 指向单精度复数的指针，用于指定向量的标量
    # - singlecomplex *: 指向单精度复数的指针，用于指定要按元素相加的向量
    # - integer *: 指向整数的指针，用于指定按元素相加的向量的步长
    # - singlecomplex *: 指向单精度复数的指针，用于指定结果向量
    # - integer *: 指向整数的指针，用于指定结果向量的步长

    extern /* Subroutine */ int clarfg_(integer *, singlecomplex *,
        singlecomplex *, integer *, singlecomplex *);

    # 外部声明的 clarfg_ 子程序接受以下参数：
    # - integer *: 指向整数的指针，用于指定向量中元素的个数
    # - singlecomplex *: 指向单精度复数的指针，用于指定第一个向量元素
    # - singlecomplex *: 指向单精度复数的指针，用于指定第一个向量中的其余元素
    # - integer *: 指向整数的指针，用于指定按元素相加的向量的步长
    # - singlecomplex *: 指向单精度复数的指针，用于指定结果的 Householder 向量

    extern /* Subroutine */ int clacgv_(integer *, singlecomplex *,
        integer *);

    # 外部声明的 clacgv_ 子程序接受以下参数：
    # - integer *: 指向整数的指针，用于指定向量中元素的个数
    # - singlecomplex *: 指向单精度复数的指针，用于指定要取共轭的向量
    # - integer *: 指向整数的指针，用于指定取共轭向量的步长
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    CLATRD reduces NB rows and columns of a complex Hermitian matrix A to
    Hermitian tridiagonal form by a unitary similarity
    transformation Q' * A * Q, and returns the matrices V and W which are
    needed to apply the transformation to the unreduced part of A.

    If UPLO = 'U', CLATRD reduces the last NB rows and columns of a
    matrix, of which the upper triangle is supplied;
    if UPLO = 'L', CLATRD reduces the first NB rows and columns of a
    matrix, of which the lower triangle is supplied.

    This is an auxiliary routine called by CHETRD.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular

    N       (input) INTEGER
            The order of the matrix A.

    NB      (input) INTEGER
            The number of rows and columns to be reduced.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the unitary matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the unitary matrix Q as a
              product of elementary reflectors.
            See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    E       (output) REAL array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
*/
    TAU     (output) COMPLEX array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.

    W       (output) COMPLEX array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.

    LDW     (input) INTEGER
            The leading dimension of the array W. LDW >= max(1,N).

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n) H(n-1) . . . H(n-nb+1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
    and tau in TAU(i-1).

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a complex scalar, and v is a complex vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
    and tau in TAU(i).

    The elements of the vectors v together form the n-by-nb matrix V
    which is needed, with W, to apply the transformation to the unreduced
    part of the matrix, using a Hermitian rank-2k update of the form:
    A := A - V*W' - W*V'.

    The contents of A on exit are illustrated by the following examples
    with n = 5 and nb = 2:

    if UPLO = 'U':                       if UPLO = 'L':

      (  a   a   a   v4  v5 )              (  d                  )
      (      a   a   v4  v5 )              (  1   d              )
      (          a   1   v5 )              (  v1  1   a          )
      (              d   1  )              (  v1  v2  a   a      )
      (                  d  )              (  v1  v2  a   a   a  )

    where d denotes a diagonal element of the reduced matrix, a denotes
    an element of the original matrix that is unchanged, and vi denotes
    an element of the vector defining H(i).

    =====================================================================


       Quick return if possible
    /* 参数调整 */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --e;
    --tau;
    w_dim1 = *ldw;
    w_offset = 1 + w_dim1;
    w -= w_offset;

    /* 函数主体 */
    if (*n <= 0) {
        return 0;
    }

    if (lsame_(uplo, "U")) {

        /* 减少上三角的最后 NB 列 */

        i__1 = *n - *nb + 1;
        for (i__ = *n; i__ >= i__1; --i__) {
            iw = i__ - *n + *nb;
            if (i__ < *n) {

                /* 更新 A(1:i,i) */

                i__2 = i__ + i__ * a_dim1;
                i__3 = i__ + i__ * a_dim1;
                r__1 = a[i__3].r;
                a[i__2].r = r__1, a[i__2].i = 0.f;
                i__2 = *n - i__;
                clacgv_(&i__2, &w[i__ + (iw + 1) * w_dim1], ldw);
                i__2 = *n - i__;
                q__1.r = -1.f, q__1.i = -0.f;
                cgemv_("No transpose", &i__, &i__2, &q__1, &a[(i__ + 1) *
                    a_dim1 + 1], lda, &w[i__ + (iw + 1) * w_dim1], ldw, &
                    c_b57, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                clacgv_(&i__2, &w[i__ + (iw + 1) * w_dim1], ldw);
                i__2 = *n - i__;
                clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                i__2 = *n - i__;
                q__1.r = -1.f, q__1.i = -0.f;
                cgemv_("No transpose", &i__, &i__2, &q__1, &w[(iw + 1) *
                    w_dim1 + 1], ldw, &a[i__ + (i__ + 1) * a_dim1], lda, &
                    c_b57, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
                i__2 = i__ + i__ * a_dim1;
                i__3 = i__ + i__ * a_dim1;
                r__1 = a[i__3].r;
                a[i__2].r = r__1, a[i__2].i = 0.f;
            }
            if (i__ > 1) {

                /* 生成用于消除 A(1:i-2,i) 的初等反射器 H(i) */

                i__2 = i__ - 1 + i__ * a_dim1;
                alpha.r = a[i__2].r, alpha.i = a[i__2].i;
                i__2 = i__ - 1;
                clarfg_(&i__2, &alpha, &a[i__ * a_dim1 + 1], &c__1, &tau[i__
                    - 1]);
                i__2 = i__ - 1;
                e[i__2] = alpha.r;
                i__2 = i__ - 1 + i__ * a_dim1;
                a[i__2].r = 1.f, a[i__2].i = 0.f;
/*              Compute W(1:i-1,i) */

/* 计算 W(1:i-1,i) */

        i__2 = i__ - 1;
/* 设置子例程 chemv 的参数 i__2 为 i-1 */

        chemv_("Upper", &i__2, &c_b57, &a[a_offset], lda, &a[i__ *
            a_dim1 + 1], &c__1, &c_b56, &w[iw * w_dim1 + 1], &
            c__1);
/* 调用 BLAS 子例程 chemv 计算向量乘积，参数含义依次为：矩阵类型为 Upper、矩阵的行数 i__2、系数 c_b57、矩阵 A、A 的 leading dimension lda、向量 a[i__ * a_dim1 + 1]、步长 1、系数 c_b56、输出结果向量 w[iw * w_dim1 + 1]、步长 1 */

        if (i__ < *n) {
/* 若 i 小于 n，则执行以下操作 */

            i__2 = i__ - 1;
/* 设置子例程 cgemv 的参数 i__2 为 i-1 */

            i__3 = *n - i__;
/* 设置子例程 cgemv 的参数 i__3 为 n-i */

            cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &w[(
                iw + 1) * w_dim1 + 1], ldw, &a[i__ * a_dim1 + 1],
                &c__1, &c_b56, &w[i__ + 1 + iw * w_dim1], &c__1);
/* 调用 BLAS 子例程 cgemv 计算向量乘积，参数含义依次为：矩阵类型为 Conjugate transpose、矩阵的行数 i__2、矩阵的列数 i__3、系数 c_b57、矩阵 W 的子矩阵、W 的 leading dimension ldw、矩阵 A 的列向量 a[i__ * a_dim1 + 1]、步长 1、系数 c_b56、输出结果向量 w[i__ + 1 + iw * w_dim1]、步长 1 */

            i__2 = i__ - 1;
/* 设置子例程 cgemv 的参数 i__2 为 i-1 */

            i__3 = *n - i__;
/* 设置子例程 cgemv 的参数 i__3 为 n-i */

            q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数 q__1 为 -1 */

            cgemv_("No transpose", &i__2, &i__3, &q__1, &a[(i__ + 1) *
                 a_dim1 + 1], lda, &w[i__ + 1 + iw * w_dim1], &
                c__1, &c_b57, &w[iw * w_dim1 + 1], &c__1);
/* 调用 BLAS 子例程 cgemv 计算向量乘积，参数含义依次为：矩阵类型为 No transpose、矩阵的行数 i__2、矩阵的列数 i__3、复数系数 q__1、矩阵 A 的列向量 a[(i__ + 1) * a_dim1 + 1]、A 的 leading dimension lda、输入向量 w[i__ + 1 + iw * w_dim1]、步长 1、复数系数 c_b57、输出结果向量 w[iw * w_dim1 + 1]、步长 1 */

            i__2 = i__ - 1;
/* 设置子例程 cgemv 的参数 i__2 为 i-1 */

            i__3 = *n - i__;
/* 设置子例程 cgemv 的参数 i__3 为 n-i */

            cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[(
                i__ + 1) * a_dim1 + 1], lda, &a[i__ * a_dim1 + 1],
                 &c__1, &c_b56, &w[i__ + 1 + iw * w_dim1], &c__1);
/* 调用 BLAS 子例程 cgemv 计算向量乘积，参数含义依次为：矩阵类型为 Conjugate transpose、矩阵的行数 i__2、矩阵的列数 i__3、系数 c_b57、矩阵 A 的列向量 a[(i__ + 1) * a_dim1 + 1]、A 的 leading dimension lda、矩阵 A 的列向量 a[i__ * a_dim1 + 1]、步长 1、系数 c_b56、输出结果向量 w[i__ + 1 + iw * w_dim1]、步长 1 */

            i__2 = i__ - 1;
/* 设置子例程 cgemv 的参数 i__2 为 i-1 */

            i__3 = *n - i__;
/* 设置子例程 cgemv 的参数 i__3 为 n-i */

            q__1.r = -1.f, q__1.i = -0.f;
/* 设置复数 q__1 为 -1 */

            cgemv_("No transpose", &i__2, &i__3, &q__1, &w[(iw + 1) *
                w_dim1 + 1], ldw, &w[i__ + 1 + iw * w_dim1], &
                c__1, &c_b57, &w[iw * w_dim1 + 1], &c__1);
/* 调用 BLAS 子例程 cgemv 计算向量乘积，参数含义依次为：矩阵类型为 No transpose、矩阵的行数 i__2、矩阵的列数 i__3、复数系数 q__1、矩阵 W 的子矩阵、W 的 leading dimension ldw、输入向量 w[i__ + 1 + iw * w_dim1]、步长 1、复数系数 c_b57、输出结果向量 w[iw * w_dim1 + 1]、步长 1 */
        }

        i__2 = i__ - 1;
/* 设置子例程 cscal 的参数 i__2 为 i-1 */

        cscal_(&i__2, &tau[i__ - 1], &w[iw * w_dim1 + 1], &c__1);
/* 调用 BLAS 子例程 cscal 对向量 w[iw * w_dim1 + 1] 进行标量乘法操作，参数含义依次为：矩阵的行数 i__2、复数系数 tau[i__ - 1]、输入向量 w[iw * w_dim1 + 1]、步长 1 */

        q__3.r = -.5f, q__3.i = -0.f;
/* 设置复数 q__3 为 -0.5 */

        i__2 = i__ - 1;
/* 设置子例程 cdotc 的参数 i__2 为 i-1 */

        q__2.r = q__3.r * tau[i__2].r - q__3.i * tau[i__2].i, q__2.i =
             q__3.r * tau[i__2].i + q__3.i * tau[i__2].r;
/* 计算复数 q__2 */

        i__3 = i__ - 1;
/* 设置子例程 cdotc 的参数 i__3 为 i-1 */

        cdotc_(&q__4, &i__3, &w[iw * w_dim1 + 1], &c__1, &a[i__ *
            a_dim1 + 1], &c__1);
/* 调用 BLAS 子例程 cdotc 计算向量点积，参数含义依次为：输出结果 q__4、矩阵的行数 i__3、输入向量 w[iw * w_dim1 + 1]、步长 1、矩阵 A 的列向量 a[i__ * a_dim1 + 1]、步长 1 */

        q__1.r = q__2.r * q__4.r - q__2.i * q__4.i, q__1.i = q__2.r *
            q__4.i + q__2.i * q__4.r;
/* 计算复数 q__1 */

        alpha.r
/*           Update A(i:n,i) */

// 更新 A 的第 i 列中第 i 行到第 n 行的元素
i__2 = i__ + i__ * a_dim1;
i__3 = i__ + i__ * a_dim1;
r__1 = a[i__3].r;
a[i__2].r = r__1, a[i__2].i = 0.f;

// 将 W 的前 i-1 行取共轭
i__2 = i__ - 1;
clacgv_(&i__2, &w[i__ + w_dim1], ldw);

// 计算矩阵向量乘积，结果存入 A 的第 i 列中第 i 行到第 n 行的元素
i__2 = *n - i__ + 1;
i__3 = i__ - 1;
q__1.r = -1.f, q__1.i = -0.f;
cgemv_("No transpose", &i__2, &i__3, &q__1, &a[i__ + a_dim1], lda,
     &w[i__ + w_dim1], ldw, &c_b57, &a[i__ + i__ * a_dim1], &
    c__1);

// 将 W 的前 i-1 行取共轭
i__2 = i__ - 1;
clacgv_(&i__2, &w[i__ + w_dim1], ldw);

// 将 A 的第 i 列取共轭
i__2 = i__ - 1;
clacgv_(&i__2, &a[i__ + a_dim1], lda);

// 计算矩阵向量乘积，结果存入 A 的第 i 列中第 i 行到第 n 行的元素
i__2 = *n - i__ + 1;
i__3 = i__ - 1;
q__1.r = -1.f, q__1.i = -0.f;
cgemv_("No transpose", &i__2, &i__3, &q__1, &w[i__ + w_dim1], ldw,
     &a[i__ + a_dim1], lda, &c_b57, &a[i__ + i__ * a_dim1], &
    c__1);

// 将 A 的第 i 列取共轭
i__2 = i__ - 1;
clacgv_(&i__2, &a[i__ + a_dim1], lda);

// 更新 A 的第 i 行中第 i 列的元素
i__2 = i__ + i__ * a_dim1;
i__3 = i__ + i__ * a_dim1;
r__1 = a[i__3].r;
a[i__2].r = r__1, a[i__2].i = 0.f;

if (i__ < *n) {

/*
        Generate elementary reflector H(i) to annihilate
        A(i+2:n,i)
*/

// 获取 A(i+1,i) 元素，用于生成反射变换
i__2 = i__ + 1 + i__ * a_dim1;
alpha.r = a[i__2].r, alpha.i = a[i__2].i;

// 计算生成一个 Householder 反射向量，用于消除 A(i+2:n,i) 中的元素
i__2 = *n - i__;
/* Computing MIN */
i__3 = i__ + 2;
clarfg_(&i__2, &alpha, &a[min(i__3,*n) + i__ * a_dim1], &c__1,
     &tau[i__]);

// 将生成的反射系数保存到 tau 数组中
i__2 = i__;
e[i__2] = alpha.r;

// 设置 A(i+1,i) 的值为 1，其余部分为 0，生成单位矩阵的一部分
i__2 = i__ + 1 + i__ * a_dim1;
a[i__2].r = 1.f, a[i__2].i = 0.f;
/*              Compute W(i+1:n,i) */

/* 计算 W(i+1:n,i) */
        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        chemv_("Lower", &i__2, &c_b57, &a[i__ + 1 + (i__ + 1) *
            a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 chemv 函数计算矩阵向量乘积，求解 W(i+1:n,i) */

        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        i__3 = i__ - 1;
/* 计算 i__3，表示从 1 到 i-1 的长度 */
        cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &w[i__ +
            1 + w_dim1], ldw, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ * w_dim1 + 1], &c__1);
/* 使用 cgemv 函数计算矩阵向量乘积，求解矩阵的转置与向量的乘积 */

        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        i__3 = i__ - 1;
/* 计算 i__3，表示从 1 到 i-1 的长度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 q__1 为 -1 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &a[i__ + 1 +
            a_dim1], lda, &w[i__ * w_dim1 + 1], &c__1, &c_b57, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 cgemv 函数计算矩阵向量乘积，求解没有转置的情况下的乘积 */

        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        i__3 = i__ - 1;
/* 计算 i__3，表示从 1 到 i-1 的长度 */
        cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
            1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
            c_b56, &w[i__ * w_dim1 + 1], &c__1);
/* 使用 cgemv 函数计算矩阵向量乘积，求解矩阵的转置与向量的乘积 */

        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        i__3 = i__ - 1;
/* 计算 i__3，表示从 1 到 i-1 的长度 */
        q__1.r = -1.f, q__1.i = -0.f;
/* 定义复数 q__1 为 -1 */
        cgemv_("No transpose", &i__2, &i__3, &q__1, &w[i__ + 1 +
            w_dim1], ldw, &w[i__ * w_dim1 + 1], &c__1, &c_b57, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 cgemv 函数计算矩阵向量乘积，求解没有转置的情况下的乘积 */

        i__2 = *n - i__;
/* 计算 i__2，表示从 i 到 n 的长度 */
        cscal_(&i__2, &tau[i__], &w[i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 cscal 函数对向量进行标量乘法 */

        q__3.r = -.5f, q__3.i = -0.f;
/* 定义复数 q__3 为 -0.5 */
        i__2 = i__;
/* 计算 i__2，为 i 的长度 */
        q__2.r = q__3.r * tau[i__2].r - q__3.i * tau[i__2].i, q__2.i =
             q__3.r * tau[i__2].i + q__3.i * tau[i__2].r;
/* 计算复数 q__2 */
        i__3 = *n - i__;
/* 计算 i__3，为 n-i 的长度 */
        cdotc_(&q__4, &i__3, &w[i__ + 1 + i__ * w_dim1], &c__1, &a[
            i__ + 1 + i__ * a_dim1], &c__1);
/* 使用 cdotc 函数计算两个向量的内积 */
        q__1.r = q__2.r * q__4.r - q__2.i * q__4.i, q__1.i = q__2.r *
            q__4.i + q__2.i * q__4.r;
/* 计算复数 q__1 */
        alpha.r = q__1.r, alpha.i = q__1.i;
/* 将计算结果存储到 alpha 变量中 */
        i__2 = *n - i__;
/* 计算 i__2，为 n-i 的长度 */
        caxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &w[
            i__ + 1 + i__ * w_dim1], &c__1);
/* 使用 caxpy 函数完成向量的加法 */

        }

/* L20: */
/* 标签，用于控制程序跳转 */

    }
/* 结束循环 */

    return 0;
/* 返回值为 0，表示正常结束 */

/*     End of CLATRD */

} /* clatrd_ */

/* Subroutine */ int clatrs_(char *uplo, char *trans, char *diag, char *
    normin, integer *n, singlecomplex *a, integer *lda, singlecomplex *x, real *scale,
     real *cnorm, integer *info)
{
/* Subroutine 开始 */

    /* System generated locals */
/* 系统生成的本地变量声明 */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
/* 声明整型变量 */

    real r__1, r__2, r__3, r__4;
/* 声明实型变量 */

    singlecomplex q__1, q__2, q__3, q__4;
/* 声明复数变量 */

    /* Local variables */
/* 本地变量声明 */
    static integer i__, j;
/* 声明整型变量 i 和 j */

    static real xj, rec, tjj;
/* 声明实型变量 xj, rec, tjj */

    static integer jinc;
/* 声明整型变量 jinc */

    static real xbnd;
/* 声明实型变量 xbnd */

    static integer imax;
/* 声明整型变量 imax */

    static real tmax;
/* 声明实型变量 tmax */

    static singlecomplex tjjs;
/* 声明复数变量 tjjs */

    static real xmax, grow;
/* 声明实型变量 xmax 和 grow */

    extern /* Complex */ VOID cdotc_(singlecomplex *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
/* 外部函数声明 */

    extern logical lsame_(char *, char *);
/* 外部函数声明 */

    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
/* 外部函数声明 */
    # 声明一个外部的复数函数 cdotu_
    extern /* Complex */ VOID cdotu_(singlecomplex *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);

    # 声明一个静态的单精度复数 csumj
    static singlecomplex csumj;

    # 声明一个外部的复数向量-常数乘加函数 caxpy_
    extern /* Subroutine */ int caxpy_(integer *, singlecomplex *, singlecomplex *,
        integer *, singlecomplex *, integer *);

    # 声明一个静态的逻辑变量 upper
    static logical upper;

    # 声明一个外部的复数矩阵向量解函数 ctrsv_
    extern /* Subroutine */ int ctrsv_(char *, char *, char *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *);

    # 声明一个外部的单精度浮点数初始化函数 slabad_
    extern /* Subroutine */ int slabad_(real *, real *);

    # 声明一个外部的整数向量最大值索引函数 icamax_
    extern integer icamax_(integer *, singlecomplex *, integer *);

    # 声明一个外部的复数除法函数 cladiv_
    extern /* Complex */ VOID cladiv_(singlecomplex *, singlecomplex *, singlecomplex *);

    # 声明一个外部的双精度浮点数机器精度函数 slamch_
    extern doublereal slamch_(char *);

    # 声明一个外部的复数向量缩放函数 csscal_
    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
        *);

    # 声明一个外部的错误处理函数 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明一个静态的单精度浮点数 bignum
    static real bignum;

    # 声明一个外部的整数向量最大值索引函数 isamax_
    extern integer isamax_(integer *, real *, integer *);

    # 声明一个外部的单精度复数绝对和函数 scasum_
    extern doublereal scasum_(integer *, singlecomplex *, integer *);

    # 声明一个静态的逻辑变量 notran
    static logical notran;

    # 声明一个静态的整数变量 jfirst
    static integer jfirst;

    # 声明一个静态的单精度浮点数 smlnum
    static real smlnum;

    # 声明一个静态的逻辑变量 nounit
    static logical nounit;
# LAPACK 辅助例程 (版本 3.2)
# LAPACK 是由田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包，发布于 2006年11月

# CLATRS 解决以下三个三角系统之一：
# A * x = s*b, A**T * x = s*b, 或者 A**H * x = s*b，
# 其中 A 是上三角或下三角矩阵，A**T 表示 A 的转置，A**H 表示 A 的共轭转置，
# x 和 b 是 n 元素向量，s 是缩放因子，通常小于或等于 1，选择使得 x 的分量小于溢出阈值。
# 如果未缩放的问题不会导致溢出，则调用 Level 2 BLAS 例程 CTRSV。
# 如果矩阵 A 是奇异的（即 A(j,j) = 0 对某些 j），则设置 s 为 0，并返回 A*x = 0 的非平凡解。

# 参数
# =====

# UPLO (输入) CHARACTER*1
# 指定矩阵 A 是上三角还是下三角。
# = 'U': 上三角
# = 'L': 下三角

# TRANS (输入) CHARACTER*1
# 指定对 A 执行的操作。
# = 'N': 解 A * x = s*b     (不转置)
# = 'T': 解 A**T * x = s*b  (转置)
# = 'C': 解 A**H * x = s*b  (共轭转置)

# DIAG (输入) CHARACTER*1
# 指定矩阵 A 是否为单位三角。
# = 'N': 非单位三角
# = 'U': 单位三角

# NORMIN (输入) CHARACTER*1
# 指定 CNORM 是否已设置。
# = 'Y': CNORM 在输入时包含列范数
# = 'N': CNORM 在输入时未设置。退出时，范数将被计算并存储在 CNORM 中。

# N (输入) INTEGER
# 矩阵 A 的阶数。N >= 0。

# A (输入) COMPLEX 数组，维度为 (LDA,N)
# 三角矩阵 A。如果 UPLO = 'U'，则数组 A 的前 n 行 n 列是上三角部分，且 A 的严格下三角部分不引用。
# 如果 UPLO = 'L'，则数组 A 的前 n 行 n 列是下三角部分，且 A 的严格上三角部分不引用。
# 如果 DIAG = 'U'，则假定 A 的对角元素也不引用且假定为 1。

# LDA (输入) INTEGER
# 数组 A 的第一个维度。LDA >= max (1,N)。

# X (输入/输出) COMPLEX 数组，维度为 (N)
# 在输入时，是三角系统的右手边 b。
# 在输出时，X 被重写为解向量 x。
    SCALE   (output) REAL
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.

SCALE 是一个输出变量，表示三角系统的缩放因子 s：
- 如果 SCALE = 0，则表示矩阵 A 是奇异的或者缩放严重不良，向量 x 是方程 A*x = 0 的精确或近似解。


    CNORM   (input or output) REAL array, dimension (N)

            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.

            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.

CNORM 是一个实数数组，大小为 N，可以作为输入或输出：
- 当 NORMIN = 'Y' 时，CNORM 是输入参数，CNORM(j) 包含矩阵 A 第 j 列的非对角线部分的范数。如果 TRANS = 'N'，则 CNORM(j) 必须大于或等于无穷范数；如果 TRANS = 'T' 或 'C'，则 CNORM(j) 必须大于或等于 1-范数。
- 当 NORMIN = 'N' 时，CNORM 是输出参数，CNORM(j) 返回矩阵 A 第 j 列的 1-范数的值。


    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -k, the k-th argument had an illegal value

INFO 是一个输出整数，表示函数执行的结果：
- INFO = 0 表示成功退出。
- INFO < 0 表示参数中第 k 个参数的值非法，具体是 INFO = -k。


    Further Details
    ======= =======

    A rough bound on x is computed; if that is less than overflow, CTRSV
    is called, otherwise, specific code is used which checks for possible
    overflow or divide-by-zero at every operation.

进一步细节部分：
- 计算 x 的一个粗略界限；如果小于溢出阈值，调用 CTRSV；否则，使用特定的代码检查每次操作可能的溢出或除以零情况。


    A columnwise scheme is used for solving A*x = b.  The basic algorithm
    if A is lower triangular is

         x[1:n] := b[1:n]
         for j = 1, ..., n
              x(j) := x(j) / A(j,j)
              x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
         end

    Define bounds on the components of x after j iterations of the loop:
       M(j) = bound on x[1:j]
       G(j) = bound on x[j+1:n]
    Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.

使用列优先方案解决 A*x = b 的问题。如果 A 是下三角矩阵：
- 基本算法如下：
  - 将 x 的前 n 个元素设为 b 的前 n 个元素。
  - 对于 j = 1, ..., n：
    - x(j) := x(j) / A(j,j)
    - x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]

定义循环 j 次后 x 分量的界限：
- M(j) 表示 x[1:j] 的界限
- G(j) 表示 x[j+1:n] 的界限
初始时，设 M(0) = 0，G(0) = max{x(i), i=1,...,n}。


    Then for iteration j+1 we have
       M(j+1) <= G(j) / | A(j+1,j+1) |
       G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
              <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

    where CNORM(j+1) is greater than or equal to the infinity-norm of
    column j+1 of A, not counting the diagonal.  Hence

       G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                    1<=i<=j
    and

       |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                     1<=i< j

对于 j+1 的迭代，有：
- M(j+1) <= G(j) / | A(j+1,j+1) |
- G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
          <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

其中，CNORM(j+1) 大于或等于矩阵 A 第 j+1 列的无穷范数（不计对角线）。因此，
- G(j) <= G(0) 的乘积 ( 1 + CNORM(i) / | A(i,i) | )，其中 1<=i<=j
- |x(j)| <= ( G(0) / |A(j,j)| ) 的乘积 ( 1 + CNORM(i) / |A(i,i)| )，其中 1<=i< j


    Since |x(j)| <= M(j), we use the Level 2 BLAS routine CTRSV if the
    reciprocal of the largest M(j), j=1,..,n, is larger than
    max(underflow, 1/overflow).

由于 |x(j)| <= M(j)，如果 M(j) 的最大值的倒数大于最大的下溢或溢出阈值，我们使用 Level 2 BLAS 程序 CTRSV。


    The bound on x(j) is also used to determine when a step in the
    columnwise method can be performed without fear of overflow.  If
    the computed bound is greater than a large constant, x is scaled to
    prevent overflow, but if the bound overflows, x is set to 0, x(j) to
    1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

x(j) 的界限也用于确定何时可以在列优先方法中执行步骤而不必担心溢出。如果计算得到的界限大于一个大的常数，x 被缩放以防溢出；但如果界限溢出，x 被设为 0，x(j) 被设为 1，缩放因子设为 0，这样可以找到 A*x = 0 的非平凡解。


    Similarly, a row-wise scheme is used to solve A**T *x = b  or
    A**H *x = b.  The basic algorithm for A upper triangular is

         for j = 1, ..., n
              x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
         end

类似地，使用行优先方案解决 A**T *x = b 或 A**H *x = b 的问题。如果 A 是上三角矩阵：
- 基本算法如下：
  - 对于 j = 1, ..., n：
    - x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
    # 同时计算两个边界值
    # G(j) = b(i) - A[1:i-1,i]' * x[1:i-1] 的上界，其中 1<=i<=j
    # M(j) = x(i) 的上界，其中 1<=i<=j
    
    # 初始化条件为 G(0) = 0, M(0) = max{b(i), i=1,..,n}，并添加约束条件 G(j) >= G(j-1) 和 M(j) >= M(j-1) 对于 j >= 1。
    # 然后 x(j) 的上界为
    # M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
    #      <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
    #                1<=i<=j
    
    # 如果 1/M(n) 和 1/G(n) 都大于 max(underflow, 1/overflow)，则可以安全地调用 CTRSV。
    # =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;
    --cnorm;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    notran = lsame_(trans, "N");
    nounit = lsame_(diag, "N");

    /* Test the input parameters. */
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T") && !
        lsame_(trans, "C")) {
        *info = -2;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -3;
    } else if (! lsame_(normin, "Y") && ! lsame_(normin,
         "N")) {
        *info = -4;
    } else if (*n < 0) {
        *info = -5;
    } else if (*lda < max(1,*n)) {
        *info = -7;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CLATRS", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /* Determine machine dependent parameters to control overflow. */
    smlnum = slamch_("Safe minimum");
    bignum = 1.f / smlnum;
    slabad_(&smlnum, &bignum);
    smlnum /= slamch_("Precision");
    bignum = 1.f / smlnum;
    *scale = 1.f;

    if (lsame_(normin, "N")) {

        /* Compute the 1-norm of each column, not including the diagonal. */
        if (upper) {

            /* A is upper triangular. */
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j - 1;
                cnorm[j] = scasum_(&i__2, &a[j * a_dim1 + 1], &c__1);
            } // L10
        } else {

            /* A is lower triangular. */
            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                cnorm[j] = scasum_(&i__2, &a[j + 1 + j * a_dim1], &c__1);
            } // L20
            cnorm[*n] = 0.f;
        }
    }

    /*
       Scale the column norms by TSCAL if the maximum element in CNORM is
       greater than BIGNUM/2.
    */
    imax = isamax_(n, &cnorm[1], &c__1);
    tmax = cnorm[imax];
    if (tmax <= bignum * .5f) {
        tscal = 1.f;
    } else {
        tscal = .5f / (smlnum * tmax);
        sscal_(n, &tscal, &cnorm[1], &c__1);
    }

    /*
       Compute a bound on the computed solution vector to see if the
       Level 2 BLAS routine CTRSV can be used.
    */
    xmax = 0.f;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        /* Computing MAX */
        i__2 = j;
        r__3 = xmax, r__4 = (r__1 = x[i__2].r / 2.f, dabs(r__1)) + (r__2 =
            r_imag(&x[j]) / 2.f, dabs(r__2));
        xmax = dmax(r__3,r__4);
    } // L30
    xbnd = xmax;

    if (notran) {

        /* Compute the growth in A * x = b. */
        if (upper) {
            jfirst = *n;
            jlast = 1;
            jinc = -1;
        } else {
            jfirst = 1;
            jlast = *n;
            jinc = 1;
        }

        if (tscal != 1.f) {
            grow = 0.f;
            goto L60;
        }

        if (nounit) {

            /*
               A is non-unit triangular.

               Compute GROW = 1/G(j) and XBND = 1/M(j).
               Initially, G(0) = max{x(i), i=1,...,n}.
            */
        grow = .5f / dmax(xbnd,smlnum);
        // 计算生长因子，初始值为 0.5 / max(xbnd, smlnum)

        xbnd = grow;
        // 将生长因子赋值给 xbnd

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L60;
        }

        i__3 = j + j * a_dim1;
        tjjs.r = a[i__3].r, tjjs.i = a[i__3].i;
        // 获取对角线元素 A(j,j) 的实部和虚部

        tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
            dabs(r__2));
        // 计算对角线元素的绝对值

        if (tjj >= smlnum) {

/*
                   M(j) = G(j-1) / abs(A(j,j))

   Computing MIN
*/
            // 如果对角线元素的绝对值大于等于 smlnum，则计算 M(j)
            r__1 = xbnd, r__2 = dmin(1.f,tjj) * grow;
            xbnd = dmin(r__1,r__2);
            // 更新 xbnd 为 min(xbnd, min(1, tjj) * grow)
        } else {

/*                 M(j) could overflow, set XBND to 0. */

            // 如果对角线元素的绝对值小于 smlnum，则 M(j) 可能溢出，将 xbnd 设为 0
            xbnd = 0.f;
        }

        if (tjj + cnorm[j] >= smlnum) {

/*                 G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) ) */

            // 如果对角线元素的绝对值加上 cnorm[j] 大于等于 smlnum，则计算 G(j)
            grow *= tjj / (tjj + cnorm[j]);
            // 更新生长因子 grow
        } else {

/*                 G(j) could overflow, set GROW to 0. */

            // 如果对角线元素的绝对值加上 cnorm[j] 小于 smlnum，则 G(j) 可能溢出，将 grow 设为 0
            grow = 0.f;
        }
/* L40: */
        }
        grow = xbnd;
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
        // A 是单位上三角形

        r__1 = 1.f, r__2 = .5f / dmax(xbnd,smlnum);
        grow = dmin(r__1,r__2);
        // 计算初始生长因子 grow = min(1, 0.5 / max(xbnd, smlnum))

        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L60;
        }

/*              G(j) = G(j-1)*( 1 + CNORM(j) ) */

        // 计算单位上三角形时的生长因子 G(j)
        grow *= 1.f / (cnorm[j] + 1.f);
/* L50: */
        }
    }
L60:

    ;
    } else {

/*        Compute the growth in A**T * x = b  or  A**H * x = b. */

    // 计算 A 的转置或共轭转置乘以 x 等于 b 的增长

    if (upper) {
        jfirst = 1;
        jlast = *n;
        jinc = 1;
    } else {
        jfirst = *n;
        jlast = 1;
        jinc = -1;
    }

    if (tscal != 1.f) {
        // 如果 tscal 不等于 1，则生长因子为 0，跳转到 L90 处
        grow = 0.f;
        goto L90;
    }

    if (nounit) {

/*
             A is non-unit triangular.

             Compute GROW = 1/G(j) and XBND = 1/M(j).
             Initially, M(0) = max{x(i), i=1,...,n}.
*/

        // A 是非单位上三角形

        grow = .5f / dmax(xbnd,smlnum);
        // 计算初始生长因子，初始值为 0.5 / max(xbnd, smlnum)

        xbnd = grow;
        // 将生长因子赋值给 xbnd

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L90;
        }

/*              G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) ) */

        // 计算非单位上三角形时的生长因子 G(j)
        xj = cnorm[j] + 1.f;
        // 计算 M(j-1) * (1 + CNORM(j))
/* Computing MIN */
        r__1 = grow, r__2 = xbnd / xj;
        grow = dmin(r__1,r__2);
        // 更新生长因子 grow 为 min(grow, xbnd / xj)

        i__3 = j + j * a_dim1;
        tjjs.r = a[i__3].r, tjjs.i = a[i__3].i;
        // 获取对角线元素 A(j,j) 的实部和虚部

        tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
            dabs(r__2));
        // 计算对角线元素的绝对值

        if (tjj >= smlnum) {

            // 如果对角线元素的绝对值大于等于 smlnum，则计算 M(j-1) * (1 + CNORM(j)) 可能的溢出情况
            r__1 = grow, r__2 = xbnd / xj;
            grow = dmin(r__1,r__2);
            // 更新生长因子 grow 为 min(grow, xbnd / xj)
        } else {

/*                 M(j) could overflow, set XBND to 0. */

            // 如果对角线元素的绝对值小于 smlnum，则 M(j-1) 可能溢出，将 xbnd 设为 0
            xbnd = 0.f;
        }
/* L40: */
        }
        grow = xbnd;
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
        // A 是单位上三角形

        r__1 = 1.f, r__2 = .5f / dmax(xbnd,smlnum);
        grow = dmin(r__1,r__2);
        // 计算初始生长因子 grow = min(1, 0.5 / max(xbnd, smlnum))

        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L60;
        }

/*              G(j) = G(j-1)*( 1 + CNORM(j) ) */

        // 计算单位上三角形时的生长因子 G(j)
        grow *= 1.f / (cnorm[j] + 1.f);
/* L50: */
        }
    }
L60:

    ;
    } else {

/*        Compute the growth in A**T * x = b  or  A**H * x = b. */

    // 计算 A 的转置或共轭转置乘以 x 等于 b 的增长

    if (upper) {
        jfirst = 1;
        jlast = *n;
        jinc = 1;
    } else {
        jfirst = *n;
        jlast = 1;
        jinc = -1;
    }

    if (tscal != 1.f) {
        // 如果 tscal 不等于 1，则生长因子为 0，跳转到 L90 处
        grow = 0.f;
        goto L90;
    }

    if (nounit) {

/*
             A is non-unit triangular.

             Compute GROW = 1/G(j) and XBND = 1/M(j).
             Initially, M(0) = max{x(i), i=1,...,n}.
*/

        // A 是非单位上三角形

        grow = .5f / dmax(xbnd,smlnum);
        // 计算初始生长因子，初始值为 0.5 / max(xbnd, smlnum)

        xbnd = grow;
        // 将生长因子赋值给 xbnd

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L90;
        }

/*              G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) ) */

        // 计算非单位上三角形时的生长因子 G(j)
        xj = cnorm[j] + 1.f;
        // 计算 M(j-1) * (1 + CNORM(j))
/* Computing MIN */
        r__1 = grow, r__2 = xbnd / xj;
        grow = dmin(r__1,r__2);
        // 更新生长因子 grow 为 min(grow, xbnd / xj)

        i__3 = j + j * a_dim1;
        tjjs.r = a[i__3].r, tjjs.i = a[i__3].i;
        // 获取对角线元素 A(j,j) 的实部和虚部

        tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
            dabs(r__2));
        // 计算对角线元素的绝对值

        if (tjj >= smlnum) {
            // 如果对角线元素的绝对值大于等于 smlnum，则计算 M(j-1) * (1 + CNORM(j)) 可能的溢出情况
            r__1 = grow, r__2 = xbnd / xj;
            grow = dmin(r__1,r__2);
            // 更新生长因子 grow 为 min(grow, xbnd / xj)
        } else {

/*                 M(j) could overflow, set XBND to 0. */

            // 如果对角线元素的绝对值小于 smlnum，则 M(j-1) 可能溢出，将 xbnd 设为 0
            xbnd = 0.f;
        }
/* L40: */
        }
        grow = xbnd;
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
        // A 是单位上三角形

        r__1 = 1.f, r__2 = .5f / dmax(xbnd,smlnum);
        grow = dmin(r__1,r__2);
        // 计算初始生长因子 grow = min(1, 0.5 / max(xbnd, smlnum))

        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            // 如果生长因子小于等于 smlnum，则退出循环
            goto L60;
        }

/*              G(j) = G(j-1)*( 1 + CNORM(j) ) */

        // 计算单位上三角形时的生长因子 G(j)
        grow *= 1.f / (cnorm[j] + 1.f);
/* L50: */
        }
    }
L60:

    ;
    }
L90:
    ;
/*                 M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j)) */

            if (xj > tjj) {
            xbnd *= tjj / xj;
            }
        } else {

/*                 M(j) could overflow, set XBND to 0. */

            xbnd = 0.f;
        }
/* L70: */
        }
        grow = dmin(grow,xbnd);
    } else {

/*
             A is unit triangular.

             Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.

   Computing MIN
*/
        r__1 = 1.f, r__2 = .5f / dmax(xbnd,smlnum);
        grow = dmin(r__1,r__2);
        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

        if (grow <= smlnum) {
            goto L90;
        }

/*              G(j) = ( 1 + CNORM(j) )*G(j-1) */

        xj = cnorm[j] + 1.f;
        grow /= xj;
/* L80: */
        }
    }
L90:
    ;
    }

    if (grow * tscal > smlnum) {

/*
          Use the Level 2 BLAS solve if the reciprocal of the bound on
          elements of X is not too small.
*/

    ctrsv_(uplo, trans, diag, n, &a[a_offset], lda, &x[1], &c__1);
    } else {

/*        Use a Level 1 BLAS solve, scaling intermediate results. */

    if (xmax > bignum * .5f) {

/*
             Scale X so that its components are less than or equal to
             BIGNUM in absolute value.
*/

        *scale = bignum * .5f / xmax;
        csscal_(n, scale, &x[1], &c__1);
        xmax = bignum;
    } else {
        xmax *= 2.f;
    }

    if (notran) {

/*           Solve A * x = b */

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Compute x(j) = b(j) / A(j,j), scaling x if necessary. */

        i__3 = j;
        xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]),
            dabs(r__2));
        if (nounit) {
            i__3 = j + j * a_dim1;
            q__1.r = tscal * a[i__3].r, q__1.i = tscal * a[i__3].i;
            tjjs.r = q__1.r, tjjs.i = q__1.i;
        } else {
            tjjs.r = tscal, tjjs.i = 0.f;
            if (tscal == 1.f) {
            goto L105;
            }
        }
        tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
            dabs(r__2));
        if (tjj > smlnum) {

/*                    abs(A(j,j)) > SMLNUM: */

            if (tjj < 1.f) {
            if (xj > tjj * bignum) {

/*                          Scale x by 1/b(j). */

                rec = 1.f / xj;
                csscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
            }
            }
            i__3 = j;
            cladiv_(&q__1, &x[j], &tjjs);
            x[i__3].r = q__1.r, x[i__3].i = q__1.i;
            i__3 = j;
            xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]
                ), dabs(r__2));
        } else if (tjj > 0.f) {
/*
   0 < abs(A(j,j)) <= SMLNUM: 
   当 A(j,j) 的绝对值在 (0, SMLNUM] 范围内时执行以下操作
*/

if (xj > tjj * bignum) {
    /*
       Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
       to avoid overflow when dividing by A(j,j).
       如果 x(j) 超过 tjj * BIGNUM，通过缩放 x 以避免除以 A(j,j) 时溢出
    */
    rec = tjj * bignum / xj;
    if (cnorm[j] > 1.f) {
        /*
           Scale by 1/CNORM(j) to avoid overflow when
           multiplying x(j) times column j.
           如果 CNORM(j) 大于 1，通过缩放来避免 x(j) 乘以列 j 时溢出
        */
        rec /= cnorm[j];
    }
    csscal_(n, &rec, &x[1], &c__1);
    *scale *= rec;
    xmax *= rec;
}

i__3 = j;
cladiv_(&q__1, &x[j], &tjjs);
x[i__3].r = q__1.r, x[i__3].i = q__1.i;
i__3 = j;
xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]
    ), dabs(r__2));
/*
   A(j,j) != 0: 
   当 A(j,j) 不等于 0 时执行以下操作
*/

} else {
    /*
       A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
       scale = 0, and compute a solution to A*x = 0.
       当 A(j,j) 等于 0 时，将 x(1:n) 设为 0，x(j) 设为 1，scale 设为 0，并计算 A*x = 0 的解
    */
    i__3 = *n;
    for (i__ = 1; i__ <= i__3; ++i__) {
        i__4 = i__;
        x[i__4].r = 0.f, x[i__4].i = 0.f;
    }
    i__3 = j;
    x[i__3].r = 1.f, x[i__3].i = 0.f;
    xj = 1.f;
    *scale = 0.f;
    xmax = 0.f;
}

L105:
/*
   Scale x if necessary to avoid overflow when adding a
   multiple of column j of A.
   当添加 A 的第 j 列的倍数时，如有必要则对 x 进行缩放以避免溢出
*/
if (xj > 1.f) {
    rec = 1.f / xj;
    if (cnorm[j] > (bignum - xmax) * rec) {
        /*
           Scale x by 1/(2*abs(x(j))).
           通过 1/(2*abs(x(j))) 的倍数来缩放 x
        */
        rec *= .5f;
        csscal_(n, &rec, &x[1], &c__1);
        *scale *= rec;
    }
} else if (xj * cnorm[j] > bignum - xmax) {
    /*
       Scale x by 1/2.
       缩放 x 为原来的一半
    */
    csscal_(n, &c_b2435, &x[1], &c__1);
    *scale *= .5f;
}

if (upper) {
    if (j > 1) {
        /*
           Compute the update
           x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
           计算更新 x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
        */
        i__3 = j - 1;
        i__4 = j;
        q__2.r = -x[i__4].r, q__2.i = -x[i__4].i;
        q__1.r = tscal * q__2.r, q__1.i = tscal * q__2.i;
        caxpy_(&i__3, &q__1, &a[j * a_dim1 + 1], &c__1, &x[1],
             &c__1);
        i__3 = j - 1;
        i__ = icamax_(&i__3, &x[1], &c__1);
        i__3 = i__;
        xmax = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 =
            r_imag(&x[i__]), dabs(r__2));
    }
} else {
    if (j < *n) {
        /*
           Compute the update
           x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
           计算更新 x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
        */
            i__3 = *n - j;
            i__4 = j;
            q__2.r = -x[i__4].r, q__2.i = -x[i__4].i;
            q__1.r = tscal * q__2.r, q__1.i = tscal * q__2.i;
            caxpy_(&i__3, &q__1, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);

```    
            i__3 = *n - j;
            i__ = j + icamax_(&i__3, &x[j + 1], &c__1);
            i__3 = i__;
            xmax = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 =
                r_imag(&x[i__]), dabs(r__2));

```py    
            }
        }

```    
        } else if (lsame_(trans, "T")) {

```py    
/*           Solve A**T * x = b */

```    
        i__2 = jlast;
        i__1 = jinc;
        for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

```py    
/*
                Compute x(j) = b(j) - sum A(k,j)*x(k).
                                      k<>j
*/

```    
        i__3 = j;
        xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]),
            dabs(r__2));
        uscal.r = tscal, uscal.i = 0.f;
        rec = 1.f / dmax(xmax,1.f);
        if (cnorm[j] > (bignum - xj) * rec) {

```py    
/*                 If x(j) could overflow, scale x by 1/(2*XMAX). */

```    
            rec *= .5f;
            if (nounit) {
            i__3 = j + j * a_dim1;
            q__1.r = tscal * a[i__3].r, q__1.i = tscal * a[i__3]
                .i;
            tjjs.r = q__1.r, tjjs.i = q__1.i;
            } else {
            tjjs.r = tscal, tjjs.i = 0.f;
            }
            tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
                 dabs(r__2));
            if (tjj > 1.f) {

```py    
/*
                         Divide by A(j,j) when scaling x if A(j,j) > 1.

   Computing MIN
*/

```    
            r__1 = 1.f, r__2 = rec * tjj;
            rec = dmin(r__1,r__2);
            cladiv_(&q__1, &uscal, &tjjs);
            uscal.r = q__1.r, uscal.i = q__1.i;
            }
            if (rec < 1.f) {
            csscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
        }

```py    
        csumj.r = 0.f, csumj.i = 0.f;
        if (uscal.r == 1.f && uscal.i == 0.f) {

```    
/*
                   If the scaling needed for A in the dot product is 1,
                   call CDOTU to perform the dot product.
*/

```py    
            if (upper) {
            i__3 = j - 1;
            cdotu_(&q__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                 &c__1);
            csumj.r = q__1.r, csumj.i = q__1.i;
            } else if (j < *n) {
            i__3 = *n - j;
            cdotu_(&q__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);
            csumj.r = q__1.r, csumj.i = q__1.i;
            }
        } else {
/*                 Otherwise, use in-line code for the dot product. */
/* 如果不满足前面的条件，则使用内联代码计算点积。 */

            if (upper) {
/* 如果 upper 为真，则执行以下代码块 */
            i__3 = j - 1;
            for (i__ = 1; i__ <= i__3; ++i__) {
/* 循环遍历 i 从 1 到 j-1 */
                i__4 = i__ + j * a_dim1;
/* 计算矩阵 a 中的元素索引 */
                q__3.r = a[i__4].r * uscal.r - a[i__4].i *
                    uscal.i, q__3.i = a[i__4].r * uscal.i + a[
                    i__4].i * uscal.r;
/* 计算复数乘法 */
                i__5 = i__;
/* 计算矩阵 x 中的元素索引 */
                q__2.r = q__3.r * x[i__5].r - q__3.i * x[i__5].i,
                    q__2.i = q__3.r * x[i__5].i + q__3.i * x[
                    i__5].r;
/* 计算复数乘法 */
                q__1.r = csumj.r + q__2.r, q__1.i = csumj.i +
                    q__2.i;
/* 计算复数加法 */
                csumj.r = q__1.r, csumj.i = q__1.i;
/* 更新 csumj 变量 */
/* L120: */
            }
/* 循环结束 */
            } else if (j < *n) {
/* 如果 upper 为假且 j 小于 n，则执行以下代码块 */
            i__3 = *n;
            for (i__ = j + 1; i__ <= i__3; ++i__) {
/* 循环遍历 i 从 j+1 到 n */
                i__4 = i__ + j * a_dim1;
/* 计算矩阵 a 中的元素索引 */
                q__3.r = a[i__4].r * uscal.r - a[i__4].i *
                    uscal.i, q__3.i = a[i__4].r * uscal.i + a[
                    i__4].i * uscal.r;
/* 计算复数乘法 */
                i__5 = i__;
/* 计算矩阵 x 中的元素索引 */
                q__2.r = q__3.r * x[i__5].r - q__3.i * x[i__5].i,
                    q__2.i = q__3.r * x[i__5].i + q__3.i * x[
                    i__5].r;
/* 计算复数乘法 */
                q__1.r = csumj.r + q__2.r, q__1.i = csumj.i +
                    q__2.i;
/* 计算复数加法 */
                csumj.r = q__1.r, csumj.i = q__1.i;
/* 更新 csumj 变量 */
/* L130: */
            }
/* 循环结束 */
            }
/* 条件语句结束 */

        }

/* 计算复数乘法 */

        q__1.r = tscal, q__1.i = 0.f;
/* 初始化复数变量 q__1 */

        if (uscal.r == q__1.r && uscal.i == q__1.i) {
/* 检查是否 uscal 等于 q__1 */

/*
                   Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j)
                   was not used to scale the dotproduct.
*/
/* 计算 x(j) := ( x(j) - CSUMJ ) / A(j,j)，如果没有使用 1/A(j,j) 来缩放点积 */

            i__3 = j;
/* 计算矩阵 x 中的元素索引 */
            i__4 = j;
/* 计算矩阵 x 中的元素索引 */
            q__1.r = x[i__4].r - csumj.r, q__1.i = x[i__4].i -
                csumj.i;
/* 计算复数减法 */
            x[i__3].r = q__1.r, x[i__3].i = q__1.i;
/* 更新矩阵 x 中的元素 */

            i__3 = j;
/* 计算矩阵 x 中的元素索引 */
            xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]
                ), dabs(r__2));
/* 计算 x(j) 的绝对值 */

            if (nounit) {
/* 如果 nounit 为真，则执行以下代码块 */
            i__3 = j + j * a_dim1;
/* 计算矩阵 a 中的元素索引 */
            q__1.r = tscal * a[i__3].r, q__1.i = tscal * a[i__3]
                .i;
/* 计算复数乘法 */
            tjjs.r = q__1.r, tjjs.i = q__1.i;
/* 更新 tjjs 变量 */
            } else {
/* 如果 nounit 为假，则执行以下代码块 */
            tjjs.r = tscal, tjjs.i = 0.f;
/* 初始化 tjjs 变量 */
            if (tscal == 1.f) {
/* 如果 tscal 等于 1.0，则跳转到标签 L145 */
                goto L145;
/* 跳转到标签 L145 */
            }
/* 条件语句结束 */

/*                    Compute x(j) = x(j) / A(j,j), scaling if necessary. */
/* 计算 x(j) = x(j) / A(j,j)，如有必要进行缩放 */

            tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
                 dabs(r__2));
/* 计算 tjjs 的绝对值 */

            if (tjj > smlnum) {
/* 如果 tjjs 的绝对值大于 smlnum，则执行以下代码块 */

/*                       abs(A(j,j)) > SMLNUM: */

            if (tjj < 1.f) {
/* 如果 tjjs 的绝对值小于 1.0，则执行以下代码块 */
                if (xj > tjj * bignum) {
/* 如果 xj 大于 tjjs 乘以 bignum，则执行以下代码块 */
/*                             Scale X by 1/abs(x(j)). */

                rec = 1.f / xj;
                csscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
                }
            }
            i__3 = j;
            cladiv_(&q__1, &x[j], &tjjs);
            x[i__3].r = q__1.r, x[i__3].i = q__1.i;
            } else if (tjj > 0.f) {

/*                       0 < abs(A(j,j)) <= SMLNUM: */

            if (xj > tjj * bignum) {

/*                          Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM. */

                rec = tjj * bignum / xj;
                csscal_(n, &rec, &x[1], &c__1);
                *scale *= rec;
                xmax *= rec;
            }
            i__3 = j;
            cladiv_(&q__1, &x[j], &tjjs);
            x[i__3].r = q__1.r, x[i__3].i = q__1.i;
            } else {

/*
                         A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                         scale = 0 and compute a solution to A**T *x = 0.
*/

            i__3 = *n;
            for (i__ = 1; i__ <= i__3; ++i__) {
                i__4 = i__;
                x[i__4].r = 0.f, x[i__4].i = 0.f;
/* L140: */
            }
            i__3 = j;
            x[i__3].r = 1.f, x[i__3].i = 0.f;
            *scale = 0.f;
            xmax = 0.f;
            }
L145:
            ;
        } else {

/*
                   Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot
                   product has already been divided by 1/A(j,j).
*/

            i__3 = j;
            cladiv_(&q__2, &x[j], &tjjs);
            q__1.r = q__2.r - csumj.r, q__1.i = q__2.i - csumj.i;
            x[i__3].r = q__1.r, x[i__3].i = q__1.i;
        }
/* Computing MAX */
        i__3 = j;
        r__3 = xmax, r__4 = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 =
            r_imag(&x[j]), dabs(r__2));
        xmax = dmax(r__3,r__4);
/* L150: */
        }

    } else {

/*           Solve A**H * x = b */

        i__1 = jlast;
        i__2 = jinc;
        for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*
                Compute x(j) = b(j) - sum A(k,j)*x(k).
                                      k<>j
*/

        i__3 = j;
        xj = (r__1 = x[i__3].r, dabs(r__1)) + (r__2 = r_imag(&x[j]),
            dabs(r__2));
        uscal.r = tscal, uscal.i = 0.f;
        rec = 1.f / dmax(xmax,1.f);
        if (cnorm[j] > (bignum - xj) * rec) {

/*                 If x(j) could overflow, scale x by 1/(2*XMAX). */

            rec *= .5f;
            if (nounit) {
            r_cnjg(&q__2, &a[j + j * a_dim1]);
            q__1.r = tscal * q__2.r, q__1.i = tscal * q__2.i;
            tjjs.r = q__1.r, tjjs.i = q__1.i;
            } else {
            tjjs.r = tscal, tjjs.i = 0.f;
            }
            tjj = (r__1 = tjjs.r, dabs(r__1)) + (r__2 = r_imag(&tjjs),
                 dabs(r__2));
            if (tjj > 1.f) {

/*
                         Divide by A(j,j) when scaling x if A(j,j) > 1.

   Computing MIN
*/
/*
            r__1 = 1.f, r__2 = rec * tjj;
            rec = dmin(r__1,r__2);
            cladiv_(&q__1, &uscal, &tjjs);
            uscal.r = q__1.r, uscal.i = q__1.i;
            }
            if (rec < 1.f) {
            csscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
        }
*/
            // 计算 rec = min(1.0, rec * tjj)，用于后续的数值缩放
            r__1 = 1.f, r__2 = rec * tjj;
            rec = dmin(r__1,r__2);
            // 计算 uscal / tjjs 并将结果存入 uscal
            cladiv_(&q__1, &uscal, &tjjs);
            uscal.r = q__1.r, uscal.i = q__1.i;
            }
            // 如果 rec 小于 1.0，则对 x 进行缩放
            if (rec < 1.f) {
            csscal_(n, &rec, &x[1], &c__1);
            *scale *= rec;
            xmax *= rec;
            }
        }

        // 初始化 csumj 为复数 0
        csumj.r = 0.f, csumj.i = 0.f;
        // 如果 A 的缩放为 1，使用 CDOTC 计算点积
        if (uscal.r == 1.f && uscal.i == 0.f) {

/*
                   If the scaling needed for A in the dot product is 1,
                   call CDOTC to perform the dot product.
*/

            if (upper) {
            i__3 = j - 1;
            cdotc_(&q__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                 &c__1);
            csumj.r = q__1.r, csumj.i = q__1.i;
            } else if (j < *n) {
            i__3 = *n - j;
            cdotc_(&q__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                x[j + 1], &c__1);
            csumj.r = q__1.r, csumj.i = q__1.i;
            }
        } else {

/*                 Otherwise, use in-line code for the dot product. */

            if (upper) {
            i__3 = j - 1;
            for (i__ = 1; i__ <= i__3; ++i__) {
                r_cnjg(&q__4, &a[i__ + j * a_dim1]);
                q__3.r = q__4.r * uscal.r - q__4.i * uscal.i,
                    q__3.i = q__4.r * uscal.i + q__4.i *
                    uscal.r;
                i__4 = i__;
                q__2.r = q__3.r * x[i__4].r - q__3.i * x[i__4].i,
                    q__2.i = q__3.r * x[i__4].i + q__3.i * x[
                    i__4].r;
                q__1.r = csumj.r + q__2.r, q__1.i = csumj.i +
                    q__2.i;
                csumj.r = q__1.r, csumj.i = q__1.i;
/* L160: */
            }
            } else if (j < *n) {
            i__3 = *n;
            for (i__ = j + 1; i__ <= i__3; ++i__) {
                r_cnjg(&q__4, &a[i__ + j * a_dim1]);
                q__3.r = q__4.r * uscal.r - q__4.i * uscal.i,
                    q__3.i = q__4.r * uscal.i + q__4.i *
                    uscal.r;
                i__4 = i__;
                q__2.r = q__3.r * x[i__4].r - q__3.i * x[i__4].i,
                    q__2.i = q__3.r * x[i__4].i + q__3.i * x[
                    i__4].r;
                q__1.r = csumj.r + q__2.r, q__1.i = csumj.i +
                    q__2.i;
                csumj.r = q__1.r, csumj.i = q__1.i;
/* L170: */
            }
            }
        }

        // 如果 A 的缩放因子等于 tscal，则计算 x(j) := ( x(j) - CSUMJ ) / A(j,j)
        q__1.r = tscal, q__1.i = 0.f;
        if (uscal.r == q__1.r && uscal.i == q__1.i) {

/*
                   Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j)
                   was not used to scale the dotproduct.

*/
/*     Scale the column norms by 1/TSCAL for return. */

if (tscal != 1.f) {
    // 如果 tscal 不等于 1，将列的范数按 1/tscal 缩放
    # 计算倒数，将结果存储在 r__1 中，tscal 是一个除数
    r__1 = 1.f / tscal;
    # 调用名为 sscal_ 的函数，对数组 cnorm 中的元素进行按比例缩放操作
    sscal_(n, &r__1, &cnorm[1], &c__1);
    }  # 结束当前的函数或代码块

    # 返回整数值 0，表示函数执行成功
    return 0;
/*     End of CLATRS */
/*     End of CLATRS */

} /* clatrs_ */

/* Subroutine */ int clauu2_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    real r__1;
    singlecomplex q__1;

    /* Local variables */
    static integer i__;
    static real aii;
    extern /* Complex */ VOID cdotc_(singlecomplex *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int cgemv_(char *, integer *, integer *, singlecomplex *
        , singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *);
    static logical upper;
    extern /* Subroutine */ int clacgv_(integer *, singlecomplex *, integer *),
        csscal_(integer *, real *, singlecomplex *, integer *), xerbla_(char *,
        integer *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLAUU2 computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the unblocked form of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;  // 初始化 INFO，表示操作成功
    upper = lsame_(uplo, "U");  // 检查 UPLO 是否为 'U'，确定是否处理上三角部分
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 UPLO 不是 'U' 且不是 'L'，则设置错误码
    *info = -1;
    } else if (*n < 0) {  // 如果 N 小于 0，设置错误码
    *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 LDA 小于 max(1,N)，设置错误码


这段代码中的注释将每一行具体解释了它们的功能和作用，确保代码的每一部分都得到了清晰的解释。
    *info = -4;

# 将info指向的内存位置设置为-4，这通常用于指示某种错误或异常情况


    }

# 结束if语句块


    if (*info != 0) {

# 如果info指向的值不等于0，执行以下操作


    i__1 = -(*info);

# 将info指向的值取反并赋给i__1变量


    xerbla_("CLAUU2", &i__1);

# 调用名为xerbla_的函数，传递字符串"CLAUU2"和指向i__1的指针作为参数


    return 0;

# 函数返回0，通常表示出现了某种错误或异常情况的处理结束
/*     Quick return if possible */
如果 n 的值为 0，则立即返回 0
    if (*n == 0) {
        return 0;
    }

检查是否为上三角矩阵
    if (upper) {

/*        Compute the product U * U'. */
计算上三角矩阵 U 与其共轭转置 U' 的乘积

    i__1 = *n;
    遍历矩阵的每一列，从第一列到第 n 列
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + i__ * a_dim1;
        获取矩阵中第 i 行第 i 列的元素 aii
        aii = a[i__2].r;
        如果 i 小于 n
        if (i__ < *n) {
            i__2 = i__ + i__ * a_dim1;
            i__3 = *n - i__;
            调用 cdotc 函数计算向量的内积，并存储在 q__1 中
            cdotc_(&q__1, &i__3, &a[i__ + (i__ + 1) * a_dim1], lda, &a[
                i__ + (i__ + 1) * a_dim1], lda);
            计算 aii * aii + 内积结果，得到新的 aii 值
            r__1 = aii * aii + q__1.r;
            将计算结果存储回矩阵中，虚部为 0
            a[i__2].r = r__1, a[i__2].i = 0.f;
            对矩阵的一部分进行共轭
            i__2 = *n - i__;
            clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
            i__2 = i__ - 1;
            i__3 = *n - i__;
            q__1.r = aii, q__1.i = 0.f;
            调用 cgemv 函数计算矩阵向量乘积
            cgemv_("No transpose", &i__2, &i__3, &c_b57, &a[(i__ + 1) *
                a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
                q__1, &a[i__ * a_dim1 + 1], &c__1);
            对矩阵的一部分进行共轭
            i__2 = *n - i__;
            clacgv_(&i__2, &a[i__ + (i__ + 1) * a_dim1], lda);
        } else {
        如果 i 等于 n，则调用 csscal 函数对矩阵的一部分进行缩放
            csscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
        }
/* L10: */
    }

    } else {

/*        Compute the product L' * L. */
计算下三角矩阵 L 的共轭转置 L' 与 L 的乘积

    i__1 = *n;
    遍历矩阵的每一列，从第一列到第 n 列
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + i__ * a_dim1;
        获取矩阵中第 i 行第 i 列的元素 aii
        aii = a[i__2].r;
        如果 i 小于 n
        if (i__ < *n) {
            i__2 = i__ + i__ * a_dim1;
            i__3 = *n - i__;
            调用 cdotc 函数计算向量的内积，并存储在 q__1 中
            cdotc_(&q__1, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &a[
                i__ + 1 + i__ * a_dim1], &c__1);
            计算 aii * aii + 内积结果，得到新的 aii 值
            r__1 = aii * aii + q__1.r;
            将计算结果存储回矩阵中，虚部为 0
            a[i__2].r = r__1, a[i__2].i = 0.f;
            i__2 = i__ - 1;
            对矩阵的一部分进行共轭
            clacgv_(&i__2, &a[i__ + a_dim1], lda);
            i__2 = *n - i__;
            i__3 = i__ - 1;
            q__1.r = aii, q__1.i = 0.f;
            调用 cgemv 函数计算矩阵向量乘积
            cgemv_("Conjugate transpose", &i__2, &i__3, &c_b57, &a[i__ +
                1 + a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &
                q__1, &a[i__ + a_dim1], lda);
            对矩阵的一部分进行共轭
            i__2 = i__ - 1;
            clacgv_(&i__2, &a[i__ + a_dim1], lda);
        } else {
        如果 i 等于 n，则调用 csscal 函数对矩阵的一部分进行缩放
            csscal_(&i__, &aii, &a[i__ + a_dim1], lda);
        }
/* L20: */
    }
    }

    return 0;

/*     End of CLAUU2 */

} /* clauu2_ */

/* Subroutine */ int clauum_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, ib, nb;
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *), cherk_(char *,
        char *, integer *, integer *, real *, singlecomplex *, integer *, real *
        , singlecomplex *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int ctrmm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *);
    static logical upper;
    外部声明：子例程 clauu2，接受参数类型为 char*, integer*, singlecomplex*, integer*, integer*
    extern /* Subroutine */ int clauu2_(char *, integer *, singlecomplex *, integer
        *, integer *);
    外部声明：子例程 xerbla，接受参数类型为 char*, integer*
    extern /* Subroutine */ int xerbla_(char *, integer *);
    外部声明：函数 ilaenv，接受参数为 integer*, char*, char*, integer*, integer*, integer*, integer*, ftnlen, ftnlen
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CLAUUM computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the blocked form of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    // 判断 UPLO 参数是否为 'U' 或 'L'
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        // 如果 UPLO 参数既不是 'U' 也不是 'L'，则返回错误信息
        *info = -1;
    } else if (*n < 0) {
        // 如果 N 参数小于 0，则返回错误信息
        *info = -2;
    } else if (*lda < max(1,*n)) {
        // 如果 LDA 参数小于 max(1, N)，则返回错误信息
        *info = -4;
    }
    if (*info != 0) {
        // 如果 INFO 不为 0，调用错误处理函数 xerbla_
        i__1 = -(*info);
        xerbla_("CLAUUM", &i__1);
        return 0;
    }

    /* Quick return if possible */
    // 如果 N 为 0，直接返回
    if (*n == 0) {
        return 0;
    }

    /* Determine the block size for this environment. */
    // 根据当前环境确定块大小
    nb = ilaenv_(&c__1, "CLAUUM", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);

    if (nb <= 1 || nb >= *n) {

        /* Use unblocked code */
        // 如果块大小 nb <= 1 或者 nb >= N，使用非块状代码 clauu2_
        clauu2_(uplo, n, &a[a_offset], lda, info);
    } else {

        /* Use blocked code */
        // 使用块状代码

        if (upper) {

            /* Compute the product U * U'. */
            // 计算乘积 U * U'

            // 循环处理块
            i__1 = *n;
            i__2 = nb;
            for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
/* 计算最小值 */
        i__3 = nb, i__4 = *n - i__ + 1;
/* 计算两个值的最小值，确定当前迭代中子矩阵的大小 */
        ib = min(i__3,i__4);
/* 将计算得到的最小值赋给ib，确定当前迭代中子矩阵的大小 */
        i__3 = i__ - 1;
/* 计算i__ - 1 */
        ctrmm_("Right", "Upper", "Conjugate transpose", "Non-unit", &
/* 调用BLAS库函数ctrmm，右侧矩阵乘，上三角，共轭转置，非单位三角矩阵 */
            i__3, &ib, &c_b57, &a[i__ + i__ * a_dim1], lda, &a[
/* 传递参数给ctrmm函数 */
            i__ * a_dim1 + 1], lda);
/* 传递参数给ctrmm函数 */
        clauu2_("Upper", &ib, &a[i__ + i__ * a_dim1], lda, info);
/* 调用BLAS库函数clauu2，计算上三角部分的Cholesky分解 */
        if (i__ + ib <= *n) {
/* 检查是否存在剩余的子矩阵需要处理 */
            i__3 = i__ - 1;
/* 计算i__ - 1 */
            i__4 = *n - i__ - ib + 1;
/* 计算需要处理的列数 */
            cgemm_("No transpose", "Conjugate transpose", &i__3, &ib,
/* 调用BLAS库函数cgemm，不进行转置，进行共轭转置 */
                &i__4, &c_b57, &a[(i__ + ib) * a_dim1 + 1], lda, &
/* 传递参数给cgemm函数 */
                a[i__ + (i__ + ib) * a_dim1], lda, &c_b57, &a[i__
/* 传递参数给cgemm函数 */
                * a_dim1 + 1], lda);
/* 传递参数给cgemm函数 */
            i__3 = *n - i__ - ib + 1;
/* 计算需要处理的列数 */
            cherk_("Upper", "No transpose", &ib, &i__3, &c_b1034, &a[
/* 调用BLAS库函数cherk，计算矩阵的Hermitian rank-k更新 */
                i__ + (i__ + ib) * a_dim1], lda, &c_b1034, &a[i__
/* 传递参数给cherk函数 */
                + i__ * a_dim1], lda);
/* 传递参数给cherk函数 */
        }
/* L10: */
/* 结束if分支 */
        }
/* 结束for循环 */
    } else {
/* 开始else分支 */
/*           Compute the product L' * L. */
/* 计算矩阵L' * L的乘积 */

        i__2 = *n;
/* 设置循环的上界 */
        i__1 = nb;
/* 设置循环的步长 */
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {
/* 开始for循环 */
/* Computing MIN */
/* 计算最小值 */
        i__3 = nb, i__4 = *n - i__ + 1;
/* 计算两个值的最小值，确定当前迭代中子矩阵的大小 */
        ib = min(i__3,i__4);
/* 将计算得到的最小值赋给ib，确定当前迭代中子矩阵的大小 */
        i__3 = i__ - 1;
/* 计算i__ - 1 */
        ctrmm_("Left", "Lower", "Conjugate transpose", "Non-unit", &
/* 调用BLAS库函数ctrmm，左侧矩阵乘，下三角，共轭转置，非单位三角矩阵 */
            ib, &i__3, &c_b57, &a[i__ + i__ * a_dim1], lda, &a[
/* 传递参数给ctrmm函数 */
            i__ + a_dim1], lda);
/* 传递参数给ctrmm函数 */
        clauu2_("Lower", &ib, &a[i__ + i__ * a_dim1], lda, info);
/* 调用BLAS库函数clauu2，计算下三角部分的Cholesky分解 */
        if (i__ + ib <= *n) {
/* 检查是否存在剩余的子矩阵需要处理 */
            i__3 = i__ - 1;
/* 计算i__ - 1 */
            i__4 = *n - i__ - ib + 1;
/* 计算需要处理的列数 */
            cgemm_("Conjugate transpose", "No transpose", &ib, &i__3,
/* 调用BLAS库函数cgemm，进行共轭转置，不进行转置 */
                &i__4, &c_b57, &a[i__ + ib + i__ * a_dim1], lda, &
/* 传递参数给cgemm函数 */
                a[i__ + ib + a_dim1], lda, &c_b57, &a[i__ +
/* 传递参数给cgemm函数 */
                a_dim1], lda);
/* 传递参数给cgemm函数 */
            i__3 = *n - i__ - ib + 1;
/* 计算需要处理的列数 */
            cherk_("Lower", "Conjugate transpose", &ib, &i__3, &
/* 调用BLAS库函数cherk，计算矩阵的Hermitian rank-k更新 */
                c_b1034, &a[i__ + ib + i__ * a_dim1], lda, &
/* 传递参数给cherk函数 */
                c_b1034, &a[i__ + i__ * a_dim1], lda);
/* 传递参数给cherk函数 */
        }
/* L20: */
/* 结束if分支 */
        }
/* 结束for循环 */
    }
/* 结束else分支 */
    }
/* 结束subroutine */
    return 0;
/* 返回0 */
/*     End of CLAUUM */
/* 结束CLAUUM */

} /* clauum_ */

/* Subroutine */ int cpotf2_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     integer *info)
{
/* 开始subroutine */
    /* System generated locals */
/* 系统生成的本地变量 */
    integer a_dim1, a_offset, i__1, i__2, i__3;
/* 声明本地整型变量 */
    real r__1;
/* 声明本地实型变量 */
    singlecomplex q__1, q__2;
/* 声明本地复数型变量 */

    /* Local variables */
/* 本地变量 */
    static integer j;
/* 声明静态整型变量 */
    static real ajj;
/* 声明静态实型变量 */
    extern /* Complex */ VOID cdotc_(singlecomplex *, integer *, singlecomplex *, integer
        *, singlecomplex *, integer *);
/* 声明外部函数，计算两个复数向量的内积 */
    extern logical lsame_(char *, char *);
/* 声明外部函数，比较两个字符是否相同 */
    extern /* Subroutine */ int cgemv_(char *, integer *, integer *, singlecomplex *
        , singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *);
/* 声明外部函数，进行矩阵向量乘法 */
    static logical upper;
/* 声明静态逻辑型变量 */
    extern /* Subroutine */ int clacgv_(integer *, singlecomplex *, integer *),
/* 声明外部函数，共轭转置向量 */
        csscal_(integer *, real *, singlecomplex *, integer *), xerbla_(char *,
/* 声明外部函数，生成错误消息并终止程序 */
        integer *);
/* 声明外部函数，生成错误消息并终止程序 */
    # 声明一个外部函数 `sisnan_`，用于检查实数是否为 NaN（Not a Number）
    extern logical sisnan_(real *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CPOTF2 computes the Cholesky factorization of a complex Hermitian
    positive definite matrix A.

    The factorization has the form
       A = U' * U ,  if UPLO = 'U', or
       A = L  * L',  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U'*U  or A = L*L'.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.

    =====================================================================


       Test the input parameters.
*/

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;

/* Function Body */
*info = 0;
upper = lsame_(uplo, "U");
if (! upper && ! lsame_(uplo, "L")) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*lda < max(1,*n)) {
*info = -4;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CPOTF2", &i__1);
return 0;
}

/* Quick return if possible */

if (*n == 0) {
return 0;
}

if (upper) {

/* Compute the Cholesky factorization A = U'*U. */

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
/*           Compute U(J,J) and test for non-positive-definiteness. */

        // 计算矩阵A的主对角线元素U(J,J)
        i__2 = j + j * a_dim1;
        // 获取A(J,J)的实部
        r__1 = a[i__2].r;
        // 计算矩阵A的列向量与自身的内积，存储在q__2中
        i__3 = j - 1;
        cdotc_(&q__2, &i__3, &a[j * a_dim1 + 1], &c__1, &a[j * a_dim1 + 1]
            , &c__1);
        // 计算A(J,J) - 内积结果的实部，得到U(J,J)
        q__1.r = r__1 - q__2.r, q__1.i = -q__2.i;
        ajj = q__1.r;
        // 检查U(J,J)是否非正定或是否为NaN
        if (ajj <= 0.f || sisnan_(&ajj)) {
        // 如果非正定或NaN，将U(J,J)设为0
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.f;
        // 跳转到标签L30
        goto L30;
        }
        // 计算U(J,J)的平方根，得到U(J,J)
        ajj = sqrt(ajj);
        // 将U(J,J)存入A(J,J)
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.f;

/*           Compute elements J+1:N of row J. */

        // 如果J小于总列数N
        if (j < *n) {
        // 对A的第J行的前J-1列进行共轭变换
        i__2 = j - 1;
        clacgv_(&i__2, &a[j * a_dim1 + 1], &c__1);
        // 计算A的第J行中从第J+1列到第N列的元素
        i__2 = j - 1;
        i__3 = *n - j;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("Transpose", &i__2, &i__3, &q__1, &a[(j + 1) * a_dim1
            + 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b57, &a[j + (
            j + 1) * a_dim1], lda);
        // 对A的第J行的前J-1列进行共轭变换
        i__2 = j - 1;
        clacgv_(&i__2, &a[j * a_dim1 + 1], &c__1);
        // 计算结果向量除以U(J,J)
        i__2 = *n - j;
        r__1 = 1.f / ajj;
        csscal_(&i__2, &r__1, &a[j + (j + 1) * a_dim1], lda);
        }
/* L10: */
    }
    } else {

/*        Compute the Cholesky factorization A = L*L'. */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {

/*           Compute L(J,J) and test for non-positive-definiteness. */

        // 计算矩阵A的主对角线元素L(J,J)
        i__2 = j + j * a_dim1;
        // 获取A(J,J)的实部
        r__1 = a[i__2].r;
        // 计算矩阵A的列向量与自身的内积，存储在q__2中
        i__3 = j - 1;
        cdotc_(&q__2, &i__3, &a[j + a_dim1], lda, &a[j + a_dim1], lda);
        // 计算A(J,J) - 内积结果的实部，得到L(J,J)
        q__1.r = r__1 - q__2.r, q__1.i = -q__2.i;
        ajj = q__1.r;
        // 检查L(J,J)是否非正定或是否为NaN
        if (ajj <= 0.f || sisnan_(&ajj)) {
        // 如果非正定或NaN，将L(J,J)设为0
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.f;
        // 跳转到标签L30
        goto L30;
        }
        // 计算L(J,J)的平方根，得到L(J,J)
        ajj = sqrt(ajj);
        // 将L(J,J)存入A(J,J)
        i__2 = j + j * a_dim1;
        a[i__2].r = ajj, a[i__2].i = 0.f;

/*           Compute elements J+1:N of column J. */

        // 如果J小于总列数N
        if (j < *n) {
        // 对A的第J列的前J-1行进行共轭变换
        i__2 = j - 1;
        clacgv_(&i__2, &a[j + a_dim1], lda);
        // 计算A的第J列中从第J+1行到第N行的元素
        i__2 = *n - j;
        i__3 = j - 1;
        q__1.r = -1.f, q__1.i = -0.f;
        cgemv_("No transpose", &i__2, &i__3, &q__1, &a[j + 1 + a_dim1]
            , lda, &a[j + a_dim1], lda, &c_b57, &a[j + 1 + j *
            a_dim1], &c__1);
        // 对A的第J列的前J-1行进行共轭变换
        i__2 = j - 1;
        clacgv_(&i__2, &a[j + a_dim1], lda);
        // 计算结果向量除以L(J,J)
        i__2 = *n - j;
        r__1 = 1.f / ajj;
        csscal_(&i__2, &r__1, &a[j + 1 + j * a_dim1], &c__1);
        }
/* L20: */
    }
    }
    // 跳转到标签L40
    goto L40;

L30:
    // 如果进入此处，将当前迭代次数存入info
    *info = j;

L40:
    // 返回0表示成功完成Cholesky分解
    return 0;

/*     End of CPOTF2 */

} /* cpotf2_ */

/* Subroutine */ int cpotrf_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    singlecomplex q__1;

    /* Local variables */
    static integer j, jb, nb;
    # 外部函数声明：定义了一些外部的 Fortran 子例程，具体功能和实现不在此处展开
    extern /* Subroutine */ int cgemm_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);

    # 外部函数声明：定义了一个逻辑函数 lsame_，用于比较两个字符是否相同
    extern logical lsame_(char *, char *);

    # 外部函数声明：定义了一个矩阵操作的子例程 ctrsm_
    extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *);

    # 静态变量声明：声明了一个静态逻辑变量 upper
    static logical upper;

    # 外部函数声明：定义了一个 Cholesky 分解的子例程 cpotf2_
    extern /* Subroutine */ int cpotf2_(char *, integer *, singlecomplex *, integer
        *, integer *);

    # 外部函数声明：定义了一个错误处理例程 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 外部函数声明：定义了一个用于环境查询的函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CPOTRF computes the Cholesky factorization of a complex Hermitian
    positive definite matrix A.

    The factorization has the form
       A = U**H * U,  if UPLO = 'U', or
       A = L  * L**H,  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the block version of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.

    =====================================================================


       Test the input parameters.
*/

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;

/* Function Body */
*info = 0;
// 判断 UPLO 是否为 'U'，若不是则判断是否为 'L'，若不是则返回错误信息
upper = lsame_(uplo, "U");
if (! upper && ! lsame_(uplo, "L")) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*lda < max(1,*n)) {
*info = -4;
}
// 如果参数检查不通过，则调用错误处理函数并返回
if (*info != 0) {
i__1 = -(*info);
xerbla_("CPOTRF", &i__1);
return 0;
}

/*     Quick return if possible */

// 如果矩阵阶数 N 为 0，则直接返回
if (*n == 0) {
return 0;
}

/*     Determine the block size for this environment. */

// 根据环境确定块大小 nb
nb = ilaenv_(&c__1, "CPOTRF", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (
    ftnlen)1);
// 如果块大小 nb 小于等于 1 或者大于等于矩阵阶数 N，则使用未块化的算法
if (nb <= 1 || nb >= *n) {

/*        Use unblocked code. */

cpotf2_(uplo, n, &a[a_offset], lda, info);
} else {

/*        Use blocked code. */

// 如果上三角矩阵，则使用基于块的 Cholesky 分解算法
if (upper) {
/*
           计算 Cholesky 分解 A = U'*U。
*/

        i__1 = *n;
        i__2 = nb;
        for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*
                更新并因子化当前对角块，并测试是否非正定。

   计算 MIN
*/
        i__3 = nb, i__4 = *n - j + 1;
        jb = min(i__3,i__4);
        i__3 = j - 1;
        cherk_("Upper", "Conjugate transpose", &jb, &i__3, &c_b1276, &
            a[j * a_dim1 + 1], lda, &c_b1034, &a[j + j * a_dim1],
            lda);
        cpotf2_("Upper", &jb, &a[j + j * a_dim1], lda, info);
        if (*info != 0) {
            goto L30;
        }
        if (j + jb <= *n) {

/*                 计算当前块行。 */

            i__3 = *n - j - jb + 1;
            i__4 = j - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("Conjugate transpose", "No transpose", &jb, &i__3,
                &i__4, &q__1, &a[j * a_dim1 + 1], lda, &a[(j + jb)
                 * a_dim1 + 1], lda, &c_b57, &a[j + (j + jb) *
                a_dim1], lda);
            i__3 = *n - j - jb + 1;
            ctrsm_("Left", "Upper", "Conjugate transpose", "Non-unit",
                 &jb, &i__3, &c_b57, &a[j + j * a_dim1], lda, &a[
                j + (j + jb) * a_dim1], lda);
        }
/* L10: */
        }

    } else {

/*
           计算 Cholesky 分解 A = L*L'。
*/

        i__2 = *n;
        i__1 = nb;
        for (j = 1; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*
                更新并因子化当前对角块，并测试是否非正定。

   计算 MIN
*/
        i__3 = nb, i__4 = *n - j + 1;
        jb = min(i__3,i__4);
        i__3 = j - 1;
        cherk_("Lower", "No transpose", &jb, &i__3, &c_b1276, &a[j +
            a_dim1], lda, &c_b1034, &a[j + j * a_dim1], lda);
        cpotf2_("Lower", &jb, &a[j + j * a_dim1], lda, info);
        if (*info != 0) {
            goto L30;
        }
        if (j + jb <= *n) {

/*                 计算当前块列。 */

            i__3 = *n - j - jb + 1;
            i__4 = j - 1;
            q__1.r = -1.f, q__1.i = -0.f;
            cgemm_("No transpose", "Conjugate transpose", &i__3, &jb,
                &i__4, &q__1, &a[j + jb + a_dim1], lda, &a[j +
                a_dim1], lda, &c_b57, &a[j + jb + j * a_dim1],
                lda);
            i__3 = *n - j - jb + 1;
            ctrsm_("Right", "Lower", "Conjugate transpose", "Non-unit"
                , &i__3, &jb, &c_b57, &a[j + j * a_dim1], lda, &a[
                j + jb + j * a_dim1], lda);
        }
/* L20: */
        }
    }
    }
    goto L40;

L30:
    *info = *info + j - 1;

L40:
    return 0;

/*     CPOTRF 结束 */

} /* cpotrf_ */

/* 子例程 cpotri_ */

/* Subroutine */ int cpotri_(char *uplo, integer *n, singlecomplex *a, integer *lda,
     integer *info)
{
    /* 系统生成的本地变量 */
    integer a_dim1, a_offset, i__1;

    /* 局部变量 */
    # 声明外部函数 lsame_
    extern logical lsame_(char *, char *);
    # 声明外部函数 xerbla_
    extern /* Subroutine */ int xerbla_(char *, integer *);
    # 声明外部子程序 clauum_
    extern /* Subroutine */ int clauum_(
        char *, integer *, singlecomplex *, integer *, integer *);
    # 声明外部子程序 ctrtri_
    extern /* Subroutine */ int ctrtri_(
        char *, char *, integer *, singlecomplex *, integer *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CPOTRI computes the inverse of a complex Hermitian positive definite
    matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    computed by CPOTRF.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H, as computed by
            CPOTRF.
            On exit, the upper or lower triangle of the (Hermitian)
            inverse of A, overwriting the input factor U or L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.

    =====================================================================


       Test the input parameters.
*/
void cpotri_(char *uplo, integer *n, singlecomplex *a, integer *lda, integer *info) {
    /* Parameter adjustments */
    integer a_dim1, a_offset;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        integer i__1 = -(*info);
        xerbla_("CPOTRI", &i__1);
        return;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return;
    }

    /* Invert the triangular Cholesky factor U or L. */
    ctrtri_(uplo, "Non-unit", n, &a[a_offset], lda, info);
    if (*info > 0) {
        return;
    }

    /* Form inv(U)*inv(U)' or inv(L)'*inv(L). */
    clauum_(uplo, n, &a[a_offset], lda, info);

    return;
} /* cpotri_ */

/* Subroutine */ void cpotrs_(char *uplo, integer *n, integer *nrhs, singlecomplex *
    a, integer *lda, singlecomplex *b, integer *ldb, integer *info) {
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static logical upper;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ void ctrsm_(char *, char *, char *, char *,
        integer *, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *,
        integer *);
    extern /* Subroutine */ void xerbla_(char *, integer *);

    /*
        -- LAPACK routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    upper = lsame_(uplo, "U");

    /* Test the input parameters */
    *info = 0;
    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    } else if (*ldb < max(1,*n)) {
        *info = -7;
    }
    if (*info != 0) {
        integer i__1 = -(*info);
        xerbla_("CPOTRS", &i__1);
        return;
    }

    /* Quick return if possible */
    if (*n == 0 || *nrhs == 0) {
        return;
    }

    /* Solve A*X = B or A**T*X = B */
    ctrsm_("Left", uplo, "No transpose", "Non-unit", n, nrhs, (singlecomplex *) &c_b1, &a[
        a_offset], lda, &b[b_offset], ldb);

    return;
} /* cpotrs_ */


注释完成。
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CPOTRS solves a system of linear equations A*X = B with a Hermitian
    positive definite matrix A using the Cholesky factorization
    A = U**H*U or A = L*L**H computed by CPOTRF.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input) COMPLEX array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H, as computed by CPOTRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    B       (input/output) COMPLEX array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input parameters.


注释：

-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006
    作者信息和代码更新日期

Purpose
    CPOTRS函数的目的说明，解决Hermitian正定矩阵A的线性方程组A*X = B，使用CPOTRF计算的Cholesky分解A = U**H*U或A = L*L**H。

Arguments
    函数参数说明：

UPLO    (input) CHARACTER*1
        存储A的上三角或下三角信息：
        = 'U':  A的上三角被存储；
        = 'L':  A的下三角被存储。

N       (input) INTEGER
        矩阵A的阶数。N >= 0。

NRHS    (input) INTEGER
        右手边矩阵B的列数，即B的列数。NRHS >= 0。

A       (input) COMPLEX array, dimension (LDA,N)
        Cholesky分解得到的上三角矩阵U或下三角矩阵L。A = U**H*U 或 A = L*L**H，由CPOTRF计算得到。

LDA     (input) INTEGER
        数组A的第一维长度。LDA >= max(1,N)。

B       (input/output) COMPLEX array, dimension (LDB,NRHS)
        输入时为右手边矩阵B，输出时为解矩阵X。

LDB     (input) INTEGER
        数组B的第一维长度。LDB >= max(1,N)。

INFO    (output) INTEGER
        函数执行信息：
        = 0: 成功退出。
        < 0: 若INFO = -i，表示第i个参数具有非法值。

=====================================================================

Test the input parameters.
    测试输入参数的有效性。
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
b_dim1 = *ldb;
b_offset = 1 + b_dim1;
b -= b_offset;

/* Function Body */
*info = 0;
upper = lsame_(uplo, "U");
if (! upper && ! lsame_(uplo, "L")) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*nrhs < 0) {
*info = -3;
} else if (*lda < max(1,*n)) {
*info = -5;
} else if (*ldb < max(1,*n)) {
*info = -7;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CPOTRS", &i__1);
return 0;
}

/* Quick return if possible */

if (*n == 0 || *nrhs == 0) {
return 0;
}

if (upper) {

/*
      Solve A*X = B where A = U'*U.

      Solve U'*X = B, overwriting B with X.
*/

ctrsm_("Left", "Upper", "Conjugate transpose", "Non-unit", n, nrhs, &
    c_b57, &a[a_offset], lda, &b[b_offset], ldb);

/* Solve U*X = B, overwriting B with X. */

ctrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b57, &
    a[a_offset], lda, &b[b_offset], ldb);
} else {

/*
      Solve A*X = B where A = L*L'.

      Solve L*X = B, overwriting B with X.
*/

ctrsm_("Left", "Lower", "No transpose", "Non-unit", n, nrhs, &c_b57, &
    a[a_offset], lda, &b[b_offset], ldb);

/* Solve L'*X = B, overwriting B with X. */

ctrsm_("Left", "Lower", "Conjugate transpose", "Non-unit", n, nrhs, &
    c_b57, &a[a_offset], lda, &b[b_offset], ldb);
}

return 0;

/* End of CPOTRS */

} /* cpotrs_ */

/* Subroutine */ int crot_(integer *n, singlecomplex *cx, integer *incx, singlecomplex *
    cy, integer *incy, real *c__, singlecomplex *s)
{
/* System generated locals */
integer i__1, i__2, i__3, i__4;
singlecomplex q__1, q__2, q__3, q__4;

/* Local variables */
static integer i__, ix, iy;
static singlecomplex stemp;


/*
-- LAPACK auxiliary routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

CROT   applies a plane rotation, where the cos (C) is real and the
sin (S) is complex, and the vectors CX and CY are complex.

Arguments
=========

N       (input) INTEGER
        The number of elements in the vectors CX and CY.

CX      (input/output) COMPLEX array, dimension (N)
        On input, the vector X.
        On output, CX is overwritten with C*X + S*Y.

INCX    (input) INTEGER
        The increment between successive values of CY.  INCX <> 0.

CY      (input/output) COMPLEX array, dimension (N)
        On input, the vector Y.
        On output, CY is overwritten with -CONJG(S)*X + C*Y.

INCY    (input) INTEGER
        The increment between successive values of CY.  INCX <> 0.

C       (input) REAL


注释：
    S       (input) COMPLEX
            # S 是一个复数输入参数，用于定义一个旋转矩阵的一部分。
            # 旋转矩阵如下所示：
            # [  C          S  ]
            # [ -conjg(S)   C  ]
            # 其中 C 是另一个参数，共同定义了这个旋转。
            # C*C + S*CONJG(S) = 1.0 是一个约束条件，确保旋转矩阵是单位长度的。
/* Parameter adjustments */
--cy;
--cx;
/*
调整参数，将指针移动到数组 `cy` 和 `cx` 的起始位置
*/

/* Function Body */
if (*n <= 0) {
/*
如果输入的长度 `n` 小于等于 0，则直接返回 0
*/
return 0;
}
if (*incx == 1 && *incy == 1) {
/*
如果 `incx` 和 `incy` 都等于 1，跳转到标签 L20 处
*/
goto L20;
}

/*     Code for unequal increments or equal increments not equal to 1 */
/*
处理不等增量或者增量不等于1的情况的代码
*/

ix = 1;
iy = 1;
if (*incx < 0) {
/*
如果 `incx` 小于 0，则计算 `ix` 的起始位置
*/
ix = (-(*n) + 1) * *incx + 1;
}
if (*incy < 0) {
/*
如果 `incy` 小于 0，则计算 `iy` 的起始位置
*/
iy = (-(*n) + 1) * *incy + 1;
}
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
/*
循环处理每个元素，`i__` 从 1 到 `n`
*/
i__2 = ix;
q__2.r = *c__ * cx[i__2].r, q__2.i = *c__ * cx[i__2].i;
i__3 = iy;
q__3.r = s->r * cy[i__3].r - s->i * cy[i__3].i, q__3.i = s->r * cy[
    i__3].i + s->i * cy[i__3].r;
q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
stemp.r = q__1.r, stemp.i = q__1.i;
i__2 = iy;
i__3 = iy;
q__2.r = *c__ * cy[i__3].r, q__2.i = *c__ * cy[i__3].i;
r_cnjg(&q__4, s);
i__4 = ix;
q__3.r = q__4.r * cx[i__4].r - q__4.i * cx[i__4].i, q__3.i = q__4.r *
    cx[i__4].i + q__4.i * cx[i__4].r;
q__1.r = q__2.r - q__3.r, q__1.i = q__2.i - q__3.i;
cy[i__2].r = q__1.r, cy[i__2].i = q__1.i;
i__2 = ix;
cx[i__2].r = stemp.r, cx[i__2].i = stemp.i;
ix += *incx;
iy += *incy;
/* L10: */
}
return 0;
/*
循环结束后返回 0
*/

/*     Code for both increments equal to 1 */

L20:
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
/*
处理增量都等于 1 的情况的代码，`i__` 从 1 到 `n`
*/
i__2 = i__;
q__2.r = *c__ * cx[i__2].r, q__2.i = *c__ * cx[i__2].i;
i__3 = i__;
q__3.r = s->r * cy[i__3].r - s->i * cy[i__3].i, q__3.i = s->r * cy[
    i__3].i + s->i * cy[i__3].r;
q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
stemp.r = q__1.r, stemp.i = q__1.i;
i__2 = i__;
i__3 = i__;
q__2.r = *c__ * cy[i__3].r, q__2.i = *c__ * cy[i__3].i;
r_cnjg(&q__4, s);
i__4 = i__;
q__3.r = q__4.r * cx[i__4].r - q__4.i * cx[i__4].i, q__3.i = q__4.r *
    cx[i__4].i + q__4.i * cx[i__4].r;
q__1.r = q__2.r - q__3.r, q__1.i = q__2.i - q__3.i;
cy[i__2].r = q__1.r, cy[i__2].i = q__1.i;
i__2 = i__;
cx[i__2].r = stemp.r, cx[i__2].i = stemp.i;
/* L30: */
}
return 0;
/*
循环结束后返回 0
}
*/

/* crot_ */
/*
子例程的名称为 `crot_`
*/

/* Subroutine */ int cstedc_(char *compz, integer *n, real *d__, real *e,
singlecomplex *z__, integer *ldz, singlecomplex *work, integer *lwork, real *
rwork, integer *lrwork, integer *iwork, integer *liwork, integer *
info)
{
/*
子例程 `cstedc_` 的定义
*/

/* System generated locals */
integer z_dim1, z_offset, i__1, i__2, i__3, i__4;
real r__1, r__2;
/*
系统生成的本地变量声明
*/

/* Local variables */
static integer i__, j, k, m;
static real p;
static integer ii, ll, lgn;
static real eps, tiny;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int cswap_(integer *, singlecomplex *, integer *,
    singlecomplex *, integer *);
/*
声明本地变量和外部子例程 `lsame_`, `cswap_`
*/

static integer lwmin;
extern /* Subroutine */ int claed0_(integer *, integer *, real *, real *,
    singlecomplex *, integer *, singlecomplex *, integer *, real *, integer *,
    integer *);
static integer start;
/*
声明本地变量和外部子例程 `claed0_`
*/
    ! 声明外部子程序 clacrm_
    extern /* Subroutine */ int clacrm_(integer *, integer *, singlecomplex *,
        integer *, real *, integer *, singlecomplex *, integer *, real *);

    ! 声明外部函数 slamch_
    extern doublereal slamch_(char *);

    ! 声明外部子程序 clacpy_
    extern /* Subroutine */ int clacpy_(char *, integer *, integer *, singlecomplex
        *, integer *, singlecomplex *, integer *);

    ! 声明外部子程序 xerbla_
    extern /* Subroutine */ int xerbla_(char *,
        integer *);

    ! 声明外部函数 ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    ! 声明静态整型变量 finish
    static integer finish;

    ! 声明外部子程序 slascl_
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);

    ! 声明外部子程序 sstedc_
    extern /* Subroutine */ int sstedc_(char *, integer *, real *, real *, real *,
        integer *, real *, integer *, integer *, integer *, integer *);

    ! 声明外部子程序 slaset_
    extern /* Subroutine */ int slaset_(char *, integer *, integer *, real *, real *,
        real *, integer *);

    ! 声明静态整型变量 liwmin, icompz
    static integer liwmin, icompz;

    ! 声明外部子程序 csteqr_
    extern /* Subroutine */ int csteqr_(char *, integer *, real *, real *,
        singlecomplex *, integer *, real *, integer *);

    ! 声明静态实数变量 orgnrm
    static real orgnrm;

    ! 声明外部函数 slanst_
    extern doublereal slanst_(char *, integer *, real *, real *);

    ! 声明外部子程序 ssterf_
    extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *);

    ! 声明静态整型变量 lrwmin
    static integer lrwmin;

    ! 声明静态逻辑变量 lquery
    static logical lquery;

    ! 声明静态整型变量 smlsiz
    static integer smlsiz;

    ! 声明外部子程序 ssteqr_
    extern /* Subroutine */ int ssteqr_(char *, integer *, real *, real *,
        real *, integer *, real *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.
    The eigenvectors of a full or band complex Hermitian matrix can also
    be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
    matrix to tridiagonal form.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See SLAED3 for details.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original Hermitian matrix
                    also.  On entry, Z contains the unitary matrix used
                    to reduce the original matrix to tridiagonal form.

    N       (input) INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D       (input/output) REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.

    Z       (input/output) COMPLEX array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).

    WORK    (workspace/output) COMPLEX    array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
            Note that for COMPZ = 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be 1.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.


```    
    RWORK   (workspace/output) REAL array, dimension (MAX(1,LRWORK))
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.



    LRWORK  (input) INTEGER
            The dimension of the array RWORK.
            If COMPZ = 'N' or N <= 1, LRWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LRWORK must be at least
                           1 + 3*N + 2*N*lg N + 3*N**2 ,
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1, LRWORK must be at least
                           1 + 4*N + 2*N**2 .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LRWORK
            need only be max(1,2*(N-1)).

            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.



    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.



    LIWORK  (input) INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N <= 1, LIWORK must be at least 1.
            If COMPZ = 'V' or N > 1,  LIWORK must be at least
                                      6 + 6*N + 5*N*lg N.
            If COMPZ = 'I' or N > 1,  LIWORK must be at least
                                      3 + 5*N .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.

            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
    # INFO (输出) INTEGER
    #     = 0:  成功退出。
    #     < 0:  如果 INFO = -i，则第 i 个参数的值非法。
    #     > 0:  算法在处理位于行和列 INFO/(N+1) 到 mod(INFO,N+1) 的子矩阵时未能计算出特征值。

    # 进一步细节
    # ===============

    # 基于以下贡献而制定：
    #    Jeff Rutter，加州大学伯克利分校计算机科学系，美国

    # =====================================================================


    # 检查输入参数。
    /* Parameter adjustments */
    --d__;                  // 调整参数 d__
    --e;                    // 调整参数 e
    z_dim1 = *ldz;          // 获取 z 的第一维度大小
    z_offset = 1 + z_dim1;  // 计算 z 的偏移量
    z__ -= z_offset;        // 调整 z 的起始地址
    --work;                 // 调整参数 work
    --rwork;                // 调整参数 rwork
    --iwork;                // 调整参数 iwork

    /* Function Body */
    *info = 0;              // 初始化 info 为 0
    lquery = *lwork == -1 || *lrwork == -1 || *liwork == -1;  // 检查是否进行查询

    if (lsame_(compz, "N")) {   // 如果 compz 等于 "N"
        icompz = 0;             // 设置 icompz 为 0
    } else if (lsame_(compz, "V")) {  // 如果 compz 等于 "V"
        icompz = 1;             // 设置 icompz 为 1
    } else if (lsame_(compz, "I")) {  // 如果 compz 等于 "I"
        icompz = 2;             // 设置 icompz 为 2
    } else {
        icompz = -1;            // 否则设置 icompz 为 -1
    }
    if (icompz < 0) {           // 如果 icompz 小于 0
        *info = -1;             // 设置 info 为 -1
    } else if (*n < 0) {        // 如果 n 小于 0
        *info = -2;             // 设置 info 为 -2
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {  // 如果 ldz 小于 1 或者 (icompz 大于 0 且 ldz 小于 max(1, n))
        *info = -6;             // 设置 info 为 -6
    }

    if (*info == 0) {

        /* Compute the workspace requirements */

        smlsiz = ilaenv_(&c__9, "CSTEDC", " ", &c__0, &c__0, &c__0, &c__0, (ftnlen)6, (ftnlen)1);  // 计算工作空间需求
        if (*n <= 1 || icompz == 0) {  // 如果 n 小于等于 1 或者 icompz 等于 0
            lwmin = 1;               // 设置 lwmin 为 1
            liwmin = 1;              // 设置 liwmin 为 1
            lrwmin = 1;              // 设置 lrwmin 为 1
        } else if (*n <= smlsiz) {   // 如果 n 小于等于 smlsiz
            lwmin = 1;               // 设置 lwmin 为 1
            liwmin = 1;              // 设置 liwmin 为 1
            lrwmin = *n - 1 << 1;    // 设置 lrwmin 为 (n-1)*2
        } else if (icompz == 1) {    // 如果 icompz 等于 1
            lgn = (integer) (log((real) (*n)) / log(2.f));  // 计算 log2(n)
            if (pow_ii(&c__2, &lgn) < *n) {  // 如果 2^lgn 小于 n
                ++lgn;                 // lgn 加一
            }
            if (pow_ii(&c__2, &lgn) < *n) {  // 如果 2^lgn 小于 n
                ++lgn;                 // lgn 加一
            }
            lwmin = *n * *n;           // 设置 lwmin 为 n^2
            lrwmin = *n * 3 + 1 + (*n << 1) * lgn + (*n) * (*n) * 3;  // 计算 lrwmin
            liwmin = *n * 6 + 6 + (*n) * 5 * lgn;  // 计算 liwmin
        } else if (icompz == 2) {    // 如果 icompz 等于 2
            lwmin = 1;               // 设置 lwmin 为 1
            lrwmin = (*n << 2) + 1 + ((*n) * (*n) << 1);  // 计算 lrwmin
            liwmin = *n * 5 + 3;     // 计算 liwmin
        }
        work[1].r = (real) lwmin, work[1].i = 0.f;  // 设置 work[1]
        rwork[1] = (real) lrwmin;   // 设置 rwork[1]
        iwork[1] = liwmin;          // 设置 iwork[1]

        if (*lwork < lwmin && ! lquery) {  // 如果 lwork 小于 lwmin 且不是查询
            *info = -8;            // 设置 info 为 -8
        } else if (*lrwork < lrwmin && ! lquery) {  // 如果 lrwork 小于 lrwmin 且不是查询
            *info = -10;           // 设置 info 为 -10
        } else if (*liwork < liwmin && ! lquery) {  // 如果 liwork 小于 liwmin 且不是查询
            *info = -12;           // 设置 info 为 -12
        }
    }

    if (*info != 0) {              // 如果 info 不等于 0
        i__1 = -(*info);           // 设置 i__1 为 -info
        xerbla_("CSTEDC", &i__1);  // 调用错误处理函数 xerbla_
        return 0;                  // 返回 0
    } else if (lquery) {           // 否则如果是查询
        return 0;                  // 返回 0
    }

    /* Quick return if possible */

    if (*n == 0) {                 // 如果 n 等于 0
        return 0;                  // 返回 0
    }
    if (*n == 1) {                 // 如果 n 等于 1
        if (icompz != 0) {         // 如果 icompz 不等于 0
            i__1 = z_dim1 + 1;     // 计算索引
            z__[i__1].r = 1.f, z__[i__1].i = 0.f;  // 设置 z__ 的值
        }
        return 0;                  // 返回 0
    }

/*
       If the following conditional clause is removed, then the routine
       will use the Divide and Conquer routine to compute only the
       eigenvalues, which requires (3N + 3N**2) real workspace and
       (2 + 5N + 2N lg(N)) integer workspace.
       Since on many architectures SSTERF is much faster than any other
       algorithm for finding eigenvalues only, it is used here
       as the default. If the conditional clause is removed, then
       information on the size of workspace needs to be changed.

       If COMPZ = 'N', use SSTERF to compute the eigenvalues.
*/

    if (icompz == 0) {             // 如果 icompz 等于 0
        ssterf_(n, &d__[1], &e[1], info);  // 调用 SSTERF 计算特征值
        goto L70;                  // 跳转到标签 L70
    }
/*
       如果 N 小于等于最小分解大小 (SMLSIZ)，则使用另一种求解方法。
*/
if (*n <= smlsiz) {
    /*
       调用 LAPACK 函数 CSTEQR 解决问题。
       compz 指示是否计算特征向量，n 是矩阵维度，d 是主对角线元素，e 是次对角线元素，
       z 是存储特征向量的数组，ldz 是 z 的列数，rwork 是工作数组，info 是返回状态。
    */
    csteqr_(compz, n, &d__[1], &e[1], &z__[z_offset], ldz, &rwork[1], info);
} else {
    /*
       如果 COMPZ = 'I'，则调用 SSTEDC 函数。
       初始化工作数组 rwork，并调用 SSTEDC 求解特征值问题。
       n 是矩阵维度，d 是主对角线元素，e 是次对角线元素，rwork 是工作数组，
       liwork 是工作整型数组的长度，info 是返回状态。
    */
    if (icompz == 2) {
        slaset_("Full", n, n, &c_b328, &c_b1034, &rwork[1], n);
        ll = *n * *n + 1;
        i__1 = *lrwork - ll + 1;
        sstedc_("I", n, &d__[1], &e[1], &rwork[1], n, &rwork[ll], &i__1, &iwork[1], liwork, info);
        /*
           将计算得到的特征向量存储到 z 数组中。
           i 和 j 是循环索引。
        */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * z_dim1;
                i__4 = (j - 1) * *n + i__;
                z__[i__3].r = rwork[i__4], z__[i__3].i = 0.f;
                /* L10: */
            }
            /* L20: */
        }
        goto L70;
    }

    /*
       从现在开始，唯一剩下的选项是 COMPZ = 'V'，即 icompz = 1。
       进行矩阵的缩放。
    */
    orgnrm = slanst_("M", n, &d__[1], &e[1]);
    if (orgnrm == 0.f) {
        goto L70;
    }

    eps = slamch_("Epsilon");

    start = 1;

    /*
       当 start 小于等于 N 时执行循环。
    */
L30:
    if (start <= *n) {

        /*
           计算 FINISH，它是下一个次对角线条目的位置，满足 E(FINISH) <= TINY，
           或者如果没有这样的次对角线，FINISH = N。
           START 和 FINISH 之间的矩阵构成一个独立的子问题。
        */
        finish = start;
L40:
        if (finish < *n) {
            /*
               计算 TINY 的值，并根据其与次对角线元素的比较决定是否继续扩展 FINISH。
            */
            tiny = eps * sqrt((r__1 = d__[finish], dabs(r__1))) * sqrt((r__2 = d__[finish + 1], dabs(r__2)));
            if ((r__1 = e[finish], dabs(r__1)) > tiny) {
                ++finish;
                goto L40;
            }
        }

        /*
           确定了子问题。计算其大小并解决它。
        */
        m = finish - start + 1;
        if (m > smlsiz) {
            /*
               缩放子问题的矩阵，并调用 CLAED0 求解特征值问题。
               start 和 m 是子问题的起始和大小，z 是存储特征向量的数组，ldz 是 z 的列数，
               work 是工作数组，rwork 是工作实数数组，iwork 是工作整型数组，info 是返回状态。
            */
            orgnrm = slanst_("M", &m, &d__[start], &e[start]);
            slascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &m, &c__1, &d__[start], &m, info);
            i__1 = m - 1;
            i__2 = m - 1;
            slascl_("G", &c__0, &c__0, &orgnrm, &c_b1034, &i__1, &c__1, &e[start], &i__2, info);
            claed0_(n, &m, &d__[start], &e[start], &z__[start * z_dim1 + 1], ldz, &work[1], n, &rwork[1], &iwork[1], info);
            if (*info > 0) {
                /*
                   如果 CLAED0 返回错误信息，则调整 info 并跳转到结束。
                */
                *info = (*info / (m + 1) + start - 1) * (*n + 1) + *info % (m + 1) + start - 1;
                goto L70;
            }

                /* L70: */
                goto L70;
            }

            /*
               继续处理下一个子问题的起始位置。
            */
            start = finish + 1;
            goto L30;
        }
    }

    /*
       如果循环结束，则说明所有子问题都已经处理完毕或者出现了不可处理的情况。
    */
L70:
    ;
}
/*              Scale back. */

/* 调用 LAPACK 函数 slascl 来对数组 d__ 中的子数组进行缩放 */
        slascl_("G", &c__0, &c__0, &c_b1034, &orgnrm, &m, &c__1, &d__[
            start], &m, info);

        } else {
/* 调用 LAPACK 函数 ssteqr 解决对称三对角矩阵的特征值问题 */
        ssteqr_("I", &m, &d__[start], &e[start], &rwork[1], &m, &
            rwork[m * m + 1], info);
/* 调用 LAPACK 函数 clacrm 将复数矩阵 z__ 的一部分转换成实数矩阵 */
        clacrm_(n, &m, &z__[start * z_dim1 + 1], ldz, &rwork[1], &m, &
            work[1], n, &rwork[m * m + 1]);
/* 调用 LAPACK 函数 clacpy 复制矩阵 */
        clacpy_("A", n, &m, &work[1], n, &z__[start * z_dim1 + 1],
            ldz);
/* 如果 info 大于 0，则设置其值为 start * (*n + 1) + finish，并跳转到标签 L70 */
        if (*info > 0) {
            *info = start * (*n + 1) + finish;
            goto L70;
        }
        }

/* 更新 start 的值 */
        start = finish + 1;
/* 跳转到标签 L30 */
        goto L30;
    }

/*
          endwhile

          If the problem split any number of times, then the eigenvalues
          will not be properly ordered.  Here we permute the eigenvalues
          (and the associated eigenvectors) into ascending order.
*/

/* 如果 m 不等于 *n，则使用选择排序算法对特征值进行排序 */
    if (m != *n) {

/*           Use Selection Sort to minimize swaps of eigenvectors */

/* 初始化循环 */
        i__1 = *n;
        for (ii = 2; ii <= i__1; ++ii) {
/* 设置索引 */
        i__ = ii - 1;
        k = i__;
/* 记录最小值 */
        p = d__[i__];
/* 内循环，寻找最小的特征值 */
        i__2 = *n;
        for (j = ii; j <= i__2; ++j) {
/* 如果找到更小的特征值，则更新相关变量 */
            if (d__[j] < p) {
            k = j;
            p = d__[j];
            }
/* L50: */
        }
/* 如果需要交换，则交换特征值和对应的特征向量 */
        if (k != i__) {
            d__[k] = d__[i__];
            d__[i__] = p;
            cswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1
                + 1], &c__1);
        }
/* L60: */
        }
    }
    }

/* 标签 L70：设置工作数组的第一个元素的实部为 lwmin，虚部为 0 */
L70:
    work[1].r = (real) lwmin, work[1].i = 0.f;
/* 设置实部为 lrwmin 的第一个元素 */
    rwork[1] = (real) lrwmin;
/* 设置第一个元素为 liwmin */
    iwork[1] = liwmin;

/* 返回 0，结束子程序 */
    return 0;

/*     End of CSTEDC */

} /* cstedc_ */

/* Subroutine */ int csteqr_(char *compz, integer *n, real *d__, real *e,
    singlecomplex *z__, integer *ldz, real *work, integer *info)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2;
    real r__1, r__2;

    /* Local variables */
    static real b, c__, f, g;
    static integer i__, j, k, l, m;
    static real p, r__, s;
    static integer l1, ii, mm, lm1, mm1, nm1;
    static real rt1, rt2, eps;
    static integer lsv;
    static real tst, eps2;
    static integer lend, jtot;
    extern /* Subroutine */ int slae2_(real *, real *, real *, real *, real *)
        ;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int clasr_(char *, char *, char *, integer *,
        integer *, real *, real *, singlecomplex *, integer *);
    static real anorm;
    extern /* Subroutine */ int cswap_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);
    static integer lendm1, lendp1;
    extern /* Subroutine */ int slaev2_(real *, real *, real *, real *, real *
        , real *, real *);
    extern doublereal slapy2_(real *, real *);
    static integer iscale;
    extern doublereal slamch_(char *);
    extern /* Subroutine */ int claset_(char *, integer *, integer *, singlecomplex
        *, singlecomplex *, singlecomplex *, integer *);
    static real safmin;


这段代码是一个 Fortran 子程序 `cstedc_` 的实现，用于计算对称矩阵的特征值和特征向量。注释详细解释了每个代码块的功能和调用的 LAPACK 子程序，以及一些变量和参数的作用。
    # 外部函数声明，用于处理错误情况
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 静态变量声明，用于存储最大安全值
    static real safmax;

    # 外部函数声明，用于矩阵缩放
    extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *,
        real *, integer *, integer *, real *, integer *, integer *);

    # 静态变量声明，用于存储结束位置
    static integer lendsv;

    # 外部函数声明，用于生成 Givens 变换
    extern /* Subroutine */ int slartg_(real *, real *, real *, real *, real *);

    # 静态变量声明，用于存储最小安全值
    static real ssfmin;

    # 静态变量声明，用于存储最大迭代次数
    static integer nmaxit, icompz;

    # 静态变量声明，用于存储最大单精度浮点数的绝对值
    static real ssfmax;

    # 外部函数声明，用于计算矩阵范数
    extern doublereal slanst_(char *, integer *, real *, real *);

    # 外部函数声明，用于排序实数数组
    extern /* Subroutine */ int slasrt_(char *, integer *, real *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the implicit QL or QR method.
    The eigenvectors of a full or band complex Hermitian matrix can also
    be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
    matrix to tridiagonal form.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    Hermitian matrix.  On entry, Z must contain the
                    unitary matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) REAL array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) REAL array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    Z       (input/output) COMPLEX array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).

    WORK    (workspace) REAL array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is unitarily similar to the original
                  matrix.

    =====================================================================


       Test the input parameters.
*/

/* Parameter adjustments */
--d__;


注释：
- `--d__;`: 这行代码是一个参数调整的注释标记。在Fortran中，函数参数通常是以数组的形式传递的，`--d__`表示对数组`d__`进行参数调整的开始。
    --e;  // 将指针 e 减小 1，移动到前一个位置
    z_dim1 = *ldz;  // 获取 ldz 指向的值，赋给 z_dim1
    z_offset = 1 + z_dim1;  // 计算 z 数组的偏移量
    z__ -= z_offset;  // 调整 z__ 指针，使其指向正确的起始位置
    --work;  // 将指针 work 减小 1，移动到前一个位置

    /* Function Body */
    *info = 0;  // 初始化 info 指向的值为 0

    // 根据 compz 的值确定 icompz 的值
    if (lsame_(compz, "N")) {
        icompz = 0;
    } else if (lsame_(compz, "V")) {
        icompz = 1;
    } else if (lsame_(compz, "I")) {
        icompz = 2;
    } else {
        icompz = -1;
    }

    // 根据 icompz 的值检查输入参数的有效性，设置 *info 的值
    if (icompz < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {
        *info = -6;
    }

    // 如果 *info 不为 0，则调用 xerbla_ 报告错误，并返回 0
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CSTEQR", &i__1);
        return 0;
    }
/*     Quick return if possible */
/* 如果 n 等于 0，直接返回 */
    if (*n == 0) {
    return 0;
    }

/* 如果 n 等于 1 */
    if (*n == 1) {
/* 如果 icompz 等于 2 */
    if (icompz == 2) {
/* 设置 z__ 中第一个元素为 (1.0, 0.0) */
        i__1 = z_dim1 + 1;
        z__[i__1].r = 1.f, z__[i__1].i = 0.f;
    }
/* 直接返回 */
    return 0;
    }

/*     Determine the unit roundoff and over/underflow thresholds. */
/* 确定单位舍入误差和溢出/下溢阈值 */

/* 获取机器精度 */
    eps = slamch_("E");
/* 计算 eps 的平方 */
/* Computing 2nd power */
    r__1 = eps;
    eps2 = r__1 * r__1;
/* 获取安全最小值 */
    safmin = slamch_("S");
/* 计算安全最大值的倒数 */
    safmax = 1.f / safmin;
/* 计算 sqrt(safmax) 的三分之一 */
    ssfmax = sqrt(safmax) / 3.f;
/* 计算 sqrt(safmin) 的 eps2 倍的倒数 */
    ssfmin = sqrt(safmin) / eps2;

/*
       Compute the eigenvalues and eigenvectors of the tridiagonal
       matrix.
*/

/* 如果 icompz 等于 2 */
    if (icompz == 2) {
/* 将 z__ 矩阵设为全零 */
    claset_("Full", n, n, &c_b56, &c_b57, &z__[z_offset], ldz);
    }

/* 设置最大迭代次数 */
    nmaxit = *n * 30;
/* 初始化 jtot */
    jtot = 0;

/*
       Determine where the matrix splits and choose QL or QR iteration
       for each block, according to whether top or bottom diagonal
       element is smaller.
*/

/* 初始化 l1 和 nm1 */
    l1 = 1;
    nm1 = *n - 1;

L10:
/* 如果 l1 大于 n，则跳到 L160 */
    if (l1 > *n) {
    goto L160;
    }
/* 如果 l1 大于 1，将 e[l1-1] 设为 0 */
    if (l1 > 1) {
    e[l1 - 1] = 0.f;
    }
/* 如果 l1 小于等于 nm1 */
    if (l1 <= nm1) {
/* 循环计算 tst */
    i__1 = nm1;
    for (m = l1; m <= i__1; ++m) {
/* 计算 tst */
        tst = (r__1 = e[m], dabs(r__1));
/* 如果 tst 等于 0，跳到 L30 */
        if (tst == 0.f) {
        goto L30;
        }
/* 如果 tst 小于等于 sqrt(|d__[m]| * |d__[m+1]|) * eps */
        if (tst <= sqrt((r__1 = d__[m], dabs(r__1))) * sqrt((r__2 = d__[m
            + 1], dabs(r__2))) * eps) {
/* 将 e[m] 设为 0，跳到 L30 */
        e[m] = 0.f;
        goto L30;
        }
/* L20: */
    }
    }
/* 设定 m 为 n */
    m = *n;

L30:
/* 设置 l、lsv、lend 和 lendsv */
    l = l1;
    lsv = l;
    lend = m;
    lendsv = lend;
/* 将 l1 设为 m+1 */
    l1 = m + 1;
/* 如果 lend 等于 l，跳到 L10 */
    if (lend == l) {
    goto L10;
    }

/*     Scale submatrix in rows and columns L to LEND */
/* 缩放子矩阵的行和列 L 到 LEND */

/* 计算矩阵的无穷范数 */
    i__1 = lend - l + 1;
    anorm = slanst_("I", &i__1, &d__[l], &e[l]);
/* 初始化 iscale */
    iscale = 0;
/* 如果 anorm 等于 0，跳到 L10 */
    if (anorm == 0.f) {
    goto L10;
    }
/* 如果 anorm 大于 ssfmax */
    if (anorm > ssfmax) {
    iscale = 1;
/* 缩放 d__[l] 和 e[l] */
    i__1 = lend - l + 1;
    slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n,
        info);
    i__1 = lend - l;
    slascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n,
        info);
    } else if (anorm < ssfmin) {
    iscale = 2;
/* 缩放 d__[l] 和 e[l] */
    i__1 = lend - l + 1;
    slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n,
        info);
    i__1 = lend - l;
    slascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n,
        info);
    }

/*     Choose between QL and QR iteration */

/* 如果 |d__[lend]| 小于 |d__[l]| */
    if ((r__1 = d__[lend], dabs(r__1)) < (r__2 = d__[l], dabs(r__2))) {
/* 交换 lend 和 l */
    lend = lsv;
    l = lendsv;
    }

/* 如果 lend 大于 l */
    if (lend > l) {

/*
          QL Iteration

          Look for small subdiagonal element.
*/

L40:
/* 如果 l 不等于 lend */
    if (l != lend) {
    lendm1 = lend - 1;
/* 循环寻找小的次对角线元素 */
    i__1 = lendm1;
    for (m = l; m <= i__1; ++m) {
/* 计算 tst */
/* Computing 2nd power */
        r__2 = (r__1 = e[m], dabs(r__1));
        tst = r__2 * r__2;
/* 如果 tst 小于等于 eps2 * |d__[m]| * |d__[m+1]| + safmin */
        if (tst <= eps2 * (r__1 = d__[m], dabs(r__1)) * (r__2 = d__[m
            + 1], dabs(r__2)) + safmin) {
/* 跳到 L60 */
            goto L60;
        }
/* L50: */
    }
    }

/* 设定 m 为 lend */
    m = lend;

L60:
/* 如果 m 小于 lend，将 e[m] 设为 0 */
    if (m < lend) {
    e[m] = 0.f;
    }
/* 将 p 设为 d__[l] */
    p = d__[l];
/* 如果 m 等于 l，跳到 L80 */
    if (m == l) {
    goto L80;
    }
/*
          如果剩余的矩阵是 2x2 的，则使用 SLAE2 或 SLAEV2 计算其特征系统。
*/

    if (m == l + 1) {
        if (icompz > 0) {
            // 调用 SLAEV2 计算特征值和特征向量旋转参数
            slaev2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2, &c__, &s);
            // 保存特征向量旋转参数到工作数组
            work[l] = c__;
            work[*n - 1 + l] = s;
            // 应用旋转到 Z 矩阵的相关列
            clasr_("R", "V", "B", n, &c__2, &work[l], &work[*n - 1 + l], &
                z__[l * z_dim1 + 1], ldz);
        } else {
            // 调用 SLAE2 计算特征值
            slae2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2);
        }
        // 更新对角元素和下三角元素
        d__[l] = rt1;
        d__[l + 1] = rt2;
        e[l] = 0.f;
        l += 2;
        // 继续处理下一对特征值
        if (l <= lend) {
            goto L40;
        }
        goto L140;
    }

    // 达到最大迭代次数
    if (jtot == nmaxit) {
        goto L140;
    }
    ++jtot;

/*        形成位移量。*/

    // 计算位移量 g
    g = (d__[l + 1] - p) / (e[l] * 2.f);
    // 计算 r = sqrt(g^2 + 1)
    r__ = slapy2_(&g, &c_b1034);
    // 计算位移量修正后的 g
    g = d__[m] - p + e[l] / (g + r_sign(&r__, &g));

    s = 1.f;
    c__ = 1.f;
    p = 0.f;

/*        内循环*/

    // 设置循环边界
    mm1 = m - 1;
    i__1 = l;
    for (i__ = mm1; i__ >= i__1; --i__) {
        // 计算 f 和 b
        f = s * e[i__];
        b = c__ * e[i__];
        // 计算旋转参数 c 和 s
        slartg_(&g, &f, &c__, &s, &r__);
        if (i__ != m - 1) {
            e[i__ + 1] = r__;
        }
        // 更新 d 和 g
        g = d__[i__ + 1] - p;
        r__ = (d__[i__] - g) * s + c__ * 2.f * b;
        p = s * r__;
        d__[i__ + 1] = g + p;
        g = c__ * r__ - b;

/*           如果需要特征向量，则保存旋转参数。*/

        if (icompz > 0) {
            work[i__] = c__;
            work[*n - 1 + i__] = -s;
        }

/* L70: */
    }

/*        如果需要特征向量，则应用保存的旋转参数。*/

    if (icompz > 0) {
        mm = m - l + 1;
        clasr_("R", "V", "B", n, &mm, &work[l], &work[*n - 1 + l], &z__[l
            * z_dim1 + 1], ldz);
    }

    // 更新对角元素和下三角元素
    d__[l] -= p;
    e[l] = g;
    goto L40;

/*        找到特征值。*/

L80:
    d__[l] = p;

    ++l;
    if (l <= lend) {
        goto L40;
    }
    goto L140;

    } else {

/*
          QR 迭代

          查找较小的超对角元素。
*/

L90:
    if (l != lend) {
        lendp1 = lend + 1;
        i__1 = lendp1;
        for (m = l; m >= i__1; --m) {
/* Computing 2nd power */
        r__2 = (r__1 = e[m - 1], dabs(r__1));
        tst = r__2 * r__2;
        // 检查超对角元素是否足够小
        if (tst <= eps2 * (r__1 = d__[m], dabs(r__1)) * (r__2 = d__[m
            - 1], dabs(r__2)) + safmin) {
            goto L110;
        }
/* L100: */
        }
    }

    m = lend;

L110:
    if (m > lend) {
        e[m - 1] = 0.f;
    }
    p = d__[l];
    if (m == l) {
        goto L130;
    }

/*
          如果剩余的矩阵是 2x2 的，则使用 SLAE2 或 SLAEV2 计算其特征系统。
*/
    # 如果 m 等于 l - 1
    if (m == l - 1) {
        # 如果 icompz 大于 0
        if (icompz > 0) {
            # 调用 slaev2_ 函数，计算特征值问题的两个特征值
            slaev2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2, &c__, &s);
            # 将计算得到的 c 和 s 存储到 work 数组中
            work[m] = c__;
            work[*n - 1 + m] = s;
            # 对矩阵 z 进行一种类型的行变换，用 c 和 s 控制
            clasr_("R", "V", "F", n, &c__2, &work[m], &work[*n - 1 + m], &
                z__[(l - 1) * z_dim1 + 1], ldz);
        } else {
            # 如果 icompz 不大于 0，调用 slae2_ 函数计算特征值问题的两个特征值
            slae2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2);
        }
        # 更新数组 d 和 e 中的值
        d__[l - 1] = rt1;
        d__[l] = rt2;
        e[l - 1] = 0.f;
        # l 减去 2
        l += -2;
        # 如果 l 仍然大于或等于 lend，则跳转到标签 L90
        if (l >= lend) {
            goto L90;
        }
        # 跳转到标签 L140
        goto L140;
    }

    # 如果 jtot 等于 nmaxit，则跳转到标签 L140
    if (jtot == nmaxit) {
        goto L140;
    }
    # jtot 加 1
    ++jtot;
/*
   Form shift.
*/

g = (d__[l - 1] - p) / (e[l - 1] * 2.f);
r__ = slapy2_(&g, &c_b1034);
g = d__[m] - p + e[l - 1] / (g + r_sign(&r__, &g));

s = 1.f;
c__ = 1.f;
p = 0.f;

/*
   Inner loop
*/

lm1 = l - 1;
i__1 = lm1;
for (i__ = m; i__ <= i__1; ++i__) {
    f = s * e[i__];
    b = c__ * e[i__];
    slartg_(&g, &f, &c__, &s, &r__);
    if (i__ != m) {
        e[i__ - 1] = r__;
    }
    g = d__[i__] - p;
    r__ = (d__[i__ + 1] - g) * s + c__ * 2.f * b;
    p = s * r__;
    d__[i__] = g + p;
    g = c__ * r__ - b;

    /*
       If eigenvectors are desired, then save rotations.
    */

    if (icompz > 0) {
        work[i__] = c__;
        work[*n - 1 + i__] = s;
    }

    /* L120: */
}

/*
   If eigenvectors are desired, then apply saved rotations.
*/

if (icompz > 0) {
    mm = l - m + 1;
    clasr_("R", "V", "F", n, &mm, &work[m], &work[*n - 1 + m], &z__[m
        * z_dim1 + 1], ldz);
}

d__[l] -= p;
e[lm1] = g;
goto L90;

/*
   Eigenvalue found.
*/

L130:
d__[l] = p;

--l;
if (l >= lend) {
    goto L90;
}
goto L140;

}

/*
   Undo scaling if necessary
*/

L140:
if (iscale == 1) {
    i__1 = lendsv - lsv + 1;
    slascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv],
        n, info);
    i__1 = lendsv - lsv;
    slascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &e[lsv], n,
        info);
} else if (iscale == 2) {
    i__1 = lendsv - lsv + 1;
    slascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv],
        n, info);
    i__1 = lendsv - lsv;
    slascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &e[lsv], n,
        info);
}

/*
   Check for no convergence to an eigenvalue after a total
   of N*MAXIT iterations.
*/

if (jtot == nmaxit) {
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (e[i__] != 0.f) {
            ++(*info);
        }
        /* L150: */
    }
    return 0;
}
goto L10;

/*
   Order eigenvalues and eigenvectors.
*/

L160:
if (icompz == 0) {

    /*
       Use Quick Sort
    */

    slasrt_("I", n, &d__[1], info);

} else {

    /*
       Use Selection Sort to minimize swaps of eigenvectors
    */

    i__1 = *n;
    for (ii = 2; ii <= i__1; ++ii) {
        i__ = ii - 1;
        k = i__;
        p = d__[i__];
        i__2 = *n;
        for (j = ii; j <= i__2; ++j) {
            if (d__[j] < p) {
                k = j;
                p = d__[j];
            }
            /* L170: */
        }
        if (k != i__) {
            d__[k] = d__[i__];
            d__[i__] = p;
            cswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1 + 1],
                 &c__1);
        }
        /* L180: */
    }
}
return 0;

/* End of CSTEQR */
} /* csteqr_ */

/* Subroutine */ int ctrevc_(char *side, char *howmny, logical *select,
    integer *n, singlecomplex *t, integer *ldt, singlecomplex *vl, integer *ldvl,
    singlecomplex *vr, integer *ldvr, integer *mm, integer *m, singlecomplex *work,
    real *rwork, integer *info)


    # 声明复数类型指针 vr，用于存储右特征向量
    singlecomplex *vr,
    # 整型指针 ldvr，指向存储右特征向量的数组的第一个维度大小
    integer *ldvr,
    # 整型指针 mm，指向存储右特征向量的数组的第二个维度大小
    integer *mm,
    # 整型指针 m，指向存储右特征向量的数组的第一维大小
    integer *m,
    # 声明复数类型指针 work，用于存储工作区域
    singlecomplex *work,
    # 声明实型指针 rwork，用于存储实数工作区域
    real *rwork,
    # 整型指针 info，用于存储返回的状态信息
    integer *info
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
        i__2, i__3, i__4, i__5;
    real r__1, r__2, r__3;
    singlecomplex q__1, q__2;

    /* Local variables */
    static integer i__, j, k, ii, ki, is;  // 声明整型局部变量
    static real ulp;  // 机器精度
    static logical allv;  // 逻辑变量，指示是否计算所有的特征向量
    static real unfl, ovfl, smin;  // 浮点数变量，存储极小值、溢出阈值和最小奇异值
    static logical over;  // 逻辑变量，指示是否出现溢出
    static real scale;  // 浮点数变量，用于估计矩阵的规模
    extern logical lsame_(char *, char *);  // 外部函数声明，用于比较两个字符是否相同
    extern /* Subroutine */ int cgemv_(char *, integer *, integer *, singlecomplex *
        , singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *);  // 外部子程序声明，进行复杂矩阵向量乘法
    static real remax;  // 最大残差
    extern /* Subroutine */ int ccopy_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);  // 外部子程序声明，复制复数向量
    static logical leftv, bothv, somev;  // 逻辑变量，指示是否计算左特征向量、同时计算左右特征向量、计算部分特征向量
    extern /* Subroutine */ int slabad_(real *, real *);  // 外部子程序声明，初始化机器精度相关参数
    extern integer icamax_(integer *, singlecomplex *, integer *);  // 外部函数声明，计算复数向量的绝对值最大元素的索引
    extern doublereal slamch_(char *);  // 外部函数声明，返回机器相关参数的值
    extern /* Subroutine */ int csscal_(integer *, real *, singlecomplex *, integer
        *), xerbla_(char *, integer *), clatrs_(char *, char *,
        char *, char *, integer *, singlecomplex *, integer *, singlecomplex *, real *
        , real *, integer *);  // 外部子程序声明，缩放复数向量、错误处理、计算矩阵乘法
    extern doublereal scasum_(integer *, singlecomplex *, integer *);  // 外部函数声明，计算复数向量的绝对值之和
    static logical rightv;  // 逻辑变量，指示是否计算右特征向量
    static real smlnum;  // 极小值

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CTREVC computes some or all of the right and/or left eigenvectors of
    a complex upper triangular matrix T.
    Matrices of this type are produced by the Schur factorization of
    a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.

    The right eigenvector x and the left eigenvector y of T corresponding
    to an eigenvalue w are defined by:

                 T*x = w*x,     (y**H)*T = w*(y**H)

    where y**H denotes the conjugate transpose of the vector y.
    The eigenvalues are not input to this routine, but are read directly
    from the diagonal of T.

    This routine returns the matrices X and/or Y of right and left
    eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
    input matrix.  If Q is the unitary factor that reduces a matrix A to
    Schur form T, then Q*X and Q*Y are the matrices of right and left
    eigenvectors of A.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
    # 输入参数，指示计算哪些特征向量
    HOWMNY  (input) CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed using the matrices supplied in
                    VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.

    # 输入参数，逻辑数组，用于选择计算哪些特征向量
    SELECT  (input) LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            The eigenvector corresponding to the j-th eigenvalue is
            computed if SELECT(j) = .TRUE..
            Not referenced if HOWMNY = 'A' or 'B'.

    # 输入参数，矩阵 T 的阶数，必须大于等于 0
    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    # 输入/输出参数，上三角矩阵 T，函数会修改但退出时会恢复
    T       (input/output) COMPLEX array, dimension (LDT,N)
            The upper triangular matrix T.  T is modified, but restored
            on exit.

    # 输入参数，数组 T 的主维度
    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    # 输入/输出参数，左特征向量矩阵 VL
    VL      (input/output) COMPLEX array, dimension (LDVL,MM)
            On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by CHSEQR).
            On exit, if SIDE = 'L' or 'B', VL contains:
            if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*Y;
            if HOWMNY = 'S', the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'R'.

    # 输入参数，数组 VL 的主维度，至少为 1，若 SIDE = 'L' or 'B'，需至少为 N
    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1, and if
            SIDE = 'L' or 'B', LDVL >= N.

    # 输入/输出参数，右特征向量矩阵 VR
    VR      (input/output) COMPLEX array, dimension (LDVR,MM)
            On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by CHSEQR).
            On exit, if SIDE = 'R' or 'B', VR contains:
            if HOWMNY = 'A', the matrix X of right eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*X;
            if HOWMNY = 'S', the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'L'.

    # 输入参数，数组 VR 的主维度，至少为 1，若 SIDE = 'R' or 'B'，需至少为 N
    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR >= 1, and if
            SIDE = 'R' or 'B'; LDVR >= N.

    # 输入参数，数组 VL 和/或 VR 的列数，至少为 M
    MM      (input) INTEGER
            The number of columns in the arrays VL and/or VR. MM >= M.
    M       (output) INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
            is set to N.  Each selected eigenvector occupies one
            column.


# 输出参数，表示用于存储特征向量的数组 VL 和/或 VR 实际使用的列数。
# 如果 HOWMNY = 'A' 或 'B'，则 M 被设为 N。每个选定的特征向量占据一列。



    WORK    (workspace) COMPLEX array, dimension (2*N)


# 工作空间，用于存储复数类型数组，大小为 (2*N)。



    RWORK   (workspace) REAL array, dimension (N)


# 工作空间，用于存储实数类型数组，大小为 N。



    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value


# 输出参数，表示函数执行的结果：
# - 等于 0 表示成功退出
# - 小于 0，如果 INFO = -i，则表示第 i 个参数具有非法值。



    Further Details
    ===============

    The algorithm used in this program is basically backward (forward)
    substitution, with scaling to make the code robust against
    possible overflow.

    Each eigenvector is normalized so that the element of largest
    magnitude has magnitude 1; here the magnitude of a complex number
    (x,y) is taken to be |x| + |y|.


# 进一步细节
# ===============
# 本程序使用的算法基本上是向后（向前）替换，使用缩放使代码对可能的溢出具有鲁棒性。
# 每个特征向量被标准化，使得具有最大幅值的元素的幅度为1；这里复数（x，y）的幅度被定义为 |x| + |y|。



    =====================================================================


# 分隔线，标记进一步细节部分的结束。



       Decode and test the input parameters


# 解码和测试输入参数。
    /* Parameter adjustments */
    --select;                // Adjust select array pointer to first element
    t_dim1 = *ldt;           // Get dimension of T matrix
    t_offset = 1 + t_dim1;   // Offset for accessing T(1,1)
    t -= t_offset;           // Adjust T matrix pointer
    vl_dim1 = *ldvl;         // Get dimension of VL matrix
    vl_offset = 1 + vl_dim1; // Offset for accessing VL(1,1)
    vl -= vl_offset;         // Adjust VL matrix pointer
    vr_dim1 = *ldvr;         // Get dimension of VR matrix
    vr_offset = 1 + vr_dim1; // Offset for accessing VR(1,1)
    vr -= vr_offset;         // Adjust VR matrix pointer
    --work;                  // Adjust work array pointer
    --rwork;                 // Adjust rwork array pointer

    /* Function Body */
    bothv = lsame_(side, "B");   // Check if side parameter is "B"
    rightv = lsame_(side, "R") || bothv;  // Check if side parameter is "R" or "B"
    leftv = lsame_(side, "L") || bothv;   // Check if side parameter is "L" or "B"

    allv = lsame_(howmny, "A");   // Check if howmny parameter is "A"
    over = lsame_(howmny, "B");   // Check if howmny parameter is "B"
    somev = lsame_(howmny, "S");  // Check if howmny parameter is "S"

/*
       Set M to the number of columns required to store the selected
       eigenvectors.
*/
    if (somev) {               // If somev is true
        *m = 0;                // Initialize m to 0
        i__1 = *n;             // Loop over n elements
        for (j = 1; j <= i__1; ++j) {  // Iterate over each element
            if (select[j]) {    // If select[j] is true
                ++(*m);         // Increment m
            }
/* L10: */                    // Label L10 for loop end
        }
    } else {                   // Otherwise
        *m = *n;               // Set m equal to n
    }

    *info = 0;                 // Initialize info to 0
    if (! rightv && ! leftv) { // If neither rightv nor leftv is true
        *info = -1;            // Set info to -1
    } else if (! allv && ! over && ! somev) {  // If none of allv, over, or somev is true
        *info = -2;            // Set info to -2
    } else if (*n < 0) {       // If n is less than 0
        *info = -4;            // Set info to -4
    } else if (*ldt < max(1,*n)) {  // If ldt is less than max(1, n)
        *info = -6;            // Set info to -6
    } else if (*ldvl < 1 || leftv && *ldvl < *n) {  // If ldvl is less than 1 or leftv and ldvl < n
        *info = -8;            // Set info to -8
    } else if (*ldvr < 1 || rightv && *ldvr < *n) {  // If ldvr is less than 1 or rightv and ldvr < n
        *info = -10;           // Set info to -10
    } else if (*mm < *m) {     // If mm is less than m
        *info = -11;           // Set info to -11
    }
    if (*info != 0) {          // If info is not equal to 0
        i__1 = -(*info);       // Compute negative of info
        xerbla_("CTREVC", &i__1);  // Call error handler xerbla
        return 0;              // Return 0
    }

/*     Quick return if possible. */
    if (*n == 0) {             // If n is equal to 0
        return 0;              // Return 0
    }

/*     Set the constants to control overflow. */
    unfl = slamch_("Safe minimum");   // Get safe minimum value
    ovfl = 1.f / unfl;                // Calculate overflow value
    slabad_(&unfl, &ovfl);            // Adjust unfl and ovfl
    ulp = slamch_("Precision");       // Get precision value
    smlnum = unfl * (*n / ulp);       // Calculate small number threshold

/*     Store the diagonal elements of T in working array WORK. */
    i__1 = *n;                        // Loop over n elements
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = i__ + *n;              // Calculate index
        i__3 = i__ + i__ * t_dim1;    // Calculate index
        work[i__2].r = t[i__3].r, work[i__2].i = t[i__3].i;  // Store diagonal elements in work array
/* L20: */                            // Label L20 for loop end
    }

/*
       Compute 1-norm of each column of strictly upper triangular
       part of T to control overflow in triangular solver.
*/
    rwork[1] = 0.f;                   // Initialize first element of rwork to 0
    i__1 = *n;                        // Loop over n elements
    for (j = 2; j <= i__1; ++j) {
        i__2 = j - 1;                 // Calculate index
        rwork[j] = scasum_(&i__2, &t[j * t_dim1 + 1], &c__1);  // Compute 1-norm of each column
/* L30: */                            // Label L30 for loop end
    }

    if (rightv) {                     // If rightv is true

/*        Compute right eigenvectors. */

        is = *m;                     // Set is to m
        for (ki = *n; ki >= 1; --ki) {  // Reverse loop over n elements

            if (somev) {             // If somev is true
                if (! select[ki]) {  // If select[ki] is false
                    goto L80;        // Jump to label L80
                }
            }
/* Computing MAX */                  // Compute maximum value
            i__1 = ki + ki * t_dim1;  // Calculate index
            r__3 = ulp * ((r__1 = t[i__1].r, dabs(r__1)) + (r__2 = r_imag(&t[
                ki + ki * t_dim1]), dabs(r__2)));  // Compute ulp scaled value
            smin = dmax(r__3,smlnum);  // Compute maximum of r__3 and smlnum

            work[1].r = 1.f, work[1].i = 0.f;  // Initialize work array for right-hand side

/*           Form right-hand side. */

            i__1 = ki - 1;           // Loop over ki-1 elements
            for (k = 1; k <= i__1; ++k) {
                i__2 = k;           // Calculate index
                i__3 = k + ki * t_dim1;  // Calculate index
                q__1.r = -t[i__3].r, q__1.i = -t[i__3].i;  // Negate and store in work array
                work[i__2].r = q__1.r, work[i__2].i = q__1.i;
/* L40: */                              // Label L40 for loop end
            }

/*
             Solve the triangular system:
                (T(1:KI-1,1:KI-1) - T(KI,KI))*X = SCALE*WORK.
*/
        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
            // 计算下标 i__2 对应的元素，将其值减去下标 i__4 对应的元素
            i__2 = k + k * t_dim1;
            i__3 = k + k * t_dim1;
            i__4 = ki + ki * t_dim1;
            q__1.r = t[i__3].r - t[i__4].r, q__1.i = t[i__3].i - t[i__4].i;
            // 将计算结果赋值给下标 i__2 对应的元素
            t[i__2].r = q__1.r, t[i__2].i = q__1.i;
            // 检查对角线元素的绝对值之和是否小于 smin，若是则设置其为 smin
            i__2 = k + k * t_dim1;
            if ((r__1 = t[i__2].r, dabs(r__1)) + (r__2 = r_imag(&t[k + k * t_dim1]), dabs(r__2)) < smin) {
                i__3 = k + k * t_dim1;
                t[i__3].r = smin, t[i__3].i = 0.f;
            }
            // 继续下一个 k 值的循环
            // L50 标记
        }

        // 如果 ki > 1，则进行以下操作
        if (ki > 1) {
            // 调用 clatrs 函数，对上三角阵 t 进行操作
            i__1 = ki - 1;
            clatrs_("Upper", "No transpose", "Non-unit", "Y", &i__1, &t[t_offset], ldt, &work[1], &scale, &rwork[1], info);
            // 设置 work 数组中下标为 ki 的元素为 scale
            i__1 = ki;
            work[i__1].r = scale, work[i__1].i = 0.f;
        }

/*           Copy the vector x or Q*x to VR and normalize. */

        // 如果 over 不为真，则执行以下操作
        if (! over) {
            // 复制 work 数组中的 ki 个元素到 vr 数组中的第 is 列，并保持步长为 1
            ccopy_(&ki, &work[1], &c__1, &vr[is * vr_dim1 + 1], &c__1);

            // 找出 vr 数组中第 is 列的最大模值元素的下标
            ii = icamax_(&ki, &vr[is * vr_dim1 + 1], &c__1);
            // 计算归一化因子 remax
            i__1 = ii + is * vr_dim1;
            remax = 1.f / ((r__1 = vr[i__1].r, dabs(r__1)) + (r__2 = r_imag(&vr[ii + is * vr_dim1]), dabs(r__2)));
            // 对 vr 数组中第 is 列的元素进行缩放，以使其模为 1
            csscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);

            // 将 vr 数组中从 ki+1 到 n 的元素置为 0
            i__1 = *n;
            for (k = ki + 1; k <= i__1; ++k) {
                i__2 = k + is * vr_dim1;
                vr[i__2].r = 0.f, vr[i__2].i = 0.f;
                // L60 标记
            }
        } else {
            // 如果 ki > 1，则执行以下操作
            if (ki > 1) {
                // 计算 Q^H * work，并加到 vr 的第 ki 列上
                i__1 = ki - 1;
                q__1.r = scale, q__1.i = 0.f;
                cgemv_("N", n, &i__1, &c_b57, &vr[vr_offset], ldvr, &work[1], &c__1, &q__1, &vr[ki * vr_dim1 + 1], &c__1);
            }

            // 找出 vr 数组中第 ki 列的最大模值元素的下标
            ii = icamax_(n, &vr[ki * vr_dim1 + 1], &c__1);
            // 计算归一化因子 remax
            i__1 = ii + ki * vr_dim1;
            remax = 1.f / ((r__1 = vr[i__1].r, dabs(r__1)) + (r__2 = r_imag(&vr[ii + ki * vr_dim1]), dabs(r__2)));
            // 对 vr 数组中第 ki 列的元素进行缩放，以使其模为 1
            csscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
        }

/*           Set back the original diagonal elements of T. */

        // 将工作数组中的元素复制回 t 的对角线元素
        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
            i__2 = k + k * t_dim1;
            i__3 = k + *n;
            t[i__2].r = work[i__3].r, t[i__2].i = work[i__3].i;
            // L70 标记
        }

        // is 减少 1
        --is;
L80:
        ;
    }

    // 如果 leftv 为真，则执行以下操作
    if (leftv) {

/*        Compute left eigenvectors. */

        // 设置 is 为 1
        is = 1;
        // 对每个 ki 进行操作
        i__1 = *n;
        for (ki = 1; ki <= i__1; ++ki) {

            // 如果 somev 为真，并且 select[ki] 为假，则跳转到标记 L130
            if (somev) {
                if (! select[ki]) {
                    goto L130;
                }
            }
            // 计算用于判断下限的 smin 值
            i__2 = ki + ki * t_dim1;
            r__3 = ulp * ((r__1 = t[i__2].r, dabs(r__1)) + (r__2 = r_imag(&t[ki + ki * t_dim1]), dabs(r__2)));
            smin = dmax(r__3,smlnum);

            // 设置 work 数组中的最后一个元素为 1
            i__2 = *n;
            work[i__2].r = 1.f, work[i__2].i = 0.f;

/*           Form right-hand side. */

            // 计算右侧向量的内容
            i__2 = *n;
            for (k = ki + 1; k <= i__2; ++k) {
                i__3 = k;
                r_cnjg(&q__2, &t[ki + k * t_dim1]);
                q__1.r = -q__2.r, q__1.i = -q__2.i;
                work[i__3].r = q__1.r, work[i__3].i = q__1.i;
                // 继续下一个 k 值的循环
            }
/*
   Solve the triangular system:
      (T(KI+1:N,KI+1:N) - T(KI,KI))'*X = SCALE*WORK.
*/

/* 循环处理从 KI+1 到 N 的每一列 */
i__2 = *n;
for (k = ki + 1; k <= i__2; ++k) {
    /* 计算 T(K,K) - T(KI,KI) 并将结果存入 T(K,K) */
    i__3 = k + k * t_dim1;
    i__4 = k + k * t_dim1;
    i__5 = ki + ki * t_dim1;
    q__1.r = t[i__4].r - t[i__5].r, q__1.i = t[i__4].i - t[i__5].i;
    t[i__3].r = q__1.r, t[i__3].i = q__1.i;

    /* 如果新的 T(K,K) 小于预设的最小值 smin，则将其设置为 smin */
    i__3 = k + k * t_dim1;
    if ((r__1 = t[i__3].r, dabs(r__1)) + (r__2 = r_imag(&t[k + k * t_dim1]), dabs(r__2)) < smin) {
        i__4 = k + k * t_dim1;
        t[i__4].r = smin, t[i__4].i = 0.f;
    }
}

/* 如果 KI 小于 N，则进行一次矩阵运算 */
if (ki < *n) {
    /* 调用 clatrs_ 函数解上三角线性方程组 */
    i__2 = *n - ki;
    clatrs_("Upper", "Conjugate transpose", "Non-unit", "Y", &
        i__2, &t[ki + 1 + (ki + 1) * t_dim1], ldt, &work[ki +
        1], &scale, &rwork[1], info);
    
    /* 将结果保存到 work 数组中 */
    i__2 = ki;
    work[i__2].r = scale, work[i__2].i = 0.f;
}

/* 复制向量 x 或 Q*x 到 VL 并进行归一化处理 */
if (! over) {
    /* 复制 work 数组的部分数据到 VL 中 */
    i__2 = *n - ki + 1;
    ccopy_(&i__2, &work[ki], &c__1, &vl[ki + is * vl_dim1], &c__1);

    /* 找出复制后的部分中模最大的元素的索引 */
    i__2 = *n - ki + 1;
    ii = icamax_(&i__2, &vl[ki + is * vl_dim1], &c__1) + ki - 1;

    /* 计算归一化因子 */
    i__2 = ii + is * vl_dim1;
    remax = 1.f / ((r__1 = vl[i__2].r, dabs(r__1)) + (r__2 =
        r_imag(&vl[ii + is * vl_dim1]), dabs(r__2)));

    /* 对 VL 进行归一化 */
    i__2 = *n - ki + 1;
    csscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);

    /* 将 VL 中的部分数据清零 */
    i__2 = ki - 1;
    for (k = 1; k <= i__2; ++k) {
        i__3 = k + is * vl_dim1;
        vl[i__3].r = 0.f, vl[i__3].i = 0.f;
    }
} else {
    /* 如果 over 为真且 KI 小于 N，则进行矩阵乘法运算 */
    if (ki < *n) {
        i__2 = *n - ki;
        q__1.r = scale, q__1.i = 0.f;
        cgemv_("N", n, &i__2, &c_b57, &vl[(ki + 1) * vl_dim1 + 1],
             ldvl, &work[ki + 1], &c__1, &q__1, &vl[ki *
            vl_dim1 + 1], &c__1);
    }

    /* 找出 VL 中模最大的元素的索引 */
    ii = icamax_(n, &vl[ki * vl_dim1 + 1], &c__1);

    /* 计算归一化因子 */
    i__2 = ii + ki * vl_dim1;
    remax = 1.f / ((r__1 = vl[i__2].r, dabs(r__1)) + (r__2 =
        r_imag(&vl[ii + ki * vl_dim1]), dabs(r__2)));

    /* 对 VL 进行归一化 */
    csscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
}

/* 恢复 T 的对角线元素 */
i__2 = *n;
for (k = ki + 1; k <= i__2; ++k) {
    i__3 = k + k * t_dim1;
    i__4 = k + *n;
    t[i__3].r = work[i__4].r, t[i__3].i = work[i__4].i;
}
    # 声明静态变量 cs，类型为 real
    static real cs;
    # 声明静态变量 t11, t22, sn, temp，类型为 singlecomplex
    static singlecomplex t11, t22, sn, temp;
    # 声明外部函数 crot_ 的声明，该函数用于完成复杂数的 Givens 变换
    extern /* Subroutine */ int crot_(integer *, singlecomplex *, integer *,
        singlecomplex *, integer *, real *, singlecomplex *);
    # 声明外部函数 lsame_ 的声明，用于比较两个字符是否相同（不区分大小写）
    extern logical lsame_(char *, char *);
    # 声明静态变量 wantq，类型为逻辑型，表示是否需要计算 Q 矩阵
    static logical wantq;
    # 声明外部函数 clartg_ 的声明，用于计算两个复数的 Givens 旋转参数
    extern /* Subroutine */ int clartg_(singlecomplex *, singlecomplex *, real *, singlecomplex
        *, singlecomplex *);
    # 声明外部函数 xerbla_ 的声明，用于错误处理
    extern /* Subroutine */ int xerbla_(char *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CTREXC reorders the Schur factorization of a complex matrix
    A = Q*T*Q**H, so that the diagonal element of T with row index IFST
    is moved to row ILST.

    The Schur form T is reordered by a unitary similarity transformation
    Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
    postmultplying it with Z.

    Arguments
    =========

    COMPQ   (input) CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input/output) COMPLEX array, dimension (LDT,N)
            On entry, the upper triangular matrix T.
            On exit, the reordered upper triangular matrix.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    Q       (input/output) COMPLEX array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            unitary transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    IFST    (input) INTEGER
    ILST    (input) INTEGER
            Specify the reordering of the diagonal elements of T:
            The element with row index IFST is moved to row ILST by a
            sequence of transpositions between adjacent elements.
            1 <= IFST <= N; 1 <= ILST <= N.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Decode and test the input parameters.
*/
/* Parameter adjustments */
t_dim1 = *ldt;
t_offset = 1 + t_dim1;
t -= t_offset;
q_dim1 = *ldq;
q_offset = 1 + q_dim1;
q -= q_offset;

/* Function Body */
*info = 0;
wantq = lsame_(compq, "V");
if (! lsame_(compq, "N") && ! wantq) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*ldt < max(1,*n)) {
*info = -4;
} else if (*ldq < 1 || wantq && *ldq < max(1,*n)) {
*info = -6;
} else if (*ifst < 1 || *ifst > *n) {
*info = -7;
} else if (*ilst < 1 || *ilst > *n) {
*info = -8;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CTREXC", &i__1);
return 0;
}

/*     Quick return if possible */

if (*n == 1 || *ifst == *ilst) {
return 0;
}

if (*ifst < *ilst) {

/*        Move the IFST-th diagonal element forward down the diagonal. */

m1 = 0;
m2 = -1;
m3 = 1;
} else {


注释：
- `t_dim1 = *ldt;`: 计算二维数组 `t` 的第一维长度，即 `LDT`
- `t_offset = 1 + t_dim1;`: 计算 `t` 的偏移量，用于访问 `t` 中的元素
- `t -= t_offset;`: 将 `t` 指针调整到正确的起始位置
- `q_dim1 = *ldq;`: 计算二维数组 `q` 的第一维长度，即 `LDQ`
- `q_offset = 1 + q_dim1;`: 计算 `q` 的偏移量，用于访问 `q` 中的元素
- `q -= q_offset;`: 将 `q` 指针调整到正确的起始位置
- `*info = 0;`: 将输出参数 `info` 初始化为 0
- `wantq = lsame_(compq, "V");`: 检查 `compq` 是否为 `'V'`，确定是否需要更新 `Q` 矩阵
- 条件语句依次检查输入参数的合法性，并在出现不合法情况时设置 `info` 的相应负值
- `xerbla_("CTREXC", &i__1);`: 调用错误处理程序 `xerbla_`，输出错误信息和错误码
/*        Move the IFST-th diagonal element backward up the diagonal. */

/* 设置 m1、m2、m3 的初值 */
m1 = -1;
m2 = 0;
m3 = -1;

/* 循环遍历对角元素进行交换 */
i__1 = *ilst + m2;   /* 终止条件，根据 m2 确定 */
i__2 = m3;           /* 步长，根据 m3 确定 */
for (k = *ifst + m1; i__2 < 0 ? k >= i__1 : k <= i__1; k += i__2) {

/*        Interchange the k-th and (k+1)-th diagonal elements. */

/* 交换第 k 和第 (k+1) 对角元素 */
i__3 = k + k * t_dim1;
t11.r = t[i__3].r, t11.i = t[i__3].i;
i__3 = k + 1 + (k + 1) * t_dim1;
t22.r = t[i__3].r, t22.i = t[i__3].i;

/* 确定执行交换的变换 */
q__1.r = t22.r - t11.r, q__1.i = t22.i - t11.i;
clartg_(&t[k + (k + 1) * t_dim1], &q__1, &cs, &sn, &temp);

/* 对矩阵 T 应用变换 */
if (k + 2 <= *n) {
    i__3 = *n - k - 1;
    crot_(&i__3, &t[k + (k + 2) * t_dim1], ldt, &t[k + 1 + (k + 2) *
        t_dim1], ldt, &cs, &sn);
}
i__3 = k - 1;
r_cnjg(&q__1, &sn);
crot_(&i__3, &t[k * t_dim1 + 1], &c__1, &t[(k + 1) * t_dim1 + 1], &
    c__1, &cs, &q__1);

/* 更新对角元素的值 */
i__3 = k + k * t_dim1;
t[i__3].r = t22.r, t[i__3].i = t22.i;
i__3 = k + 1 + (k + 1) * t_dim1;
t[i__3].r = t11.r, t[i__3].i = t11.i;

if (wantq) {

/*           Accumulate transformation in the matrix Q. */

/* 在矩阵 Q 中累积变换 */
r_cnjg(&q__1, &sn);
crot_(n, &q[k * q_dim1 + 1], &c__1, &q[(k + 1) * q_dim1 + 1], &
    c__1, &cs, &q__1);
}

/* L10: */
}

return 0;

/*     End of CTREXC */

} /* ctrexc_ */

/* Subroutine */ int ctrti2_(char *uplo, char *diag, integer *n, singlecomplex *a,
    integer *lda, integer *info)
{
/* 系统生成的本地变量和函数声明 */
integer a_dim1, a_offset, i__1, i__2;
singlecomplex q__1;

/* 本地变量声明 */
static integer j;
static singlecomplex ajj;
extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
    integer *);
extern logical lsame_(char *, char *);
static logical upper;
extern /* Subroutine */ int ctrmv_(char *, char *, char *, integer *,
    singlecomplex *, integer *, singlecomplex *, integer *), xerbla_(char *, integer *);
static logical nounit;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

CTRTI2 计算单精度复数上三角或下三角矩阵的逆矩阵。

This is the Level 2 BLAS version of the algorithm.

Arguments
=========

UPLO    (input) CHARACTER*1
        指定矩阵 A 是上三角还是下三角。
        = 'U':  上三角
        = 'L':  下三角

DIAG    (input) CHARACTER*1
        指定矩阵 A 是否为单位三角矩阵。
        = 'N':  非单位三角
        = 'U':  单位三角

N       (input) INTEGER
        矩阵 A 的阶数。N >= 0.
*/
    # 测试输入参数的有效性
    Test the input parameters.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.

            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    nounit = lsame_(diag, "N");

    // 检查上三角或下三角标识符是否正确
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -2;
    } else if (*n < 0) {
        // 检查矩阵维度是否合法
        *info = -3;
    } else if (*lda < max(1,*n)) {
        // 检查数组的第一个维度是否合法
        *info = -5;
    }

    // 若出现错误，调用错误处理函数并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CTRTI2", &i__1);
        return 0;
    }

    // 根据上三角或下三角标识符选择不同的逆矩阵计算方法
    if (upper) {
        /* Compute inverse of upper triangular matrix. */

        // 对上三角矩阵进行逆矩阵计算
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            if (nounit) {
                // 计算对角元素的倒数
                i__2 = j + j * a_dim1;
                c_div(&q__1, &c_b57, &a[j + j * a_dim1]);
                a[i__2].r = q__1.r, a[i__2].i = q__1.i;
                // 将对角元素变为其倒数的相反数
                i__2 = j + j * a_dim1;
                q__1.r = -a[i__2].r, q__1.i = -a[i__2].i;
                ajj.r = q__1.r, ajj.i = q__1.i;
            } else {
                // 若单位对角矩阵标志为真，则将对角元素设置为-1
                q__1.r = -1.f, q__1.i = -0.f;
                ajj.r = q__1.r, ajj.i = q__1.i;
            }

            // 计算第j列的前1:j-1个元素
            i__2 = j - 1;
            ctrmv_("Upper", "No transpose", diag, &i__2, &a[a_offset], lda, &
                a[j * a_dim1 + 1], &c__1);
            // 对第j列的前1:j-1个元素乘以ajj
            i__2 = j - 1;
            cscal_(&i__2, &ajj, &a[j * a_dim1 + 1], &c__1);
            /* L10: */
        }
    } else {
        /* Compute inverse of lower triangular matrix. */

        // 对下三角矩阵进行逆矩阵计算
        for (j = *n; j >= 1; --j) {
            if (nounit) {
                // 计算对角元素的倒数
                i__1 = j + j * a_dim1;
                c_div(&q__1, &c_b57, &a[j + j * a_dim1]);
                a[i__1].r = q__1.r, a[i__1].i = q__1.i;
                // 将对角元素变为其倒数的相反数
                i__1 = j + j * a_dim1;
                q__1.r = -a[i__1].r, q__1.i = -a[i__1].i;
                ajj.r = q__1.r, ajj.i = q__1.i;
            } else {
                // 若单位对角矩阵标志为真，则将对角元素设置为-1
                q__1.r = -1.f, q__1.i = -0.f;
                ajj.r = q__1.r, ajj.i = q__1.i;
            }
            if (j < *n) {
                // 计算第j列的后j+1:n个元素
                i__1 = *n - j;
                ctrmv_("Lower", "No transpose", diag, &i__1, &a[j + 1 + (j +
                    1) * a_dim1], lda, &a[j + 1 + j * a_dim1], &c__1);
                // 对第j列的后j+1:n个元素乘以ajj
                i__1 = *n - j;
                cscal_(&i__1, &ajj, &a[j + 1 + j * a_dim1], &c__1);
            }
            /* L20: */
        }
    }

    // 返回计算成功的标志
    return 0;

/*     End of CTRTI2 */

} /* ctrti2_ */


注释已按照要求添加到每一行代码中，并且按照规范使用了特定的注释格式。
    extern /* Subroutine */ int ctrti2_(char *, char *, integer *, singlecomplex *,
        integer *, integer *), xerbla_(char *, integer *);

外部声明两个函数 `ctrti2_` 和 `xerbla_`，它们的参数和返回类型如下：

- `ctrti2_`:
  - 参数: 
    - `char *` 类型的指针（字符数组）
    - `char *` 类型的指针（字符数组）
    - `integer *` 类型的指针（整数数组）
    - `singlecomplex *` 类型的指针（单精度复数数组）
    - `integer *` 类型的指针（整数数组）
    - `integer *` 类型的指针（整数数组）
  - 返回类型: `int`

- `xerbla_`:
  - 参数: 
    - `char *` 类型的指针（字符数组）
    - `integer *` 类型的指针（整数数组）
  - 返回类型: `void`

```py    
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

外部声明函数 `ilaenv_`，它的参数和返回类型如下：

- `ilaenv_`:
  - 参数: 
    - `integer *` 类型的指针（整数数组）
    - `char *` 类型的指针（字符数组）
    - `char *` 类型的指针（字符数组）
    - `integer *` 类型的指针（整数数组）
    - `integer *` 类型的指针（整数数组）
    - `integer *` 类型的指针（整数数组）
    - `integer *` 类型的指针（整数数组）
    - `ftnlen` 类型的整数
    - `ftnlen` 类型的整数
  - 返回类型: `integer`

```    
    static logical nounit;

定义了一个静态的逻辑型变量 `nounit`。
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CTRTRI computes the inverse of a complex upper or lower triangular
    matrix A.

    This is the Level 3 BLAS version of the algorithm.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.

    DIAG    (input) CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.

    =====================================================================


       Test the input parameters.
*/



    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    /* Adjust the array A indexing to match the Fortran style (1-based indexing). */

    /* Function Body */
    *info = 0;
    /* Initialize INFO to 0, indicating no errors initially. */

    upper = lsame_(uplo, "U");
    /* Check if UPLO equals 'U' (upper triangular). */

    nounit = lsame_(diag, "N");
    /* Check if DIAG equals 'N' (non-unit triangular). */

    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    }
    /* Validate the input arguments UPLO, DIAG, N, LDA, and set INFO accordingly if any error is found. */

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CTRTRI", &i__1);
        return 0;
    }
    /* If INFO is not 0, call the error handler XERBLA and return. */

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }
    /* If N is 0, no computation is needed, so return. */

    /* Check for singularity if non-unit. */
    if (nounit) {
        /* If DIAG = 'N', check for zero diagonal elements. */
        i__1 = *n;
        for (*info = 1; *info <= i__1; ++(*info)) {
            /* Loop over each diagonal element. */
            i__2 = *info + *info * a_dim1;
            if (a[i__2].r == 0.f && a[i__2].i == 0.f) {
                return 0;
            }
            /* If diagonal element is zero, matrix is singular, return. */
        }
        *info = 0;
        /* Reset INFO to 0, indicating no singularity. */
    }

    /*
       Determine the block size for this environment.
       Writing concatenation
    */
    i__3[0] = 1, a__1[0] = uplo;
    i__3[1] = 1, a__1[1] = diag;
    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
    # 将字符串数组 a__1 中的字符串连接起来，存放在 ch__1 中，使用连接符 &c__2

    nb = ilaenv_(&c__1, "CTRTRI", ch__1, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)2);
    # 调用 ilaenv_ 函数，获取用于计算矩阵逆的优化块大小 nb
    # 参数解释：
    # &c__1: 询问参数 1 表示要求的任务类型
    # "CTRTRI": 字符串参数，指定要查询的 LAPACK 子程序名
    # ch__1: 字符串参数，用于传递连接后的字符串
    # n: 矩阵的阶数
    # &c_n1: 整数参数，无效参数，传递 -1
    # &c_n1: 整数参数，无效参数，传递 -1
    # &c_n1: 整数参数，无效参数，传递 -1
    # (ftnlen)6: 整数参数，指定 "CTRTRI" 字符串的长度
    # (ftnlen)2: 整数参数，指定 ch__1 字符串的长度

    if (nb <= 1 || nb >= *n) {
    # 如果计算得到的优化块大小 nb 小于等于 1 或者大于等于输入矩阵的阶数 *n
/*        Use unblocked code */

    ctrti2_(uplo, diag, n, &a[a_offset], lda, info);
    } else {

/*        Use blocked code */

    if (upper) {

/*           Compute inverse of upper triangular matrix */

        i__1 = *n;
        i__2 = nb;
        for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
        i__4 = nb, i__5 = *n - j + 1;
        jb = min(i__4,i__5);

/*              Compute rows 1:j-1 of current block column */

        i__4 = j - 1;
        ctrmm_("Left", "Upper", "No transpose", diag, &i__4, &jb, &
            c_b57, &a[a_offset], lda, &a[j * a_dim1 + 1], lda);
        i__4 = j - 1;
        q__1.r = -1.f, q__1.i = -0.f;
        ctrsm_("Right", "Upper", "No transpose", diag, &i__4, &jb, &
            q__1, &a[j + j * a_dim1], lda, &a[j * a_dim1 + 1],
            lda);

/*              Compute inverse of current diagonal block */

        ctrti2_("Upper", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L20: */
        }
    } else {

/*           Compute inverse of lower triangular matrix */

        nn = (*n - 1) / nb * nb + 1;
        i__2 = -nb;
        for (j = nn; i__2 < 0 ? j >= 1 : j <= 1; j += i__2) {
/* Computing MIN */
        i__1 = nb, i__4 = *n - j + 1;
        jb = min(i__1,i__4);
        if (j + jb <= *n) {

/*                 Compute rows j+jb:n of current block column */

            i__1 = *n - j - jb + 1;
            ctrmm_("Left", "Lower", "No transpose", diag, &i__1, &jb,
                &c_b57, &a[j + jb + (j + jb) * a_dim1], lda, &a[j
                + jb + j * a_dim1], lda);
            i__1 = *n - j - jb + 1;
            q__1.r = -1.f, q__1.i = -0.f;
            ctrsm_("Right", "Lower", "No transpose", diag, &i__1, &jb,
                 &q__1, &a[j + j * a_dim1], lda, &a[j + jb + j *
                a_dim1], lda);
        }

/*              Compute inverse of current diagonal block */

        ctrti2_("Lower", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L30: */
        }
    }
    }

    return 0;

/*     End of CTRTRI */

} /* ctrtri_ */

/* Subroutine */ int cung2r_(integer *m, integer *n, integer *k, singlecomplex *a,
    integer *lda, singlecomplex *tau, singlecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *), clarf_(char *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *),
        xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CUNG2R generates an m by n complex matrix Q with orthonormal columns,
    # 测试输入参数的合法性

    # 确保输入参数 M 大于等于零，即矩阵 Q 的行数必须非负
    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    # 确保输入参数 N 大于等于零且不超过 M，即矩阵 Q 的列数在指定范围内
    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.

    # 确保输入参数 K 大于等于零且不超过 N，即定义矩阵 Q 的 elementary reflectors 的数量在指定范围内
    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.

    # 确保输入参数 A 符合要求
    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by CGEQRF in the first k columns of its array
            argument A.
            On exit, the m by n matrix Q.

    # 确保输入参数 LDA 大于等于 max(1, M)，即数组 A 的第一个维度要足够容纳矩阵 Q
    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    # 确保输入参数 TAU 符合要求
    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.

    # 确保输入参数 WORK 符合要求
    WORK    (workspace) COMPLEX array, dimension (N)

    # 确保输出参数 INFO 符合要求
    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    =====================================================================
    /* Parameter adjustments */
    // 设置矩阵a的第一维度和偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    // 调整参数数组
    --tau;
    --work;

    /* Function Body */
    // 初始化info为0，表示无错误
    *info = 0;
    // 检查*m是否小于0，若是则将info设为-1
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0 || *n > *m) {
        // 检查*n是否小于0或者大于*m，若是则将info设为-2
        *info = -2;
    } else if (*k < 0 || *k > *n) {
        // 检查*k是否小于0或者大于*n，若是则将info设为-3
        *info = -3;
    } else if (*lda < max(1,*m)) {
        // 检查*lda是否小于1和*m的较大值，若是则将info设为-5
        *info = -5;
    }
    // 若info不为0，表示有错误发生，调用错误处理例程并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNG2R", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 如果*n小于等于0，直接返回
    if (*n <= 0) {
        return 0;
    }

/*     Initialise columns k+1:n to columns of the unit matrix */

    // 将矩阵a的第k+1至n列初始化为单位矩阵的列
    i__1 = *n;
    for (j = *k + 1; j <= i__1; ++j) {
        i__2 = *m;
        for (l = 1; l <= i__2; ++l) {
            // 设置a的元素为复数0
            i__3 = l + j * a_dim1;
            a[i__3].r = 0.f, a[i__3].i = 0.f;
/* L10: */
        }
        // 设置单位矩阵的元素
        i__2 = j + j * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;
/* L20: */
    }

    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i) to A(i:m,i:n) from the left */

    // 如果i小于*n，将H(i)应用于A的子矩阵A(i:m,i:n)
    if (i__ < *n) {
        // 设置A的对角元素为1
        i__1 = i__ + i__ * a_dim1;
        a[i__1].r = 1.f, a[i__1].i = 0.f;
        // 计算clarf所需的参数并调用该函数
        i__1 = *m - i__ + 1;
        i__2 = *n - i__;
        clarf_("Left", &i__1, &i__2, &a[i__ + i__ * a_dim1], &c__1, &tau[
            i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
    }
    // 如果i小于*m，将H(i)应用于A的子矩阵A(i+1:m,i)
    if (i__ < *m) {
        i__1 = *m - i__;
        i__2 = i__;
        q__1.r = -tau[i__2].r, q__1.i = -tau[i__2].i;
        cscal_(&i__1, &q__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
    }
    // 更新A的对角元素
    i__1 = i__ + i__ * a_dim1;
    i__2 = i__;
    q__1.r = 1.f - tau[i__2].r, q__1.i = 0.f - tau[i__2].i;
    a[i__1].r = q__1.r, a[i__1].i = q__1.i;

/*        Set A(1:i-1,i) to zero */

    // 将A的第1至i-1行第i列元素设置为0
    i__1 = i__ - 1;
    for (l = 1; l <= i__1; ++l) {
        i__2 = l + i__ * a_dim1;
        a[i__2].r = 0.f, a[i__2].i = 0.f;
/* L30: */
    }
/* L40: */
    }
    // 返回
    return 0;

/*     End of CUNG2R */

} /* cung2r_ */

/* Subroutine */ int cungbr_(char *vect, integer *m, integer *n, integer *k,
    singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *work, integer *lwork,
     integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, nb, mn;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    static logical wantq;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int cunglq_(integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer *),
         cungqr_(integer *, integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    !----------------------------------------------------------------------
    !     Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
    !     November 2006
    !----------------------------------------------------------------------
    !
    !     Purpose
    !     =======
    !
    !     CUNGBR generates one of the complex unitary matrices Q or P**H
    !     determined by CGEBRD when reducing a complex matrix A to bidiagonal
    !     form: A = Q * B * P**H.  Q and P**H are defined as products of
    !     elementary reflectors H(i) or G(i) respectively.
    !
    !     If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
    !     is of order M:
    !     if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
    !     columns of Q, where m >= n >= k;
    !     if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
    !     M-by-M matrix.
    !
    !     If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
    !     is of order N:
    !     if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
    !     rows of P**H, where n >= m >= k;
    !     if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
    !     an N-by-N matrix.
    !
    !     Arguments
    !     =========
    !
    !     VECT    (input) CHARACTER*1
    !             Specifies whether the matrix Q or the matrix P**H is
    !             required, as defined in the transformation applied by CGEBRD:
    !             = 'Q':  generate Q;
    !             = 'P':  generate P**H.
    !
    !     M       (input) INTEGER
    !             The number of rows of the matrix Q or P**H to be returned.
    !             M >= 0.
    !
    !     N       (input) INTEGER
    !             The number of columns of the matrix Q or P**H to be returned.
    !             N >= 0.
    !             If VECT = 'Q', M >= N >= min(M,K);
    !             if VECT = 'P', N >= M >= min(N,K).
    !
    !     K       (input) INTEGER
    !             If VECT = 'Q', the number of columns in the original M-by-K
    !             matrix reduced by CGEBRD.
    !             If VECT = 'P', the number of rows in the original K-by-N
    !             matrix reduced by CGEBRD.
    !             K >= 0.
    !
    !     A       (input/output) COMPLEX array, dimension (LDA,N)
    !             On entry, the vectors which define the elementary reflectors,
    !             as returned by CGEBRD.
    !             On exit, the M-by-N matrix Q or P**H.
    !
    !     LDA     (input) INTEGER
    !             The leading dimension of the array A. LDA >= M.
    !
    !     TAU     (input) COMPLEX array, dimension
    !                                       (min(M,K)) if VECT = 'Q'
    !                                       (min(N,K)) if VECT = 'P'
    !             TAU(i) must contain the scalar factor of the elementary
    !             reflector H(i) or G(i), which determines Q or P**H, as
    !             returned by CGEBRD in its array argument TAUQ or TAUP.
    !
    !     WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
    !             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    !----------------------------------------------------------------------
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK. LWORK >= max(1,min(M,N)).
    #         For optimum performance LWORK >= min(M,N)*NB, where NB
    #         is the optimal blocksize.
    #
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the WORK array, returns
    #         this value as the first entry of the WORK array, and no error
    #         message related to LWORK is issued by XERBLA.
    
    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value
    
    # =====================================================================
    
    # Test the input arguments
/* Parameter adjustments */
// 对参数进行调整
a_dim1 = *lda;
// 获取 lda 的值
a_offset = 1 + a_dim1;
// 计算 a 的偏移量
a -= a_offset;
// 调整 a 的指针位置
--tau;
// 将 tau 指针向前移动一个位置
--work;
// 将 work 指针向前移动一个位置

/* Function Body */
// 函数体开始
*info = 0;
// 初始化 info 为 0
wantq = lsame_(vect, "Q");
// 判断 vect 是否等于 "Q"
mn = min(*m,*n);
// 计算 m 和 n 中的较小值
lquery = *lwork == -1;
// 判断是否为查询操作

if (! wantq && ! lsame_(vect, "P")) {
    *info = -1;
    // 如果 wantq 不为真且 vect 不等于 "P"，将 info 设为 -1
} else if (*m < 0) {
    *info = -2;
    // 如果 m 小于 0，将 info 设为 -2
} else if (*n < 0 || wantq && (*n > *m || *n < min(*m,*k)) || ! wantq && (
    *m > *n || *m < min(*n,*k))) {
    *info = -3;
    // 如果 n 小于 0，或者 wantq 为真且 (n 大于 m 或者 n 小于 m 和 k 中的最小值)，或者 wantq 不为真且 (m 大于 n 或者 m 小于 n 和 k 中的最小值)，将 info 设为 -3
} else if (*k < 0) {
    *info = -4;
    // 如果 k 小于 0，将 info 设为 -4
} else if (*lda < max(1,*m)) {
    *info = -6;
    // 如果 lda 小于 max(1, m)，将 info 设为 -6
} else if (*lwork < max(1,mn) && ! lquery) {
    *info = -9;
    // 如果 lwork 小于 max(1, mn) 并且不是查询操作，将 info 设为 -9
}

if (*info == 0) {
    // 如果 info 为 0
    if (wantq) {
        // 如果 wantq 为真
        nb = ilaenv_(&c__1, "CUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (
            ftnlen)1);
        // 调用 ilaenv 函数确定 nb 的值
    } else {
        // 如果 wantq 不为真
        nb = ilaenv_(&c__1, "CUNGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (
            ftnlen)1);
        // 调用 ilaenv 函数确定 nb 的值
    }
    lwkopt = max(1,mn) * nb;
    // 计算所需的最优工作空间大小
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    // 将 work 的第一个元素设为最优工作空间大小的实部，虚部为 0
}

if (*info != 0) {
    // 如果 info 不为 0
    i__1 = -(*info);
    xerbla_("CUNGBR", &i__1);
    // 调用 xerbla 函数报告错误信息
    return 0;
    // 返回 0
} else if (lquery) {
    // 如果是查询操作
    return 0;
    // 返回 0
}

/*     Quick return if possible */
// 如果可能，快速返回

if (*m == 0 || *n == 0) {
    // 如果 m 或 n 为 0
    work[1].r = 1.f, work[1].i = 0.f;
    // 将 work 的第一个元素设为实部为 1，虚部为 0
    return 0;
    // 返回 0
}

if (wantq) {

/*
      Form Q, determined by a call to CGEBRD to reduce an m-by-k
      matrix
*/
// 构造 Q 矩阵，由调用 CGEBRD 函数来降维一个 m-by-k 矩阵

if (*m >= *k) {

/*       If m >= k, assume m >= n >= k */
// 如果 m >= k，假设 m >= n >= k

    cungqr_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
        iinfo);

} else {

/*
         If m < k, assume m = n

         Shift the vectors which define the elementary reflectors one
         column to the right, and set the first row and column of Q
         to those of the unit matrix
*/
// 如果 m < k，假设 m = n

    for (j = *m; j >= 2; --j) {
        // 循环 j 从 m 到 2
        i__1 = j * a_dim1 + 1;
        a[i__1].r = 0.f, a[i__1].i = 0.f;
        // 将第 j 行第一列的元素设为 0
        i__1 = *m;
        for (i__ = j + 1; i__ <= i__1; ++i__) {
            // 循环 i 从 j+1 到 m
            i__2 = i__ + j * a_dim1;
            i__3 = i__ + (j - 1) * a_dim1;
            a[i__2].r = a[i__3].r, a[i__2].i = a[i__3].i;
            // 将 Q 的元素进行向右移动一列
        }
    }
    i__1 = a_dim1 + 1;
    a[i__1].r = 1.f, a[i__1].i = 0.f;
    // 将 Q 的第一行第一列设为单位矩阵的对应元素
    i__1 = *m;
    for (i__ = 2; i__ <= i__1; ++i__) {
        // 循环 i 从 2 到 m
        i__2 = i__ + a_dim1;
        a[i__2].r = 0.f, a[i__2].i = 0.f;
        // 将 Q 的第一列除了第一个元素外其余元素设为 0
    }
    if (*m > 1) {

/*         Form Q(2:m,2:m) */
// 构造 Q(2:m,2:m)

        i__1 = *m - 1;
        i__2 = *m - 1;
        i__3 = *m - 1;
        cungqr_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
            1], &work[1], lwork, &iinfo);
        // 调用 cungqr 函数构造 Q(2:m,2:m)
    }
}
} else {

/*
      Form P', determined by a call to CGEBRD to reduce a k-by-n
      matrix
*/
// 构造 P' 矩阵，由调用 CGEBRD 函数来降维一个 k-by-n 矩阵

if (*k < *n) {

/*       If k < n, assume k <= m <= n */
// 如果 k < n，假设 k <= m <= n

    cunglq_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
        iinfo);

} else {
/*
             If k >= n, assume m = n

             Shift the vectors which define the elementary reflectors one
             row downward, and set the first row and column of P' to
             those of the unit matrix
*/

        i__1 = a_dim1 + 1;
        a[i__1].r = 1.f, a[i__1].i = 0.f;
        i__1 = *n;
        for (i__ = 2; i__ <= i__1; ++i__) {
        i__2 = i__ + a_dim1;
        a[i__2].r = 0.f, a[i__2].i = 0.f;
/* L40: */
        }
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
        for (i__ = j - 1; i__ >= 2; --i__) {
            i__2 = i__ + j * a_dim1;
            i__3 = i__ - 1 + j * a_dim1;
            a[i__2].r = a[i__3].r, a[i__2].i = a[i__3].i;
/* L50: */
        }
        i__2 = j * a_dim1 + 1;
        a[i__2].r = 0.f, a[i__2].i = 0.f;
/* L60: */
        }
        if (*n > 1) {

/*              Form P'(2:n,2:n) */

        i__1 = *n - 1;
        i__2 = *n - 1;
        i__3 = *n - 1;
        cunglq_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
            1], &work[1], lwork, &iinfo);
        }
    }
    }
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;

/*     End of CUNGBR */

} /* cungbr_ */

/* Subroutine */ int cunghr_(integer *n, integer *ilo, integer *ihi, singlecomplex *
    a, integer *lda, singlecomplex *tau, singlecomplex *work, integer *lwork, integer
    *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, nb, nh, iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int cungqr_(integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CUNGHR generates a complex unitary matrix Q which is defined as the
    product of IHI-ILO elementary reflectors of order N, as returned by
    CGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix Q. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of CGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) COMPLEX array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by CGEHRD.
            On exit, the N-by-N unitary matrix Q.
*/
    ! 检查输入参数是否合法
    
        LDA     (input) INTEGER
                The leading dimension of the array A. LDA >= max(1,N).
                数组 A 的前导维度。要求 LDA >= max(1,N)。
    
        TAU     (input) COMPLEX array, dimension (N-1)
                TAU(i) must contain the scalar factor of the elementary
                reflector H(i), as returned by CGEHRD.
                TAU(i) 必须包含由 CGEHRD 返回的第 i 个基本反射器 H(i) 的标量因子。
    
        WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
                On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
                退出时，如果 INFO = 0，则 WORK(1) 返回最佳 LWORK。
    
        LWORK   (input) INTEGER
                The dimension of the array WORK. LWORK >= IHI-ILO.
                For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
                the optimal blocksize.
                WORK 数组的维度。要求 LWORK >= IHI-ILO。
                为了达到最佳性能，建议 LWORK >= (IHI-ILO)*NB，其中 NB 是最佳块大小。
    
                If LWORK = -1, then a workspace query is assumed; the routine
                only calculates the optimal size of the WORK array, returns
                this value as the first entry of the WORK array, and no error
                message related to LWORK is issued by XERBLA.
                如果 LWORK = -1，则假定为工作空间查询；该例程仅计算 WORK 数组的最佳大小，并将此值作为 WORK 数组的第一个条目返回，
                XERBLA 不会返回与 LWORK 相关的任何错误信息。
    
        INFO    (output) INTEGER
                = 0:  successful exit
                < 0:  if INFO = -i, the i-th argument had an illegal value
                输出：
                = 0：成功退出
                < 0：如果 INFO = -i，则第 i 个参数具有非法值
    
        =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nh = *ihi - *ilo;
    lquery = *lwork == -1;

    /* Check for invalid input parameters */
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*lwork < max(1,nh) && ! lquery) {
        *info = -8;
    }

    /* Compute optimal workspace size if lwork is queried */
    if (*info == 0) {
        nb = ilaenv_(&c__1, "CUNGQR", " ", &nh, &nh, &nh, &c_n1, (ftnlen)6, (ftnlen)1);
        lwkopt = max(1,nh) * nb;
        work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

    /* Handle error case by calling XERBLA and returning */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNGHR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if n == 0 */
    if (*n == 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    /*
       Shift the vectors which define the elementary reflectors one
       column to the right, and set the first ilo and the last n-ihi
       rows and columns to those of the unit matrix
    */
    i__1 = *ilo + 1;
    for (j = *ihi; j >= i__1; --j) {
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            a[i__3].r = 0.f, a[i__3].i = 0.f;
        }
        i__2 = *ihi;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            i__4 = i__ + (j - 1) * a_dim1;
            a[i__3].r = a[i__4].r, a[i__3].i = a[i__4].i;
        }
        i__2 = *n;
        for (i__ = *ihi + 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            a[i__3].r = 0.f, a[i__3].i = 0.f;
        }
    }
    i__1 = *ilo;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *n;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            a[i__3].r = 0.f, a[i__3].i = 0.f;
        }
        i__2 = j + j * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;
    }
    i__1 = *n;
    for (j = *ihi + 1; j <= i__1; ++j) {
        i__2 = *n;
        for (i__ = 1; i__ <= i__2; ++i__) {
            i__3 = i__ + j * a_dim1;
            a[i__3].r = 0.f, a[i__3].i = 0.f;
        }
        i__2 = j + j * a_dim1;
        a[i__2].r = 1.f, a[i__2].i = 0.f;
    }

    /* Generate Q(ilo+1:ihi, ilo+1:ihi) if nh > 0 */
    if (nh > 0) {
        cungqr_(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*ilo], &work[1], lwork, &iinfo);
    }

    /* Set the optimal workspace size and return */
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;

/* End of CUNGHR */

} /* cunghr_ */

/* Subroutine */ int cungl2_(integer *m, integer *n, integer *k, singlecomplex *a,
    integer *lda, singlecomplex *tau, singlecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    singlecomplex q__1, q__2;

    /* Local variables */
    static integer i__, j, l;
    # 定义外部子程序 cscal_，参数分别为整数、单精度复数数组、单精度复数数组和整数
    extern /* Subroutine */ int cscal_(integer *, singlecomplex *, singlecomplex *,
        integer *);
    # 定义外部子程序 clarf_，参数分别为字符指针、整数、整数、单精度复数数组、整数、
    # 单精度复数数组、单精度复数数组、整数、单精度复数数组
    clarf_(char *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
    # 定义外部子程序 clacgv_，参数分别为整数、单精度复数数组和整数
    clacgv_(integer *, singlecomplex *, integer *);
    # 定义外部子程序 xerbla_，参数分别为字符指针和整数
    xerbla_(char *, integer *);
/* 参数调整 */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
--work;

/* 函数体 */
*info = 0;
if (*m < 0) {
*info = -1;
} else if (*n < *m) {
*info = -2;
} else if (*k < 0 || *k > *m) {
*info = -3;
} else if (*lda < max(1,*m)) {
*info = -5;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CUNGL2", &i__1);
return 0;
}

/* 如果可能的话，快速返回 */
if (*m <= 0) {
return 0;
}

if (*k < *m) {

/* 将行 k+1:m 初始化为单位矩阵的行 */

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
i__2 = *m;
for (l = *k + 1; l <= i__2; ++l) {
i__3 = l + j * a_dim1;
a[i__3].r = 0.f, a[i__3].i = 0.f;
/* L10: */
}
if (j > *k && j <= *m) {
i__2 = j + j * a_dim1;
a[i__2].r = 1.f, a[i__2].i = 0.f;
}
/* L20: */
}
}

for (i__ = *k; i__ >= 1; --i__) {

/* 将 H(i)' 作用于右侧的 A(i:m,i:n) */
    # 如果 i__ 小于 *n，则执行以下操作
    if (i__ < *n) {
        # 计算剩余部分的复共轭
        i__1 = *n - i__;
        clacgv_(&i__1, &a[i__ + (i__ + 1) * a_dim1], lda);
        
        # 如果 i__ 小于 *m，则执行以下操作
        if (i__ < *m) {
            # 设置主对角线元素为 (1, 0)
            i__1 = i__ + i__ * a_dim1;
            a[i__1].r = 1.f, a[i__1].i = 0.f;
            
            # 计算 Householder 变换并作用在右侧矩阵部分
            i__1 = *m - i__;
            i__2 = *n - i__ + 1;
            r_cnjg(&q__1, &tau[i__]);
            clarf_("Right", &i__1, &i__2, &a[i__ + i__ * a_dim1], lda, &
                q__1, &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
        }
        
        # 计算 Householder 向量的作用并复共轭
        i__1 = *n - i__;
        i__2 = i__;
        q__1.r = -tau[i__2].r, q__1.i = -tau[i__2].i;
        cscal_(&i__1, &q__1, &a[i__ + (i__ + 1) * a_dim1], lda);
        clacgv_(&i__1, &a[i__ + (i__ + 1) * a_dim1], lda);
    }
    
    # 更新主对角线元素
    i__1 = i__ + i__ * a_dim1;
    r_cnjg(&q__2, &tau[i__]);
    q__1.r = 1.f - q__2.r, q__1.i = 0.f - q__2.i;
    a[i__1].r = q__1.r, a[i__1].i = q__1.i;
/*        Set A(i,1:i-1,i) to zero */

// 循环将 A(i,1:i-1,i) 设置为零
i__1 = i__ - 1;
for (l = 1; l <= i__1; ++l) {
    i__2 = i__ + l * a_dim1;
    a[i__2].r = 0.f, a[i__2].i = 0.f;
/* L30: */
}
/* L40: */
}
return 0;

/*     End of CUNGL2 */

} /* cungl2_ */

/* Subroutine */ int cunglq_(integer *m, integer *n, integer *k, singlecomplex *a,
    integer *lda, singlecomplex *tau, singlecomplex *work, integer *lwork, integer *
    info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

/* Local variables */
static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
extern /* Subroutine */ int cungl2_(integer *, integer *, integer *,
    singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *), clarfb_(
    char *, char *, char *, char *, integer *, integer *, integer *,
    singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
    singlecomplex *, integer *), clarft_(
    char *, char *, integer *, integer *, singlecomplex *, integer *,
    singlecomplex *, singlecomplex *, integer *), xerbla_(char *,
    integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static integer ldwork, lwkopt;
static logical lquery;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
which is defined as the first M rows of a product of K elementary
reflectors of order N

      Q  =  H(k)' . . . H(2)' H(1)'

as returned by CGELQF.

Arguments
=========

M       (input) INTEGER
        The number of rows of the matrix Q. M >= 0.

N       (input) INTEGER
        The number of columns of the matrix Q. N >= M.

K       (input) INTEGER
        The number of elementary reflectors whose product defines the
        matrix Q. M >= K >= 0.

A       (input/output) COMPLEX array, dimension (LDA,N)
        On entry, the i-th row must contain the vector which defines
        the elementary reflector H(i), for i = 1,2,...,k, as returned
        by CGELQF in the first k rows of its array argument A.
        On exit, the M-by-N matrix Q.

LDA     (input) INTEGER
        The first dimension of the array A. LDA >= max(1,M).

TAU     (input) COMPLEX array, dimension (K)
        TAU(i) must contain the scalar factor of the elementary
        reflector H(i), as returned by CGELQF.

WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
        On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    # 定义输入参数 LWORK，表示工作数组的维度
    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            
            如果 LWORK = -1，则假定为工作空间查询；该例程仅计算工作数组的最佳大小，
            并将此值作为工作数组的第一个条目返回，XERBLA 不会发出与 LWORK 相关的错误消息。
    
    # 定义输出参数 INFO，表示函数返回的状态信息
    INFO    (output) INTEGER
            = 0:  successful exit;
            < 0:  if INFO = -i, the i-th argument has an illegal value

    =====================================================================

       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "CUNGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    lwkopt = max(1,*m) * nb;
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < *m) {
        *info = -2;
    } else if (*k < 0 || *k > *m) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*lwork < max(1,*m) && ! lquery) {
        *info = -8;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNGLQ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*m <= 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *m;
    if (nb > 1 && nb < *k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
        i__1 = 0, i__2 = ilaenv_(&c__3, "CUNGLQ", " ", m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *k) {

/*           Determine if workspace is large enough for blocked code. */

            ldwork = *m;
            iws = ldwork * nb;
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

                nb = *lwork / ldwork;
/* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "CUNGLQ", " ", m, n, k, &c_n1,
                     (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*
          Use blocked code after the last block.
          The first kk rows are handled by the block method.
*/

        ki = (*k - nx - 1) / nb * nb;
/* Computing MIN */
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);

/*        Set A(kk+1:m,1:kk) to zero. */

        i__1 = kk;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = kk + 1; i__ <= i__2; ++i__) {
                i__3 = i__ + j * a_dim1;
                a[i__3].r = 0.f, a[i__3].i = 0.f;
/* L10: */
            }
/* L20: */
        }
    } else {
        kk = 0;
    }

/*     Use unblocked code for the last or only block. */

    if (kk < *m) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        cungl2_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &
            tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/*        Use blocked code */

        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);
            if (i__ + ib <= *m) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

                clarf_("Left", &i__1, &ib, &a[i__ + (i__ + 1) * a_dim1], lda, &tau[i__], &work[1]);
            }
        }
    }
/*      Initialize the block size */



        i__2 = *n - i__ + 1;



        clarft_("Forward", "Rowwise", &i__2, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);



/*              Apply H' to A(i+ib:m,i:n) from the right */



        i__2 = *m - i__ - ib + 1;
        i__3 = *n - i__ + 1;
        clarfb_("Right", "Conjugate transpose", "Forward", "Rowwise",
            &i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
            1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[
            ib + 1], &ldwork);



        }



/*           Apply H' to columns i:n of current block */



        i__2 = *n - i__ + 1;
        cungl2_(&ib, &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
            work[1], &iinfo);



/*           Set columns 1:i-1 of current block to zero */



        i__2 = i__ - 1;
        for (j = 1; j <= i__2; ++j) {
        i__3 = i__ + ib - 1;
        for (l = i__; l <= i__3; ++l) {
            i__4 = l + j * a_dim1;
            a[i__4].r = 0.f, a[i__4].i = 0.f;
/* L30: */
        }
/* L40: */
        }
/* L50: */
    }
    }



    work[1].r = (real) iws, work[1].i = 0.f;



    return 0;



/*     End of CUNGLQ */



} /* cunglq_ */



/* Subroutine */ int cungqr_(integer *m, integer *n, integer *k, singlecomplex *a,
    integer *lda, singlecomplex *tau, singlecomplex *work, integer *lwork, integer *
    info)
{



    /* System generated locals */



    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;



    /* Local variables */



    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;



    extern /* Subroutine */ int cung2r_(integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *);



    extern /* Subroutine */ int clarfb_(
        char *, char *, char *, char *, integer *, integer *, integer *,
        singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *, integer *,
        singlecomplex *, integer *);



    extern /* Subroutine */ int clarft_(
        char *, char *, integer *, integer *, singlecomplex *, integer *,
        singlecomplex *, singlecomplex *, integer *);



    extern /* Subroutine */ int xerbla_(char *, integer *);



    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);



    static integer ldwork, lwkopt;



    static logical lquery;



/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006



    Purpose
    =======



    CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
    which is defined as the first N columns of a product of K elementary
    reflectors of order M



          Q  =  H(1) H(2) . . . H(k)



    as returned by CGEQRF.



    Arguments
    ==========



    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.



    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
    # K (输入) 整数
    # 定义矩阵 Q 的基础反射器数量。N >= K >= 0。
    K       (input) INTEGER

    # A (输入/输出) 复数数组，维度为 (LDA,N)
    # 在输入时，第 i 列必须包含由 CGEQRF 返回的第 i 个基础反射器 H(i) 的向量，对于 i = 1,2,...,k。
    # 在输出时，是 MxN 矩阵 Q。
    A       (input/output) COMPLEX array, dimension (LDA,N)

    # LDA (输入) 整数
    # 数组 A 的第一个维度。LDA >= max(1,M)。
    LDA     (input) INTEGER

    # TAU (输入) 复数数组，维度为 (K)
    # TAU(i) 必须包含由 CGEQRF 返回的第 i 个基础反射器 H(i) 的标量因子。
    TAU     (input) COMPLEX array, dimension (K)

    # WORK (工作空间/输出) 复数数组，维度为 (MAX(1,LWORK))
    # 在输出时，如果 INFO = 0，则 WORK(1) 返回最优 LWORK。
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))

    # LWORK (输入) 整数
    # 数组 WORK 的维度。LWORK >= max(1,N)。
    # 为了获得最佳性能，建议 LWORK >= N*NB，其中 NB 是最优块大小。
    # 如果 LWORK = -1，则假定需要进行工作空间查询；该例程仅计算 WORK 数组的最优大小，
    # 并将此值作为 WORK 数组的第一个条目返回，并且 XERBLA 不会发出与 LWORK 相关的错误消息。
    LWORK   (input) INTEGER

    # INFO (输出) 整数
    # = 0：成功退出
    # < 0：如果 INFO = -i，则第 i 个参数具有非法值
    INFO    (output) INTEGER

    # ================================================================
    # 测试输入参数
    # 检查输入参数的有效性，例如 K 是否在指定范围内，LDA 是否足够大，LWORK 是否满足性能需求等。
    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    nb = ilaenv_(&c__1, "CUNGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);  // 调用 ilaenv 函数确定最优块大小 nb
    lwkopt = max(1,*n) * nb;  // 计算所需的最大工作空间大小
    work[1].r = (real) lwkopt, work[1].i = 0.f;  // 设置工作数组的第一个元素为计算得到的工作空间大小
    lquery = *lwork == -1;  // 判断是否为查询工作空间大小的阶段
    if (*m < 0) {
        *info = -1;  // 若 m 参数小于 0，则设置错误码为 -1
    } else if (*n < 0 || *n > *m) {
        *info = -2;  // 若 n 参数不在有效范围内，则设置错误码为 -2
    } else if (*k < 0 || *k > *n) {
        *info = -3;  // 若 k 参数不在有效范围内，则设置错误码为 -3
    } else if (*lda < max(1,*m)) {
        *info = -5;  // 若 lda 参数小于所需最小值，则设置错误码为 -5
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;  // 若 lwork 参数小于所需最小值且不处于查询阶段，则设置错误码为 -8
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNGQR", &i__1);  // 若出现错误，则调用错误处理函数 xerbla_
        return 0;  // 返回错误码
    } else if (lquery) {
        return 0;  // 若处于查询阶段，则直接返回
    }

/*     Quick return if possible */

    if (*n <= 0) {
        work[1].r = 1.f, work[1].i = 0.f;  // 若 n <= 0，则设置工作数组的第一个元素为 1
        return 0;  // 直接返回
    }

    nbmin = 2;  // 设置最小块大小为 2
    nx = 0;  // 初始化 nx 参数为 0
    iws = *n;  // 初始化 iws 参数为 n
    if (nb > 1 && nb < *k) {

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "CUNGQR", " ", m, n, k, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);  // 计算跨越阈值 nx
    if (nx < *k) {

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *n;  // 设置 ldwork 参数为 n
        iws = ldwork * nb;  // 计算工作空间大小
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        nb = *lwork / ldwork;  // 根据工作空间大小重新调整 nb 的值
/* Computing MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "CUNGQR", " ", m, n, k, &c_n1,
             (ftnlen)6, (ftnlen)1);
        nbmin = max(i__1,i__2);  // 更新最小块大小 nbmin
        }
    }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*
          Use blocked code after the last block.
          The first kk columns are handled by the block method.
*/

    ki = (*k - nx - 1) / nb * nb;  // 计算最后一个块之后的起始位置 ki
/* Computing MIN */
    i__1 = *k, i__2 = ki + nb;
    kk = min(i__1,i__2);  // 计算实际处理的列数 kk

/*        Set A(1:kk,kk+1:n) to zero. */

    i__1 = *n;
    for (j = kk + 1; j <= i__1; ++j) {  // 循环设置 A 的部分元素为零
        i__2 = kk;
        for (i__ = 1; i__ <= i__2; ++i__) {
        i__3 = i__ + j * a_dim1;
        a[i__3].r = 0.f, a[i__3].i = 0.f;  // 设置实部和虚部为零
/* L10: */
        }
/* L20: */
    }
    } else {
    kk = 0;  // 若条件不满足，则设置 kk 为 0
    }

/*     Use unblocked code for the last or only block. */

    if (kk < *n) {
    i__1 = *m - kk;
    i__2 = *n - kk;
    i__3 = *k - kk;
    cung2r_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &
        tau[kk + 1], &work[1], &iinfo);  // 调用 cung2r 函数处理最后一个或唯一的块
    }

    if (kk > 0) {

/*        Use blocked code */

    i__1 = -nb;
    for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
        i__2 = nb, i__3 = *k - i__ + 1;
        ib = min(i__2,i__3);  // 计算当前块的大小 ib
        if (i__ + ib <= *n) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
        i__2 = *m - i__ + 1;
        clarft_("Forward", "Columnwise", &i__2, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);

用法说明：


        i__2 = *m - i__ + 1;

计算当前块的行数。


        clarft_("Forward", "Columnwise", &i__2, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);

调用 clarft 函数，对当前块的部分数据进行计算转换操作。


        i__2 = *m - i__ + 1;
        i__3 = *n - i__ - ib + 1;
        clarfb_("Left", "No transpose", "Forward", "Columnwise", &
            i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
            1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &
            work[ib + 1], &ldwork);

应用 Hessenberg 矩阵 H 到 A(i:m,i+ib:n) 的左乘操作。


        i__2 = *m - i__ + 1;
        cung2r_(&i__2, &ib, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
            work[1], &iinfo);

生成元素反射器序列 H(k)...H(2)H(1)，并将其存储在 Q 中。


        i__2 = i__ + ib - 1;
        for (j = i__; j <= i__2; ++j) {
        i__3 = i__ - 1;
        for (l = 1; l <= i__3; ++l) {
            i__4 = l + j * a_dim1;
            a[i__4].r = 0.f, a[i__4].i = 0.f;
        }
        }

将当前块的上三角部分设置为零。


    work[1].r = (real) iws, work[1].i = 0.f;
    return 0;

设置工作数组中的第一个元素为实数部分 iws，并返回零。


} /* cungqr_ */

结束 cungqr_ 子程序。


/* Subroutine */ int cunm2l_(char *side, char *trans, integer *m, integer *n,
    integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
    integer *ldc, singlecomplex *work, integer *info)
{

开始 cunm2l_ 子程序。


    static integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
    singlecomplex q__1;

声明静态局部变量和复数类型的局部变量 q__1。


    static integer i__, i1, i2, i3, mi, ni, nq;
    static singlecomplex aii;
    static logical left;
    static singlecomplex taui;
    extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
        , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static logical notran;

声明整数变量、单精度复数变量、逻辑变量，以及调用的外部子程序声明。


    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

说明 LAPACK 的版本和提供者信息。


    Purpose
    =======

目的：对 cunm2l_ 子程序的说明。


    CUNM2L overwrites the general complex m-by-n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'C', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'C',

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

说明 cunm2l_ 子程序的功能和操作对象。


    Arguments
    =========

参数说明开始。


    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

SIDE 参数说明：指定是从左侧还是右侧应用 Q 或 Q'。


    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q' (Conjugate transpose)

TRANS 参数说明：指定是应用 Q 还是 Q'。

以上为 cunm2l_ 子程序开头部分的注释和说明。
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.


    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.


    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.


    A       (input) COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.


    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).


    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQLF.


    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.


    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).


    WORK    (workspace) COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'


    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value


    =====================================================================


       Test the input arguments
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
c_dim1 = *ldc;
c_offset = 1 + c_dim1;
c__ -= c_offset;
--work;

/* Function Body */
*info = 0;
left = lsame_(side, "L");
notran = lsame_(trans, "N");

/* NQ is the order of Q */

if (left) {
nq = *m;
} else {
nq = *n;
}
if (! left && ! lsame_(side, "R")) {
*info = -1;
} else if (! notran && ! lsame_(trans, "C")) {
*info = -2;
} else if (*m < 0) {
*info = -3;
} else if (*n < 0) {
*info = -4;
} else if (*k < 0 || *k > nq) {
*info = -5;
} else if (*lda < max(1,nq)) {
*info = -7;
} else if (*ldc < max(1,*m)) {
*info = -10;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CUNM2L", &i__1);
return 0;
}

/* Quick return if possible */

if (*m == 0 || *n == 0 || *k == 0) {
return 0;
}

if (left && notran || ! left && ! notran) {
i1 = 1;
i2 = *k;
i3 = 1;
} else {
i1 = *k;
i2 = 1;
i3 = -1;
}

if (left) {
ni = *n;
} else {
mi = *m;
}

i__1 = i2;
i__2 = i3;
for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
if (left) {

/* H(i) or H(i)' is applied to C(1:m-k+i,1:n) */

mi = *m - *k + i__;
} else {

/* H(i) or H(i)' is applied to C(1:m,1:n-k+i) */

ni = *n - *k + i__;
}

/* Apply H(i) or H(i)' */

if (notran) {
i__3 = i__;
taui.r = tau[i__3].r, taui.i = tau[i__3].i;
} else {
r_cnjg(&q__1, &tau[i__]);
taui.r = q__1.r, taui.i = q__1.i;
}
i__3 = nq - *k + i__ + i__ * a_dim1;
aii.r = a[i__3].r, aii.i = a[i__3].i;
i__3 = nq - *k + i__ + i__ * a_dim1;
a[i__3].r = 1.f, a[i__3].i = 0.f;
clarf_(side, &mi, &ni, &a[i__ * a_dim1 + 1], &c__1, &taui, &c__[
c_offset], ldc, &work[1]);
i__3 = nq - *k + i__ + i__ * a_dim1;
a[i__3].r = aii.r, a[i__3].i = aii.i;
/* L10: */
}
return 0;

/* End of CUNM2L */

} /* cunm2l_ */

/* Subroutine */ int cunm2r_(char *side, char *trans, integer *m, integer *n,
integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
integer *ldc, singlecomplex *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
singlecomplex q__1;

/* Local variables */
static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
static singlecomplex aii;
static logical left;
static singlecomplex taui;
extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
, integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
extern logical lsame_(char *, char *);
extern /* Subroutine */ int xerbla_(char *, integer *);
static logical notran;
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006



    Purpose
    =======

    CUNM2R overwrites the general complex m-by-n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'C', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'C',

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.



    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q' (Conjugate transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).

    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.

    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments



    Test the input arguments
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
c_dim1 = *ldc;
c_offset = 1 + c_dim1;
c__ -= c_offset;
--work;

/* Function Body */
*info = 0;
left = lsame_(side, "L");
notran = lsame_(trans, "N");

/* NQ is the order of Q */

if (left) {
nq = *m;
} else {
nq = *n;
}
if (! left && ! lsame_(side, "R")) {
*info = -1;
} else if (! notran && ! lsame_(trans, "C")) {
*info = -2;
} else if (*m < 0) {
*info = -3;
} else if (*n < 0) {
*info = -4;
} else if (*k < 0 || *k > nq) {
*info = -5;
} else if (*lda < max(1,nq)) {
*info = -7;
} else if (*ldc < max(1,*m)) {
*info = -10;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("CUNM2R", &i__1);
return 0;
}

/* Quick return if possible */

if (*m == 0 || *n == 0 || *k == 0) {
return 0;
}

if (left && ! notran || ! left && notran) {
i1 = 1;
i2 = *k;
i3 = 1;
} else {
i1 = *k;
i2 = 1;
i3 = -1;
}

if (left) {
ni = *n;
jc = 1;
} else {
mi = *m;
ic = 1;
}

i__1 = i2;
i__2 = i3;
for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
if (left) {

/* H(i) or H(i)' is applied to C(i:m,1:n) */

mi = *m - i__ + 1;
ic = i__;
} else {

/* H(i) or H(i)' is applied to C(1:m,i:n) */

ni = *n - i__ + 1;
jc = i__;
}

/* Apply H(i) or H(i)' */

if (notran) {
i__3 = i__;
taui.r = tau[i__3].r, taui.i = tau[i__3].i;
} else {
r_cnjg(&q__1, &tau[i__]);
taui.r = q__1.r, taui.i = q__1.i;
}
i__3 = i__ + i__ * a_dim1;
aii.r = a[i__3].r, aii.i = a[i__3].i;
i__3 = i__ + i__ * a_dim1;
a[i__3].r = 1.f, a[i__3].i = 0.f;
clarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &taui, &c__[ic
+ jc * c_dim1], ldc, &work[1]);
i__3 = i__ + i__ * a_dim1;
a[i__3].r = aii.r, a[i__3].i = aii.i;
/* L10: */
}
return 0;

/* End of CUNM2R */

} /* cunm2r_ */

/* Subroutine */ int cunmbr_(char *vect, char *side, char *trans, integer *m,
integer *n, integer *k, singlecomplex *a, integer *lda, singlecomplex *tau,
singlecomplex *c__, integer *ldc, singlecomplex *work, integer *lwork, integer *
info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2];
char ch__1[2];

/* Local variables */
static integer i1, i2, nb, mi, ni, nq, nw;
static logical left;
extern logical lsame_(char *, char *);
static integer iinfo;
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
integer *, integer *, ftnlen, ftnlen);
    # 外部声明，引用 Fortran 编写的 cunmlq_ 子例程，用于执行特定的矩阵操作
    extern /* Subroutine */ int cunmlq_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);
    
    # 静态变量，逻辑类型，指示不执行转置操作
    static logical notran;
    
    # 外部声明，引用 Fortran 编写的 cunmqr_ 子例程，用于执行特定的矩阵操作
    extern /* Subroutine */ int cunmqr_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);
    
    # 静态变量，逻辑类型，指示是否应用 Q 矩阵
    static logical applyq;
    
    # 静态变量，字符数组，用于指定转置操作的类型
    static char transt[1];
    
    # 静态变量，整型，用于存储需要的工作空间大小的最优值
    static integer lwkopt;
    
    # 静态变量，逻辑类型，指示是否查询工作空间大小
    static logical lquery;
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      P * C          C * P
    TRANS = 'C':      P**H * C       C * P**H

    Here Q and P**H are the unitary matrices determined by CGEBRD when
    reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
    and P**H are defined as products of elementary reflectors H(i) and
    G(i) respectively.

    Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
    order of the unitary matrix Q or P**H that is applied.

    If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
    if nq >= k, Q = H(1) H(2) . . . H(k);
    if nq < k, Q = H(1) H(2) . . . H(nq-1).

    If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
    if k < nq, P = G(1) G(2) . . . G(k);
    if k >= nq, P = G(1) G(2) . . . G(nq-1).

    Arguments
    =========

    VECT    (input) CHARACTER*1
            = 'Q': apply Q or Q**H;
            = 'P': apply P or P**H.

    SIDE    (input) CHARACTER*1
            = 'L': apply Q, Q**H, P or P**H from the Left;
            = 'R': apply Q, Q**H, P or P**H from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q or P;
            = 'C':  Conjugate transpose, apply Q**H or P**H.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by CGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by CGEBRD.
            K >= 0.

    A       (input) COMPLEX array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by CGEBRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).

    TAU     (input) COMPLEX array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by CGEBRD in the array argument TAUQ or TAUP.
"""
    # 测试输入参数的有效性
    # 指示：COMPLEX 类型数组 C，大小为 (LDC,N)，用于存储输入和输出数据
    #       在输入时，包含 M 行 N 列的矩阵 C
    #       在输出时，根据具体操作，可能包含 Q*C、Q**H*C、C*Q**H、C*Q、P*C、P**H*C、C*P 或 C*P**H 的结果
    C       (input/output) COMPLEX array, dimension (LDC,N)
    
    # 输入参数 LDC
    # 指示：矩阵 C 的列的领导维度
    #       必须满足 LDC >= max(1,M)，确保 LDC 至少等于矩阵 C 的行数 M
    LDC     (input) INTEGER
    
    # 工作空间 WORK 数组
    # 指示：用于存储计算过程中需要的临时数据
    #       在输出时，如果 INFO = 0，则 WORK(1) 返回最优 LWORK 的大小
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
    
    # 输入参数 LWORK
    # 指示：工作空间 WORK 数组的大小
    #       如果 SIDE = 'L'，则要求 LWORK >= max(1,N)
    #       如果 SIDE = 'R'，则要求 LWORK >= max(1,M)
    #       如果 N = 0 或者 M = 0，则要求 LWORK >= 1
    #       为了获得最佳性能，通常要求 LWORK >= max(1,N*NB) 或 LWORK >= max(1,M*NB)，其中 NB 是最优的块大小（如果 M = 0 或 N = 0，则 NB = 0）
    #       当 LWORK = -1 时，用于进行工作空间查询；函数计算出最优的 WORK 数组大小，将其作为 WORK 数组的第一个元素返回，同时不会因 LWORK 引发错误信息
    LWORK   (input) INTEGER
    
    # 输出参数 INFO
    # 指示：函数调用的返回状态
    #       INFO = 0 表示成功退出
    #       INFO < 0 表示第 -INFO 个参数存在非法值
    INFO    (output) INTEGER
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;  // 调整数组 a 的起始地址，使其符合 FORTRAN 的习惯
    --tau;          // 将数组 tau 的索引减一，以符合 C 语言中从零开始的索引
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;  // 调整数组 c__ 的起始地址，使其符合 FORTRAN 的习惯
    --work;          // 将数组 work 的索引减一，以符合 C 语言中从零开始的索引

    /* Function Body */
    *info = 0;  // 将指针 info 所指的内存位置置为零，用于存储函数执行状态信息
    applyq = lsame_(vect, "Q");  // 判断字符串 vect 是否为 "Q"，返回逻辑值给 applyq
    left = lsame_(side, "L");    // 判断字符串 side 是否为 "L"，返回逻辑值给 left
    notran = lsame_(trans, "N");  // 判断字符串 trans 是否为 "N"，返回逻辑值给 notran
    lquery = *lwork == -1;       // 判断指针 lwork 所指的内存位置是否为 -1，返回逻辑值给 lquery

    /* NQ is the order of Q or P and NW is the minimum dimension of WORK */
    // 计算 NQ 和 NW 的值，用于后续计算
    if (left) {
        nq = *m;  // 如果 side 为 "L"，则 NQ = *m
        nw = *n;  // 如果 side 为 "L"，则 NW = *n
    } else {
        nq = *n;  // 如果 side 不为 "L"，则 NQ = *n
        nw = *m;  // 如果 side 不为 "L"，则 NW = *m
    }
    if (*m == 0 || *n == 0) {
        nw = 0;  // 如果 *m 或 *n 为零，则 NW = 0
    }
    if (! applyq && ! lsame_(vect, "P")) {
        *info = -1;  // 如果 applyq 为假且 vect 不为 "P"，则将 *info 设为 -1
    } else if (! left && ! lsame_(side, "R")) {
        *info = -2;  // 如果 left 为假且 side 不为 "R"，则将 *info 设为 -2
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -3;  // 如果 notran 为假且 trans 不为 "C"，则将 *info 设为 -3
    } else if (*m < 0) {
        *info = -4;  // 如果 *m 小于零，则将 *info 设为 -4
    } else if (*n < 0) {
        *info = -5;  // 如果 *n 小于零，则将 *info 设为 -5
    } else if (*k < 0) {
        *info = -6;  // 如果 *k 小于零，则将 *info 设为 -6
    } else /* if(complicated condition) */ {
        /* Computing MAX */
        i__1 = 1, i__2 = min(nq,*k);  // 计算两个值的最大值，用于后续判断
        if (applyq && *lda < max(1,nq) || ! applyq && *lda < max(i__1,i__2)) {
            *info = -8;  // 如果 lda 小于要求的最小值，则将 *info 设为 -8
        } else if (*ldc < max(1,*m)) {
            *info = -11;  // 如果 ldc 小于要求的最小值，则将 *info 设为 -11
        } else if (*lwork < max(1,nw) && ! lquery) {
            *info = -13;  // 如果 lwork 小于要求的最小值且非查询模式，则将 *info 设为 -13
        }
    }

    if (*info == 0) {
        if (nw > 0) {
            if (applyq) {
                if (left) {
                    /* Writing concatenation */
                    i__3[0] = 1, a__1[0] = side;
                    i__3[1] = 1, a__1[1] = trans;
                    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 字符串拼接操作
                    i__1 = *m - 1;
                    i__2 = *m - 1;
                    nb = ilaenv_(&c__1, "CUNMQR", ch__1, &i__1, n, &i__2, &
                        c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv_ 函数，计算 nb
                } else {
                    /* Writing concatenation */
                    i__3[0] = 1, a__1[0] = side;
                    i__3[1] = 1, a__1[1] = trans;
                    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 字符串拼接操作
                    i__1 = *n - 1;
                    i__2 = *n - 1;
                    nb = ilaenv_(&c__1, "CUNMQR", ch__1, m, &i__1, &i__2, &
                        c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv_ 函数，计算 nb
                }
            } else {
                if (left) {
                    /* Writing concatenation */
                    i__3[0] = 1, a__1[0] = side;
                    i__3[1] = 1, a__1[1] = trans;
                    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 字符串拼接操作
                    i__1 = *m - 1;
                    i__2 = *m - 1;
                    nb = ilaenv_(&c__1, "CUNMLQ", ch__1, &i__1, n, &i__2, &
                        c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv_ 函数，计算 nb
                } else {
                    /* Writing concatenation */
                    i__3[0] = 1, a__1[0] = side;
                    i__3[1] = 1, a__1[1] = trans;
                    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 字符串拼接操作
                    i__1 = *n - 1;
                    i__2 = *n - 1;
                    nb = ilaenv_(&c__1, "CUNMLQ", ch__1, m, &i__1, &i__2, &
                        c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv_ 函数，计算 nb
                }
            }
            /* Computing MAX */
            i__1 = 1, i__2 = nw * nb;
            lwkopt = max(i__1,i__2);  // 计算工作数组的最优长度
        } else {
            lwkopt = 1;  // 如果 nw 为零，则工作数组的长度为 1
        }
        work[1].r = (real) lwkopt, work[1].i = 0.f;  // 设置工作数组的第一个元素的实部为 lwkopt，虚部为 0
    }

    if (*info != 0) {
        i__1 = -(*info);  // 计算 info 的负值
        xerbla_("CUNMBR", &i__1);  // 调用 xerbla_ 函数，报告错误信息
        return 0;  // 返回 0，表示函数执行失败
    }
    } else if (lquery) {
        # 如果条件满足 lquery，则执行以下操作
        return 0;
        # 返回 0，结束当前函数调用
    }
/*     Quick return if possible */

/* 快速返回，如果可能 */

    if (*m == 0 || *n == 0) {
    return 0;
    }

    if (applyq) {

/*        Apply Q */

/* 应用 Q 矩阵 */

    if (nq >= *k) {

/*           Q was determined by a call to CGEBRD with nq >= k */

/* 如果 nq >= k，则 Q 矩阵由 CGEBRD 调用确定 */

        cunmqr_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], lwork, &iinfo);
    } else if (nq > 1) {

/*           Q was determined by a call to CGEBRD with nq < k */

/* 如果 nq > 1 且 nq < k，则 Q 矩阵由 CGEBRD 调用确定 */

        if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
        } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
        }
        i__1 = nq - 1;
        cunmqr_(side, trans, &mi, &ni, &i__1, &a[a_dim1 + 2], lda, &tau[1]
            , &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
    }
    } else {

/*        Apply P */

/* 应用 P 矩阵 */

    if (notran) {
        *(unsigned char *)transt = 'C';
    } else {
        *(unsigned char *)transt = 'N';
    }
    if (nq > *k) {

/*           P was determined by a call to CGEBRD with nq > k */

/* 如果 nq > k，则 P 矩阵由 CGEBRD 调用确定 */

        cunmlq_(side, transt, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], lwork, &iinfo);
    } else if (nq > 1) {

/*           P was determined by a call to CGEBRD with nq <= k */

/* 如果 nq > 1 且 nq <= k，则 P 矩阵由 CGEBRD 调用确定 */

        if (left) {
        mi = *m - 1;
        ni = *n;
        i1 = 2;
        i2 = 1;
        } else {
        mi = *m;
        ni = *n - 1;
        i1 = 1;
        i2 = 2;
        }
        i__1 = nq - 1;
        cunmlq_(side, transt, &mi, &ni, &i__1, &a[(a_dim1 << 1) + 1], lda,
             &tau[1], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &
            iinfo);
    }
    }
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;

/*     End of CUNMBR */

/* CUNMBR 结束 */

} /* cunmbr_ */

/* Subroutine */ int cunmhr_(char *side, char *trans, integer *m, integer *n,
    integer *ilo, integer *ihi, singlecomplex *a, integer *lda, singlecomplex *tau,
    singlecomplex *c__, integer *ldc, singlecomplex *work, integer *lwork, integer *
    info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2;
    char ch__1[2];

    /* Local variables */
    static integer i1, i2, nb, mi, nh, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int cunmqr_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose

/* LAPACK 程序包版本信息及用途说明 */
    =======

    CUNMHR overwrites the general complex M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    where Q is a complex unitary matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    IHI-ILO elementary reflectors, as returned by CGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    ILO     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of CGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.

    A       (input) COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by CGEHRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.

    TAU     (input) COMPLEX array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEHRD.

    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================

    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

参数调整：对输入参数进行调整，将一维数组的偏移量应用到二维数组上，以便正确访问数组中的元素。


    /* Function Body */
    *info = 0;
    nh = *ihi - *ilo;
    left = lsame_(side, "L");
    lquery = *lwork == -1;

函数主体：初始化错误信息为0，计算变量nh的值，判断side是否为"L"，并检查是否为查询模式。


/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
    nq = *m;
    nw = *n;
    } else {
    nq = *n;
    nw = *m;
    }

NQ和NW的定义：根据side的值确定NQ和NW的取值，分别表示Q的阶数和WORK的最小维度。


    if (! left && ! lsame_(side, "R")) {
    *info = -1;
    } else if (! lsame_(trans, "N") && ! lsame_(trans,
        "C")) {
    *info = -2;
    } else if (*m < 0) {
    *info = -3;
    } else if (*n < 0) {
    *info = -4;
    } else if (*ilo < 1 || *ilo > max(1,nq)) {
    *info = -5;
    } else if (*ihi < min(*ilo,nq) || *ihi > nq) {
    *info = -6;
    } else if (*lda < max(1,nq)) {
    *info = -8;
    } else if (*ldc < max(1,*m)) {
    *info = -11;
    } else if (*lwork < max(1,nw) && ! lquery) {
    *info = -13;
    }

参数检查：对输入参数进行检查，设置相应的错误信息。


    if (*info == 0) {
    if (left) {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        nb = ilaenv_(&c__1, "CUNMQR", ch__1, &nh, n, &nh, &c_n1, (ftnlen)
            6, (ftnlen)2);
    } else {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        nb = ilaenv_(&c__1, "CUNMQR", ch__1, m, &nh, &nh, &c_n1, (ftnlen)
            6, (ftnlen)2);
    }
    lwkopt = max(1,nw) * nb;
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

设置工作空间大小：根据side和trans的组合，调用ilaenv_函数确定工作空间的最优大小。


    if (*info != 0) {
    i__2 = -(*info);
    xerbla_("CUNMHR", &i__2);
    return 0;
    } else if (lquery) {
    return 0;
    }

错误处理和查询模式处理：如果有错误信息则调用xerbla_函数处理，如果处于查询模式则直接返回。


/*     Quick return if possible */

    if (*m == 0 || *n == 0 || nh == 0) {
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

快速返回：如果m、n或nh为0，则直接设置工作空间大小为1并返回。


    if (left) {
    mi = nh;
    ni = *n;
    i1 = *ilo + 1;
    i2 = 1;
    } else {
    mi = *m;
    ni = nh;
    i1 = 1;
    i2 = *ilo + 1;
    }

设置mi、ni和i1、i2：根据side的值设置矩阵的维度和起始索引。


    cunmqr_(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &
        tau[*ilo], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);

调用cunmqr_函数：根据参数调用QR分解求解函数。


    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;

/*     End of CUNMHR */

} /* cunmhr_ */

/* Subroutine */ int cunml2_(char *side, char *trans, integer *m, integer *n,
    integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
    integer *ldc, singlecomplex *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
    singlecomplex q__1;

    /* Local variables */
    static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    static singlecomplex aii;
    static logical left;
    static singlecomplex taui;

子程序定义：定义并初始化了一个名为cunml2_的子程序，其中包含了一些局部变量和系统生成的局部变量。
    // 声明外部子程序 clarf_ 的接口，其参数包括字符型指针、整型指针、整型指针、
    // 单精度复数数组、整型指针、单精度复数数组、单精度复数数组、整型指针、
    // 单精度复数数组
    extern /* Subroutine */ int clarf_(char *, integer *, integer *, singlecomplex *
        , integer *, singlecomplex *, singlecomplex *, integer *, singlecomplex *);
    
    // 声明外部子程序 lsame_ 的接口，其参数包括字符型指针和字符型指针
    extern logical lsame_(char *, char *);
    
    // 声明外部子程序 clacgv_ 的接口，其参数包括整型指针、单精度复数数组和整型指针
    extern /* Subroutine */ int clacgv_(integer *, singlecomplex *, integer *);
    
    // 声明外部子程序 xerbla_ 的接口，其参数包括字符型指针和整型指针
    extern /* Subroutine */ int xerbla_(char *, integer *);
    
    // 声明静态逻辑型变量 notran，用于本地文件范围
    static logical notran;
/*
    LAPACK routine (version 3.2)
    LAPACK is a software package provided by Univ. of Tennessee,
    Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.
    November 2006

    Purpose
    =======
    
    CUNML2 overwrites the general complex m-by-n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or
          Q'* C  if SIDE = 'L' and TRANS = 'C', or
          C * Q  if SIDE = 'R' and TRANS = 'N', or
          C * Q' if SIDE = 'R' and TRANS = 'C',

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k)' . . . H(2)' H(1)'

    as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

    Arguments
    =========
    
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q' (Conjugate transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.

    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) COMPLEX array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value

    =====================================================================
    
    Test the input arguments
*/

/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--tau;
c_dim1 = *ldc;
c_offset = 1 + c_dim1;
c__ -= c_offset;
--work;

/* Function Body */
*info = 0;


注释：
    # 调用 lsame_ 函数，比较 side 和 "L" 是否相同，返回结果赋给 left 变量
    left = lsame_(side, "L");
    # 调用 lsame_ 函数，比较 trans 和 "N" 是否相同，返回结果赋给 notran 变量
    notran = lsame_(trans, "N");
/*     NQ is the order of Q */

/*     Determine the order of the matrix Q based on whether 'left' is true or not */
    if (left) {
        nq = *m;
    } else {
        nq = *n;
    }

/*     Check for errors in input parameters */
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,*k)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }

/*     Handle errors: print error message and return */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNML2", &i__1);
        return 0;
    }

/*     Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        return 0;
    }

/*     Determine loop indices and directions based on 'left' and 'notran' */
    if (left && notran || ! left && ! notran) {
        i1 = 1;
        i2 = *k;
        i3 = 1;
    } else {
        i1 = *k;
        i2 = 1;
        i3 = -1;
    }

/*     Initialize indices and loop variables */
    if (left) {
        ni = *n;
        jc = 1;
    } else {
        mi = *m;
        ic = 1;
    }

/*     Main loop over the matrix to apply Householder transformations */
    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
        if (left) {

/*           H(i) or H(i)' is applied to C(i:m,1:n) */

            mi = *m - i__ + 1;
            ic = i__;
        } else {

/*           H(i) or H(i)' is applied to C(1:m,i:n) */

            ni = *n - i__ + 1;
            jc = i__;
        }

/*        Apply Householder transformation H(i) or H(i)' */
        if (notran) {
            r_cnjg(&q__1, &tau[i__]);
            taui.r = q__1.r, taui.i = q__1.i;
        } else {
            i__3 = i__;
            taui.r = tau[i__3].r, taui.i = tau[i__3].i;
        }
        if (i__ < nq) {
            i__3 = nq - i__;
            clacgv_(&i__3, &a[i__ + (i__ + 1) * a_dim1], lda);
        }
        i__3 = i__ + i__ * a_dim1;
        aii.r = a[i__3].r, aii.i = a[i__3].i;
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = 1.f, a[i__3].i = 0.f;
        clarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], lda, &taui, &c__[ic +
            jc * c_dim1], ldc, &work[1]);
        i__3 = i__ + i__ * a_dim1;
        a[i__3].r = aii.r, a[i__3].i = aii.i;
        if (i__ < nq) {
            i__3 = nq - i__;
            clacgv_(&i__3, &a[i__ + (i__ + 1) * a_dim1], lda);
        }
    }

/*     End of CUNML2 */

    return 0;

} /* cunml2_ */

/* Subroutine */ int cunmlq_(char *side, char *trans, integer *m, integer *n,
    integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
    integer *ldc, singlecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static singlecomplex t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    ! 外部函数声明，用于调用 LAPACK 程序库中的 cunml2、clarfb、clarft、xerbla 和 ilaenv 函数
    extern /* Subroutine */ int cunml2_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *), clarfb_(char *, char *,
        char *, char *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarft_(char *, char *
        , integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *), xerbla_(char *, integer *);
    
    ! 外部函数声明，用于调用 LAPACK 程序库中的 ilaenv 函数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    
    ! 静态变量声明
    static logical notran;   ! 逻辑类型变量，用于指示是否进行转置操作
    static integer ldwork;   ! 整数类型变量，用于存储工作数组的维度
    static char transt[1];   ! 字符数组，用于存储转置操作的标志
    static integer lwkopt;   ! 整数类型变量，用于存储最优工作数组大小
    static logical lquery;   ! 逻辑类型变量，用于指示是否查询最优工作数组大小
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CUNMLQ overwrites the general complex M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k)' . . . H(2)' H(1)'

    as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGELQF.

    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/

/*
    The following code block contains the definition and description of the LAPACK routine CUNMLQ.
    CUNMLQ is used to apply a complex unitary matrix Q or its conjugate transpose Q**H to a general matrix C.
    Depending on the values of SIDE (apply from Left or Right) and TRANS (No transpose or Conjugate transpose),
    CUNMLQ modifies the matrix C accordingly using the elementary reflectors stored in A and the scalar factors
    in TAU, both provided by the user after a prior CGELQF decomposition.

    The routine uses workspace in the array WORK to compute its result. The size of this workspace is returned in WORK(1)
    if INFO = 0 upon successful completion of CUNMLQ.

    Please refer to LAPACK documentation for detailed information on the parameters and their constraints.
*/
    LWORK   (input) INTEGER
            WORK 数组的维度。
            如果 SIDE = 'L'，要求 LWORK >= max(1,N);
            如果 SIDE = 'R'，要求 LWORK >= max(1,M)。
            为了最佳性能，如果 SIDE = 'L'，则要求 LWORK >= N*NB，如果 SIDE = 'R'，则要求 LWORK >= M*NB，其中 NB 是最优块大小。

            如果 LWORK = -1，那么假定为工作空间查询；程序仅计算 WORK 数组的最佳大小，并将此值作为 WORK 数组的第一个条目返回，XERBLA 不会因 LWORK 相关的错误而发出错误消息。

    INFO    (output) INTEGER
            = 0:  成功退出
            < 0:  如果 INFO = -i，表示第 i 个参数的值非法

    =====================================================================


       测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,*k)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        /* Determine the block size. NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "CUNMLQ", ch__1, m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNMLQ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "CUNMLQ", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        cunml2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        if (notran) {
            *(unsigned char *)transt = 'C';
        } else {
            *(unsigned char *)transt = 'N';
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
/* 计算最小值 */
        i__4 = nb, i__5 = *k - i__ + 1;
        ib = min(i__4,i__5);

/*
             Form the triangular factor of the block reflector
             H = H(i) H(i+1) . . . H(i+ib-1)
*/
/*
             构造块反射器的上三角因子
             H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__4 = nq - i__ + 1;
        clarft_("Forward", "Rowwise", &i__4, &ib, &a[i__ + i__ * a_dim1],
            lda, &tau[i__], t, &c__65);
        if (left) {

/*              H or H' is applied to C(i:m,1:n) */
/*              H或H'作用于C(i:m,1:n) */

        mi = *m - i__ + 1;
        ic = i__;
        } else {

/*              H or H' is applied to C(1:m,i:n) */
/*              H或H'作用于C(1:m,i:n) */

        ni = *n - i__ + 1;
        jc = i__;
        }

/*           Apply H or H' */
/*           应用H或H' */

        clarfb_(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__
            + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1],
            ldc, &work[1], &ldwork);
/* L10: */
    }
    }
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    return 0;

/*     End of CUNMLQ */

} /* cunmlq_ */

/* Subroutine */ int cunmql_(char *side, char *trans, integer *m, integer *n,
    integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
    integer *ldc, singlecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static singlecomplex t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int cunm2l_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *), clarfb_(char *, char *,
        char *, char *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarft_(char *, char *
        , integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CUNMQL overwrites the general complex M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)


*/
/*
-- LAPACK例程（版本3.2）--
-- LAPACK是由田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司提供的软件包。--
   2006年11月

用途
=======

CUNMQL用k个初等反射器的乘积Q来覆盖一般复数M×N矩阵C

                SIDE = 'L'     SIDE = 'R'
TRANS = 'N':    Q * C          C * Q
TRANS = 'C':    Q**H * C       C * Q**H

其中Q是一个复数酉矩阵，由k个初等反射器定义为乘积

      Q = H(k) . . . H(2) H(1)

*/
    # 测试输入参数的有效性，确保它们符合预期的范围和条件

    # 确定是否从左侧或右侧应用 Q 或 Q**H
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.

    # 确定是否应用 Q 或 Q**H 或它们的转置
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.

    # 矩阵 C 的行数 M
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    # 矩阵 C 的列数 N
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    # 定义矩阵 Q 的基本反射器的数量 K
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    # 存储用于形成基本反射器的矢量的数组 A
    A       (input) COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.

    # 数组 A 的领先维度
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).

    # 存储基本反射器的标量因子的数组 TAU
    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQLF.

    # 输入矩阵 C，输出矩阵 Q*C 或 Q**H*C 或 C*Q**H 或 C*Q
    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    # 数组 C 的领先维度
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    # 工作空间数组，用于存储中间结果和优化信息
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    # 工作空间数组 WORK 的长度
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    # 返回函数执行状态
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;  // a_dim1 是矩阵 A 的第一维度的步长
    a_offset = 1 + a_dim1;  // 计算数组 A 的偏移量
    a -= a_offset;  // 将数组 A 的起始位置调整到正确的位置
    --tau;  // 将数组 tau 的起始位置调整到正确的位置
    c_dim1 = *ldc;  // c_dim1 是矩阵 C 的第一维度的步长
    c_offset = 1 + c_dim1;  // 计算数组 C 的偏移量
    c__ -= c_offset;  // 将数组 C 的起始位置调整到正确的位置
    --work;  // 将数组 work 的起始位置调整到正确的位置

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    left = lsame_(side, "L");  // 判断 side 是否为 "L"，返回布尔值给 left
    notran = lsame_(trans, "N");  // 判断 trans 是否为 "N"，返回布尔值给 notran
    lquery = *lwork == -1;  // 判断 lwork 是否为 -1，返回布尔值给 lquery

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
        nq = *m;  // 如果 side 是 "L"，则 nq 为 m
        nw = max(1,*n);  // nw 是 1 和 n 中的较大值
    } else {
        nq = *n;  // 否则 nq 为 n
        nw = max(1,*m);  // nw 是 1 和 m 中的较大值
    }
    if (! left && ! lsame_(side, "R")) {  // 如果 side 不是 "L" 且不是 "R"
        *info = -1;  // 设置 info 为 -1
    } else if (! notran && ! lsame_(trans, "C")) {  // 如果 trans 不是 "N" 且不是 "C"
        *info = -2;  // 设置 info 为 -2
    } else if (*m < 0) {  // 如果 m 小于 0
        *info = -3;  // 设置 info 为 -3
    } else if (*n < 0) {  // 如果 n 小于 0
        *info = -4;  // 设置 info 为 -4
    } else if (*k < 0 || *k > nq) {  // 如果 k 小于 0 或大于 nq
        *info = -5;  // 设置 info 为 -5
    } else if (*lda < max(1,nq)) {  // 如果 lda 小于 1 和 nq 中的较大值
        *info = -7;  // 设置 info 为 -7
    } else if (*ldc < max(1,*m)) {  // 如果 ldc 小于 1 和 m 中的较大值
        *info = -10;  // 设置 info 为 -10
    }

    if (*info == 0) {  // 如果 info 为 0
        if (*m == 0 || *n == 0) {  // 如果 m 或 n 为 0
            lwkopt = 1;  // 设置 lwkopt 为 1
        } else {

/*
             Determine the block size.  NB may be at most NBMAX, where
             NBMAX is used to define the local array T.

   Computing MIN
   Writing concatenation
*/
            i__3[0] = 1, a__1[0] = side;  // 构造字符串 side 的字符数组
            i__3[1] = 1, a__1[1] = trans;  // 构造字符串 trans 的字符数组
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将两个字符数组连接成一个字符串
            i__1 = 64, i__2 = ilaenv_(&c__1, "CUNMQL", ch__1, m, n, k, &c_n1,
                (ftnlen)6, (ftnlen)2);  // 调用 ilaenv 函数确定 NB 的大小
            nb = min(i__1,i__2);  // 计算 NB 的最小值
            lwkopt = nw * nb;  // 计算工作数组的最优长度
        }
        work[1].r = (real) lwkopt, work[1].i = 0.f;  // 设置 work 数组的第一个元素

        if (*lwork < nw && ! lquery) {  // 如果 lwork 小于 nw 且不是查询模式
            *info = -12;  // 设置 info 为 -12
        }
    }

    if (*info != 0) {  // 如果 info 不为 0
        i__1 = -(*info);  // 计算 info 的负值
        xerbla_("CUNMQL", &i__1);  // 调用 xerbla 函数处理错误信息
        return 0;  // 返回 0
    } else if (lquery) {  // 如果是查询模式
        return 0;  // 返回 0
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {  // 如果 m 或 n 为 0
        return 0;  // 返回 0
    }

    nbmin = 2;  // 设置 nbmin 为 2
    ldwork = nw;  // 设置 ldwork 为 nw
    if (nb > 1 && nb < *k) {  // 如果 nb 大于 1 且小于 k
        iws = nw * nb;  // 计算工作空间的长度
        if (*lwork < iws) {  // 如果 lwork 小于 iws
            nb = *lwork / ldwork;  // 重新计算 nb
/*
   Computing MAX
   Writing concatenation
*/
            i__3[0] = 1, a__1[0] = side;  // 构造字符串 side 的字符数组
            i__3[1] = 1, a__1[1] = trans;  // 构造字符串 trans 的字符数组
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将两个字符数组连接成一个字符串
            i__1 = 2, i__2 = ilaenv_(&c__2, "CUNMQL", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);  // 调用 ilaenv 函数确定 nbmin 的大小
            nbmin = max(i__1,i__2);  // 计算 nbmin 的最大值
        }
    } else {
        iws = nw;  // 设置 iws 为 nw
    }

    if (nb < nbmin || nb >= *k) {

/*        Use unblocked code */

        cunm2l_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);  // 调用 cunm2l 函数进行无块代码运算
    } else {

/*        Use blocked code */

        if (left && notran || ! left && ! notran) {  // 如果是左乘且不转置 或者 不是左乘且不转置
            i1 = 1;  // 设置 i1 为 1
            i2 = *k;  // 设置 i2 为 k
            i3 = nb;  // 设置 i3 为 nb
        } else {  // 否则
            i1 = (*k - 1) / nb * nb + 1;  // 设置 i1 为 (*k - 1) / nb * nb + 1
            i2 = 1;  // 设置 i2 为 1
            i3 = -nb;  // 设置 i3 为 -nb
        }

        if (left) {  // 如果是左乘
            ni = *n;  // 设置 ni 为 n
        } else {  // 否则
            mi = *m;  // 设置 mi 为 m
        }

        i__1 = i2;  // 设置循环的上限
        i__2 = i3;  // 设置循环的步长
        for
/*
             Form the triangular factor of the block reflector
             H = H(i+ib-1) . . . H(i+1) H(i)
*/

        i__4 = nq - *k + i__ + ib - 1;
        // 计算当前块反射器的三角形因子的维数
        clarft_("Backward", "Columnwise", &i__4, &ib, &a[i__ * a_dim1 + 1]
            , lda, &tau[i__], t, &c__65);
        if (left) {

/*              H or H' is applied to C(1:m-k+i+ib-1,1:n) */

        mi = *m - *k + i__ + ib - 1;
        } else {

/*              H or H' is applied to C(1:m,1:n-k+i+ib-1) */

        ni = *n - *k + i__ + ib - 1;
        }

/*           Apply H or H' */

        clarfb_(side, trans, "Backward", "Columnwise", &mi, &ni, &ib, &a[
            i__ * a_dim1 + 1], lda, t, &c__65, &c__[c_offset], ldc, &
            work[1], &ldwork);
/* L10: */
    }
    }
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    // 设置工作数组的大小并返回
    return 0;

/*     End of CUNMQL */

} /* cunmql_ */

/* Subroutine */ int cunmqr_(char *side, char *trans, integer *m, integer *n,
    integer *k, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
    integer *ldc, singlecomplex *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static singlecomplex t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int cunm2r_(char *, char *, integer *, integer *,
        integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
        singlecomplex *, integer *), clarfb_(char *, char *,
        char *, char *, integer *, integer *, integer *, singlecomplex *,
        integer *, singlecomplex *, integer *, singlecomplex *, integer *, singlecomplex *,
        integer *), clarft_(char *, char *
        , integer *, integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *
        , integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    CUNMQR overwrites the general complex M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'C':      Q**H * C       C * Q**H

    where Q is a complex unitary matrix defined as the product of k
    elementary reflectors

          Q = H(1) H(2) . . . H(k)

    as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.
*/
    # 测试输入参数

    # 检查 SIDE 参数是否正确，确定是从左侧还是右侧应用 Q 或 Q**H
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.

    # 检查 TRANS 参数，确定是应用 Q 还是 Q**H
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.

    # 检查 M 参数，确保矩阵 C 的行数非负
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    # 检查 N 参数，确保矩阵 C 的列数非负
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    # 检查 K 参数，确保用于定义 Q 的反射变换的数目在有效范围内
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    # 检查 A 参数，确认包含用于定义 H(i) 反射变换的向量
    A       (input) COMPLEX array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            CGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.

    # 检查 LDA 参数，确保数组 A 的主维度足够大
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).

    # 检查 TAU 参数，确认包含每个 H(i) 反射变换的标量因子
    TAU     (input) COMPLEX array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CGEQRF.

    # 检查 C 参数，输入为 MxN 矩阵，输出可能为 Q*C、Q**H*C、C*Q**H 或 C*Q
    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    # 检查 LDC 参数，确保数组 C 的主维度足够大
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    # 检查 WORK 参数，用作工作空间，最终返回最佳 LWORK 大小
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    # 检查 LWORK 参数，确定工作空间的大小，或者执行工作空间查询
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    # 检查 INFO 参数，返回执行状态
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    # =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }

    /* Check for errors in input parameters */
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "C")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    /* If no errors, proceed with determining the block size */
    if (*info == 0) {

        /* Determine the block size */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "CUNMQR", ch__1, m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

    /* Handle errors */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("CUNMQR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1].r = 1.f, work[1].i = 0.f;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;

    /* Determine if blocked code should be used */
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;

            /* Compute maximum of NB and the minimum dimension for workspace */
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "CUNMQR", ch__1, m, n, k, &c_n1, (
                ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    /* Choose between blocked and unblocked code */
    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        cunm2r_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
            c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && ! notran || ! left && notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        /* Perform blocked computation */
        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Determine current block size */
            ib = min(nb,*k - i__ + 1);
/*
    Form the triangular factor of the block reflector
    H = H(i) H(i+1) . . . H(i+ib-1)
*/

i__4 = nq - i__ + 1;
clarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ *
    a_dim1], lda, &tau[i__], t, &c__65)
    ;
if (left) {

/*  H or H' is applied to C(i:m,1:n) */

mi = *m - i__ + 1;
ic = i__;
} else {

/*  H or H' is applied to C(1:m,i:n) */

ni = *n - i__ + 1;
jc = i__;
}

/*  Apply H or H' */

clarfb_(side, trans, "Forward", "Columnwise", &mi, &ni, &ib, &a[
    i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc *
    c_dim1], ldc, &work[1], &ldwork);
/* L10: */
}
}
work[1].r = (real) lwkopt, work[1].i = 0.f;
return 0;

/*  End of CUNMQR */

} /* cunmqr_ */

/* Subroutine */ int cunmtr_(char *side, char *uplo, char *trans, integer *m,
integer *n, singlecomplex *a, integer *lda, singlecomplex *tau, singlecomplex *c__,
integer *ldc, singlecomplex *work, integer *lwork, integer *info)
{
/* System generated locals */
address a__1[2];
integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2, i__3;
char ch__1[2];

/* Local variables */
static integer i1, i2, nb, mi, ni, nq, nw;
static logical left;
extern logical lsame_(char *, char *);
static integer iinfo;
static logical upper;
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int cunmql_(char *, char *, integer *, integer *,
    integer *, singlecomplex *, integer *, singlecomplex *, singlecomplex *, integer *,
    singlecomplex *, integer *, integer *), cunmqr_(char *,
    char *, integer *, integer *, integer *, singlecomplex *, integer *,
    singlecomplex *, singlecomplex *, integer *, singlecomplex *, integer *, integer *);
static integer lwkopt;
static logical lquery;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
November 2006


Purpose
=======

CUNMTR overwrites the general complex M-by-N matrix C with

                SIDE = 'L'     SIDE = 'R'
TRANS = 'N':    Q * C          C * Q
TRANS = 'C':    Q**H * C       C * Q**H

where Q is a complex unitary matrix of order nq, with nq = m if
SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
nq-1 elementary reflectors, as returned by CHETRD:

if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'L': apply Q or Q**H from the Left;
        = 'R': apply Q or Q**H from the Right;
*/
    ! 定义输入参数 UPLO，指定 A 的上/下三角形的类型
    UPLO    (input) CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from CHETRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from CHETRD.

    ! 定义输入参数 TRANS，指定是否使用转置或共轭转置
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.

    ! 定义输入参数 M，矩阵 C 的行数，必须大于等于 0
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    ! 定义输入参数 N，矩阵 C 的列数，必须大于等于 0
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    ! 定义输入参数 A，复数数组，存储由 CHETRD 返回的初等反射器
    A       (input) COMPLEX array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by CHETRD.

    ! 定义输入参数 LDA，数组 A 的主维度大小
    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.

    ! 定义输入参数 TAU，复数数组，存储由 CHETRD 返回的初等反射器的标量因子
    TAU     (input) COMPLEX array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by CHETRD.

    ! 定义输入输出参数 C，复数数组，存储待更新的矩阵
    C       (input/output) COMPLEX array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

    ! 定义输入参数 LDC，数组 C 的主维度大小，必须大于等于 M
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    ! 定义工作空间参数 WORK，复数数组，用于存储中间计算结果
    WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    ! 定义输入参数 LWORK，工作空间数组 WORK 的大小
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >=M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    ! 定义输出参数 INFO，整数，表示程序执行状态
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    ! 分隔线，用于标记测试输入参数的结束和实际计算的开始
    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

参数调整：对输入参数进行调整，例如矩阵 A 和 C 的维度以及工作数组的偏移。


    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;

函数主体：初始化返回信息为 0，并检查参数 `side` 和 `uplo` 是否为指定的值，同时检查是否需要查询工作空间大小。


/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
    nq = *m;
    nw = *n;
    } else {
    nq = *n;
    nw = *m;
    }

NQ 是 Q 的阶数，NW 是工作数组的最小维度，根据 `side` 参数确定它们的值。


    if (! left && ! lsame_(side, "R")) {
    *info = -1;
    } else if (! upper && ! lsame_(uplo, "L")) {
    *info = -2;
    } else if (! lsame_(trans, "N") && ! lsame_(trans,
        "C")) {
    *info = -3;
    } else if (*m < 0) {
    *info = -4;
    } else if (*n < 0) {
    *info = -5;
    } else if (*lda < max(1,nq)) {
    *info = -7;
    } else if (*ldc < max(1,*m)) {
    *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
    *info = -12;
    }

检查参数是否合法，例如检查 `side`、`uplo` 和 `trans` 是否是指定的字符，以及检查矩阵维度和工作数组大小是否满足要求。


    if (*info == 0) {
    if (upper) {
        if (left) {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        i__2 = *m - 1;
        i__3 = *m - 1;
        nb = ilaenv_(&c__1, "CUNMQL", ch__1, &i__2, n, &i__3, &c_n1, (
            ftnlen)6, (ftnlen)2);
        } else {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        i__2 = *n - 1;
        i__3 = *n - 1;
        nb = ilaenv_(&c__1, "CUNMQL", ch__1, m, &i__2, &i__3, &c_n1, (
            ftnlen)6, (ftnlen)2);
        }
    } else {
        if (left) {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        i__2 = *m - 1;
        i__3 = *m - 1;
        nb = ilaenv_(&c__1, "CUNMQR", ch__1, &i__2, n, &i__3, &c_n1, (
            ftnlen)6, (ftnlen)2);
        } else {
/* Writing concatenation */
        i__1[0] = 1, a__1[0] = side;
        i__1[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
        i__2 = *n - 1;
        i__3 = *n - 1;
        nb = ilaenv_(&c__1, "CUNMQR", ch__1, m, &i__2, &i__3, &c_n1, (
            ftnlen)6, (ftnlen)2);
        }
    }
    lwkopt = max(1,nw) * nb;
    work[1].r = (real) lwkopt, work[1].i = 0.f;
    }

根据 `side` 和 `uplo` 参数选择合适的 LAPACK 函数，并计算所需的工作空间大小。


    if (*info != 0) {
    i__2 = -(*info);
    xerbla_("CUNMTR", &i__2);
    return 0;
    } else if (lquery) {
    return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || nq == 1) {
    work[1].r = 1.f, work[1].i = 0.f;
    return 0;
    }

处理异常情况和快速返回条件。


    if (left) {
    mi = *m - 1;
    ni = *n;
    } else {
    mi = *m;
    ni = *n - 1;
    }

    if (upper) {

/*        Q was determined by a call to CHETRD with UPLO = 'U' */

    i__2 = nq - 1;

根据 `side` 和 `uplo` 参数计算 mi 和 ni 的值，如果 `upper` 为真则进一步说明 Q 是如何通过调用 CHETRD 确定的。
    # 调用cunmql_函数，传入side, trans, mi, ni, i__2, a[(a_dim1 << 1) + 1], lda, tau[1], c__[c_offset], ldc, work[1], lwork, iinfo作为参数
    cunmql_(side, trans, &mi, &ni, &i__2, &a[(a_dim1 << 1) + 1], lda, &tau[1], &c__[c_offset], ldc, &work[1], lwork, &iinfo);
    # 如果条件不满足
    } else {
/*
   Q 是通过调用 CHETRD 函数并指定 UPLO = 'L' 来确定的
*/

if (left) {
    // 如果 left 为真，执行以下赋值操作
    i1 = 2;
    i2 = 1;
} else {
    // 如果 left 为假，执行以下赋值操作
    i1 = 1;
    i2 = 2;
}
// 计算变量 i__2 的值
i__2 = nq - 1;
// 调用 CUNMQR 函数来对矩阵进行乘积运算
cunmqr_(side, trans, &mi, &ni, &i__2, &a[a_dim1 + 2], lda, &tau[1], &
    c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
}
// 设置 work 数组的第一个元素为 lwkopt 的实部值，虚部为 0
work[1].r = (real) lwkopt, work[1].i = 0.f;
// 返回值为 0，标志函数执行成功
return 0;

/*
   CUNMTR 函数结束
*/

} /* cunmtr_ */
```