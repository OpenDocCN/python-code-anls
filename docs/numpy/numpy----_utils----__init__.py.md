# `.\numpy\numpy\_utils\__init__.py`

```py
"""
This is a module for defining private helpers which do not depend on the
rest of NumPy.

Everything in here must be self-contained so that it can be
imported anywhere else without creating circular imports.
If a utility requires the import of NumPy, it probably belongs
in ``numpy._core``.
"""

import functools
import warnings
from ._convertions import asunicode, asbytes


def set_module(module):
    """Private decorator for overriding __module__ on a function or class.

    Example usage::

        @set_module('numpy')
        def example():
            pass

        assert example.__module__ == 'numpy'
    """
    def decorator(func):
        if module is not None:
            func.__module__ = module
        return func
    return decorator


def _rename_parameter(old_names, new_names, dep_version=None):
    """
    Generate decorator for backward-compatible keyword renaming.

    Apply the decorator generated by `_rename_parameter` to functions with a
    renamed parameter to maintain backward-compatibility.

    After decoration, the function behaves as follows:
    If only the new parameter is passed into the function, behave as usual.
    If only the old parameter is passed into the function (as a keyword), raise
    a DeprecationWarning if `dep_version` is provided, and behave as usual
    otherwise.
    If both old and new parameters are passed into the function, raise a
    DeprecationWarning if `dep_version` is provided, and raise the appropriate
    TypeError (function got multiple values for argument).

    Parameters
    ----------
    old_names : list of str
        Old names of parameters
    new_names : list of str
        New names of parameters
    dep_version : str, optional
        Version of NumPy in which old parameter was deprecated in the format
        'X.Y.Z'. If supplied, the deprecation message will indicate that
        support for the old parameter will be removed in version 'X.Y+2.Z'

    Notes
    -----
    Untested with functions that accept *args. Probably won't work as written.

    """
    # 定义装饰器函数，接受一个函数作为参数
    def decorator(fun):
        # 使用 functools 模块的 wraps 装饰器保留原始函数的元数据
        @functools.wraps(fun)
        # 定义装饰后的函数 wrapper，接受任意数量的位置参数和关键字参数
        def wrapper(*args, **kwargs):
            # 遍历 old_names 和 new_names 的元素对
            for old_name, new_name in zip(old_names, new_names):
                # 检查关键字参数 kwargs 中是否存在旧参数名 old_name
                if old_name in kwargs:
                    # 如果指定了 dep_version，处理版本号递增的逻辑
                    if dep_version:
                        # 将 dep_version 拆分为主版本号和次版本号，并将次版本号加 2
                        end_version = dep_version.split('.')
                        end_version[1] = str(int(end_version[1]) + 2)
                        end_version = '.'.join(end_version)
                        # 构建弃用警告消息
                        msg = (f"Use of keyword argument `{old_name}` is "
                               f"deprecated and replaced by `{new_name}`. "
                               f"Support for `{old_name}` will be removed "
                               f"in NumPy {end_version}.")
                        # 发出弃用警告
                        warnings.warn(msg, DeprecationWarning, stacklevel=2)
                    # 检查新参数名 new_name 是否已经存在于 kwargs 中
                    if new_name in kwargs:
                        # 如果存在，抛出类型错误，指示参数重复
                        msg = (f"{fun.__name__}() got multiple values for "
                               f"argument now known as `{new_name}`")
                        raise TypeError(msg)
                    # 将旧参数名对应的值移到新参数名下
                    kwargs[new_name] = kwargs.pop(old_name)
            # 调用原始函数 fun，并传递更新后的参数 kwargs
            return fun(*args, **kwargs)
        # 返回装饰后的函数 wrapper
        return wrapper
```