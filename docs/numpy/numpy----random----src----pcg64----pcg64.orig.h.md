# `.\numpy\numpy\random\src\pcg64\pcg64.orig.h`

```py
/*
 * PCG Random Number Generation for C.
 *
 * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For additional information about the PCG random number generation scheme,
 * including its license and other licensing options, visit
 *
 *     http://www.pcg-random.org
 */

/*
 * This code is derived from the canonical C++ PCG implementation, which
 * has many additional features and is preferable if you can use C++ in
 * your project.
 *
 * Much of the derivation was performed mechanically.  In particular, the
 * output functions were generated by compiling the C++ output functions
 * into LLVM bitcode and then transforming that using the LLVM C backend
 * (from https://github.com/draperlaboratory/llvm-cbe), and then
 * postprocessing and hand editing the output.
 *
 * Much of the remaining code was generated by C-preprocessor metaprogramming.
 */

#ifndef PCG_VARIANTS_H_INCLUDED
#define PCG_VARIANTS_H_INCLUDED 1

#include <inttypes.h>

#if __SIZEOF_INT128__
typedef __uint128_t pcg128_t;
#define PCG_128BIT_CONSTANT(high, low) ((((pcg128_t)high) << 64) + low)
#define PCG_HAS_128BIT_OPS 1
#endif

#if __GNUC_GNU_INLINE__ && !defined(__cplusplus)
#error Nonstandard GNU inlining semantics. Compile with -std=c99 or better.
// We could instead use macros PCG_INLINE and PCG_EXTERN_INLINE
// but better to just reject ancient C code.
#endif

#if __cplusplus
extern "C" {
#endif

/*
 * Rotate helper functions.
 */

// 定义一个内联函数，对一个8位整数进行右旋操作
inline uint8_t pcg_rotr_8(uint8_t value, unsigned int rot) {
/* Unfortunately, clang is kinda pathetic when it comes to properly
 * recognizing idiomatic rotate code, so for clang we actually provide
 * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss.
 */
#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__ || __i386__)
  // 使用内联汇编实现右旋操作，对于clang编译器启用
  asm("rorb   %%cl, %0" : "=r"(value) : "0"(value), "c"(rot));
  return value;
#else
  // 普通实现，对值进行右移和左移来模拟右旋
  return (value >> rot) | (value << ((-rot) & 7));
#endif
}

// 定义一个内联函数，对一个16位整数进行右旋操作
inline uint16_t pcg_rotr_16(uint16_t value, unsigned int rot) {
#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__ || __i386__)
  // 使用内联汇编实现右旋操作，对于clang编译器启用
  asm("rorw   %%cl, %0" : "=r"(value) : "0"(value), "c"(rot));
  return value;
#else
  // 普通实现，对值进行右移和左移来模拟右旋
  return (value >> rot) | (value << ((-rot) & 15));
#endif
}

// 定义一个内联函数，对一个32位整数进行右旋操作
inline uint32_t pcg_rotr_32(uint32_t value, unsigned int rot) {
#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__ || __i386__)
  // 使用内联汇编实现右旋操作，对于clang编译器启用
  asm("rorl   %%cl, %0" : "=r"(value) : "0"(value), "c"(rot));
  return value;
#else
  // 普通实现，对值进行右移和左移来模拟右旋
  return (value >> rot) | (value << ((-rot) & 31));
#endif
}
#if 0 && PCG_USE_INLINE_ASM && __clang__ && __x86_64__
    // 如果条件为真且使用内联汇编，并且是在 clang 编译器和 x86_64 架构下
    // 由于 clang 实际上会自动生成 `rorq` 指令，因此这段代码不需要执行
    asm ("rorq   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
    return value;
#else
  // 如果不满足上述条件，则执行标准的循环右移操作
  return (value >> rot) | (value << ((-rot) & 63));
#endif
}

// 当 PCG 支持 128 位操作时定义的函数
#if PCG_HAS_128BIT_OPS
inline pcg128_t pcg_rotr_128(pcg128_t value, unsigned int rot) {
  // 对于 128 位数值，执行循环右移操作
  return (value >> rot) | (value << ((-rot) & 127));
}
#endif

/*
 * 输出函数。这些函数是 PCG 生成方案的核心。
 */

// XSH RS

inline uint8_t pcg_output_xsh_rs_16_8(uint16_t state) {
  // 16 位状态的 XSH RS 输出函数，使用移位和异或运算
  return (uint8_t)(((state >> 7u) ^ state) >> ((state >> 14u) + 3u));
}

inline uint16_t pcg_output_xsh_rs_32_16(uint32_t state) {
  // 32 位状态的 XSH RS 输出函数，使用移位和异或运算
  return (uint16_t)(((state >> 11u) ^ state) >> ((state >> 30u) + 11u));
}

inline uint32_t pcg_output_xsh_rs_64_32(uint64_t state) {
  // 64 位状态的 XSH RS 输出函数，使用移位和异或运算
  return (uint32_t)(((state >> 22u) ^ state) >> ((state >> 61u) + 22u));
}

#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_output_xsh_rs_128_64(pcg128_t state) {
  // 128 位状态的 XSH RS 输出函数，使用移位和异或运算
  return (uint64_t)(((state >> 43u) ^ state) >> ((state >> 124u) + 45u));
}
#endif

// XSH RR

inline uint8_t pcg_output_xsh_rr_16_8(uint16_t state) {
  // 16 位状态的 XSH RR 输出函数，结合循环右移函数 pcg_rotr_8
  return pcg_rotr_8(((state >> 5u) ^ state) >> 5u, state >> 13u);
}

inline uint16_t pcg_output_xsh_rr_32_16(uint32_t state) {
  // 32 位状态的 XSH RR 输出函数，结合循环右移函数 pcg_rotr_16
  return pcg_rotr_16(((state >> 10u) ^ state) >> 12u, state >> 28u);
}

inline uint32_t pcg_output_xsh_rr_64_32(uint64_t state) {
  // 64 位状态的 XSH RR 输出函数，结合循环右移函数 pcg_rotr_32
  return pcg_rotr_32(((state >> 18u) ^ state) >> 27u, state >> 59u);
}

#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_output_xsh_rr_128_64(pcg128_t state) {
  // 128 位状态的 XSH RR 输出函数，结合循环右移函数 pcg_rotr_64
  return pcg_rotr_64(((state >> 29u) ^ state) >> 58u, state >> 122u);
}
#endif

// RXS M XS

inline uint8_t pcg_output_rxs_m_xs_8_8(uint8_t state) {
  // 8 位状态的 RXS M XS 输出函数，结合移位和异或运算
  uint8_t word = ((state >> ((state >> 6u) + 2u)) ^ state) * 217u;
  return (word >> 6u) ^ word;
}

inline uint16_t pcg_output_rxs_m_xs_16_16(uint16_t state) {
  // 16 位状态的 RXS M XS 输出函数，结合移位和异或运算
  uint16_t word = ((state >> ((state >> 13u) + 3u)) ^ state) * 62169u;
  return (word >> 11u) ^ word;
}

inline uint32_t pcg_output_rxs_m_xs_32_32(uint32_t state) {
  // 32 位状态的 RXS M XS 输出函数，结合移位和异或运算
  uint32_t word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return (word >> 22u) ^ word;
}

inline uint64_t pcg_output_rxs_m_xs_64_64(uint64_t state) {
  // 64 位状态的 RXS M XS 输出函数，结合移位和异或运算
  uint64_t word =
      ((state >> ((state >> 59u) + 5u)) ^ state) * 12605985483714917081ull;
  return (word >> 43u) ^ word;
}

#if PCG_HAS_128BIT_OPS
inline pcg128_t pcg_output_rxs_m_xs_128_128(pcg128_t state) {
  // 128 位状态的 RXS M XS 输出函数，结合移位、异或运算和常量乘法
  pcg128_t word =
      ((state >> ((state >> 122u) + 6u)) ^ state) *
      (PCG_128BIT_CONSTANT(17766728186571221404ULL, 12605985483714917081ULL));
  return (word >> 86u) ^ word;
}
#endif
// 使用 XSL RR 算法从64位状态生成32位输出
inline uint32_t pcg_output_xsl_rr_64_32(uint64_t state) {
  // 将64位状态向右移32位，取低32位并与原始32位状态异或，然后进行指定位数的右旋
  return pcg_rotr_32(((uint32_t)(state >> 32u)) ^ (uint32_t)state,
                     state >> 59u);
}

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 算法从128位状态生成64位输出
inline uint64_t pcg_output_xsl_rr_128_64(pcg128_t state) {
  // 将128位状态向右移64位，取低64位并与原始64位状态异或，然后进行指定位数的右旋
  return pcg_rotr_64(((uint64_t)(state >> 64u)) ^ (uint64_t)state,
                     state >> 122u);
}
#endif

// XSL RR RR 算法（仅定义在 >= 64 bits 的情况下）

inline uint64_t pcg_output_xsl_rr_rr_64_64(uint64_t state) {
  // 将64位状态向右移59位，分别提取高32位和低32位，然后进行异或运算
  uint32_t rot1 = (uint32_t)(state >> 59u);
  uint32_t high = (uint32_t)(state >> 32u);
  uint32_t low = (uint32_t)state;
  uint32_t xored = high ^ low;
  // 对异或结果进行指定位数的右旋
  uint32_t newlow = pcg_rotr_32(xored, rot1);
  // 对高32位进行指定位数的右旋，右旋位数取低32位结果与31的与运算结果
  uint32_t newhigh = pcg_rotr_32(high, newlow & 31u);
  // 合并新的高32位和低32位，形成64位输出
  return (((uint64_t)newhigh) << 32u) | newlow;
}

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR RR 算法从128位状态生成128位输出
inline pcg128_t pcg_output_xsl_rr_rr_128_128(pcg128_t state) {
  // 将128位状态向右移122位，分别提取高64位和低64位，然后进行异或运算
  uint32_t rot1 = (uint32_t)(state >> 122u);
  uint64_t high = (uint64_t)(state >> 64u);
  uint64_t low = (uint64_t)state;
  uint64_t xored = high ^ low;
  // 对异或结果进行指定位数的右旋
  uint64_t newlow = pcg_rotr_64(xored, rot1);
  // 对高64位进行指定位数的右旋，右旋位数取低64位结果与63的与运算结果
  uint64_t newhigh = pcg_rotr_64(high, newlow & 63u);
  // 合并新的高64位和低64位，形成128位输出
  return (((pcg128_t)newhigh) << 64u) | newlow;
}
#endif

// 默认的乘数常量定义
#define PCG_DEFAULT_MULTIPLIER_8 141U
#define PCG_DEFAULT_MULTIPLIER_16 12829U
#define PCG_DEFAULT_MULTIPLIER_32 747796405U
#define PCG_DEFAULT_MULTIPLIER_64 6364136223846793005ULL

// 默认的增量常量定义
#define PCG_DEFAULT_INCREMENT_8 77U
#define PCG_DEFAULT_INCREMENT_16 47989U
#define PCG_DEFAULT_INCREMENT_32 2891336453U
#define PCG_DEFAULT_INCREMENT_64 1442695040888963407ULL

#if PCG_HAS_128BIT_OPS
// 默认的128位乘数常量定义
#define PCG_DEFAULT_MULTIPLIER_128                                             \
  PCG_128BIT_CONSTANT(2549297995355413924ULL, 4865540595714422341ULL)
// 默认的128位增量常量定义
#define PCG_DEFAULT_INCREMENT_128                                              \
  PCG_128BIT_CONSTANT(6364136223846793005ULL, 1442695040888963407ULL)
#endif

  /*
   * 静态初始化常量（如果由于某些奇怪的原因不能调用srandom）。
   */

// 单序列模式的8位状态初始化器
#define PCG_STATE_ONESEQ_8_INITIALIZER                                         \
  { 0xd7U }
// 单序列模式的16位状态初始化器
#define PCG_STATE_ONESEQ_16_INITIALIZER                                        \
  { 0x20dfU }
// 单序列模式的32位状态初始化器
#define PCG_STATE_ONESEQ_32_INITIALIZER                                        \
  { 0x46b56677U }
// 单序列模式的64位状态初始化器
#define PCG_STATE_ONESEQ_64_INITIALIZER                                        \
  { 0x4d595df4d0f33173ULL }
#if PCG_HAS_128BIT_OPS
// 单序列模式的128位状态初始化器
#define PCG_STATE_ONESEQ_128_INITIALIZER                                       \
  { PCG_128BIT_CONSTANT(0xb8dc10e158a92392ULL, 0x98046df007ec0a53ULL) }
#endif

// 独立模式的状态初始化器（与单序列模式相同）
#define PCG_STATE_UNIQUE_8_INITIALIZER PCG_STATE_ONESEQ_8_INITIALIZER
#define PCG_STATE_UNIQUE_16_INITIALIZER PCG_STATE_ONESEQ_16_INITIALIZER
#define PCG_STATE_UNIQUE_32_INITIALIZER PCG_STATE_ONESEQ_32_INITIALIZER
#define PCG_STATE_UNIQUE_64_INITIALIZER PCG_STATE_ONESEQ_64_INITIALIZER
#if PCG_HAS_128BIT_OPS
#define PCG_STATE_UNIQUE_128_INITIALIZER PCG_STATE_ONESEQ_128_INITIALIZER
#endif
/* 定义 PCG 随机数生成器的 MCG 变体的初始状态 */

#define PCG_STATE_MCG_8_INITIALIZER                                            \
  { 0xe5U }  // 8位状态的 MCG 初始值

#define PCG_STATE_MCG_16_INITIALIZER                                           \
  { 0xa5e5U }  // 16位状态的 MCG 初始值

#define PCG_STATE_MCG_32_INITIALIZER                                           \
  { 0xd15ea5e5U }  // 32位状态的 MCG 初始值

#define PCG_STATE_MCG_64_INITIALIZER                                           \
  { 0xcafef00dd15ea5e5ULL }  // 64位状态的 MCG 初始值

#if PCG_HAS_128BIT_OPS
#define PCG_STATE_MCG_128_INITIALIZER                                          \
  { PCG_128BIT_CONSTANT(0x0000000000000000ULL, 0xcafef00dd15ea5e5ULL) }         // 128位状态的 MCG 初始值
#endif

/* 定义 PCG 随机数生成器的 setseq 变体的初始状态 */

#define PCG_STATE_SETSEQ_8_INITIALIZER                                         \
  { 0x9bU, 0xdbU }  // 8位状态的 setseq 初始值

#define PCG_STATE_SETSEQ_16_INITIALIZER                                        \
  { 0xe39bU, 0x5bdbU }  // 16位状态的 setseq 初始值

#define PCG_STATE_SETSEQ_32_INITIALIZER                                        \
  { 0xec02d89bU, 0x94b95bdbU }  // 32位状态的 setseq 初始值

#define PCG_STATE_SETSEQ_64_INITIALIZER                                        \
  { 0x853c49e6748fea9bULL, 0xda3e39cb94b95bdbULL }  // 64位状态的 setseq 初始值

#if PCG_HAS_128BIT_OPS
#define PCG_STATE_SETSEQ_128_INITIALIZER                                       \
  {                                                                            \
    PCG_128BIT_CONSTANT(0x979c9a98d8462005ULL, 0x7d3e9cb6cfe0549bULL),         // 第一个 128位状态的 setseq 初始值
    PCG_128BIT_CONSTANT(0x0000000000000001ULL, 0xda3e39cb94b95bdbULL)          // 第二个 128位状态的 setseq 初始值
  }
#endif

/* 定义结构体表示不同变体的 PCG 随机数生成器状态 */

struct pcg_state_8 {
  uint8_t state;  // 8位状态的 PCG 随机数生成器状态结构体
};

struct pcg_state_16 {
  uint16_t state;  // 16位状态的 PCG 随机数生成器状态结构体
};

struct pcg_state_32 {
  uint32_t state;  // 32位状态的 PCG 随机数生成器状态结构体
};

struct pcg_state_64 {
  uint64_t state;  // 64位状态的 PCG 随机数生成器状态结构体
};

#if PCG_HAS_128BIT_OPS
struct pcg_state_128 {
  pcg128_t state;  // 128位状态的 PCG 随机数生成器状态结构体
};
#endif

/* 定义表示 setseq 变体的 PCG 随机数生成器状态结构体 */

struct pcg_state_setseq_8 {
  uint8_t state;  // 8位状态的 setseq 变体的 PCG 随机数生成器状态结构体
  uint8_t inc;    // 8位状态的 setseq 变体的增量
};

struct pcg_state_setseq_16 {
  uint16_t state;  // 16位状态的 setseq 变体的 PCG 随机数生成器状态结构体
  uint16_t inc;    // 16位状态的 setseq 变体的增量
};

struct pcg_state_setseq_32 {
  uint32_t state;  // 32位状态的 setseq 变体的 PCG 随机数生成器状态结构体
  uint32_t inc;    // 32位状态的 setseq 变体的增量
};

struct pcg_state_setseq_64 {
  uint64_t state;  // 64位状态的 setseq 变体的 PCG 随机数生成器状态结构体
  uint64_t inc;    // 64位状态的 setseq 变体的增量
};

#if PCG_HAS_128BIT_OPS
struct pcg_state_setseq_128 {
  pcg128_t state;  // 128位状态的 setseq 变体的 PCG 随机数生成器状态结构体
  pcg128_t inc;    // 128位状态的 setseq 变体的增量
};
#endif

/* 多步进函数（跳跃前进、跳跃后退）的声明 */

extern uint8_t pcg_advance_lcg_8(uint8_t state, uint8_t delta, uint8_t cur_mult,
                                 uint8_t cur_plus);  // 8位状态的 LCG 跳跃函数声明

extern uint16_t pcg_advance_lcg_16(uint16_t state, uint16_t delta,
                                   uint16_t cur_mult, uint16_t cur_plus);  // 16位状态的 LCG 跳跃函数声明

extern uint32_t pcg_advance_lcg_32(uint32_t state, uint32_t delta,
                                   uint32_t cur_mult, uint32_t cur_plus);  // 32位状态的 LCG 跳跃函数声明

extern uint64_t pcg_advance_lcg_64(uint64_t state, uint64_t delta,
                                   uint64_t cur_mult, uint64_t cur_plus);  // 64位状态的 LCG 跳跃函数声明

#if PCG_HAS_128BIT_OPS
extern pcg128_t pcg_advance_lcg_128(pcg128_t state, pcg128_t delta,
                                    pcg128_t cur_mult, pcg128_t cur_plus);  // 128位状态的 LCG 跳跃函数声明
#endif
/* Functions to advance the underlying LCG, one version for each size and
 * each style.  These functions are considered semi-private.  There is rarely
 * a good reason to call them directly.
 */

// 基于每种大小和风格的底层LCG前进函数集合。这些函数被视为半私有的。通常情况下不直接调用它们。

// 在PCG默认乘数和增量的影响下，以一步前进PCG状态（8位版本）
inline void pcg_oneseq_8_step_r(struct pcg_state_8 *rng) {
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_8 + PCG_DEFAULT_INCREMENT_8;
}

// 在PCG默认乘数和增量的影响下，以指定的8位增量delta前进PCG状态
inline void pcg_oneseq_8_advance_r(struct pcg_state_8 *rng, uint8_t delta) {
  rng->state = pcg_advance_lcg_8(rng->state, delta, PCG_DEFAULT_MULTIPLIER_8,
                                 PCG_DEFAULT_INCREMENT_8);
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（8位版本，MCG风格）
inline void pcg_mcg_8_step_r(struct pcg_state_8 *rng) {
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_8;
}

// 在PCG默认乘数的影响下，以指定的8位增量delta前进PCG状态（8位版本，MCG风格）
inline void pcg_mcg_8_advance_r(struct pcg_state_8 *rng, uint8_t delta) {
  rng->state =
      pcg_advance_lcg_8(rng->state, delta, PCG_DEFAULT_MULTIPLIER_8, 0u);
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（8位版本，唯一值风格）
inline void pcg_unique_8_step_r(struct pcg_state_8 *rng) {
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_8 + (uint8_t)(((intptr_t)rng) | 1u);
}

// 在PCG默认乘数的影响下，以指定的8位增量delta前进PCG状态（8位版本，唯一值风格）
inline void pcg_unique_8_advance_r(struct pcg_state_8 *rng, uint8_t delta) {
  rng->state = pcg_advance_lcg_8(rng->state, delta, PCG_DEFAULT_MULTIPLIER_8,
                                 (uint8_t)(((intptr_t)rng) | 1u));
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（带集合序列的8位版本）
inline void pcg_setseq_8_step_r(struct pcg_state_setseq_8 *rng) {
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_8 + rng->inc;
}

// 在PCG默认乘数的影响下，以指定的8位增量delta前进PCG状态（带集合序列的8位版本）
inline void pcg_setseq_8_advance_r(struct pcg_state_setseq_8 *rng,
                                   uint8_t delta) {
  rng->state =
      pcg_advance_lcg_8(rng->state, delta, PCG_DEFAULT_MULTIPLIER_8, rng->inc);
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（16位版本）
inline void pcg_oneseq_16_step_r(struct pcg_state_16 *rng) {
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_16 + PCG_DEFAULT_INCREMENT_16;
}

// 在PCG默认乘数和增量的影响下，以指定的16位增量delta前进PCG状态（16位版本）
inline void pcg_oneseq_16_advance_r(struct pcg_state_16 *rng, uint16_t delta) {
  rng->state = pcg_advance_lcg_16(rng->state, delta, PCG_DEFAULT_MULTIPLIER_16,
                                  PCG_DEFAULT_INCREMENT_16);
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（16位版本，MCG风格）
inline void pcg_mcg_16_step_r(struct pcg_state_16 *rng) {
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_16;
}

// 在PCG默认乘数的影响下，以指定的16位增量delta前进PCG状态（16位版本，MCG风格）
inline void pcg_mcg_16_advance_r(struct pcg_state_16 *rng, uint16_t delta) {
  rng->state =
      pcg_advance_lcg_16(rng->state, delta, PCG_DEFAULT_MULTIPLIER_16, 0u);
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（16位版本，唯一值风格）
inline void pcg_unique_16_step_r(struct pcg_state_16 *rng) {
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_16 + (uint16_t)(((intptr_t)rng) | 1u);
}

// 在PCG默认乘数的影响下，以指定的16位增量delta前进PCG状态（16位版本，唯一值风格）
inline void pcg_unique_16_advance_r(struct pcg_state_16 *rng, uint16_t delta) {
  rng->state = pcg_advance_lcg_16(rng->state, delta, PCG_DEFAULT_MULTIPLIER_16,
                                  (uint16_t)(((intptr_t)rng) | 1u));
}

// 在PCG默认乘数的影响下，以一步前进PCG状态（带集合序列的16位版本）
inline void pcg_setseq_16_step_r(struct pcg_state_setseq_16 *rng) {
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_16 + rng->inc;
}
// 使用传入的 delta 更新 16-bit 设置序列 RNG 的状态
inline void pcg_setseq_16_advance_r(struct pcg_state_setseq_16 *rng,
                                    uint16_t delta) {
  // 调用 pcg_advance_lcg_16 函数更新 RNG 的状态
  rng->state = pcg_advance_lcg_16(rng->state, delta, PCG_DEFAULT_MULTIPLIER_16,
                                  rng->inc);
}

// 单序列 32-bit RNG 的单步更新函数
inline void pcg_oneseq_32_step_r(struct pcg_state_32 *rng) {
  // 使用默认的乘数和增量更新 RNG 的状态
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_32 + PCG_DEFAULT_INCREMENT_32;
}

// 使用 delta 更新单序列 32-bit RNG 的状态
inline void pcg_oneseq_32_advance_r(struct pcg_state_32 *rng, uint32_t delta) {
  // 调用 pcg_advance_lcg_32 函数根据 delta 更新 RNG 的状态
  rng->state = pcg_advance_lcg_32(rng->state, delta, PCG_DEFAULT_MULTIPLIER_32,
                                  PCG_DEFAULT_INCREMENT_32);
}

// MCG 32-bit RNG 的单步更新函数
inline void pcg_mcg_32_step_r(struct pcg_state_32 *rng) {
  // 使用默认的乘数更新 MCG 32-bit RNG 的状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_32;
}

// 使用 delta 更新 MCG 32-bit RNG 的状态
inline void pcg_mcg_32_advance_r(struct pcg_state_32 *rng, uint32_t delta) {
  // 调用 pcg_advance_lcg_32 函数根据 delta 更新 MCG 32-bit RNG 的状态
  rng->state =
      pcg_advance_lcg_32(rng->state, delta, PCG_DEFAULT_MULTIPLIER_32, 0u);
}

// 唯一性 32-bit RNG 的单步更新函数
inline void pcg_unique_32_step_r(struct pcg_state_32 *rng) {
  // 使用指针值加一作为增量更新唯一性 32-bit RNG 的状态
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_32 + (uint32_t)(((intptr_t)rng) | 1u);
}

// 使用 delta 更新唯一性 32-bit RNG 的状态
inline void pcg_unique_32_advance_r(struct pcg_state_32 *rng, uint32_t delta) {
  // 调用 pcg_advance_lcg_32 函数根据 delta 和指针值加一更新唯一性 32-bit RNG 的状态
  rng->state = pcg_advance_lcg_32(rng->state, delta, PCG_DEFAULT_MULTIPLIER_32,
                                  (uint32_t)(((intptr_t)rng) | 1u));
}

// 设置序列 32-bit RNG 的单步更新函数
inline void pcg_setseq_32_step_r(struct pcg_state_setseq_32 *rng) {
  // 使用增量更新设置序列 32-bit RNG 的状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_32 + rng->inc;
}

// 使用 delta 更新设置序列 32-bit RNG 的状态
inline void pcg_setseq_32_advance_r(struct pcg_state_setseq_32 *rng,
                                    uint32_t delta) {
  // 调用 pcg_advance_lcg_32 函数根据 delta 更新设置序列 32-bit RNG 的状态
  rng->state = pcg_advance_lcg_32(rng->state, delta, PCG_DEFAULT_MULTIPLIER_32,
                                  rng->inc);
}

// 单序列 64-bit RNG 的单步更新函数
inline void pcg_oneseq_64_step_r(struct pcg_state_64 *rng) {
  // 使用默认的乘数和增量更新单序列 64-bit RNG 的状态
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_64 + PCG_DEFAULT_INCREMENT_64;
}

// 使用 delta 更新单序列 64-bit RNG 的状态
inline void pcg_oneseq_64_advance_r(struct pcg_state_64 *rng, uint64_t delta) {
  // 调用 pcg_advance_lcg_64 函数根据 delta 更新单序列 64-bit RNG 的状态
  rng->state = pcg_advance_lcg_64(rng->state, delta, PCG_DEFAULT_MULTIPLIER_64,
                                  PCG_DEFAULT_INCREMENT_64);
}

// MCG 64-bit RNG 的单步更新函数
inline void pcg_mcg_64_step_r(struct pcg_state_64 *rng) {
  // 使用默认的乘数更新 MCG 64-bit RNG 的状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_64;
}

// 使用 delta 更新 MCG 64-bit RNG 的状态
inline void pcg_mcg_64_advance_r(struct pcg_state_64 *rng, uint64_t delta) {
  // 调用 pcg_advance_lcg_64 函数根据 delta 更新 MCG 64-bit RNG 的状态
  rng->state =
      pcg_advance_lcg_64(rng->state, delta, PCG_DEFAULT_MULTIPLIER_64, 0u);
}

// 唯一性 64-bit RNG 的单步更新函数
inline void pcg_unique_64_step_r(struct pcg_state_64 *rng) {
  // 使用指针值加一作为增量更新唯一性 64-bit RNG 的状态
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_64 + (uint64_t)(((intptr_t)rng) | 1u);
}

// 使用 delta 更新唯一性 64-bit RNG 的状态
inline void pcg_unique_64_advance_r(struct pcg_state_64 *rng, uint64_t delta) {
  // 调用 pcg_advance_lcg_64 函数根据 delta 和指针值加一更新唯一性 64-bit RNG 的状态
  rng->state = pcg_advance_lcg_64(rng->state, delta, PCG_DEFAULT_MULTIPLIER_64,
                                  (uint64_t)(((intptr_t)rng) | 1u));
}

// 设置序列 64-bit RNG 的单步更新函数
inline void pcg_setseq_64_step_r(struct pcg_state_setseq_64 *rng) {
  // 使用增量更新设置序列 64-bit RNG 的状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_64 + rng->inc;
}
// 设置序列生成器状态的前进函数，用于64位序列生成器
inline void pcg_setseq_64_advance_r(struct pcg_state_setseq_64 *rng,
                                    uint64_t delta) {
  // 调用底层的线性同余生成器前进函数，更新状态
  rng->state = pcg_advance_lcg_64(rng->state, delta, PCG_DEFAULT_MULTIPLIER_64,
                                  rng->inc);
}

#if PCG_HAS_128BIT_OPS
// 单序列128位操作下的步进函数
inline void pcg_oneseq_128_step_r(struct pcg_state_128 *rng) {
  // 用128位乘法和增量更新状态
  rng->state =
      rng->state * PCG_DEFAULT_MULTIPLIER_128 + PCG_DEFAULT_INCREMENT_128;
}
#endif

#if PCG_HAS_128BIT_OPS
// 单序列128位操作下的前进函数
inline void pcg_oneseq_128_advance_r(struct pcg_state_128 *rng,
                                     pcg128_t delta) {
  // 调用底层的线性同余生成器前进函数，更新状态
  rng->state = pcg_advance_lcg_128(
      rng->state, delta, PCG_DEFAULT_MULTIPLIER_128, PCG_DEFAULT_INCREMENT_128);
}
#endif

#if PCG_HAS_128BIT_OPS
// 混合乘法-余数128位操作下的步进函数
inline void pcg_mcg_128_step_r(struct pcg_state_128 *rng) {
  // 使用混合乘法更新状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128;
}
#endif

#if PCG_HAS_128BIT_OPS
// 混合乘法-余数128位操作下的前进函数
inline void pcg_mcg_128_advance_r(struct pcg_state_128 *rng, pcg128_t delta) {
  // 调用底层的线性同余生成器前进函数，更新状态
  rng->state =
      pcg_advance_lcg_128(rng->state, delta, PCG_DEFAULT_MULTIPLIER_128, 0u);
}
#endif

#if PCG_HAS_128BIT_OPS
// 唯一序列128位操作下的步进函数
inline void pcg_unique_128_step_r(struct pcg_state_128 *rng) {
  // 使用唯一增量更新状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128 +
               (pcg128_t)(((intptr_t)rng) | 1u);
}
#endif

#if PCG_HAS_128BIT_OPS
// 唯一序列128位操作下的前进函数
inline void pcg_unique_128_advance_r(struct pcg_state_128 *rng,
                                     pcg128_t delta) {
  // 调用底层的线性同余生成器前进函数，更新状态
  rng->state =
      pcg_advance_lcg_128(rng->state, delta, PCG_DEFAULT_MULTIPLIER_128,
                          (pcg128_t)(((intptr_t)rng) | 1u));
}
#endif

#if PCG_HAS_128BIT_OPS
// 设置序列生成器128位操作下的步进函数
inline void pcg_setseq_128_step_r(struct pcg_state_setseq_128 *rng) {
  // 使用设置序列增量更新状态
  rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128 + rng->inc;
}
#endif

#if PCG_HAS_128BIT_OPS
// 设置序列生成器128位操作下的前进函数
inline void pcg_setseq_128_advance_r(struct pcg_state_setseq_128 *rng,
                                     pcg128_t delta) {
  // 调用底层的线性同余生成器前进函数，更新状态
  rng->state = pcg_advance_lcg_128(rng->state, delta,
                                   PCG_DEFAULT_MULTIPLIER_128, rng->inc);
}
#endif

/* 用于种子生成随机数状态的函数，每个大小和风格都有一种版本。
 * 不同于步进函数，普通用户可以调用这些函数。
 */

// 单序列8位简单随机数生成器的种子函数
inline void pcg_oneseq_8_srandom_r(struct pcg_state_8 *rng, uint8_t initstate) {
  // 初始化状态为0
  rng->state = 0U;
  // 执行一次步进操作
  pcg_oneseq_8_step_r(rng);
  // 将初始状态加到状态中
  rng->state += initstate;
  // 再执行一次步进操作
  pcg_oneseq_8_step_r(rng);
}

// 混合乘法-余数8位简单随机数生成器的种子函数
inline void pcg_mcg_8_srandom_r(struct pcg_state_8 *rng, uint8_t initstate) {
  // 使用初始状态的低位为1的方式设置状态
  rng->state = initstate | 1u;
}

// 唯一序列8位简单随机数生成器的种子函数
inline void pcg_unique_8_srandom_r(struct pcg_state_8 *rng, uint8_t initstate) {
  // 初始化状态为0
  rng->state = 0U;
  // 执行一次步进操作
  pcg_unique_8_step_r(rng);
  // 将初始状态加到状态中
  rng->state += initstate;
  // 再执行一次步进操作
  pcg_unique_8_step_r(rng);
}

// 设置序列生成器8位简单随机数生成器的种子函数
inline void pcg_setseq_8_srandom_r(struct pcg_state_setseq_8 *rng,
                                   uint8_t initstate, uint8_t initseq) {
  // 初始化状态为0
  rng->state = 0U;
  // 设置增量为初始序列左移1位或运算后加1
  rng->inc = (initseq << 1u) | 1u;
  // 执行一次步进操作
  pcg_setseq_8_step_r(rng);
  // 将初始状态加到状态中
  rng->state += initstate;
  // 再执行一次步进操作
  pcg_setseq_8_step_r(rng);
}
// 初始化一个PCG RNG状态结构体，使用16位状态
inline void pcg_oneseq_16_srandom_r(struct pcg_state_16 *rng,
                                    uint16_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_oneseq_16_step_r(rng);  // 执行一次PCG 16位序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_oneseq_16_step_r(rng);  // 再执行一次PCG 16位序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用16位MCG序列
inline void pcg_mcg_16_srandom_r(struct pcg_state_16 *rng, uint16_t initstate) {
  rng->state = initstate | 1u;  // 将初始状态设为给定初始状态的位或操作结果，保证状态为奇数
}

// 初始化一个PCG RNG状态结构体，使用16位唯一序列
inline void pcg_unique_16_srandom_r(struct pcg_state_16 *rng,
                                    uint16_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_unique_16_step_r(rng);  // 执行一次PCG 16位唯一序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_unique_16_step_r(rng);  // 再执行一次PCG 16位唯一序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用16位集合序列
inline void pcg_setseq_16_srandom_r(struct pcg_state_setseq_16 *rng,
                                    uint16_t initstate, uint16_t initseq) {
  rng->state = 0U;  // 将状态初始化为0
  rng->inc = (initseq << 1u) | 1u;  // 计算增量，使用给定的初始序列左移1位并与1位或操作
  pcg_setseq_16_step_r(rng);  // 执行一次PCG 16位集合序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_setseq_16_step_r(rng);  // 再执行一次PCG 16位集合序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用32位单序列
inline void pcg_oneseq_32_srandom_r(struct pcg_state_32 *rng,
                                    uint32_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_oneseq_32_step_r(rng);  // 执行一次PCG 32位单序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_oneseq_32_step_r(rng);  // 再执行一次PCG 32位单序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用32位MCG序列
inline void pcg_mcg_32_srandom_r(struct pcg_state_32 *rng, uint32_t initstate) {
  rng->state = initstate | 1u;  // 将初始状态设为给定初始状态的位或操作结果，保证状态为奇数
}

// 初始化一个PCG RNG状态结构体，使用32位唯一序列
inline void pcg_unique_32_srandom_r(struct pcg_state_32 *rng,
                                    uint32_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_unique_32_step_r(rng);  // 执行一次PCG 32位唯一序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_unique_32_step_r(rng);  // 再执行一次PCG 32位唯一序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用32位集合序列
inline void pcg_setseq_32_srandom_r(struct pcg_state_setseq_32 *rng,
                                    uint32_t initstate, uint32_t initseq) {
  rng->state = 0U;  // 将状态初始化为0
  rng->inc = (initseq << 1u) | 1u;  // 计算增量，使用给定的初始序列左移1位并与1位或操作
  pcg_setseq_32_step_r(rng);  // 执行一次PCG 32位集合序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_setseq_32_step_r(rng);  // 再执行一次PCG 32位集合序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用64位单序列
inline void pcg_oneseq_64_srandom_r(struct pcg_state_64 *rng,
                                    uint64_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_oneseq_64_step_r(rng);  // 执行一次PCG 64位单序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_oneseq_64_step_r(rng);  // 再执行一次PCG 64位单序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用64位MCG序列
inline void pcg_mcg_64_srandom_r(struct pcg_state_64 *rng, uint64_t initstate) {
  rng->state = initstate | 1u;  // 将初始状态设为给定初始状态的位或操作结果，保证状态为奇数
}

// 初始化一个PCG RNG状态结构体，使用64位唯一序列
inline void pcg_unique_64_srandom_r(struct pcg_state_64 *rng,
                                    uint64_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_unique_64_step_r(rng);  // 执行一次PCG 64位唯一序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_unique_64_step_r(rng);  // 再执行一次PCG 64位唯一序列的步骤函数
}

// 初始化一个PCG RNG状态结构体，使用64位集合序列
inline void pcg_setseq_64_srandom_r(struct pcg_state_setseq_64 *rng,
                                    uint64_t initstate, uint64_t initseq) {
  rng->state = 0U;  // 将状态初始化为0
  rng->inc = (initseq << 1u) | 1u;  // 计算增量，使用给定的初始序列左移1位并与1位或操作
  pcg_setseq_64_step_r(rng);  // 执行一次PCG 64位集合序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_setseq_64_step_r(rng);  // 再执行一次PCG 64位集合序列的步骤函数
}

#if PCG_HAS_128BIT_OPS
// 如果支持128位操作，初始化一个PCG RNG状态结构体，使用128位单序列
inline void pcg_oneseq_128_srandom_r(struct pcg_state_128 *rng,
                                     pcg128_t initstate) {
  rng->state = 0U;  // 将状态初始化为0
  pcg_oneseq_128_step_r(rng);  // 执行一次PCG 128位单序列的步骤函数
  rng->state += initstate;  // 将初始状态加到当前状态上
  pcg_oneseq_128_step_r(rng);  // 再执行一次PCG 128位单序列的步骤函数
}
#endif

#if PCG_HAS_128BIT_OPS
/* 定义函数 pcg_mcg_128_srandom_r，用于初始化 PCG 128位状态 rng 的状态值 */
inline void pcg_mcg_128_srandom_r(struct pcg_state_128 *rng,
                                  pcg128_t initstate) {
  rng->state = initstate | 1u;
}
#endif

#if PCG_HAS_128BIT_OPS
/* 定义函数 pcg_unique_128_srandom_r，用于初始化 PCG 128位状态 rng 的状态值，并保证状态值不为零 */
inline void pcg_unique_128_srandom_r(struct pcg_state_128 *rng,
                                     pcg128_t initstate) {
  rng->state = 0U;
  // 调用 pcg_unique_128_step_r 函数来更新状态值
  pcg_unique_128_step_r(rng);
  // 将初始状态值加到当前状态值上
  rng->state += initstate;
  // 再次调用 pcg_unique_128_step_r 函数来进一步更新状态值
  pcg_unique_128_step_r(rng);
}
#endif

#if PCG_HAS_128BIT_OPS
/* 定义函数 pcg_setseq_128_srandom_r，用于初始化 PCG 128位序列化状态 rng 的状态值和增量值 */
inline void pcg_setseq_128_srandom_r(struct pcg_state_setseq_128 *rng,
                                     pcg128_t initstate, pcg128_t initseq) {
  rng->state = 0U;
  // 计算增量值，左移一位后加 1
  rng->inc = (initseq << 1u) | 1u;
  // 调用 pcg_setseq_128_step_r 函数来更新状态值
  pcg_setseq_128_step_r(rng);
  // 将初始状态值加到当前状态值上
  rng->state += initstate;
  // 再次调用 pcg_setseq_128_step_r 函数来进一步更新状态值
  pcg_setseq_128_step_r(rng);
}
#endif

/* 现在，我们逐个创建每个单独的生成器。我们提供一个 random_r 函数，提供适当类型的完整范围的随机数，以及一个 boundedrand_r 版本，
 * 提供一个受限范围内的随机数。
 *
 * boundedrand_r 的实现说明：
 *
 *     为了避免偏差，我们需要使 RNG 的范围是 bound 的倍数，通过丢弃小于阈值的输出来实现。
 *     让我们考虑一个 32 位的情况... 一个简单的计算阈值的方案是
 *
 *         uint32_t threshold = 0x100000000ull % bound;
 *
 *     但是64位的除法/取模比32位的慢（特别是在32位平台上）。实际上，我们采用
 *
 *         uint32_t threshold = (0x100000000ull-bound) % bound;
 *
 *     因为这个版本将计算相同的模数，但左边的值小于2^32。
 *
 *     （注意，对于良好的 RNG 使用模数是明智的，而像原始 LCG 这样较差的 RNG，使用基于除法的技术更好。）
 *     实验性测试表明，对于减少 RNG 范围来说，除法比取模更可取。它更快，有时甚至在统计上更优。
 */

/* 生成函数 XSH RS 的实现 */

/* 定义函数 pcg_oneseq_16_xsh_rs_8_random_r，返回一个 8 位随机数 */
inline uint8_t pcg_oneseq_16_xsh_rs_8_random_r(struct pcg_state_16 *rng) {
  // 获取旧状态值
  uint16_t oldstate = rng->state;
  // 调用 pcg_oneseq_16_step_r 函数来更新状态值
  pcg_oneseq_16_step_r(rng);
  // 返回应用 XSH RS 输出函数得到的结果
  return pcg_output_xsh_rs_16_8(oldstate);
}

/* 定义函数 pcg_oneseq_16_xsh_rs_8_boundedrand_r，返回一个受限制的 8 位随机数 */
inline uint8_t pcg_oneseq_16_xsh_rs_8_boundedrand_r(struct pcg_state_16 *rng,
                                                    uint8_t bound) {
  // 计算阈值，确保范围是 bound 的倍数
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  for (;;) {
    // 调用 pcg_oneseq_16_xsh_rs_8_random_r 函数获取一个随机数
    uint8_t r = pcg_oneseq_16_xsh_rs_8_random_r(rng);
    // 如果随机数大于等于阈值，则返回对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}

/* 定义函数 pcg_oneseq_32_xsh_rs_16_random_r，返回一个 16 位随机数 */
inline uint16_t pcg_oneseq_32_xsh_rs_16_random_r(struct pcg_state_32 *rng) {
  // 获取旧状态值
  uint32_t oldstate = rng->state;
  // 调用 pcg_oneseq_32_step_r 函数来更新状态值
  pcg_oneseq_32_step_r(rng);
  // 返回应用 XSH RS 输出函数得到的结果
  return pcg_output_xsh_rs_32_16(oldstate);
}

/* 定义函数 pcg_oneseq_32_xsh_rs_16_boundedrand_r，返回一个受限制的 16 位随机数 */
inline uint16_t pcg_oneseq_32_xsh_rs_16_boundedrand_r(struct pcg_state_32 *rng,
                                                      uint16_t bound) {
  // 计算阈值，确保范围是 bound 的倍数
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 调用 pcg_oneseq_32_xsh_rs_16_random_r 函数获取一个随机数
    uint16_t r = pcg_oneseq_32_xsh_rs_16_random_r(rng);
    // 如果随机数大于等于阈值，则返回对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}
    # 如果 r 大于等于阈值 threshold，则执行以下操作
    if (r >= threshold)
      # 返回 r 对 bound 取模的结果
      return r % bound;
  }
}

// 使用 PCG 算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 32 位无符号整数
inline uint32_t pcg_oneseq_64_xsh_rs_32_random_r(struct pcg_state_64 *rng) {
  // 保存旧状态
  uint64_t oldstate = rng->state;
  // 调用 PCG 状态更新函数
  pcg_oneseq_64_step_r(rng);
  // 使用旧状态生成 XSH-RS 32 位输出
  return pcg_output_xsh_rs_64_32(oldstate);
}

// 使用 PCG 算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
inline uint32_t pcg_oneseq_64_xsh_rs_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint32_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint32_t r = pcg_oneseq_64_xsh_rs_32_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128 位操作，则使用 PCG 128 位算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 64 位无符号整数
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_oneseq_128_xsh_rs_64_random_r(struct pcg_state_128 *rng) {
  // 调用 PCG 状态更新函数
  pcg_oneseq_128_step_r(rng);
  // 使用 XSH-RS 128-64 组合输出
  return pcg_output_xsh_rs_128_64(rng->state);
}
#endif

// 如果支持 128 位操作，则使用 PCG 128 位算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_oneseq_128_xsh_rs_64_boundedrand_r(struct pcg_state_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint64_t r = pcg_oneseq_128_xsh_rs_64_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 使用 PCG 算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 8 位无符号整数
inline uint8_t pcg_unique_16_xsh_rs_8_random_r(struct pcg_state_16 *rng) {
  // 保存旧状态
  uint16_t oldstate = rng->state;
  // 调用 PCG 状态更新函数
  pcg_unique_16_step_r(rng);
  // 使用旧状态生成 XSH-RS 16-8 输出
  return pcg_output_xsh_rs_16_8(oldstate);
}

// 使用 PCG 算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
inline uint8_t pcg_unique_16_xsh_rs_8_boundedrand_r(struct pcg_state_16 *rng,
                                                    uint8_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  for (;;) {
    // 生成一个随机数
    uint8_t r = pcg_unique_16_xsh_rs_8_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}

// 使用 PCG 算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 16 位无符号整数
inline uint16_t pcg_unique_32_xsh_rs_16_random_r(struct pcg_state_32 *rng) {
  // 保存旧状态
  uint32_t oldstate = rng->state;
  // 调用 PCG 状态更新函数
  pcg_unique_32_step_r(rng);
  // 使用旧状态生成 XSH-RS 32-16 输出
  return pcg_output_xsh_rs_32_16(oldstate);
}

// 使用 PCG 算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
inline uint16_t pcg_unique_32_xsh_rs_16_boundedrand_r(struct pcg_state_32 *rng,
                                                      uint16_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 生成一个随机数
    uint16_t r = pcg_unique_32_xsh_rs_16_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}

// 使用 PCG 算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 32 位无符号整数
inline uint32_t pcg_unique_64_xsh_rs_32_random_r(struct pcg_state_64 *rng) {
  // 保存旧状态
  uint64_t oldstate = rng->state;
  // 调用 PCG 状态更新函数
  pcg_unique_64_step_r(rng);
  // 使用旧状态生成 XSH-RS 64-32 输出
  return pcg_output_xsh_rs_64_32(oldstate);
}

// 使用 PCG 算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
inline uint32_t pcg_unique_64_xsh_rs_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint32_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint32_t r = pcg_unique_64_xsh_rs_32_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128 位操作，则使用 PCG 128 位算法生成一个随机数，使用 XSH-RS 组合输出，返回一个 64 位无符号整数
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_unique_128_xsh_rs_64_random_r(struct pcg_state_128 *rng) {
  // 调用 PCG 状态更新函数
  pcg_unique_128_step_r(rng);
  // 使用 XSH-RS 128-64 组合输出
  return pcg_output_xsh_rs_128_64(rng->state);
}
#endif

// 如果支持 128 位操作，则使用 PCG 128 位算法生成一个有界随机数，使用 XSH-RS 组合输出，返回小于给定边界的随机数
#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_unique_128_xsh_rs_64_boundedrand_r(struct pcg_state_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，确保生成小于给定边界的随机数
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint64_t r = pcg_unique_128_xsh_rs_64_random_r(rng);
    // 检查是否小于阈值
    if (r >= threshold)
      return r % bound;
  }
}
#endif
    # 使用 RNG 生成一个 64 位的随机数 r
    uint64_t r = pcg_unique_128_xsh_rs_64_random_r(rng);
    # 如果生成的随机数 r 大于等于阈值 threshold，则执行以下操作
    if (r >= threshold)
      # 返回 r 对 bound 取模的结果作为随机数
      return r % bound;
  }
#endif

inline uint8_t
pcg_setseq_16_xsh_rs_8_random_r(struct pcg_state_setseq_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 执行一步状态更新
  pcg_setseq_16_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_16_8(oldstate);
}

inline uint8_t
pcg_setseq_16_xsh_rs_8_boundedrand_r(struct pcg_state_setseq_16 *rng,
                                     uint8_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint8_t r = pcg_setseq_16_xsh_rs_8_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

inline uint16_t
pcg_setseq_32_xsh_rs_16_random_r(struct pcg_state_setseq_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 执行一步状态更新
  pcg_setseq_32_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_32_16(oldstate);
}

inline uint16_t
pcg_setseq_32_xsh_rs_16_boundedrand_r(struct pcg_state_setseq_32 *rng,
                                      uint16_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint16_t r = pcg_setseq_32_xsh_rs_16_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

inline uint32_t
pcg_setseq_64_xsh_rs_32_random_r(struct pcg_state_setseq_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 执行一步状态更新
  pcg_setseq_64_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_64_32(oldstate);
}

inline uint32_t
pcg_setseq_64_xsh_rs_32_boundedrand_r(struct pcg_state_setseq_64 *rng,
                                      uint32_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint32_t threshold = -bound % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint32_t r = pcg_setseq_64_xsh_rs_32_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_setseq_128_xsh_rs_64_random_r(struct pcg_state_setseq_128 *rng) {
  // 执行一步状态更新
  pcg_setseq_128_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_128_64(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_setseq_128_xsh_rs_64_boundedrand_r(struct pcg_state_setseq_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint64_t threshold = -bound % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint64_t r = pcg_setseq_128_xsh_rs_64_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}
#endif

inline uint8_t pcg_mcg_16_xsh_rs_8_random_r(struct pcg_state_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 执行一步状态更新
  pcg_mcg_16_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_16_8(oldstate);
}

inline uint8_t pcg_mcg_16_xsh_rs_8_boundedrand_r(struct pcg_state_16 *rng,
                                                 uint8_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint8_t r = pcg_mcg_16_xsh_rs_8_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

inline uint16_t pcg_mcg_32_xsh_rs_16_random_r(struct pcg_state_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 执行一步状态更新
  pcg_mcg_32_step_r(rng);
  // 返回经过 XSH-RS 输出变换后的随机数
  return pcg_output_xsh_rs_32_16(oldstate);
}

inline uint16_t pcg_mcg_32_xsh_rs_16_boundedrand_r(struct pcg_state_32 *rng,
                                                   uint16_t bound) {
  // 计算阈值，确保生成的随机数在指定的边界内
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  // 无限循环，直到生成满足条件的随机数
  for (;;) {
    // 调用上述函数生成随机数
    uint16_t r = pcg_mcg_32_xsh_rs_16_random_r(rng);
    // 如果生成的随机数大于等于阈值，则返回在指定边界内的随机数
    if (r >= threshold)
      return r % bound;
  }
}
    # 如果 r 大于等于阈值 threshold，则执行以下操作
    if (r >= threshold)
      # 返回 r 除以 bound 的余数
      return r % bound;
  }
/* 定义一个内联函数，生成基于 pcg_state_64 结构的 XSH RS 32 位随机数 */
inline uint32_t pcg_mcg_64_xsh_rs_32_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 使用 pcg_mcg_64_step_r 函数更新状态
  pcg_mcg_64_step_r(rng);
  // 返回旧状态的 XSH RS 64 到 32 位输出
  return pcg_output_xsh_rs_64_32(oldstate);
}

/* 定义一个内联函数，生成基于 pcg_state_64 结构的 XSH RS 32 位有界随机数 */
inline uint32_t pcg_mcg_64_xsh_rs_32_boundedrand_r(struct pcg_state_64 *rng,
                                                   uint32_t bound) {
  // 计算阈值，确保 r 位于 [0, bound) 范围内
  uint32_t threshold = -bound % bound;
  // 无限循环直到返回一个在指定范围内的随机数
  for (;;) {
    // 生成一个 XSH RS 32 位随机数
    uint32_t r = pcg_mcg_64_xsh_rs_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，返回 r 对 bound 取模后的结果
    if (r >= threshold)
      return r % bound;
  }
}

/* 如果支持 128 位运算，则定义一个内联函数，生成基于 pcg_state_128 结构的 XSH RS 64 位随机数 */
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_mcg_128_xsh_rs_64_random_r(struct pcg_state_128 *rng) {
  // 使用 pcg_mcg_128_step_r 函数更新状态
  pcg_mcg_128_step_r(rng);
  // 返回当前状态的 XSH RS 128 到 64 位输出
  return pcg_output_xsh_rs_128_64(rng->state);
}
#endif

/* 如果支持 128 位运算，则定义一个内联函数，生成基于 pcg_state_128 结构的 XSH RS 64 位有界随机数 */
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_mcg_128_xsh_rs_64_boundedrand_r(struct pcg_state_128 *rng,
                                                    uint64_t bound) {
  // 计算阈值，确保 r 位于 [0, bound) 范围内
  uint64_t threshold = -bound % bound;
  // 无限循环直到返回一个在指定范围内的随机数
  for (;;) {
    // 生成一个 XSH RS 64 位随机数
    uint64_t r = pcg_mcg_128_xsh_rs_64_random_r(rng);
    // 如果随机数 r 大于等于阈值，返回 r 对 bound 取模后的结果
    if (r >= threshold)
      return r % bound;
  }
}
#endif

/* 定义一个内联函数，生成基于 pcg_state_16 结构的 XSH RR 8 位随机数 */
inline uint8_t pcg_oneseq_16_xsh_rr_8_random_r(struct pcg_state_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 使用 pcg_oneseq_16_step_r 函数更新状态
  pcg_oneseq_16_step_r(rng);
  // 返回旧状态的 XSH RR 16 到 8 位输出
  return pcg_output_xsh_rr_16_8(oldstate);
}

/* 定义一个内联函数，生成基于 pcg_state_16 结构的 XSH RR 8 位有界随机数 */
inline uint8_t pcg_oneseq_16_xsh_rr_8_boundedrand_r(struct pcg_state_16 *rng,
                                                    uint8_t bound) {
  // 计算阈值，确保 r 位于 [0, bound) 范围内
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  // 无限循环直到返回一个在指定范围内的随机数
  for (;;) {
    // 生成一个 XSH RR 8 位随机数
    uint8_t r = pcg_oneseq_16_xsh_rr_8_random_r(rng);
    // 如果随机数 r 大于等于阈值，返回 r 对 bound 取模后的结果
    if (r >= threshold)
      return r % bound;
  }
}

/* 定义一个内联函数，生成基于 pcg_state_32 结构的 XSH RR 16 位随机数 */
inline uint16_t pcg_oneseq_32_xsh_rr_16_random_r(struct pcg_state_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 使用 pcg_oneseq_32_step_r 函数更新状态
  pcg_oneseq_32_step_r(rng);
  // 返回旧状态的 XSH RR 32 到 16 位输出
  return pcg_output_xsh_rr_32_16(oldstate);
}

/* 定义一个内联函数，生成基于 pcg_state_32 结构的 XSH RR 16 位有界随机数 */
inline uint16_t pcg_oneseq_32_xsh_rr_16_boundedrand_r(struct pcg_state_32 *rng,
                                                      uint16_t bound) {
  // 计算阈值，确保 r 位于 [0, bound) 范围内
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  // 无限循环直到返回一个在指定范围内的随机数
  for (;;) {
    // 生成一个 XSH RR 16 位随机数
    uint16_t r = pcg_oneseq_32_xsh_rr_16_random_r(rng);
    // 如果随机数 r 大于等于阈值，返回 r 对 bound 取模后的结果
    if (r >= threshold)
      return r % bound;
  }
}

/* 定义一个内联函数，生成基于 pcg_state_64 结构的 XSH RR 32 位随机数 */
inline uint32_t pcg_oneseq_64_xsh_rr_32_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 使用 pcg_oneseq_64_step_r 函数更新状态
  pcg_oneseq_64_step_r(rng);
  // 返回旧状态的 XSH RR 64 到 32 位输出
  return pcg_output_xsh_rr_64_32(oldstate);
}

/* 定义一个内联函数，生成基于 pcg_state_64 结构的 XSH RR 32 位有界随机数 */
inline uint32_t pcg_oneseq_64_xsh_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  // 计算阈值，确保 r 位于 [0, bound) 范围内
  uint32_t threshold = -bound % bound;
  // 无限循环直到返回一个在指定范围内的随机数
  for (;;) {
    // 生成一个 XSH RR 32 位随机数
    uint32_t r = pcg_oneseq_64_xsh_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，返回 r 对 bound 取模后的结果
    if (r >= threshold)
      return r % bound;
  }
}

/* 如果支持 128 位运算，则定义一个内联函数，生成基于 pcg_state_128 结构的 XSH RR 64 位随机数 */
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_oneseq_128_xsh_rr_64_random_r(struct pcg_state_128 *rng) {
  // 使用 pcg_oneseq_128_step_r 函数更新状态
  pcg_oneseq_128_step_r(rng);
  // 返回当前状态的 XSH RR 128 到 64 位输出
  return pcg_output_xsh_rr_128_64(rng->state);
}
#endif

/* 如果支持 128 位运算，则定义一个内联函数，生成基于 pcg_state_128 结构的 XSH RR 64 位有界随机数 */
#if PCG_HAS_128BIT_OPS
inline uint64
    // 调用 PCG 伪随机数生成器生成一个 64 位无符号整数 r
    uint64_t r = pcg_oneseq_128_xsh_rr_64_random_r(rng);
    
    // 如果 r 大于等于阈值 threshold，则执行以下操作
    if (r >= threshold)
      // 返回 r 对 bound 取模的结果
      return r % bound;
  }
#endif

// 返回一个8位无符号整数的随机数，使用PCG 16位状态结构体rng
inline uint8_t pcg_unique_16_xsh_rr_8_random_r(struct pcg_state_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 更新状态
  pcg_unique_16_step_r(rng);
  // 返回使用旧状态计算的随机数
  return pcg_output_xsh_rr_16_8(oldstate);
}

// 返回一个8位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG 16位状态结构体rng
inline uint8_t pcg_unique_16_xsh_rr_8_boundedrand_r(struct pcg_state_16 *rng,
                                                    uint8_t bound) {
  // 计算阈值，确保分布均匀
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  for (;;) {
    // 获取一个随机数
    uint8_t r = pcg_unique_16_xsh_rr_8_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}

// 返回一个16位无符号整数的随机数，使用PCG 32位状态结构体rng
inline uint16_t pcg_unique_32_xsh_rr_16_random_r(struct pcg_state_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 更新状态
  pcg_unique_32_step_r(rng);
  // 返回使用旧状态计算的随机数
  return pcg_output_xsh_rr_32_16(oldstate);
}

// 返回一个16位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG 32位状态结构体rng
inline uint16_t pcg_unique_32_xsh_rr_16_boundedrand_r(struct pcg_state_32 *rng,
                                                      uint16_t bound) {
  // 计算阈值，确保分布均匀
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 获取一个随机数
    uint16_t r = pcg_unique_32_xsh_rr_16_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}

// 返回一个32位无符号整数的随机数，使用PCG 64位状态结构体rng
inline uint32_t pcg_unique_64_xsh_rr_32_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 更新状态
  pcg_unique_64_step_r(rng);
  // 返回使用旧状态计算的随机数
  return pcg_output_xsh_rr_64_32(oldstate);
}

// 返回一个32位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG 64位状态结构体rng
inline uint32_t pcg_unique_64_xsh_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  // 计算阈值，确保分布均匀
  uint32_t threshold = -bound % bound;
  for (;;) {
    // 获取一个随机数
    uint32_t r = pcg_unique_64_xsh_rr_32_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
// 返回一个64位无符号整数的随机数，使用PCG 128位状态结构体rng
inline uint64_t pcg_unique_128_xsh_rr_64_random_r(struct pcg_state_128 *rng) {
  // 更新状态
  pcg_unique_128_step_r(rng);
  // 返回使用当前状态计算的随机数
  return pcg_output_xsh_rr_128_64(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 返回一个64位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG 128位状态结构体rng
inline uint64_t
pcg_unique_128_xsh_rr_64_boundedrand_r(struct pcg_state_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，确保分布均匀
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 获取一个随机数
    uint64_t r = pcg_unique_128_xsh_rr_64_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 返回一个8位无符号整数的随机数，使用PCG setseq 16位状态结构体rng
inline uint8_t
pcg_setseq_16_xsh_rr_8_random_r(struct pcg_state_setseq_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 更新状态
  pcg_setseq_16_step_r(rng);
  // 返回使用旧状态计算的随机数
  return pcg_output_xsh_rr_16_8(oldstate);
}

// 返回一个8位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG setseq 16位状态结构体rng
inline uint8_t
pcg_setseq_16_xsh_rr_8_boundedrand_r(struct pcg_state_setseq_16 *rng,
                                     uint8_t bound) {
  // 计算阈值，确保分布均匀
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  for (;;) {
    // 获取一个随机数
    uint8_t r = pcg_setseq_16_xsh_rr_8_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}

// 返回一个16位无符号整数的随机数，使用PCG setseq 32位状态结构体rng
inline uint16_t
pcg_setseq_32_xsh_rr_16_random_r(struct pcg_state_setseq_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 更新状态
  pcg_setseq_32_step_r(rng);
  // 返回使用旧状态计算的随机数
  return pcg_output_xsh_rr_32_16(oldstate);
}

// 返回一个16位无符号整数的有界随机数，范围在0到bound-1之间，使用PCG setseq 32位状态结构体rng
inline uint16_t
pcg_setseq_32_xsh_rr_16_boundedrand_r(struct pcg_state_setseq_32 *rng,
                                      uint16_t bound) {
  // 计算阈值，确保分布均匀
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 获取一个随机数
    uint16_t r = pcg_setseq_32_xsh_rr_16_random_r(rng);
    // 如果随机数在有效范围内，则返回
    if (r >= threshold)
      return r % bound;
  }
}
    # 使用 RNG 生成一个 16 位的随机数 r
    uint16_t r = pcg_setseq_32_xsh_rr_16_random_r(rng);
    # 如果生成的随机数 r 大于等于阈值 threshold，则执行以下操作
    if (r >= threshold)
      # 返回 r 对 bound 取模后的结果
      return r % bound;
  }
// 定义一个内联函数，用于生成基于 PCG 算法的64位状态、XSH-RR输出，范围为32位随机数
inline uint32_t
pcg_setseq_64_xsh_rr_32_random_r(struct pcg_state_setseq_64 *rng) {
  // 保存当前状态以便后续输出旧状态
  uint64_t oldstate = rng->state;
  // 更新 RNG 的状态
  pcg_setseq_64_step_r(rng);
  // 返回 XSH-RR 输出的低32位
  return pcg_output_xsh_rr_64_32(oldstate);
}

// 定义一个内联函数，用于生成基于 PCG 算法的64位状态、XSH-RR输出，范围在0到bound-1之间的随机数
inline uint32_t
pcg_setseq_64_xsh_rr_32_boundedrand_r(struct pcg_state_setseq_64 *rng,
                                      uint32_t bound) {
  // 计算生成随机数的阈值，确保在[0, bound)范围内
  uint32_t threshold = -bound % bound;
  // 无限循环，直到生成满足要求的随机数
  for (;;) {
    // 调用 pcg_setseq_64_xsh_rr_32_random_r 生成随机数
    uint32_t r = pcg_setseq_64_xsh_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回在[0, bound)范围内的余数
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持128位操作，定义一个内联函数，用于生成基于 PCG 算法的128位状态、XSH-RR输出，范围为64位随机数
#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_setseq_128_xsh_rr_64_random_r(struct pcg_state_setseq_128 *rng) {
  // 更新 RNG 的状态
  pcg_setseq_128_step_r(rng);
  // 返回 XSH-RR 输出的64位随机数
  return pcg_output_xsh_rr_128_64(rng->state);
}
#endif

// 如果支持128位操作，定义一个内联函数，用于生成基于 PCG 算法的128位状态、XSH-RR输出，范围在0到bound-1之间的随机数
#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_setseq_128_xsh_rr_64_boundedrand_r(struct pcg_state_setseq_128 *rng,
                                       uint64_t bound) {
  // 计算生成随机数的阈值，确保在[0, bound)范围内
  uint64_t threshold = -bound % bound;
  // 无限循环，直到生成满足要求的随机数
  for (;;) {
    // 调用 pcg_setseq_128_xsh_rr_64_random_r 生成随机数
    uint64_t r = pcg_setseq_128_xsh_rr_64_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回在[0, bound)范围内的余数
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 定义一个内联函数，用于生成基于 PCG 算法的16位状态、XSH-RR输出，范围为8位随机数
inline uint8_t pcg_mcg_16_xsh_rr_8_random_r(struct pcg_state_16 *rng) {
  // 保存当前状态以便后续输出旧状态
  uint16_t oldstate = rng->state;
  // 更新 RNG 的状态
  pcg_mcg_16_step_r(rng);
  // 返回 XSH-RR 输出的低8位
  return pcg_output_xsh_rr_16_8(oldstate);
}

// 定义一个内联函数，用于生成基于 PCG 算法的16位状态、XSH-RR输出，范围在0到bound-1之间的随机数
inline uint8_t pcg_mcg_16_xsh_rr_8_boundedrand_r(struct pcg_state_16 *rng,
                                                 uint8_t bound) {
  // 计算生成随机数的阈值，确保在[0, bound)范围内
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  // 无限循环，直到生成满足要求的随机数
  for (;;) {
    // 调用 pcg_mcg_16_xsh_rr_8_random_r 生成随机数
    uint8_t r = pcg_mcg_16_xsh_rr_8_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回在[0, bound)范围内的余数
    if (r >= threshold)
      return r % bound;
  }
}

// 定义一个内联函数，用于生成基于 PCG 算法的32位状态、XSH-RR输出，范围为16位随机数
inline uint16_t pcg_mcg_32_xsh_rr_16_random_r(struct pcg_state_32 *rng) {
  // 保存当前状态以便后续输出旧状态
  uint32_t oldstate = rng->state;
  // 更新 RNG 的状态
  pcg_mcg_32_step_r(rng);
  // 返回 XSH-RR 输出的低16位
  return pcg_output_xsh_rr_32_16(oldstate);
}

// 定义一个内联函数，用于生成基于 PCG 算法的32位状态、XSH-RR输出，范围在0到bound-1之间的随机数
inline uint16_t pcg_mcg_32_xsh_rr_16_boundedrand_r(struct pcg_state_32 *rng,
                                                   uint16_t bound) {
  // 计算生成随机数的阈值，确保在[0, bound)范围内
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  // 无限循环，直到生成满足要求的随机数
  for (;;) {
    // 调用 pcg_mcg_32_xsh_rr_16_random_r 生成随机数
    uint16_t r = pcg_mcg_32_xsh_rr_16_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回在[0, bound)范围内的余数
    if (r >= threshold)
      return r % bound;
  }
}

// 定义一个内联函数，用于生成基于 PCG 算法的64位状态、XSH-RR输出，范围为32位随机数
inline uint32_t pcg_mcg_64_xsh_rr_32_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态以便后续输出旧状态
  uint64_t oldstate = rng->state;
  // 更新 RNG 的状态
  pcg_mcg_64_step_r(rng);
  // 返回 XSH-RR 输出的低32位
  return pcg_output_xsh_rr_64_32(oldstate);
}

// 定义一个内联函数，用于生成基于 PCG 算法的64位状态、XSH-RR输出，范围在0到bound-1之间的随机数
inline uint32_t pcg_mcg_64_xsh_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                   uint32_t bound) {
  // 计算生成随机数的阈值，确保在[0, bound)范围内
  uint32_t threshold = -bound % bound;
  // 无限循环，直到生成满足要求的随机数
  for (;;) {
    // 调用 pcg_mcg_64_xsh_rr_32_random_r 生成随机数
    uint32_t r = pcg_mcg_64_xsh_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回在[0, bound)范围内的余数
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持128位操作，定义一个内联函数，用于生成基于 PCG 算法的128位状态、XSH-RR输出，范围为64
    # 如果 r 大于等于阈值 threshold，则执行以下语句
    if (r >= threshold)
      # 返回 r 对 bound 取模的结果
      return r % bound;
  }
/* 结束条件的宏定义，用于条件编译 */
}

/* 各种PCG生成函数的实现，使用RXS M XS算法（不包括MCG版本，因为在使用整个状态时没有意义） */

/* 返回一个8位无符号整数的随机数 */
inline uint8_t pcg_oneseq_8_rxs_m_xs_8_random_r(struct pcg_state_8 *rng) {
  /* 保存旧的状态 */
  uint8_t oldstate = rng->state;
  /* 执行一步PCG生成器的状态更新 */
  pcg_oneseq_8_step_r(rng);
  /* 返回基于旧状态的RXS M XS 8位输出 */
  return pcg_output_rxs_m_xs_8_8(oldstate);
}

/* 返回一个8位无符号整数的有界随机数 */
inline uint8_t pcg_oneseq_8_rxs_m_xs_8_boundedrand_r(struct pcg_state_8 *rng,
                                                     uint8_t bound) {
  /* 计算阈值，确保均匀性 */
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  /* 循环直到生成的随机数满足条件 */
  for (;;) {
    /* 获取一个随机数 */
    uint8_t r = pcg_oneseq_8_rxs_m_xs_8_random_r(rng);
    /* 如果随机数大于等于阈值，则返回对bound取模的结果 */
    if (r >= threshold)
      return r % bound;
  }
}

/* 返回一个16位无符号整数的随机数 */
inline uint16_t pcg_oneseq_16_rxs_m_xs_16_random_r(struct pcg_state_16 *rng) {
  /* 保存旧的状态 */
  uint16_t oldstate = rng->state;
  /* 执行一步PCG生成器的状态更新 */
  pcg_oneseq_16_step_r(rng);
  /* 返回基于旧状态的RXS M XS 16位输出 */
  return pcg_output_rxs_m_xs_16_16(oldstate);
}

/* 返回一个16位无符号整数的有界随机数 */
inline uint16_t
pcg_oneseq_16_rxs_m_xs_16_boundedrand_r(struct pcg_state_16 *rng,
                                        uint16_t bound) {
  /* 计算阈值，确保均匀性 */
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  /* 循环直到生成的随机数满足条件 */
  for (;;) {
    /* 获取一个随机数 */
    uint16_t r = pcg_oneseq_16_rxs_m_xs_16_random_r(rng);
    /* 如果随机数大于等于阈值，则返回对bound取模的结果 */
    if (r >= threshold)
      return r % bound;
  }
}

/* 返回一个32位无符号整数的随机数 */
inline uint32_t pcg_oneseq_32_rxs_m_xs_32_random_r(struct pcg_state_32 *rng) {
  /* 保存旧的状态 */
  uint32_t oldstate = rng->state;
  /* 执行一步PCG生成器的状态更新 */
  pcg_oneseq_32_step_r(rng);
  /* 返回基于旧状态的RXS M XS 32位输出 */
  return pcg_output_rxs_m_xs_32_32(oldstate);
}

/* 返回一个32位无符号整数的有界随机数 */
inline uint32_t
pcg_oneseq_32_rxs_m_xs_32_boundedrand_r(struct pcg_state_32 *rng,
                                        uint32_t bound) {
  /* 计算阈值，确保均匀性 */
  uint32_t threshold = -bound % bound;
  /* 循环直到生成的随机数满足条件 */
  for (;;) {
    /* 获取一个随机数 */
    uint32_t r = pcg_oneseq_32_rxs_m_xs_32_random_r(rng);
    /* 如果随机数大于等于阈值，则返回对bound取模的结果 */
    if (r >= threshold)
      return r % bound;
  }
}

/* 返回一个64位无符号整数的随机数 */
inline uint64_t pcg_oneseq_64_rxs_m_xs_64_random_r(struct pcg_state_64 *rng) {
  /* 保存旧的状态 */
  uint64_t oldstate = rng->state;
  /* 执行一步PCG生成器的状态更新 */
  pcg_oneseq_64_step_r(rng);
  /* 返回基于旧状态的RXS M XS 64位输出 */
  return pcg_output_rxs_m_xs_64_64(oldstate);
}

/* 返回一个64位无符号整数的有界随机数 */
inline uint64_t
pcg_oneseq_64_rxs_m_xs_64_boundedrand_r(struct pcg_state_64 *rng,
                                        uint64_t bound) {
  /* 计算阈值，确保均匀性 */
  uint64_t threshold = -bound % bound;
  /* 循环直到生成的随机数满足条件 */
  for (;;) {
    /* 获取一个随机数 */
    uint64_t r = pcg_oneseq_64_rxs_m_xs_64_random_r(rng);
    /* 如果随机数大于等于阈值，则返回对bound取模的结果 */
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
/* 返回一个128位整数的随机数 */
inline pcg128_t
pcg_oneseq_128_rxs_m_xs_128_random_r(struct pcg_state_128 *rng) {
  /* 执行一步PCG生成器的状态更新 */
  pcg_oneseq_128_step_r(rng);
  /* 返回基于状态的RXS M XS 128位输出 */
  return pcg_output_rxs_m_xs_128_128(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
/* 返回一个128位整数的有界随机数 */
inline pcg128_t
pcg_oneseq_128_rxs_m_xs_128_boundedrand_r(struct pcg_state_128 *rng,
                                          pcg128_t bound) {
  /* 计算阈值，确保均匀性 */
  pcg128_t threshold = -bound % bound;
  /* 循环直到生成的随机数满足条件 */
  for (;;) {
    /* 获取一个随机数 */
    pcg128_t r = pcg_oneseq_128_rxs_m_xs_128_random_r(rng);
    /* 如果随机数大于等于阈值，则返回对bound取模的结果 */
    if (r >= threshold)
      return r % bound;
  }
}
#endif

/* 返回一个16位无符号整数的独特随机数 */
inline uint16_t pcg_unique_16_rxs_m_xs_16_random_r(struct pcg_state_16 *rng) {
  /* 保存旧的状态 */
  uint16_t oldstate = rng->state;
  /* 执行一步PCG生成器的状态更新 */
  pcg_unique_16_step_r(rng);
  /* 返回基于旧状态的RXS M XS 16位输出 */
  return pcg_output_rxs_m_xs_16_16(oldstate);
}

/* 返回一个16位无符号整数的有界随机数 */
inline uint16_t
// 生成一个范围内的随机数，使用 PCG 16位状态和 RXS-M-XS 算法
pcg_unique_16_rxs_m_xs_16_boundedrand_r(struct pcg_state_16 *rng,
                                        uint16_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    uint16_t r = pcg_unique_16_rxs_m_xs_16_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 生成一个 32位范围内的随机数，使用 PCG 32位状态和 RXS-M-XS 算法
inline uint32_t pcg_unique_32_rxs_m_xs_32_random_r(struct pcg_state_32 *rng) {
  // 保存当前状态
  uint32_t oldstate = rng->state;
  // 更新状态
  pcg_unique_32_step_r(rng);
  // 返回经过 RXS-M-XS 处理后的输出
  return pcg_output_rxs_m_xs_32_32(oldstate);
}

// 生成一个 32位范围内的随机数，使用 PCG 32位状态和 RXS-M-XS 算法
inline uint32_t
pcg_unique_32_rxs_m_xs_32_boundedrand_r(struct pcg_state_32 *rng,
                                        uint32_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  uint32_t threshold = -bound % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    uint32_t r = pcg_unique_32_rxs_m_xs_32_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 生成一个 64位范围内的随机数，使用 PCG 64位状态和 RXS-M-XS 算法
inline uint64_t pcg_unique_64_rxs_m_xs_64_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 更新状态
  pcg_unique_64_step_r(rng);
  // 返回经过 RXS-M-XS 处理后的输出
  return pcg_output_rxs_m_xs_64_64(oldstate);
}

// 生成一个 64位范围内的随机数，使用 PCG 64位状态和 RXS-M-XS 算法
inline uint64_t
pcg_unique_64_rxs_m_xs_64_boundedrand_r(struct pcg_state_64 *rng,
                                        uint64_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    uint64_t r = pcg_unique_64_rxs_m_xs_64_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128位运算，生成一个 128位范围内的随机数，使用 PCG 128位状态和 RXS-M-XS 算法
#if PCG_HAS_128BIT_OPS
inline pcg128_t
pcg_unique_128_rxs_m_xs_128_random_r(struct pcg_state_128 *rng) {
  // 更新状态
  pcg_unique_128_step_r(rng);
  // 返回经过 RXS-M-XS 处理后的输出
  return pcg_output_rxs_m_xs_128_128(rng->state);
}
#endif

// 如果支持 128位运算，生成一个 128位范围内的随机数，使用 PCG 128位状态和 RXS-M-XS 算法
#if PCG_HAS_128BIT_OPS
inline pcg128_t
pcg_unique_128_rxs_m_xs_128_boundedrand_r(struct pcg_state_128 *rng,
                                          pcg128_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  pcg128_t threshold = -bound % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    pcg128_t r = pcg_unique_128_rxs_m_xs_128_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 生成一个 8位范围内的随机数，使用 PCG SetSeq 8位状态和 RXS-M-XS 算法
inline uint8_t
pcg_setseq_8_rxs_m_xs_8_random_r(struct pcg_state_setseq_8 *rng) {
  // 保存当前状态
  uint8_t oldstate = rng->state;
  // 更新状态
  pcg_setseq_8_step_r(rng);
  // 返回经过 RXS-M-XS 处理后的输出
  return pcg_output_rxs_m_xs_8_8(oldstate);
}

// 生成一个 8位范围内的随机数，使用 PCG SetSeq 8位状态和 RXS-M-XS 算法
inline uint8_t
pcg_setseq_8_rxs_m_xs_8_boundedrand_r(struct pcg_state_setseq_8 *rng,
                                      uint8_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  uint8_t threshold = ((uint8_t)(-bound)) % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    uint8_t r = pcg_setseq_8_rxs_m_xs_8_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 生成一个 16位范围内的随机数，使用 PCG SetSeq 16位状态和 RXS-M-XS 算法
inline uint16_t
pcg_setseq_16_rxs_m_xs_16_random_r(struct pcg_state_setseq_16 *rng) {
  // 保存当前状态
  uint16_t oldstate = rng->state;
  // 更新状态
  pcg_setseq_16_step_r(rng);
  // 返回经过 RXS-M-XS 处理后的输出
  return pcg_output_rxs_m_xs_16_16(oldstate);
}

// 生成一个 16位范围内的随机数，使用 PCG SetSeq 16位状态和 RXS-M-XS 算法
inline uint16_t
pcg_setseq_16_rxs_m_xs_16_boundedrand_r(struct pcg_state_setseq_16 *rng,
                                        uint16_t bound) {
  // 计算阈值，确保 r < threshold 时返回有效结果
  uint16_t threshold = ((uint16_t)(-bound)) % bound;
  for (;;) {
    // 调用随机数生成函数获取下一个随机数
    uint16_t r = pcg_setseq_16_rxs_m_xs_16_random_r(rng);
    // 如果随机数 r 大于等于阈值 threshold，则返回 r 对 bound 取模的结果
    if (r >= threshold)
      return r % bound;
  }
}
/* 返回 PCG 状态的旧状态 */
pcg_setseq_32_rxs_m_xs_32_random_r(struct pcg_state_setseq_32 *rng) {
  uint32_t oldstate = rng->state;  // 获取 RNG 的当前状态
  pcg_setseq_32_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_rxs_m_xs_32_32(oldstate);  // 返回经过处理后的旧状态
}

/* 生成一个介于 0 到 bound-1 之间的随机数 */
inline uint32_t
pcg_setseq_32_rxs_m_xs_32_boundedrand_r(struct pcg_state_setseq_32 *rng,
                                        uint32_t bound) {
  uint32_t threshold = -bound % bound;  // 计算阈值，使得 r 的取值范围均匀
  for (;;) {
    uint32_t r = pcg_setseq_32_rxs_m_xs_32_random_r(rng);  // 生成一个随机数 r
    if (r >= threshold)  // 如果 r 大于等于阈值
      return r % bound;  // 返回 r 对 bound 取模后的值
  }
}

/* 返回 PCG 状态的旧状态 */
inline uint64_t
pcg_setseq_64_rxs_m_xs_64_random_r(struct pcg_state_setseq_64 *rng) {
  uint64_t oldstate = rng->state;  // 获取 RNG 的当前状态
  pcg_setseq_64_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_rxs_m_xs_64_64(oldstate);  // 返回经过处理后的旧状态
}

/* 生成一个介于 0 到 bound-1 之间的随机数 */
inline uint64_t
pcg_setseq_64_rxs_m_xs_64_boundedrand_r(struct pcg_state_setseq_64 *rng,
                                        uint64_t bound) {
  uint64_t threshold = -bound % bound;  // 计算阈值，使得 r 的取值范围均匀
  for (;;) {
    uint64_t r = pcg_setseq_64_rxs_m_xs_64_random_r(rng);  // 生成一个随机数 r
    if (r >= threshold)  // 如果 r 大于等于阈值
      return r % bound;  // 返回 r 对 bound 取模后的值
  }
}

/* 如果支持 128 位运算，则返回 PCG 状态的输出 */
#if PCG_HAS_128BIT_OPS
inline pcg128_t
pcg_setseq_128_rxs_m_xs_128_random_r(struct pcg_state_setseq_128 *rng) {
  pcg_setseq_128_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_rxs_m_xs_128_128(rng->state);  // 返回经过处理后的状态输出
}
#endif

/* 如果支持 128 位运算，则生成一个介于 0 到 bound-1 之间的随机数 */
#if PCG_HAS_128BIT_OPS
inline pcg128_t
pcg_setseq_128_rxs_m_xs_128_boundedrand_r(struct pcg_state_setseq_128 *rng,
                                          pcg128_t bound) {
  pcg128_t threshold = -bound % bound;  // 计算阈值，使得 r 的取值范围均匀
  for (;;) {
    pcg128_t r = pcg_setseq_128_rxs_m_xs_128_random_r(rng);  // 生成一个随机数 r
    if (r >= threshold)  // 如果 r 大于等于阈值
      return r % bound;  // 返回 r 对 bound 取模后的值
  }
}
#endif

/* XSL RR 生成函数（仅针对“大”类型定义） */

/* 返回 PCG 状态的旧状态 */
inline uint32_t pcg_oneseq_64_xsl_rr_32_random_r(struct pcg_state_64 *rng) {
  uint64_t oldstate = rng->state;  // 获取 RNG 的当前状态
  pcg_oneseq_64_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_xsl_rr_64_32(oldstate);  // 返回经过处理后的旧状态
}

/* 生成一个介于 0 到 bound-1 之间的随机数 */
inline uint32_t pcg_oneseq_64_xsl_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  uint32_t threshold = -bound % bound;  // 计算阈值，使得 r 的取值范围均匀
  for (;;) {
    uint32_t r = pcg_oneseq_64_xsl_rr_32_random_r(rng);  // 生成一个随机数 r
    if (r >= threshold)  // 如果 r 大于等于阈值
      return r % bound;  // 返回 r 对 bound 取模后的值
  }
}

/* 如果支持 128 位运算，则返回 PCG 状态的输出 */
#if PCG_HAS_128BIT_OPS
inline uint64_t pcg_oneseq_128_xsl_rr_64_random_r(struct pcg_state_128 *rng) {
  pcg_oneseq_128_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_xsl_rr_128_64(rng->state);  // 返回经过处理后的状态输出
}
#endif

/* 如果支持 128 位运算，则生成一个介于 0 到 bound-1 之间的随机数 */
#if PCG_HAS_128BIT_OPS
inline uint64_t
pcg_oneseq_128_xsl_rr_64_boundedrand_r(struct pcg_state_128 *rng,
                                       uint64_t bound) {
  uint64_t threshold = -bound % bound;  // 计算阈值，使得 r 的取值范围均匀
  for (;;) {
    uint64_t r = pcg_oneseq_128_xsl_rr_64_random_r(rng);  // 生成一个随机数 r
    if (r >= threshold)  // 如果 r 大于等于阈值
      return r % bound;  // 返回 r 对 bound 取模后的值
  }
}
#endif

/* 返回 PCG 状态的旧状态 */
inline uint32_t pcg_unique_64_xsl_rr_32_random_r(struct pcg_state_64 *rng) {
  uint64_t oldstate = rng->state;  // 获取 RNG 的当前状态
  pcg_unique_64_step_r(rng);  // 更新 RNG 的状态
  return pcg_output_xsl_rr_64_32(oldstate);  // 返回经过处理后的旧状态
}
// 使用 XSL RR 32 位有界随机数生成算法从指定的 RNG 状态结构中生成一个随机数
inline uint32_t pcg_unique_64_xsl_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                      uint32_t bound) {
  // 计算阈值，用于限制生成的随机数不超过指定的 bound
  uint32_t threshold = -bound % bound;
  // 无限循环直到生成满足条件的随机数
  for (;;) {
    // 调用 XSL RR 32 位无界随机数生成函数，获取一个随机数
    uint32_t r = pcg_unique_64_xsl_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回 r 对 bound 取余的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128 位操作，则定义下列函数

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位随机数生成算法从指定的 128 位 RNG 状态结构中生成一个随机数
inline uint64_t pcg_unique_128_xsl_rr_64_random_r(struct pcg_state_128 *rng) {
  // 执行 128 位状态结构的单步操作
  pcg_unique_128_step_r(rng);
  // 返回基于 XSL RR 128 -> 64 位输出函数的结果
  return pcg_output_xsl_rr_128_64(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位有界随机数生成算法从指定的 128 位 RNG 状态结构中生成一个随机数
inline uint64_t
pcg_unique_128_xsl_rr_64_boundedrand_r(struct pcg_state_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，用于限制生成的随机数不超过指定的 bound
  uint64_t threshold = -bound % bound;
  // 无限循环直到生成满足条件的随机数
  for (;;) {
    // 调用 XSL RR 64 位无界随机数生成函数，获取一个随机数
    uint64_t r = pcg_unique_128_xsl_rr_64_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回 r 对 bound 取余的结果
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 使用 XSL RR 32 位随机数生成算法从指定的 setseq 64 位 RNG 状态结构中生成一个随机数
inline uint32_t
pcg_setseq_64_xsl_rr_32_random_r(struct pcg_state_setseq_64 *rng) {
  // 保存旧状态
  uint64_t oldstate = rng->state;
  // 执行 setseq 64 位状态结构的单步操作
  pcg_setseq_64_step_r(rng);
  // 返回基于 XSL RR 64 -> 32 位输出函数的结果
  return pcg_output_xsl_rr_64_32(oldstate);
}

// 使用 XSL RR 32 位有界随机数生成算法从指定的 setseq 64 位 RNG 状态结构中生成一个随机数
inline uint32_t
pcg_setseq_64_xsl_rr_32_boundedrand_r(struct pcg_state_setseq_64 *rng,
                                      uint32_t bound) {
  // 计算阈值，用于限制生成的随机数不超过指定的 bound
  uint32_t threshold = -bound % bound;
  // 无限循环直到生成满足条件的随机数
  for (;;) {
    // 调用 XSL RR 32 位无界随机数生成函数，获取一个随机数
    uint32_t r = pcg_setseq_64_xsl_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回 r 对 bound 取余的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128 位操作，则定义下列函数

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位随机数生成算法从指定的 setseq 128 位 RNG 状态结构中生成一个随机数
inline uint64_t
pcg_setseq_128_xsl_rr_64_random_r(struct pcg_state_setseq_128 *rng) {
  // 执行 setseq 128 位状态结构的单步操作
  pcg_setseq_128_step_r(rng);
  // 返回基于 XSL RR 128 -> 64 位输出函数的结果
  return pcg_output_xsl_rr_128_64(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位有界随机数生成算法从指定的 setseq 128 位 RNG 状态结构中生成一个随机数
inline uint64_t
pcg_setseq_128_xsl_rr_64_boundedrand_r(struct pcg_state_setseq_128 *rng,
                                       uint64_t bound) {
  // 计算阈值，用于限制生成的随机数不超过指定的 bound
  uint64_t threshold = -bound % bound;
  // 无限循环直到生成满足条件的随机数
  for (;;) {
    // 调用 XSL RR 64 位无界随机数生成函数，获取一个随机数
    uint64_t r = pcg_setseq_128_xsl_rr_64_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回 r 对 bound 取余的结果
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 使用 XSL RR 32 位随机数生成算法从指定的 RNG 64 位状态结构中生成一个随机数
inline uint32_t pcg_mcg_64_xsl_rr_32_random_r(struct pcg_state_64 *rng) {
  // 保存旧状态
  uint64_t oldstate = rng->state;
  // 执行 64 位 MCG 状态结构的单步操作
  pcg_mcg_64_step_r(rng);
  // 返回基于 XSL RR 64 -> 32 位输出函数的结果
  return pcg_output_xsl_rr_64_32(oldstate);
}

// 使用 XSL RR 32 位有界随机数生成算法从指定的 RNG 64 位状态结构中生成一个随机数
inline uint32_t pcg_mcg_64_xsl_rr_32_boundedrand_r(struct pcg_state_64 *rng,
                                                   uint32_t bound) {
  // 计算阈值，用于限制生成的随机数不超过指定的 bound
  uint32_t threshold = -bound % bound;
  // 无限循环直到生成满足条件的随机数
  for (;;) {
    // 调用 XSL RR 32 位无界随机数生成函数，获取一个随机数
    uint32_t r = pcg_mcg_64_xsl_rr_32_random_r(rng);
    // 如果随机数 r 大于等于阈值，则返回 r 对 bound 取余的结果
    if (r >= threshold)
      return r % bound;
  }
}

// 如果支持 128 位操作，则定义下列函数

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位随机数生成算法从指定的 RNG 128 位状态结构中生成一个随机数
inline uint64_t pcg_mcg_128_xsl_rr_64_random_r(struct pcg_state_128 *rng) {
  // 执行 128 位 MCG 状态结构的单步操作
  pcg_mcg_128_step_r(rng);
  // 返回基于 XSL RR 128 -> 64 位输出函数的结果
  return pcg_output_xsl_rr_128_64(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 XSL RR 64 位有界随机数生成算法从指定的 RNG 128 位状态结构中生成一个随机数
inline uint64_t pcg_mcg_128_xsl_rr_64_boundedrand_r(struct pcg_state_128 *rng,
                                                    uint64_t bound) {
  // 计算阈值
// 使用 PCG 64位单序列随机数生成器生成一个随机数
inline uint64_t pcg_oneseq_64_xsl_rr_rr_64_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 更新随机数生成器状态
  pcg_oneseq_64_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_64_64(oldstate);
}

// 使用 PCG 64位单序列随机数生成器生成一个指定范围内的随机数
inline uint64_t
pcg_oneseq_64_xsl_rr_rr_64_boundedrand_r(struct pcg_state_64 *rng,
                                         uint64_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint64_t r = pcg_oneseq_64_xsl_rr_rr_64_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位单序列随机数生成器生成一个随机数
inline pcg128_t
pcg_oneseq_128_xsl_rr_rr_128_random_r(struct pcg_state_128 *rng) {
  // 更新随机数生成器状态
  pcg_oneseq_128_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_128_128(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位单序列随机数生成器生成一个指定范围内的随机数
inline pcg128_t
pcg_oneseq_128_xsl_rr_rr_128_boundedrand_r(struct pcg_state_128 *rng,
                                           pcg128_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  pcg128_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    pcg128_t r = pcg_oneseq_128_xsl_rr_rr_128_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 使用 PCG 64位唯一序列随机数生成器生成一个随机数
inline uint64_t pcg_unique_64_xsl_rr_rr_64_random_r(struct pcg_state_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 更新随机数生成器状态
  pcg_unique_64_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_64_64(oldstate);
}

// 使用 PCG 64位唯一序列随机数生成器生成一个指定范围内的随机数
inline uint64_t
pcg_unique_64_xsl_rr_rr_64_boundedrand_r(struct pcg_state_64 *rng,
                                         uint64_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint64_t r = pcg_unique_64_xsl_rr_rr_64_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位唯一序列随机数生成器生成一个随机数
inline pcg128_t
pcg_unique_128_xsl_rr_rr_128_random_r(struct pcg_state_128 *rng) {
  // 更新随机数生成器状态
  pcg_unique_128_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_128_128(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位唯一序列随机数生成器生成一个指定范围内的随机数
inline pcg128_t
pcg_unique_128_xsl_rr_rr_128_boundedrand_r(struct pcg_state_128 *rng,
                                           pcg128_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  pcg128_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    pcg128_t r = pcg_unique_128_xsl_rr_rr_128_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}
#endif

// 使用 PCG 64位集序列随机数生成器生成一个随机数
inline uint64_t
pcg_setseq_64_xsl_rr_rr_64_random_r(struct pcg_state_setseq_64 *rng) {
  // 保存当前状态
  uint64_t oldstate = rng->state;
  // 更新随机数生成器状态
  pcg_setseq_64_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_64_64(oldstate);
}

// 使用 PCG 64位集序列随机数生成器生成一个指定范围内的随机数
inline uint64_t
pcg_setseq_64_xsl_rr_rr_64_boundedrand_r(struct pcg_state_setseq_64 *rng,
                                         uint64_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  uint64_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    uint64_t r = pcg_setseq_64_xsl_rr_rr_64_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位集序列随机数生成器生成一个随机数
inline pcg128_t
pcg_setseq_128_xsl_rr_rr_128_random_r(struct pcg_state_setseq_128 *rng) {
  // 更新随机数生成器状态
  pcg_setseq_128_step_r(rng);
  // 返回经过输出变换的随机数
  return pcg_output_xsl_rr_rr_128_128(rng->state);
}
#endif

#if PCG_HAS_128BIT_OPS
// 使用 PCG 128位集序列随机数生成器生成一个指定范围内的随机数
inline pcg128_t
pcg_setseq_128_xsl_rr_rr_128_boundedrand_r(struct pcg_state_setseq_128 *rng,
                                           pcg128_t bound) {
  // 计算阈值，确保生成的随机数在指定的范围内
  pcg128_t threshold = -bound % bound;
  for (;;) {
    // 生成一个随机数
    pcg128_t r = pcg_setseq_128_xsl_rr_rr_128_random_r(rng);
    // 如果随机数在阈值以上，则返回在指定范围内的随机数
    if (r >= threshold)
      return r % bound;
  }
}
#endif
//// Typedefs
// 定义不同的结构体类型别名用于不同的随机数生成器
typedef struct pcg_state_setseq_64 pcg32_random_t;
typedef struct pcg_state_64 pcg32s_random_t;
typedef struct pcg_state_64 pcg32u_random_t;
typedef struct pcg_state_64 pcg32f_random_t;

//// random_r
// 定义不同的随机数生成函数宏，对应于不同的算法
#define pcg32_random_r pcg_setseq_64_xsh_rr_32_random_r
#define pcg32s_random_r pcg_oneseq_64_xsh_rr_32_random_r
#define pcg32u_random_r pcg_unique_64_xsh_rr_32_random_r
#define pcg32f_random_r pcg_mcg_64_xsh_rs_32_random_r

//// boundedrand_r
// 定义不同的有界随机数生成函数宏，对应于不同的算法
#define pcg32_boundedrand_r pcg_setseq_64_xsh_rr_32_boundedrand_r
#define pcg32s_boundedrand_r pcg_oneseq_64_xsh_rr_32_boundedrand_r
#define pcg32u_boundedrand_r pcg_unique_64_xsh_rr_32_boundedrand_r
#define pcg32f_boundedrand_r pcg_mcg_64_xsh_rs_32_boundedrand_r

//// srandom_r
// 定义不同的种子设置函数宏，对应于不同的算法
#define pcg32_srandom_r pcg_setseq_64_srandom_r
#define pcg32s_srandom_r pcg_oneseq_64_srandom_r
#define pcg32u_srandom_r pcg_unique_64_srandom_r
#define pcg32f_srandom_r pcg_mcg_64_srandom_r

//// advance_r
// 定义不同的状态推进函数宏，对应于不同的算法
#define pcg32_advance_r pcg_setseq_64_advance_r
#define pcg32s_advance_r pcg_oneseq_64_advance_r
#define pcg32u_advance_r pcg_unique_64_advance_r
#define pcg32f_advance_r pcg_mcg_64_advance_r

#if PCG_HAS_128BIT_OPS
//// Typedefs
// 如果支持128位操作，定义不同的结构体类型别名用于不同的随机数生成器
typedef struct pcg_state_setseq_128 pcg64_random_t;
typedef struct pcg_state_128 pcg64s_random_t;
typedef struct pcg_state_128 pcg64u_random_t;
typedef struct pcg_state_128 pcg64f_random_t;

//// random_r
// 定义不同的随机数生成函数宏，对应于不同的算法
#define pcg64_random_r pcg_setseq_128_xsl_rr_64_random_r
#define pcg64s_random_r pcg_oneseq_128_xsl_rr_64_random_r
#define pcg64u_random_r pcg_unique_128_xsl_rr_64_random_r
#define pcg64f_random_r pcg_mcg_128_xsl_rr_64_random_r

//// boundedrand_r
// 定义不同的有界随机数生成函数宏，对应于不同的算法
#define pcg64_boundedrand_r pcg_setseq_128_xsl_rr_64_boundedrand_r
#define pcg64s_boundedrand_r pcg_oneseq_128_xsl_rr_64_boundedrand_r
#define pcg64u_boundedrand_r pcg_unique_128_xsl_rr_64_boundedrand_r
#define pcg64f_boundedrand_r pcg_mcg_128_xsl_rr_64_boundedrand_r

//// srandom_r
// 定义不同的种子设置函数宏，对应于不同的算法
#define pcg64_srandom_r pcg_setseq_128_srandom_r
#define pcg64s_srandom_r pcg_oneseq_128_srandom_r
#define pcg64u_srandom_r pcg_unique_128_srandom_r
#define pcg64f_srandom_r pcg_mcg_128_srandom_r

//// advance_r
// 定义不同的状态推进函数宏，对应于不同的算法
#define pcg64_advance_r pcg_setseq_128_advance_r
#define pcg64s_advance_r pcg_oneseq_128_advance_r
#define pcg64u_advance_r pcg_unique_128_advance_r
#define pcg64f_advance_r pcg_mcg_128_advance_r
#endif

//// Typedefs
// 定义不同的结构体类型别名用于不同的随机数生成器
typedef struct pcg_state_8 pcg8si_random_t;
typedef struct pcg_state_16 pcg16si_random_t;
typedef struct pcg_state_32 pcg32si_random_t;
typedef struct pcg_state_64 pcg64si_random_t;

//// random_r
// 定义不同的随机数生成函数宏，对应于不同的算法
#define pcg8si_random_r pcg_oneseq_8_rxs_m_xs_8_random_r
#define pcg16si_random_r pcg_oneseq_16_rxs_m_xs_16_random_r
// 定义宏，将 pcg32si_random_r 映射到 pcg_oneseq_32_rxs_m_xs_32_random_r
#define pcg32si_random_r pcg_oneseq_32_rxs_m_xs_32_random_r
// 定义宏，将 pcg64si_random_r 映射到 pcg_oneseq_64_rxs_m_xs_64_random_r
#define pcg64si_random_r pcg_oneseq_64_rxs_m_xs_64_random_r

//// boundedrand_r
// 定义宏，将 pcg8si_boundedrand_r 映射到 pcg_oneseq_8_rxs_m_xs_8_boundedrand_r
#define pcg8si_boundedrand_r pcg_oneseq_8_rxs_m_xs_8_boundedrand_r
// 定义宏，将 pcg16si_boundedrand_r 映射到 pcg_oneseq_16_rxs_m_xs_16_boundedrand_r
#define pcg16si_boundedrand_r pcg_oneseq_16_rxs_m_xs_16_boundedrand_r
// 定义宏，将 pcg32si_boundedrand_r 映射到 pcg_oneseq_32_rxs_m_xs_32_boundedrand_r
#define pcg32si_boundedrand_r pcg_oneseq_32_rxs_m_xs_32_boundedrand_r
// 定义宏，将 pcg64si_boundedrand_r 映射到 pcg_oneseq_64_rxs_m_xs_64_boundedrand_r
#define pcg64si_boundedrand_r pcg_oneseq_64_rxs_m_xs_64_boundedrand_r

//// srandom_r
// 定义宏，将 pcg8si_srandom_r 映射到 pcg_oneseq_8_srandom_r
#define pcg8si_srandom_r pcg_oneseq_8_srandom_r
// 定义宏，将 pcg16si_srandom_r 映射到 pcg_oneseq_16_srandom_r
#define pcg16si_srandom_r pcg_oneseq_16_srandom_r
// 定义宏，将 pcg32si_srandom_r 映射到 pcg_oneseq_32_srandom_r
#define pcg32si_srandom_r pcg_oneseq_32_srandom_r
// 定义宏，将 pcg64si_srandom_r 映射到 pcg_oneseq_64_srandom_r
#define pcg64si_srandom_r pcg_oneseq_64_srandom_r

//// advance_r
// 定义宏，将 pcg8si_advance_r 映射到 pcg_oneseq_8_advance_r
#define pcg8si_advance_r pcg_oneseq_8_advance_r
// 定义宏，将 pcg16si_advance_r 映射到 pcg_oneseq_16_advance_r
#define pcg16si_advance_r pcg_oneseq_16_advance_r
// 定义宏，将 pcg32si_advance_r 映射到 pcg_oneseq_32_advance_r
#define pcg32si_advance_r pcg_oneseq_32_advance_r
// 定义宏，将 pcg64si_advance_r 映射到 pcg_oneseq_64_advance_r
#define pcg64si_advance_r pcg_oneseq_64_advance_r

#if PCG_HAS_128BIT_OPS
// 如果支持 128 位操作，定义结构体 pcg128si_random_t 为 pcg_state_128，将 pcg128si_random_r 映射到 pcg_oneseq_128_rxs_m_xs_128_random_r
typedef struct pcg_state_128 pcg128si_random_t;
#define pcg128si_random_r pcg_oneseq_128_rxs_m_xs_128_random_r
// 定义宏，将 pcg128si_boundedrand_r 映射到 pcg_oneseq_128_rxs_m_xs_128_boundedrand_r
#define pcg128si_boundedrand_r pcg_oneseq_128_rxs_m_xs_128_boundedrand_r
// 定义宏，将 pcg128si_srandom_r 映射到 pcg_oneseq_128_srandom_r
#define pcg128si_srandom_r pcg_oneseq_128_srandom_r
// 定义宏，将 pcg128si_advance_r 映射到 pcg_oneseq_128_advance_r
#define pcg128si_advance_r pcg_oneseq_128_advance_r
#endif

//// Typedefs
// 定义结构体 pcg8i_random_t 为 pcg_state_setseq_8
typedef struct pcg_state_setseq_8 pcg8i_random_t;
// 定义结构体 pcg16i_random_t 为 pcg_state_setseq_16
typedef struct pcg_state_setseq_16 pcg16i_random_t;
// 定义结构体 pcg32i_random_t 为 pcg_state_setseq_32
typedef struct pcg_state_setseq_32 pcg32i_random_t;
// 定义结构体 pcg64i_random_t 为 pcg_state_setseq_64
typedef struct pcg_state_setseq_64 pcg64i_random_t;

//// random_r
// 定义宏，将 pcg8i_random_r 映射到 pcg_setseq_8_rxs_m_xs_8_random_r
#define pcg8i_random_r pcg_setseq_8_rxs_m_xs_8_random_r
// 定义宏，将 pcg16i_random_r 映射到 pcg_setseq_16_rxs_m_xs_16_random_r
#define pcg16i_random_r pcg_setseq_16_rxs_m_xs_16_random_r
// 定义宏，将 pcg32i_random_r 映射到 pcg_setseq_32_rxs_m_xs_32_random_r
#define pcg32i_random_r pcg_setseq_32_rxs_m_xs_32_random_r
// 定义宏，将 pcg64i_random_r 映射到 pcg_setseq_64_rxs_m_xs_64_random_r
#define pcg64i_random_r pcg_setseq_64_rxs_m_xs_64_random_r

//// boundedrand_r
// 定义宏，将 pcg8i_boundedrand_r 映射到 pcg_setseq_8_rxs_m_xs_8_boundedrand_r
#define pcg8i_boundedrand_r pcg_setseq_8_rxs_m_xs_8_boundedrand_r
// 定义宏，将 pcg16i_boundedrand_r 映射到 pcg_setseq_16_rxs_m_xs_16_boundedrand_r
#define pcg16i_boundedrand_r pcg_setseq_16_rxs_m_xs_16_boundedrand_r
// 定义宏，将 pcg32i_boundedrand_r 映射到 pcg_setseq_32_rxs_m_xs_32_boundedrand_r
#define pcg32i_boundedrand_r pcg_setseq_32_rxs_m_xs_32_boundedrand_r
// 定义宏，将 pcg64i_boundedrand_r 映射到 pcg_setseq_64_rxs_m_xs_64_boundedrand_r
#define pcg64i_boundedrand_r pcg_setseq_64_rxs_m_xs_64_boundedrand_r

//// srandom_r
// 定义宏，将 pcg8i_srandom_r 映射到 pcg_setseq_8_srandom_r
#define pcg8i_srandom_r pcg_setseq_8_srandom_r
// 定义宏，将 pcg16i_srandom_r 映射到 pcg_setseq_16_srandom_r
#define pcg16i_srandom_r pcg_setseq_16_srandom_r
// 定义宏，将 pcg32i_srandom_r 映射到 pcg_setseq_32_srandom_r
#define pcg32i_srandom_r pcg_setseq_32_srandom_r
// 定义宏，将 pcg64i_srandom_r 映射到 pcg_setseq_64_srandom_r
#define pcg64i_srandom_r pcg_setseq_64_srandom_r

//// advance_r
// 定义宏，将 pcg8i_advance_r 映射到 pcg_setseq_8_advance_r
#define pcg8i_advance_r pcg_setseq_8_advance_r
// 定义宏，将 pcg16i_advance_r 映射到 pcg_setseq_16_advance_r
#define pcg16i_advance_r pcg_setseq_16_advance_r
// 定义宏，将 pcg32i_advance_r 映射到 pcg_setseq_32_advance_r
#define pcg32i_advance_r pcg_setseq_32_advance_r
// 定义宏，将 pcg64i_advance_r 映
extern void pcg64_srandom(pcg128_t seed, pcg128_t seq);
extern void pcg64_advance(pcg128_t delta);
#endif

/*
 * Static initialization constants (if you can't call srandom for some
 * bizarre reason).
 */

// 定义 PCG32 系列初始化常量，基于不同的状态初始化宏
#define PCG32_INITIALIZER PCG_STATE_SETSEQ_64_INITIALIZER
#define PCG32U_INITIALIZER PCG_STATE_UNIQUE_64_INITIALIZER
#define PCG32S_INITIALIZER PCG_STATE_ONESEQ_64_INITIALIZER
#define PCG32F_INITIALIZER PCG_STATE_MCG_64_INITIALIZER

#if PCG_HAS_128BIT_OPS
// 如果支持 128 位操作，定义 PCG64 系列初始化常量，基于不同的状态初始化宏
#define PCG64_INITIALIZER PCG_STATE_SETSEQ_128_INITIALIZER
#define PCG64U_INITIALIZER PCG_STATE_UNIQUE_128_INITIALIZER
#define PCG64S_INITIALIZER PCG_STATE_ONESEQ_128_INITIALIZER
#define PCG64F_INITIALIZER PCG_STATE_MCG_128_INITIALIZER
#endif

// 定义 PCG8SI、PCG16SI、PCG32SI、PCG64SI 等初始化常量，基于单序列初始化宏
#define PCG8SI_INITIALIZER PCG_STATE_ONESEQ_8_INITIALIZER
#define PCG16SI_INITIALIZER PCG_STATE_ONESEQ_16_INITIALIZER
#define PCG32SI_INITIALIZER PCG_STATE_ONESEQ_32_INITIALIZER
#define PCG64SI_INITIALIZER PCG_STATE_ONESEQ_64_INITIALIZER
#if PCG_HAS_128BIT_OPS
// 如果支持 128 位操作，定义 PCG128SI 初始化常量，基于单序列初始化宏
#define PCG128SI_INITIALIZER PCG_STATE_ONESEQ_128_INITIALIZER
#endif

// 定义 PCG8I、PCG16I、PCG32I、PCG64I 等初始化常量，基于集合序列初始化宏
#define PCG8I_INITIALIZER PCG_STATE_SETSEQ_8_INITIALIZER
#define PCG16I_INITIALIZER PCG_STATE_SETSEQ_16_INITIALIZER
#define PCG32I_INITIALIZER PCG_STATE_SETSEQ_32_INITIALIZER
#define PCG64I_INITIALIZER PCG_STATE_SETSEQ_64_INITIALIZER
#if PCG_HAS_128BIT_OPS
// 如果支持 128 位操作，定义 PCG128I 初始化常量，基于集合序列初始化宏
#define PCG128I_INITIALIZER PCG_STATE_SETSEQ_128_INITIALIZER
#endif

#if __cplusplus
}
#endif

#endif // PCG_VARIANTS_H_INCLUDED


注释解释了每个宏的作用和定义，确保代码的可读性和理解性。
```