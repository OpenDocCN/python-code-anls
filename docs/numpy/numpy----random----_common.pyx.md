# `D:\src\scipysrc\numpy\numpy\random\_common.pyx`

```
# 导入必要的模块和函数
# 设置 Cython 编译器的参数，关闭部分安全检查以提高性能
# 使用 namedtuple 定义一个接口，包含多个字段
# 导入 NumPy 库并调用其 import_array() 方法
from collections import namedtuple  # 导入 namedtuple 类
from cpython cimport PyFloat_AsDouble  # 导入 CPython 的 PyFloat_AsDouble 函数
import sys  # 导入 sys 模块
import numpy as np  # 导入 NumPy 库
cimport numpy as np  # 在 Cython 中导入 NumPy 库

# 导入 C 库中的数据类型和函数
from libc.stdint cimport uintptr_t  # 导入 uintptr_t 类型
from libc.math cimport isnan, signbit  # 导入 C 库中的 isnan 和 signbit 函数

# 从 limits.h 头文件中导入 LONG_MAX 常量
cdef extern from "limits.h":
    cdef long LONG_MAX  # 定义 LONG_MAX 常量，NumPy 应该也有，也许 `__init__.pyd` 应该暴露它

# 定义要导出的模块成员列表
__all__ = ['interface']

# 导入 NumPy C API
np.import_array()

# 使用 namedtuple 定义接口，包含多个字段：state_address, state, next_uint64, next_uint32, next_double, bit_generator
interface = namedtuple('interface', ['state_address', 'state', 'next_uint64',
                                     'next_uint32', 'next_double',
                                     'bit_generator'])

# 定义两个常量，分别是 legacy Poisson 和 Poisson 参数的最大值
cdef double LEGACY_POISSON_LAM_MAX = <double>np.iinfo('l').max - np.sqrt(np.iinfo('l').max)*10
cdef double POISSON_LAM_MAX = <double>np.iinfo('int64').max - np.sqrt(np.iinfo('int64').max)*10

# 定义一个常量，表示 Python 中的 sys.maxsize 转换成 uint64_t 类型
cdef uint64_t MAXSIZE = <uint64_t>sys.maxsize

# 定义一个函数 benchmark，用于测试 BitGenerator 的性能
# 方法名为 benchmark
# 参数包括 bitgen: BitGenerator 结构体的地址, lock: BitGenerator 提供的锁, cnt: 计数器, method: 方法名称
cdef object benchmark(bitgen_t *bitgen, object lock, Py_ssize_t cnt, object method):
    """Benchmark command used by BitGenerator"""
    cdef Py_ssize_t i  # 定义一个 Python ssize_t 类型的变量 i
    if method=='uint64':  # 如果 method 参数为 'uint64'
        with lock, nogil:  # 使用锁和 nogil 上下文管理器
            for i in range(cnt):  # 循环 cnt 次
                bitgen.next_uint64(bitgen.state)  # 调用 BitGenerator 的 next_uint64 方法
    elif method=='double':  # 如果 method 参数为 'double'
        with lock, nogil:  # 使用锁和 nogil 上下文管理器
            for i in range(cnt):  # 循环 cnt 次
                bitgen.next_double(bitgen.state)  # 调用 BitGenerator 的 next_double 方法
    else:
        raise ValueError('Unknown method')  # 抛出 ValueError 异常，表示未知的方法

# 定义一个函数 random_raw，用于返回基础 PRNG 生成的随机数
# 方法名为 random_raw
# 参数包括 bitgen: BitGenerator 结构体的地址, lock: BitGenerator 提供的锁, size: 输出形状, output: 是否输出性能测试
cdef object random_raw(bitgen_t *bitgen, object lock, object size, object output):
    """
    random_raw(self, size=None)

    Return randoms as generated by the underlying PRNG

    Parameters
    ----------
    bitgen : BitGenerator
        Address of the bit generator struct
    lock : Threading.Lock
        Lock provided by the bit generator
    size : int or tuple of ints, optional
        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
        ``m * n * k`` samples are drawn.  Default is None, in which case a
        single value is returned.
    output : bool, optional
        Output values.  Used for performance testing since the generated
        values are not returned.

    Returns
    -------
    out : uint or ndarray
        Drawn samples.

    Notes
    -----
    This method directly exposes the raw underlying pseudo-random
    number generator. All values are returned as unsigned 64-bit
    values irrespective of the number of bits produced by the PRNG.

    See the class docstring for the number of bits returned.
    """
    cdef np.ndarray randoms  # 定义一个 NumPy 数组变量 randoms
    cdef uint64_t *randoms_data  # 定义一个 uint64_t 类型指针变量 randoms_data
    cdef Py_ssize_t i, n  # 定义 Python ssize_t 类型变量 i 和 n

    if not output:  # 如果 output 参数为 False
        if size is None:  # 如果 size 参数为 None
            with lock:  # 使用锁
                bitgen.next_raw(bitgen.state)  # 调用 BitGenerator 的 next_raw 方法
            return None  # 返回 None
        n = np.asarray(size).sum()  # 计算 size 参数的总和
        with lock, nogil:  # 使用锁和 nogil 上下文管理器
            for i in range(n):  # 循环 n 次
                bitgen.next_raw(bitgen.state)  # 调用 BitGenerator 的 next_raw 方法
        return None  # 返回 None

    if size is None:  # 如果 size 参数为 None
        with lock:  # 使用锁
            return bitgen.next_raw(bitgen.state)  # 返回 BitGenerator 的 next_raw 方法的结果

    randoms = <np.ndarray>np.empty(size, np.uint64)  # 创建一个空的 NumPy 数组 randoms，数据类型为 uint64，形状为 size
    # 将 NumPy 数组 `randoms` 的数据指针转换为 uint64_t 类型的指针
    randoms_data = <uint64_t*>np.PyArray_DATA(randoms)
    # 获取 NumPy 数组 `randoms` 的大小（元素个数）
    n = np.PyArray_SIZE(randoms)
    
    # 使用 Cython 的 `with` 语句结合 `lock` 和 `nogil` 上下文管理器，
    # 以确保在没有全局解释器锁 (GIL) 的情况下安全地执行以下代码块
    with lock, nogil:
        # 遍历数组 `randoms` 的每一个元素
        for i in range(n):
            # 调用 `bitgen.next_raw(bitgen.state)` 方法生成下一个随机数，
            # 并将其存储到 `randoms_data[i]` 中
            randoms_data[i] = bitgen.next_raw(bitgen.state)
    
    # 返回更新后的 NumPy 数组 `randoms`
    return randoms
cdef object prepare_cffi(bitgen_t *bitgen):
    """
    使用 cffi 打包与 BitGenerator 的交互接口

    Parameters
    ----------
    bitgen : pointer
        指向 BitGenerator 实例的指针

    Returns
    -------
    interface : namedtuple
        使用 cffi 与 BitGenerator 交互所需的函数接口：

        * state_address - 状态结构体的内存地址
        * state - 指向状态结构体的指针
        * next_uint64 - 生成 64 位整数的函数指针
        * next_uint32 - 生成 32 位整数的函数指针
        * next_double - 生成双精度浮点数的函数指针
        * bit_generator - 指向 BitGenerator 结构体的指针
    """
    try:
        import cffi
    except ImportError as e:
        raise ImportError('cffi 无法导入。') from e

    ffi = cffi.FFI()
    _cffi = interface(<uintptr_t>bitgen.state,
                      ffi.cast('void *', <uintptr_t>bitgen.state),
                      ffi.cast('uint64_t (*)(void *)', <uintptr_t>bitgen.next_uint64),
                      ffi.cast('uint32_t (*)(void *)', <uintptr_t>bitgen.next_uint32),
                      ffi.cast('double (*)(void *)', <uintptr_t>bitgen.next_double),
                      ffi.cast('void *', <uintptr_t>bitgen))
    return _cffi

cdef object prepare_ctypes(bitgen_t *bitgen):
    """
    使用 ctypes 打包与 BitGenerator 的交互接口

    Parameters
    ----------
    bitgen : pointer
        指向 BitGenerator 实例的指针

    Returns
    -------
    interface : namedtuple
        使用 ctypes 与 BitGenerator 交互所需的函数接口：

        * state_address - 状态结构体的内存地址
        * state - 指向状态结构体的指针
        * next_uint64 - 生成 64 位整数的函数指针
        * next_uint32 - 生成 32 位整数的函数指针
        * next_double - 生成双精度浮点数的函数指针
        * bit_generator - 指向 BitGenerator 结构体的指针
    """
    import ctypes

    _ctypes = interface(<uintptr_t>bitgen.state,
                        ctypes.c_void_p(<uintptr_t>bitgen.state),
                        ctypes.cast(<uintptr_t>bitgen.next_uint64,
                                    ctypes.CFUNCTYPE(ctypes.c_uint64,
                                                     ctypes.c_void_p)),
                        ctypes.cast(<uintptr_t>bitgen.next_uint32,
                                    ctypes.CFUNCTYPE(ctypes.c_uint32,
                                                     ctypes.c_void_p)),
                        ctypes.cast(<uintptr_t>bitgen.next_double,
                                    ctypes.CFUNCTYPE(ctypes.c_double,
                                                     ctypes.c_void_p)),
                        ctypes.c_void_p(<uintptr_t>bitgen))
    return _ctypes

cdef double kahan_sum(double *darr, np.npy_intp n) noexcept:
    """
    Parameters
    ----------
    darr : pointer
        指向双精度浮点数数组的指针
    n : np.npy_intp
        数组的长度

    Returns
    -------
    double
        数组元素的累加和，使用 Kahan 算法

    Raises
    ------
    """
    # darr : double 数组的引用
    #     要求求和的数值地址
    # n : intp
    #     darr 数组的长度
    
    # Returns
    # -------
    # float
    #     总和。如果 n <= 0，则返回 0.0。
    """
    # 使用 Cython 声明变量，以提高性能
    cdef double c, y, t, sum
    cdef np.npy_intp i
    
    # 如果 n 小于等于 0，直接返回 0.0
    if n <= 0:
        return 0.0
    
    # 初始化 sum 为数组第一个元素的值
    sum = darr[0]
    # 初始化 c 为 0.0
    c = 0.0
    
    # 遍历数组，从第二个元素开始累加到 sum
    for i in range(1, n):
        # 计算当前元素与 c 的差值
        y = darr[i] - c
        # 将 sum 与 y 相加得到 t
        t = sum + y
        # 更新 c 为 (t - sum) - y
        c = (t - sum) - y
        # 更新 sum 为 t
        sum = t
    
    # 返回最终的总和值
    return sum
# 将整数包装到区间 [0, 2**bits) 中
cdef object wrap_int(object val, object bits):
    mask = ~(~int(0) << bits)  # 创建一个掩码，用于限制整数在指定位数范围内
    return val & mask  # 返回 val 和掩码的按位与操作结果，确保 val 在指定范围内


# 将大整数转换为无符号整数数组
cdef np.ndarray int_to_array(object value, object name, object bits, object uint_size):
    len = bits // uint_size  # 计算数组长度，根据位数和单个整数大小计算
    value = np.asarray(value)  # 将 value 转换为 NumPy 数组
    if uint_size == 32:
        dtype = np.uint32  # 设置数据类型为 uint32
    elif uint_size == 64:
        dtype = np.uint64  # 设置数据类型为 uint64
    else:
        raise ValueError('Unknown uint_size')  # 抛出异常，未知的 uint_size
    if value.shape == ():  # 如果 value 是标量
        value = int(value)  # 转换为整数
        upper = int(2)**int(bits)  # 计算上限值
        if value < 0 or value >= upper:
            raise ValueError(f'{name} must be positive and less than 2**{bits}.')  # 抛出数值错误异常
        out = np.empty(len, dtype=dtype)  # 创建一个空数组，用于存储结果
        for i in range(len):
            out[i] = value % 2**int(uint_size)  # 将整数按位拆分存入数组
            value >>= int(uint_size)  # 右移整数以处理下一部分数据
    else:
        out = value.astype(dtype)  # 如果 value 是数组，则直接转换为指定类型
        if out.shape != (len,):  # 如果数组形状不符合预期长度
            raise ValueError(f'{name} must have {len} elements when using array form')  # 抛出数值错误异常
    return out  # 返回转换后的数组


# 验证输出数组的形状与迭代形状是否一致
cdef validate_output_shape(iter_shape, np.ndarray output):
    cdef np.npy_intp *dims  # 创建指向整数数组的指针 dims
    cdef np.npy_intp ndim, i  # 创建整数变量 ndim 和 i
    cdef bint error  # 创建布尔值变量 error
    dims = np.PyArray_DIMS(output)  # 获取输出数组的维度信息
    ndim = np.PyArray_NDIM(output)  # 获取输出数组的维度数量
    output_shape = tuple((dims[i] for i in range(ndim)))  # 将维度信息转换为元组形式
    if iter_shape != output_shape:  # 如果迭代形状与输出形状不一致
        raise ValueError(
            f"Output size {output_shape} is not compatible with broadcast "
            f"dimensions of inputs {iter_shape}."
        )  # 抛出数值错误异常，输出数组大小与输入的广播维度不兼容


# 检查用户提供的输出数组属性和形状
cdef check_output(object out, object dtype, object size, bint require_c_array):
    """
    检查用户提供的输出数组属性和形状
    
    Parameters
    ----------
    out : {ndarray, None}
        要检查的数组。如果为 None，则立即返回。
    dtype : dtype
        out 的所需数据类型。
    size : {None, int, tuple[int]}
        传递的大小。如果 out 是一个 ndarray，则验证其形状是否与 size 匹配。
    require_c_array : bool
        是否要求 out 必须是 C 数组。如果为 False，则 out 可以是 C 或 F 排序的。
        如果为 True，则必须是 C 排序的。在任何情况下，必须是连续的、可写的、对齐的，
        并且是本机字节顺序的。
    """
    if out is None:  # 如果输出数组为 None，则直接返回
        return
    cdef np.ndarray out_array = <np.ndarray>out  # 将 out 强制转换为 NumPy 数组
    if not (np.PyArray_ISCARRAY(out_array) or
            (np.PyArray_ISFARRAY(out_array) and not require_c_array)):
        req = "C-" if require_c_array else ""  # 如果要求 C 数组，设置说明字符串为 "C-"
        raise ValueError(
            f'Supplied output array must be {req}contiguous, writable, '
            f'aligned, and in machine byte-order.'
        )  # 抛出数值错误异常，提供的输出数组必须是指定要求的类型
    if out_array.dtype != dtype:  # 如果输出数组的数据类型与要求不符
        raise TypeError('Supplied output array has the wrong type. '
                        'Expected {0}, got {1}'.format(np.dtype(dtype), out_array.dtype))  # 抛出类型错误异常，输出数组类型错误
    # 如果 size 参数不为 None，则执行以下逻辑
    try:
        # 尝试将 size 转换为元组类型
        tup_size = tuple(size)
    except TypeError:
        # 如果 size 不能被转换为元组（可能是单个元素），则将其转换为包含该元素的元组
        tup_size = tuple([size])
    # 如果 tup_size 与 out 的形状不匹配，则抛出数值错误异常
    if tup_size != out.shape:
        raise ValueError('size must match out.shape when used together')
# 定义 C 扩展函数，用于填充双精度浮点数数组
cdef object double_fill(void *func, bitgen_t *state, object size, object lock, object out):
    # 将 void 指针转换为双精度浮点数填充函数类型
    cdef random_double_fill random_func = (<random_double_fill>func)
    # 声明双精度浮点数输出值
    cdef double out_val
    # 声明双精度浮点数数组数据指针
    cdef double *out_array_data
    # 声明 NumPy 数组对象
    cdef np.ndarray out_array
    # 声明 NumPy 中的整数类型和变量
    cdef np.npy_intp i, n

    # 如果 size 和 out 均为 None
    if size is None and out is None:
        # 使用锁，调用随机双精度浮点数填充函数，返回填充后的值
        with lock:
            random_func(state, 1, &out_val)
            return out_val

    # 如果 out 不为 None
    if out is not None:
        # 检查输出数组是否符合要求的 np.float64 类型和指定的大小，不要求 C 连续性
        check_output(out, np.float64, size, False)
        out_array = <np.ndarray>out
    else:
        # 创建一个指定大小的空双精度浮点数数组
        out_array = <np.ndarray>np.empty(size, np.double)

    # 获取输出数组的长度
    n = np.PyArray_SIZE(out_array)
    # 获取输出数组的数据指针
    out_array_data = <double *>np.PyArray_DATA(out_array)
    # 使用锁，无 GIL 状态下调用随机双精度浮点数填充函数填充数组
    with lock, nogil:
        random_func(state, n, out_array_data)
    # 返回填充后的数组
    return out_array


# 定义 C 扩展函数，用于填充单精度浮点数数组
cdef object float_fill(void *func, bitgen_t *state, object size, object lock, object out):
    # 将 void 指针转换为单精度浮点数填充函数类型
    cdef random_float_fill random_func = (<random_float_fill>func)
    # 声明单精度浮点数输出值
    cdef float out_val
    # 声明单精度浮点数数组数据指针
    cdef float *out_array_data
    # 声明 NumPy 数组对象
    cdef np.ndarray out_array
    # 声明 NumPy 中的整数类型和变量
    cdef np.npy_intp i, n

    # 如果 size 和 out 均为 None
    if size is None and out is None:
        # 使用锁，调用随机单精度浮点数填充函数，返回填充后的值
        with lock:
            random_func(state, 1, &out_val)
            return out_val

    # 如果 out 不为 None
    if out is not None:
        # 检查输出数组是否符合要求的 np.float32 类型和指定的大小，不要求 C 连续性
        check_output(out, np.float32, size, False)
        out_array = <np.ndarray>out
    else:
        # 创建一个指定大小的空单精度浮点数数组
        out_array = <np.ndarray>np.empty(size, np.float32)

    # 获取输出数组的长度
    n = np.PyArray_SIZE(out_array)
    # 获取输出数组的数据指针
    out_array_data = <float *>np.PyArray_DATA(out_array)
    # 使用锁，无 GIL 状态下调用随机单精度浮点数填充函数填充数组
    with lock, nogil:
        random_func(state, n, out_array_data)
    # 返回填充后的数组
    return out_array


# 定义 C 扩展函数，从双精度浮点数填充到单精度浮点数数组
cdef object float_fill_from_double(void *func, bitgen_t *state, object size, object lock, object out):
    # 将 void 指针转换为双精度浮点数填充函数类型
    cdef random_double_0 random_func = (<random_double_0>func)
    # 声明单精度浮点数数组数据指针
    cdef float *out_array_data
    # 声明 NumPy 数组对象
    cdef np.ndarray out_array
    # 声明 NumPy 中的整数类型和变量
    cdef np.npy_intp i, n

    # 如果 size 和 out 均为 None
    if size is None and out is None:
        # 使用锁，调用随机双精度浮点数填充函数，将结果转换为单精度浮点数并返回
        with lock:
            return <float>random_func(state)

    # 如果 out 不为 None
    if out is not None:
        # 检查输出数组是否符合要求的 np.float32 类型和指定的大小，不要求 C 连续性
        check_output(out, np.float32, size, False)
        out_array = <np.ndarray>out
    else:
        # 创建一个指定大小的空单精度浮点数数组
        out_array = <np.ndarray>np.empty(size, np.float32)

    # 获取输出数组的长度
    n = np.PyArray_SIZE(out_array)
    # 获取输出数组的数据指针
    out_array_data = <float *>np.PyArray_DATA(out_array)
    # 使用锁，无 GIL 状态下循环调用随机双精度浮点数填充函数，将结果转换为单精度浮点数填充数组
    with lock, nogil:
        for i in range(n):
            out_array_data[i] = <float>random_func(state)
    # 返回填充后的数组
    return out_array


# 定义检查数组元素是否在 [0, 1] 范围内的 C 扩展函数
cdef int _check_array_cons_bounded_0_1(np.ndarray val, object name) except -1:
    # 声明双精度浮点数数组数据指针
    cdef double *val_data
    # 声明 NumPy 中的整数类型和变量
    cdef np.npy_intp i
    # 声明错误标志变量，默认为 False
    cdef bint err = 0

    # 如果数组非 C 连续或者不是双精度浮点数类型
    if not np.PyArray_ISONESEGMENT(val) or np.PyArray_TYPE(val) != np.NPY_DOUBLE:
        # 针对非连续数组或任何非双精度类型，采用慢速路径处理
        err = not np.all(np.greater_equal(val, 0)) or not np.all(np.less_equal(val, 1))
    else:
        # 获取双精度浮点数数组的数据指针
        val_data = <double *>np.PyArray_DATA(val)
        # 遍历数组元素
        for i in range(np.PyArray_SIZE(val)):
            # 检查每个元素是否在 [0, 1] 范围内
            err = (not (val_data[i] >= 0)) or (not val_data[i] <= 1)
            if err:
                break

    # 如果出现错误，则抛出 ValueError 异常
    if err:
        raise ValueError(f"{name} < 0, {name} > 1 or {name} contains NaNs")

    # 返回 0 表示检查成功
    return 0
cdef int check_array_constraint(np.ndarray val, object name, constraint_type cons) except -1:
    # 检查数组约束条件的函数，返回值为整数，异常为-1

    if cons == CONS_NON_NEGATIVE:
        # 如果约束条件为非负数
        if np.any(np.logical_and(np.logical_not(np.isnan(val)), np.signbit(val))):
            # 如果数组中存在非NaN且小于0的元素，则抛出数值错误异常
            raise ValueError(name + " < 0")

    elif cons == CONS_POSITIVE or cons == CONS_POSITIVE_NOT_NAN:
        # 如果约束条件为正数或者非NaN的正数
        if cons == CONS_POSITIVE_NOT_NAN and np.any(np.isnan(val)):
            # 如果约束条件为非NaN的正数且数组中存在NaN元素，则抛出数值错误异常
            raise ValueError(name + " must not be NaN")
        elif np.any(np.less_equal(val, 0)):
            # 如果数组中存在小于等于0的元素，则抛出数值错误异常
            raise ValueError(name + " <= 0")

    elif cons == CONS_BOUNDED_0_1:
        # 如果约束条件为0到1之间
        return _check_array_cons_bounded_0_1(val, name)

    elif cons == CONS_BOUNDED_GT_0_1:
        # 如果约束条件为大于0小于等于1的区间
        if not np.all(np.greater(val, 0)) or not np.all(np.less_equal(val, 1)):
            # 如果数组中存在不大于0或不小于等于1的元素，则抛出数值错误异常
            raise ValueError("{0} <= 0, {0} > 1 or {0} contains NaNs".format(name))

    elif cons == CONS_BOUNDED_LT_0_1:
        # 如果约束条件为大于等于0小于1的区间
        if not np.all(np.greater_equal(val, 0)) or not np.all(np.less(val, 1)):
            # 如果数组中存在不大于等于0或不小于1的元素，则抛出数值错误异常
            raise ValueError("{0} < 0, {0} >= 1 or {0} contains NaNs".format(name))

    elif cons == CONS_GT_1:
        # 如果约束条件为大于1
        if not np.all(np.greater(val, 1)):
            # 如果数组中存在不大于1的元素，则抛出数值错误异常
            raise ValueError("{0} <= 1 or {0} contains NaNs".format(name))

    elif cons == CONS_GTE_1:
        # 如果约束条件为大于等于1
        if not np.all(np.greater_equal(val, 1)):
            # 如果数组中存在不大于等于1的元素，则抛出数值错误异常
            raise ValueError("{0} < 1 or {0} contains NaNs".format(name))

    elif cons == CONS_POISSON:
        # 如果约束条件为泊松分布
        if not np.all(np.less_equal(val, POISSON_LAM_MAX)):
            # 如果数组中有超过泊松分布允许值的元素，则抛出数值错误异常
            raise ValueError("{0} value too large".format(name))
        elif not np.all(np.greater_equal(val, 0.0)):
            # 如果数组中有小于0的元素，则抛出数值错误异常
            raise ValueError("{0} < 0 or {0} contains NaNs".format(name))

    elif cons == LEGACY_CONS_POISSON:
        # 如果约束条件为旧版泊松分布
        if not np.all(np.less_equal(val, LEGACY_POISSON_LAM_MAX)):
            # 如果数组中有超过旧版泊松分布允许值的元素，则抛出数值错误异常
            raise ValueError("{0} value too large".format(name))
        elif not np.all(np.greater_equal(val, 0.0)):
            # 如果数组中有小于0的元素，则抛出数值错误异常
            raise ValueError("{0} < 0 or {0} contains NaNs".format(name))

    elif cons == LEGACY_CONS_NON_NEGATIVE_INBOUNDS_LONG:
        # 如果约束条件为旧版非负数且在长整型范围内
        # 注意，这里假设数组元素为整数：
        if not np.all(val >= 0):
            # 如果数组中有小于0的元素，则抛出数值错误异常
            raise ValueError(name + " < 0")
        elif not np.all(val <= int(LONG_MAX)):
            # 如果数组中有超过长整型范围的元素，则抛出数值错误异常
            raise ValueError(
                    name + " is out of bounds for long, consider using "
                    "the new generator API for 64bit integers.")

    return 0


cdef int check_constraint(double val, object name, constraint_type cons) except -1:
    # 检查单个值约束条件的函数，返回值为整数，异常为-1
    cdef bint is_nan

    if cons == CONS_NON_NEGATIVE:
        # 如果约束条件为非负数
        if not isnan(val) and signbit(val):
            # 如果值不是NaN且小于0，则抛出数值错误异常
            raise ValueError(name + " < 0")

    elif cons == CONS_POSITIVE or cons == CONS_POSITIVE_NOT_NAN:
        # 如果约束条件为正数或者非NaN的正数
        if cons == CONS_POSITIVE_NOT_NAN and isnan(val):
            # 如果约束条件为非NaN的正数且值为NaN，则抛出数值错误异常
            raise ValueError(name + " must not be NaN")
        elif val <= 0:
            # 如果值小于等于0，则抛出数值错误异常
            raise ValueError(name + " <= 0")

    elif cons == CONS_BOUNDED_0_1:
        # 如果约束条件为0到1之间
        if not (val >= 0) or not (val <= 1):
            # 如果值小于0或大于1，则抛出数值错误异常
            raise ValueError("{0} < 0, {0} > 1 or {0} is NaN".format(name))
    # 如果约束条件为 CONS_BOUNDED_GT_0_1
    elif cons == CONS_BOUNDED_GT_0_1:
        # 检查值是否不大于0或不小于等于1，如果是，则抛出值错误异常
        if not val > 0 or not val <= 1:
            raise ValueError("{0} <= 0, {0} > 1 or {0} contains NaNs".format(name))
    
    # 如果约束条件为 CONS_BOUNDED_LT_0_1
    elif cons == CONS_BOUNDED_LT_0_1:
        # 检查值是否不大于等于0或不小于1，如果是，则抛出值错误异常
        if not (val >= 0) or not (val < 1):
            raise ValueError("{0} < 0, {0} >= 1 or {0} is NaN".format(name))
    
    # 如果约束条件为 CONS_GT_1
    elif cons == CONS_GT_1:
        # 检查值是否不大于1，如果是，则抛出值错误异常
        if not (val > 1):
            raise ValueError("{0} <= 1 or {0} is NaN".format(name))
    
    # 如果约束条件为 CONS_GTE_1
    elif cons == CONS_GTE_1:
        # 检查值是否不大于等于1，如果是，则抛出值错误异常
        if not (val >= 1):
            raise ValueError("{0} < 1 or {0} is NaN".format(name))
    
    # 如果约束条件为 CONS_POISSON
    elif cons == CONS_POISSON:
        # 检查值是否不小于0，如果是，则抛出值错误异常
        if not (val >= 0):
            raise ValueError("{0} < 0 or {0} is NaN".format(name))
        # 检查值是否不大于 POISSON_LAM_MAX，如果是，则抛出值错误异常
        elif not (val <= POISSON_LAM_MAX):
            raise ValueError(name + " value too large")
    
    # 如果约束条件为 LEGACY_CONS_POISSON
    elif cons == LEGACY_CONS_POISSON:
        # 检查值是否不小于0，如果是，则抛出值错误异常
        if not (val >= 0):
            raise ValueError("{0} < 0 or {0} is NaN".format(name))
        # 检查值是否不大于 LEGACY_POISSON_LAM_MAX，如果是，则抛出值错误异常
        elif not (val <= LEGACY_POISSON_LAM_MAX):
            raise ValueError(name + " value too large")
    
    # 如果约束条件为 LEGACY_CONS_NON_NEGATIVE_INBOUNDS_LONG
    elif cons == LEGACY_CONS_NON_NEGATIVE_INBOUNDS_LONG:
        # 注意：假设值是整数（LONG_MAX 的两倍应该可以处理）
        # 检查值是否小于0，如果是，则抛出值错误异常
        if val < 0:
            raise ValueError(name + " < 0")
        # 检查值是否大于 LONG_MAX，如果是，则抛出值错误异常
        elif val > LONG_MAX:
            raise ValueError(
                    name + " is out of bounds for long, consider using "
                    "the new generator API for 64bit integers.")

    # 如果以上条件都不满足，则返回0
    return 0
# 定义一个 Cython 函数，用于执行广播计算，生成一个包含随机数的 NumPy 数组
cdef object cont_broadcast_1(void *func, void *state, object size, object lock,
                             np.ndarray a_arr, object a_name, constraint_type a_constraint,
                             object out):

    # 声明变量
    cdef np.ndarray randoms  # 存储生成的随机数的 NumPy 数组
    cdef double a_val        # 存储从数组 a_arr 中提取的值
    cdef double *randoms_data  # 用于访问 randoms 的数据指针
    cdef np.broadcast it     # NumPy 的广播迭代器
    cdef random_double_1 f = (<random_double_1>func)  # 函数指针，指向随机数生成函数
    cdef np.npy_intp i, n    # 用于迭代的整数变量

    # 检查是否有约束条件，如果有，则检查数组 a_arr 是否符合约束
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 根据 size 参数决定创建 randoms 的方式
    if size is not None and out is None:
        randoms = <np.ndarray>np.empty(size, np.double)
    elif out is None:
        randoms = np.PyArray_SimpleNew(np.PyArray_NDIM(a_arr), np.PyArray_DIMS(a_arr), np.NPY_DOUBLE)
    else:
        randoms = <np.ndarray>out

    # 获取 randoms 数组的数据指针
    randoms_data = <double *>np.PyArray_DATA(randoms)
    # 获取 randoms 数组的大小
    n = np.PyArray_SIZE(randoms)
    # 创建广播迭代器 it，用于同时迭代 randoms 和 a_arr
    it = np.PyArray_MultiIterNew2(randoms, a_arr)
    # 验证输出形状是否正确
    validate_output_shape(it.shape, randoms)

    # 使用锁和 nogil 上下文执行并行化的计算
    with lock, nogil:
        # 遍历 randoms 数组
        for i in range(n):
            # 从广播迭代器中获取当前 a_arr 中的值
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            # 使用函数指针 f 调用指定的随机数生成函数，将结果存入 randoms 中
            randoms_data[i] = f(state, a_val)

            # 移动广播迭代器到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回生成的随机数数组
    return randoms



# 定义另一个 Cython 函数，用于执行两个数组的广播计算，生成一个包含随机数的 NumPy 数组
cdef object cont_broadcast_2(void *func, void *state, object size, object lock,
                 np.ndarray a_arr, object a_name, constraint_type a_constraint,
                 np.ndarray b_arr, object b_name, constraint_type b_constraint):
    # 声明变量
    cdef np.ndarray randoms  # 存储生成的随机数的 NumPy 数组
    cdef double a_val, b_val  # 存储从数组 a_arr 和 b_arr 中提取的值
    cdef double *randoms_data  # 用于访问 randoms 的数据指针
    cdef np.broadcast it     # NumPy 的广播迭代器
    cdef random_double_2 f = (<random_double_2>func)  # 函数指针，指向随机数生成函数
    cdef np.npy_intp i, n    # 用于迭代的整数变量

    # 检查约束条件，如果有，则检查数组 a_arr 和 b_arr 是否符合约束
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 根据 size 参数决定创建 randoms 的方式
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.double)
    else:
        it = np.PyArray_MultiIterNew2(a_arr, b_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.double)

    # 获取 randoms 数组的数据指针
    randoms_data = <double *>np.PyArray_DATA(randoms)
    # 获取 randoms 数组的大小
    n = np.PyArray_SIZE(randoms)

    # 创建广播迭代器 it，用于同时迭代 randoms、a_arr 和 b_arr
    it = np.PyArray_MultiIterNew3(randoms, a_arr, b_arr)
    # 验证输出形状是否正确
    validate_output_shape(it.shape, randoms)

    # 使用锁和 nogil 上下文执行并行化的计算
    with lock, nogil:
        # 遍历 randoms 数组
        for i in range(n):
            # 从广播迭代器中获取当前 a_arr 和 b_arr 中的值
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            b_val = (<double*>np.PyArray_MultiIter_DATA(it, 2))[0]
            # 使用函数指针 f 调用指定的随机数生成函数，将结果存入 randoms 中
            randoms_data[i] = f(state, a_val, b_val)

            # 移动广播迭代器到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回生成的随机数数组
    return randoms



# 定义另一个 Cython 函数，用于执行三个数组的广播计算，生成一个包含随机数的 NumPy 数组
cdef object cont_broadcast_3(void *func, void *state, object size, object lock,
                             np.ndarray a_arr, object a_name, constraint_type a_constraint,
                             np.ndarray b_arr, object b_name, constraint_type b_constraint,
                             np.ndarray c_arr, object c_name, constraint_type c_constraint):
    # 声明变量
    cdef np.ndarray randoms  # 存储生成的随机数的 NumPy 数组
    cdef double a_val, b_val, c_val  # 存储从数组 a_arr、b_arr 和 c_arr 中提取的值
    # 声明一个指向 double 类型的指针变量 randoms_data
    cdef double *randoms_data
    # 声明一个 numpy 广播对象 it
    cdef np.broadcast it
    # 将 func 强制转换为 random_double_3 类型，并赋值给 f
    cdef random_double_3 f = (<random_double_3>func)
    # 声明两个 numpy 的整数类型变量 i 和 n
    cdef np.npy_intp i, n

    # 如果 a_constraint 不等于 CONS_NONE，则调用 check_array_constraint 检查 a_arr
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 如果 b_constraint 不等于 CONS_NONE，则调用 check_array_constraint 检查 b_arr
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 如果 c_constraint 不等于 CONS_NONE，则调用 check_array_constraint 检查 c_arr
    if c_constraint != CONS_NONE:
        check_array_constraint(c_arr, c_name, c_constraint)

    # 如果 size 不为 None，则创建一个大小为 size 的新的 double 类型的 numpy 数组 randoms
    # 否则，使用 np.PyArray_MultiIterNew3 创建一个多迭代器 it，并使用其形状创建 randoms
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.double)
    else:
        it = np.PyArray_MultiIterNew3(a_arr, b_arr, c_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.double)

    # 将 randoms 的数据指针赋值给 randoms_data
    randoms_data = <double *>np.PyArray_DATA(randoms)
    # 获取 randoms 数组的大小，并赋值给 n
    n = np.PyArray_SIZE(randoms)

    # 使用 np.PyArray_MultiIterNew4 创建一个四维的多迭代器 it，验证其形状与 randoms 是否一致
    it = np.PyArray_MultiIterNew4(randoms, a_arr, b_arr, c_arr)
    validate_output_shape(it.shape, randoms)

    # 使用 lock 和 nogil 上下文，遍历 randoms 的元素个数 n
    with lock, nogil:
        for i in range(n):
            # 分别获取多迭代器 it 中第 1、2、3 个数组的当前元素，并强制转换为 double 指针类型，获取其值
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            b_val = (<double*>np.PyArray_MultiIter_DATA(it, 2))[0]
            c_val = (<double*>np.PyArray_MultiIter_DATA(it, 3))[0]
            # 调用函数 f，将 state、a_val、b_val、c_val 作为参数，将结果赋值给 randoms_data 的当前索引 i 处
            randoms_data[i] = f(state, a_val, b_val, c_val)

            # 更新多迭代器 it，使其指向下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回生成的随机数数组 randoms
    return randoms
# 定义 C 扩展函数 cont，接收多个参数和约束条件，返回一个对象
cdef object cont(void *func, void *state, object size, object lock, int narg,
                 object a, object a_name, constraint_type a_constraint,
                 object b, object b_name, constraint_type b_constraint,
                 object c, object c_name, constraint_type c_constraint,
                 object out):
    # 定义用于存储参数的 numpy 数组变量
    cdef np.ndarray a_arr, b_arr, c_arr
    # 定义用于存储参数的 double 类型变量
    cdef double _a = 0.0, _b = 0.0, _c = 0.0
    # 布尔型变量，表示是否是标量值
    cdef bint is_scalar = True
    
    # 检查输出参数的类型和大小，要求是 np.float64 类型
    check_output(out, np.float64, size, narg > 0)
    
    # 如果有第一个参数
    if narg > 0:
        # 将参数 a 转换为 np.ndarray 类型
        a_arr = <np.ndarray>np.PyArray_FROM_OTF(a, np.NPY_DOUBLE, np.NPY_ALIGNED)
        # 判断是否为标量
        is_scalar = is_scalar and np.PyArray_NDIM(a_arr) == 0
        
    # 如果有第二个参数
    if narg > 1:
        # 将参数 b 转换为 np.ndarray 类型
        b_arr = <np.ndarray>np.PyArray_FROM_OTF(b, np.NPY_DOUBLE, np.NPY_ALIGNED)
        # 判断是否为标量
        is_scalar = is_scalar and np.PyArray_NDIM(b_arr) == 0
        
    # 如果有第三个参数
    if narg == 3:
        # 将参数 c 转换为 np.ndarray 类型
        c_arr = <np.ndarray>np.PyArray_FROM_OTF(c, np.NPY_DOUBLE, np.NPY_ALIGNED)
        # 判断是否为标量
        is_scalar = is_scalar and np.PyArray_NDIM(c_arr) == 0

    # 如果不是标量值
    if not is_scalar:
        # 根据参数个数调用不同的广播函数
        if narg == 1:
            return cont_broadcast_1(func, state, size, lock,
                                    a_arr, a_name, a_constraint,
                                    out)
        elif narg == 2:
            return cont_broadcast_2(func, state, size, lock,
                                    a_arr, a_name, a_constraint,
                                    b_arr, b_name, b_constraint)
        else:
            return cont_broadcast_3(func, state, size, lock,
                                    a_arr, a_name, a_constraint,
                                    b_arr, b_name, b_constraint,
                                    c_arr, c_name, c_constraint)

    # 如果参数是标量值
    if narg > 0:
        # 将参数 a 转换为 double 类型
        _a = PyFloat_AsDouble(a)
        # 如果有约束条件且是标量，则检查约束
        if a_constraint != CONS_NONE and is_scalar:
            check_constraint(_a, a_name, a_constraint)
            
    # 如果有第二个参数
    if narg > 1:
        # 将参数 b 转换为 double 类型
        _b = PyFloat_AsDouble(b)
        # 如果有约束条件，则检查约束
        if b_constraint != CONS_NONE:
            check_constraint(_b, b_name, b_constraint)
            
    # 如果有第三个参数
    if narg == 3:
        # 将参数 c 转换为 double 类型
        _c = PyFloat_AsDouble(c)
        # 如果有约束条件且是标量，则检查约束
        if c_constraint != CONS_NONE and is_scalar:
            check_constraint(_c, c_name, c_constraint)

    # 如果 size 和 out 都为空
    if size is None and out is None:
        # 在锁的作用域内执行以下逻辑
        with lock:
            # 根据参数个数调用不同的随机数生成函数
            if narg == 0:
                return (<random_double_0>func)(state)
            elif narg == 1:
                return (<random_double_1>func)(state, _a)
            elif narg == 2:
                return (<random_double_2>func)(state, _a, _b)
            elif narg == 3:
                return (<random_double_3>func)(state, _a, _b, _c)

    # 定义循环变量和数组大小变量
    cdef np.npy_intp i, n
    # 定义存储随机数的 numpy 数组变量
    cdef np.ndarray randoms
    
    # 如果输出参数为空
    if out is None:
        # 创建一个指定大小的空数组用于存储随机数
        randoms = <np.ndarray>np.empty(size)
    else:
        # 否则使用传入的输出参数
        randoms = <np.ndarray>out
        
    # 获取随机数数组的大小
    n = np.PyArray_SIZE(randoms)

    # 获取随机数数组的数据指针
    cdef double *randoms_data = <double *>np.PyArray_DATA(randoms)
    # 定义用于存储随机数生成函数的变量
    cdef random_double_0 f0
    cdef random_double_1 f1
    cdef random_double_2 f2
    cdef random_double_3 f3
    # 使用给定的锁和无全局解锁（no gil）的上下文执行以下代码块
    with lock, nogil:
        # 如果参数个数为0，则使用第一个随机函数处理数据
        if narg == 0:
            # 获取第一个随机函数对象并调用它生成随机数序列
            f0 = (<random_double_0>func)
            # 循环生成n个随机数并存储到randoms_data数组中
            for i in range(n):
                randoms_data[i] = f0(state)
        # 如果参数个数为1，则使用第二个随机函数处理数据
        elif narg == 1:
            # 获取第二个随机函数对象并调用它生成随机数序列
            f1 = (<random_double_1>func)
            # 循环生成n个随机数并存储到randoms_data数组中
            for i in range(n):
                randoms_data[i] = f1(state, _a)
        # 如果参数个数为2，则使用第三个随机函数处理数据
        elif narg == 2:
            # 获取第三个随机函数对象并调用它生成随机数序列
            f2 = (<random_double_2>func)
            # 循环生成n个随机数并存储到randoms_data数组中
            for i in range(n):
                randoms_data[i] = f2(state, _a, _b)
        # 如果参数个数为3，则使用第四个随机函数处理数据
        elif narg == 3:
            # 获取第四个随机函数对象并调用它生成随机数序列
            f3 = (<random_double_3>func)
            # 循环生成n个随机数并存储到randoms_data数组中
            for i in range(n):
                randoms_data[i] = f3(state, _a, _b, _c)
    
    # 如果未提供输出对象，则返回生成的随机数数组
    if out is None:
        return randoms
    # 否则返回指定的输出对象
    else:
        return out
# 定义 C 函数，用于离散广播操作，接受函数指针、状态指针、大小、锁、数组 a_arr、数组名称 a_name、约束类型 a_constraint 作为参数
cdef object discrete_broadcast_d(void *func, void *state, object size, object lock,
                                 np.ndarray a_arr, object a_name, constraint_type a_constraint):
    # 声明变量
    cdef np.ndarray randoms  # 存储随机数的数组
    cdef int64_t *randoms_data  # 指向随机数数组数据的指针
    cdef np.broadcast it  # 广播迭代器
    cdef random_uint_d f = (<random_uint_d>func)  # 转换函数指针类型为 random_uint_d

    # 如果存在约束条件，检查数组 a_arr 是否符合约束
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 如果指定了大小，创建指定大小的空数组 randoms
    if size is not None:
        randoms = np.empty(size, np.int64)
    else:
        # 否则，使用 a_arr 的形状创建空数组 randoms
        randoms = np.PyArray_SimpleNew(np.PyArray_NDIM(a_arr), np.PyArray_DIMS(a_arr), np.NPY_INT64)

    # 获取 randoms 数组的数据指针和大小
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建包含 randoms 和 a_arr 的多重迭代器 it，并验证输出形状
    it = np.PyArray_MultiIterNew2(randoms, a_arr)
    validate_output_shape(it.shape, randoms)

    # 使用锁和 nogil 上下文执行并发操作
    with lock, nogil:
        for i in range(n):
            # 获取 a_arr 中的当前值 a_val
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            # 使用函数指针 f 处理 state 和 a_val，将结果存入 randoms_data[i]
            randoms_data[i] = f(state, a_val)

            # 将迭代器 it 推进到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回随机数数组 randoms
    return randoms


# 定义 C 函数，用于双数组离散广播操作，接受函数指针、状态指针、大小、锁、数组 a_arr、数组名称 a_name、约束类型 a_constraint、数组 b_arr、数组名称 b_name、约束类型 b_constraint 作为参数
cdef object discrete_broadcast_dd(void *func, void *state, object size, object lock,
                                  np.ndarray a_arr, object a_name, constraint_type a_constraint,
                                  np.ndarray b_arr, object b_name, constraint_type b_constraint):
    # 声明变量
    cdef np.ndarray randoms  # 存储随机数的数组
    cdef int64_t *randoms_data  # 指向随机数数组数据的指针
    cdef np.broadcast it  # 广播迭代器
    cdef random_uint_dd f = (<random_uint_dd>func)  # 转换函数指针类型为 random_uint_dd

    # 如果存在约束条件，检查数组 a_arr 和 b_arr 是否符合约束
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 如果指定了大小，创建指定大小的空数组 randoms
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.int64)
    else:
        # 否则，使用 a_arr 和 b_arr 的形状创建空数组 randoms
        it = np.PyArray_MultiIterNew2(a_arr, b_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.int64)
        # randoms = np.PyArray_SimpleNew(it.nd, np.PyArray_DIMS(it), np.NPY_INT64)

    # 获取 randoms 数组的数据指针和大小
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建包含 randoms、a_arr 和 b_arr 的多重迭代器 it，并验证输出形状
    it = np.PyArray_MultiIterNew3(randoms, a_arr, b_arr)
    validate_output_shape(it.shape, randoms)

    # 使用锁和 nogil 上下文执行并发操作
    with lock, nogil:
        for i in range(n):
            # 获取 a_arr 和 b_arr 中的当前值 a_val 和 b_val
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            b_val = (<double*>np.PyArray_MultiIter_DATA(it, 2))[0]
            # 使用函数指针 f 处理 state、a_val 和 b_val，将结果存入 randoms_data[i]
            randoms_data[i] = f(state, a_val, b_val)

            # 将迭代器 it 推进到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回随机数数组 randoms
    return randoms


# 定义 C 函数，用于数组与整数离散广播操作，接受函数指针、状态指针、大小、锁、数组 a_arr、数组名称 a_name、约束类型 a_constraint、数组 b_arr、数组名称 b_name、约束类型 b_constraint 作为参数
cdef object discrete_broadcast_di(void *func, void *state, object size, object lock,
                                  np.ndarray a_arr, object a_name, constraint_type a_constraint,
                                  np.ndarray b_arr, object b_name, constraint_type b_constraint):
    # 声明变量
    cdef np.ndarray randoms  # 存储随机数的数组
    cdef int64_t *randoms_data  # 指向随机数数组数据的指针
    cdef np.broadcast it  # 广播迭代器
    cdef random_uint_di f = (<random_uint_di>func)  # 转换函数指针类型为 random_uint_di

    # 如果存在约束条件，检查数组 a_arr 和 b_arr 是否符合约束
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 如果指定了大小，创建指定大小的空数组 randoms
    if size is not None:
        randoms = np.empty(size, np.int64)
    else:
        # 否则，使用 a_arr 和 b_arr 的形状创建空数组 randoms
        it = np.PyArray_MultiIterNew2(a_arr, b_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.int64)
        # randoms = np.PyArray_SimpleNew(it.nd, np.PyArray_DIMS(it), np.NPY_INT64)

    # 获取 randoms 数组的数据指针和大小
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建包含 randoms、a_arr 和 b_arr 的多重迭代器 it，并验证输出形状
    it = np.PyArray_MultiIterNew3(randoms, a_arr, b_arr)
    validate_output_shape(it.shape, randoms)

    # 使用锁和 nogil 上下文执行并发操作
    with lock, nogil:
        for i in range(n):
            # 获取 a_arr 和 b_arr 中的当前值 a_val 和 b_val
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            b_val = (<double*>np.PyArray_MultiIter_DATA(it, 2))[0]
            # 使用函数指针 f 处理 state、a_val 和 b_val，将结果存入 randoms_data[i]
            randoms_data[i] = f(state, a_val, b_val)

            # 将迭代器 it 推进到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回随机数数组 randoms
    return randoms
    # 如果给定的 a_constraint 不是 CONS_NONE，则检查数组 a_arr 是否符合约束条件，并报告可能的问题
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 如果给定的 b_constraint 不是 CONS_NONE，则检查数组 b_arr 是否符合约束条件，并报告可能的问题
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 如果 size 不是 None，则创建一个指定大小的空的 int64 类型的 numpy 数组 randoms
    # 否则，使用 a_arr 和 b_arr 的形状创建一个空的 int64 类型的 numpy 数组 randoms
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.int64)
    else:
        it = np.PyArray_MultiIterNew2(a_arr, b_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.int64)

    # 获取 randoms 数组的数据指针，以 int64_t* 的形式存储在 randoms_data 中
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    # 获取 randoms 数组的大小
    n = np.PyArray_SIZE(randoms)

    # 创建一个三数组迭代器，包括 randoms, a_arr, b_arr，并验证其形状是否一致
    it = np.PyArray_MultiIterNew3(randoms, a_arr, b_arr)
    validate_output_shape(it.shape, randoms)

    # 使用 lock 和 nogil 保护的上下文，迭代处理 randoms 数组中的每个元素
    with lock, nogil:
        for i in range(n):
            # 获取迭代器 it 中第二个数组 (a_arr) 当前元素的值，以 double* 形式存储在 a_val 中
            a_val = (<double*>np.PyArray_MultiIter_DATA(it, 1))[0]
            # 获取迭代器 it 中第三个数组 (b_arr) 当前元素的值，以 int64_t* 形式存储在 b_val 中
            b_val = (<int64_t*>np.PyArray_MultiIter_DATA(it, 2))[0]
            # 将调用 f(state, a_val, b_val) 的结果存储在 randoms 数组中当前元素的位置
            (<int64_t*>np.PyArray_MultiIter_DATA(it, 0))[0] = f(state, a_val, b_val)

            # 将迭代器 it 向前移动到下一个元素
            np.PyArray_MultiIter_NEXT(it)

    # 返回填充后的 randoms 数组
    return randoms
cdef object discrete_broadcast_iii(void *func, void *state, object size, object lock,
                                   np.ndarray a_arr, object a_name, constraint_type a_constraint,
                                   np.ndarray b_arr, object b_name, constraint_type b_constraint,
                                   np.ndarray c_arr, object c_name, constraint_type c_constraint):
    # 声明变量
    cdef np.ndarray randoms
    cdef int64_t *randoms_data
    cdef np.broadcast it
    cdef random_uint_iii f = (<random_uint_iii>func)
    cdef np.npy_intp i, n

    # 如果数组a有约束条件，则检查其约束条件
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 如果数组b有约束条件，则检查其约束条件
    if b_constraint != CONS_NONE:
        check_array_constraint(b_arr, b_name, b_constraint)

    # 如果数组c有约束条件，则检查其约束条件
    if c_constraint != CONS_NONE:
        check_array_constraint(c_arr, c_name, c_constraint)

    # 如果size不为None，则创建指定大小的空数组randoms
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.int64)
    else:
        # 否则，创建一个与a_arr、b_arr、c_arr广播形状相同的空数组randoms
        it = np.PyArray_MultiIterNew3(a_arr, b_arr, c_arr)
        randoms = <np.ndarray>np.empty(it.shape, np.int64)

    # 获取randoms数组的数据指针和大小
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建一个四元素多迭代器，包括randoms、a_arr、b_arr、c_arr，并验证其形状
    it = np.PyArray_MultiIterNew4(randoms, a_arr, b_arr, c_arr)
    validate_output_shape(it.shape, randoms)

    # 使用lock和nogil上下文，遍历randoms数组
    with lock, nogil:
        for i in range(n):
            # 获取当前迭代器位置处的a_arr、b_arr、c_arr的值，并调用函数f计算randoms_data[i]
            a_val = (<int64_t*>np.PyArray_MultiIter_DATA(it, 1))[0]
            b_val = (<int64_t*>np.PyArray_MultiIter_DATA(it, 2))[0]
            c_val = (<int64_t*>np.PyArray_MultiIter_DATA(it, 3))[0]
            randoms_data[i] = f(state, a_val, b_val, c_val)

            # 将迭代器移动到下一个位置
            np.PyArray_MultiIter_NEXT(it)

    # 返回计算得到的randoms数组
    return randoms


cdef object discrete_broadcast_i(void *func, void *state, object size, object lock,
                                 np.ndarray a_arr, object a_name, constraint_type a_constraint):
    # 声明变量
    cdef np.ndarray randoms
    cdef int64_t *randoms_data
    cdef np.broadcast it
    cdef random_uint_i f = (<random_uint_i>func)
    cdef np.npy_intp i, n

    # 如果数组a有约束条件，则检查其约束条件
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 如果size不为None，则创建指定大小的空数组randoms
    if size is not None:
        randoms = <np.ndarray>np.empty(size, np.int64)
    else:
        # 否则，创建一个与a_arr广播形状相同的空数组randoms
        randoms = np.PyArray_SimpleNew(np.PyArray_NDIM(a_arr), np.PyArray_DIMS(a_arr), np.NPY_INT64)

    # 获取randoms数组的数据指针和大小
    randoms_data = <int64_t *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建一个二元素多迭代器，包括randoms和a_arr，并验证其形状
    it = np.PyArray_MultiIterNew2(randoms, a_arr)
    validate_output_shape(it.shape, randoms)

    # 使用lock和nogil上下文，遍历randoms数组
    with lock, nogil:
        for i in range(n):
            # 获取当前迭代器位置处的a_arr的值，并调用函数f计算randoms_data[i]
            a_val = (<int64_t*>np.PyArray_MultiIter_DATA(it, 1))[0]
            randoms_data[i] = f(state, a_val)

            # 将迭代器移动到下一个位置
            np.PyArray_MultiIter_NEXT(it)

    # 返回计算得到的randoms数组
    return randoms
cdef object disc(void *func, void *state, object size, object lock,
                 int narg_double, int narg_int64,
                 object a, object a_name, constraint_type a_constraint,
                 object b, object b_name, constraint_type b_constraint,
                 object c, object c_name, constraint_type c_constraint):

    cdef double _da = 0, _db = 0
    cdef int64_t _ia = 0, _ib = 0, _ic = 0
    cdef bint is_scalar = True
    
    # 检查是否需要处理浮点数参数
    if narg_double > 0:
        # 从对象 `a` 中创建双精度浮点数的 NumPy 数组
        a_arr = <np.ndarray>np.PyArray_FROM_OTF(a, np.NPY_DOUBLE, np.NPY_ALIGNED)
        # 检查是否是标量（0维度）
        is_scalar = is_scalar and np.PyArray_NDIM(a_arr) == 0
        if narg_double > 1:
            # 从对象 `b` 中创建双精度浮点数的 NumPy 数组
            b_arr = <np.ndarray>np.PyArray_FROM_OTF(b, np.NPY_DOUBLE, np.NPY_ALIGNED)
            # 继续检查是否是标量
            is_scalar = is_scalar and np.PyArray_NDIM(b_arr) == 0
        elif narg_int64 == 1:
            # 否则，从对象 `b` 中创建64位整数的 NumPy 数组
            b_arr = <np.ndarray>np.PyArray_FROM_OTF(b, np.NPY_INT64, np.NPY_ALIGNED)
            # 再次检查是否是标量
            is_scalar = is_scalar and np.PyArray_NDIM(b_arr) == 0
    else:
        # 处理整数参数的情况
        if narg_int64 > 0:
            # 从对象 `a` 中创建64位整数的 NumPy 数组
            a_arr = <np.ndarray>np.PyArray_FROM_OTF(a, np.NPY_INT64, np.NPY_ALIGNED)
            # 检查是否是标量
            is_scalar = is_scalar and np.PyArray_NDIM(a_arr) == 0
        if narg_int64 > 1:
            # 从对象 `b` 中创建64位整数的 NumPy 数组
            b_arr = <np.ndarray>np.PyArray_FROM_OTF(b, np.NPY_INT64, np.NPY_ALIGNED)
            # 继续检查是否是标量
            is_scalar = is_scalar and np.PyArray_NDIM(b_arr) == 0
        if narg_int64 > 2:
            # 从对象 `c` 中创建64位整数的 NumPy 数组
            c_arr = <np.ndarray>np.PyArray_FROM_OTF(c, np.NPY_INT64, np.NPY_ALIGNED)
            # 继续检查是否是标量
            is_scalar = is_scalar and np.PyArray_NDIM(c_arr) == 0

    # 如果参数不是标量，则执行相应的广播调用
    if not is_scalar:
        if narg_int64 == 0:
            if narg_double == 1:
                # 调用专门处理双精度浮点数广播的函数
                return discrete_broadcast_d(func, state, size, lock,
                                            a_arr, a_name, a_constraint)
            elif narg_double == 2:
                # 调用专门处理双精度浮点数广播的函数
                return discrete_broadcast_dd(func, state, size, lock,
                                             a_arr, a_name, a_constraint,
                                             b_arr, b_name, b_constraint)
        elif narg_int64 == 1:
            if narg_double == 0:
                # 调用专门处理64位整数广播的函数
                return discrete_broadcast_i(func, state, size, lock,
                                            a_arr, a_name, a_constraint)
            elif narg_double == 1:
                # 调用专门处理混合参数（浮点数和整数）广播的函数
                return discrete_broadcast_di(func, state, size, lock,
                                             a_arr, a_name, a_constraint,
                                             b_arr, b_name, b_constraint)
        else:
            # 如果没有相应的向量化路径，则抛出未实现错误
            raise NotImplementedError("No vector path available")
    # 如果参数 narg_double 大于 0
    if narg_double > 0:
        # 将变量 a 转换为双精度浮点数 _da
        _da = PyFloat_AsDouble(a)
        # 如果 a 的约束条件不是 CONS_NONE 并且是标量
        if a_constraint != CONS_NONE and is_scalar:
            # 检查约束条件
            check_constraint(_da, a_name, a_constraint)

        # 如果参数个数大于 1
        if narg_double > 1:
            # 将变量 b 转换为双精度浮点数 _db
            _db = PyFloat_AsDouble(b)
            # 如果 b 的约束条件不是 CONS_NONE 并且是标量
            if b_constraint != CONS_NONE and is_scalar:
                # 检查约束条件
                check_constraint(_db, b_name, b_constraint)
        # 如果参数个数为 1 且为整型
        elif narg_int64 == 1:
            # 将变量 b 强制转换为 int64_t 类型并赋值给 _ib
            _ib = <int64_t>b
            # 如果 b 的约束条件不是 CONS_NONE 并且是标量
            if b_constraint != CONS_NONE and is_scalar:
                # 将 _ib 转换为双精度浮点数后检查约束条件
                check_constraint(<double>_ib, b_name, b_constraint)
    # 如果参数 narg_double 等于 0
    else:
        # 如果参数个数大于 0 且为整型
        if narg_int64 > 0:
            # 将变量 a 强制转换为 int64_t 类型并赋值给 _ia
            _ia = <int64_t>a
            # 如果 a 的约束条件不是 CONS_NONE 并且是标量
            if a_constraint != CONS_NONE and is_scalar:
                # 将 _ia 转换为双精度浮点数后检查约束条件
                check_constraint(<double>_ia, a_name, a_constraint)
        # 如果参数个数大于 1 且为整型
        if narg_int64 > 1:
            # 将变量 b 强制转换为 int64_t 类型并赋值给 _ib
            _ib = <int64_t>b
            # 如果 b 的约束条件不是 CONS_NONE 并且是标量
            if b_constraint != CONS_NONE and is_scalar:
                # 将 _ib 转换为双精度浮点数后检查约束条件
                check_constraint(<double>_ib, b_name, b_constraint)
        # 如果参数个数大于 2 且为整型
        if narg_int64 > 2:
            # 将变量 c 强制转换为 int64_t 类型并赋值给 _ic
            _ic = <int64_t>c
            # 如果 c 的约束条件不是 CONS_NONE 并且是标量
            if c_constraint != CONS_NONE and is_scalar:
                # 将 _ic 转换为双精度浮点数后检查约束条件
                check_constraint(<double>_ic, c_name, c_constraint)

    # 如果 size 为 None
    if size is None:
        # 在锁的保护下
        with lock:
            # 如果整型参数个数为 0
            if narg_int64 == 0:
                # 返回使用状态 state 调用 <random_uint_0>func 的结果
                return (<random_uint_0>func)(state)
            # 如果整型参数个数为 1
            elif narg_int64 == 1:
                # 如果双精度浮点数参数个数为 0
                if narg_double == 0:
                    # 返回使用状态 state 和 _ia 调用 <random_uint_i>func 的结果
                    return (<random_uint_i>func)(state, _ia)
                # 如果双精度浮点数参数个数为 1
                elif narg_double == 1:
                    # 返回使用状态 state、_da 和 _ib 调用 <random_uint_di>func 的结果
                    return (<random_uint_di>func)(state, _da, _ib)
                # 如果双精度浮点数参数个数为 2
                elif narg_double == 2:
                    # 返回使用状态 state、_da 和 _db 调用 <random_uint_dd>func 的结果
                    return (<random_uint_dd>func)(state, _da, _db)
            # 如果整型参数个数大于 1
            else:
                # 返回使用状态 state、_ia、_ib 和 _ic 调用 <random_uint_iii>func 的结果
                return (<random_uint_iii>func)(state, _ia, _ib, _ic)

    # 声明 np.npy_intp 类型的 i 和 n 变量
    cdef np.npy_intp i, n
    # 声明一个形状为 size、数据类型为 np.int64 的 numpy 数组 randoms
    cdef np.ndarray randoms = <np.ndarray>np.empty(size, np.int64)
    # 声明一个指向 randoms 数据的指针 randoms_data
    cdef np.int64_t *randoms_data
    # 声明 random_uint_0 到 random_uint_iii 的函数指针变量
    cdef random_uint_0 f0
    cdef random_uint_d fd
    cdef random_uint_dd fdd
    cdef random_uint_di fdi
    cdef random_uint_i fi
    cdef random_uint_iii fiii

    # 获取 randoms 数组的大小
    n = np.PyArray_SIZE(randoms)
    # 获取 randoms 数组的数据指针
    randoms_data = <np.int64_t *>np.PyArray_DATA(randoms)
    # 使用 lock 和 nogil 上下文来确保并发安全性
    with lock, nogil:
        # 根据参数数量选择合适的随机函数进行初始化
        if narg_int64 == 0:
            if narg_double == 0:
                # 初始化使用无浮点参数的随机函数
                f0 = (<random_uint_0>func)
                # 对于指定数量的数据点，生成随机数并存储到数组中
                for i in range(n):
                    randoms_data[i] = f0(state)
            elif narg_double == 1:
                # 初始化使用一个浮点参数的随机函数
                fd = (<random_uint_d>func)
                # 对于指定数量的数据点，生成随机数并存储到数组中
                for i in range(n):
                    randoms_data[i] = fd(state, _da)
            elif narg_double == 2:
                # 初始化使用两个浮点参数的随机函数
                fdd = (<random_uint_dd>func)
                # 对于指定数量的数据点，生成随机数并存储到数组中
                for i in range(n):
                    randoms_data[i] = fdd(state, _da, _db)
        elif narg_int64 == 1:
            if narg_double == 0:
                # 初始化使用一个整数参数的随机函数
                fi = (<random_uint_i>func)
                # 对于指定数量的数据点，生成随机数并存储到数组中
                for i in range(n):
                    randoms_data[i] = fi(state, _ia)
            if narg_double == 1:
                # 初始化使用一个整数和一个浮点参数的随机函数
                fdi = (<random_uint_di>func)
                # 对于指定数量的数据点，生成随机数并存储到数组中
                for i in range(n):
                    randoms_data[i] = fdi(state, _da, _ib)
        else:
            # 初始化使用三个整数参数的随机函数
            fiii = (<random_uint_iii>func)
            # 对于指定数量的数据点，生成随机数并存储到数组中
            for i in range(n):
                randoms_data[i] = fiii(state, _ia, _ib, _ic)

    # 返回生成的随机数数组
    return randoms
# 定义一个Cython函数，用于处理连续型随机变量的抽样操作
cdef object cont_broadcast_1_f(void *func, bitgen_t *state, object size, object lock,
                               np.ndarray a_arr, object a_name, constraint_type a_constraint,
                               object out):

    # 声明变量
    cdef np.ndarray randoms  # 存储随机数结果的NumPy数组
    cdef float a_val  # 存储单个随机数值的变量
    cdef float *randoms_data  # 指向随机数数组数据的指针
    cdef np.broadcast it  # 广播对象，用于迭代处理数组
    cdef random_float_1 f = (<random_float_1>func)  # 强制类型转换为特定的随机数生成函数
    cdef np.npy_intp i, n  # 用于迭代的整数变量

    # 检查是否存在约束条件，并根据约束条件检查数组
    if a_constraint != CONS_NONE:
        check_array_constraint(a_arr, a_name, a_constraint)

    # 根据不同情况初始化随机数数组
    if size is not None and out is None:
        randoms = <np.ndarray>np.empty(size, np.float32)
    elif out is None:
        randoms = np.PyArray_SimpleNew(np.PyArray_NDIM(a_arr),
                                       np.PyArray_DIMS(a_arr),
                                       np.NPY_FLOAT32)
    else:
        randoms = <np.ndarray>out

    # 获取随机数数组的数据指针及其大小
    randoms_data = <float *>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    # 创建一个多迭代器对象，用于同时迭代两个数组
    it = np.PyArray_MultiIterNew2(randoms, a_arr)

    # 验证输出形状是否符合预期
    validate_output_shape(it.shape, randoms)

    # 使用锁和无GIL状态，迭代处理数组元素
    with lock, nogil:
        for i in range(n):
            # 获取当前迭代位置的数组元素值，并调用指定的随机数生成函数进行处理
            a_val = (<float*>np.PyArray_MultiIter_DATA(it, 1))[0]
            randoms_data[i] = f(state, a_val)

            # 移动到迭代器的下一个元素位置
            np.PyArray_MultiIter_NEXT(it)

    # 返回生成的随机数数组
    return randoms


# 定义另一个Cython函数，用于处理单个随机变量的抽样操作
cdef object cont_f(void *func, bitgen_t *state, object size, object lock,
                   object a, object a_name, constraint_type a_constraint,
                   object out):

    # 声明变量
    cdef np.ndarray a_arr, b_arr, c_arr  # 输入参数的NumPy数组
    cdef float _a  # 存储单个浮点数值的变量
    cdef bint is_scalar = True  # 标志变量，指示是否为标量
    cdef int requirements = np.NPY_ALIGNED | np.NPY_FORCECAST  # 数组要求标志
    check_output(out, np.float32, size, True)  # 检查输出数组是否符合预期的要求
    a_arr = <np.ndarray>np.PyArray_FROMANY(a, np.NPY_FLOAT32, 0, 0, requirements)  # 将输入参数a转换为NumPy数组
    is_scalar = np.PyArray_NDIM(a_arr) == 0  # 检查a_arr是否为标量

    # 如果a_arr不是标量，则调用cont_broadcast_1_f处理
    if not is_scalar:
        return cont_broadcast_1_f(func, state, size, lock, a_arr, a_name, a_constraint, out)

    # 将a转换为浮点数，并根据约束条件检查其值
    _a = <float>PyFloat_AsDouble(a)
    if a_constraint != CONS_NONE:
        check_constraint(_a, a_name, a_constraint)

    # 根据size和out的情况初始化随机数数组
    if size is None and out is None:
        with lock:
            return (<random_float_1>func)(state, _a)

    cdef np.npy_intp i, n  # 迭代器变量
    cdef np.ndarray randoms  # 存储随机数结果的NumPy数组

    # 根据out的情况初始化随机数数组
    if out is None:
        randoms = <np.ndarray>np.empty(size, np.float32)
    else:
        randoms = <np.ndarray>out

    n = np.PyArray_SIZE(randoms)  # 获取随机数数组的大小

    cdef float *randoms_data = <float *>np.PyArray_DATA(randoms)  # 获取随机数数组的数据指针
    cdef random_float_1 f1 = <random_float_1>func  # 强制类型转换为特定的随机数生成函数

    # 使用锁和无GIL状态，迭代处理数组元素
    with lock, nogil:
        for i in range(n):
            randoms_data[i] = f1(state, _a)

    # 根据out的情况返回结果数组
    if out is None:
        return randoms
    else:
        return out
```