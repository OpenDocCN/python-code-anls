# `.\numpy\numpy\linalg\lapack_lite\f2c_d_lapack.c`

```
/*
 * NOTE: This is generated code. Look in numpy/linalg/lapack_lite for
 *       information on remaking this file.
 */
#include "f2c.h"

#ifdef HAVE_CONFIG
#include "config.h"
#else
extern doublereal dlamch_(char *);
#define EPSILON dlamch_("Epsilon")
#define SAFEMINIMUM dlamch_("Safe minimum")
#define PRECISION dlamch_("Precision")
#define BASE dlamch_("Base")
#endif

extern doublereal dlapy2_(doublereal *x, doublereal *y);

/*
f2c knows the exact rules for precedence, and so omits parentheses where not
strictly necessary. Since this is generated code, we don't really care if
it's readable, and we know what is written is correct. So don't warn about
them.
*/
#if defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

/* Table of constant values */

static integer c__9 = 9;             // 定义整数常量 c__9 并赋值为 9
static integer c__0 = 0;             // 定义整数常量 c__0 并赋值为 0
static doublereal c_b15 = 1.;        // 定义双精度浮点常量 c_b15 并赋值为 1.0
static integer c__1 = 1;             // 定义整数常量 c__1 并赋值为 1
static doublereal c_b29 = 0.;        // 定义双精度浮点常量 c_b29 并赋值为 0.0
static doublereal c_b94 = -.125;     // 定义双精度浮点常量 c_b94 并赋值为 -0.125
static doublereal c_b151 = -1.;      // 定义双精度浮点常量 c_b151 并赋值为 -1.0
static integer c_n1 = -1;            // 定义整数常量 c_n1 并赋值为 -1
static integer c__3 = 3;             // 定义整数常量 c__3 并赋值为 3
static integer c__2 = 2;             // 定义整数常量 c__2 并赋值为 2
static integer c__65 = 65;           // 定义整数常量 c__65 并赋值为 65
static integer c__6 = 6;             // 定义整数常量 c__6 并赋值为 6
static integer c__12 = 12;           // 定义整数常量 c__12 并赋值为 12
static integer c__49 = 49;           // 定义整数常量 c__49 并赋值为 49
static integer c__4 = 4;             // 定义整数常量 c__4 并赋值为 4
static logical c_false = FALSE_;     // 定义逻辑常量 c_false 并赋值为 FALSE
static integer c__13 = 13;           // 定义整数常量 c__13 并赋值为 13
static integer c__15 = 15;           // 定义整数常量 c__15 并赋值为 15
static integer c__14 = 14;           // 定义整数常量 c__14 并赋值为 14
static integer c__16 = 16;           // 定义整数常量 c__16 并赋值为 16
static logical c_true = TRUE_;       // 定义逻辑常量 c_true 并赋值为 TRUE
static integer c__10 = 10;           // 定义整数常量 c__10 并赋值为 10
static integer c__11 = 11;           // 定义整数常量 c__11 并赋值为 11
static doublereal c_b3192 = 2.;      // 定义双精度浮点常量 c_b3192 并赋值为 2.0

/* Subroutine */ int dbdsdc_(char *uplo, char *compq, integer *n, doublereal *
    d__, doublereal *e, doublereal *u, integer *ldu, doublereal *vt,
    integer *ldvt, doublereal *q, integer *iq, doublereal *work, integer *
    iwork, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k;
    static doublereal p, r__;
    static integer z__, ic, ii, kk;
    static doublereal cs;
    static integer is, iu;
    static doublereal sn;
    static integer nm1;
    static doublereal eps;
    static integer ivt, difl, difr, ierr, perm, mlvl, sqre;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dlasr_(char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *), dcopy_(integer *, doublereal *, integer *
        , doublereal *, integer *), dswap_(integer *, doublereal *,
        integer *, doublereal *, integer *);
    static integer poles, iuplo, nsize, start;
    extern /* Subroutine */ int dlasd0_(integer *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        integer *, integer *, doublereal *, integer *);



注：以上是对给定的 C 语言代码进行逐行注释的结果。
    extern /* Subroutine */ int dlasda_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         integer *), dlascl_(char *, integer *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *);
    ! 外部函数声明：dlasda, dlascl

    extern /* Subroutine */ int dlasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, doublereal *, doublereal *, doublereal *,
         integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *);
    ! 外部函数声明：dlasdq

    extern /* Subroutine */ int dlaset_(char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *);
    ! 外部函数声明：dlaset

    extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *);
    ! 外部函数声明：dlartg

    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 外部函数声明：ilaenv

    extern /* Subroutine */ int xerbla_(char *, integer *);
    ! 外部函数声明：xerbla

    static integer givcol;
    ! 静态变量声明：givcol

    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    ! 外部函数声明：dlanst

    static integer icompq;
    ! 静态变量声明：icompq

    static doublereal orgnrm;
    ! 静态变量声明：orgnrm

    static integer givnum, givptr, qstart, smlsiz, wstart, smlszp;
    ! 静态变量声明：givnum, givptr, qstart, smlsiz, wstart, smlszp
"""
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DBDSDC computes the singular value decomposition (SVD) of a real
    N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
    using a divide and conquer method, where S is a diagonal matrix
    with non-negative diagonal elements (the singular values of B), and
    U and VT are orthogonal matrices of left and right singular vectors,
    respectively. DBDSDC can be used to compute all singular values,
    and optionally, singular vectors or singular vectors in compact form.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See DLASD3 for details.

    The code currently calls DLASDQ if singular values only are desired.
    However, it can be slightly modified to compute singular values
    using the divide and conquer method.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  B is upper bidiagonal.
            = 'L':  B is lower bidiagonal.

    COMPQ   (input) CHARACTER*1
            Specifies whether singular vectors are to be computed
            as follows:
            = 'N':  Compute singular values only;
            = 'P':  Compute singular values and compute singular
                    vectors in compact form;
            = 'I':  Compute singular values and singular vectors.

    N       (input) INTEGER
            The order of the matrix B.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the elements of E contain the offdiagonal
            elements of the bidiagonal matrix whose SVD is desired.
            On exit, E has been destroyed.

    U       (output) DOUBLE PRECISION array, dimension (LDU,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, U contains the left singular vectors
               of the bidiagonal matrix.
            For other values of COMPQ, U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU >= 1.
            If singular vectors are desired, then LDU >= max( 1, N ).
"""
    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, VT' contains the right singular
               vectors of the bidiagonal matrix.
            For other values of COMPQ, VT is not referenced.


    # 输出参数 VT，是一个双精度数组，维度为 (LDVT,N)
    # 如果 COMPQ = 'I'，则：
    # 在退出时，如果 INFO = 0，VT' 包含双对角矩阵的右奇异向量。
    # 对于 COMPQ 的其他值，VT 不被引用。



    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT >= 1.
            If singular vectors are desired, then LDVT >= max( 1, N ).


    # 输入参数 LDVT，是整数
    # 数组 VT 的主导维度。LDVT >= 1。
    # 如果需要奇异向量，则 LDVT >= max( 1, N )。



    Q       (output) DOUBLE PRECISION array, dimension (LDQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, Q contains all the DOUBLE PRECISION data in
               LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, Q is not referenced.


    # 输出参数 Q，是一个双精度数组，维度为 (LDQ)
    # 如果 COMPQ = 'P'，则：
    # 在退出时，如果 INFO = 0，Q 和 IQ 以紧凑形式包含左右奇异向量，
    # 需要 O(N log N) 的空间，而不是 2*N**2。
    # 具体而言，Q 包含所有的双精度数据，要求 LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
    # 字节的内存空间，其中 SMLSIZ 由 ILAENV 返回，并且等于计算树底部子问题的最大大小（通常约为 25）。
    # 对于 COMPQ 的其他值，Q 不被引用。



    IQ      (output) INTEGER array, dimension (LDIQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, IQ contains all INTEGER data in
               LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, IQ is not referenced.


    # 输出参数 IQ，是一个整数数组，维度为 (LDIQ)
    # 如果 COMPQ = 'P'，则：
    # 在退出时，如果 INFO = 0，Q 和 IQ 以紧凑形式包含左右奇异向量，
    # 需要 O(N log N) 的空间，而不是 2*N**2。
    # 具体而言，IQ 包含所有的整数数据，要求 LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
    # 字节的内存空间，其中 SMLSIZ 由 ILAENV 返回，并且等于计算树底部子问题的最大大小（通常约为 25）。
    # 对于 COMPQ 的其他值，IQ 不被引用。



    WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            If COMPQ = 'N' then LWORK >= (4 * N).
            If COMPQ = 'P' then LWORK >= (6 * N).
            If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).


    # 工作空间参数 WORK，是一个双精度数组，维度为 (MAX(1,LWORK))
    # 如果 COMPQ = 'N'，则 LWORK >= (4 * N)。
    # 如果 COMPQ = 'P'，则 LWORK >= (6 * N)。
    # 如果 COMPQ = 'I'，则 LWORK >= (3 * N**2 + 4 * N)。



    IWORK   (workspace) INTEGER array, dimension (8*N)


    # 工作空间参数 IWORK，是一个整数数组，维度为 (8*N)



    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute a singular value.
                  The update process of divide and conquer failed.


    # 输出参数 INFO，是一个整数
    # = 0: 成功退出。
    # < 0: 如果 INFO = -i，则第 i 个参数的值非法。
    # > 0: 算法未能计算奇异值。
    #      分割与征服的更新过程失败。



    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================
    Changed dimension statement in comment describing E from (N) to
    (N-1).  Sven, 17 Feb 05.
    =====================================================================


    # 进一步细节
    # ===============
    # 基于以下贡献：
    #    Ming Gu 和 Huan Ren，加州大学伯克利分校，美国计算机科学系
    # =====================================================================
    # 在描述 E 的注释中，将维度声明从 (N) 更改为 (N-1)。Sven, 2005年2月17日。
    # =====================================================================



       Test the input parameters.


    # 测试输入参数。
    /* Parameter adjustments */
    --d__;
    --e;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --q;
    --iq;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;

    iuplo = 0;
    if (lsame_(uplo, "U")) {
        iuplo = 1;
    }
    if (lsame_(uplo, "L")) {
        iuplo = 2;
    }
    if (lsame_(compq, "N")) {
        icompq = 0;
    } else if (lsame_(compq, "P")) {
        icompq = 1;
    } else if (lsame_(compq, "I")) {
        icompq = 2;
    } else {
        icompq = -1;
    }
    if (iuplo == 0) {
        *info = -1;
    } else if (icompq < 0) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*ldu < 1 || icompq == 2 && *ldu < *n) {
        *info = -7;
    } else if (*ldvt < 1 || icompq == 2 && *ldvt < *n) {
        *info = -9;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DBDSDC", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }
    smlsiz = ilaenv_(&c__9, "DBDSDC", " ", &c__0, &c__0, &c__0, &c__0, (ftnlen)6, (ftnlen)1);
    if (*n == 1) {
        if (icompq == 1) {
            q[1] = d_sign(&c_b15, &d__[1]);
            q[smlsiz * *n + 1] = 1.;
        } else if (icompq == 2) {
            u[u_dim1 + 1] = d_sign(&c_b15, &d__[1]);
            vt[vt_dim1 + 1] = 1.;
        }
        d__[1] = abs(d__[1]);
        return 0;
    }
    nm1 = *n - 1;

    /* If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left */
    wstart = 1;
    qstart = 3;
    if (icompq == 1) {
        dcopy_(n, &d__[1], &c__1, &q[1], &c__1);
        i__1 = *n - 1;
        dcopy_(&i__1, &e[1], &c__1, &q[*n + 1], &c__1);
    }
    if (iuplo == 2) {
        qstart = 5;
        wstart = (*n << 1) - 1;
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {
            dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__);
            d__[i__] = r__;
            e[i__] = sn * d__[i__ + 1];
            d__[i__ + 1] = cs * d__[i__ + 1];
            if (icompq == 1) {
                q[i__ + (*n << 1)] = cs;
                q[i__ + *n * 3] = sn;
            } else if (icompq == 2) {
                work[i__] = cs;
                work[nm1 + i__] = -sn;
            }
        }
    }

    /* If ICOMPQ = 0, use DLASDQ to compute the singular values. */
    if (icompq == 0) {
        dlasdq_("U", &c__0, n, &c__0, &c__0, &c__0, &d__[1], &e[1], &vt[vt_offset], ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[wstart], info);
        goto L40;
    }

    /* If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver. */
    if (*n <= smlsiz) {
        if (icompq == 2) {
            dlaset_("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
            dlaset_("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
            dlasdq_("U", &c__0, n, n, n, &c__0, &d__[1], &e[1], &vt[vt_offset], ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[wstart], info);
    // 如果 icompq 等于 1，则执行以下操作
    } else if (icompq == 1) {
        // 设置矩阵索引
        iu = 1;
        ivt = iu + *n;
        // 设置 Q 矩阵的初始值为零
        dlaset_("A", n, n, &c_b29, &c_b15, &q[iu + (qstart - 1) * *n], n);
        // 设置 Q 矩阵的初始值为零
        dlaset_("A", n, n, &c_b29, &c_b15, &q[ivt + (qstart - 1) * *n], n);
        // 调用 SVD 过程中的特征值分解计算
        dlasdq_("U", &c__0, n, n, n, &c__0, &d__[1], &e[1], &q[ivt + (
            qstart - 1) * *n], n, &q[iu + (qstart - 1) * *n], n, &q[
            iu + (qstart - 1) * *n], n, &work[wstart], info);
    }
    // 转到 L40 标签处执行
    goto L40;
    }

    // 如果 icompq 等于 2，则执行以下操作
    if (icompq == 2) {
        // 设置 U 矩阵的初始值为零
        dlaset_("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
        // 设置 VT 矩阵的初始值为零
        dlaset_("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
    }
/*     Scale. */

/* 计算范数，用于后续的数值缩放 */
    orgnrm = dlanst_("M", n, &d__[1], &e[1]);
/* 如果计算得到的范数为0，则直接返回0 */
    if (orgnrm == 0.) {
        return 0;
    }
/* 对角元素缩放 */
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, &c__1, &d__[1], n, &ierr);
/* 次对角元素缩放 */
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &nm1, &c__1, &e[1], &nm1, &
        ierr);

/* 设置机器精度 */
    eps = EPSILON;

/* 计算要进行的分裂次数 */
    mlvl = (integer) (log((doublereal) (*n) / (doublereal) (smlsiz + 1)) /
        log(2.)) + 1;
/* 计算小规模问题的大小 */
    smlszp = smlsiz + 1;

/* 如果需要计算Q矩阵，则进行以下设置 */
    if (icompq == 1) {
        iu = 1;
        ivt = smlsiz + 1;
        difl = ivt + smlszp;
        difr = difl + mlvl;
        z__ = difr + (mlvl << 1);
        ic = z__ + mlvl;
        is = ic + 1;
        poles = is + 1;
        givnum = poles + (mlvl << 1);

        k = 1;
        givptr = 2;
        perm = 3;
        givcol = perm + mlvl;
    }

/* 对角元素进行检查，若小于机器精度则进行修正 */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if ((d__1 = d__[i__], abs(d__1)) < eps) {
            d__[i__] = d_sign(&eps, &d__[i__]);
        }
/* L20: */
    }

/* 初始化子问题的起始位置和标志 */
    start = 1;
    sqre = 0;

/* 开始主循环，处理每一个子问题 */
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if ((d__1 = e[i__], abs(d__1)) < eps || i__ == nm1) {

/* 发现一个子问题，首先确定其大小，然后应用分治法 */
            if (i__ < nm1) {

/*        对于E(I)在I<NM1的情况，确定子问题的大小 */
                nsize = i__ - start + 1;
            } else if ((d__1 = e[i__], abs(d__1)) >= eps) {

/*        对于E(NM1)不太小且I=NM1的情况，确定子问题的大小 */
                nsize = *n - start + 1;
            } else {

/*
          对于E(NM1)很小的情况，这意味着在D(N)处有一个1×1子问题。先解决这个1×1问题。
*/
                nsize = i__ - start + 1;
                if (icompq == 2) {
                    u[*n + *n * u_dim1] = d_sign(&c_b15, &d__[*n]);
                    vt[*n + *n * vt_dim1] = 1.;
                } else if (icompq == 1) {
                    q[*n + (qstart - 1) * *n] = d_sign(&c_b15, &d__[*n]);
                    q[*n + (smlsiz + qstart - 1) * *n] = 1.;
                }
                d__[*n] = (d__1 = d__[*n], abs(d__1));
            }
/* 根据不同的ICOMPQ值，调用不同的子程序解决子问题 */
            if (icompq == 2) {
                dlasd0_(&nsize, &sqre, &d__[start], &e[start], &u[start +
                    start * u_dim1], ldu, &vt[start + start * vt_dim1],
                    ldvt, &smlsiz, &iwork[1], &work[wstart], info);
            } else {
                dlasda_(&icompq, &smlsiz, &nsize, &sqre, &d__[start], &e[
                    start], &q[start + (iu + qstart - 2) * *n], n, &q[
                    start + (ivt + qstart - 2) * *n], &iq[start + k * *n],
                     &q[start + (difl + qstart - 2) * *n], &q[start + (
                    difr + qstart - 2) * *n], &q[start + (z__ + qstart -
                    2) * *n], &q[start + (poles + qstart - 2) * *n], &iq[
                    start + givptr * *n], &iq[start + givcol * *n], n, &
                    iq[start + perm * *n], &q[start + (givnum + qstart -
                    2) * *n], &q[start + (ic + qstart - 2) * *n], &q[
                    start + (is + qstart - 2) * *n], &work[wstart], &
                    iwork[1], info);
            }
/* 若信息标志不为0，则返回 */
            if (*info != 0) {
                return 0;
            }
/* 更新起始位置 */
            start = i__ + 1;
        }
/* L30: */
    }
/*     Unscale */
/*
       执行对称矩阵对角化的过程中，将对角元素缩放回原始的规模
*/

    dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n, &ierr);
L40:

/*     Use Selection Sort to minimize swaps of singular vectors */
/*
       使用选择排序算法来最小化奇异向量的交换次数
*/

    i__1 = *n;
    for (ii = 2; ii <= i__1; ++ii) {
    i__ = ii - 1;
    kk = i__;
    p = d__[i__];
    i__2 = *n;
    for (j = ii; j <= i__2; ++j) {
        if (d__[j] > p) {
        kk = j;
        p = d__[j];
        }
/* L50: */
    }
    if (kk != i__) {
        d__[kk] = d__[i__];
        d__[i__] = p;
        if (icompq == 1) {
        iq[i__] = kk;
        } else if (icompq == 2) {
        dswap_(n, &u[i__ * u_dim1 + 1], &c__1, &u[kk * u_dim1 + 1], &
            c__1);
        dswap_(n, &vt[i__ + vt_dim1], ldvt, &vt[kk + vt_dim1], ldvt);
        }
    } else if (icompq == 1) {
        iq[i__] = i__;
    }
/* L60: */
    }

/*     If ICOMPQ = 1, use IQ(N,1) as the indicator for UPLO */
/*
       如果 ICOMPQ = 1，则使用 IQ(N) 作为 UPLO 的指示器
*/

    if (icompq == 1) {
    if (iuplo == 1) {
        iq[*n] = 1;
    } else {
        iq[*n] = 0;
    }
    }

/*
       If B is lower bidiagonal, update U by those Givens rotations
       which rotated B to be upper bidiagonal
*/
/*
       如果 B 是下三角双对角矩阵，则使用旋转矩阵更新 U，
       这些旋转矩阵将 B 旋转成上三角双对角矩阵
*/

    if (iuplo == 2 && icompq == 2) {
    dlasr_("L", "V", "B", n, n, &work[1], &work[*n], &u[u_offset], ldu);
    }

    return 0;

/*     End of DBDSDC */

} /* dbdsdc_ */

/* Subroutine */ int dbdsqr_(char *uplo, integer *n, integer *ncvt, integer *
    nru, integer *ncc, doublereal *d__, doublereal *e, doublereal *vt,
    integer *ldvt, doublereal *u, integer *ldu, doublereal *c__, integer *
    ldc, doublereal *work, integer *info)
{
    /* System generated locals */
    integer c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    static doublereal f, g, h__;
    static integer i__, j, m;
    static doublereal r__, cs;
    static integer ll;
    static doublereal sn, mu;
    static integer nm1, nm12, nm13, lll;
    static doublereal eps, sll, tol, abse;
    static integer idir;
    static doublereal abss;
    static integer oldm;
    static doublereal cosl;
    static integer isub, iter;
    static doublereal unfl, sinl, cosr, smin, smax, sinr;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *), dlas2_(
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *), dscal_(integer *, doublereal *, doublereal *,
        integer *);
    extern logical lsame_(char *, char *);
    static doublereal oldcs;
    extern /* Subroutine */ int dlasr_(char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *);
    static integer oldll;
    static doublereal shift, sigmn, oldsn;
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer maxit;
    static doublereal sminl, sigmx;
    static logical lower;
    ! 外部子程序声明：计算特定任务的一维雅各比法过程的第一步
    extern /* Subroutine */ int dlasq1_(integer *, doublereal *, doublereal *,
         doublereal *, integer *);

    ! 外部子程序声明：计算两个实数的奇异值分解中的旋转
    extern /* Subroutine */ int dlasv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);

    ! 外部子程序声明：计算给定两个实数的旋转
    extern /* Subroutine */ int dlartg_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);

    ! 外部子程序声明：处理错误信息的外部子程序
    extern /* Subroutine */ int xerbla_(char *,
        integer *);

    ! 静态变量声明：存储最小值和阈值
    static doublereal sminoa, thresh;

    ! 静态变量声明：标志变量，指示是否需要旋转
    static logical rotate;

    ! 静态变量声明：容差乘法因子
    static doublereal tolmul;
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   January 2007


Purpose
=======
DBDSQR computes the singular values and, optionally, the right and/or
left singular vectors from the singular value decomposition (SVD) of
a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
zero-shift QR algorithm.  The SVD of B has the form

   B = Q * S * P**T

where S is the diagonal matrix of singular values, Q is an orthogonal
matrix of left singular vectors, and P is an orthogonal matrix of
right singular vectors.  If left singular vectors are requested, this
subroutine actually returns U*Q instead of Q, and, if right singular
vectors are requested, this subroutine returns P**T*VT instead of
P**T, for given real input matrices U and VT.  When U and VT are the
orthogonal matrices that reduce a general matrix A to bidiagonal
form:  A = U*B*VT, as computed by DGEBRD, then

   A = (U*Q) * S * (P**T*VT)

is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
for a given real input matrix C.

See "Computing  Small Singular Values of Bidiagonal Matrices With
Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
no. 5, pp. 873-912, Sept 1990) and
"Accurate singular values and differential qd algorithms," by
B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
Department, University of California at Berkeley, July 1992
for a detailed description of the algorithm.

Arguments
=========
UPLO    (input) CHARACTER*1
        = 'U':  B is upper bidiagonal;
        = 'L':  B is lower bidiagonal.

N       (input) INTEGER
        The order of the matrix B.  N >= 0.

NCVT    (input) INTEGER
        The number of columns of the matrix VT. NCVT >= 0.

NRU     (input) INTEGER
        The number of rows of the matrix U. NRU >= 0.

NCC     (input) INTEGER
        The number of columns of the matrix C. NCC >= 0.

D       (input/output) DOUBLE PRECISION array, dimension (N)
        On entry, the n diagonal elements of the bidiagonal matrix B.
        On exit, if INFO=0, the singular values of B in decreasing
        order.

E       (input/output) DOUBLE PRECISION array, dimension (N-1)
        On entry, the N-1 offdiagonal elements of the bidiagonal
        matrix B.
        On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
        will contain the diagonal and superdiagonal elements of a
        bidiagonal matrix orthogonally equivalent to the one given
        as input.
"""
    # VT 是一个 N × NCVT 的矩阵，在函数调用前是输入参数，在函数返回后被 P 的转置乘积覆盖
    VT      (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
    
    # VT 数组的第一个维度
    LDVT    (input) INTEGER
            The leading dimension of the array VT.
            LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
    
    # U 是一个 NRU × N 的矩阵，在函数调用前是输入参数，在函数返回后被 U 乘以 Q 覆盖
    U       (input/output) DOUBLE PRECISION array, dimension (LDU, N)
    
    # U 数组的第一个维度
    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU >= max(1,NRU).
    
    # C 是一个 N × NCC 的矩阵，在函数调用前是输入参数，在函数返回后被 Q 的转置乘积覆盖
    C       (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
    
    # C 数组的第一个维度
    LDC     (input) INTEGER
            The leading dimension of the array C.
            LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
    
    # WORK 是一个长度为 4*N 的工作空间数组
    WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
    
    # INFO 是一个输出参数，用于指示函数执行状态
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  If INFO = -i, the i-th argument had an illegal value
            > 0:
               if NCVT = NRU = NCC = 0,
                  = 1, a split was marked by a positive value in E
                  = 2, current block of Z not diagonalized after 30*N
                       iterations (in inner while loop)
                  = 3, termination criterion of outer while loop not met
                       (program created more than N unreduced blocks)
               else NCVT = NRU = NCC = 0,
                     the algorithm did not converge; D and E contain the
                     elements of a bidiagonal matrix which is orthogonally
                     similar to the input matrix B;  if INFO = i, i
                     elements of E have not converged to zero.
    
    # TOLMUL 是一个内部参数，用于控制 QR 算法的收敛性标准
    # 默认值是 max(10, min(100, EPS**(-1/8)))
    # TOLMUL 控制 QR 循环的收敛标准
    # 如果为正数，TOLMUL*EPS 是计算奇异值的期望相对精度
    # 如果为负数，abs(TOLMUL*EPS*sigma_max) 是计算奇异值的期望绝对精度
    # abs(TOLMUL) 应在 1 到 1/EPS 之间，并且最好在 10 到 0.1/EPS 之间
    # 默认值导致在每个计算的奇异值中失去八分之一或二分之一的可用十进制位数
    Internal Parameters
    ===================
    # 设置整数型变量 MAXITR，默认值为 6
    # MAXITR 控制算法通过其内部循环的最大次数。
    # 如果通过内部循环的次数超过 MAXITR*N**2，算法将停止（因此无法收敛）。

    =====================================================================


    # 测试输入参数。
    /* Parameter adjustments */
    --d__;              // 调整参数d__
    --e;                // 调整参数e
    vt_dim1 = *ldvt;    // 计算vt的第一维度大小
    vt_offset = 1 + vt_dim1;  // 计算vt的偏移量
    vt -= vt_offset;    // 调整参数vt

    u_dim1 = *ldu;      // 计算u的第一维度大小
    u_offset = 1 + u_dim1;    // 计算u的偏移量
    u -= u_offset;      // 调整参数u

    c_dim1 = *ldc;      // 计算c的第一维度大小
    c_offset = 1 + c_dim1;    // 计算c的偏移量
    c__ -= c_offset;    // 调整参数c

    --work;             // 调整参数work

    /* Function Body */
    *info = 0;          // 初始化info为0
    lower = lsame_(uplo, "L");   // 判断uplo是否为"L"，确定lower是否为真值
    if (! lsame_(uplo, "U") && ! lower) {    // 如果uplo不为"U"且lower也不为真，则设置info为-1
        *info = -1;
    } else if (*n < 0) {    // 如果n小于0，则设置info为-2
        *info = -2;
    } else if (*ncvt < 0) { // 如果ncvt小于0，则设置info为-3
        *info = -3;
    } else if (*nru < 0) {  // 如果nru小于0，则设置info为-4
        *info = -4;
    } else if (*ncc < 0) {  // 如果ncc小于0，则设置info为-5
        *info = -5;
    } else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < max(1,*n)) {  // 根据ncvt和ldvt的值设置info为-9
        *info = -9;
    } else if (*ldu < max(1,*nru)) {    // 如果ldu小于max(1, nru)，则设置info为-11
        *info = -11;
    } else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < max(1,*n)) { // 根据ncc和ldc的值设置info为-13
        *info = -13;
    }
    if (*info != 0) {   // 如果info不为0，则调用xerbla_函数报错并返回
        i__1 = -(*info);
        xerbla_("DBDSQR", &i__1);
        return 0;
    }
    if (*n == 0) {      // 如果n为0，则直接返回
        return 0;
    }
    if (*n == 1) {      // 如果n为1，则跳转到标签L160处执行
        goto L160;
    }

/*     ROTATE is true if any singular vectors desired, false otherwise */

    rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;    // 根据ncvt, nru, ncc的值确定rotate是否为真

/*     If no singular vectors desired, use qd algorithm */

    if (! rotate) {     // 如果不需要任何奇异向量，则调用dlasq1_函数并返回
        dlasq1_(n, &d__[1], &e[1], &work[1], info);
        return 0;
    }

    nm1 = *n - 1;       // 计算n-1的值
    nm12 = nm1 + nm1;   // 计算2*(n-1)的值
    nm13 = nm12 + nm1;  // 计算3*(n-1)的值
    idir = 0;           // 初始化idir为0

/*     Get machine constants */

    eps = EPSILON;      // 获取机器精度常数eps
    unfl = SAFEMINIMUM; // 获取机器下限常数unfl

/*
       If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left
*/

    if (lower) {        // 如果lower为真，则将矩阵旋转为上Hessenberg形式
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) { // 循环应用Givens旋转到左边
            dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__); // 计算Givens旋转参数
            d__[i__] = r__;                         // 更新d
            e[i__] = sn * d__[i__ + 1];             // 更新e
            d__[i__ + 1] = cs * d__[i__ + 1];       // 更新d
            work[i__] = cs;                         // 存储旋转角度cos
            work[nm1 + i__] = sn;                   // 存储旋转角度sin
        /* L10: */                                 // 标签L10
        }

/*        Update singular vectors if desired */

        if (*nru > 0) { // 如果需要更新右奇异向量，则调用dlasr_函数更新u
            dlasr_("R", "V", "F", nru, n, &work[1], &work[*n], &u[u_offset],
                   ldu);
        }
        if (*ncc > 0) { // 如果需要更新左奇异向量，则调用dlasr_函数更新c
            dlasr_("L", "V", "F", n, ncc, &work[1], &work[*n], &c__[c_offset],
                   ldc);
        }
    }

/*
       Compute singular values to relative accuracy TOL
       (By setting TOL to be negative, algorithm will compute
       singular values to absolute accuracy ABS(TOL)*norm(input matrix))

   Computing MAX
   Computing MIN
*/
    d__3 = 100., d__4 = pow_dd(&eps, &c_b94); // 计算100和eps的c_b94次方
    d__1 = 10., d__2 = min(d__3,d__4);       // 计算10和d__3、d__4的最小值
    tolmul = max(d__1,d__2);                 // 计算tolmul为d__1和d__2的最大值
    tol = tolmul * eps;                     // 计算tol为tolmul乘以eps

/*     Compute approximate maximum, minimum singular values */

    smax = 0.;          // 初始化最大奇异值为0
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {      // 循环计算最大奇异值
/* Computing MAX */
        d__2 = smax, d__3 = (d__1 = d__[i__], abs(d__1)); // 计算d[i]的绝对值
        smax = max(d__2,d__3);              // 更新最大奇异值
    /* L20: */                              // 标签L20
    }
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {      // 循环计算最大奇异值
/* Computing MAX */
        d__2 = smax, d__3 = (d__1 = e[i__], abs(d__1)); // 计算e[i]的绝对值
        smax = max(d__2,d__3);              // 更新最大奇异值
    /* L30: */                              // 标签L30
    }
    sminl = 0.;         // 初始化最小奇异值为0
    if (tol >= 0.) {    // 如果tol大于等于0，则计算相对精度的最小奇异值
/*        Relative accuracy desired */

/* 初始化相对精度要求 */
    sminoa = abs(d__[1]);
/* 计算第一个对角元素的绝对值 */
    if (sminoa == 0.) {
/* 如果第一个对角元素为零，跳转到 L50 标签处 */
        goto L50;
    }
/* 将第一个对角元素的绝对值作为初始的 mu */
    mu = sminoa;
/* 循环计算所有对角元素的绝对值的乘积除以相邻次对角元素的绝对值和 */
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        mu = (d__2 = d__[i__], abs(d__2)) * (mu / (mu + (d__1 = e[i__ - 1]
            , abs(d__1))));
/* 更新 sminoa 为当前 mu 和之前计算的最小值 */
        sminoa = min(sminoa,mu);
/* 如果 sminoa 已经为零，跳转到 L50 标签处 */
        if (sminoa == 0.) {
        goto L50;
        }
/* L40: */
    }
L50:
/* 将 sminoa 归一化 */
    sminoa /= sqrt((doublereal) (*n));
/* 计算阈值 thresh，取 tol 乘以 sminoa 和 n^2 * 6 * n * unfl 中的较大值 */
/* Computing MAX */
    d__1 = tol * sminoa, d__2 = *n * 6 * *n * unfl;
    thresh = max(d__1,d__2);
    } else {

/*
          Absolute accuracy desired

   Computing MAX
*/
/* 绝对精度要求 */
    d__1 = abs(tol) * smax, d__2 = *n * 6 * *n * unfl;
    thresh = max(d__1,d__2);
    }

/*
       Prepare for main iteration loop for the singular values
       (MAXIT is the maximum number of passes through the inner
       loop permitted before nonconvergence signalled.)
*/

/* 准备主循环迭代，计算奇异值 */
    maxit = *n * 6 * *n;
/* 迭代计数器初始化为 0 */
    iter = 0;
/* 上一次迭代的 m 和 ll 初始化为 -1 */
    oldll = -1;
    oldm = -1;

/*     M points to last element of unconverged part of matrix */

/* M 指向矩阵中未收敛部分的最后一个元素 */
    m = *n;

/*     Begin main iteration loop */

/* 开始主循环迭代 */

L60:

/*     Check for convergence or exceeding iteration count */

/* 检查是否收敛或超出最大迭代次数 */

    if (m <= 1) {
    goto L160;
    }
/* 如果 m 小于等于 1，跳转到 L160 标签处 */
    if (iter > maxit) {
    goto L200;
    }
/* 如果迭代次数超过 maxit，跳转到 L200 标签处 */

/*     Find diagonal block of matrix to work on */

/* 找到要处理的矩阵的对角块 */

    if (tol < 0. && (d__1 = d__[m], abs(d__1)) <= thresh) {
    d__[m] = 0.;
    }
/* 如果 tol 小于零且 d[m] 的绝对值小于等于 thresh，则将 d[m] 置为零 */
    smax = (d__1 = d__[m], abs(d__1));
/* 计算当前对角元素的绝对值作为 smax */
    smin = smax;
/* 初始化 smin 为当前的 smax */
    i__1 = m - 1;
    for (lll = 1; lll <= i__1; ++lll) {
    ll = m - lll;
/* 循环处理矩阵的下三角部分 */
    abss = (d__1 = d__[ll], abs(d__1));
/* 当前对角元素的绝对值 */
    abse = (d__1 = e[ll], abs(d__1));
/* 当前下对角元素的绝对值 */
    if (tol < 0. && abss <= thresh) {
        d__[ll] = 0.;
    }
/* 如果 tol 小于零且 abss 小于等于 thresh，则将 d[ll] 置为零 */
    if (abse <= thresh) {
        goto L80;
    }
/* 如果 abse 小于等于 thresh，跳转到 L80 标签处 */
    smin = min(smin,abss);
/* 更新 smin 为当前 abss 和之前计算的最小值 */
/* Computing MAX */
    d__1 = max(smax,abss);
    smax = max(d__1,abse);
/* 更新 smax 为当前 smax、abss 和 abse 的最大值 */
/* L70: */
    }
    ll = 0;
    goto L90;
/* 跳转到 L90 标签处 */

L80:
    e[ll] = 0.;
/* 将 e[ll] 置为零 */

/*     Matrix splits since E(LL) = 0 */

/* 因为 E(LL) 等于零，所以矩阵分裂 */

    if (ll == m - 1) {

/*        Convergence of bottom singular value, return to top of loop */

/* 底部奇异值收敛，返回循环顶部 */
    --m;
/* m 减 1 */
    goto L60;
/* 跳转到 L60 标签处 */
    }
/* 如果 ll 等于 m-1，则跳转到 L60 标签处 */

L90:
    ++ll;

/*     E(LL) through E(M-1) are nonzero, E(LL-1) is zero */

/* E(LL) 到 E(M-1) 不为零，且 E(LL-1) 为零 */

    if (ll == m - 1) {

/*        2 by 2 block, handle separately */

/* 2x2 块，单独处理 */
    dlasv2_(&d__[m - 1], &e[m - 1], &d__[m], &sigmn, &sigmx, &sinr, &cosr,
         &sinl, &cosl);
/* 使用 dlasv2 计算 2x2 块的奇异值 */
    d__[m - 1] = sigmx;
    e[m - 1] = 0.;
    d__[m] = sigmn;
/* 更新对角元素 */

/*        Compute singular vectors, if desired */

/* 计算奇异向量，如果需要的话 */
    if (*ncvt > 0) {
        drot_(ncvt, &vt[m - 1 + vt_dim1], ldvt, &vt[m + vt_dim1], ldvt, &
            cosr, &sinr);
    }
/* 对 vt 的列进行 Givens 旋转 */
    if (*nru > 0) {
        drot_(nru, &u[(m - 1) * u_dim1 + 1], &c__1, &u[m * u_dim1 + 1], &
            c__1, &cosl, &sinl);
    }
/* 对 u 的行进行 Givens 旋转 */
    if (*ncc > 0) {
        drot_(ncc, &c__[m - 1 + c_dim1], ldc, &c__[m + c_dim1], ldc, &
            cosl, &sinl);
    }
/* 对 c 的列进行 Givens 旋转 */
    m += -2;
/* m 减 2 */
    goto L60;
/* 跳转到 L60 标签处 */
    }

/*
       If working on new submatrix, choose shift direction
       (from larger end diagonal element towards smaller)
*/

/* 如果在新子矩阵上工作，选择移位方向（从较大的对角元素向较小的方向） */
    if (ll > oldm || m < oldll) {
/* 如果 ll 大于 oldm 或者 m 小于 oldll */
    # 检查数组 d__ 中索引为 ll 的元素与索引为 m 的元素绝对值的大小关系
    if ((d__1 = d__[ll], abs(d__1)) >= (d__2 = d__[m], abs(d__2))) {
/*           Chase bulge from top (big end) to bottom (small end) */
/*           从顶部（大端）向底部（小端）驱动突起 */

        idir = 1;
    } else {

/*           Chase bulge from bottom (big end) to top (small end) */
/*           从底部（大端）向顶部（小端）驱动突起 */

        idir = 2;
    }
    }

/*     Apply convergence tests */
/*     应用收敛测试 */

    if (idir == 1) {

/*
          Run convergence test in forward direction
          First apply standard test to bottom of matrix
*/
/*          在正向方向上运行收敛测试
            首先对矩阵底部应用标准测试 */

    if ((d__2 = e[m - 1], abs(d__2)) <= abs(tol) * (d__1 = d__[m], abs(
        d__1)) || tol < 0. && (d__3 = e[m - 1], abs(d__3)) <= thresh)
        {
        e[m - 1] = 0.;
        goto L60;
    }

    if (tol >= 0.) {

/*
             If relative accuracy desired,
             apply convergence criterion forward
*/
/*             如果需要相对精度，
               应用正向收敛标准 */

        mu = (d__1 = d__[ll], abs(d__1));
        sminl = mu;
        i__1 = m - 1;
        for (lll = ll; lll <= i__1; ++lll) {
        if ((d__1 = e[lll], abs(d__1)) <= tol * mu) {
            e[lll] = 0.;
            goto L60;
        }
        mu = (d__2 = d__[lll + 1], abs(d__2)) * (mu / (mu + (d__1 = e[
            lll], abs(d__1))));
        sminl = min(sminl,mu);
/* L100: */
        }
    }

    } else {

/*
          Run convergence test in backward direction
          First apply standard test to top of matrix
*/
/*          在反向方向上运行收敛测试
            首先对矩阵顶部应用标准测试 */

    if ((d__2 = e[ll], abs(d__2)) <= abs(tol) * (d__1 = d__[ll], abs(d__1)
        ) || tol < 0. && (d__3 = e[ll], abs(d__3)) <= thresh) {
        e[ll] = 0.;
        goto L60;
    }

    if (tol >= 0.) {

/*
             If relative accuracy desired,
             apply convergence criterion backward
*/
/*             如果需要相对精度，
               应用反向收敛标准 */

        mu = (d__1 = d__[m], abs(d__1));
        sminl = mu;
        i__1 = ll;
        for (lll = m - 1; lll >= i__1; --lll) {
        if ((d__1 = e[lll], abs(d__1)) <= tol * mu) {
            e[lll] = 0.;
            goto L60;
        }
        mu = (d__2 = d__[lll], abs(d__2)) * (mu / (mu + (d__1 = e[lll]
            , abs(d__1))));
        sminl = min(sminl,mu);
/* L110: */
        }
    }
    }
    oldll = ll;
    oldm = m;

/*
       Compute shift.  First, test if shifting would ruin relative
       accuracy, and if so set the shift to zero.

   Computing MAX
*/
/*       计算位移。首先，测试位移是否会破坏相对精度，
         如果是，则将位移设置为零。 */

    d__1 = eps, d__2 = tol * .01;
    if (tol >= 0. && *n * tol * (sminl / smax) <= max(d__1,d__2)) {

/*        Use a zero shift to avoid loss of relative accuracy */
/*        使用零位移以避免相对精度的损失 */

    shift = 0.;
    } else {

/*        Compute the shift from 2-by-2 block at end of matrix */
/*        从矩阵末尾的2x2块计算位移 */

    if (idir == 1) {
        sll = (d__1 = d__[ll], abs(d__1));
        dlas2_(&d__[m - 1], &e[m - 1], &d__[m], &shift, &r__);
    } else {
        sll = (d__1 = d__[m], abs(d__1));
        dlas2_(&d__[ll], &e[ll], &d__[ll + 1], &shift, &r__);
    }

/*        Test if shift negligible, and if so set to zero */
/*        测试位移是否可以忽略，如果可以则设置为零 */

    if (sll > 0.) {
/* Computing 2nd power */
        d__1 = shift / sll;
        if (d__1 * d__1 < eps) {
        shift = 0.;
        }
    }
    }

/*     Increment iteration count */
/*     增加迭代计数 */

    iter = iter + m - ll;

/*     If SHIFT = 0, do simplified QR iteration */
/*     如果位移为零，则进行简化的QR迭代 */

    if (shift == 0.) {
    if (idir == 1) {
/*
     Chase bulge from top to bottom
     Save cosines and sines for later singular vector updates
*/
cs = 1.; // 初始化 cosine
oldcs = 1.; // 初始化旧的 cosine
i__1 = m - 1; // 循环上限为 m-1
for (i__ = ll; i__ <= i__1; ++i__) { // 循环从 ll 到 m-1
    d__1 = d__[i__] * cs; // 计算 d[i] * cs
    dlartg_(&d__1, &e[i__], &cs, &sn, &r__); // 计算旋转角度，更新 cs, sn
    if (i__ > ll) {
        e[i__ - 1] = oldsn * r__; // 更新 e[i-1]
    }
    d__1 = oldcs * r__; // 计算旋转的旧 cosine
    d__2 = d__[i__ + 1] * sn; // 计算 d[i+1] * sn
    dlartg_(&d__1, &d__2, &oldcs, &oldsn, &d__[i__]); // 计算旋转角度，更新 oldcs, oldsn, d[i]
    work[i__ - ll + 1] = cs; // 存储当前的 cs
    work[i__ - ll + 1 + nm1] = sn; // 存储当前的 sn
    work[i__ - ll + 1 + nm12] = oldcs; // 存储旧的 oldcs
    work[i__ - ll + 1 + nm13] = oldsn; // 存储旧的 oldsn
    /* L120: */
}
h__ = d__[m] * cs; // 计算 h
d__[m] = h__ * oldcs; // 更新 d[m]
e[m - 1] = h__ * oldsn; // 更新 e[m-1]

/* Update singular vectors */
if (*ncvt > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("L", "V", "F", &i__1, ncvt, &work[1], &work[*n], &vt[
        ll + vt_dim1], ldvt); // 更新 vt
}
if (*nru > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("R", "V", "F", nru, &i__1, &work[nm12 + 1], &work[nm13
        + 1], &u[ll * u_dim1 + 1], ldu); // 更新 u
}
if (*ncc > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("L", "V", "F", &i__1, ncc, &work[nm12 + 1], &work[nm13
        + 1], &c__[ll + c_dim1], ldc); // 更新 c
}

/* Test convergence */
if ((d__1 = e[m - 1], abs(d__1)) <= thresh) { // 检查收敛性
    e[m - 1] = 0.; // 如果满足条件，置 e[m-1] 为 0
}
} else {

/*
     Chase bulge from bottom to top
     Save cosines and sines for later singular vector updates
*/
cs = 1.; // 初始化 cosine
oldcs = 1.; // 初始化旧的 cosine
i__1 = ll + 1; // 循环上限为 ll+1
for (i__ = m; i__ >= i__1; --i__) { // 循环从 m 到 ll+1
    d__1 = d__[i__] * cs; // 计算 d[i] * cs
    dlartg_(&d__1, &e[i__ - 1], &cs, &sn, &r__); // 计算旋转角度，更新 cs, sn
    if (i__ < m) {
        e[i__] = oldsn * r__; // 更新 e[i]
    }
    d__1 = oldcs * r__; // 计算旋转的旧 cosine
    d__2 = d__[i__ - 1] * sn; // 计算 d[i-1] * sn
    dlartg_(&d__1, &d__2, &oldcs, &oldsn, &d__[i__]); // 计算旋转角度，更新 oldcs, oldsn, d[i]
    work[i__ - ll] = cs; // 存储当前的 cs
    work[i__ - ll + nm1] = -sn; // 存储当前的 -sn
    work[i__ - ll + nm12] = oldcs; // 存储旧的 oldcs
    work[i__ - ll + nm13] = -oldsn; // 存储旧的 -oldsn
    /* L130: */
}
h__ = d__[ll] * cs; // 计算 h
d__[ll] = h__ * oldcs; // 更新 d[ll]
e[ll] = h__ * oldsn; // 更新 e[ll]

/* Update singular vectors */
if (*ncvt > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[
        nm13 + 1], &vt[ll + vt_dim1], ldvt); // 更新 vt
}
if (*nru > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll *
         u_dim1 + 1], ldu); // 更新 u
}
if (*ncc > 0) {
    i__1 = m - ll + 1; // 更新上限为 m-ll+1
    dlasr_("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c__[
        ll + c_dim1], ldc); // 更新 c
}

/* Test convergence */
if ((d__1 = e[ll], abs(d__1)) <= thresh) { // 检查收敛性
    e[ll] = 0.; // 如果满足条件，置 e[ll] 为 0
}
}
} else {

/* Use nonzero shift */

if (idir == 1) {
/*
             Chase bulge from top to bottom
             Save cosines and sines for later singular vector updates
*/
        f = ((d__1 = d__[ll], abs(d__1)) - shift) * (d_sign(&c_b15, &d__[
            ll]) + shift / d__[ll]);
        g = e[ll];
        i__1 = m - 1;
        for (i__ = ll; i__ <= i__1; ++i__) {
            // Compute rotation to eliminate bulge in d and e vectors
            dlartg_(&f, &g, &cosr, &sinr, &r__);
            if (i__ > ll) {
                e[i__ - 1] = r__;  // Update e vector with new value
            }
            // Apply rotation to update d and e vectors
            f = cosr * d__[i__] + sinr * e[i__];
            e[i__] = cosr * e[i__] - sinr * d__[i__];
            g = sinr * d__[i__ + 1];
            d__[i__ + 1] = cosr * d__[i__ + 1];
            // Compute rotation to prepare for next iteration
            dlartg_(&f, &g, &cosl, &sinl, &r__);
            d__[i__] = r__;
            f = cosl * e[i__] + sinl * d__[i__ + 1];
            d__[i__ + 1] = cosl * d__[i__ + 1] - sinl * e[i__];
            if (i__ < m - 1) {
                g = sinl * e[i__ + 1];
                e[i__ + 1] = cosl * e[i__ + 1];
            }
            // Save cosines and sines for later singular vector updates
            work[i__ - ll + 1] = cosr;
            work[i__ - ll + 1 + nm1] = sinr;
            work[i__ - ll + 1 + nm12] = cosl;
            work[i__ - ll + 1 + nm13] = sinl;
/* L140: */
        }
        e[m - 1] = f;  // Update e vector with the final computed value

/*           Update singular vectors */

        if (*ncvt > 0) {
            // Update singular vectors for matrix V
            i__1 = m - ll + 1;
            dlasr_("L", "V", "F", &i__1, ncvt, &work[1], &work[*n], &vt[
                ll + vt_dim1], ldvt);
        }
        if (*nru > 0) {
            // Update singular vectors for matrix U
            i__1 = m - ll + 1;
            dlasr_("R", "V", "F", nru, &i__1, &work[nm12 + 1], &work[nm13
                + 1], &u[ll * u_dim1 + 1], ldu);
        }
        if (*ncc > 0) {
            // Update singular vectors for matrix C
            i__1 = m - ll + 1;
            dlasr_("L", "V", "F", &i__1, ncc, &work[nm12 + 1], &work[nm13
                + 1], &c__[ll + c_dim1], ldc);
        }

/*           Test convergence */

        if ((d__1 = e[m - 1], abs(d__1)) <= thresh) {
            e[m - 1] = 0.;  // Set singular value to zero if converged
        }

    } else {

/*
             Chase bulge from bottom to top
             Save cosines and sines for later singular vector updates
*/

        f = ((d__1 = d__[m], abs(d__1)) - shift) * (d_sign(&c_b15, &d__[m]
            ) + shift / d__[m]);
        g = e[m - 1];
        i__1 = ll + 1;
        for (i__ = m; i__ >= i__1; --i__) {
            // Compute rotation to eliminate bulge in d and e vectors
            dlartg_(&f, &g, &cosr, &sinr, &r__);
            if (i__ < m) {
                e[i__] = r__;  // Update e vector with new value
            }
            // Apply rotation to update d and e vectors
            f = cosr * d__[i__] + sinr * e[i__ - 1];
            e[i__ - 1] = cosr * e[i__ - 1] - sinr * d__[i__];
            g = sinr * d__[i__ - 1];
            d__[i__ - 1] = cosr * d__[i__ - 1];
            // Compute rotation to prepare for next iteration
            dlartg_(&f, &g, &cosl, &sinl, &r__);
            d__[i__] = r__;
            f = cosl * e[i__ - 1] + sinl * d__[i__ - 1];
            d__[i__ - 1] = cosl * d__[i__ - 1] - sinl * e[i__ - 1];
            if (i__ > ll + 1) {
                g = sinl * e[i__ - 2];
                e[i__ - 2] = cosl * e[i__ - 2];
            }
            // Save cosines and sines for later singular vector updates
            work[i__ - ll] = cosr;
            work[i__ - ll + nm1] = -sinr;
            work[i__ - ll + nm12] = cosl;
            work[i__ - ll + nm13] = -sinl;
/* L150: */
        }
        e[ll] = f;  // Update e vector with the final computed value
/*           Test convergence */

/* 检测奇异值是否收敛 */
if ((d__1 = e[ll], abs(d__1)) <= thresh) {
    e[ll] = 0.;
}

/*           Update singular vectors if desired */

/* 如果需要更新奇异向量，则执行以下操作 */

/* 更新左奇异向量 */
if (*ncvt > 0) {
    i__1 = m - ll + 1;
    dlasr_("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[nm13 + 1], &vt[ll + vt_dim1], ldvt);
}

/* 更新右奇异向量 */
if (*nru > 0) {
    i__1 = m - ll + 1;
    dlasr_("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll * u_dim1 + 1], ldu);
}

/* 更新中间奇异向量 */
if (*ncc > 0) {
    i__1 = m - ll + 1;
    dlasr_("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c__[ll + c_dim1], ldc);
}
}
}

/*     QR iteration finished, go back and check convergence */

/* QR 迭代完成，返回并检查奇异值是否收敛 */
goto L60;

/*     All singular values converged, so make them positive */

/* 所有奇异值已经收敛，将其变为正数 */
L160:
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
if (d__[i__] < 0.) {
    d__[i__] = -d__[i__];

/*           Change sign of singular vectors, if desired */

/* 如果需要，改变奇异向量的符号 */
if (*ncvt > 0) {
    dscal_(ncvt, &c_b151, &vt[i__ + vt_dim1], ldvt);
}
}
/* L170: */
}

/*
   Sort the singular values into decreasing order (insertion sort on
   singular values, but only one transposition per singular vector)
*/

/*
   将奇异值按降序排序（对奇异值进行插入排序，但每个奇异向量只进行一次转置）
*/
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {

/*        Scan for smallest D(I) */

/* 扫描寻找最小的 D(I) */
isub = 1;
smin = d__[1];
i__2 = *n + 1 - i__;
for (j = 2; j <= i__2; ++j) {
    if (d__[j] <= smin) {
    isub = j;
    smin = d__[j];
    }
/* L180: */
}
if (isub != *n + 1 - i__) {

/*           Swap singular values and vectors */

/* 交换奇异值和奇异向量 */
d__[isub] = d__[*n + 1 - i__];
d__[*n + 1 - i__] = smin;
if (*ncvt > 0) {
    dswap_(ncvt, &vt[isub + vt_dim1], ldvt, &vt[*n + 1 - i__ + vt_dim1], ldvt);
}
if (*nru > 0) {
    dswap_(nru, &u[isub * u_dim1 + 1], &c__1, &u[(*n + 1 - i__) * u_dim1 + 1], &c__1);
}
if (*ncc > 0) {
    dswap_(ncc, &c__[isub + c_dim1], ldc, &c__[*n + 1 - i__ + c_dim1], ldc);
}
}
/* L190: */
}
goto L220;

/*     Maximum number of iterations exceeded, failure to converge */

/* 迭代次数超过最大限制，收敛失败 */
L200:
*info = 0;
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
if (e[i__] != 0.) {
    ++(*info);
}
/* L210: */
}
L220:
return 0;

/*     End of DBDSQR */

} /* dbdsqr_ */

/* Subroutine */ int dgebak_(char *job, char *side, integer *n, integer *ilo,
integer *ihi, doublereal *scale, integer *m, doublereal *v, integer *
ldv, integer *info)
{
/* Subroutine to backward transform the right singular vectors of a
matrix which has been reduced by decomposition techniques. */
/* 用于反向变换已通过分解技术减少的矩阵的右奇异向量的子例程。 */

/* System generated locals */
integer v_dim1, v_offset, i__1;

/* Local variables */
static integer i__, k;
static doublereal s;
static integer ii;
extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
integer *);
extern logical lsame_(char *, char *);
    # 定义一个外部的双精度数组交换子程序，参数包括整数、双精度数组及其长度
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    # 声明静态逻辑变量 leftv 和 rightv
    static logical leftv;
    # 定义一个外部的错误处理子程序，参数为字符指针和整数
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static logical rightv;
/*
   -- LAPACK routine (version 3.2) --
   -- LAPACK is a software package provided by Univ. of Tennessee,    --
   -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


   Purpose
   =======

   DGEBAK forms the right or left eigenvectors of a real general matrix
   by backward transformation on the computed eigenvectors of the
   balanced matrix output by DGEBAL.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           Specifies the type of backward transformation required:
           = 'N', do nothing, return immediately;
           = 'P', do backward transformation for permutation only;
           = 'S', do backward transformation for scaling only;
           = 'B', do backward transformations for both permutation and
                  scaling.
           JOB must be the same as the argument JOB supplied to DGEBAL.

   SIDE    (input) CHARACTER*1
           = 'R':  V contains right eigenvectors;
           = 'L':  V contains left eigenvectors.

   N       (input) INTEGER
           The number of rows of the matrix V.  N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           The integers ILO and IHI determined by DGEBAL.
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   SCALE   (input) DOUBLE PRECISION array, dimension (N)
           Details of the permutation and scaling factors, as returned
           by DGEBAL.

   M       (input) INTEGER
           The number of columns of the matrix V.  M >= 0.

   V       (input/output) DOUBLE PRECISION array, dimension (LDV,M)
           On entry, the matrix of right or left eigenvectors to be
           transformed, as returned by DHSEIN or DTREVC.
           On exit, V is overwritten by the transformed eigenvectors.

   LDV     (input) INTEGER
           The leading dimension of the array V. LDV >= max(1,N).

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.

   =====================================================================


      Decode and Test the input parameters
*/
{
    /* Parameter adjustments */
    --scale;
    int v_dim1 = *ldv;
    int v_offset = 1 + v_dim1;
    v -= v_offset;

    /* Function Body */
    bool rightv = lsame_(side, "R");  // Determine if SIDE equals 'R'
    bool leftv = lsame_(side, "L");   // Determine if SIDE equals 'L'

    *info = 0;  // Initialize INFO to indicate successful exit
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;  // Set INFO to -1 if JOB is not one of 'N', 'P', 'S', 'B'
    } else if (! rightv && ! leftv) {
        *info = -2;  // Set INFO to -2 if SIDE is neither 'R' nor 'L'
    } else if (*n < 0) {
        *info = -3;  // Set INFO to -3 if N is less than 0
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -4;  // Set INFO to -4 if ILO is out of valid range
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -5;  // Set INFO to -5 if IHI is out of valid range
    } else if (*m < 0) {
        *info = -7;  // Set INFO to -7 if M is less than 0
    } else if (*ldv < max(1,*n)) {
        *info = -9;  // Set INFO to -9 if LDV is less than max(1, N)
    }
    if (*info != 0) {
        int i__1 = -(*info);
        xerbla_("DGEBAK", &i__1);  // Call error handler if INFO is not 0
        return 0;  // Return from the function
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;  // Return immediately if N is 0
    }
    }
    # 如果指针 m 指向的值为 0，则返回 0
    if (*m == 0) {
    # 如果参数 job 的值是 "N"，则返回 0
    return 0;
    }
    # 如果 ilo 指向的值等于 ihi 指向的值，跳转到标签 L30
    if (lsame_(job, "N")) {
    return 0;
    }
    # 如果参数 ilo 指向的值等于参数 ihi 指向的值，执行标签 L30 下的代码
    if (*ilo == *ihi) {
    goto L30;
    }
/*
       Backward balance */

// 检查参数 job 是否为 "S" 或 "B"，执行向后平衡的相关操作
if (lsame_(job, "S") || lsame_(job, "B")) {

    // 如果需要右乘向量 v
    if (rightv) {
        // 遍历从 ilo 到 ihi 的每一行
        i__1 = *ihi;
        for (i__ = *ilo; i__ <= i__1; ++i__) {
            // 获取当前行的缩放因子
            s = scale[i__];
            // 对 v[i__][*] 中的每个元素乘以缩放因子 s
            dscal_(m, &s, &v[i__ + v_dim1], ldv);
            /* L10: */
        }
    }

    // 如果需要左乘向量 v
    if (leftv) {
        // 遍历从 ilo 到 ihi 的每一行
        i__1 = *ihi;
        for (i__ = *ilo; i__ <= i__1; ++i__) {
            // 计算当前行的逆缩放因子
            s = 1. / scale[i__];
            // 对 v[i__][*] 中的每个元素乘以逆缩放因子 s
            dscal_(m, &s, &v[i__ + v_dim1], ldv);
            /* L20: */
        }
    }

}

/*
       Backward permutation

       For  I = ILO-1 step -1 until 1,
                IHI+1 step 1 until N do --
*/

// 标记为 L30 的跳转点，执行向后置换相关操作
L30:
if (lsame_(job, "P") || lsame_(job, "B")) {
    // 如果需要右乘向量 v
    if (rightv) {
        // 从 1 到 n 遍历每个 ii
        i__1 = *n;
        for (ii = 1; ii <= i__1; ++ii) {
            // 设置当前行索引 i__
            i__ = ii;
            // 如果 i__ 在 ilo 和 ihi 之间，跳转到 L40 标签处
            if (i__ >= *ilo && i__ <= *ihi) {
                goto L40;
            }
            // 如果 i__ 小于 ilo，则设置 i__ 为 ilo - ii
            if (i__ < *ilo) {
                i__ = *ilo - ii;
            }
            // 获取当前行的置换值 k
            k = (integer) scale[i__];
            // 如果 k 等于 i__，跳转到 L40 标签处
            if (k == i__) {
                goto L40;
            }
            // 对 v[i__][*] 和 v[k][*] 进行元素交换
            dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L40:
            ;
        }
    }

    // 如果需要左乘向量 v
    if (leftv) {
        // 从 1 到 n 遍历每个 ii
        i__1 = *n;
        for (ii = 1; ii <= i__1; ++ii) {
            // 设置当前行索引 i__
            i__ = ii;
            // 如果 i__ 在 ilo 和 ihi 之间，跳转到 L50 标签处
            if (i__ >= *ilo && i__ <= *ihi) {
                goto L50;
            }
            // 如果 i__ 小于 ilo，则设置 i__ 为 ilo - ii
            if (i__ < *ilo) {
                i__ = *ilo - ii;
            }
            // 获取当前行的置换值 k
            k = (integer) scale[i__];
            // 如果 k 等于 i__，跳转到 L50 标签处
            if (k == i__) {
                goto L50;
            }
            // 对 v[i__][*] 和 v[k][*] 进行元素交换
            dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L50:
            ;
        }
    }
}

// 返回 0，结束函数 dgebak_
return 0;

/*     End of DGEBAK */

} /* dgebak_ */


这些注释按照要求详细解释了每行代码的作用，包括条件判断、循环遍历、元素操作和函数调用等。
    # 根据参数 JOB 控制对矩阵 A 的平衡操作：
    # 'N': 无操作，直接设定 ILO = 1, IHI = N, SCALE(I) = 1.0
    # 'P': 仅进行置换操作
    # 'S': 仅进行缩放操作
    # 'B': 同时进行置换和缩放操作
    JOB     (input) CHARACTER*1

    # 矩阵 A 的阶数，即矩阵 A 的行数和列数
    N       (input) INTEGER

    # 输入输出参数，初始时为输入矩阵 A，返回时为经过平衡操作后的矩阵 A
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)

    # 数组 A 的第一个维度的长度，即矩阵 A 在内存中的行数
    LDA     (input) INTEGER

    # 输出参数，平衡后的矩阵 A 的子矩阵 B 的起始列和结束列的索引
    ILO     (output) INTEGER
    IHI     (output) INTEGER

    # 输出参数，记录置换和缩放操作的详细信息
    SCALE   (output) DOUBLE PRECISION array, dimension (N)

    # 输出参数，返回子程序执行的状态信息
    INFO    (output) INTEGER
    =====================================================================
    # 用于标记测试输入参数部分的分隔线，可能用于区分不同部分的代码块或者注释段落
       Test the input parameters
    # 测试输入参数的有效性或合法性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --scale;

    /* Function Body */
    *info = 0;
    if (! lsame_(job, "N") && ! lsame_(job, "P") && ! lsame_(job, "S")
        && ! lsame_(job, "B")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGEBAL", &i__1);
        return 0;
    }

    k = 1;
    l = *n;

    if (*n == 0) {
        goto L210;
    }

    if (lsame_(job, "N")) {
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
            scale[i__] = 1.;
        }
        goto L210;
    }

    if (lsame_(job, "S")) {
        goto L120;
    }

/*     Permutation to isolate eigenvalues if possible */

    goto L50;

/*     Row and column exchange. */

L20:
    scale[m] = (doublereal) j;
    if (j == m) {
        goto L30;
    }

    dswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    i__1 = *n - k + 1;
    dswap_(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

L30:
    switch (iexc) {
    case 1:  goto L40;
    case 2:  goto L80;
    }

/*     Search for rows isolating an eigenvalue and push them down. */

L40:
    if (l == 1) {
        goto L210;
    }
    --l;

L50:
    for (j = l; j >= 1; --j) {

        i__1 = l;
        for (i__ = 1; i__ <= i__1; ++i__) {
            if (i__ == j) {
                goto L60;
            }
            if (a[j + i__ * a_dim1] != 0.) {
                goto L70;
            }
L60:
            ;
        }

        m = l;
        iexc = 1;
        goto L20;
L70:
        ;
    }

    goto L90;

/*     Search for columns isolating an eigenvalue and push them left. */

L80:
    ++k;

L90:
    i__1 = l;
    for (j = k; j <= i__1; ++j) {

        i__2 = l;
        for (i__ = k; i__ <= i__2; ++i__) {
            if (i__ == j) {
                goto L100;
            }
            if (a[i__ + j * a_dim1] != 0.) {
                goto L110;
            }
L100:
            ;
        }

        m = k;
        iexc = 2;
        goto L20;
L110:
        ;
    }

L120:
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        scale[i__] = 1.;
    }

    if (lsame_(job, "P")) {
        goto L210;
    }

/*
       Balance the submatrix in rows K to L.

       Iterative loop for norm reduction
*/

    sfmin1 = SAFEMINIMUM / PRECISION;
    sfmax1 = 1. / sfmin1;
    sfmin2 = sfmin1 * 2.;
    sfmax2 = 1. / sfmin2;
L140:
    noconv = FALSE_;

    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
        c__ = 0.;
        r__ = 0.;

        i__2 = l;
        for (j = k; j <= i__2; ++j) {
            if (j == i__) {
                goto L150;
            }
            c__ += (d__1 = a[j + i__ * a_dim1], abs(d__1));
            r__ += (d__1 = a[i__ + j * a_dim1], abs(d__1));
L150:
            ;
        }
        ica = idamax_(&l, &a[i__ * a_dim1 + 1], &c__1);
        ca = (d__1 = a[ica + i__ * a_dim1], abs(d__1));
        i__2 = *n - k + 1;
        ira = idamax_(&i__2, &a[i__ + k * a_dim1], lda);
        ra = (d__1 = a[i__ + (ira + k - 1) * a_dim1], abs(d__1));

/*        Guard against zero C or R due to underflow. */
    # 如果 c__ 或 r__ 等于 0，则跳转到标签 L200 处
    if (c__ == 0. || r__ == 0.) {
        goto L200;
    }
    # 计算 g 为 r__ 的一半
    g = r__ / 2.;
    # 初始化 f 为 1
    f = 1.;
    # 计算 s 为 c__ 和 r__ 的和
    s = c__ + r__;
L160:
/* Computing MAX */
    d__1 = max(f,c__);
/* Computing MIN */
    d__2 = min(r__,g);
    if (c__ >= g || max(d__1,ca) >= sfmax2 || min(d__2,ra) <= sfmin2) {
        goto L170;
    }
    d__1 = c__ + f + ca + r__ + g + ra;
    if (disnan_(&d__1)) {

/*           Exit if NaN to avoid infinite loop */

        *info = -3;
        i__2 = -(*info);
        xerbla_("DGEBAL", &i__2);
        return 0;
    }
    f *= 2.;
    c__ *= 2.;
    ca *= 2.;
    r__ /= 2.;
    g /= 2.;
    ra /= 2.;
    goto L160;

L170:
    g = c__ / 2.;
L180:
/* Computing MIN */
    d__1 = min(f,c__), d__1 = min(d__1,g);
    if (g < r__ || max(r__,ra) >= sfmax2 || min(d__1,ca) <= sfmin2) {
        goto L190;
    }
    f /= 2.;
    c__ /= 2.;
    g /= 2.;
    ca /= 2.;
    r__ *= 2.;
    ra *= 2.;
    goto L180;

/*        Now balance. */

L190:
    if (c__ + r__ >= s * .95) {
        goto L200;
    }
    if (f < 1. && scale[i__] < 1.) {
        if (f * scale[i__] <= sfmin1) {
        goto L200;
        }
    }
    if (f > 1. && scale[i__] > 1.) {
        if (scale[i__] >= sfmax1 / f) {
        goto L200;
        }
    }
    g = 1. / f;
    scale[i__] *= f;
    noconv = TRUE_;

    i__2 = *n - k + 1;
    dscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
    dscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
    ;
    }

    if (noconv) {
    goto L140;
    }

L210:
    *ilo = k;
    *ihi = l;

    return 0;

/*     End of DGEBAL */

} /* dgebal_ */


注释：


L160:
/* Computing MAX */
    d__1 = max(f,c__);  // 计算 f 和 c__ 的最大值
/* Computing MIN */
    d__2 = min(r__,g);  // 计算 r__ 和 g 的最小值
    if (c__ >= g || max(d__1,ca) >= sfmax2 || min(d__2,ra) <= sfmin2) {
        goto L170;  // 如果条件满足则跳转到 L170 标签处
    }
    d__1 = c__ + f + ca + r__ + g + ra;
    if (disnan_(&d__1)) {

/*           Exit if NaN to avoid infinite loop */

        *info = -3;  // 如果出现 NaN，则设置 info 为 -3
        i__2 = -(*info);
        xerbla_("DGEBAL", &i__2);  // 调用错误处理函数 xerbla
        return 0;  // 返回 0
    }
    f *= 2.;  // 将 f 增加一倍
    c__ *= 2.;  // 将 c__ 增加一倍
    ca *= 2.;  // 将 ca 增加一倍
    r__ /= 2.;  // 将 r__ 减少一倍
    g /= 2.;  // 将 g 减少一倍
    ra /= 2.;  // 将 ra 减少一倍
    goto L160;  // 回到 L160 标签处继续执行

L170:
    g = c__ / 2.;  // 将 g 设置为 c__ 的一半
L180:
/* Computing MIN */
    d__1 = min(f,c__), d__1 = min(d__1,g);  // 计算 f、c__ 和 g 的最小值
    if (g < r__ || max(r__,ra) >= sfmax2 || min(d__1,ca) <= sfmin2) {
        goto L190;  // 如果条件满足则跳转到 L190 标签处
    }
    f /= 2.;  // 将 f 减少一倍
    c__ /= 2.;  // 将 c__ 减少一倍
    g /= 2.;  // 将 g 减少一倍
    ca /= 2.;  // 将 ca 减少一倍
    r__ *= 2.;  // 将 r__ 增加一倍
    ra *= 2.;  // 将 ra 增加一倍
    goto L180;  // 回到 L180 标签处继续执行

/*        Now balance. */

L190:
    if (c__ + r__ >= s * .95) {
        goto L200;  // 如果条件满足则跳转到 L200 标签处
    }
    if (f < 1. && scale[i__] < 1.) {
        if (f * scale[i__] <= sfmin1) {
        goto L200;  // 如果条件满足则跳转到 L200 标签处
        }
    }
    if (f > 1. && scale[i__] > 1.) {
        if (scale[i__] >= sfmax1 / f) {
        goto L200;  // 如果条件满足则跳转到 L200 标签处
        }
    }
    g = 1. / f;  // 计算 g 的倒数
    scale[i__] *= f;  // 缩放 scale[i__] 的值
    noconv = TRUE_;  // 设置 noconv 为 TRUE

    i__2 = *n - k + 1;
    dscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);  // 矩阵 a 的列向量乘以 g
    dscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);  // 矩阵 a 的行向量乘以 f

L200:
    ;  // 空语句

    }

    if (noconv) {
    goto L140;  // 如果条件满足则跳转到 L140 标签处
    }

L210:
    *ilo = k;  // 设置 ilo 为 k
    *ihi = l;  // 设置 ihi 为 l

    return 0;  // 返回 0

/*     End of DGEBAL */

} /* dgebal_ */
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            输入/输出参数，大小为 (LDA,N) 的双精度浮点数数组。
            On entry, 要被减少的 m × n 一般矩阵。
            On exit,
            如果 m >= n，则对角线和第一个超对角线被上三角双对角矩阵 B 覆盖；
              在对角线下方的元素，用数组 TAUQ 表示正交矩阵 Q 作为一系列初等反射器的乘积；
              在第一个超对角线上方的元素，用数组 TAUP 表示正交矩阵 P 作为一系列初等反射器的乘积；
            如果 m < n，则对角线和第一个次对角线被下三角双对角矩阵 B 覆盖；
              在第一个次对角线下方的元素，用数组 TAUQ 表示正交矩阵 Q 作为一系列初等反射器的乘积；
              在对角线上方的元素，用数组 TAUP 表示正交矩阵 P 作为一系列初等反射器的乘积。
            See Further Details.

    LDA     (input) INTEGER
            输入参数，整数。
            数组 A 的领导维度。要求 LDA >= max(1, M)。

    D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            输出参数，大小为 min(M,N) 的双精度浮点数数组。
            双对角矩阵 B 的对角线元素：
            D(i) = A(i,i)。

    E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            输出参数，大小为 min(M,N)-1 的双精度浮点数数组。
            双对角矩阵 B 的非对角线元素：
            如果 m >= n，则对于 i = 1,2,...,n-1，E(i) = A(i,i+1)；
            如果 m < n，则对于 i = 1,2,...,m-1，E(i) = A(i+1,i)。

    TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
            输出参数，大小为 min(M,N) 的双精度浮点数数组。
            表示正交矩阵 Q 的初等反射器的标量因子。See Further Details.

    TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
            输出参数，大小为 min(M,N) 的双精度浮点数数组。
            表示正交矩阵 P 的初等反射器的标量因子。See Further Details.

    WORK    (workspace) DOUBLE PRECISION array, dimension (max(M,N))
            工作空间，大小为 max(M,N) 的双精度浮点数数组。

    INFO    (output) INTEGER
            输出参数，整数。
            = 0：成功退出。
            < 0：如果 INFO = -i，则第 i 个参数具有非法值。

    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

    如果 m >= n,

       Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

    每个 H(i) 和 G(i) 的形式为：

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    其中 tauq 和 taup 是实数标量，v 和 u 是实向量；
    v(1:i-1) = 0，v(i) = 1，并且 v(i+1:m) 在退出时存储在 A(i+1:m,i) 中；
    u(1:i) = 0，u(i+1) = 1，并且 u(i+2:n) 在退出时存储在 A(i,i+2:n) 中；
    tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。

    如果 m < n,

       Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)

    每个 H(i) 和 G(i) 的形式为：

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
    # Test the input parameters
    # 测试输入参数的有效性和合理性
    /* Parameter adjustments */
    a_dim1 = *lda;  // 设置矩阵 A 的第一维度为 lda
    a_offset = 1 + a_dim1;  // 计算 A 数组的偏移量
    a -= a_offset;  // 调整指向矩阵 A 的指针
    --d__;  // 调整指向向量 d 的指针
    --e;  // 调整指向向量 e 的指针
    --tauq;  // 调整指向向量 tauq 的指针
    --taup;  // 调整指向向量 taup 的指针
    --work;  // 调整指向工作区域 work 的指针

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    if (*m < 0) {  // 检查 m 的值是否小于 0
        *info = -1;  // 若是，设置 info 为 -1
    } else if (*n < 0) {  // 检查 n 的值是否小于 0
        *info = -2;  // 若是，设置 info 为 -2
    } else if (*lda < max(1,*m)) {  // 检查 lda 是否小于 max(1, m)
        *info = -4;  // 若是，设置 info 为 -4
    }
    if (*info < 0) {  // 如果 info 小于 0，表示出现了错误条件
        i__1 = -(*info);  // 计算错误码的绝对值
        xerbla_("DGEBD2", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0 表示异常退出
    }

    if (*m >= *n) {

        /* Reduce to upper bidiagonal form */

        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {

            /* Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

            i__2 = *m - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ *
                a_dim1], &c__1, &tauq[i__]);  // 生成 H(i)，使得 A(i+1:m,i) 变为零
            d__[i__] = a[i__ + i__ * a_dim1];  // 存储对角元素 d
            a[i__ + i__ * a_dim1] = 1.;  // 设置对角线上的元素为 1

            /* Apply H(i) to A(i:m,i+1:n) from the left */

            if (i__ < *n) {
                i__2 = *m - i__ + 1;
                i__3 = *n - i__;
                dlarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &
                    tauq[i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]
                    );  // 从左侧应用 H(i) 到 A(i:m,i+1:n)
            }
            a[i__ + i__ * a_dim1] = d__[i__];  // 恢复对角元素 d

            if (i__ < *n) {

                /* Generate elementary reflector G(i) to annihilate
                   A(i,i+2:n) */

                i__2 = *n - i__;
                /* Computing MIN */
                i__3 = i__ + 2;
                dlarfg_(&i__2, &a[i__ + (i__ + 1) * a_dim1], &a[i__ + min(
                    i__3,*n) * a_dim1], lda, &taup[i__]);  // 生成 G(i)，使得 A(i,i+2:n) 变为零
                e[i__] = a[i__ + (i__ + 1) * a_dim1];  // 存储超对角元素 e
                a[i__ + (i__ + 1) * a_dim1] = 1.;  // 设置超对角线上的元素为 1

                /* Apply G(i) to A(i+1:m,i+1:n) from the right */

                i__2 = *m - i__;
                i__3 = *n - i__;
                dlarf_("Right", &i__2, &i__3, &a[i__ + (i__ + 1) * a_dim1],
                    lda, &taup[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
                    lda, &work[1]);  // 从右侧应用 G(i) 到 A(i+1:m,i+1:n)
                a[i__ + (i__ + 1) * a_dim1] = e[i__];  // 恢复超对角元素 e
            } else {
                taup[i__] = 0.;  // 如果 i >= n，设置 taup[i] 为 0
            }
        }  // end for i__
    } else {

        /* Reduce to lower bidiagonal form */

        i__1 = *m;
        for (i__ = 1; i__ <= i__1; ++i__) {

            /* Generate elementary reflector G(i) to annihilate A(i,i+1:n) */

            i__2 = *n - i__ + 1;
            /* Computing MIN */
            i__3 = i__ + 1;
            dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) *
                a_dim1], lda, &taup[i__]);  // 生成 G(i)，使得 A(i,i+1:n) 变为零
            d__[i__] = a[i__ + i__ * a_dim1];  // 存储对角元素 d
            a[i__ + i__ * a_dim1] = 1.;  // 设置对角线上的元素为 1

            /* Apply G(i) to A(i+1:m,i:n) from the right */

            if (i__ < *m) {
                i__2 = *m - i__;
                i__3 = *n - i__ + 1;
                dlarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &
                    taup[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
                    // 从右侧应用 G(i) 到 A(i+1:m,i:n)
            }
            a[i__ + i__ * a_dim1] = d__[i__];  // 恢复对角元素 d

            if (i__ < *m) {

                /* Generate elementary reflector H(i) to annihilate
                   A(i+2:m,i) */

                i__2 = *m - i__;
/* Computing MIN */
/* 计算 MIN 函数的结果 */
        i__3 = i__ + 2;
/* 获取 i__ + 2 的值 */
        dlarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*m) +
            i__ * a_dim1], &c__1, &tauq[i__]);
/* 调用 dlarfg 函数，对向量进行 Householder 变换，生成一个标量和一个 Householder 向量 */
        e[i__] = a[i__ + 1 + i__ * a_dim1];
/* 将 a[i__ + 1 + i__ * a_dim1] 的值赋给 e[i__] */
        a[i__ + 1 + i__ * a_dim1] = 1.;
/* 将 a[i__ + 1 + i__ * a_dim1] 设置为 1 */

/* Apply H(i) to A(i+1:m,i+1:n) from the left */
/* 将 H(i) 从左边应用于 A(i+1:m,i+1:n) */

        i__2 = *m - i__;
/* 计算行数 */
        i__3 = *n - i__;
/* 计算列数 */
        dlarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &
            c__1, &tauq[i__], &a[i__ + 1 + (i__ + 1) * a_dim1],
            lda, &work[1]);
/* 调用 dlarf 函数，将 Householder 变换应用于矩阵 A 的子区域 */

        a[i__ + 1 + i__ * a_dim1] = e[i__];
/* 将 e[i__] 的值赋给 a[i__ + 1 + i__ * a_dim1] */
        } else {
/* 如果不满足条件则 */
        tauq[i__] = 0.;
/* 将 tauq[i__] 设为 0 */
        }
/* L20: */
    }
/* 结束循环 */
    }
/* 结束循环 */

    return 0;
/* 返回值为 0 */

/*     End of DGEBD2 */
/* DGEBD2 的结束 */

} /* dgebd2_ */
/* dgebd2_ 子程序的结束 */

/* Subroutine */ int dgebrd_(integer *m, integer *n, doublereal *a, integer *
    lda, doublereal *d__, doublereal *e, doublereal *tauq, doublereal *
    taup, doublereal *work, integer *lwork, integer *info)
{
/* 子程序 dgebrd_ 的开始 */

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, nb, nx;
    static doublereal ws;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static integer nbmin, iinfo, minmn;
    extern /* Subroutine */ int dgebd2_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *), dlabrd_(integer *, integer *, integer *
        , doublereal *, integer *, doublereal *, doublereal *, doublereal
        *, doublereal *, doublereal *, integer *, doublereal *, integer *)
        , xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwrkx, ldwrky, lwkopt;
    static logical lquery;

/* 变量声明和初始化 */

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======
    DGEBRD reduces a general real M-by-N matrix A to upper or lower
    bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.

    If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
*/

/* 用于将矩阵 A 缩减为上/下双对角形式的子程序 */

/* Arguments
   =========
   M       (input) INTEGER
           矩阵 A 的行数。M >= 0.

   N       (input) INTEGER
           矩阵 A 的列数。N >= 0.
*/
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors;
            if m < n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.

- `A`: 输入输出参数，双精度浮点数组，维度为 (LDA,N)。
  - 在输入时，是一个 M×N 的一般矩阵，用于进行约化。
  - 在输出时，
    - 若 m >= n，对角线和第一个超对角线会被上三角双对角矩阵 B 覆盖；
    - 对角线以下的元素会由数组 TAUQ 表示，代表正交矩阵 Q 是一系列初等反射器的乘积；
    - 第一个超对角线以上的元素由数组 TAUP 表示，代表正交矩阵 P 是一系列初等反射器的乘积。
    - 若 m < n，则对角线和第一个次对角线会被下三角双对角矩阵 B 覆盖；
    - 对角线以下的元素由数组 TAUQ 表示，代表正交矩阵 Q 是一系列初等反射器的乘积；
    - 对角线以上的元素由数组 TAUP 表示，代表正交矩阵 P 是一系列初等反射器的乘积。
    - 参见进一步详细说明。


    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

- `LDA`: 输入参数，整数。
  - 数组 A 的领导维度，即 A 的第一个维度的大小，必须满足 LDA >= max(1,M)。


    D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).

- `D`: 输出参数，双精度浮点数组，维度为 min(M,N)。
  - 双对角矩阵 B 的对角线元素。
  - D(i) 表示 B 的第 i 个对角线元素，即 A(i,i)。


    E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

- `E`: 输出参数，双精度浮点数组，维度为 min(M,N)-1。
  - 双对角矩阵 B 的非对角线元素。
  - 若 m >= n，则 E(i) 表示 B 的第 i 个超对角线元素，即 A(i,i+1)，其中 i = 1,2,...,n-1。
  - 若 m < n，则 E(i) 表示 B 的第 i 个次对角线元素，即 A(i+1,i)，其中 i = 1,2,...,m-1。


    TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.

- `TAUQ`: 输出参数，双精度浮点数组，维度为 min(M,N)。
  - 元素是初等反射器的标量因子，用于表示正交矩阵 Q。
  - 参见进一步详细说明。


    TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.

- `TAUP`: 输出参数，双精度浮点数组，维度为 min(M,N)。
  - 元素是初等反射器的标量因子，用于表示正交矩阵 P。
  - 参见进一步详细说明。


    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

- `WORK`: 工作空间/输出参数，双精度浮点数组，维度为 MAX(1,LWORK)。
  - 在程序退出时，如果 INFO = 0，WORK(1) 返回最优 LWORK 的大小。


    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

- `LWORK`: 输入参数，整数。
  - 数组 WORK 的长度，必须满足 LWORK >= max(1,M,N)。
  - 为了达到最佳性能，建议 LWORK >= (M+N)*NB，其中 NB 是最优块大小。
  - 若 LWORK = -1，则假定进行工作空间查询；程序只计算 WORK 数组的最优大小，并将此值作为 WORK 数组的第一个条目返回，不会因 LWORK 相关的错误而产生 XERBLA 错误信息。


    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

- `INFO`: 输出参数，整数。
  - 返回状态信息：
    - 0：成功退出。
    - < 0：若 INFO = -i，则表示第 i 个参数具有非法值。


    Further Details
    ===============

    The matrices Q and P are represented as products of elementary
    reflectors:

    If m >= n,

       Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

- 进一步详细说明：
  - 矩阵 Q 和 P 被表示为初等反射器的乘积形式。
  - 若 m >= n，
    - Q = H(1) H(2) . . . H(n)
    - P = G(1) G(2) . . . G(n-1)


       where each H(i) and G(i) is a reflection.

       H(i) is a plane rotation that zero's out elements below the
       diagonal in the i-th column, and G(i) is a plane rotation that
       zero's out elements to the right of the subdiagonal in the i-th
       row.

    If m < n,

       Q = H(1) H(2) . . . H(m-1)

       P = G(1) G(2) . . . G(m)

- 若 m < n，
  - Q = H(1) H(2) . . . H(m-1)
  - P = G(1) G(2) . . . G(m)


       where each H(i) and G(i) is a reflection.

       H(i) is a plane rotation that zero's out elements below the
       subdiagonal in the i-th row, and G(i) is a plane rotation that
    # 每个 H(i) 和 G(i) 的形式如下：

    # H(i) = I - tauq * v * v' 和 G(i) = I - taup * u * u'

    # 其中 tauq 和 taup 是实数标量，v 和 u 是实向量；
    # v(1:i-1) = 0，v(i) = 1，并且退出时 v(i+1:m) 存储在 A(i+1:m,i) 中；
    # u(1:i) = 0，u(i+1) = 1，并且退出时 u(i+2:n) 存储在 A(i,i+2:n) 中；
    # tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。

    # 如果 m < n，

    # Q = H(1) H(2) . . . H(m-1)  和  P = G(1) G(2) . . . G(m)

    # 每个 H(i) 和 G(i) 的形式如下：

    # H(i) = I - tauq * v * v' 和 G(i) = I - taup * u * u'

    # 其中 tauq 和 taup 是实数标量，v 和 u 是实向量；
    # v(1:i) = 0，v(i+1) = 1，并且退出时 v(i+2:m) 存储在 A(i+2:m,i) 中；
    # u(1:i-1) = 0，u(i) = 1，并且退出时 u(i+1:n) 存储在 A(i,i+1:n) 中；
    # tauq 存储在 TAUQ(i) 中，taup 存储在 TAUP(i) 中。

    # A 在退出时的内容可以通过以下示例来说明：

    # 当 m = 6 且 n = 5 (m > n) 时：          当 m = 5 且 n = 6 (m < n) 时：

    #   (  d   e   u1  u1  u1 )                 (  d   u1  u1  u1  u1  u1 )
    #   (  v1  d   e   u2  u2 )                 (  e   d   u2  u2  u2  u2 )
    #   (  v1  v2  d   e   u3 )                 (  v1  e   d   u3  u3  u3 )
    #   (  v1  v2  v3  d   e  )                 (  v1  v2  e   d   u4  u4 )
    #   (  v1  v2  v3  v4  d  )                 (  v1  v2  v3  e   d   u5 )
    #   (  v1  v2  v3  v4  v5 )                

    # 其中 d 和 e 表示 B 的对角线和非对角线元素，vi 表示定义 H(i) 的向量元素，ui 表示定义 G(i) 的向量元素。

    # =====================================================================


    # 测试输入参数
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--d__;
--e;
--tauq;
--taup;
--work;

/* Function Body */
*info = 0;
/* Computing MAX */
i__1 = 1, i__2 = ilaenv_(&c__1, "DGEBRD", " ", m, n, &c_n1, &c_n1, (
    ftnlen)6, (ftnlen)1);
nb = max(i__1,i__2);
lwkopt = (*m + *n) * nb;
work[1] = (doublereal) lwkopt;
lquery = *lwork == -1;

if (*m < 0) {
    *info = -1;
} else if (*n < 0) {
    *info = -2;
} else if (*lda < max(1,*m)) {
    *info = -4;
} else /* if(complicated condition) */ {
    /* Computing MAX */
    i__1 = max(1,*m);
    if (*lwork < max(i__1,*n) && ! lquery) {
        *info = -10;
    }
}
if (*info < 0) {
    i__1 = -(*info);
    xerbla_("DGEBRD", &i__1);
    return 0;
} else if (lquery) {
    return 0;
}

/* Quick return if possible */

minmn = min(*m,*n);
if (minmn == 0) {
    work[1] = 1.;
    return 0;
}

ws = (doublereal) max(*m,*n);
ldwrkx = *m;
ldwrky = *n;

if (nb > 1 && nb < minmn) {

    /* Set the crossover point NX. */
    /* Computing MAX */
    i__1 = nb, i__2 = ilaenv_(&c__3, "DGEBRD", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nx = max(i__1,i__2);

    /* Determine when to switch from blocked to unblocked code. */
    if (nx < minmn) {
        ws = (doublereal) ((*m + *n) * nb);
        if ((doublereal) (*lwork) < ws) {

            /* Not enough work space for the optimal NB, consider using
               a smaller block size. */

            nbmin = ilaenv_(&c__2, "DGEBRD", " ", m, n, &c_n1, &c_n1, (
                ftnlen)6, (ftnlen)1);
            if (*lwork >= (*m + *n) * nbmin) {
                nb = *lwork / (*m + *n);
            } else {
                nb = 1;
                nx = minmn;
            }
        }
    }
} else {
    nx = minmn;
}

i__1 = minmn - nx;
i__2 = nb;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {

    /* Reduce rows and columns i:i+nb-1 to bidiagonal form and return
       the matrices X and Y which are needed to update the unreduced
       part of the matrix. */

    i__3 = *m - i__ + 1;
    i__4 = *n - i__ + 1;
    dlabrd_(&i__3, &i__4, &nb, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[
        i__], &tauq[i__], &taup[i__], &work[1], &ldwrkx, &work[ldwrkx
        * nb + 1], &ldwrky);

    /* Update the trailing submatrix A(i+nb:m,i+nb:n), using an update
       of the form  A := A - V*Y' - X*U'. */

    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    dgemm_("No transpose", "Transpose", &i__3, &i__4, &nb, &c_b151, &a[
        i__ + nb + i__ * a_dim1], lda, &work[ldwrkx * nb + nb + 1], &
        ldwrky, &c_b15, &a[i__ + nb + (i__ + nb) * a_dim1], lda);
    i__3 = *m - i__ - nb + 1;
    i__4 = *n - i__ - nb + 1;
    dgemm_("No transpose", "No transpose", &i__3, &i__4, &nb, &c_b151, &
        work[nb + 1], &ldwrkx, &a[i__ + (i__ + nb) * a_dim1], lda, &
        c_b15, &a[i__ + nb + (i__ + nb) * a_dim1], lda);



    # 调用 BLAS 库中的 DGEMM 函数，进行矩阵乘法操作
    # 参数说明:
    # - "No transpose": 不对输入矩阵进行转置操作
    # - &i__3: 第一个矩阵的行数
    # - &i__4: 第二个矩阵的列数和结果矩阵的行数
    # - &nb: 第一个矩阵的列数和第二个矩阵的行数
    # - &c_b151: 乘法操作中的倍乘因子
    # - &work[nb + 1]: 第一个输入矩阵的起始地址
    # - &ldwrkx: 第一个输入矩阵的列数
    # - &a[i__ + (i__ + nb) * a_dim1]: 第二个输入矩阵的起始地址
    # - lda: 第二个输入矩阵的行数
    # - &c_b15: 乘法操作中的加法因子
    # - &a[i__ + nb + (i__ + nb) * a_dim1]: 结果矩阵的起始地址
    # - lda: 结果矩阵的行数
/*        Copy diagonal and off-diagonal elements of B back into A */

/* 如果行数 m 大于等于列数 n */
if (*m >= *n) {
    /* 循环将 B 的对角线和次对角线元素复制回 A */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 复制 B 的对角线元素到 A */
        a[j + j * a_dim1] = d__[j];
        /* 复制 B 的次对角线元素到 A */
        a[j + (j + 1) * a_dim1] = e[j];
        /* L10: */
    }
} else {
    /* 如果行数 m 小于列数 n */
    i__3 = i__ + nb - 1;
    for (j = i__; j <= i__3; ++j) {
        /* 复制 B 的对角线元素到 A */
        a[j + j * a_dim1] = d__[j];
        /* 复制 B 的次对角线元素到 A */
        a[j + 1 + j * a_dim1] = e[j];
        /* L20: */
    }
}
/* L30: */
}

/*     Use unblocked code to reduce the remainder of the matrix */

/* 用未块化的代码来处理矩阵的剩余部分 */
i__2 = *m - i__ + 1;
i__1 = *n - i__ + 1;
dgebd2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__], &
    tauq[i__], &taup[i__], &work[1], &iinfo);
/* 将 work[1] 设置为 ws */
work[1] = ws;
/* 返回 0 表示成功 */
return 0;

/*     End of DGEBRD */

} /* dgebrd_ */

/* 子程序 */ int dgeev_(char *jobvl, char *jobvr, integer *n, doublereal *
    a, integer *lda, doublereal *wr, doublereal *wi, doublereal *vl,
    integer *ldvl, doublereal *vr, integer *ldvr, doublereal *work,
    integer *lwork, integer *info)
{
/* 系统生成的本地变量 */
integer a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
    i__2, i__3;
doublereal d__1, d__2;

/* 本地变量 */
static integer i__, k;
static doublereal r__, cs, sn;
static integer ihi;
static doublereal scl;
static integer ilo;
static doublereal dum[1], eps;
static integer ibal;
static char side[1];
static doublereal anrm;
static integer ierr, itau;
extern /* 子程序 */ int drot_(integer *, doublereal *, integer *,
    doublereal *, integer *, doublereal *, doublereal *);
static integer iwrk, nout;
extern doublereal dnrm2_(integer *, doublereal *, integer *);
extern /* 子程序 */ int dscal_(integer *, doublereal *, doublereal *,
    integer *);
extern logical lsame_(char *, char *);
extern doublereal dlapy2_(doublereal *, doublereal *);
extern /* 子程序 */ int dlabad_(doublereal *, doublereal *), dgebak_(
    char *, char *, integer *, integer *, integer *, doublereal *,
    integer *, doublereal *, integer *, integer *),
    dgebal_(char *, integer *, doublereal *, integer *, integer *,
    integer *, doublereal *, integer *);
static logical scalea;

static doublereal cscale;
extern doublereal dlange_(char *, integer *, integer *, doublereal *,
    integer *, doublereal *);
extern /* 子程序 */ int dgehrd_(integer *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *,
    integer *), dlascl_(char *, integer *, integer *, doublereal *,
    doublereal *, integer *, integer *, doublereal *, integer *,
    integer *);
extern integer idamax_(integer *, doublereal *, integer *);
    # 外部函数声明：复制矩阵，拉特格矩阵生成，错误处理
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *),
        dlartg_(doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *), xerbla_(char *, integer *);

    # 静态变量声明：选择数组，存储逻辑选择标志
    static logical select[1];

    # 外部函数声明：环境查询函数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    # 静态变量声明：大数和小数，用于比较数值大小
    static doublereal bignum;
    static doublereal smlnum;

    # 外部函数声明：生成正交矩阵，哈雷矩阵求特征值，计算特征向量
    extern /* Subroutine */ int dorghr_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *), dhseqr_(char *, char *, integer *, integer *, integer
        *, doublereal *, integer *, doublereal *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, integer *);

    extern /* Subroutine */ int dtrevc_(char *, char *, logical *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, integer *, integer *, doublereal *, integer *);

    # 静态变量声明：最小工作空间，最大工作空间，用于哈雷函数计算
    static integer minwrk, maxwrk;

    # 静态变量声明：是否请求查询工作空间大小，是否要求计算左特征向量和右特征向量
    static logical lquery, wantvl, wantvr;

    # 静态变量声明：计算哈雷矩阵特征值时需要的工作空间大小
    static integer hswork;
"""
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
"""
    ! VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
    !         If JOBVR = 'V', the right eigenvectors v(j) are stored one
    !         after another in the columns of VR, in the same order
    !         as their eigenvalues.
    !         If JOBVR = 'N', VR is not referenced.
    !         If the j-th eigenvalue is real, then v(j) = VR(:,j),
    !         the j-th column of VR.
    !         If the j-th and (j+1)-st eigenvalues form a complex
    !         conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
    !         v(j+1) = VR(:,j) - i*VR(:,j+1).
    
    ! LDVR    (input) INTEGER
    !         The leading dimension of the array VR.  LDVR >= 1; if
    !         JOBVR = 'V', LDVR >= N.
    
    ! WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    ! LWORK   (input) INTEGER
    !         The dimension of the array WORK.  LWORK >= max(1,3*N), and
    !         if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
    !         performance, LWORK must generally be larger.
    !         
    !         If LWORK = -1, then a workspace query is assumed; the routine
    !         only calculates the optimal size of the WORK array, returns
    !         this value as the first entry of the WORK array, and no error
    !         message related to LWORK is issued by XERBLA.
    
    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument had an illegal value.
    !         > 0:  if INFO = i, the QR algorithm failed to compute all the
    !               eigenvalues, and no eigenvectors have been computed;
    !               elements i+1:N of WR and WI contain eigenvalues which
    !               have converged.
    
    ! =====================================================================
    
       Test the input arguments
    /* Parameter adjustments */
    // 设置矩阵 A 的维度参数
    a_dim1 = *lda;
    // 设置矩阵 A 的偏移量
    a_offset = 1 + a_dim1;
    // 调整矩阵 A 的指针
    a -= a_offset;
    // 调整实部特征值数组的指针
    --wr;
    // 调整虚部特征值数组的指针
    --wi;
    // 设置左特征向量矩阵 VL 的维度参数
    vl_dim1 = *ldvl;
    // 设置左特征向量矩阵 VL 的偏移量
    vl_offset = 1 + vl_dim1;
    // 调整左特征向量矩阵 VL 的指针
    vl -= vl_offset;
    // 设置右特征向量矩阵 VR 的维度参数
    vr_dim1 = *ldvr;
    // 设置右特征向量矩阵 VR 的偏移量
    vr_offset = 1 + vr_dim1;
    // 调整右特征向量矩阵 VR 的指针
    vr -= vr_offset;
    // 调整工作空间数组的指针
    --work;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 判断是否进行工作空间查询
    lquery = *lwork == -1;
    // 判断是否需要计算左特征向量
    wantvl = lsame_(jobvl, "V");
    // 判断是否需要计算右特征向量
    wantvr = lsame_(jobvr, "V");
    // 检查 jobvl 参数是否合法
    if (! wantvl && ! lsame_(jobvl, "N")) {
        *info = -1;
    } else if (! wantvr && ! lsame_(jobvr, "N")) {
        // 检查 jobvr 参数是否合法
        *info = -2;
    } else if (*n < 0) {
        // 检查矩阵维度参数 n 是否非负
        *info = -3;
    } else if (*lda < max(1,*n)) {
        // 检查矩阵 A 的列数是否合法
        *info = -5;
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
        // 检查左特征向量矩阵 VL 的列数是否合法
        *info = -9;
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
        // 检查右特征向量矩阵 VR 的列数是否合法
        *info = -11;
    }

/*
       Compute workspace
        (Note: Comments in the code beginning "Workspace:" describe the
         minimal amount of workspace needed at that point in the code,
         as well as the preferred amount for good performance.
         NB refers to the optimal block size for the immediately
         following subroutine, as returned by ILAENV.
         HSWORK refers to the workspace preferred by DHSEQR, as
         calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
         the worst case.)
*/

    // 如果没有错误信息
    if (*info == 0) {
        // 如果矩阵维度 n 为 0
        if (*n == 0) {
            // 设置最小和最大工作空间为 1
            minwrk = 1;
            maxwrk = 1;
        } else {
            // 计算最大所需工作空间
            maxwrk = (*n << 1) + *n * ilaenv_(&c__1, "DGEHRD", " ", n, &c__1,
                n, &c__0, (ftnlen)6, (ftnlen)1);
            // 如果需要计算左特征向量
            if (wantvl) {
                // 设置最小工作空间为 4*n
                minwrk = *n << 2;
                /* Computing MAX */
                // 计算最大工作空间需求
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                    "DORGHR", " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)
                    1);
                maxwrk = max(i__1,i__2);
                // 调用 DHSEQR 计算特征值和左特征向量
                dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
                    1], &vl[vl_offset], ldvl, &work[1], &c_n1, info);
                // 获取 DHSEQR 函数所需的工作空间大小
                hswork = (integer) work[1];
                /* Computing MAX */
                // 更新最大工作空间需求
                i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
                    n + hswork;
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                // 最终确定最大工作空间需求
                i__1 = maxwrk, i__2 = *n << 2;
                maxwrk = max(i__1,i__2);
            } else if (wantvr) {
                // 设置最小工作空间为 4*n
                minwrk = *n << 2;
                /* Computing MAX */
                // 计算最大工作空间需求
                i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1,
                    "DORGHR", " ", n, &c__1, n, &c_n1, (ftnlen)6, (ftnlen)
                    1);
                maxwrk = max(i__1,i__2);
                // 调用 DHSEQR 计算特征值和右特征向量
                dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
                    1], &vr[vr_offset], ldvr, &work[1], &c_n1, info);
                // 获取 DHSEQR 函数所需的工作空间大小
                hswork = (integer) work[1];
                /* Computing MAX */
                // 更新最大工作空间需求
                i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
                    n + hswork;
                maxwrk = max(i__1,i__2);
                /* Computing MAX */
                // 最终确定最大工作空间需求
                i__1 = maxwrk, i__2 = *n << 2;
                maxwrk = max(i__1,i__2);
            }
        }
    }
/* Computing MAX */
i__1 = maxwrk, i__2 = *n << 2;
maxwrk = max(i__1,i__2);



/* 计算MAX */
maxwrk = max(maxwrk, *n * 4);



} else {
minwrk = *n * 3;
dhseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
    1], &vr[vr_offset], ldvr, &work[1], &c_n1, info);
hswork = (integer) work[1];
/* Computing MAX */
i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
    n + hswork;
maxwrk = max(i__1,i__2);



} else {
    /* 如果不满足条件，则设置最小工作空间为3 * N */
    minwrk = *n * 3;
    /* 调用DHSEQR计算特征值问题，不计算Schur向量 */
    dhseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[1],
            &vr[vr_offset], ldvr, &work[1], &c_n1, info);
    /* 将DHSEQR的工作空间转换为整数类型 */
    hswork = (integer) work[1];
    /* 计算最大工作空间大小 */
    /* Computing MAX */
    i__1 = maxwrk, i__2 = *n + 1, i__1 = max(i__1,i__2), i__2 = *
        n + hswork;
    maxwrk = max(i__1,i__2);



}
maxwrk = max(maxwrk,minwrk);
}
work[1] = (doublereal) maxwrk;



}
/* 设置工作空间第一个元素为最大工作空间大小 */
work[1] = (doublereal) maxwrk;



if (*lwork < minwrk && ! lquery) {
*info = -13;
}
}



if (*lwork < minwrk && ! lquery) {
    /* 如果提供的工作空间小于所需的最小工作空间大小，并且不是查询模式 */
    *info = -13;
}



if (*info != 0) {
i__1 = -(*info);
xerbla_("DGEEV ", &i__1);
return 0;
} else if (lquery) {
return 0;
}



if (*info != 0) {
    /* 如果返回的信息代码不为0，则输出错误信息 */
    i__1 = -(*info);
    xerbla_("DGEEV ", &i__1);
    return 0;
} else if (lquery) {
    /* 如果是查询模式，则返回0 */
    return 0;
}



/*     Quick return if possible */

if (*n == 0) {
return 0;
}



/* 如果N为0，则直接返回 */
if (*n == 0) {
    return 0;
}



/*     Get machine constants */

eps = PRECISION;
smlnum = SAFEMINIMUM;
bignum = 1. / smlnum;
dlabad_(&smlnum, &bignum);
smlnum = sqrt(smlnum) / eps;
bignum = 1. / smlnum;



/* 获取机器常数 */
eps = PRECISION;
smlnum = SAFEMINIMUM;
bignum = 1.0 / smlnum;
dlabad_(&smlnum, &bignum);
smlnum = sqrt(smlnum) / eps;
bignum = 1.0 / smlnum;



/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

anrm = dlange_("M", n, n, &a[a_offset], lda, dum);
scalea = FALSE_;
if (anrm > 0. && anrm < smlnum) {
scalea = TRUE_;
cscale = smlnum;
} else if (anrm > bignum) {
scalea = TRUE_;
cscale = bignum;
}
if (scalea) {
dlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
    ierr);
}



/* 如果矩阵A中最大元素超出范围[SMLNUM,BIGNUM]，则对A进行缩放 */

/* 计算矩阵A的无穷范数 */
anrm = dlange_("M", n, n, &a[a_offset], lda, dum);
scalea = FALSE_;
if (anrm > 0. && anrm < smlnum) {
    scalea = TRUE_;
    cscale = smlnum;
} else if (anrm > bignum) {
    scalea = TRUE_;
    cscale = bignum;
}
/* 如果需要缩放，则调用DLASCL进行缩放 */
if (scalea) {
    dlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
        ierr);
}



/*
   Balance the matrix
   (Workspace: need N)
*/

ibal = 1;
dgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &work[ibal], &ierr);



/*
   平衡矩阵
   (工作空间: 需要N)
*/

ibal = 1;
dgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &work[ibal], &ierr);



/*
   Reduce to upper Hessenberg form
   (Workspace: need 3*N, prefer 2*N+N*NB)
*/

itau = ibal + *n;
iwrk = itau + *n;
i__1 = *lwork - iwrk + 1;
dgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
     &ierr);



/*
   将矩阵约化为上Hessenberg形式
   (工作空间: 需要 3*N, 最好 2*N+N*NB)
*/

itau = ibal + *n;
iwrk = itau + *n;
i__1 = *lwork - iwrk + 1;
dgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
     &ierr);



if (wantvl) {

/*
      Want left eigenvectors
      Copy Householder vectors to VL
*/

*(unsigned char *)side = 'L';
dlacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl)
    ;



if (wantvl) {

/*
   想要左特征向量
   将Householder向量复制到VL
*/

*(unsigned char *)side = 'L';
dlacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl);



/*
      Generate orthogonal matrix in VL
      (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB)
*/

i__1 = *lwork - iwrk + 1;
dorghr_(n, &ilo, &ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk],
     &i__1, &ierr);



/*
   在VL中生成正交矩阵
   (工作空间: 需要 3*N-1, 最好 2*N+(N-1)*NB)
*/

i__1 = *lwork - iwrk + 1;
dorghr_(n, &ilo, &ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk],
     &i__1, &ierr);



/*
      Perform QR iteration, accumulating Schur vectors in VL
      (Workspace: need N+1, prefer N+HSWORK (see comments) )
*/

iwrk = itau;
i__1 = *lwork - iwrk + 1;
dhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda
    dlacpy_("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr)
        ;



    调用名为 dlacpy_ 的 Fortran 子程序，用于复制矩阵 a 的左下部分到矩阵 vr 的对应位置。
    参数解释：
    - "L": 表示复制矩阵 a 的左下部分。
    - n: 矩阵的大小（行数和列数）。
    - &a[a_offset]: 矩阵 a 的起始地址，a_offset 是偏移量。
    - lda: 矩阵 a 的列数。
    - &vr[vr_offset]: 矩阵 vr 的起始地址，vr_offset 是偏移量。
    - ldvr: 矩阵 vr 的列数。
/*
          生成 VR 中的正交矩阵
          (工作空间需求: 3*N-1, 最好是 2*N+(N-1)*NB)
*/
i__1 = *lwork - iwrk + 1;
dorghr_(n, &ilo, &ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk],
     &i__1, &ierr);

/*
          执行 QR 迭代，累积 Schur 向量到 VR 中
          (工作空间需求: N+1, 最好是 N+HSWORK (详见注释))
*/
iwrk = itau;
i__1 = *lwork - iwrk + 1;
dhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &
    vr[vr_offset], ldvr, &work[iwrk], &i__1, info);

} else {

/*
          仅计算特征值
          (工作空间需求: N+1, 最好是 N+HSWORK (详见注释))
*/
iwrk = itau;
i__1 = *lwork - iwrk + 1;
dhseqr_("E", "N", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &
    vr[vr_offset], ldvr, &work[iwrk], &i__1, info);
}

/*     如果 DHSEQR 返回 INFO > 0，则退出 */
if (*info > 0) {
goto L50;
}

if (wantvl || wantvr) {

/*
          计算左右特征向量
          (工作空间需求: 4*N)
*/
dtrevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
     &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &ierr);
}

if (wantvl) {

/*
          撤销左特征向量的平衡
          (工作空间需求: N)
*/
dgebak_("B", "L", n, &ilo, &ihi, &work[ibal], n, &vl[vl_offset], ldvl,
     &ierr);

/*        规范化左特征向量并确保最大分量为实数 */
i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {
    if (wi[i__] == 0.) {
    scl = 1. / dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
    dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
    } else if (wi[i__] > 0.) {
    d__1 = dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
    d__2 = dnrm2_(n, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
    scl = 1. / dlapy2_(&d__1, &d__2);
    dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
    dscal_(n, &scl, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
    i__2 = *n;
    for (k = 1; k <= i__2; ++k) {
    /* 计算平方 */
        d__1 = vl[k + i__ * vl_dim1];
    /* 计算平方 */
        d__2 = vl[k + (i__ + 1) * vl_dim1];
        work[iwrk + k - 1] = d__1 * d__1 + d__2 * d__2;
    }
    k = idamax_(n, &work[iwrk], &c__1);
    dlartg_(&vl[k + i__ * vl_dim1], &vl[k + (i__ + 1) * vl_dim1],
        &cs, &sn, &r__);
    drot_(n, &vl[i__ * vl_dim1 + 1], &c__1, &vl[(i__ + 1) *
        vl_dim1 + 1], &c__1, &cs, &sn);
    vl[k + (i__ + 1) * vl_dim1] = 0.;
    }
}
}

if (wantvr) {

/*
          撤销右特征向量的平衡
          (工作空间需求: N)
*/
dgebak_("B", "R", n, &ilo, &ihi, &work[ibal], n, &vr[vr_offset], ldvr,
     &ierr);

/*        规范化右特征向量并确保最大分量为实数 */
i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 循环遍历索引 i__ 从 1 到 i__1
        if (wi[i__] == 0.) {
            // 如果 wi[i__] 等于 0，则执行以下操作
            scl = 1. / dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
            // 计算向量的二范数倒数，赋给 scl
            dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
            // 对向量 vr[i__ * vr_dim1 + 1] 进行标量乘法
        } else if (wi[i__] > 0.) {
            // 否则如果 wi[i__] 大于 0，则执行以下操作
            d__1 = dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
            // 计算向量的二范数，赋给 d__1
            d__2 = dnrm2_(n, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
            // 计算向量的二范数，赋给 d__2
            scl = 1. / dlapy2_(&d__1, &d__2);
            // 计算两个数的平方和的平方根的倒数，赋给 scl
            dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
            // 对向量 vr[i__ * vr_dim1 + 1] 进行标量乘法
            dscal_(n, &scl, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
            // 对向量 vr[(i__ + 1) * vr_dim1 + 1] 进行标量乘法
            i__2 = *n;
            // 设置循环变量 i__2 为 n
            for (k = 1; k <= i__2; ++k) {
                // 循环遍历索引 k 从 1 到 i__2
/* Computing 2nd power */
            d__1 = vr[k + i__ * vr_dim1];
/* Computing 2nd power */
            d__2 = vr[k + (i__ + 1) * vr_dim1];
            work[iwrk + k - 1] = d__1 * d__1 + d__2 * d__2;
/* L30: */
        }
        k = idamax_(n, &work[iwrk], &c__1);
        dlartg_(&vr[k + i__ * vr_dim1], &vr[k + (i__ + 1) * vr_dim1],
            &cs, &sn, &r__);
        drot_(n, &vr[i__ * vr_dim1 + 1], &c__1, &vr[(i__ + 1) *
            vr_dim1 + 1], &c__1, &cs, &sn);
        vr[k + (i__ + 1) * vr_dim1] = 0.;
        }
/* L40: */
    }
    }

/*     Undo scaling if necessary */

L50:
    if (scalea) {
    i__1 = *n - *info;
/* Computing MAX */
    i__3 = *n - *info;
    i__2 = max(i__3,1);
    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[*info +
        1], &i__2, &ierr);
    i__1 = *n - *info;
/* Computing MAX */
    i__3 = *n - *info;
    i__2 = max(i__3,1);
    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[*info +
        1], &i__2, &ierr);
    if (*info > 0) {
        i__1 = ilo - 1;
        dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[1],
            n, &ierr);
        i__1 = ilo - 1;
        dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[1],
            n, &ierr);
    }
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGEEV */

} /* dgeev_ */

/* Subroutine */ int dgehd2_(integer *n, integer *ilo, integer *ihi,
    doublereal *a, integer *lda, doublereal *tau, doublereal *work,
    integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__;
    static doublereal aii;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *), dlarfg_(integer *, doublereal *,
        doublereal *, integer *, doublereal *), xerbla_(char *, integer *);


注释：
    ! Test the input parameters
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            ! On entry, the n by n general matrix to be reduced.
            ! On exit, the upper triangle and the first subdiagonal of A
            ! are overwritten with the upper Hessenberg matrix H, and the
            ! elements below the first subdiagonal, with the array TAU,
            ! represent the orthogonal matrix Q as a product of elementary
            ! reflectors. See Further Details.

    LDA     (input) INTEGER
            ! The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) DOUBLE PRECISION array, dimension (N-1)
            ! The scalar factors of the elementary reflectors (see Further
            ! Details).

    WORK    (workspace) DOUBLE PRECISION array, dimension (N)

    INFO    (output) INTEGER
            ! = 0:  successful exit.
            ! < 0:  if INFO = -i, the i-th argument had an illegal value.

    ! Further Details
    ! ===============

    ! The matrix Q is represented as a product of (ihi-ilo) elementary
    ! reflectors
    !
    !    Q = H(ilo) H(ilo+1) . . . H(ihi-1).
    !
    ! Each H(i) has the form
    !
    !    H(i) = I - tau * v * v'
    !
    ! where tau is a real scalar, and v is a real vector with
    ! v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    ! exit in A(i+2:ihi,i), and tau in TAU(i).
    !
    ! The contents of A are illustrated by the following example, with
    ! n = 7, ilo = 2 and ihi = 6:
    !
    ! on entry,                        on exit,
    !
    ! ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    ! (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    ! (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    ! (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    ! (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    ! (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    ! (                         a )    (                          a )
    !
    ! where a denotes an element of the original matrix A, h denotes a
    ! modified element of the upper Hessenberg matrix H, and vi denotes an
    ! element of the vector defining H(i).
    !
    ! =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGEHD2", &i__1);
        return 0;
    }

    i__1 = *ihi - 1;
    for (i__ = *ilo; i__ <= i__1; ++i__) {

/*        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) */

        i__2 = *ihi - i__;
        /* Computing MIN */
        i__3 = i__ + 2;
        dlarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*n) + i__ *
            a_dim1], &c__1, &tau[i__]);
        aii = a[i__ + 1 + i__ * a_dim1];
        a[i__ + 1 + i__ * a_dim1] = 1.;

/*        Apply H(i) to A(1:ihi,i+1:ihi) from the right */

        i__2 = *ihi - i__;
        dlarf_("Right", ihi, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &a[(i__ + 1) * a_dim1 + 1], lda, &work[1]);

/*        Apply H(i) to A(i+1:ihi,i+1:n) from the left */

        i__2 = *ihi - i__;
        i__3 = *n - i__;
        dlarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);

        a[i__ + 1 + i__ * a_dim1] = aii;
/* L10: */
    }

    return 0;

/*     End of DGEHD2 */

} /* dgehd2_ */

/* Subroutine */ int dgehrd_(integer *n, integer *ilo, integer *ihi,
    doublereal *a, integer *lda, doublereal *tau, doublereal *work,
    integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j;
    static doublereal t[4160]    /* was [65][64] */;
    static integer ib;
    static doublereal ei;
    static integer nb, nh, nx, iws;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int dtrmm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *), daxpy_(
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *), dgehd2_(integer *, integer *, integer *, doublereal *,
         integer *, doublereal *, doublereal *, integer *), dlahr2_(
        integer *, integer *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *),
        dlarfb_(char *, char *, char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
    # 外部声明一个名为ilaenv_的函数，该函数接受多个整型参数和两个字符参数，并返回一个整数值
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
                           integer *, integer *, ftnlen, ftnlen);
    
    # 静态变量声明：ldwork为整数类型，lwkopt为整数类型
    static integer ldwork, lwkopt;
    
    # 静态逻辑类型变量声明：lquery为逻辑类型，通常用于表示查询状态
    static logical lquery;
"""
    -- LAPACK routine (version 3.2.1)                                  --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --


    Purpose
    =======

    DGEHRD reduces a real general matrix A to upper Hessenberg form H by
    an orthogonal similarity transformation:  Q' * A * Q = H .

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to DGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
"""
    n = 7, ilo = 2 and ihi = 6:

    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This file is a slight modification of LAPACK-3.0's DGEHRD
    subroutine incorporating improvements proposed by Quintana-Orti and
    Van de Geijn (2006). (See DLAHR2.)

    =====================================================================


       Test the input parameters



    n = 7, ilo = 2 and ihi = 6:
    # 设置矩阵维度 n 为 7，下标范围 ilo 从 2 到 ihi 为 6

    on entry,                        on exit,
    # 进入时矩阵状态，离开时矩阵状态

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )
    # 描述了矩阵 A 和上 Hessenberg 矩阵 H 在进入和退出时的变化，a 表示原始矩阵 A 的元素，h 表示上三角 Hessenberg 矩阵 H 的修改元素，vi 表示定义 H(i) 的向量元素。

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).

    This file is a slight modification of LAPACK-3.0's DGEHRD
    subroutine incorporating improvements proposed by Quintana-Orti and
    Van de Geijn (2006). (See DLAHR2.)

    =====================================================================


       Test the input parameters
    # 对输入参数进行测试
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

    /* Computing MIN */
    // 确定 nb 的值，为两个值的最小值
    i__1 = 64, i__2 = ilaenv_(&c__1, "DGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);

    // 计算所需的工作空间大小
    lwkopt = *n * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;  // 是否为查询模式

    // 检查输入参数是否合法，若不合法则设置相应的错误代码
    if (*n < 0) {
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) {
        *info = -8;
    }

    // 如果有错误信息，则调用错误处理程序并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGEHRD", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero */

    // 将数组 tau 的部分元素设置为零
    i__1 = *ilo - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        tau[i__] = 0.;
    }

    i__1 = *n - 1;
    // 将数组 tau 的部分元素设置为零
    for (i__ = max(1,*ihi); i__ <= i__1; ++i__) {
        tau[i__] = 0.;
    }

/*     Quick return if possible */

    // 如果 nh <= 1，直接设置工作数组的第一个元素为 1 并返回
    nh = *ihi - *ilo + 1;
    if (nh <= 1) {
        work[1] = 1.;
        return 0;
    }

/*
       Determine the block size

   Computing MIN
*/
    // 确定块大小 nb 的值，为两个值的最小值
    i__1 = 64, i__2 = ilaenv_(&c__1, "DGEHRD", " ", n, ilo, ihi, &c_n1, (
        ftnlen)6, (ftnlen)1);
    nb = min(i__1,i__2);
    nbmin = 2;
    iws = 1;

    // 如果 nb 大于 1 并且小于 nh，则进行以下判断
    if (nb > 1 && nb < nh) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code)

   Computing MAX
*/
        // 确定从块代码切换到非块代码的交叉点
        i__1 = nb, i__2 = ilaenv_(&c__3, "DGEHRD", " ", n, ilo, ihi, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);

        // 如果 nx 小于 nh，则进行以下判断
        if (nx < nh) {

/*           Determine if workspace is large enough for blocked code */

            // 计算需要的工作空间大小
            iws = *n * nb;

            // 如果当前工作空间不够，则重新确定 nb 的最小值，或者强制使用非块代码
            if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code

   Computing MAX
*/
                // 确定 nbmin 的值
                i__1 = 2, i__2 = ilaenv_(&c__2, "DGEHRD", " ", n, ilo, ihi, &
                    c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);

                // 根据当前工作空间大小确定 nb 的值
                if (*lwork >= *n * nbmin) {
                    nb = *lwork / *n;
                } else {
                    nb = 1;
                }
            }
        }
    }

    // 设置工作数组的维度大小
    ldwork = *n;

    // 如果 nb 小于 nbmin 或者 nb 大于等于 nh，则使用非块代码
    if (nb < nbmin || nb >= nh) {

/*        Use unblocked code below */

        i__ = *ilo;

    } else {

/*        Use blocked code */

        // 对每个块进行处理
        i__1 = *ihi - 1 - nx;
        i__2 = nb;
        for (i__ = *ilo; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
            // 确定当前块的大小
            i__3 = nb, i__4 = *ihi - i__;
            ib = min(i__3,i__4);

/*
             Reduce columns i:i+ib-1 to Hessenberg form, returning the
             matrices V and T of the block reflector H = I - V*T*V'
             which performs the reduction, and also the matrix Y = A*V*T
*/
/*

        dlahr2_(ihi, &i__, &ib, &a[i__ * a_dim1 + 1], lda, &tau[i__], t, &
            c__65, &work[1], &ldwork);

/*
             对 A(1:ihi,i+ib:ihi) 右侧应用分块反射器 H，计算 A := A - Y * V'。必须设置 V(i+ib,ib-1) 为 1
*/

        ei = a[i__ + ib + (i__ + ib - 1) * a_dim1];
        a[i__ + ib + (i__ + ib - 1) * a_dim1] = 1.;
        i__3 = *ihi - i__ - ib + 1;
        dgemm_("No transpose", "Transpose", ihi, &i__3, &ib, &c_b151, &
            work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &
            c_b15, &a[(i__ + ib) * a_dim1 + 1], lda);
        a[i__ + ib + (i__ + ib - 1) * a_dim1] = ei;

/*
             对 A(1:i,i+1:i+ib-1) 右侧应用分块反射器 H
*/

        i__3 = ib - 1;
        dtrmm_("Right", "Lower", "Transpose", "Unit", &i__, &i__3, &c_b15,
             &a[i__ + 1 + i__ * a_dim1], lda, &work[1], &ldwork);
        i__3 = ib - 2;
        for (j = 0; j <= i__3; ++j) {
        daxpy_(&i__, &c_b151, &work[ldwork * j + 1], &c__1, &a[(i__ +
            j + 1) * a_dim1 + 1], &c__1);
/* L30: */
        }

/*
             对 A(i+1:ihi,i+ib:n) 左侧应用分块反射器 H
*/

        i__3 = *ihi - i__;
        i__4 = *n - i__ - ib + 1;
        dlarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
            i__4, &ib, &a[i__ + 1 + i__ * a_dim1], lda, t, &c__65, &a[
            i__ + 1 + (i__ + ib) * a_dim1], lda, &work[1], &ldwork);
/* L40: */
    }
    }

/*     使用未分块代码处理矩阵的剩余部分 */

    dgehd2_(n, &i__, ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
    work[1] = (doublereal) iws;

    return 0;

/*     DGEHRD 结束 */

} /* dgehrd_ */

/* 子程序 */ int dgelq2_(integer *m, integer *n, doublereal *a, integer *
    lda, doublereal *tau, doublereal *work, integer *info)
{
    /* 系统生成的本地变量 */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* 本地变量 */
    static integer i__, k;
    static doublereal aii;
    extern /* 子程序 */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *), dlarfg_(integer *, doublereal *,
        doublereal *, integer *, doublereal *), xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DGELQ2 计算实数 m 行 n 列矩阵 A 的 LQ 分解：
    A = L * Q.

    Arguments
    =========

    M       (输入) 整数
            矩阵 A 的行数。M >= 0.

    N       (输入) 整数
            矩阵 A 的列数。N >= 0.
*/
    ! 测试输入参数的合法性
    Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0
    if (*m < 0) {  // 检查 m 是否小于 0
        *info = -1;  // 若 m 小于 0，则设置 info 为 -1
    } else if (*n < 0) {  // 检查 n 是否小于 0
        *info = -2;  // 若 n 小于 0，则设置 info 为 -2
    } else if (*lda < max(1,*m)) {  // 检查 lda 是否小于 max(1, m)
        *info = -4;  // 若 lda 小于 max(1, m)，则设置 info 为 -4
    }
    if (*info != 0) {  // 如果 info 不为 0，表示有错误
        i__1 = -(*info);
        xerbla_("DGELQ2", &i__1);  // 调用 xerbla 函数报告错误
        return 0;  // 返回
    }

    k = min(*m,*n);  // 计算 k = min(m, n)

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i,i+1:n) */

        i__2 = *n - i__ + 1;
/* Computing MIN */
        i__3 = i__ + 1;
        dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) * a_dim1]
            , lda, &tau[i__]);  // 调用 dlarfg 函数生成用于消除 A(i,i+1:n) 的反射变换 H(i)
        if (i__ < *m) {

/*           Apply H(i) to A(i+1:m,i:n) from the right */

            doublereal aii = a[i__ + i__ * a_dim1];
            a[i__ + i__ * a_dim1] = 1.;
            i__2 = *m - i__;
            i__3 = *n - i__ + 1;
            dlarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[
                i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);  // 调用 dlarf 函数将反射变换 H(i) 应用到 A(i+1:m,i:n) 的右侧
            a[i__ + i__ * a_dim1] = aii;  // 恢复 A(i,i) 的值
        }
/* L10: */
    }
    return 0;

/*     End of DGELQ2 */

} /* dgelq2_ */

/* Subroutine */ int dgelqf_(integer *m, integer *n, doublereal *a, integer *
    lda, doublereal *tau, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int dgelq2_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *), dlarfb_(char *,
         char *, char *, char *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DGELQF computes an LQ factorization of a real M-by-N matrix A:
    A = L * Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.
    ! Test the input arguments
    ! 测试输入参数

    IF (M.LT.0) THEN
        ! If M is less than zero, set INFO = -1 and return
        ! 如果 M 小于零，则将 INFO 设为 -1 并返回
        INFO = -1
        RETURN
    ELSE IF (N.LT.0) THEN
        ! If N is less than zero, set INFO = -2 and return
        ! 如果 N 小于零，则将 INFO 设为 -2 并返回
        INFO = -2
        RETURN
    ELSE IF (LDA.LT.MAX(1,M)) THEN
        ! If LDA is less than max(1,M), set INFO = -4 and return
        ! 如果 LDA 小于 max(1,M)，则将 INFO 设为 -4 并返回
        INFO = -4
        RETURN
    ELSE IF (LWORK.LT.MAX(1,M) .AND. LWORK.NE.-1) THEN
        ! If LWORK is less than max(1,M) and not equal to -1, set INFO = -7 and return
        ! 如果 LWORK 小于 max(1,M) 且不等于 -1，则将 INFO 设为 -7 并返回
        INFO = -7
        RETURN
    END IF

    ! Quick return if possible
    ! 如果可能的话，快速返回
    IF (M.EQ.0 .OR. N.EQ.0) THEN
        ! If M or N is zero, set INFO = 0 and return
        ! 如果 M 或 N 等于零，则将 INFO 设为 0 并返回
        INFO = 0
        RETURN
    END IF

    ! Compute the optimal block size NB
    ! 计算最优块大小 NB
    NB = ILAENV(1, 'DGEQRF', ' ', M, N, -1, -1)

    ! Compute the optimal LWORK
    ! 计算最优 LWORK
    LWKOPT = M * NB

    IF (LWORK.EQ.-1) THEN
        ! If LWORK = -1, set WORK(1) = LWKOPT and return
        ! 如果 LWORK = -1，则将 WORK(1) 设为 LWKOPT 并返回
        WORK(1) = LWKOPT
        RETURN
    END IF

    ! Verify that LWORK is sufficient
    ! 验证 LWORK 是否足够
    IF (LWORK.LT.M * NB) THEN
        ! If LWORK is less than M * NB, set INFO = -7 and return
        ! 如果 LWORK 小于 M * NB，则将 INFO 设为 -7 并返回
        INFO = -7
        RETURN
    END IF
    /* 参数调整 */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* 函数体 */
    *info = 0;
    // 调用 ILAENV 获取最优块大小 NB
    nb = ilaenv_(&c__1, "DGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    // 计算工作空间所需大小
    lwkopt = *m * nb;
    work[1] = (doublereal) lwkopt;
    // 判断是否为查询工作空间大小
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*m)) {
        *info = -4;
    } else if (*lwork < max(1,*m) && ! lquery) {
        *info = -7;
    }
    // 如果有错误信息，调用 XERBLA 处理并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGELQF", &i__1);
        return 0;
    } else if (lquery) {
        // 如果是查询工作空间大小，直接返回
        return 0;
    }

/*     如果可能，快速返回 */

    // 计算 k 的最小值
    k = min(*m,*n);
    // 如果 k 为 0，设置工作空间大小为 1 并返回
    if (k == 0) {
        work[1] = 1.;
        return 0;
    }

    // 初始化 nbmin 和 nx
    nbmin = 2;
    nx = 0;
    iws = *m;
    // 如果 nb 大于 1 并且小于 k
    if (nb > 1 && nb < k) {

/*
          确定从阻塞代码到非阻塞代码的切换点。

   计算 MAX
*/
        // 调用 ILAENV 获取交叉点 NX
        i__1 = 0, i__2 = ilaenv_(&c__3, "DGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        // 如果 NX 小于 k
        if (nx < k) {

/*           判断工作空间是否足够用于阻塞代码。 */

            ldwork = *m;
            iws = ldwork * nb;
            // 如果工作空间不足以使用最优 NB，则减小 NB 并确定最小值
            if (*lwork < iws) {

/*
                工作空间不足以使用最优 NB：减小 NB 并确定 NB 的最小值。
*/

                nb = *lwork / ldwork;
                // 计算 MAX
                i__1 = 2, i__2 = ilaenv_(&c__2, "DGELQF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    // 如果 nb 大于等于 nbmin 并且小于 k 且 nx 小于 k
    if (nb >= nbmin && nb < k && nx < k) {

/*        首先使用阻塞代码 */

        // 循环进行阻塞代码的 LQ 分解
        i__1 = k - nx;
        i__2 = nb;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* 计算 MIN */
            i__3 = k - i__ + 1;
            ib = min(i__3,nb);

/*
             计算当前块 A(i:i+ib-1,i:n) 的 LQ 分解。
*/

            i__3 = *n - i__ + 1;
            dgelq2_(&ib, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &iinfo);
            // 如果 i+ib <= m，形成块反射器的上三角因子 H
            if (i__ + ib <= *m) {

/*
                形成块反射器 H = H(i) H(i+1) . . . H(i+ib-1)
*/

                i__3 = *n - i__ + 1;
                dlarft_("Forward", "Rowwise", &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              从右侧将 H 应用于 A(i+ib:m,i:n) */

                i__3 = *m - i__ - ib + 1;
                i__4 = *n - i__ + 1;
                dlarfb_("Right", "No transpose", "Forward", "Rowwise", &i__3, &i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib + 1], &ldwork);
            }
/* L10: */
        }
    } else {
        i__ = 1;
    }

/*     使用非阻塞代码来进行最后或唯一的块的 LQ 分解。 */

    if (i__ <= k) {
        i__2 = *m - i__ + 1;
        i__1 = *n - i__ + 1;


这段代码是 Fortran 77 风格的 LAPACK 子例程 `DGELQF` 的 C 语言实现，用于计算矩阵的 LQ 分解。
    # 调用 LAPACK 库中的 dgelq2_ 子程序，执行 LQ 分解，矩阵 a 的子块操作
    dgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    # 结束循环
    
    # 将整数 iws 转换为双精度浮点数，并存储在 work 数组的第一个位置
    work[1] = (doublereal) iws;
    # 返回 0 表示成功执行
    return 0;
/*     End of DGELQF */

} /* dgelqf_ */

/* Subroutine */ int dgelsd_(integer *m, integer *n, integer *nrhs,
    doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *
    s, doublereal *rcond, integer *rank, doublereal *work, integer *lwork,
     integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer ie, il, mm;
    static doublereal eps, anrm, bnrm;
    static integer itau, nlvl, iascl, ibscl;
    static doublereal sfmin;
    static integer minmn, maxmn, itaup, itauq, mnthr, nwork;
    extern /* Subroutine */ int dlabad_(doublereal *, doublereal *), dgebrd_(
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         integer *);
    extern doublereal dlamch_(char *), dlange_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *);
    extern /* Subroutine */ int dgelqf_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, integer *),
        dlalsd_(char *, integer *, integer *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *, integer *), dlascl_(char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        integer *, doublereal *, integer *, integer *), dgeqrf_(
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, integer *), dlacpy_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *), dlaset_(char *, integer *, integer *, doublereal *,
        doublereal *, doublereal *, integer *), xerbla_(char *,
        integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static doublereal bignum;
    extern /* Subroutine */ int dormbr_(char *, char *, char *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, integer *);
    static integer wlalsd;
    extern /* Subroutine */ int dormlq_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    static integer ldwork;
    extern /* Subroutine */ int dormqr_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    static integer liwork, minwrk, maxwrk;
    static doublereal smlnum;
    static logical lquery;
    static integer smlsiz;


/* 
    -- LAPACK driver routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DGELSD computes the minimum-norm solution to a real linear least
    squares problem:
        minimize 2-norm(| b - A*x |)
    using the singular value decomposition (SVD) of A. A is an M-by-N
    matrix which may be rank-deficient.


    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.


    The problem is solved in three steps:
    (1) Reduce the coefficient matrix A to bidiagonal form with
        Householder transformations, reducing the original problem
        into a "bidiagonal least squares problem" (BLS)
    (2) Solve the BLS using a divide and conquer approach.
    (3) Apply back all the Householder tranformations to solve
        the original least squares problem.


    The effective rank of A is determined by treating as zero those
    singular values which are less than RCOND times the largest singular
    value.


    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.


    Arguments
    =========

    M       (input) INTEGER
            The number of rows of A. M >= 0.

    N       (input) INTEGER
            The number of columns of A. N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrices B and X. NRHS >= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, B is overwritten by the N-by-NRHS solution
            matrix X.  If m >= n and RANK = n, the residual
            sum-of-squares for the solution in the i-th column is given
            by the sum of squares of elements n+1:m in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,max(M,N)).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A in decreasing order.
            The condition number of A in the 2-norm = S(1)/S(min(m,n)).
    # RCOND   (input) DOUBLE PRECISION
    #         RCOND is used to determine the effective rank of A.
    #         Singular values S(i) <= RCOND*S(1) are treated as zero.
    #         If RCOND < 0, machine precision is used instead.

    # RANK    (output) INTEGER
    #         The effective rank of A, i.e., the number of singular values
    #         which are greater than RCOND*S(1).

    # WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
    #         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    # LWORK   (input) INTEGER
    #         The dimension of the array WORK. LWORK must be at least 1.
    #         The exact minimum amount of workspace needed depends on M,
    #         N and NRHS. As long as LWORK is at least
    #             12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,
    #         if M is greater than or equal to N or
    #             12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,
    #         if M is less than N, the code will execute correctly.
    #         SMLSIZ is returned by ILAENV and is equal to the maximum
    #         size of the subproblems at the bottom of the computation
    #         tree (usually about 25), and
    #            NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
    #         For good performance, LWORK should generally be larger.
    #         
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the WORK array, returns
    #         this value as the first entry of the WORK array, and no error
    #         message related to LWORK is issued by XERBLA.

    # IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
    #         LIWORK >= max(1, 3 * MINMN * NLVL + 11 * MINMN),
    #         where MINMN = MIN( M,N ).
    #         On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.

    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value.
    #         > 0:  the algorithm for computing the SVD failed to converge;
    #               if INFO = i, i off-diagonal elements of an intermediate
    #               bidiagonal form did not converge to zero.

    # Further Details
    # ===============

    # Based on contributions by
    #    Ming Gu and Ren-Cang Li, Computer Science Division, University of
    #      California at Berkeley, USA
    #    Osni Marques, LBNL/NERSC, USA

    # =====================================================================


    # Test the input arguments.
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --s;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;
    minmn = min(*m,*n);
    maxmn = max(*m,*n);
    mnthr = ilaenv_(&c__6, "DGELSD", " ", m, n, nrhs, &c_n1, (ftnlen)6, (ftnlen)1);
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*nrhs < 0) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*ldb < max(1,maxmn)) {
        *info = -7;
    }

    smlsiz = ilaenv_(&c__9, "DGELSD", " ", &c__0, &c__0, &c__0, &c__0, (ftnlen)6, (ftnlen)1);

    /*
           Compute workspace.
           (Note: Comments in the code beginning "Workspace:" describe the
           minimal amount of workspace needed at that point in the code,
           as well as the preferred amount for good performance.
           NB refers to the optimal block size for the immediately
           following subroutine, as returned by ILAENV.)
    */

    minwrk = 1;
    liwork = 1;
    minmn = max(1,minmn);
    /* Computing MAX */
    i__1 = (integer) (log((doublereal) minmn / (doublereal) (smlsiz + 1)) / log(2.)) + 1;
    nlvl = max(i__1,0);

    if (*info == 0) {
        maxwrk = 0;
        liwork = minmn * 3 * nlvl + minmn * 11;
        mm = *m;
        if (*m >= *n && *m >= mnthr) {

            /* Path 1a - overdetermined, with many more rows than columns. */

            mm = *n;
            /* Computing MAX */
            i__1 = maxwrk, i__2 = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m,
                n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
            maxwrk = max(i__1,i__2);
            /* Computing MAX */
            i__1 = maxwrk, i__2 = *n + *nrhs * ilaenv_(&c__1, "DORMQR", "LT",
                m, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)2);
            maxwrk = max(i__1,i__2);
        }
        if (*m >= *n) {

            /*
                     Path 1 - overdetermined or exactly determined.

            Computing MAX
            */
            i__1 = maxwrk, i__2 = *n * 3 + (mm + *n) * ilaenv_(&c__1, "DGEBRD"
                , " ", &mm, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
            maxwrk = max(i__1,i__2);
            /* Computing MAX */
            i__1 = maxwrk, i__2 = *n * 3 + *nrhs * ilaenv_(&c__1, "DORMBR",
                "QLT", &mm, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);
            maxwrk = max(i__1,i__2);
            /* Computing MAX */
            i__1 = maxwrk, i__2 = *n * 3 + (*n - 1) * ilaenv_(&c__1, "DORMBR",
                 "PLN", n, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);
            maxwrk = max(i__1,i__2);
            /* Computing 2nd power */
            i__1 = smlsiz + 1;
            wlalsd = *n * 9 + (*n << 1) * smlsiz + (*n << 3) * nlvl + *n * *
                nrhs + i__1 * i__1;
            /* Computing MAX */
            i__1 = maxwrk, i__2 = *n * 3 + wlalsd;
            maxwrk = max(i__1,i__2);
            /* Computing MAX */
            i__1 = *n * 3 + mm, i__2 = *n * 3 + *nrhs, i__1 = max(i__1,i__2),
                i__2 = *n * 3 + wlalsd;
            minwrk = max(i__1,i__2);
        }
        if (*n > *m) {
/* Computing 2nd power */
i__1 = smlsiz + 1;  // 计算 smlsiz + 1 的值，用于后续的计算
wlalsd = *m * 9 + (*m << 1) * smlsiz + (*m << 3) * nlvl + *m * *nrhs + i__1 * i__1;  // 计算 wlalsd 的值，涉及多个参数的复合计算
if (*n >= mnthr) {

    /*
        Path 2a - underdetermined, with many more columns
        than rows.
    */

    maxwrk = *m + *m * ilaenv_(&c__1, "DGELQF", " ", m, n, &c_n1,
        &c_n1, (ftnlen)6, (ftnlen)1);  // 设置 maxwrk 初值，根据 DGELQF 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m << 1) *
        ilaenv_(&c__1, "DGEBRD", " ", m, m, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DGEBRD 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + *nrhs * ilaenv_(&
        c__1, "DORMBR", "QLT", m, nrhs, m, &c_n1, (ftnlen)6, (
        ftnlen)3);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DORMBR QLT 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + (*m - 1) *
        ilaenv_(&c__1, "DORMBR", "PLN", m, nrhs, m, &c_n1, (
        ftnlen)6, (ftnlen)3);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DORMBR PLN 算法的工作空间估计

    if (*nrhs > 1) {
        /* Computing MAX */
        i__1 = maxwrk, i__2 = *m * *m + *m + *m * *nrhs;
        maxwrk = max(i__1,i__2);  // 如果 nrhs 大于 1，再次更新 maxwrk
    } else {
        /* Computing MAX */
        i__1 = maxwrk, i__2 = *m * *m + (*m << 1);
        maxwrk = max(i__1,i__2);  // 否则更新 maxwrk，基于 *m * *m + (*m << 1)
    }

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m + *nrhs * ilaenv_(&c__1, "DORMLQ",
        "LT", n, nrhs, m, &c_n1, (ftnlen)6, (ftnlen)2);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DORMLQ LT 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * *m + (*m << 2) + wlalsd;
    maxwrk = max(i__1,i__2);  // 最后更新 maxwrk，包括 wlalsd 的值

    /*
       XXX: Ensure the Path 2a case below is triggered.  The workspace
       calculation should use queries for all routines eventually.
   Computing MAX
   Computing MAX
    */
    i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4), i__3 =
         max(i__3,*nrhs), i__4 = *n - *m * 3;
    i__1 = maxwrk, i__2 = (*m << 2) + *m * *m + max(i__3,i__4);
    maxwrk = max(i__1,i__2);  // 最后一次更新 maxwrk，考虑多个参数的复合计算
} else {

    /* Path 2 - remaining underdetermined cases. */

    maxwrk = *m * 3 + (*n + *m) * ilaenv_(&c__1, "DGEBRD", " ", m,
         n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 设置 maxwrk 初值，根据 DGEBRD 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * 3 + *nrhs * ilaenv_(&c__1, "DORMBR"
        , "QLT", m, nrhs, n, &c_n1, (ftnlen)6, (ftnlen)3);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DORMBR QLT 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR",
        "PLN", n, nrhs, m, &c_n1, (ftnlen)6, (ftnlen)3);
    maxwrk = max(i__1,i__2);  // 更新 maxwrk，考虑 DORMBR PLN 算法的工作空间估计

    /* Computing MAX */
    i__1 = maxwrk, i__2 = *m * 3 + wlalsd;
    maxwrk = max(i__1,i__2);  // 最后更新 maxwrk，包括 wlalsd 的值
}

/* Computing MAX */
i__1 = *m * 3 + *nrhs, i__2 = *m * 3 + *m, i__1 = max(i__1,i__2),
    i__2 = *m * 3 + wlalsd;
minwrk = max(i__1,i__2);  // 计算 minwrk，基于多个参数的复合计算

minwrk = min(minwrk,maxwrk);  // 最终确定 minwrk 为 min(minwrk, maxwrk)
work[1] = (doublereal) maxwrk;  // 将 maxwrk 赋给 work 数组的第一个元素
iwork[1] = liwork;  // 将 liwork 赋给 iwork 数组的第一个元素
    // 检查工作数组长度是否小于最小工作长度并且不是查询模式
    if (*lwork < minwrk && !lquery) {
        // 如果是，则设置错误代码为-12
        *info = -12;
    }
    // 如果有错误信息
    if (*info != 0) {
        // 将错误代码取反并调用错误处理函数 xerbla_
        i__1 = -(*info);
        xerbla_("DGELSD", &i__1);
        // 返回0
        return 0;
    } else if (lquery) {
        // 如果是查询模式，跳转到标签 L10
        goto L10;
    }
/*     Quick return if possible. */
if (*m == 0 || *n == 0) {
    *rank = 0;
    return 0;
}

/*     Get machine parameters. */
eps = PRECISION;
sfmin = SAFEMINIMUM;
smlnum = sfmin / eps;
bignum = 1. / smlnum;
dlabad_(&smlnum, &bignum);

/*     Scale A if max entry outside range [SMLNUM,BIGNUM]. */
anrm = dlange_("M", m, n, &a[a_offset], lda, &work[1]);
iascl = 0;
if (anrm > 0. && anrm < smlnum) {
    /*        Scale matrix norm up to SMLNUM. */
    dlascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda,
            info);
    iascl = 1;
} else if (anrm > bignum) {
    /*        Scale matrix norm down to BIGNUM. */
    dlascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda,
            info);
    iascl = 2;
} else if (anrm == 0.) {
    /*        Matrix all zero. Return zero solution. */
    i__1 = max(*m,*n);
    dlaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[b_offset], ldb);
    dlaset_("F", &minmn, &c__1, &c_b29, &c_b29, &s[1], &c__1);
    *rank = 0;
    goto L10;
}

/*     Scale B if max entry outside range [SMLNUM,BIGNUM]. */
bnrm = dlange_("M", m, nrhs, &b[b_offset], ldb, &work[1]);
ibscl = 0;
if (bnrm > 0. && bnrm < smlnum) {
    /*        Scale matrix norm up to SMLNUM. */
    dlascl_("G", &c__0, &c__0, &bnrm, &smlnum, m, nrhs, &b[b_offset], ldb,
            info);
    ibscl = 1;
} else if (bnrm > bignum) {
    /*        Scale matrix norm down to BIGNUM. */
    dlascl_("G", &c__0, &c__0, &bnrm, &bignum, m, nrhs, &b[b_offset], ldb,
            info);
    ibscl = 2;
}

/*     If M < N make sure certain entries of B are zero. */
if (*m < *n) {
    i__1 = *n - *m;
    dlaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[*m + 1 + b_dim1], ldb);
}

/*     Overdetermined case. */
if (*m >= *n) {

/*        Path 1 - overdetermined or exactly determined. */
    mm = *m;
    if (*m >= mnthr) {

/*           Path 1a - overdetermined, with many more rows than columns. */
        mm = *n;
        itau = 1;
        nwork = itau + *n;

        /*
             Compute A=Q*R.
             (Workspace: need 2*N, prefer N+N*NB)
        */
        i__1 = *lwork - nwork + 1;
        dgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
                info);

        /*
             Multiply B by transpose(Q).
             (Workspace: need N+NRHS, prefer N+NRHS*NB)
        */
        i__1 = *lwork - nwork + 1;
        dormqr_("L", "T", m, nrhs, n, &a[a_offset], lda, &work[itau], &b[
                b_offset], ldb, &work[nwork], &i__1, info);

        /*           Zero out below R. */
        if (*n > 1) {
            i__1 = *n - 1;
            i__2 = *n - 1;
            dlaset_("L", &i__1, &i__2, &c_b29, &c_b29, &a[a_dim1 + 2],
                    lda);
        }
    }

    ie = 1;
    itauq = ie + *n;
    itaup = itauq + *n;
    nwork = itaup + *n;

    /*
          Bidiagonalize R in A.
          (Workspace: need 3*N+MM, prefer 3*N+(MM+N)*NB)
    */
    i__1 = *lwork - nwork + 1;
    # 调用外部 Fortran 函数 dgebrd_，对矩阵进行双边分解
    dgebrd_(&mm, n, &a[a_offset], lda, &s[1], &work[ie], &work[itauq], &
            work[itaup], &work[nwork], &i__1, info);
    # 参数说明：
    # - mm: 控制分解过程的整数参数
    # - n: 矩阵的阶数
    # - &a[a_offset]: 矩阵 a 的起始地址（在 Fortran 中通常使用偏移量 a_offset）
    # - lda: 矩阵 a 的列数
    # - &s[1]: 双边分解后的特征值和奇异值
    # - &work[ie]: 存储额外信息的工作数组
    # - &work[itauq]: 存储分解结果的工作数组
    # - &work[itaup]: 存储分解结果的工作数组
    # - &work[nwork]: 存储其他计算过程中的工作数组
    # - &i__1: 用于控制循环的步长参数
    # - info: 返回操作结果的状态信息
/*
    Multiply B by transpose of left bidiagonalizing vectors of R.
    (Workspace: need 3*N+NRHS, prefer 3*N+NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
dormbr_("Q", "L", "T", &mm, nrhs, n, &a[a_offset], lda, &work[itauq],
        &b[b_offset], ldb, &work[nwork], &i__1, info);

/* 
    Solve the bidiagonal least squares problem.
*/
dlalsd_("U", &smlsiz, n, nrhs, &s[1], &work[ie], &b[b_offset], ldb,
        rcond, rank, &work[nwork], &iwork[1], info);
if (*info != 0) {
    goto L10;
}

/*
    Multiply B by right bidiagonalizing vectors of R.
*/
i__1 = *lwork - nwork + 1;
dormbr_("P", "L", "N", n, nrhs, n, &a[a_offset], lda, &work[itaup], &
        b[b_offset], ldb, &work[nwork], &i__1, info);

} else /* if(complicated condition) */ {
    /*
        Computing MAX
    */
    i__1 = *m, i__2 = (*m << 1) - 4, i__1 = max(i__1,i__2), i__1 = max(
        i__1,*nrhs), i__2 = *n - *m * 3, i__1 = max(i__1,i__2);
    if (*n >= mnthr && *lwork >= (*m << 2) + *m * *m + max(i__1,wlalsd)) {

        /*
            Path 2a - underdetermined, with many more columns than rows
            and sufficient workspace for an efficient algorithm.
        */

        ldwork = *m;
        /*
            Computing MAX
            Computing MAX
        */
        i__3 = *m, i__4 = (*m << 1) - 4, i__3 = max(i__3,i__4), i__3 =
            max(i__3,*nrhs), i__4 = *n - *m * 3;
        i__1 = (*m << 2) + *m * *lda + max(i__3,i__4), i__2 = *m * *lda +
            *m + *m * *nrhs, i__1 = max(i__1,i__2), i__2 = (*m << 2)
            + *m * *lda + wlalsd;
        if (*lwork >= max(i__1,i__2)) {
            ldwork = *lda;
        }
        itau = 1;
        nwork = *m + 1;

        /*
            Compute A=L*Q.
            (Workspace: need 2*M, prefer M+M*NB)
        */
        i__1 = *lwork - nwork + 1;
        dgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1,
                info);
        il = nwork;

        /* 
            Copy L to WORK(IL), zeroing out above its diagonal.
        */
        dlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwork);
        i__1 = *m - 1;
        i__2 = *m - 1;
        dlaset_("U", &i__1, &i__2, &c_b29, &c_b29, &work[il + ldwork], &
                ldwork);
        ie = il + ldwork * *m;
        itauq = ie + *m;
        itaup = itauq + *m;
        nwork = itaup + *m;

        /*
            Bidiagonalize L in WORK(IL).
            (Workspace: need M*M+5*M, prefer M*M+4*M+2*M*NB)
        */
        i__1 = *lwork - nwork + 1;
        dgebrd_(m, m, &work[il], &ldwork, &s[1], &work[ie], &work[itauq],
                &work[itaup], &work[nwork], &i__1, info);

        /*
            Multiply B by transpose of left bidiagonalizing vectors of L.
            (Workspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
        */
        i__1 = *lwork - nwork + 1;
        dormbr_("Q", "L", "T", m, nrhs, m, &work[il], &ldwork, &work[
                itauq], &b[b_offset], ldb, &work[nwork], &i__1, info);
/*
    Solve the bidiagonal least squares problem using the DGELSD routine.
*/
dlalsd_("U", &smlsiz, m, nrhs, &s[1], &work[ie], &b[b_offset],
    ldb, rcond, rank, &work[nwork], &iwork[1], info);
if (*info != 0) {
    goto L10;
}

/*
    Multiply B by the right bidiagonalizing vectors of L.
*/
i__1 = *lwork - nwork + 1;
dormbr_("P", "L", "N", m, nrhs, m, &work[il], &ldwork, &work[itaup], &b[b_offset], ldb, &work[nwork], &i__1, info);

/*
    Zero out the lower part below the first M rows of B.
*/
i__1 = *n - *m;
dlaset_("F", &i__1, nrhs, &c_b29, &c_b29, &b[*m + 1 + b_dim1], ldb);
nwork = itau + *m;

/*
    Multiply transpose(Q) by B.
    (Workspace: need M+NRHS, prefer M+NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
dormlq_("L", "T", n, nrhs, m, &a[a_offset], lda, &work[itau], &b[b_offset], ldb, &work[nwork], &i__1, info);
} else {

/*
    Path 2 - handle remaining underdetermined cases.
*/
ie = 1;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
    Bidiagonalize A.
    (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*/
i__1 = *lwork - nwork + 1;
dgebrd_(m, n, &a[a_offset], lda, &s[1], &work[ie], &work[itauq], &work[itaup], &work[nwork], &i__1, info);

/*
    Multiply B by transpose of left bidiagonalizing vectors.
    (Workspace: need 3*M+NRHS, prefer 3*M+NRHS*NB)
*/
i__1 = *lwork - nwork + 1;
dormbr_("Q", "L", "T", m, nrhs, n, &a[a_offset], lda, &work[itauq], &b[b_offset], ldb, &work[nwork], &i__1, info);

/*
    Solve the bidiagonal least squares problem.
*/
dlalsd_("L", &smlsiz, m, nrhs, &s[1], &work[ie], &b[b_offset], ldb, rcond, rank, &work[nwork], &iwork[1], info);
if (*info != 0) {
    goto L10;
}

/*
    Multiply B by the right bidiagonalizing vectors of A.
*/
i__1 = *lwork - nwork + 1;
dormbr_("P", "L", "N", n, nrhs, m, &a[a_offset], lda, &work[itaup], &b[b_offset], ldb, &work[nwork], &i__1, info);
}

/*
    Undo scaling applied earlier.
*/
if (iascl == 1) {
    dlascl_("G", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb, info);
    dlascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &minmn, info);
} else if (iascl == 2) {
    dlascl_("G", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb, info);
    dlascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &minmn, info);
}
if (ibscl == 1) {
    dlascl_("G", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb, info);
} else if (ibscl == 2) {
    dlascl_("G", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb, info);
}

L10:
work[1] = (doublereal) maxwrk;
iwork[1] = liwork;
return 0;

/* End of DGELSD */
} /* dgelsd_ */
/* Subroutine */ int dgeqr2_(integer *m, integer *n, doublereal *a, integer *
    lda, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k;
    static doublereal aii;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *), dlarfg_(integer *, doublereal *,
        doublereal *, integer *, doublereal *), xerbla_(char *, integer *);

    /*
        -- LAPACK routine (version 3.2.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
        June 2010

        Purpose
        =======

        DGEQR2 computes a QR factorization of a real m by n matrix A:
        A = Q * R.

        Arguments
        =========

        M       (input) INTEGER
                The number of rows of the matrix A.  M >= 0.

        N       (input) INTEGER
                The number of columns of the matrix A.  N >= 0.

        A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
                On entry, the m by n matrix A.
                On exit, the elements on and above the diagonal of the array
                contain the min(m,n) by n upper trapezoidal matrix R (R is
                upper triangular if m >= n); the elements below the diagonal,
                with the array TAU, represent the orthogonal matrix Q as a
                product of elementary reflectors (see Further Details).

        LDA     (input) INTEGER
                The leading dimension of the array A.  LDA >= max(1,M).

        TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
                The scalar factors of the elementary reflectors (see Further
                Details).

        WORK    (workspace) DOUBLE PRECISION array, dimension (N)

        INFO    (output) INTEGER
                = 0: successful exit
                < 0: if INFO = -i, the i-th argument had an illegal value

        Further Details
        ===============

        The matrix Q is represented as a product of elementary reflectors

        Q = H(1) H(2) . . . H(k), where k = min(m,n).

        Each H(i) has the form

        H(i) = I - tau * v * v'

        where tau is a real scalar, and v is a real vector with
        v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
        and tau in TAU(i).

        =====================================================================

        Test the input arguments
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*m)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGEQR2", &i__1);
        return 0;
    }

    k = min(*m,*n);

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {


这段代码是一个 LAPACK 中的 DGEQR2 子程序，用于计算实数矩阵 A 的 QR 分解。以下是对每行代码的注释：

1. `/* Subroutine */ int dgeqr2_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info)`
   - 定义了一个名为 dgeqr2 的子程序，接受多个输入参数和一个输出参数。

2. `/* System generated locals */`
   - 自动生成的局部变量声明部分。

3. `integer a_dim1, a_offset, i__1, i__2, i__3;`
   - 声明整型变量用于矩阵 A 的维度和偏移量，以及循环中使用的索引变量。

4. `/* Local variables */`
   - 本地变量声明部分。

5. `static integer i__, k;`
   - 声明静态整型变量 i 和 k，用于循环索引和最小维数。

6. `static doublereal aii;`
   - 声明静态双精度浮点数变量 aii，用于存储矩阵 A 的元素。

7. `extern /* Subroutine */ int dlarf_(char *, integer *, integer *, doublereal *, integer *, doublereal *, doublereal *, integer *, doublereal *), dlarfg_(integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);`
   - 声明外部的几个子程序，用于后续在主程序中调用。

8. `/* LAPACK routine (version 3.2.2) */`
   - LAPACK 的版本信息和日期注释。

9. `/* Purpose */`
   - 函数目的说明部分。

10. `/* Arguments */`
    - 函数参数说明部分，包括输入和输出参数的描述。

11. `/* Further Details */`
    - 更多细节说明，如 QR 分解的具体实现和矩阵 Q 的表示方法。

12. `/* Test the input arguments */`
    - 测试输入参数的有效性。

至此为止，这段代码的注释涵盖了每一行的作用和功能描述。
/*        Generate elementary reflector H(i) to annihilate A(i+1:m,i) */
/* 生成元反射器 H(i)，用来将 A(i+1:m,i) 化为零 */

    i__2 = *m - i__ + 1;
/* 计算元素个数，限制在较小的范围内 */
/* Computing MIN */
    i__3 = i__ + 1;
    dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ * a_dim1]
        , &c__1, &tau[i__]);
    if (i__ < *n) {

/*           Apply H(i) to A(i:m,i+1:n) from the left */

        aii = a[i__ + i__ * a_dim1];
/* 存储 A(i,i) 的值 */
        a[i__ + i__ * a_dim1] = 1.;
/* 设置 A(i,i) 为 1 */
        i__2 = *m - i__ + 1;
        i__3 = *n - i__;
        dlarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &tau[
            i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
/* 对 A(i:m,i+1:n) 应用 H(i)，从左侧进行操作 */
        a[i__ + i__ * a_dim1] = aii;
/* 恢复 A(i,i) 的原始值 */
    }
/* L10: */
    }
/* 如果 i 小于 n，则继续下一次迭代 */

    return 0;

/*     End of DGEQR2 */
/* DGEQR2 结束 */

} /* dgeqr2_ */

/* Subroutine */ int dgeqrf_(integer *m, integer *n, doublereal *a, integer *
    lda, doublereal *tau, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    extern /* Subroutine */ int dgeqr2_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *), dlarfb_(char *,
         char *, char *, char *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DGEQRF computes a QR factorization of a real M-by-N matrix A:
    A = Q * R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
*/


以上是对给定代码的注释，每行都按照要求进行了详细解释。
    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

工作数组 `WORK`，用于存储中间计算结果或输出结果。其维度为 `MAX(1, LWORK)`，其中 `LWORK` 是工作数组的维度。
在函数执行完毕时，如果 `INFO = 0`，则 `WORK(1)` 返回最优的 `LWORK`。


    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.

输入参数 `LWORK`，表示工作数组 `WORK` 的维度。要求 `LWORK` 至少为 `max(1, N)`，其中 `N` 是一个参数。
为了达到最佳性能，推荐设定 `LWORK >= N*NB`，其中 `NB` 是最优块大小。


            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

如果 `LWORK = -1`，则假定进行工作空间查询；该子例程仅计算工作数组 `WORK` 的最优大小，并将此值作为 `WORK` 数组的第一个条目返回。此时，`XERBLA` 不会发出与 `LWORK` 相关的任何错误消息。


    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

输出参数 `INFO`，表示函数的返回状态：
- `INFO = 0`：表示函数成功执行。
- `INFO < 0`：表示第 `i` 个参数存在非法值，具体的非法值由 `-i` 表示。


    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).

    =====================================================================

进一步的细节说明：
- 矩阵 `Q` 被表示为一系列初等反射器的乘积。
- `Q = H(1) H(2) . . . H(k)`，其中 `k = min(m, n)`，`m` 和 `n` 是矩阵的尺寸。
- 每个 `H(i)` 的形式为 `H(i) = I - tau * v * v'`，其中 `tau` 是实数标量，`v` 是实向量。
- `v(1:i-1) = 0`，`v(i) = 1`，并且 `v(i+1:m)` 在退出时存储在 `A(i+1:m, i)` 中，`tau` 存储在 `TAU(i)` 中。


       Test the input arguments

测试输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;  // 获取第一个维度的长度，通常是矩阵A的行数
    a_offset = 1 + a_dim1;  // 计算A数组的偏移量
    a -= a_offset;  // 将指针A调整到正确的起始位置
    --tau;  // 将数组tau的索引从1改为0开始
    --work;  // 将数组work的索引从1改为0开始

    /* Function Body */
    *info = 0;  // 初始化info为0，用于存储返回状态
    nb = ilaenv_(&c__1, "DGEQRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)
        1);  // 根据调用环境评估合适的块大小nb
    lwkopt = *n * nb;  // 计算所需的最优工作空间大小
    work[1] = (doublereal) lwkopt;  // 将最优工作空间大小存入work数组的第一个位置
    lquery = *lwork == -1;  // 判断是否仅查询所需的工作空间大小
    if (*m < 0) {  // 检查输入参数m是否合法
    *info = -1;  // 设置错误码为-1，表示m参数无效
    } else if (*n < 0) {  // 检查输入参数n是否合法
    *info = -2;  // 设置错误码为-2，表示n参数无效
    } else if (*lda < max(1,*m)) {  // 检查输入参数lda是否合法
    *info = -4;  // 设置错误码为-4，表示lda参数无效
    } else if (*lwork < max(1,*n) && ! lquery) {  // 检查工作空间大小是否足够
    *info = -7;  // 设置错误码为-7，表示工作空间不足
    }
    if (*info != 0) {  // 如果存在错误信息
    i__1 = -(*info);  // 计算错误码的负值
    xerbla_("DGEQRF", &i__1);  // 调用错误处理函数xerbla输出错误信息
    return 0;  // 返回
    } else if (lquery) {  // 如果仅查询工作空间大小
    return 0;  // 返回
    }

/*     Quick return if possible */

    k = min(*m,*n);  // 计算k为m和n中的较小值，表示QR分解的阶数
    if (k == 0) {  // 如果k为0
    work[1] = 1.;  // 设置work数组的第一个元素为1
    return 0;  // 返回
    }

    nbmin = 2;  // 设置最小的块大小为2
    nx = 0;  // 初始化nx为0，用于存储临时的计算结果
    iws = *n;  // 初始化iws为n，表示工作空间大小
    if (nb > 1 && nb < k) {  // 如果块大小nb大于1且小于k

/*
          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
    i__1 = 0, i__2 = ilaenv_(&c__3, "DGEQRF", " ", m, n, &c_n1, &c_n1, (
        ftnlen)6, (ftnlen)1);  // 根据调用环境评估交换从阻塞代码切换到非阻塞代码的阈值nx
    nx = max(i__1,i__2);  // 取最大值作为nx的值
    if (nx < k) {  // 如果nx小于k

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *n;  // 设置ldwork为n，表示工作空间的列数
        iws = ldwork * nb;  // 计算所需的工作空间大小
        if (*lwork < iws) {  // 如果实际工作空间大小小于所需大小

/*
                Not enough workspace to use optimal NB:  reduce NB and
                determine the minimum value of NB.
*/

        nb = *lwork / ldwork;  // 调整nb的大小为实际可用的工作空间大小
/* Computing MAX */
        i__1 = 2, i__2 = ilaenv_(&c__2, "DGEQRF", " ", m, n, &c_n1, &
            c_n1, (ftnlen)6, (ftnlen)1);  // 重新评估最小的块大小nbmin
        nbmin = max(i__1,i__2);  // 取最大值作为nbmin的值
        }
    }
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

    i__1 = k - nx;  // 计算块的数量
    i__2 = nb;  // 设置块的大小
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {  // 遍历每个块
/* Computing MIN */
        i__3 = k - i__ + 1;  // 计算当前块的大小
        ib = min(i__3,nb);  // 取ib为当前块的大小

/*
             Compute the QR factorization of the current block
             A(i:m,i:i+ib-1)
*/

        i__3 = *m - i__ + 1;  // 计算A的行数
        dgeqr2_(&i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
            1], &iinfo);  // 调用QR分解函数dgeqr2进行QR分解
        if (i__ + ib <= *n) {

/*
                Form the triangular factor of the block reflector
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__3 = *m - i__ + 1;  // 计算A的行数
        dlarft_("Forward", "Columnwise", &i__3, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], &work[1], &ldwork);  // 调用计算反射因子的函数dlarft

/*              Apply H' to A(i:m,i+ib:n) from the left */

        i__3 = *m - i__ + 1;  // 计算A的行数
        i__4 = *n - i__ - ib + 1;  // 计算A的列数
        dlarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
            i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
            ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &work[ib
            + 1], &ldwork);  // 调用计算矩阵乘法的函数dlarfb
        }
/* L10: */
    }
    } else {
    i__ = 1;  // 设置i的初始值为1
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {  // 如果还有剩余未处理的块
    i__2 = *m - i__ + 1;  // 计算当前块的行数
    i__1 = *n - i__ + 1;  // 计算当前块的列数
    # 调用外部的 LAPACK 函数 dgeqr2_ 进行 QR 分解，对矩阵 a 的子区块进行操作
    dgeqr2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
        , &iinfo);
    }

    # 将整数变量 iws 转换为双精度浮点数，并存储到 work 数组的第一个位置
    work[1] = (doublereal) iws;

    # 返回函数执行成功的标志，通常返回 0 表示成功
    return 0;
} /* dgeqrf_ */

/* Subroutine */ int dgesdd_(char *jobz, integer *m, integer *n, doublereal *
    a, integer *lda, doublereal *s, doublereal *u, integer *ldu,
    doublereal *vt, integer *ldvt, doublereal *work, integer *lwork,
    integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2, i__3;

    /* Local variables */
    static integer i__, ie, il, ir, iu, blk;
    static doublereal dum[1], eps;
    static integer ivt, iscl;
    static doublereal anrm;
    static integer idum[1], ierr, itau;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    extern logical lsame_(char *, char *);
    static integer chunk, minmn, wrkbl, itaup, itauq, mnthr;
    static logical wntqa;
    static integer nwork;
    static logical wntqn, wntqo, wntqs;
    extern /* Subroutine */ int dbdsdc_(char *, char *, integer *, doublereal
        *, doublereal *, doublereal *, integer *, doublereal *, integer *,
         doublereal *, integer *, doublereal *, integer *, integer *), dgebrd_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, integer *);
    extern doublereal dlamch_(char *), dlange_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *);
    static integer bdspac;
    extern /* Subroutine */ int dgelqf_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, integer *),
        dlascl_(char *, integer *, integer *, doublereal *, doublereal *,
        integer *, integer *, doublereal *, integer *, integer *),
         dgeqrf_(integer *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *, integer *), dlacpy_(char *,
         integer *, integer *, doublereal *, integer *, doublereal *,
        integer *), dlaset_(char *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *),
        xerbla_(char *, integer *), dorgbr_(char *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static doublereal bignum;
    extern /* Subroutine */ int dormbr_(char *, char *, char *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, integer *), dorglq_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *), dorgqr_(integer *, integer *, integer *, doublereal *,
         integer *, doublereal *, doublereal *, integer *, integer *);
    # 声明静态整型变量 ldwrkl, ldwrkr, minwrk, ldwrku, maxwrk, ldwkvt
    static integer ldwrkl, ldwrkr, minwrk, ldwrku, maxwrk, ldwkvt;
    # 声明静态双精度实数变量 smlnum
    static doublereal smlnum;
    # 声明静态逻辑变量 wntqas, lquery
    static logical wntqas, lquery;
"""
    -- LAPACK driver routine (version 3.2.1)                                  --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       March 2009


    Purpose
    =======

    DGESDD computes the singular value decomposition (SVD) of a real
    M-by-N matrix A, optionally computing the left and right singular
    vectors.  If singular vectors are desired, it uses a
    divide-and-conquer algorithm.

    The SVD is written

         A = U * SIGMA * transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns VT = V**T, not V.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**T are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**T are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    on the array A and all rows of V**T are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**T are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**T are computed.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N >= 0.
"""
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V**T (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            LDA specifies the stride between successive columns of A in memory.

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            S contains the singular values of A in descending order.

    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            U is overwritten with the left singular vectors of A.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
            LDU specifies the stride between successive columns of U in memory.

    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N orthogonal matrix V**T;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
            VT is overwritten with the right singular vectors of A.

    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            LDVT specifies the stride between successive rows of VT in memory.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            Workspace array used by LAPACK routines for computation.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= 1.
            Specifies the size of the workspace array WORK.
            The optimal value for LWORK depends on the values of M, N, and JOBZ.

    IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
            Workspace array used by LAPACK routines for integer workspace.
    # 输出参数信息，INFO 是返回代码，0 表示成功退出，负值表示参数不合法，正值表示未收敛或更新失败
    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  DBDSDC did not converge, updating process failed.

    # 进一步细节说明
    Further Details
    ===============

    # 该部分的贡献者
    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    # 分隔线
    =====================================================================


    # 测试输入参数的有效性
       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;                           // 设置数组 `a` 的第一维度大小
    a_offset = 1 + a_dim1;                   // 计算数组 `a` 的偏移量
    a -= a_offset;                           // 调整数组 `a` 的起始位置
    --s;                                     // 将数组 `s` 的指针向前移动一个位置
    u_dim1 = *ldu;                           // 设置数组 `u` 的第一维度大小
    u_offset = 1 + u_dim1;                   // 计算数组 `u` 的偏移量
    u -= u_offset;                           // 调整数组 `u` 的起始位置
    vt_dim1 = *ldvt;                         // 设置数组 `vt` 的第一维度大小
    vt_offset = 1 + vt_dim1;                 // 计算数组 `vt` 的偏移量
    vt -= vt_offset;                         // 调整数组 `vt` 的起始位置
    --work;                                  // 将数组 `work` 的指针向前移动一个位置
    --iwork;                                 // 将数组 `iwork` 的指针向前移动一个位置

    /* Function Body */
    *info = 0;                                // 初始化 `info` 为0
    minmn = min(*m,*n);                       // 计算 `m` 和 `n` 的最小值并赋给 `minmn`
    wntqa = lsame_(jobz, "A");                // 检查 `jobz` 是否为 "A"
    wntqs = lsame_(jobz, "S");                // 检查 `jobz` 是否为 "S"
    wntqas = wntqa || wntqs;                  // 判断 `jobz` 是否为 "A" 或 "S"
    wntqo = lsame_(jobz, "O");                // 检查 `jobz` 是否为 "O"
    wntqn = lsame_(jobz, "N");                // 检查 `jobz` 是否为 "N"
    lquery = *lwork == -1;                    // 判断是否为查询工作空间大小

    if (! (wntqa || wntqs || wntqo || wntqn)) {  // 检查 `jobz` 是否为合法值
        *info = -1;                           // 如果不合法，设置 `info` 为 -1
    } else if (*m < 0) {                      // 检查 `m` 是否小于0
        *info = -2;                           // 如果小于0，设置 `info` 为 -2
    } else if (*n < 0) {                      // 检查 `n` 是否小于0
        *info = -3;                           // 如果小于0，设置 `info` 为 -3
    } else if (*lda < max(1,*m)) {            // 检查 `lda` 是否小于1或`m`
        *info = -5;                           // 如果不满足条件，设置 `info` 为 -5
    } else if (*ldu < 1 || wntqas && *ldu < *m || wntqo && *m < *n && *ldu < *m) {
        *info = -8;                           // 根据不同条件设置 `info` 的值
    } else if (*ldvt < 1 || wntqa && *ldvt < *n || wntqs && *ldvt < minmn ||
               wntqo && *m >= *n && *ldvt < *n) {
        *info = -10;                          // 根据不同条件设置 `info` 的值
    }

    /*
           Compute workspace
            (Note: Comments in the code beginning "Workspace:" describe the
             minimal amount of workspace needed at that point in the code,
             as well as the preferred amount for good performance.
             NB refers to the optimal block size for the immediately
             following subroutine, as returned by ILAENV.)
    */

    if (*info == 0) {                         // 如果 `info` 为0，表示参数有效
        minwrk = 1;                           // 初始化最小工作空间为1
        maxwrk = 1;                           // 初始化最大工作空间为1
        if (*m >= *n && minmn > 0) {          // 如果 `m` 大于等于 `n` 并且 `minmn` 大于0

    /*           Compute space needed for DBDSDC */

            mnthr = (integer) (minmn * 11. / 6.);  // 计算 `mnthr` 的值
            if (wntqn) {                      // 如果 `jobz` 为 "N"
                bdspac = *n * 7;               // 计算 `bdspac` 的大小
            } else {
                bdspac = *n * 3 * *n + (*n << 2);  // 计算 `bdspac` 的大小
            }
            if (*m >= mnthr) {                // 如果 `m` 大于等于 `mnthr`
                if (wntqn) {

    /*                 Path 1 (M much larger than N, JOBZ='N') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算 `wrkbl` 的大小
    /* Computing MAX */
                    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                        "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                        ftnlen)1);
                    wrkbl = max(i__1,i__2);    // 计算 `wrkbl` 的最大值
    /* Computing MAX */
                    i__1 = wrkbl, i__2 = bdspac + *n;
                    maxwrk = max(i__1,i__2);   // 计算 `maxwrk` 的大小
                    minwrk = bdspac + *n;      // 计算 `minwrk` 的大小
                } else if (wntqo) {

    /*                 Path 2 (M much larger than N, JOBZ='O') */

                    wrkbl = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
                        c_n1, &c_n1, (ftnlen)6, (ftnlen)1);  // 计算 `wrkbl` 的大小
    /* Computing MAX */
                    i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "DORGQR",
                        " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
                    wrkbl = max(i__1,i__2);    // 计算 `wrkbl` 的最大值
    /* Computing MAX */
                    i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                        "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                        ftnlen)1);
                    wrkbl = max(i__1,i__2);    // 计算 `wrkbl` 的最大值
/* 计算工作空间大小，用于路径选择 */

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3)) */
i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
                , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3)) */
i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
                , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (bdspac + *n * 3) */
i__1 = wrkbl, i__2 = bdspac + *n * 3;
wrkbl = max(i__1,i__2);

/* 计算 maxwrk 的大小 */
maxwrk = wrkbl + (*n << 1) * *n;

/* 计算 minwrk 的大小 */
minwrk = bdspac + (*n << 1) * *n + *n * 3;

} else if (wntqs) {

/* 路径 3 (M 远大于 N, JOBZ='S') */

/* 计算 wrkbl 的大小，为 *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
   c_n1, &c_n1, (ftnlen)6, (ftnlen)1) */
wrkbl = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n + *n * ilaenv_(&c__1, "DORGQR",
   " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1)) */
i__1 = wrkbl, i__2 = *n + *n * ilaenv_(&c__1, "DORGQR",
                " ", m, n, n, &c_n1, (ftnlen)6, (ftnlen)1);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + (*n << 1) * ilaenv_(&c__1,
   "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
   ftnlen)1)) */
i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3)) */
i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
                , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3)) */
i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
                , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (bdspac + *n * 3) */
i__1 = wrkbl, i__2 = bdspac + *n * 3;
wrkbl = max(i__1,i__2);

/* 计算 maxwrk 的大小 */
maxwrk = wrkbl + *n * *n;

/* 计算 minwrk 的大小 */
minwrk = bdspac + *n * *n + *n * 3;

} else if (wntqa) {

/* 路径 4 (M 远大于 N, JOBZ='A') */

/* 计算 wrkbl 的大小，为 *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
   c_n1, &c_n1, (ftnlen)6, (ftnlen)1) */
wrkbl = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", m, n, &
                c_n1, &c_n1, (ftnlen)6, (ftnlen)1);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n + *m * ilaenv_(&c__1, "DORGQR",
   " ", m, m, n, &c_n1, (ftnlen)6, (ftnlen)1)) */
i__1 = wrkbl, i__2 = *n + *m * ilaenv_(&c__1, "DORGQR",
                " ", m, m, n, &c_n1, (ftnlen)6, (ftnlen)1);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + (*n << 1) * ilaenv_(&c__1,
   "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
   ftnlen)1)) */
i__1 = wrkbl, i__2 = *n * 3 + (*n << 1) * ilaenv_(&c__1,
                "DGEBRD", " ", n, n, &c_n1, &c_n1, (ftnlen)6, (
                ftnlen)1);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3)) */
i__1 = wrkbl, i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
                , "QLN", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);

/* 计算 wrkbl 的大小，取两者中的较大值：wrkbl 和 (*n * 3 + *n * ilaenv_(&c__1, "DORMBR"
   , "PRT", n, n, n, &c_n1, (
/*              Path 5 (M at least N, but not much larger) */

/* 计算 DGEBRD 函数所需的工作空间大小 */
wrkbl = *n * 3 + (*m + *n) * ilaenv_(&c__1, "DGEBRD", " ", m,
    n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
if (wntqn) {
    /* 如果需要计算所有特征值，则选择更大的工作空间 */
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
} else if (wntqo) {
    /* 如果需要计算一些特征值，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    wrkbl = max(i__1,i__2);
    maxwrk = wrkbl + *m * *n;
    /* 计算最小工作空间大小 */
    i__1 = *m;
    i__2 = *n * *n + bdspac;
    minwrk = *n * 3 + max(i__1,i__2);
} else if (wntqs) {
    /* 如果需要计算所有特征向量，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
} else if (wntqa) {
    /* 如果需要计算所有特征值和特征向量，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *m * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = maxwrk;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
}
} else if (minmn > 0) {

/* 计算 DBDSDC 函数所需的空间大小 */

mnthr = (integer) (minmn * 11. / 6.);
if (wntqn) {
    /* 如果需要计算所有特征值，则计算所需的空间大小 */
    bdspac = *m * 7;
} else {
    /* 如果需要计算一些特征值，则计算所需的空间大小 */
    bdspac = *m * 3 * *m + (*m << 2);
}
if (*n >= mnthr) {
    if (wntqn) {

/*                 Path 1t (N much larger than M, JOBZ='N') */

        /* 如果 N 远大于 M，并且不需要计算特征向量，则计算所需的工作空间大小 */
        wrkbl = *m + *m * ilaenv_(&c__1, "DGELQF", " ", m, n, &
            c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        /* 计算 DGEBRD 函数所需的工作空间大小 */
        i__1 = wrkbl;
        i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
            "DGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
            ftnlen)1);
        wrkbl = max(i__1,i__2);

/* 计算 DGEBRD 函数所需的工作空间大小 */
wrkbl = *n * 3 + (*m + *n) * ilaenv_(&c__1, "DGEBRD", " ", m,
    n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
if (wntqn) {
    /* 如果需要计算所有特征值，则选择更大的工作空间 */
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
} else if (wntqo) {
    /* 如果需要计算一些特征值，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    wrkbl = max(i__1,i__2);
    maxwrk = wrkbl + *m * *n;
    /* 计算最小工作空间大小 */
    i__1 = *m;
    i__2 = *n * *n + bdspac;
    minwrk = *n * 3 + max(i__1,i__2);
} else if (wntqs) {
    /* 如果需要计算所有特征向量，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = wrkbl;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
} else if (wntqa) {
    /* 如果需要计算所有特征值和特征向量，则需要更多的工作空间 */
    /* 计算 DGELQF 和 DORMBR 函数所需的工作空间大小 */
    i__1 = wrkbl;
    i__2 = *n * 3 + *m * ilaenv_(&c__1, "DORMBR"
        , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    i__1 = wrkbl;
    i__2 = *n * 3 + *n * ilaenv_(&c__1, "DORMBR"
        , "PRT", n, n, n, &c_n1, (ftnlen)6, (ftnlen)3);
    wrkbl = max(i__1,i__2);
    /* 计算最大工作空间大小 */
    i__1 = maxwrk;
    i__2 = bdspac + *n * 3;
    maxwrk = max(i__1,i__2);
    /* 计算最小工作空间大小 */
    minwrk = *n * 3 + max(*m,bdspac);
}
} else if (minmn > 0) {

/* 计算 DBDSDC 函数所需的空间大小 */

mnthr = (integer) (minmn * 11. / 6.);
if (wntqn) {
    /* 如果需要计算所有特征值，则计算所需的空间大小 */
    bdspac = *m * 7;
} else {
    /* 如果需要计算一些特征值，则计算所需的空间大小 */
    bdspac = *m * 3 * *m + (*m << 2);
}
if (*n >= mnthr) {
    if (wntqn) {

/*                 Path 1t (N much larger than M, JOBZ='N') */

        /* 如果 N 远大于 M，并且不需要计算特征向量，则计算所需的工作空间大小 */
        wrkbl = *m + *m * ilaenv_(&c__1, "DGELQF", " ", m, n, &
            c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
        /* 计算 DGEBRD 函数所需的工作空间大小 */
        i__1 = wrkbl;
        i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
            "DGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
            ftnlen)1);
        wrkbl = max(i__1,i__2);
/* 计算最大工作空间需求 */

/* 如果需要计算 Q，则进入此分支 */
wrkbl = *m + *m * ilaenv_(&c__1, "DGELQF", " ", m, n, &
    c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 计算 DGELQF 所需的工作空间大小 */

/* 计算最大值 */
i__1 = wrkbl, i__2 = *m + *m * ilaenv_(&c__1, "DORGLQ",
    " ", m, n, m, &c_n1, (ftnlen)6, (ftnlen)1);
wrkbl = max(i__1,i__2);
/* 计算 DORGLQ 所需的工作空间大小，并取最大值 */

/* 计算最大值 */
i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
    "DGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
    ftnlen)1);
wrkbl = max(i__1,i__2);
/* 计算 DGEBRD 所需的工作空间大小，并取最大值 */

/* 计算最大值 */
i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);
/* 计算 DORMBR(QLN) 所需的工作空间大小，并取最大值 */

/* 计算最大值 */
i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
wrkbl = max(i__1,i__2);
/* 计算 DORMBR(PRT) 所需的工作空间大小，并取最大值 */

/* 计算最大值 */
i__1 = wrkbl, i__2 = bdspac + *m * 3;
wrkbl = max(i__1,i__2);
/* 将工作空间需求与额外的空间 bdspac + *m * 3 进行比较，并取最大值 */

/* 计算最大工作空间需求 */
maxwrk = wrkbl + (*m << 1) * *m;
/* 计算总的最大工作空间需求 */

/* 计算最小工作空间需求 */
minwrk = bdspac + (*m << 1) * *m + *m * 3;
/* 计算总的最小工作空间需求 */
/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + (*m << 1) * ilaenv_(&c__1,
    "DGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (
    ftnlen)1);
/* 设置 i__1 为 wrkbl 和 *m * 3 + (*m << 1) * ilaenv_(&c__1,
   "DGEBRD", " ", m, m, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "QLN", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "PRT", m, m, m, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = bdspac + *m * 3;
/* 设置 i__1 为 wrkbl 和 bdspac + *m * 3 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

maxwrk = wrkbl + *m * *m;
/* 计算 maxwrk 为 wrkbl 加上 *m * *m */

minwrk = bdspac + *m * *m + *m * 3;
/* 计算 minwrk 为 bdspac 加上 *m * *m 加上 *m * 3 */

} else {

/* Path 5t (N greater than M, but not much larger) */

wrkbl = *m * 3 + (*m + *n) * ilaenv_(&c__1, "DGEBRD", " ", m,
    n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* 设置 wrkbl 为 *m * 3 加上 (*m + *n) * ilaenv_(&c__1, "DGEBRD", " ", m,
   n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1) */

if (wntqn) {
/* 如果 wntqn 为真 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = bdspac + *m * 3;
/* 设置 i__1 为 wrkbl 和 bdspac + *m * 3 两者中的最大值 */

maxwrk = max(i__1,i__2);
/* 设置 maxwrk 为 i__1 和 i__2 的最大值 */

minwrk = *m * 3 + max(*n,bdspac);
/* 设置 minwrk 为 *m * 3 加上 *n 和 bdspac 两者中的最大值 */

} else if (wntqo) {
/* 否则如果 wntqo 为真 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = bdspac + *m * 3;
/* 设置 i__1 为 wrkbl 和 bdspac + *m * 3 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

maxwrk = wrkbl + *m * *n;
/* 计算 maxwrk 为 wrkbl 加上 *m * *n */

/* Computing MAX */
/* 计算最大值 */

i__1 = *n, i__2 = *m * *m + bdspac;
/* 设置 i__1 为 *n 和 *m * *m + bdspac 两者中的最大值 */

minwrk = *m * 3 + max(i__1,i__2);
/* 设置 minwrk 为 *m * 3 加上 i__1 和 i__2 的最大值 */

} else if (wntqs) {
/* 否则如果 wntqs 为真 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "QLN", m, m, n, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大值 */

/* Computing MAX */
/* 计算最大值 */

i__1 = wrkbl, i__2 = *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
    , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3);
/* 设置 i__1 为 wrkbl 和 *m * 3 + *m * ilaenv_(&c__1, "DORMBR"
   , "PRT", m, n, m, &c_n1, (ftnlen)6, (ftnlen)3) 两者中的最大值 */

wrkbl = max(i__1,i__2);
/* 更新 wrkbl 为 i__1 和 i__2 的最大
    }
    # 更新工作数组的第一个元素为 maxwrk 的值，确保工作数组的大小足够
    maxwrk = max(maxwrk,minwrk);
    work[1] = (doublereal) maxwrk;

    # 如果传入的工作数组大小小于最小需要的工作数组大小，并且不是查询模式
    if (*lwork < minwrk && ! lquery) {
        # 设置信息标志为 -12，表示工作数组大小不足
        *info = -12;
    }
    }

    # 如果信息标志不为零，表示出现错误
    if (*info != 0) {
        # 调用错误处理函数 xerbla，传入错误信息编号的负值
        i__1 = -(*info);
        xerbla_("DGESDD", &i__1);
        # 返回 0，表示异常终止
        return 0;
    } else if (lquery) {
        # 如果是查询模式，直接返回 0
        return 0;
    }
/*     Quick return if possible */

/* 如果 m 或 n 为零，直接返回0 */
if (*m == 0 || *n == 0) {
    return 0;
}

/*     Get machine constants */

/* 获取机器常数 */
eps = PRECISION;
smlnum = sqrt(SAFEMINIMUM) / eps;
bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

/* 计算矩阵 A 的范数 anrm */
anrm = dlange_("M", m, n, &a[a_offset], lda, dum);
iscl = 0;
if (anrm > 0. && anrm < smlnum) {
    iscl = 1;
    /* 将矩阵 A 缩放到适当的范围内 */
    dlascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, &
        ierr);
} else if (anrm > bignum) {
    iscl = 1;
    /* 将矩阵 A 缩放到适当的范围内 */
    dlascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, &
        ierr);
}

if (*m >= *n) {

/*
          A has at least as many rows as columns. If A has sufficiently
          more rows than columns, first reduce using the QR
          decomposition (if sufficient workspace available)
*/

if (*m >= mnthr) {

    if (wntqn) {

/*
                Path 1 (M much larger than N, JOBZ='N')
                No singular vectors to be computed
*/

    itau = 1;
    nwork = itau + *n;

/*
                Compute A=Q*R
                (Workspace: need 2*N, prefer N+N*NB)
*/

    i__1 = *lwork - nwork + 1;
    dgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
        i__1, &ierr);

/*              Zero out below R */

    i__1 = *n - 1;
    i__2 = *n - 1;
    dlaset_("L", &i__1, &i__2, &c_b29, &c_b29, &a[a_dim1 + 2],
        lda);
    ie = 1;
    itauq = ie + *n;
    itaup = itauq + *n;
    nwork = itaup + *n;

/*
                Bidiagonalize R in A
                (Workspace: need 4*N, prefer 3*N+2*N*NB)
*/

    i__1 = *lwork - nwork + 1;
    dgebrd_(n, n, &a[a_offset], lda, &s[1], &work[ie], &work[
        itauq], &work[itaup], &work[nwork], &i__1, &ierr);
    nwork = ie + *n;

/*
                Perform bidiagonal SVD, computing singular values only
                (Workspace: need N+BDSPAC)
*/

    dbdsdc_("U", "N", n, &s[1], &work[ie], dum, &c__1, dum, &c__1,
         dum, idum, &work[nwork], &iwork[1], info);

    } else if (wntqo) {

/*
                Path 2 (M much larger than N, JOBZ = 'O')
                N left singular vectors to be overwritten on A and
                N right singular vectors to be computed in VT
*/

    ir = 1;

/*              WORK(IR) is LDWRKR by N */

    if (*lwork >= *lda * *n + *n * *n + *n * 3 + bdspac) {
        ldwrkr = *lda;
    } else {
        ldwrkr = (*lwork - *n * *n - *n * 3 - bdspac) / *n;
    }
    itau = ir + ldwrkr * *n;
    nwork = itau + *n;

/*
                Compute A=Q*R
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/

    i__1 = *lwork - nwork + 1;
    dgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
        i__1, &ierr);
/*              Copy R to WORK(IR), zeroing out below it */

/* 将矩阵 R 复制到 WORK(IR)，并清空其下方 */
dlacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
i__1 = *n - 1;
i__2 = *n - 1;
/* 使用 dlaset 函数将 WORK(IR) 下三角部分置零 */
dlaset_("L", &i__1, &i__2, &c_b29, &c_b29, &work[ir + 1], &ldwrkr);

/*
                Generate Q in A
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/

/* 在矩阵 A 中生成 Q */
i__1 = *lwork - nwork + 1;
dorgqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__1, &ierr);
ie = itau;
itauq = ie + *n;
itaup = itauq + *n;
nwork = itaup + *n;

/*
                Bidiagonalize R in VT, copying result to WORK(IR)
                (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*/

/* 对矩阵 R 进行双对角化，结果复制到 WORK(IR) */
i__1 = *lwork - nwork + 1;
dgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__1, &ierr);

/*              WORK(IU) is N by N */

/* WORK(IU) 是一个 N × N 的工作空间 */
iu = nwork;
nwork = iu + *n * *n;

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in WORK(IU) and computing right singular vectors of bidiagonal matrix in VT
                (Workspace: need N+N*N+BDSPAC)
*/

/* 执行双对角化 SVD，计算左奇异向量保存在 WORK(IU)，右奇异向量保存在 VT */
dbdsdc_("U", "I", n, &s[1], &work[ie], &work[iu], n, &vt[
    vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
    info);

/*
                Overwrite WORK(IU) by left singular vectors of R
                and VT by right singular vectors of R
                (Workspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
*/

/* 使用 dormbr 函数，用 R 的左奇异向量覆盖 WORK(IU)，用 R 的右奇异向量覆盖 VT */
i__1 = *lwork - nwork + 1;
dormbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
    itauq], &work[iu], n, &work[nwork], &i__1, &ierr);
i__1 = *lwork - nwork + 1;
dormbr_("P", "R", "T", n, n, n, &work[ir], &ldwrkr, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
    ierr);

/*
                Multiply Q in A by left singular vectors of R in WORK(IU), storing result in WORK(IR) and copying to A
                (Workspace: need 2*N*N, prefer N*N+M*N)
*/

/* 将 A 中的 Q 乘以 R 的左奇异向量，结果存储在 WORK(IR) 中并复制回 A */
i__1 = *m;
i__2 = ldwrkr;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
    i__2) {
/* 计算每次迭代的块大小 */
/* Computing MIN */
    i__3 = *m - i__ + 1;
    chunk = min(i__3,ldwrkr);
    dgemm_("N", "N", &chunk, n, n, &c_b15, &a[i__ + a_dim1],
        lda, &work[iu], n, &c_b29, &work[ir], &ldwrkr);
    dlacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ +
        a_dim1], lda);
/* L10: */
}

} else if (wntqs) {

/*
                Path 3 (M much larger than N, JOBZ='S')
                N left singular vectors to be computed in U and
                N right singular vectors to be computed in VT
*/

/* 路径 3 (M 远大于 N，JOBZ='S')，计算 N 个左奇异向量保存在 U 中，N 个右奇异向量保存在 VT 中 */
ir = 1;

/*              WORK(IR) is N by N */

/* WORK(IR) 是一个 N × N 的工作空间 */
ldwrkr = *n;
itau = ir + ldwrkr * *n;
nwork = itau + *n;
/*
        Compute A=Q*R
        (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
i__2 = *lwork - nwork + 1;
dgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__2, &ierr);

/*
        Copy R to WORK(IR), zeroing out below it
*/
dlacpy_("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
i__2 = *n - 1;
i__1 = *n - 1;
dlaset_("L", &i__2, &i__1, &c_b29, &c_b29, &work[ir + 1], &
    ldwrkr);

/*
        Generate Q in A
        (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
i__2 = *lwork - nwork + 1;
dorgqr_(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__2, &ierr);
ie = itau;
itauq = ie + *n;
itaup = itauq + *n;
nwork = itaup + *n;

/*
        Bidiagonalize R in WORK(IR)
        (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
*/
i__2 = *lwork - nwork + 1;
dgebrd_(n, n, &work[ir], &ldwrkr, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__2, &ierr);

/*
        Perform bidiagonal SVD, computing left singular vectors
        of bidiagonal matrix in U and computing right singular
        vectors of bidiagonal matrix in VT
        (Workspace: need N+BDSPAC)
*/
dbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
    vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
    info);

/*
        Overwrite U by left singular vectors of R and VT
        by right singular vectors of R
        (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
*/
i__2 = *lwork - nwork + 1;
dormbr_("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

i__2 = *lwork - nwork + 1;
dormbr_("P", "R", "T", n, n, n, &work[ir], &ldwrkr, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

/*
        Multiply Q in A by left singular vectors of R in
        WORK(IR), storing result in U
        (Workspace: need N*N)
*/
dlacpy_("F", n, n, &u[u_offset], ldu, &work[ir], &ldwrkr);
dgemm_("N", "N", m, n, n, &c_b15, &a[a_offset], lda, &work[ir]
    , &ldwrkr, &c_b29, &u[u_offset], ldu);

} else if (wntqa) {

/*
        Path 4 (M much larger than N, JOBZ='A')
        M left singular vectors to be computed in U and
        N right singular vectors to be computed in VT
*/
iu = 1;

/*
        WORK(IU) is N by N
*/
ldwrku = *n;
itau = iu + ldwrku * *n;
nwork = itau + *n;

/*
        Compute A=Q*R, copying result to U
        (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
        i__2 = *lwork - nwork + 1;
        dgeqrf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);

对矩阵 A 进行 QR 分解，生成 Q 和 R，其中 Q 存储在 A 中，R 存储在工作区中。


        dlacpy_("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);

复制矩阵 A 的下三角部分到矩阵 U，这一步将生成矩阵 U 用于后续计算。


        i__2 = *lwork - nwork + 1;
        dorgqr_(m, m, n, &u[u_offset], ldu, &work[itau], &work[nwork],
             &i__2, &ierr);

根据之前生成的矩阵 U，计算出 Q 矩阵，覆盖原来的 U 矩阵。


        i__2 = *n - 1;
        i__1 = *n - 1;
        dlaset_("L", &i__2, &i__1, &c_b29, &c_b29, &a[a_dim1 + 2],
            lda);

将矩阵 A 的下三角部分置零，生成上 Hessenberg 矩阵，这是为了进行后续的双对角化操作。


        ie = itau;
        itauq = ie + *n;
        itaup = itauq + *n;
        nwork = itaup + *n;

确定工作区数组的索引，用于存储计算过程中的中间结果和临时向量。


        i__2 = *lwork - nwork + 1;
        dgebrd_(n, n, &a[a_offset], lda, &s[1], &work[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);

对矩阵 A 进行双对角化处理，生成对角矩阵 S 和正交矩阵 Q1 和 P1。


        dbdsdc_("U", "I", n, &s[1], &work[ie], &work[iu], n, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

使用单边双对角分解 (SBD) 计算奇异值分解，计算出左奇异向量和右奇异向量。


        i__2 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", n, n, n, &a[a_offset], lda, &work[
            itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &
            ierr);

计算左奇异向量并存储在工作区的数组中。


        i__2 = *lwork - nwork + 1;
        dormbr_("P", "R", "T", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);

计算右奇异向量并存储在工作区的数组中。


        dgemm_("N", "N", m, n, n, &c_b15, &u[u_offset], ldu, &work[iu]
            , &ldwrku, &c_b29, &a[a_offset], lda);

将矩阵 U 与左奇异向量相乘，结果存储在矩阵 A 中。


        dlacpy_("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);

复制矩阵 A 中的左奇异向量到矩阵 U。


        }
    } else {

处理 M < MNTHR 的情况，采用另一种路径来处理矩阵，不进行 QR 分解而是直接进行双对角化。
/*
                Perform bidiagonal SVD, only computing singular values
                (Workspace: need N+BDSPAC)
*/
dbdsdc_("U", "N", n, &s[1], &work[ie], dum, &c__1, dum, &c__1,
         dum, idum, &work[nwork], &iwork[1], info);
} else if (wntqo) {
iu = nwork;
if (*lwork >= *m * *n + *n * 3 + bdspac) {

/*                 WORK( IU ) is M by N */

    ldwrku = *m;
    nwork = iu + ldwrku * *n;
    dlaset_("F", m, n, &c_b29, &c_b29, &work[iu], &ldwrku);
} else {

/*                 WORK( IU ) is N by N */

    ldwrku = *n;
    nwork = iu + ldwrku * *n;

/*                 WORK(IR) is LDWRKR by N */

    ir = nwork;
    ldwrkr = (*lwork - *n * *n - *n * 3) / *n;
}
nwork = iu + ldwrku * *n;

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in WORK(IU) and computing right
                singular vectors of bidiagonal matrix in VT
                (Workspace: need N+N*N+BDSPAC)
*/
dbdsdc_("U", "I", n, &s[1], &work[ie], &work[iu], &ldwrku, &
    vt[vt_offset], ldvt, dum, idum, &work[nwork], &iwork[
    1], info);

/*
                Overwrite VT by right singular vectors of A
                (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
i__2 = *lwork - nwork + 1;
dormbr_("P", "R", "T", n, n, n, &a[a_offset], lda, &work[
    itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
    ierr);

if (*lwork >= *m * *n + *n * 3 + bdspac) {

/*
                   Overwrite WORK(IU) by left singular vectors of A
                   (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
    i__2 = *lwork - nwork + 1;
    dormbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
        itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &
        ierr);

/*                 Copy left singular vectors of A from WORK(IU) to A */
    dlacpy_("F", m, n, &work[iu], &ldwrku, &a[a_offset], lda);
} else {

/*
                   Generate Q in A
                   (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
*/
    i__2 = *lwork - nwork + 1;
    dorgbr_("Q", m, n, n, &a[a_offset], lda, &work[itauq], &
        work[nwork], &i__2, &ierr);

/*
                   Multiply Q in A by left singular vectors of
                   bidiagonal matrix in WORK(IU), storing result in
                   WORK(IR) and copying to A
                   (Workspace: need 2*N*N, prefer N*N+M*N)
*/
    i__2 = *m;
    i__1 = ldwrkr;
    for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
         i__1) {
/* Computing MIN */
            i__3 = *m - i__ + 1;
            chunk = min(i__3,ldwrkr);
            dgemm_("N", "N", &chunk, n, n, &c_b15, &a[i__ +
                a_dim1], lda, &work[iu], &ldwrku, &c_b29, &
                work[ir], &ldwrkr);
            dlacpy_("F", &chunk, n, &work[ir], &ldwrkr, &a[i__ +
                a_dim1], lda);
/* L20: */
            }
        }
/* L20: */
        } else if (wntqs) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need N+BDSPAC)
*/

        dlaset_("F", m, n, &c_b29, &c_b29, &u[u_offset], ldu);
        dbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*
                Overwrite U by left singular vectors of A and VT
                by right singular vectors of A
                (Workspace: need 3*N, prefer 2*N+N*NB)
*/

        i__1 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        i__1 = *lwork - nwork + 1;
        dormbr_("P", "R", "T", n, n, n, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        } else if (wntqa) {

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in VT
                (Workspace: need N+BDSPAC)
*/

        dlaset_("F", m, m, &c_b29, &c_b29, &u[u_offset], ldu);
        dbdsdc_("U", "I", n, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*              Set the right corner of U to identity matrix */

        if (*m > *n) {
            i__1 = *m - *n;
            i__2 = *m - *n;
            dlaset_("F", &i__1, &i__2, &c_b29, &c_b15, &u[*n + 1 + (*
                n + 1) * u_dim1], ldu);
        }

/*
                Overwrite U by left singular vectors of A and VT
                by right singular vectors of A
                (Workspace: need N*N+2*N+M, prefer N*N+2*N+M*NB)
*/

        i__1 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
        i__1 = *lwork - nwork + 1;
        dormbr_("P", "R", "T", n, n, m, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);
        }

    }

    } else {

/*
          A has more columns than rows. If A has sufficiently more
          columns than rows, first reduce using the LQ decomposition (if
          sufficient workspace available)
*/

    if (*n >= mnthr) {

        if (wntqn) {
/* Computing MIN */
/*
        设置工作数组的起始位置
        itau 是用于存储元素的第一个位置
        nwork 是计算需要的工作空间大小
*/
itau = 1;
nwork = itau + *m;

/*
        计算 A=L*Q，其中 L 是下三角矩阵，Q 是正交矩阵
        (工作空间要求: 需要 2*M，最好是 M+M*NB)
*/
i__1 = *lwork - nwork + 1;
dgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__1, &ierr);

/*      
        将 L 的上三角部分置零
*/
i__1 = *m - 1;
i__2 = *m - 1;
dlaset_("U", &i__1, &i__2, &c_b29, &c_b29, &a[(a_dim1 << 1) +
    1], lda);
ie = 1;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
        对 L 在 A 中进行双对角化
        (工作空间要求: 需要 4*M，最好是 3*M+2*M*NB)
*/
i__1 = *lwork - nwork + 1;
dgebrd_(m, m, &a[a_offset], lda, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__1, &ierr);
nwork = ie + *m;

/*
        执行双对角化奇异值分解，只计算奇异值
        (工作空间要求: 需要 M+BDSPAC)
*/
dbdsdc_("U", "N", m, &s[1], &work[ie], dum, &c__1, dum, &c__1,
     dum, idum, &work[nwork], &iwork[1], info);

} else if (wntqo) {

/*
        Path 2t (N 远大于 M, JOBZ='O')
        M 右奇异向量将覆盖在 A 上，M 左奇异向量将计算在 U 中
*/

ivt = 1;

/*      
        IVT 是 M*M 的矩阵
*/
il = ivt + *m * *m;
if (*lwork >= *m * *n + *m * *m + *m * 3 + bdspac) {

/*     
        WORK(IL) 是 M*N 的矩阵
*/
    ldwrkl = *m;
    chunk = *n;
} else {
    ldwrkl = *m;
    chunk = (*lwork - *m * *m) / *m;
}
itau = il + ldwrkl * *m;
nwork = itau + *m;

/*
        计算 A=L*Q
        (工作空间要求: 需要 M*M+2*M，最好是 M*M+M+M*NB)
*/
i__1 = *lwork - nwork + 1;
dgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__1, &ierr);

/*      
        将 L 复制到 WORK(IL)，并将其上方置零
*/
dlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
i__1 = *m - 1;
i__2 = *m - 1;
dlaset_("U", &i__1, &i__2, &c_b29, &c_b29, &work[il + ldwrkl],
     &ldwrkl);

/*
        在 A 中生成 Q
        (工作空间要求: 需要 M*M+2*M，最好是 M*M+M+M*NB)
*/
i__1 = *lwork - nwork + 1;
dorglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__1, &ierr);
ie = itau;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
        对 WORK(IL) 中的 L 进行双对角化
        (工作空间要求: 需要 M*M+4*M，最好是 M*M+3*M+2*M*NB)
*/
i__1 = *lwork - nwork + 1;
dgebrd_(m, m, &work[il], &ldwrkl, &s[1], &work[ie], &work[
    itauq], &work[itaup], &work[nwork], &i__1, &ierr);
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U, and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M+M*M+BDSPAC)
*/
dbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
    work[ivt], m, dum, idum, &work[nwork], &iwork[1],
    info);

/*
                Overwrite U by left singular vectors of L and WORK(IVT)
                by right singular vectors of L
                (Workspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
*/
i__1 = *lwork - nwork + 1;
dormbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);
i__1 = *lwork - nwork + 1;
dormbr_("P", "R", "T", m, m, m, &work[il], &ldwrkl, &work[
    itaup], &work[ivt], m, &work[nwork], &i__1, &ierr);

/*
                Multiply right singular vectors of L in WORK(IVT) by Q
                in A, storing result in WORK(IL) and copying to A
                (Workspace: need 2*M*M, prefer M*M+M*N)
*/
i__1 = *n;
i__2 = chunk;
for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
    i__2) {
/* Computing MIN */
    i__3 = *n - i__ + 1;
    blk = min(i__3,chunk);
    dgemm_("N", "N", m, &blk, m, &c_b15, &work[ivt], m, &a[
        i__ * a_dim1 + 1], lda, &c_b29, &work[il], &
        ldwrkl);
    dlacpy_("F", m, &blk, &work[il], &ldwrkl, &a[i__ * a_dim1
        + 1], lda);
/* L30: */
}

} else if (wntqs) {

/*
                Path 3t (N much larger than M, JOBZ='S')
                M right singular vectors to be computed in VT and
                M left singular vectors to be computed in U
*/
il = 1;

/*              WORK(IL) is M by M */
ldwrkl = *m;
itau = il + ldwrkl * *m;
nwork = itau + *m;

/*
                Compute A=L*Q
                (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/
i__2 = *lwork - nwork + 1;
dgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
    i__2, &ierr);

/*              Copy L to WORK(IL), zeroing out above it */
dlacpy_("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
i__2 = *m - 1;
i__1 = *m - 1;
dlaset_("U", &i__2, &i__1, &c_b29, &c_b29, &work[il + ldwrkl],
     &ldwrkl);

/*
                Generate Q in A
                (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
*/
i__2 = *lwork - nwork + 1;
dorglq_(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork],
     &i__2, &ierr);
ie = itau;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
                Bidiagonalize L in WORK(IU), copying result to U
                (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
*/
        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dgebrd 对矩阵进行双对角化处理
        dgebrd_(m, m, &work[il], &ldwrkl, &s[1], &work[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);

/*
                执行双对角奇异值分解 (SVD)，计算双对角矩阵的左奇异向量存储在 U 中，
                右奇异向量存储在 VT 中
                (工作空间: 需要 M+BDSPAC)
*/

        dbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*
                使用 L 的左奇异向量覆盖 U，使用 L 的右奇异向量覆盖 VT
                (工作空间: 需要 M*M+3*M，优先 M*M+2*M+M*NB)
*/

        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dormbr，应用 Q 矩阵到 U
        dormbr_("Q", "L", "N", m, m, m, &work[il], &ldwrkl, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dormbr，应用 P 矩阵到 VT
        dormbr_("P", "R", "T", m, m, m, &work[il], &ldwrkl, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &
            ierr);

/*
                将 L 的右奇异向量存储在 WORK(IL) 中的结果乘以 A 的 Q 矩阵，
                结果存储在 VT 中
                (工作空间: 需要 M*M)
*/

        dlacpy_("F", m, m, &vt[vt_offset], ldvt, &work[il], &ldwrkl);
        // 调用 BLAS 函数 dgemm，执行矩阵乘法操作
        dgemm_("N", "N", m, n, m, &c_b15, &work[il], &ldwrkl, &a[
            a_offset], lda, &c_b29, &vt[vt_offset], ldvt);

        } else if (wntqa) {

/*
                Path 4t (N much larger than M, JOBZ='A')
                N right singular vectors to be computed in VT and
                M left singular vectors to be computed in U
*/

        ivt = 1;

/*              WORK(IVT) is M by M */

        ldwkvt = *m;
        itau = ivt + ldwkvt * *m;
        nwork = itau + *m;

/*
                计算 A = L*Q，并将结果复制到 VT 中
                (工作空间: 需要 M*M+2*M，优先 M*M+M+M*NB)
*/

        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dgelqf，计算 LQ 分解
        dgelqf_(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &
            i__2, &ierr);
        // 调用 LAPACK 函数 dlacpy，复制上三角部分到 VT
        dlacpy_("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

/*
                生成 Q 矩阵到 VT 中
                (工作空间: 需要 M*M+2*M，优先 M*M+M+M*NB)
*/

        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dorglq，生成 Q 矩阵
        dorglq_(n, n, m, &vt[vt_offset], ldvt, &work[itau], &work[
            nwork], &i__2, &ierr);

/*              生成 L 矩阵到 A 中，清零其它条目 */

        i__2 = *m - 1;
        i__1 = *m - 1;
        // 调用 LAPACK 函数 dlaset，设置矩阵 A 的上三角部分为零
        dlaset_("U", &i__2, &i__1, &c_b29, &c_b29, &a[(a_dim1 << 1) +
            1], lda);
        ie = itau;
        itauq = ie + *m;
        itaup = itauq + *m;
        nwork = itaup + *m;

/*
                对 A 中的 L 进行双对角化
                (工作空间: 需要 M*M+4*M，优先 M*M+3*M+2*M*NB)
*/

        i__2 = *lwork - nwork + 1;
        // 调用 LAPACK 函数 dgebrd，对矩阵 A 进行双对角化处理
        dgebrd_(m, m, &a[a_offset], lda, &s[1], &work[ie], &work[
            itauq], &work[itaup], &work[nwork], &i__2, &ierr);
/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M+M*M+BDSPAC)
*/
dbdsdc_("U", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
    work[ivt], &ldwkvt, dum, idum, &work[nwork], &iwork[1]
    , info);

/*
                Overwrite U by left singular vectors of L and WORK(IVT)
                by right singular vectors of L
                (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
*/
i__2 = *lwork - nwork + 1;
dormbr_("Q", "L", "N", m, m, m, &a[a_offset], lda, &work[
    itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);
i__2 = *lwork - nwork + 1;
dormbr_("P", "R", "T", m, m, m, &a[a_offset], lda, &work[
    itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &
    ierr);

/*
                Multiply right singular vectors of L in WORK(IVT) by
                Q in VT, storing result in A
                (Workspace: need M*M)
*/
dgemm_("N", "N", m, n, m, &c_b15, &work[ivt], &ldwkvt, &vt[
    vt_offset], ldvt, &c_b29, &a[a_offset], lda);

/*              Copy right singular vectors of A from A to VT */
dlacpy_("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

}

} else {

/*
             N .LT. MNTHR

             Path 5t (N greater than M, but not much larger)
             Reduce to bidiagonal form without LQ decomposition
*/

ie = 1;
itauq = ie + *m;
itaup = itauq + *m;
nwork = itaup + *m;

/*
             Bidiagonalize A
             (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
*/
i__2 = *lwork - nwork + 1;
dgebrd_(m, n, &a[a_offset], lda, &s[1], &work[ie], &work[itauq], &
    work[itaup], &work[nwork], &i__2, &ierr);
if (wntqn) {

/*
                Perform bidiagonal SVD, only computing singular values
                (Workspace: need M+BDSPAC)
*/
dbdsdc_("L", "N", m, &s[1], &work[ie], dum, &c__1, dum, &c__1,
     dum, idum, &work[nwork], &iwork[1], info);
} else if (wntqo) {
ldwkvt = *m;
ivt = nwork;
if (*lwork >= *m * *n + *m * 3 + bdspac) {

/*                 WORK( IVT ) is M by N */
dlaset_("F", m, n, &c_b29, &c_b29, &work[ivt], &ldwkvt);
nwork = ivt + ldwkvt * *n;
} else {

/*                 WORK( IVT ) is M by M */
nwork = ivt + ldwkvt * *m;
il = nwork;

/*                 WORK(IL) is M by CHUNK */
chunk = (*lwork - *m * *m - *m * 3) / *m;
}

/*
                Perform bidiagonal SVD, computing left singular vectors
                of bidiagonal matrix in U and computing right singular
                vectors of bidiagonal matrix in WORK(IVT)
                (Workspace: need M*M+BDSPAC)
*/
/*

        dbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &
            work[ivt], &ldwkvt, dum, idum, &work[nwork], &iwork[1]
            , info);

/*
                用来计算双对角矩阵的奇异值分解，并返回左奇异向量到 U 和右奇异向量到 VT
                (工作空间需求: M+BDSPAC)

*/

        i__2 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

/*
                用来计算 Q 矩阵，覆盖 U 的左奇异向量
                (工作空间需求: M*M+2*M, 最好 M*M+M+M*NB)

*/

        if (*lwork >= *m * *n + *m * 3 + bdspac) {

/*
                   覆盖 WORK(IVT) 的左奇异向量
                   (工作空间需求: M*M+2*M, 最好 M*M+M+M*NB)

*/

            i__2 = *lwork - nwork + 1;
            dormbr_("P", "R", "T", m, n, m, &a[a_offset], lda, &work[
                itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2,
                &ierr);

/*                 将 A 的右奇异向量从 WORK(IVT) 复制到 A */

            dlacpy_("F", m, n, &work[ivt], &ldwkvt, &a[a_offset], lda);
        } else {

/*
                   在 A 中生成 P**T
                   (工作空间需求: M*M+2*M, 最好 M*M+M+M*NB)

*/

            i__2 = *lwork - nwork + 1;
            dorgbr_("P", m, n, m, &a[a_offset], lda, &work[itaup], &
                work[nwork], &i__2, &ierr);

/*
                   将 A 中的 Q 乘以 WORK(IVT) 中的双对角矩阵的右奇异向量，结果存储在 WORK(IL) 中并复制到 A
                   (工作空间需求: 2*M*M, 最好 M*M+M*N)

*/

            i__2 = *n;
            i__1 = chunk;
            for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ +=
                 i__1) {
/* Computing MIN */
            i__3 = *n - i__ + 1;
            blk = min(i__3,chunk);
            dgemm_("N", "N", m, &blk, m, &c_b15, &work[ivt], &
                ldwkvt, &a[i__ * a_dim1 + 1], lda, &c_b29, &
                work[il], m);
            dlacpy_("F", m, &blk, &work[il], m, &a[i__ * a_dim1 +
                1], lda);
/* L40: */
            }
        }
        } else if (wntqs) {

/*
                执行双对角奇异值分解，计算双对角矩阵的左奇异向量到 U 和右奇异向量到 VT
                (工作空间需求: M+BDSPAC)

*/

        dlaset_("F", m, n, &c_b29, &c_b29, &vt[vt_offset], ldvt);
        dbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

/*
                覆盖 U 的左奇异向量和 VT 的右奇异向量
                (工作空间需求: 3*M, 最好 2*M+M*NB)

*/      
        i__1 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

// 调用 LAPACK 子程序 dormbr，用于计算矩阵乘积 Q * A 或 P * A，其中 Q 和 P 是由之前的分解生成的正交/单位矩阵。


        i__1 = *lwork - nwork + 1;
        dormbr_("P", "R", "T", m, n, m, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);

// 再次调用 dormbr，用于计算矩阵乘积 P * A^T 或 Q * A^T，这里 A^T 是 A 的转置。


        dlaset_("F", n, n, &c_b29, &c_b29, &vt[vt_offset], ldvt);

// 调用 LAPACK 子程序 dlaset，用于将矩阵 VT 的元素设置为指定的值，这里是零。


        dbdsdc_("L", "I", m, &s[1], &work[ie], &u[u_offset], ldu, &vt[
            vt_offset], ldvt, dum, idum, &work[nwork], &iwork[1],
            info);

// 调用 LAPACK 子程序 dbdsdc，执行奇异值分解（SVD）的双对角矩阵部分，计算左奇异向量存储在 U 中，右奇异向量存储在 VT 中。


        if (*n > *m) {
            i__1 = *n - *m;
            i__2 = *n - *m;
            dlaset_("F", &i__1, &i__2, &c_b29, &c_b15, &vt[*m + 1 + (*
                m + 1) * vt_dim1], ldvt);
        }

// 如果 n 大于 m，则调用 dlaset 设置 VT 的右下角为单位矩阵。


        i__1 = *lwork - nwork + 1;
        dormbr_("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[
            itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

// 再次调用 dormbr，用于计算矩阵乘积 Q * A 或 P * A，以重构 U 或 VT 中的奇异向量。


        i__1 = *lwork - nwork + 1;
        dormbr_("P", "R", "T", n, n, m, &a[a_offset], lda, &work[
            itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &
            ierr);

// 再次调用 dormbr，用于计算矩阵乘积 P * A^T 或 Q * A^T，以重构 U 或 VT 中的奇异向量。


    if (iscl == 1) {
    if (anrm > bignum) {
        dlascl_("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &
            minmn, &ierr);
    }
    if (anrm < smlnum) {
        dlascl_("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &
            minmn, &ierr);
    }
    }

// 如果需要，调用 LAPACK 子程序 dlascl，根据 anrm 的大小调整奇异值 s 中的元素大小。


    work[1] = (doublereal) maxwrk;

// 将工作空间的最佳大小存储在 work 数组的第一个位置。


    return 0;

// 返回 0 表示函数执行成功。


} /* dgesdd_ */

// 子程序 dgesdd 的结尾。


/* Subroutine */ int dgesv_(integer *n, integer *nrhs, doublereal *a, integer
    *lda, integer *ipiv, doublereal *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    extern /* Subroutine */ int dgetrf_(integer *, integer *, doublereal *,
        integer *, integer *, integer *), xerbla_(char *, integer *), dgetrs_(char *, integer *, integer *, doublereal *,
        integer *, integer *, doublereal *, integer *, integer *);

// 子程序 dgesv 的开头，声明了局部变量和外部函数的声明。

// 以上是对给定代码的每行详细的注释解释。
    DGESV computes the solution to a real system of linear equations
       A * X = B,
    where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

    The LU decomposition with partial pivoting and row interchanges is
    used to factor A as
       A = P * L * U,
    where P is a permutation matrix, L is unit lower triangular, and U is
    upper triangular.  The factored form of A is then used to solve the
    system of equations A * X = B.

    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N coefficient matrix A.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, so the solution could not be computed.

    =====================================================================
    /* Parameter adjustments */
    // 定义矩阵 A 的第一维度和偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    // 对 A 进行偏移，使得可以访问正确的内存位置
    a -= a_offset;
    // 对 ipiv 数组进行偏移，使得可以访问正确的内存位置
    --ipiv;
    // 定义矩阵 B 的第一维度和偏移量
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    // 对 B 进行偏移，使得可以访问正确的内存位置
    b -= b_offset;

    /* Function Body */
    // 将 info 初始化为 0
    *info = 0;
    // 检查输入参数 n 是否小于 0
    if (*n < 0) {
        *info = -1;
    // 检查输入参数 nrhs 是否小于 0
    } else if (*nrhs < 0) {
        *info = -2;
    // 检查输入参数 lda 是否小于 max(1, *n)
    } else if (*lda < max(1,*n)) {
        *info = -4;
    // 检查输入参数 ldb 是否小于 max(1, *n)
    } else if (*ldb < max(1,*n)) {
        *info = -7;
    }
    // 如果 info 不为 0，则调用 xerbla_ 报错并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DGESV ", &i__1);
        return 0;
    }

    /*     Compute the LU factorization of A. */

    // 调用 LAPACK 函数 dgetrf_，计算矩阵 A 的 LU 分解
    dgetrf_(n, n, &a[a_offset], lda, &ipiv[1], info);
    // 如果 info 为 0，说明 LU 分解成功
    if (*info == 0) {

        /*        Solve the system A*X = B, overwriting B with X. */

        // 调用 LAPACK 函数 dgetrs_，解方程组 A*X = B，结果存储在 B 中
        dgetrs_("No transpose", n, nrhs, &a[a_offset], lda, &ipiv[1], &b[
            b_offset], ldb, info);
    }
    // 返回 0 表示函数执行完毕
    return 0;

/*     End of DGESV */

} /* dgesv_ */

/* Subroutine */ int dgetf2_(integer *m, integer *n, doublereal *a, integer *
    lda, integer *ipiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, jp;
    // 最小安全浮点数
    static doublereal sfmin;
    // LAPACK 函数和 BLAS 函数声明
    extern /* Subroutine */ int dger_(integer *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *), dscal_(integer *, doublereal *, doublereal *, integer
        *);
    // BLAS 函数声明
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    // BLAS 函数声明
    extern integer idamax_(integer *, doublereal *, integer *);
    // LAPACK 函数声明
    extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DGETF2 computes an LU factorization of a general m-by-n matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 2 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).


注释到这里为止。
    # IPIV 是一个输出参数，它是一个整数数组，大小为 min(M,N)
    # 它包含了行置换的索引：对于 1 <= i <= min(M,N)，表示矩阵的第 i 行与第 IPIV(i) 行进行了交换。

    # INFO 是一个输出参数，是一个整数
    # = 0: 操作成功完成
    # < 0: 如果 INFO = -k，表示第 k 个参数具有非法值
    # > 0: 如果 INFO = k，表示矩阵分解已完成，但因为 U(k,k) 恰好为零，导致因为除零而无法使用它来解决方程组。

    =====================================================================

    # 测试输入参数的有效性。
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;
--ipiv;


# 参数调整
a_dim1 = *lda;  # 将参数 lda 赋值给 a_dim1，lda 表示数组 a 的第一个维度长度
a_offset = 1 + a_dim1;  # 计算数组 a 的偏移量
a -= a_offset;  # 调整数组 a 的指针，使其指向正确的起始位置
--ipiv;  # 将指向 ipiv 数组的指针向前移动一个位置



/* Function Body */
*info = 0;
if (*m < 0) {
*info = -1;
} else if (*n < 0) {
*info = -2;
} else if (*lda < max(1,*m)) {
*info = -4;
}
if (*info != 0) {
i__1 = -(*info);
xerbla_("DGETF2", &i__1);
return 0;
}


# 函数体
*info = 0;  # 将 info 参数初始化为 0
if (*m < 0) {  # 如果 m 参数小于 0
*info = -1;  # 设置 info 参数为 -1，表示参数错误
} else if (*n < 0) {  # 否则如果 n 参数小于 0
*info = -2;  # 设置 info 参数为 -2，表示参数错误
} else if (*lda < max(1,*m)) {  # 否则如果 lda 小于 1 和 m 中较大的值
*info = -4;  # 设置 info 参数为 -4，表示参数错误
}
if (*info != 0) {  # 如果 info 参数不为 0，即有错误发生
i__1 = -(*info);  # 计算错误码的绝对值
xerbla_("DGETF2", &i__1);  # 调用错误处理程序，指示错误的发生位置
return 0;  # 返回 0，终止函数执行
}



/*     Quick return if possible */
if (*m == 0 || *n == 0) {
return 0;
}


# 如果可能的话，快速返回
if (*m == 0 || *n == 0) {  # 如果 m 或 n 中有一个为 0
return 0;  # 直接返回 0，结束函数执行
}



/*     Compute machine safe minimum */
sfmin = SAFEMINIMUM;


# 计算机器可安全表示的最小值
sfmin = SAFEMINIMUM;  # 将预定义的 SAFEMINIMUM 赋值给 sfmin，表示最小安全值



i__1 = min(*m,*n);
for (j = 1; j <= i__1; ++j) {


# 循环计算
i__1 = min(*m,*n);  # 计算 m 和 n 中的较小值
for (j = 1; j <= i__1; ++j) {  # 循环 j 从 1 到较小值的次数



/*        Find pivot and test for singularity. */
i__2 = *m - j + 1;
jp = j - 1 + idamax_(&i__2, &a[j + j * a_dim1], &c__1);
ipiv[j] = jp;
if (a[jp + j * a_dim1] != 0.) {


# 查找主元并检查奇异性
i__2 = *m - j + 1;  # 计算当前列中要搜索的元素数
jp = j - 1 + idamax_(&i__2, &a[j + j * a_dim1], &c__1);  # 找到当前列中绝对值最大的元素的索引
ipiv[j] = jp;  # 将找到的主元的索引存储在 ipiv 数组中
if (a[jp + j * a_dim1] != 0.) {  # 如果找到的主元不为 0



/*           Apply the interchange to columns 1:N. */
if (jp != j) {
dswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);
}


# 对列 1:N 应用置换
if (jp != j) {  # 如果找到的主元不在当前列的位置
dswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);  # 交换列 j 和列 jp 的元素
}



/*           Compute elements J+1:M of J-th column. */
if (j < *m) {
if ((d__1 = a[j + j * a_dim1], abs(d__1)) >= sfmin) {
i__2 = *m - j;
d__1 = 1. / a[j + j * a_dim1];
dscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);
} else {
i__2 = *m - j;
for (i__ = 1; i__ <= i__2; ++i__) {
a[j + i__ + j * a_dim1] /= a[j + j * a_dim1];
}
}
}


# 计算第 J 列的 J+1:M 元素
if (j < *m) {  # 如果当前列小于 m
if ((d__1 = a[j + j * a_dim1], abs(d__1)) >= sfmin) {  # 如果主元的绝对值大于或等于 sfmin
i__2 = *m - j;
d__1 = 1. / a[j + j * a_dim1];
dscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);  # 对列进行缩放操作
} else {  # 否则
i__2 = *m - j;
for (i__ = 1; i__ <= i__2; ++i__) {
a[j + i__ + j * a_dim1] /= a[j + j * a_dim1];  # 对列进行归一化操作
}
}
}



} else if (*info == 0) {
*info = j;
}


# 否则如果没有发现主元且无错误信息
} else if (*info == 0) {
*info = j;  # 将当前迭代次数存储在 info 中
}



if (j < min(*m,*n)) {


# 如果当前迭代次数小于 m 和 n 中的较小值
if (j < min(*m,*n)) {



/*           Update trailing submatrix. */
i__2 = *m - j;
i__3 = *n - j;
dger_(&i__2, &i__3, &c_b151, &a[j + 1 + j * a_dim1], &c__1, &a[j
+ (j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1],
lda);


# 更新尾部子矩阵
i__2 = *m - j;
i__3 = *n - j;
dger_(&i__2, &i__3, &c_b151, &a[j + 1 + j * a_dim1], &c__1, &a[j
+ (j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1],
lda);



/* L10: */
}
return 0;

/*     End of DGETF2 */
} /* dgetf2_ */


# 结束 DGETF2 子程序
} /* dgetf2_ */



/* Subroutine */ int dgetrf_(integer *m, integer *n, doublereal *a, integer *
lda, integer *ipiv, integer *info)
{


# dgetrf 子程序
subroutine dgetrf_(integer *m, integer *n, doublereal *a, integer *
lda, integer *ipiv, integer *info)
{



/* System generated locals */
integer a_dim1, a_offset, i__1, i__2,
    # 定义函数 DGETRF，用于计算一般 M×N 矩阵 A 的 LU 分解，使用部分主元素选取和行交换。
    def DGETRF(M, N, A, LDA, IPIV, INFO):
        # 这是一个右向 Level 3 BLAS 版本的算法，用于计算 LU 分解。
    
        # M 是矩阵 A 的行数，要求大于等于 0。
        # N 是矩阵 A 的列数，要求大于等于 0。
        # A 是输入输出参数，是一个大小为 (LDA, N) 的双精度浮点数数组：
        #   在输入时，存储待分解的 M×N 矩阵 A；
        #   在输出时，存储 LU 分解后的因子 L 和 U，使得 A = P * L * U。
        # LDA 是矩阵 A 的第一个维度的长度，要求大于等于 max(1, M)。
        # IPIV 是输出参数，是一个长度为 min(M, N) 的整数数组，存储主元素的行索引。
        # INFO 是输出参数，表示函数的退出状态：
        #   = 0: 成功退出；
        #   < 0: 如果 INFO = -i，则第 i 个参数的值不合法；
        #   > 0: 如果 INFO = i，则 U(i,i) 恰好为零。尽管完成了分解，但 U 是奇异的，
        #        如果用它来解方程组将会出现除以零的情况。
        
        # 测试输入参数的合法性。
/* Parameter adjustments */
/* Adjust dimensions for matrix A */
a_dim1 = *lda;
/* Offset for matrix A */
a_offset = 1 + a_dim1;
/* Adjust pointer to matrix A */
a -= a_offset;
/* Adjust pointer to array of pivot indices */
--ipiv;

/* Function Body */
/* Initialize info flag */
*info = 0;
/* Check for invalid value of m */
if (*m < 0) {
    *info = -1;
/* Check for invalid value of n */
} else if (*n < 0) {
    *info = -2;
/* Check if lda is too small */
} else if (*lda < max(1,*m)) {
    *info = -4;
}
/* Handle error conditions */
if (*info != 0) {
    /* Call error handler */
    i__1 = -(*info);
    xerbla_("DGETRF", &i__1);
    /* Return with error */
    return 0;
}

/* Quick return if possible */
/* Check if matrix dimensions are zero */
if (*m == 0 || *n == 0) {
    /* Return immediately */
    return 0;
}

/* Determine the block size for this environment. */
/* Call a system function to determine optimal block size */
nb = ilaenv_(&c__1, "DGETRF", " ", m, n, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
/* Decide whether to use blocked or unblocked code */
if (nb <= 1 || nb >= min(*m,*n)) {

/* Use unblocked code. */
/* Call LAPACK routine for unblocked factorization */
dgetf2_(m, n, &a[a_offset], lda, &ipiv[1], info);
} else {

/* Use blocked code. */
/* Loop over diagonal blocks */
i__1 = min(*m,*n);
/* Loop increment */
i__2 = nb;
for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Determine current block size */
/* Compute actual block size */
/* Minimize the size */
i__3 = min(*m,*n) - j + 1;
/* Get the minimum */
jb = min(i__3,nb);

/*
     Factor diagonal and subdiagonal blocks and test for exact
     singularity.
*/
/* Compute the size of the leading block */
i__3 = *m - j + 1;
/* Call LAPACK routine for factorization */
dgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);

/* Adjust INFO and the pivot indices. */
/* Check if the condition is met */
if (*info == 0 && iinfo > 0) {
    /* Adjust the condition */
    *info = iinfo + j - 1;
}
/* Compute the size of the leading block */
i__3 = min(*m,*n);
/* Adjust the size of the column */
/* Adjust the swap positions */
for (i__ = j; i__ <= i__3; ++i__) {
    /* Adjust the row */
    ipiv[i__] = j - 1 + ipiv[i__];
/* L10: */
}

/* Apply interchanges to columns 1:J-1. */
/* Compute the size of the leading block */
i__3 = j - 1;
/* Compute the new position */
i__4 = j + jb - 1;
/* Adjust the elements */
dlaswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);

/* Check if the position is valid */
if (j + jb <= *n) {

/* Apply interchanges to columns J+JB:N. */
/* Compute the size of the block */
i__3 = *n - j - jb + 1;
/* Compute the position */
i__4 = j + jb - 1;
/* Adjust the elements */
dlaswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
    ipiv[1], &c__1);

/* Compute the size of the row */
i__3 = *n - j - jb + 1;
/* Compute the new position */
/* Compute the new position */
dtrsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
    c_b15, &a[j + j * a_dim1], lda, &a[j + (j + jb) *
    a_dim1], lda);
/* Check if the position is valid */

/* Update trailing submatrix. */

i__3 = *m - j - jb + 1;
i__4 = *n - j - jb + 1;
dgemm_("No transpose", "No transpose", &i__3, &i__4, &jb,
    &c_b151, &a[j + jb + j * a_dim1], lda, &a[j + (j
    + jb) * a_dim1], lda, &c_b15, &a[j + jb + (j + jb)
     * a_dim1], lda);
}
/* L20: */
}
}
return 0;

/* End of DGETRF */

} /* dgetrf_ */

/* Subroutine */ int dgetrs_(char *trans, integer *n, integer *nrhs,
doublereal *a, integer *lda, integer *ipiv, doublereal *b, integer *
ldb, integer *info)
{
/* Local variables */
/* Call the system function */
integer a_dim1, a_offset, b_dim1, b_offset, i__1;

/* Local variables */
/* Call the system function */
extern logical lsame_(char *, char *);
    # 定义外部子程序 dtrsm_
    extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);

    # 定义外部子程序 xerbla_
    extern /* Subroutine */ int xerbla_(
        char *, integer *);

    # 定义静态逻辑变量 notran，用于存储逻辑值（true/false）
    static logical notran;

    # 定义外部子程序 dlaswp_
    extern /* Subroutine */ int dlaswp_(integer *, doublereal *,
        integer *, integer *, integer *, integer *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DGETRS solves a system of linear equations
       A * X = B  or  A' * X = B
    with a general N-by-N matrix A using the LU factorization computed
    by DGETRF.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A'* X = B  (Transpose)
            = 'C':  A'* X = B  (Conjugate transpose = Transpose)

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;  // 初始化 info 参数为 0，表示成功返回
    notran = lsame_(trans, "N");  // 检查是否不是转置形式 'N'
    if (! notran && ! lsame_(trans, "T") && ! lsame_(
        trans, "C")) {
    *info = -1;  // 如果 TRANS 不是 'N', 'T', 'C' 中的一种，设置 info 为 -1，表示参数错误
    } else if (*n < 0) {
    *info = -2;  // 如果 N < 0，设置 info 为 -2，表示参数错误
    } else if (*nrhs < 0) {
    *info = -3;  // 如果 NRHS < 0，设置 info 为 -3，表示参数错误
    } else if (*lda < max(1,*n)) {
    *info = -5;  // 如果 LDA < max(1,N)，设置 info 为 -5，表示参数错误
    } else if (*ldb < max(1,*n)) {
    *info = -8;  // 如果 LDB < max(1,N)，设置 info 为 -8，表示参数错误
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DGETRS", &i__1);  // 调用 xerbla 函数报告错误信息
    return 0;  // 返回，不继续执行
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {
    return 0;  // 如果 N 或 NRHS 为 0，直接返回
    }

    if (notran) {

/*
          Solve A * X = B.

          Apply row interchanges to the right hand sides.
*/

    dlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c__1);  // 对 B 应用行交换，根据 IPIV 数组

/*        Solve L*X = B, overwriting B with X. */

    dtrsm_("Left", "Lower", "No transpose", "Unit", n, nrhs, &c_b15, &a[
        a_offset], lda, &b[b_offset], ldb);  // 解线性方程 L*X = B，覆盖 B 中的内容为 X

/*        Solve U*X = B, overwriting B with X. */
    dtrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b15, &
        a[a_offset], lda, &b[b_offset], ldb);


    ! 调用名为 dtrsm_ 的子程序，用于解一个特定形式的线性方程组
    ! "Left", "Upper", "No transpose", "Non-unit" 是 dtrsm_ 的参数，指定解的方式和矩阵特性
    ! n 是方程组的维度，nrhs 是右侧向量的数量
    ! &c_b15 是一个常数参数
    ! a[a_offset] 是矩阵 a 的起始地址，lda 是 a 的列数
    ! &b[b_offset] 是矩阵 b 的起始地址，ldb 是 b 的列数



    } else {


    ! 如果条件不满足上述 if 语句的条件，则执行这里的代码块
/*
   Solve A' * X = B.

   Solve U'*X = B, overwriting B with X.
*/
dtrsm_("Left", "Upper", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);

/* Solve L'*X = B, overwriting B with X. */
dtrsm_("Left", "Lower", "Transpose", "Unit", n, nrhs, &c_b15, &a[
    a_offset], lda, &b[b_offset], ldb);

/* Apply row interchanges to the solution vectors. */
dlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c_n1);
}

return 0;

/* End of DGETRS */
} /* dgetrs_ */

/* Subroutine */ int dhseqr_(char *job, char *compz, integer *n, integer *ilo,
     integer *ihi, doublereal *h__, integer *ldh, doublereal *wr,
     doublereal *wi, doublereal *z__, integer *ldz, doublereal *work,
     integer *lwork, integer *info)
{
/* System generated locals */
address a__1[2];
integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2[2], i__3;
doublereal d__1;
char ch__1[2];

/* Local variables */
static integer i__;
static doublereal hl[2401]    /* was [49][49] */;
static integer kbot, nmin;
extern logical lsame_(char *, char *);
static logical initz;
static doublereal workl[49];
static logical wantt, wantz;
extern /* Subroutine */ int dlaqr0_(logical *, logical *, integer *,
    integer *, integer *, doublereal *, integer *, doublereal *,
    doublereal *, integer *, integer *, doublereal *, integer *,
    doublereal *, integer *, integer *), dlahqr_(logical *, logical *,
     integer *, integer *, integer *, doublereal *, integer *,
    doublereal *, doublereal *, integer *, integer *, doublereal *,
    integer *, integer *), dlacpy_(char *, integer *, integer *,
    doublereal *, integer *, doublereal *, integer *),
    dlaset_(char *, integer *, integer *, doublereal *, doublereal *,
    doublereal *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int xerbla_(char *, integer *);
static logical lquery;


/*
*/

/* Parameter adjustments */
h_dim1 = *ldh;
h_offset = 1 + h_dim1;
h__ -= h_offset;
--wr;
--wi;
z_dim1 = *ldz;
z_offset = 1 + z_dim1;
z__ -= z_offset;
--work;

/* Function Body */
wantt = lsame_(job, "S");
initz = lsame_(compz, "I");
wantz = initz || lsame_(compz, "V");
work[1] = (doublereal) max(1,*n);
lquery = *lwork == -1;

*info = 0;
if (! lsame_(job, "E") && ! wantt) {
*info = -1;
} else if (! lsame_(compz, "N") && ! wantz) {
*info = -2;
} else if (*n < 0) {
*info = -3;
} else if (*ilo < 1 || *ilo > max(1,*n)) {
*info = -4;
} else if (*ihi < min(*ilo,*n) || *ihi > *n) {
*info = -5;
} else if (*ldh < max(1,*n)) {
*info = -7;
} else if (*ldz < 1 || wantz && *ldz < max(1,*n)) {
*info = -11;
    } else if (*lwork < max(1,*n) && ! lquery) {
        // 如果传入的工作数组长度小于1和n中的较大者，并且不是查询模式
        // 设置错误信息为-13
        *info = -13;
    }

    if (*info != 0) {
        // 如果错误信息不为0，执行以下操作
        // (这里需要根据上下文来补充具体操作的含义)
/*        ==== Quick return in case of invalid argument. ==== */
/*        快速返回，如果参数无效。*/

i__1 = -(*info);
xerbla_("DHSEQR", &i__1);
return 0;

} else if (*n == 0) {

/*        ==== Quick return in case N = 0; nothing to do. ==== */
/*        快速返回，如果 N = 0；无需执行任何操作。*/

return 0;

} else if (lquery) {

/*        ==== Quick return in case of a workspace query ==== */
/*        在工作空间查询时快速返回。*/

dlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &wi[
    1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
/*
      ==== Ensure reported workspace size is backward-compatible with
      .    previous LAPACK versions. ====
      确保报告的工作空间大小与之前的 LAPACK 版本向后兼容。
   Computing MAX
*/
d__1 = (doublereal) max(1,*n);
work[1] = max(d__1,work[1]);
return 0;

} else {

/*        ==== copy eigenvalues isolated by DGEBAL ==== */
/*        复制由 DGEBAL 隔离的特征值。*/

i__1 = *ilo - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.;
/* L10: */
}
i__1 = *n;
for (i__ = *ihi + 1; i__ <= i__1; ++i__) {
    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.;
/* L20: */
}

/*        ==== Initialize Z, if requested ==== */
/*        如果需要，初始化 Z。*/

if (initz) {
    dlaset_("A", n, n, &c_b29, &c_b15, &z__[z_offset], ldz);
}

/*        ==== Quick return if possible ==== */
/*        如果可能，快速返回。*/

if (*ilo == *ihi) {
    wr[*ilo] = h__[*ilo + *ilo * h_dim1];
    wi[*ilo] = 0.;
    return 0;
}

/*
      ==== DLAHQR/DLAQR0 crossover point ====
      DLAHQR/DLAQR0 切换点
   Writing concatenation
*/
i__2[0] = 1, a__1[0] = job;
i__2[1] = 1, a__1[1] = compz;
s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);
nmin = ilaenv_(&c__12, "DHSEQR", ch__1, n, ilo, ihi, lwork, (ftnlen)6,
     (ftnlen)2);
nmin = max(11,nmin);

/*        ==== DLAQR0 for big matrices; DLAHQR for small ones ==== */
/*        对于大矩阵使用 DLAQR0；对于小矩阵使用 DLAHQR。*/

if (*n > nmin) {
    dlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
        &wi[1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork,
        info);
} else {

/*           ==== Small matrix ==== */
/*           小矩阵 */

    dlahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
        &wi[1], ilo, ihi, &z__[z_offset], ldz, info);

    if (*info > 0) {

/*
          ==== A rare DLAHQR failure!  DLAQR0 sometimes succeeds
          .    when DLAHQR fails. ====
          罕见的 DLAHQR 失败情况！DLAQR0 有时在 DLAHQR 失败时成功。
*/

    kbot = *info;

    if (*n >= 49) {

/*
             ==== Larger matrices have enough subdiagonal scratch
             .    space to call DLAQR0 directly. ====
             较大的矩阵有足够的次对角线暂存空间可以直接调用 DLAQR0。
*/

        dlaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset],
            ldh, &wr[1], &wi[1], ilo, ihi, &z__[z_offset],
            ldz, &work[1], lwork, info);

    } else {

/*
             ==== Tiny matrices don't have enough subdiagonal
             .    scratch space to benefit from DLAQR0.  Hence,
             .    tiny matrices must be copied into a larger
             .    array before calling DLAQR0. ====
             微小的矩阵没有足够的次对角线暂存空间可以从 DLAQR0 中获益。
             因此，微小的矩阵在调用 DLAQR0 之前必须复制到一个较大的数组中。
*/
/*
   dlacpy_("A", n, n, &h__[h_offset], ldh, hl, &c__49);
   将 h__ 的内容复制到 hl，A 表示复制整个数组，n 表示复制 n × n 的子区域

   hl[*n + 1 + *n * 49 - 50] = 0.;
   将 hl 的特定元素置为 0，该元素的索引计算是基于 *n 和数组的特定偏移计算而来

   i__1 = 49 - *n;
   dlaset_("A", &c__49, &i__1, &c_b29, &c_b29, &hl[(*n + 1) * 49 - 49], &c__49);
   将 hl 的子区域设置为常数 c_b29（通常是 0.0），A 表示设置整个数组区域

   dlaqr0_(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49, &wr[1], &wi[1], ilo, ihi, &z__[z_offset], ldz, workl, &c__49, info);
   调用 LAPACK 中的 dlaqr0 函数，进行特定的 QR 算法操作，处理传递的参数和数据

   if (wantt || *info != 0) {
   判断是否需要保留变换后的 H 矩阵（hl 到 h__），或者处理错误信息
       dlacpy_("A", n, n, hl, &c__49, &h__[h_offset], ldh);
       将 hl 的内容复制回 h__，A 表示复制整个数组
   }
}
}
*/

/* ==== Clear out the trash, if necessary. ==== */

if ((wantt || *info != 0) && *n > 2) {
   判断是否需要清理“垃圾”数据，条件是需要保留变换后的 H 矩阵或者有错误信息，并且 n 大于 2
   i__1 = *n - 2;
   i__3 = *n - 2;
   dlaset_("L", &i__1, &i__3, &c_b29, &c_b29, &h__[h_dim1 + 3], ldh);
   将 h__ 的下三角矩阵区域设置为常数 c_b29（通常是 0.0），L 表示设置下三角部分
}

/*
   ==== Ensure reported workspace size is backward-compatible with
   .    previous LAPACK versions. ====

   Computing MAX
*/

d__1 = (doublereal) max(1,*n);
计算工作区大小的最大值，至少为 1 和 *n 之间的较大值
work[1] = max(d__1,work[1]);
将计算得到的工作区大小与现有的工作区大小做比较，取较大值更新工作区大小

/* ==== End of DHSEQR ==== */

return 0;
} /* dhseqr_ */

logical disnan_(doublereal *din)
{
/* System generated locals */
logical ret_val;

/* Local variables */
extern logical dlaisnan_(doublereal *, doublereal *);

/*
   -- LAPACK auxiliary routine (version 3.2.2) --
   -- LAPACK is a software package provided by Univ. of Tennessee,    --
   -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   June 2010

   Purpose
   =======

   DISNAN returns .TRUE. if its argument is NaN, and .FALSE.
   otherwise.  To be replaced by the Fortran 2003 intrinsic in the
   future.

   Arguments
   =========

   DIN     (input) DOUBLE PRECISION
   Input to test for NaN.

   =====================================================================
*/

ret_val = dlaisnan_(din, din);
调用 dlaisnan_ 函数来检测输入是否为 NaN，并返回逻辑值

return ret_val;
} /* disnan_ */

/* Subroutine */ int dlabad_(doublereal *small, doublereal *large)
{

/*
   -- LAPACK auxiliary routine (version 3.2) --
   -- LAPACK is a software package provided by Univ. of Tennessee,    --
   -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

   Purpose
   =======

   DLABAD takes as input the values computed by DLAMCH for underflow and
   overflow, and returns the square root of each of these values if the
   log of LARGE is sufficiently large.  This subroutine is intended to
   identify machines with a large exponent range, such as the Crays, and
   redefine the underflow and overflow limits to be the square roots of
   the values computed by DLAMCH.  This subroutine is needed because
   DLAMCH does not compensate for poor arithmetic in the upper half of
   the exponent range, as is found on a Cray.

   Arguments
   =========

*/
    SMALL   (input/output) DOUBLE PRECISION
            On entry, the underflow threshold as computed by DLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of SMALL, otherwise unchanged.

    LARGE   (input/output) DOUBLE PRECISION
            On entry, the overflow threshold as computed by DLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of LARGE, otherwise unchanged.

    =====================================================================

       如果看起来我们在使用 Cray 计算机，为了避免溢出和下溢问题，对 SMALL 和 LARGE 取平方根。
    if (d_lg10(large) > 2e3) {
    *small = sqrt(*small);
    *large = sqrt(*large);
    }


    // 检查 large 的对数是否大于 2000，如果是，则对 small 和 large 分别进行平方根操作
    if (d_lg10(large) > 2e3) {
        *small = sqrt(*small);
        *large = sqrt(*large);
    }



    return 0;


    // 返回整数值 0，表示函数执行成功
    return 0;



} /* dlabad_ */


// 子程序 dlabad_ 的结尾
} /* dlabad_ */



/* Subroutine */ int dlabrd_(integer *m, integer *n, integer *nb, doublereal *
    a, integer *lda, doublereal *d__, doublereal *e, doublereal *tauq,
    doublereal *taup, doublereal *x, integer *ldx, doublereal *y, integer
    *ldy)
{


/* 子程序 dlabrd_
   输入：
     M - A 矩阵的行数
     N - A 矩阵的列数
     NB - 要减少的 A 矩阵的前导行和列数
     A - 要减少的 m×n 一般矩阵
     LDA - A 数组的第一个维度的长度
     D - 主对角元素数组
     E - 次对角元素数组
     TAUQ - 包含正交矩阵 Q 的反射因子的数组
     TAUP - 包含正交矩阵 P 的反射因子的数组
     X - 用于应用变换的矩阵 X
     LDX - X 数组的第一个维度的长度
     Y - 用于应用变换的矩阵 Y
     LDY - Y 数组的第一个维度的长度

   输出：
     无
   用途：
     将 m×n 矩阵 A 的前 NB 行和列通过正交变换 Q' * A * P 减少为上/下对角形式，并返回矩阵 X 和 Y，
     用于将变换应用于 A 的未减少部分。

   注意：
     如果 m >= n，则 A 被减少为上对角形式；如果 m < n，则减少为下对角形式。
     这是由 DGEBRD 调用的辅助程序。
*/
/* Subroutine */ int dlabrd_(integer *m, integer *n, integer *nb, doublereal *
    a, integer *lda, doublereal *d__, doublereal *e, doublereal *tauq,
    doublereal *taup, doublereal *x, integer *ldx, doublereal *y, integer
    *ldy)
{



    /* System generated locals */
    integer a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2,
        i__3;


    /* 系统生成的本地变量声明 */
    integer a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2,
        i__3;



    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dgemv_(char *, integer *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *), dlarfg_(integer *, doublereal *,
         doublereal *, integer *, doublereal *);


    /* 本地变量 */
    static integer i__;
    // 外部子程序声明
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dgemv_(char *, integer *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *), dlarfg_(integer *, doublereal *,
         doublereal *, integer *, doublereal *);



/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLABRD reduces the first NB rows and columns of a real general
    m by n matrix A to upper or lower bidiagonal form by an orthogonal
    transformation Q' * A * P, and returns the matrices X and Y which
    are needed to apply the transformation to the unreduced part of A.

    If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
    bidiagonal form.

    This is an auxiliary routine called by DGEBRD

    Arguments
    =========

    M       (input) INTEGER
            The number of rows in the matrix A.

    N       (input) INTEGER
            The number of columns in the matrix A.

    NB      (input) INTEGER
            The number of leading rows and columns of A to be reduced.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the orthogonal matrix P as a product
              of elementary reflectors.
            If m < n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.



/*
    -- LAPACK 辅助例程（版本 3.2）--
    -- LAPACK 是由 Univ. of Tennessee，Univ. of California Berkeley，
       Univ. of Colorado Denver 和 NAG Ltd. 提供的软件包。
       2006 年 11 月

    用途
    =======

    DLABRD 通过正交变换 Q' * A * P 将实一般 m×n 矩阵 A 的前 NB 行和列减少为上/下对角形式，
    并返回用于将变换应用于 A 的未减少部分的矩阵 X 和 Y。

    如果 m >= n，则 A 被减少为上对角形式；如果 m < n，则减少为下对角形式。

    这是由 DGEBRD 调用的辅助例程。

    参数
    =========

    M       (输入) INTEGER
            矩阵 A 的行数。

    N       (输入) INTEGER
            矩阵 A 的列数。

    NB      (输入) INTEGER
            要减少的 A 矩阵的前导行和列数。

    A       (输入/输出) DOUBLE PRECISION 数组，维度为 (LDA,N)
            在输入时，要减少的 m×n 一般矩阵。
            在输出时，矩阵的前 NB 行和列被覆盖；数组的其余部分保持不变。
            如果 m >= n，则数组 TAUQ 中第一个 NB 列中的对角线及其以下元素表示正交矩阵 Q，
              这些元素是初等反射因子的乘积；
              数组 TAUP 中第一个 NB 行中对角线之上的元素表示正交矩阵 P，
              这些元素是初等反射因子的乘积。
            如果 m < n，则数组 TAUQ 中第一个 NB 列中对角线以下的元素表示正交矩阵 Q，
              这些元素是初等反射因
    # 输入参数，矩阵 A 的前 NB 行和列的维度
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    # 输出参数，矩阵 A 的前 NB 行和列的对角线元素
    D       (output) DOUBLE PRECISION array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).

    # 输出参数，矩阵 A 的前 NB 行和列的非对角线元素
    E       (output) DOUBLE PRECISION array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.

    # 输出参数，Q 矩阵的标量因子，表示正交矩阵 Q 的基本反射器
    TAUQ    (output) DOUBLE PRECISION array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.

    # 输出参数，P 矩阵的标量因子，表示正交矩阵 P 的基本反射器
    TAUP    (output) DOUBLE PRECISION array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.

    # 输出参数，用于更新 A 未约化部分的 m-by-nb 矩阵 X
    X       (output) DOUBLE PRECISION array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.

    # 输入参数，矩阵 X 的维度
    LDX     (input) INTEGER
            The leading dimension of the array X. LDX >= M.

    # 输出参数，用于更新 A 未约化部分的 n-by-nb 矩阵 Y
    Y       (output) DOUBLE PRECISION array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.

    # 输入参数，矩阵 Y 的维度
    LDY     (input) INTEGER
            The leading dimension of the array Y. LDY >= N.

    # 进一步细节
    # ===============

    # 矩阵 Q 和 P 表示为基本反射器的乘积
    The matrices Q and P are represented as products of elementary
    reflectors:

       Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)

    # 每个 H(i) 和 G(i) 的形式
    Each H(i) and G(i) has the form:

       H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

    # 其中 tauq 和 taup 是实数标量，v 和 u 是实向量
    where tauq and taup are real scalars, and v and u are real vectors.

    # 如果 m >= n，v(1:i-1) = 0, v(i) = 1，并且 v(i:m) 在退出时存储在 A(i:m,i) 中
    If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
    A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    # 如果 m < n，v(1:i) = 0, v(i+1) = 1，并且 v(i+1:m) 在退出时存储在 A(i+2:m,i) 中
    If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
    A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
    A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

    # 向量 v 和 u 的元素共同形成 m-by-nb 矩阵 V 和 nb-by-n 矩阵 U'
    The elements of the vectors v and u together form the m-by-nb matrix
    V and the nb-by-n matrix U' which are needed, with X and Y, to apply
    the transformation to the unreduced part of the matrix, using a block
    update of the form:  A := A - V*Y' - X*U'.

    # A 在退出时的内容通过以下示例说明，其中 nb = 2:

    # 当 m = 6 且 n = 5 (m > n):
    m = 6 and n = 5 (m > n):
      (  1   1   u1  u1  u1 )
      (  v1  1   1   u2  u2 )
      (  v1  v2  a   a   a  )
      (  v1  v2  a   a   a  )
      (  v1  v2  a   a   a  )
      (  v1  v2  a   a   a  )

    # 当 m = 5 且 n = 6 (m < n):
    m = 5 and n = 6 (m < n):
      (  1   u1  u1  u1  u1  u1 )
      (  v1  1   a   a   a   a  )
      (  1   1   u2  u2  u2  u2 )
      (  v2  1   a   a   a   a  )
      (  v2  v1  a   a   a   a  )
    vi denotes an element of the vector defining H(i), and ui an element
    of the vector defining G(i).
    # vi 表示定义 H(i) 的向量的一个元素，ui 表示定义 G(i) 的向量的一个元素。

    =====================================================================


       Quick return if possible
    # 如果可能的话，快速返回
    /* 调整参数 */
    a_dim1 = *lda;                      /* 获取参数 lda 的值并赋给 a_dim1 */
    a_offset = 1 + a_dim1;              /* 计算偏移量 a_offset */
    a -= a_offset;                      /* 调整数组 a 的指针位置 */
    --d__;                              /* 将指针 d__ 向前移动一个位置 */
    --e;                                /* 将指针 e 向前移动一个位置 */
    --tauq;                             /* 将指针 tauq 向前移动一个位置 */
    --taup;                             /* 将指针 taup 向前移动一个位置 */
    x_dim1 = *ldx;                      /* 获取参数 ldx 的值并赋给 x_dim1 */
    x_offset = 1 + x_dim1;              /* 计算偏移量 x_offset */
    x -= x_offset;                      /* 调整数组 x 的指针位置 */
    y_dim1 = *ldy;                      /* 获取参数 ldy 的值并赋给 y_dim1 */
    y_offset = 1 + y_dim1;              /* 计算偏移量 y_offset */
    y -= y_offset;                      /* 调整数组 y 的指针位置 */

    /* 函数体 */
    if (*m <= 0 || *n <= 0) {           /* 如果 m 或 n 小于等于 0，返回 0 */
        return 0;
    }

    if (*m >= *n) {                     /* 如果 m 大于等于 n，则进行下列操作 */

/*        将 A 矩阵约化为上角双对角形式 */

        i__1 = *nb;                     /* 循环次数为 nb */
        for (i__ = 1; i__ <= i__1; ++i__) {

/*           更新 A(i:m,i) */

            i__2 = *m - i__ + 1;        /* 计算行数 */
            i__3 = i__ - 1;             /* 计算列数 */
            dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + a_dim1],
                lda, &y[i__ + y_dim1], ldy, &c_b15, &a[i__ + i__ * a_dim1]
                , &c__1);
            i__2 = *m - i__ + 1;        /* 计算行数 */
            i__3 = i__ - 1;             /* 计算列数 */
            dgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + x_dim1],
                ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b15, &a[i__ + i__ *
                a_dim1], &c__1);

/*           生成反射 Q(i)，将 A(i+1:m,i) 变为零 */

            i__2 = *m - i__ + 1;        /* 计算行数 */
            /* 计算下界，不能超过 m */
            i__3 = i__ + 1;
            dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[min(i__3,*m) + i__ *
                a_dim1], &c__1, &tauq[i__]);
            d__[i__] = a[i__ + i__ * a_dim1];
            if (i__ < *n) {
                a[i__ + i__ * a_dim1] = 1.;

/*              计算 Y(i+1:n,i) */

                i__2 = *m - i__ + 1;    /* 计算行数 */
                i__3 = *n - i__;        /* 计算列数 */
                dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + (i__ + 1) *
                     a_dim1], lda, &a[i__ + i__ * a_dim1], &c__1, &c_b29,
                    &y[i__ + 1 + i__ * y_dim1], &c__1);
                i__2 = *m - i__ + 1;    /* 计算行数 */
                i__3 = i__ - 1;         /* 计算列数 */
                dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + a_dim1],
                    lda, &a[i__ + i__ * a_dim1], &c__1, &c_b29, &y[i__ *
                    y_dim1 + 1], &c__1);
                i__2 = *n - i__;        /* 计算列数 */
                i__3 = i__ - 1;         /* 计算行数 */
                dgemv_("No transpose", &i__2, &i__3, &c_b151, &y[i__ + 1 +
                    y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b15, &y[
                    i__ + 1 + i__ * y_dim1], &c__1);
                i__2 = *m - i__ + 1;    /* 计算行数 */
                i__3 = i__ - 1;         /* 计算列数 */
                dgemv_("Transpose", &i__2, &i__3, &c_b15, &x[i__ + x_dim1],
                    ldx, &a[i__ + i__ * a_dim1], &c__1, &c_b29, &y[i__ *
                    y_dim1 + 1], &c__1);
                i__2 = i__ - 1;         /* 计算行数 */
                i__3 = *n - i__;        /* 计算列数 */
                dgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1) *
                    a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &c_b15,
                     &y[i__ + 1 + i__ * y_dim1], &c__1);
                i__2 = *n - i__;        /* 计算列数 */
                dscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
            }
/*              Update A(i,i+1:n) */

/* 计算需要更新的列数 */
i__2 = *n - i__;

/* 执行矩阵向量乘法，将结果累加到A的指定部分 */
dgemv_("No transpose", &i__2, &i__, &c_b151, &y[i__ + 1 +
    y_dim1], ldy, &a[i__ + a_dim1], lda, &c_b15, &a[i__ +
    (i__ + 1) * a_dim1], lda);

/* 计算需要更新的行数 */
i__2 = i__ - 1;
/* 计算需要更新的列数 */
i__3 = *n - i__;

/* 执行矩阵向量乘法，将结果累加到A的指定部分 */
dgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1) *
    a_dim1 + 1], lda, &x[i__ + x_dim1], ldx, &c_b15, &a[
    i__ + (i__ + 1) * a_dim1], lda);

/*              Generate reflection P(i) to annihilate A(i,i+2:n) */

/* 计算需要生成反射向量的长度 */
i__2 = *n - i__;
/* 计算i+2和n中的较小值 */
/* Computing MIN */
i__3 = i__ + 2;

/* 生成反射向量P(i)，使得A(i,i+2:n)部分被置零 */
dlarfg_(&i__2, &a[i__ + (i__ + 1) * a_dim1], &a[i__ + min(
    i__3,*n) * a_dim1], lda, &taup[i__]);

/* 将生成的反射系数保存到e数组中 */
e[i__] = a[i__ + (i__ + 1) * a_dim1];
/* 将A(i,i+1)置为1 */
a[i__ + (i__ + 1) * a_dim1] = 1.;

/*              Compute X(i+1:m,i) */

/* 计算需要计算的行数 */
i__2 = *m - i__;
/* 计算需要计算的列数 */
i__3 = *n - i__;

/* 执行矩阵向量乘法，将结果累加到X的指定部分 */
dgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + (
    i__ + 1) * a_dim1], lda, &a[i__ + (i__ + 1) * a_dim1],
     lda, &c_b29, &x[i__ + 1 + i__ * x_dim1], &c__1);

/* 计算需要计算的列数 */
i__2 = *n - i__;

/* 执行矩阵向量乘法，将结果累加到X的指定部分 */
dgemv_("Transpose", &i__2, &i__, &c_b15, &y[i__ + 1 + y_dim1],
     ldy, &a[i__ + (i__ + 1) * a_dim1], lda, &c_b29, &x[
    i__ * x_dim1 + 1], &c__1);

/* 计算需要计算的行数 */
i__2 = *m - i__;
/* 计算需要计算的列数 */
i__3 = i__ - 1;

/* 执行矩阵向量乘法，将结果累加到X的指定部分 */
dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
    a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
    i__ + 1 + i__ * x_dim1], &c__1);

/* 计算需要计算的行数 */
i__2 = i__ - 1;
/* 计算需要计算的列数 */
i__3 = *n - i__;

/* 执行矩阵向量乘法，将结果累加到X的指定部分 */
dgemv_("No transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
    a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
    c_b29, &x[i__ * x_dim1 + 1], &c__1);

/* 计算需要计算的行数 */
i__2 = *m - i__;
/* 计算需要计算的列数 */
i__3 = i__ - 1;

/* 执行矩阵向量乘法，将结果累加到X的指定部分 */
dgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + 1 +
    x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
    i__ + 1 + i__ * x_dim1], &c__1);

/* 计算需要计算的行数 */
i__2 = *m - i__;

/* 对X的指定部分进行标量乘法 */
dscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);
/* Computing MIN */
/* 计算最小值 */
        i__3 = i__ + 1;  // 计算 i + 1
        // 计算向量之间的 Householder 变换，使得 a[i + i * a_dim1] 变为标量，
        // 并返回变换系数到 taup[i]
        dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + min(i__3,*n) *
            a_dim1], lda, &taup[i__]);
        // 将 a[i + i * a_dim1] 的值存储到 d__[i]
        d__[i__] = a[i__ + i__ * a_dim1];
        if (i__ < *m) {
        // 将 a[i + i * a_dim1] 设置为 1
        a[i__ + i__ * a_dim1] = 1.;

/*              Compute X(i+1:m,i) */
/*              计算 X(i+1:m, i) */

        i__2 = *m - i__;  // 计算 *m - i
        i__3 = *n - i__ + 1;  // 计算 *n - i + 1
        // 计算矩阵乘法：A 的第 i+1 行到第 *m 行与 A 的第 i 列的乘积，结果存储到 X 的第 i+1 行到第 *m 行
        dgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + i__
            * a_dim1], lda, &a[i__ + i__ * a_dim1], lda, &c_b29, &
            x[i__ + 1 + i__ * x_dim1], &c__1);
        i__2 = *n - i__ + 1;  // 计算 *n - i + 1
        i__3 = i__ - 1;  // 计算 i - 1
        // 计算矩阵乘法：Y 的第 i 行到第 *m 行与 A 的第 i 列的转置乘积，结果存储到 X 的第 i 行
        dgemv_("Transpose", &i__2, &i__3, &c_b15, &y[i__ + y_dim1],
            ldy, &a[i__ + i__ * a_dim1], lda, &c_b29, &x[i__ *
            x_dim1 + 1], &c__1);
        i__2 = *m - i__;  // 计算 *m - i
        i__3 = i__ - 1;  // 计算 i - 1
        // 计算矩阵乘法：A 的第 i+1 行到第 *m 行与 X 的第 i 行的乘积，结果存储到 X 的第 i+1 行到第 *m 行
        dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
        i__2 = i__ - 1;  // 计算 i - 1
        i__3 = *n - i__ + 1;  // 计算 *n - i + 1
        // 计算矩阵乘法：A 的第 1 行到第 i-1 行与 A 的第 i 列的乘积，结果存储到 X 的第 i 行
        dgemv_("No transpose", &i__2, &i__3, &c_b15, &a[i__ * a_dim1
            + 1], lda, &a[i__ + i__ * a_dim1], lda, &c_b29, &x[
            i__ * x_dim1 + 1], &c__1);
        i__2 = *m - i__;  // 计算 *m - i
        i__3 = i__ - 1;  // 计算 i - 1
        // 计算矩阵乘法：X 的第 i+1 行到第 *m 行与 X 的第 i 行的乘积，结果存储到 X 的第 i+1 行到第 *m 行
        dgemv_("No transpose", &i__2, &i__3, &c_b151, &x[i__ + 1 +
            x_dim1], ldx, &x[i__ * x_dim1 + 1], &c__1, &c_b15, &x[
            i__ + 1 + i__ * x_dim1], &c__1);
        i__2 = *m - i__;  // 计算 *m - i
        // 将 X 的第 i+1 行到第 *m 行乘以 taup[i]，结果覆盖原来的值
        dscal_(&i__2, &taup[i__], &x[i__ + 1 + i__ * x_dim1], &c__1);

/*              Update A(i+1:m,i) */
/*              更新 A(i+1:m, i) */

        i__2 = *m - i__;  // 计算 *m - i
        i__3 = i__ - 1;  // 计算 i - 1
        // 计算矩阵乘法：A 的第 i+1 行到第 *m 行与 Y 的第 i 行到第 *m 行的乘积，结果覆盖 A 的第 i+1 行到第 *m 行
        dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[i__ + 1 +
            a_dim1], lda, &y[i__ + y_dim1], ldy, &c_b15, &a[i__ +
            1 + i__ * a_dim1], &c__1);
        i__2 = *m - i__;  // 计算 *m - i
        // 计算矩阵乘法：A 的第 i+1 行到第 *m 行与 X 的第 1 行到第 i 行的乘积，结果覆盖 A 的第 i+1 行到第 *m 行
        dgemv_("No transpose", &i__2, &i__, &c_b151, &x[i__ + 1 +
            x_dim1], ldx, &a[i__ * a_dim1 + 1], &c__1, &c_b15, &a[
            i__ + 1 + i__ * a_dim1], &c__1);

/*              Generate reflection Q(i) to annihilate A(i+2:m,i) */
/*              生成反射变换 Q(i)，使得 A(i+2:m, i) 被消除 */

        i__2 = *m - i__;  // 计算 *m - i
/* Computing MIN */
        i__3 = i__ + 2;  // 计算 i + 2
        // 计算向量之间的 Householder 变换，使得 a[i + 1 + i * a_dim1] 变为标量，
        // 并返回变换系数到 tauq[i]
        dlarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*m) +
            i__ * a_dim1], &c__1, &tauq[i__]);
        // 将 a[i + 1 + i * a_dim1] 的值存储到 e[i]
        e[i__] = a[i__ + 1 + i__ * a_dim1];
        // 将 a[i + 1 + i * a_dim1] 设置为 1
        a[i__ + 1 + i__ * a_dim1] = 1.;
/*              Compute Y(i+1:n,i) */

// 计算 Y(i+1:n,i) 的值

        i__2 = *m - i__;
        i__3 = *n - i__;
        // 调用 BLAS 库中的 DGEMV 函数，计算 Y(i+1:n,i)
        dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + (i__ +
            1) * a_dim1], lda, &a[i__ + 1 + i__ * a_dim1], &c__1,
            &c_b29, &y[i__ + 1 + i__ * y_dim1], &c__1);
        i__2 = *m - i__;
        i__3 = i__ - 1;
        // 调用 BLAS 库中的 DGEMV 函数，计算 Y(1:i-1,i)
        dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + a_dim1]
            , lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &y[
            i__ * y_dim1 + 1], &c__1);
        i__2 = *n - i__;
        i__3 = i__ - 1;
        // 调用 BLAS 库中的 DGEMV 函数，计算 Y(i+1:n,i) 的另一部分
        dgemv_("No transpose", &i__2, &i__3, &c_b151, &y[i__ + 1 +
            y_dim1], ldy, &y[i__ * y_dim1 + 1], &c__1, &c_b15, &y[
            i__ + 1 + i__ * y_dim1], &c__1);
        i__2 = *m - i__;
        // 调用 BLAS 库中的 DGEMV 函数，计算 Y(1:i-1,i) 的另一部分
        dgemv_("Transpose", &i__2, &i__, &c_b15, &x[i__ + 1 + x_dim1],
             ldx, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &y[
            i__ * y_dim1 + 1], &c__1);
        i__2 = *n - i__;
        // 调用 BLAS 库中的 DGEMV 函数，计算 Y(i+1:n,i) 的另一部分
        dgemv_("Transpose", &i__, &i__2, &c_b151, &a[(i__ + 1) *
            a_dim1 + 1], lda, &y[i__ * y_dim1 + 1], &c__1, &c_b15,
             &y[i__ + 1 + i__ * y_dim1], &c__1);
        i__2 = *n - i__;
        // 调用 BLAS 库中的 DSCAL 函数，对 Y(i+1:n,i) 进行标量乘法
        dscal_(&i__2, &tauq[i__], &y[i__ + 1 + i__ * y_dim1], &c__1);
        }
/* L20: */
    }
    }
    // 返回 0，标识函数执行完毕

/*     End of DLABRD */

} /* dlabrd_ */

/* Subroutine */ int dlacpy_(char *uplo, integer *m, integer *n, doublereal *
    a, integer *lda, doublereal *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    // 外部函数 lsame_ 的声明

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLACPY copies all or part of a two-dimensional matrix A to another
    matrix B.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (output) DOUBLE PRECISION array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).

*/
    # 定义一个类，表示一个学生对象
    class Student:
        # 类变量，用于统计学生数量
        count = 0
    
        # 初始化方法，用于创建新的学生对象
        def __init__(self, name, age):
            # 实例变量，存储学生的姓名
            self.name = name
            # 实例变量，存储学生的年龄
            self.age = age
            # 类变量，每次创建对象时，数量加一
            Student.count += 1
    
        # 实例方法，用于显示学生的信息
        def display_student(self):
            # 打印学生的姓名和年龄
            print("Name:", self.name, ", Age:", self.age)
    
    # 创建学生对象示例
    student1 = Student("Alice", 20)
    student2 = Student("Bob", 21)
    
    # 调用实例方法显示学生信息
    student1.display_student()
    student2.display_student()
    
    # 打印总学生数量
    print("Total students:", Student.count)
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    if (lsame_(uplo, "U")) {
    i__1 = *n;
    // 循环遍历每一列
    for (j = 1; j <= i__1; ++j) {
        // 限制内层循环次数，以较小的值为准
        i__2 = min(j,*m);
        // 循环遍历每一行，将上三角矩阵的值复制到下三角矩阵
        for (i__ = 1; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L10: */
        }
/* L20: */
    }
    } else if (lsame_(uplo, "L")) {
    i__1 = *n;
    // 循环遍历每一列
    for (j = 1; j <= i__1; ++j) {
        // 从当前列开始直到末尾的行数
        i__2 = *m;
        // 循环遍历每一行，将下三角矩阵的值复制到上三角矩阵
        for (i__ = j; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L30: */
        }
/* L40: */
    }
    } else {
    i__1 = *n;
    // 循环遍历每一列
    for (j = 1; j <= i__1; ++j) {
        // 循环遍历每一行，将整个矩阵的值复制到另一个矩阵
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
        b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L50: */
        }
/* L60: */
    }
    }
    return 0;

/*     End of DLACPY */

} /* dlacpy_ */

/* Subroutine */ int dladiv_(doublereal *a, doublereal *b, doublereal *c__,
    doublereal *d__, doublereal *p, doublereal *q)
{
    static doublereal e, f;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLADIV performs complex division in  real arithmetic

                          a + i*b
               p + i*q = ---------
                          c + i*d

    The algorithm is due to Robert L. Smith and can be found
    in D. Knuth, The art of Computer Programming, Vol.2, p.195

    Arguments
    =========

    A       (input) DOUBLE PRECISION
    B       (input) DOUBLE PRECISION
    C       (input) DOUBLE PRECISION
    D       (input) DOUBLE PRECISION
            The scalars a, b, c, and d in the above expression.

    P       (output) DOUBLE PRECISION
    Q       (output) DOUBLE PRECISION
            The scalars p and q in the above expression.

    =====================================================================
*/


    if (abs(*d__) < abs(*c__)) {
    // 计算比值 e 和 f
    e = *d__ / *c__;
    f = *c__ + *d__ * e;
    // 计算复数除法结果的实部和虚部
    *p = (*a + *b * e) / f;
    *q = (*b - *a * e) / f;
    } else {
    // 计算比值 e 和 f
    e = *c__ / *d__;
    f = *d__ + *c__ * e;
    // 计算复数除法结果的实部和虚部
    *p = (*b + *a * e) / f;
    *q = (-(*a) + *b * e) / f;
    }

    return 0;

/*     End of DLADIV */

} /* dladiv_ */

/* Subroutine */ int dlae2_(doublereal *a, doublereal *b, doublereal *c__,
    doublereal *rt1, doublereal *rt2)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    static doublereal ab, df, tb, sm, rt, adf, acmn, acmx;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    # 计算一个 2x2 对称矩阵的特征值
       [  A   B  ]
       [  B   C  ].
    # 返回时，RT1 是绝对值较大的特征值，RT2 是绝对值较小的特征值。

    # 参数说明
    # ========

    A       (input) DOUBLE PRECISION
            2x2 矩阵的元素 (1,1)。

    B       (input) DOUBLE PRECISION
            2x2 矩阵的元素 (1,2) 和 (2,1)。

    C       (input) DOUBLE PRECISION
            2x2 矩阵的元素 (2,2)。

    RT1     (output) DOUBLE PRECISION
            绝对值较大的特征值。

    RT2     (output) DOUBLE PRECISION
            绝对值较小的特征值。

    # 进一步细节
    # ===============

    # RT1 在几个 ulp（最后一位单位）内是准确的，除非出现溢出或下溢。

    # 如果行列式 A*C-B*B 存在大量抵消，RT2 可能不准确；
    # 在所有情况下，需要更高精度、正确舍入或截断的算术才能准确计算 RT2。

    # 只有当 RT1 接近溢出的五倍时才可能发生溢出。
    # 如果输入数据为 0 或超出下溢阈值 / macheps，则下溢是无害的。
   =====================================================================


       计算特征值
/*

    sm = *a + *c__;
    // 计算两个指针所指向的值的和
    df = *a - *c__;
    // 计算两个指针所指向的值的差
    adf = abs(df);
    // 计算差值的绝对值
    tb = *b + *b;
    // 将指针指向的值乘以2
    ab = abs(tb);
    // 计算乘以2的值的绝对值
    if (abs(*a) > abs(*c__)) {
    // 如果a的绝对值大于c的绝对值
    acmx = *a;
    // a为最大的值
    th even man Res man Who Can Contains S Bible Story For of ש do much more But
    # 定义静态整型变量 igivnm, submat, curprb, subpbs, igivpt
    static integer igivnm, submat, curprb, subpbs, igivpt;
    # 声明外部子程序 dsteqr_
    extern /* Subroutine */ int dsteqr_(char *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);
    # 定义静态整型变量 curlvl, matsiz, iprmpt, smlsiz
    static integer curlvl, matsiz, iprmpt, smlsiz;
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======
DLAED0 computes all eigenvalues and corresponding eigenvectors of a
symmetric tridiagonal matrix using the divide and conquer method.

Arguments
=========
ICOMPQ  (input) INTEGER
        = 0:  Compute eigenvalues only.
        = 1:  Compute eigenvectors of original dense symmetric matrix
              also.  On entry, Q contains the orthogonal matrix used
              to reduce the original matrix to tridiagonal form.
        = 2:  Compute eigenvalues and eigenvectors of tridiagonal
              matrix.

QSIZ   (input) INTEGER
       The dimension of the orthogonal matrix used to reduce
       the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.

N      (input) INTEGER
       The dimension of the symmetric tridiagonal matrix.  N >= 0.

D      (input/output) DOUBLE PRECISION array, dimension (N)
       On entry, the main diagonal of the tridiagonal matrix.
       On exit, its eigenvalues.

E      (input) DOUBLE PRECISION array, dimension (N-1)
       The off-diagonal elements of the tridiagonal matrix.
       On exit, E has been destroyed.

Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
       On entry, Q must contain an N-by-N orthogonal matrix.
       If ICOMPQ = 0    Q is not referenced.
       If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                        orthogonal matrix used to reduce the full
                        matrix to tridiagonal form corresponding to
                        the subset of the full matrix which is being
                        decomposed at this time.
       If ICOMPQ = 2    On entry, Q will be the identity matrix.
                        On exit, Q contains the eigenvectors of the
                        tridiagonal matrix.

LDQ    (input) INTEGER
       The leading dimension of the array Q.  If eigenvectors are
       desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.

QSTORE (workspace) DOUBLE PRECISION array, dimension (LDQS, N)
       Referenced only when ICOMPQ = 1.  Used to store parts of
       the eigenvector matrix when the updating matrix multiplies
       take place.

LDQS   (input) INTEGER
       The leading dimension of the array QSTORE.  If ICOMPQ = 1,
       then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
"""
    # 工作空间，用于存储算法计算中间结果的双精度数组
    WORK   (workspace) DOUBLE PRECISION array,
           如果 ICOMPQ = 0 或 1，WORK 的维度至少应为
                       1 + 3*N + 2*N*lg N + 2*N**2
                       （这里 lg( N ) 是使得 2^k >= N 的最小整数 k）
           如果 ICOMPQ = 2，WORK 的维度至少应为
                       4*N + N**2.

    # 工作空间，用于存储算法计算中间结果的整数数组
    IWORK  (workspace) INTEGER array,
           如果 ICOMPQ = 0 或 1，IWORK 的维度至少应为
                          6 + 6*N + 5*N*lg N.
                          （这里 lg( N ) 是使得 2^k >= N 的最小整数 k）
           如果 ICOMPQ = 2，IWORK 的维度至少应为
                          3 + 5*N.

    # 输出参数，整数，用于指示函数执行状态
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  如果 INFO = -i，表示第 i 个参数的值不合法。
            > 0:  算法在处理子矩阵时未能计算特征值，
                  该子矩阵位于行和列 INFO/(N+1) 到 mod(INFO,N+1) 之间。

    # 更多细节
    # 基于 Jeff Rutter 在加州大学伯克利分校的计算机科学系的贡献
    Further Details
    ===============

    =====================================================================


       测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;
    --e;
    q_dim1 = *ldq;  // Assign the first dimension of Q from its pointer
    q_offset = 1 + q_dim1;  // Compute the offset for Q
    q -= q_offset;  // Adjust Q to start at q_offset
    qstore_dim1 = *ldqs;  // Assign the first dimension of QSTORE from its pointer
    qstore_offset = 1 + qstore_dim1;  // Compute the offset for QSTORE
    qstore -= qstore_offset;  // Adjust QSTORE to start at qstore_offset
    --work;  // Decrement the pointer for WORK to adjust for 1-based indexing
    --iwork;  // Decrement the pointer for IWORK to adjust for 1-based indexing

    /* Function Body */
    *info = 0;  // Initialize INFO to 0

    if (*icompq < 0 || *icompq > 2) {  // Check if ICOMPQ is out of valid range
        *info = -1;  // Set INFO to -1 if ICOMPQ is invalid
    } else if (*icompq == 1 && *qsiz < max(0,*n)) {  // Check condition for ICOMPQ = 1
        *info = -2;  // Set INFO to -2 if QSIZ is less than max(0, *n)
    } else if (*n < 0) {  // Check if N is negative
        *info = -3;  // Set INFO to -3 if N is negative
    } else if (*ldq < max(1,*n)) {  // Check condition for the leading dimension of Q
        *info = -7;  // Set INFO to -7 if LDQ is less than max(1, *n)
    } else if (*ldqs < max(1,*n)) {  // Check condition for the leading dimension of QSTORE
        *info = -9;  // Set INFO to -9 if LDQS is less than max(1, *n)
    }
    if (*info != 0) {  // Check if INFO is non-zero
        i__1 = -(*info);  // Negate INFO for use in XERBLA
        xerbla_("DLAED0", &i__1);  // Call error handler XERBLA with the negated INFO
        return 0;  // Return 0 to exit the function
    }

/*     Quick return if possible */

    if (*n == 0) {  // Check if N is zero
        return 0;  // Return 0 to exit the function immediately
    }

    smlsiz = ilaenv_(&c__9, "DLAED0", " ", &c__0, &c__0, &c__0, &c__0, (ftnlen)6, (ftnlen)1);

/*
       Determine the size and placement of the submatrices, and save in
       the leading elements of IWORK.
*/

    iwork[1] = *n;  // Initialize the first element of IWORK to N
    subpbs = 1;  // Initialize SUBPBS to 1
    tlvls = 0;  // Initialize TLVLS to 0
L10:
    if (iwork[subpbs] > smlsiz) {  // Check if the current subproblem size is greater than SMLSIZ
        for (j = subpbs; j >= 1; --j) {  // Loop over current subproblems
            iwork[j * 2] = (iwork[j] + 1) / 2;  // Compute and store sizes of child subproblems
            iwork[(j << 1) - 1] = iwork[j] / 2;  // Compute and store sizes of child subproblems
/* L20: */  // Label for loop end
        }
        ++tlvls;  // Increment the number of levels in the divide and conquer tree
        subpbs <<= 1;  // Double the number of subproblems
        goto L10;  // Jump to check the size of the new subproblems
    }
    i__1 = subpbs;  // Set loop limit to SUBPBS
    for (j = 2; j <= i__1; ++j) {  // Loop over subproblems
        iwork[j] += iwork[j - 1];  // Compute cumulative sizes of submatrices
/* L30: */  // Label for loop end
    }

/*
       Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
       using rank-1 modifications (cuts).
*/

    spm1 = subpbs - 1;  // Compute SPm1 as SUBPBS - 1
    i__1 = spm1;  // Set loop limit to SPm1
    for (i__ = 1; i__ <= i__1; ++i__) {  // Loop over submatrices
        submat = iwork[i__] + 1;  // Determine starting index of current submatrix
        smm1 = submat - 1;  // Compute index of previous element
        d__[smm1] -= (d__1 = e[smm1], abs(d__1));  // Update diagonal element
        d__[submat] -= (d__1 = e[smm1], abs(d__1));  // Update diagonal element
/* L40: */  // Label for loop end
    }

    indxq = (*n << 2) + 3;  // Compute INDXQ
    if (*icompq != 2) {  // Check if ICOMPQ is not 2

/*
          Set up workspaces for eigenvalues only/accumulate new vectors
          routine
*/

    temp = log((doublereal) (*n)) / log(2.);  // Compute logarithm base 2 of N
    lgn = (integer) temp;  // Convert logarithm to integer
    if (pow_ii(&c__2, &lgn) < *n) {  // Check condition for power of 2
        ++lgn;  // Increment LGN if condition is met
    }
    if (pow_ii(&c__2, &lgn) < *n) {  // Check condition for power of 2
        ++lgn;  // Increment LGN if condition is met
    }
    iprmpt = indxq + *n + 1;  // Compute IPRMPT
    iperm = iprmpt + *n * lgn;  // Compute IPERM
    iqptr = iperm + *n * lgn;  // Compute IQPTR
    igivpt = iqptr + *n + 2;  // Compute IGIVPT
    igivcl = igivpt + *n * lgn;  // Compute IGIVCL

    igivnm = 1;  // Initialize IGIVNM
    iq = igivnm + (*n << 1) * lgn;  // Compute IQ
/* Computing 2nd power */  // Comment indicating power computation
    i__1 = *n;  // Square N
    iwrem = iq + i__1 * i__1 + 1;  // Compute IWREM

/*        Initialize pointers */

    i__1 = subpbs;  // Set loop limit to SUBPBS
    for (i__ = 0; i__ <= i__1; ++i__) {  // Loop over subproblems
        iwork[iprmpt + i__] = 1;  // Initialize IPRMPT indices
        iwork[igivpt + i__] = 1;  // Initialize IGIVPT indices
/* L50: */  // Label for loop end
    }
    iwork[iqptr] = 1;  // Initialize IQPTR
    }

/*
       Solve each submatrix eigenproblem at the bottom of the divide and
       conquer tree.
*/

    curr = 0;  // Initialize CURR
    i__1 = spm1;  // Set loop limit to SPm1
    for (i__ = 0; i__ <= i__1; ++i__) {  // Loop over submatrices
    if (i__ == 0) {  // Check if first iteration
        submat = 1;  // Set starting submatrix index
        matsiz = iwork[1];  // Set size of first submatrix
    } else {  // For subsequent iterations
        submat = iwork[i__] + 1;  // Determine starting index of current submatrix
        matsiz = iwork[i__ + 1] - iwork[i__];  // Compute size of current submatrix
    }
    // 检查 icompq 是否为 2
    if (*icompq == 2) {
        // 调用 LAPACK 库中的 dsteqr 函数，计算特征值和特征向量
        dsteqr_("I", &matsiz, &d__[submat], &e[submat], &q[submat +
            submat * q_dim1], ldq, &work[1], info);
        // 检查计算是否成功
        if (*info != 0) {
            // 若出错则跳转到标签 L130 处处理错误
            goto L130;
        }
    } else {
        // 若 icompq 不为 2，则调用 LAPACK 库中的 dsteqr 函数，计算特征值
        dsteqr_("I", &matsiz, &d__[submat], &e[submat], &work[iq - 1 +
            iwork[iqptr + curr]], &matsiz, &work[1], info);
        // 检查计算是否成功
        if (*info != 0) {
            // 若出错则跳转到标签 L130 处处理错误
            goto L130;
        }
        // 若 icompq 为 1，则进行矩阵乘法计算
        if (*icompq == 1) {
            // 调用 BLAS 库中的 dgemm 函数，计算矩阵乘法并将结果存储在 qstore 中
            dgemm_("N", "N", qsiz, &matsiz, &matsiz, &c_b15, &q[submat *
                q_dim1 + 1], ldq, &work[iq - 1 + iwork[iqptr + curr]],
                 &matsiz, &c_b29, &qstore[submat * qstore_dim1 + 1],
                ldqs);
        }
    }
/* 计算第二次幂 */
        i__2 = matsiz;
        iwork[iqptr + curr + 1] = iwork[iqptr + curr] + i__2 * i__2;
        ++curr;
    }
    k = 1;
    i__2 = iwork[i__ + 1];
    for (j = submat; j <= i__2; ++j) {
        iwork[indxq + j] = k;
        ++k;
/* L60: */
    }
/* L70: */
    }

/*
       逐步合并相邻子矩阵的特征系统
       到相应较大矩阵的特征系统。

       while ( SUBPBS > 1 )
*/

    curlvl = 1;
L80:
    if (subpbs > 1) {
    spm2 = subpbs - 2;
    i__1 = spm2;
    for (i__ = 0; i__ <= i__1; i__ += 2) {
        if (i__ == 0) {
        submat = 1;
        matsiz = iwork[2];
        msd2 = iwork[1];
        curprb = 0;
        } else {
        submat = iwork[i__] + 1;
        matsiz = iwork[i__ + 2] - iwork[i__];
        msd2 = matsiz / 2;
        ++curprb;
        }

/*
       合并低阶特征系统（大小为 MSD2 和 MATSIZ - MSD2）
       到大小为 MATSIZ 的特征系统。
       DLAED1 仅用于三对角矩阵的完整特征系统。
       DLAED7 处理仅需要特征值或特征值和特征向量的完整对称矩阵
       （已化为三对角形式）的情况。
*/

        if (*icompq == 2) {
        dlaed1_(&matsiz, &d__[submat], &q[submat + submat * q_dim1],
            ldq, &iwork[indxq + submat], &e[submat + msd2 - 1], &
            msd2, &work[1], &iwork[subpbs + 1], info);
        } else {
        dlaed7_(icompq, &matsiz, qsiz, &tlvls, &curlvl, &curprb, &d__[
            submat], &qstore[submat * qstore_dim1 + 1], ldqs, &
            iwork[indxq + submat], &e[submat + msd2 - 1], &msd2, &
            work[iq], &iwork[iqptr], &iwork[iprmpt], &iwork[iperm]
            , &iwork[igivpt], &iwork[igivcl], &work[igivnm], &
            work[iwrem], &iwork[subpbs + 1], info);
        }
        if (*info != 0) {
        goto L130;
        }
        iwork[i__ / 2 + 1] = iwork[i__ + 2];
/* L90: */
    }
    subpbs /= 2;
    ++curlvl;
    goto L80;
    }

/*
       结束 while

       重新合并在最终合并步骤中被消除的特征值/向量。
*/

    if (*icompq == 1) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
        dcopy_(qsiz, &qstore[j * qstore_dim1 + 1], &c__1, &q[i__ * q_dim1
            + 1], &c__1);
/* L100: */
    }
    dcopy_(n, &work[1], &c__1, &d__[1], &c__1);
    } else if (*icompq == 2) {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
        dcopy_(n, &q[j * q_dim1 + 1], &c__1, &work[*n * i__ + 1], &c__1);
/* L110: */
    }
    dcopy_(n, &work[1], &c__1, &d__[1], &c__1);
    dlacpy_("A", n, n, &work[*n + 1], n, &q[q_offset], ldq);
    } else {
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        j = iwork[indxq + i__];
        work[i__] = d__[j];
/* L120: */
    }
    dcopy_(n, &work[1], &c__1, &d__[1], &c__1);
    }
    // 跳转到标签 L140 处执行代码
    goto L140;
/* 将指针 *info 设置为 submat * (*n + 1) + submat + matsiz - 1 的值 */
*info = submat * (*n + 1) + submat + matsiz - 1;

/* 返回 0，表示成功执行 */
return 0;

/*     End of DLAED0 */

} /* dlaed0_ */

/* Subroutine */ int dlaed1_(integer *n, doublereal *d__, doublereal *q,
    integer *ldq, integer *indxq, doublereal *rho, integer *cutpnt,
    doublereal *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;

    /* Local variables */
    static integer i__, k, n1, n2, is, iw, iz, iq2, zpp1, indx, indxc;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer indxp;
    extern /* Subroutine */ int dlaed2_(integer *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         integer *, integer *, integer *, integer *), dlaed3_(integer *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, doublereal *, doublereal *, integer *, integer *,
        doublereal *, doublereal *, integer *);
    static integer idlmda;
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *), xerbla_(char *, integer *);
    static integer coltyp;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAED1 computes the updated eigensystem of a diagonal
    matrix after modification by a rank-one symmetric matrix.  This
    routine is used only for the eigenproblem which requires all
    eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
    the case in which eigenvalues only or eigenvalues and eigenvectors
    of a full symmetric matrix (which was reduced to tridiagonal form)
*/
    # 根据 LAPACK 文档中的描述，修正对称三对角矩阵的特征值和特征向量。
    # 在输入和输出中，Q 是矩阵的特征向量，D 是特征值，由于函数会修改它们，因此标记为输入/输出。
    def dlaed0(N, D, Q, LDQ, INDXQ, RHO, CUTPNT, WORK, IWORK, INFO):
        # 没有具体的代码实现，只是函数的头部和文档说明。
        pass
    # 代码开头的注释，标明此部分由弗朗索瓦·蒂瑟尔（Francoise Tisseur）修改，来自田纳西大学（University of Tennessee）。

    # 分隔线，可能用于标记代码的不同部分或功能模块。
    /* Parameter adjustments */
    --d__;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --indxq;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;  /* 初始化 info 为 0 */

    if (*n < 0) {  /* 如果 n 小于 0 */
        *info = -1;  /* 设置 info 为 -1 */
    } else if (*ldq < max(1,*n)) {  /* 如果 ldq 小于 max(1, n) */
        *info = -4;  /* 设置 info 为 -4 */
    } else /* if(complicated condition) */ {
        /* 计算 MIN */
        i__1 = 1, i__2 = *n / 2;
        if (min(i__1,i__2) > *cutpnt || *n / 2 < *cutpnt) {  /* 如果满足条件 */
            *info = -7;  /* 设置 info 为 -7 */
        }
    }
    if (*info != 0) {  /* 如果 info 不等于 0 */
        i__1 = -(*info);
        xerbla_("DLAED1", &i__1);  /* 调用错误处理函数 xerbla_ */
        return 0;  /* 返回 0 */
    }

/*     Quick return if possible */

    if (*n == 0) {  /* 如果 n 等于 0 */
        return 0;  /* 直接返回 0 */
    }

/*
       The following values are integer pointers which indicate
       the portion of the workspace
       used by a particular array in DLAED2 and DLAED3.
*/

    iz = 1;  /* 设置 iz 的起始位置 */
    idlmda = iz + *n;  /* 设置 idlmda 的起始位置 */
    iw = idlmda + *n;  /* 设置 iw 的起始位置 */
    iq2 = iw + *n;  /* 设置 iq2 的起始位置 */

    indx = 1;  /* 设置 indx 的起始位置 */
    indxc = indx + *n;  /* 设置 indxc 的起始位置 */
    coltyp = indxc + *n;  /* 设置 coltyp 的起始位置 */
    indxp = coltyp + *n;  /* 设置 indxp 的起始位置 */


/*
       Form the z-vector which consists of the last row of Q_1 and the
       first row of Q_2.
*/

    dcopy_(cutpnt, &q[*cutpnt + q_dim1], ldq, &work[iz], &c__1);  /* 复制 Q 的部分行到 work 数组 */
    zpp1 = *cutpnt + 1;  /* 设置 zpp1 的值 */
    i__1 = *n - *cutpnt;
    dcopy_(&i__1, &q[zpp1 + zpp1 * q_dim1], ldq, &work[iz + *cutpnt], &c__1);  /* 复制 Q 的部分行到 work 数组 */

/*     Deflate eigenvalues. */

    dlaed2_(&k, n, cutpnt, &d__[1], &q[q_offset], ldq, &indxq[1], rho, &work[
        iz], &work[idlmda], &work[iw], &work[iq2], &iwork[indx], &iwork[
        indxc], &iwork[indxp], &iwork[coltyp], info);  /* 调用 dlaed2_ 函数处理特征值问题 */

    if (*info != 0) {  /* 如果 info 不等于 0 */
        goto L20;  /* 跳转到标签 L20 处 */
    }

/*     Solve Secular Equation. */

    if (k != 0) {  /* 如果 k 不等于 0 */
        is = (iwork[coltyp] + iwork[coltyp + 1]) * *cutpnt + (iwork[coltyp +
            1] + iwork[coltyp + 2]) * (*n - *cutpnt) + iq2;  /* 计算 is 的值 */
        dlaed3_(&k, n, cutpnt, &d__[1], &q[q_offset], ldq, rho, &work[idlmda],
             &work[iq2], &iwork[indxc], &iwork[coltyp], &work[iw], &work[
            is], info);  /* 调用 dlaed3_ 函数解决特征值问题 */
        if (*info != 0) {  /* 如果 info 不等于 0 */
            goto L20;  /* 跳转到标签 L20 处 */
        }
    }

/*     Prepare the INDXQ sorting permutation. */

    n1 = k;  /* 设置 n1 的值为 k */
    n2 = *n - k;  /* 设置 n2 的值为 n - k */
    dlamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &indxq[1]);  /* 调用 dlamrg_ 函数排序 indxq 数组 */

    goto L20;  /* 跳转到标签 L20 处 */

    return 0;

/*     End of DLAED1 */

} /* dlaed1_ */

/* Subroutine */ int dlaed2_(integer *k, integer *n, integer *n1, doublereal *
    d__, doublereal *q, integer *ldq, integer *indxq, doublereal *rho,
    doublereal *z__, doublereal *dlamda, doublereal *w, doublereal *q2,
    integer *indx, integer *indxc, integer *indxp, integer *coltyp,
    integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    static doublereal c__;
    static integer i__, j;
    static doublereal s, t;
    static integer k2, n2, ct, nj, pj, js, iq1, iq2, n1p1;
    static doublereal eps, tau, tol;
    static integer psm[4], imax, jmax;
    # 声明一个外部子程序 drot_，它的参数包括整数、双精度实数数组和它们的长度
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);

    # 声明一个静态整数数组 ctot，长度为 4
    static integer ctot[4];

    # 声明一个外部子程序 dscal_，它的参数包括整数、双精度实数数组和长度
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);

    # 声明一个外部子程序 dcopy_，它的参数包括整数、双精度实数数组和长度
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);

    # 声明一个外部函数 idamax_，它的参数包括整数、双精度实数数组和长度，返回一个整数
    extern integer idamax_(integer *, doublereal *, integer *);

    # 声明一个外部子程序 dlamrg_，它的参数包括整数、整数数组、双精度实数数组和整数指针，无返回值
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *);

    # 声明一个外部子程序 dlacpy_，它的参数包括字符、整数、整数、双精度实数数组和整数指针，无返回值
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *);

    # 声明一个外部子程序 xerbla_，它的参数包括字符和整数指针，无返回值
    extern /* Subroutine */ int xerbla_(char *, integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAED2 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny entry in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    K      (output) INTEGER
           The number of non-deflated eigenvalues, and the order of the
           related secular equation. 0 <= K <=N.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    N1     (input) INTEGER
           The location of the last eigenvalue in the leading sub-matrix.
           min(1,N) <= N1 <= N/2.

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry, D contains the eigenvalues of the two submatrices to
           be combined.
           On exit, D contains the trailing (N-K) updated eigenvalues
           (those which were deflated) sorted into increasing order.

    Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
           On entry, Q contains the eigenvectors of two submatrices in
           the two square blocks with corners at (1,1), (N1,N1)
           and (N1+1, N1+1), (N,N).
           On exit, Q contains the trailing (N-K) updated eigenvectors
           (those which were deflated) in its last N-K columns.

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= max(1,N).

    INDXQ  (input/output) INTEGER array, dimension (N)
           The permutation which separately sorts the two sub-problems
           in D into ascending order.  Note that elements in the second
           half of this permutation must first have N1 added to their
           values. Destroyed on exit.

    RHO    (input/output) DOUBLE PRECISION
           On entry, the off-diagonal element associated with the rank-1
           cut which originally split the two submatrices which are now
           being recombined.
           On exit, RHO has been modified to the value required by
           DLAED3.

    Z      (input) DOUBLE PRECISION array, dimension (N)
           On entry, Z contains the updating vector (the last
           row of the first sub-eigenvector matrix and the first row of
           the second sub-eigenvector matrix).
           On exit, the contents of Z have been destroyed by the updating
           process.

    DLAMDA (output) DOUBLE PRECISION array, dimension (N)
           A copy of the first K eigenvalues which will be used by
           DLAED3 to form the secular equation.
*/

/*
   DLAED2 merges the two sets of eigenvalues together into a single
   sorted set. Then it tries to deflate the size of the problem.
   There are two ways in which deflation can occur: when two or more
   eigenvalues are close together or if there is a tiny entry in the
   Z vector. For each such occurrence the order of the related secular
   equation problem is reduced by one.
*/

/*
   Arguments
   =========
*/

/*
   K      (output) INTEGER
          The number of non-deflated eigenvalues, and the order of the
          related secular equation. 0 <= K <=N.
*/

/*
   N      (input) INTEGER
          The dimension of the symmetric tridiagonal matrix.  N >= 0.
*/

/*
   N1     (input) INTEGER
          The location of the last eigenvalue in the leading sub-matrix.
          min(1,N) <= N1 <= N/2.
*/

/*
   D      (input/output) DOUBLE PRECISION array, dimension (N)
          On entry, D contains the eigenvalues of the two submatrices to
          be combined.
          On exit, D contains the trailing (N-K) updated eigenvalues
          (those which were deflated) sorted into increasing order.
*/

/*
   Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
          On entry, Q contains the eigenvectors of two submatrices in
          the two square blocks with corners at (1,1), (N1,N1)
          and (N1+1, N1+1), (N,N).
          On exit, Q contains the trailing (N-K) updated eigenvectors
          (those which were deflated) in its last N-K columns.
*/

/*
   LDQ    (input) INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,N).
*/

/*
   INDXQ  (input/output) INTEGER array, dimension (N)
          The permutation which separately sorts the two sub-problems
          in D into ascending order.  Note that elements in the second
          half of this permutation must first have N1 added to their
          values. Destroyed on exit.
*/

/*
   RHO    (input/output) DOUBLE PRECISION
          On entry, the off-diagonal element associated with the rank-1
          cut which originally split the two submatrices which are now
          being recombined.
          On exit, RHO has been modified to the value required by
          DLAED3.
*/

/*
   Z      (input) DOUBLE PRECISION array, dimension (N)
          On entry, Z contains the updating vector (the last
          row of the first sub-eigenvector matrix and the first row of
          the second sub-eigenvector matrix).
          On exit, the contents of Z have been destroyed by the updating
          process.
*/

/*
   DLAMDA (output) DOUBLE PRECISION array, dimension (N)
          A copy of the first K eigenvalues which will be used by
          DLAED3 to form the secular equation.
*/
    ! W      (output) DOUBLE PRECISION array, dimension (N)
    !        The first k values of the final deflation-altered z-vector
    !        which will be passed to DLAED3.

    ! Q2     (output) DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
    !        A copy of the first K eigenvectors which will be used by
    !        DLAED3 in a matrix multiply (DGEMM) to solve for the new
    !        eigenvectors.

    ! INDX   (workspace) INTEGER array, dimension (N)
    !        The permutation used to sort the contents of DLAMDA into
    !        ascending order.

    ! INDXC  (output) INTEGER array, dimension (N)
    !        The permutation used to arrange the columns of the deflated
    !        Q matrix into three groups:  the first group contains non-zero
    !        elements only at and above N1, the second contains
    !        non-zero elements only below N1, and the third is dense.

    ! INDXP  (workspace) INTEGER array, dimension (N)
    !        The permutation used to place deflated values of D at the end
    !        of the array.  INDXP(1:K) points to the nondeflated D-values
    !        and INDXP(K+1:N) points to the deflated eigenvalues.

    ! COLTYP (workspace/output) INTEGER array, dimension (N)
    !        During execution, a label which will indicate which of the
    !        following types a column in the Q2 matrix is:
    !        1 : non-zero in the upper half only;
    !        2 : dense;
    !        3 : non-zero in the lower half only;
    !        4 : deflated.
    !        On exit, COLTYP(i) is the number of columns of type i,
    !        for i=1 to 4 only.

    ! INFO   (output) INTEGER
    !         = 0:  successful exit.
    !         < 0:  if INFO = -i, the i-th argument had an illegal value.

    ! Further Details
    ! ===============

    ! Based on contributions by
    !    Jeff Rutter, Computer Science Division, University of California
    !    at Berkeley, USA
    ! Modified by Francoise Tisseur, University of Tennessee.

    ! =====================================================================

       ! Test the input parameters.
    /* Parameter adjustments */
    --d__;              // 对数组 d__ 进行参数调整
    q_dim1 = *ldq;      // 设置 q_dim1 为 ldq
    q_offset = 1 + q_dim1;  // 计算 q 的偏移量
    q -= q_offset;      // 调整 q 的起始位置
    --indxq;            // 对数组 indxq 进行参数调整
    --z__;              // 对数组 z__ 进行参数调整
    --dlamda;           // 对数组 dlamda 进行参数调整
    --w;                // 对数组 w 进行参数调整
    --q2;               // 对数组 q2 进行参数调整
    --indx;             // 对数组 indx 进行参数调整
    --indxc;            // 对数组 indxc 进行参数调整
    --indxp;            // 对数组 indxp 进行参数调整
    --coltyp;           // 对数组 coltyp 进行参数调整

    /* Function Body */
    *info = 0;          // 将 info 初始化为 0

    if (*n < 0) {       // 如果 n 小于 0
        *info = -2;     // 设置 info 为 -2
    } else if (*ldq < max(1,*n)) {  // 否则如果 ldq 小于 1 和 n 中的最大值
        *info = -6;     // 设置 info 为 -6
    } else /* if(complicated condition) */ {
        /* Computing MIN */
        i__1 = 1,       // 计算 1
        i__2 = *n / 2;  // 计算 n 的一半
        if (min(i__1,i__2) > *n1 || *n / 2 < *n1) {  // 如果计算结果小于 *n1 或者 *n 的一半小于 *n1
            *info = -3; // 设置 info 为 -3
        }
    }
    if (*info != 0) {   // 如果 info 不等于 0
        i__1 = -(*info);    // 取 info 的相反数
        xerbla_("DLAED2", &i__1);    // 调用错误处理函数 xerbla_
        return 0;       // 返回 0
    }

    /* Quick return if possible */
    if (*n == 0) {      // 如果 n 等于 0
        return 0;       // 直接返回 0
    }

    n2 = *n - *n1;      // 计算 n2
    n1p1 = *n1 + 1;     // 计算 n1p1

    if (*rho < 0.) {    // 如果 rho 小于 0
        dscal_(&n2, &c_b151, &z__[n1p1], &c__1);   // 调用向量缩放函数 dscal_
    }

    /*
       Normalize z so that norm(z) = 1.  Since z is the concatenation of
       two normalized vectors, norm2(z) = sqrt(2).
    */
    t = 1. / sqrt(2.);  // 计算 t
    dscal_(n, &t, &z__[1], &c__1);   // 调用向量缩放函数 dscal_

    /* RHO = ABS( norm(z)**2 * RHO ) */
    *rho = (d__1 = *rho * 2., abs(d__1));    // 计算 rho

    /* Sort the eigenvalues into increasing order */
    i__1 = *n;
    for (i__ = n1p1; i__ <= i__1; ++i__) {
        indxq[i__] += *n1;  // 调整 indxq 数组
        /* L10: */
    }

    /* re-integrate the deflated parts from the last pass */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dlamda[i__] = d__[indxq[i__]]; // 重组 dlamda 数组
        /* L20: */
    }
    dlamrg_(n1, &n2, &dlamda[1], &c__1, &c__1, &indxc[1]);   // 调用排序函数 dlamrg_
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        indx[i__] = indxq[indxc[i__]]; // 重组 indx 数组
        /* L30: */
    }

    /* Calculate the allowable deflation tolerance */
    imax = idamax_(n, &z__[1], &c__1);   // 计算 z__ 中的最大元素索引
    jmax = idamax_(n, &d__[1], &c__1);   // 计算 d__ 中的最大元素索引
    eps = EPSILON;      // 设置 eps 为 EPSILON
    /* Computing MAX */
    d__3 = (d__1 = d__[jmax], abs(d__1)), d__4 = (d__2 = z__[imax], abs(d__2));   // 计算两个值的最大值
    tol = eps * 8. * max(d__3,d__4);    // 计算容许的缩小容限

    /*
       If the rank-1 modifier is small enough, no more needs to be done
       except to reorganize Q so that its columns correspond with the
       elements in D.
    */
    if (*rho * (d__1 = z__[imax], abs(d__1)) <= tol) {  // 如果 rank-1 修正值足够小
        *k = 0;         // 设置 k 为 0
        iq2 = 1;        // 初始化 iq2
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__ = indx[j];  // 获取 indx 数组的值
            dcopy_(n, &q[i__ * q_dim1 + 1], &c__1, &q2[iq2], &c__1);  // 复制向量 q 中的值到 q2
            dlamda[j] = d__[i__];   // 更新 dlamda 数组
            iq2 += *n;      // 更新 iq2
            /* L40: */
        }
        dlacpy_("A", n, n, &q2[1], n, &q[q_offset], ldq);    // 复制矩阵 q2 到 q
        dcopy_(n, &dlamda[1], &c__1, &d__[1], &c__1);    // 复制向量 dlamda 到 d
        goto L190;      // 跳转到 L190 标签处
    }

    /*
       If there are multiple eigenvalues then the problem deflates.  Here
       the number of equal eigenvalues are found.  As each equal
       eigenvalue is found, an elementary reflector is computed to rotate
       the corresponding eigensubspace so that the corresponding
       components of Z are zero in this new basis.
    */
    i__1 = *n1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        coltyp[i__] = 1;    // 设置 coltyp 数组
        /* L50: */
    }
    i__1 = *n;
    for (i__ = n1p1; i__ <= i__1; ++i__) {
        coltyp[i__] = 3;    // 设置 coltyp 数组
        /* L60: */
    }

    *k = 0;     // 设置 k 为 0
    // 计算 k2 的值，等于 n + 1
    k2 = *n + 1;
    // 设定循环的上界为 n
    i__1 = *n;
    // 循环遍历 j 从 1 到 n
    for (j = 1; j <= i__1; ++j) {
        // 获取 indx[j] 的值，赋给 nj
        nj = indx[j];
        // 检查 rho * |z__[nj]| 是否小于等于 tol
        if (*rho * (d__1 = z__[nj], abs(d__1)) <= tol) {
/*           Deflate due to small z component. */

/* 减少 k2 的值，用于表示对应列的索引减少一个 */
--k2;
/* 设置 coltyp 数组中第 nj 个元素为 4，表示对应列的类型为 4 */
coltyp[nj] = 4;
/* 设置 indxp 数组中第 k2 个位置为 nj，表示索引 k2 指向 nj */
indxp[k2] = nj;
/* 如果 j 等于 *n，跳转到标签 L100 处执行 */
if (j == *n) {
goto L100;
}
} else {
/* 如果条件不满足，则执行以下操作 */
pj = nj;
/* 跳转到标签 L80 处执行 */
goto L80;
}
/* L70: */
}
L80:
/* j 自增 */
++j;
/* 获取 indx 数组中第 j 个位置的值作为 nj */
nj = indx[j];
/* 如果 j 大于 *n，跳转到标签 L100 处执行 */
if (j > *n) {
goto L100;
}
/* 如果 *rho 乘以 z__[nj] 的绝对值小于等于 tol */
if (*rho * (d__1 = z__[nj], abs(d__1)) <= tol) {

/*        Deflate due to small z component. */

/* 减少 k2 的值，用于表示对应列的索引减少一个 */
--k2;
/* 设置 coltyp 数组中第 nj 个元素为 4，表示对应列的类型为 4 */
coltyp[nj] = 4;
/* 设置 indxp 数组中第 k2 个位置为 nj，表示索引 k2 指向 nj */
indxp[k2] = nj;
} else {

/*        Check if eigenvalues are close enough to allow deflation. */

/* 获取 z__[pj] 和 z__[nj] 的值 */
s = z__[pj];
c__ = z__[nj];

/*
          Find sqrt(a**2+b**2) without overflow or
          destructive underflow.
*/

/* 计算 sqrt(c__^2 + s^2)，并将结果赋给 tau */
tau = dlapy2_(&c__, &s);
/* 计算 t = d__[nj] - d__[pj] */
t = d__[nj] - d__[pj];
/* 计算 c__ 和 s */
c__ /= tau;
s = -s / tau;
/* 如果 abs(t * c__ * s) 小于等于 tol */
if ((d__1 = t * c__ * s, abs(d__1)) <= tol) {

/*           Deflation is possible. */

/* 设置 z__[nj] 为 tau，设置 z__[pj] 为 0 */
z__[nj] = tau;
z__[pj] = 0.;
/* 如果 coltyp[nj] 不等于 coltyp[pj] */
if (coltyp[nj] != coltyp[pj]) {
/* 设置 coltyp[nj] 为 2 */
coltyp[nj] = 2;
}
/* 设置 coltyp[pj] 为 4 */
coltyp[pj] = 4;
/* 调用 drot_ 函数进行特定操作 */
drot_(n, &q[pj * q_dim1 + 1], &c__1, &q[nj * q_dim1 + 1], &c__1, &
    c__, &s);
/* 计算 t = d__[pj] * c__^2 + d__[nj] * s^2 */
/* 计算 d__[nj] 和 d__[pj] 的更新值 */
d__1 = c__;
d__2 = s;
t = d__[pj] * (d__1 * d__1) + d__[nj] * (d__2 * d__2);
d__1 = s;
d__2 = c__;
d__[nj] = d__[pj] * (d__1 * d__1) + d__[nj] * (d__2 * d__2);
d__[pj] = t;
/* 减少 k2 的值，用于表示对应列的索引减少一个 */
--k2;
/* 设置 i__ 为 1 */
i__ = 1;
L90:
/* 如果 k2 + i__ 小于等于 *n */
if (k2 + i__ <= *n) {
/* 如果 d__[pj] 小于 d__[indxp[k2 + i__]] */
if (d__[pj] < d__[indxp[k2 + i__]]) {
/* 更新 indxp 数组中的值 */
indxp[k2 + i__ - 1] = indxp[k2 + i__];
indxp[k2 + i__] = pj;
++i__;
/* 跳转到标签 L90 处执行 */
goto L90;
} else {
indxp[k2 + i__ - 1] = pj;
}
} else {
indxp[k2 + i__ - 1] = pj;
}
/* 设置 pj 为 nj */
pj = nj;
} else {
/* 如果条件不满足，则执行以下操作 */
++(*k);
/* 将 d__[pj] 和 z__[pj] 的值存入 dlamda 和 w 数组中 */
dlamda[*k] = d__[pj];
w[*k] = z__[pj];
/* 设置 indxp 数组中第 *k 个位置为 pj */
indxp[*k] = pj;
/* 设置 pj 为 nj */
pj = nj;
}
}
/* 跳转到标签 L80 处执行 */
goto L80;
L100:

/*     Record the last eigenvalue. */

/* *k 自增 */
++(*k);
/* 将 d__[pj] 和 z__[pj] 的值存入 dlamda 和 w 数组中 */
dlamda[*k] = d__[pj];
w[*k] = z__[pj];
/* 设置 indxp 数组中第 *k 个位置为 pj */
indxp[*k] = pj;

/*
       Count up the total number of the various types of columns, then
       form a permutation which positions the four column types into
       four uniform groups (although one or more of these groups may be
       empty).
*/

/* 初始化 ctot 数组 */
for (j = 1; j <= 4; ++j) {
ctot[j - 1] = 0;
/* L110: */
}
/* 统计 coltyp 数组中每种类型的列数 */
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
ct = coltyp[j];
++ctot[ct - 1];
/* L120: */
}

/*     PSM(*) = Position in SubMatrix (of types 1 through 4) */

/* 设置 psm 数组的值 */
psm[0] = 1;
psm[1] = ctot[0] + 1;
psm[2] = psm[1] + ctot[1];
psm[3] = psm[2] + ctot[2];
/* 更新 *k 的值 */
*k = *n - ctot[3];

/*
       Fill out the INDXC array so that the permutation which it induces
       will place all type-1 columns first, all type-2 columns next,
       then all type-3's, and finally all type-4's.
*/

/* 填充 indxc 数组，使得它能将不同类型的列按顺序排列 */
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
js = indxp[j];
ct = coltyp[js];
    # 将数组 indx 中 psm[ct - 1] 索引处的值设置为 js
    indx[psm[ct - 1]] = js;
    # 将数组 indxc 中 psm[ct - 1] 索引处的值设置为 j
    indxc[psm[ct - 1]] = j;
    # 将 psm[ct - 1] 索引处的值增加 1
    ++psm[ct - 1];
/* L130: */
    }

/*
       Sort the eigenvalues and corresponding eigenvectors into DLAMDA
       and Q2 respectively.  The eigenvalues/vectors which were not
       deflated go into the first K slots of DLAMDA and Q2 respectively,
       while those which were deflated go into the last N - K slots.
*/

    i__ = 1;
    // Initialize indices for copying eigenvectors and eigenvalues
    iq1 = 1;
    iq2 = (ctot[0] + ctot[1]) * *n1 + 1;
    // Copy eigenvectors and eigenvalues for eigenvalues not deflated
    i__1 = ctot[0];
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];
    // Copy part of eigenvector q into q2 and eigenvalue into z
    dcopy_(n1, &q[js * q_dim1 + 1], &c__1, &q2[iq1], &c__1);
    z__[i__] = d__[js];
    ++i__;
    iq1 += *n1;
/* L140: */
    }

    // Copy eigenvectors and eigenvalues for eigenvalues partially deflated
    i__1 = ctot[1];
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];
    // Copy part of eigenvector q and additional part into q2 and eigenvalue into z
    dcopy_(n1, &q[js * q_dim1 + 1], &c__1, &q2[iq1], &c__1);
    dcopy_(&n2, &q[*n1 + 1 + js * q_dim1], &c__1, &q2[iq2], &c__1);
    z__[i__] = d__[js];
    ++i__;
    iq1 += *n1;
    iq2 += n2;
/* L150: */
    }

    // Copy eigenvectors and eigenvalues for fully deflated eigenvalues
    i__1 = ctot[2];
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];
    // Copy additional part of eigenvector q into q2 and eigenvalue into z
    dcopy_(&n2, &q[*n1 + 1 + js * q_dim1], &c__1, &q2[iq2], &c__1);
    z__[i__] = d__[js];
    ++i__;
    iq2 += n2;
/* L160: */
    }

    // Prepare for copying remaining eigenvectors and eigenvalues
    iq1 = iq2;
    // Copy eigenvectors and eigenvalues for undeflated eigenvalues
    i__1 = ctot[3];
    for (j = 1; j <= i__1; ++j) {
    js = indx[i__];
    // Copy full eigenvector q into q2 and eigenvalue into z
    dcopy_(n, &q[js * q_dim1 + 1], &c__1, &q2[iq2], &c__1);
    iq2 += *n;
    z__[i__] = d__[js];
    ++i__;
/* L170: */
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

    // Copy deflated eigenvalues into D and deflated eigenvectors into Q
    dlacpy_("A", n, &ctot[3], &q2[iq1], n, &q[(*k + 1) * q_dim1 + 1], ldq);
    i__1 = *n - *k;
    dcopy_(&i__1, &z__[*k + 1], &c__1, &d__[*k + 1], &c__1);

/*     Copy CTOT into COLTYP for referencing in DLAED3. */

    // Copy ctot array into coltyp array for later use
    for (j = 1; j <= 4; ++j) {
    coltyp[j] = ctot[j - 1];
/* L180: */
    }

L190:
    return 0;

/*     End of DLAED2 */

} /* dlaed2_ */

/* Subroutine */ int dlaed3_(integer *k, integer *n, integer *n1, doublereal *
    d__, doublereal *q, integer *ldq, doublereal *rho, doublereal *dlamda,
     doublereal *q2, integer *indx, integer *ctot, doublereal *w,
    doublereal *s, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n2, n12, ii, n23, iq2;
    static doublereal temp;
    extern doublereal dnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *),
         dcopy_(integer *, doublereal *, integer *, doublereal *, integer
        *), dlaed4_(integer *, integer *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *);
    extern doublereal dlamc3_(doublereal *, doublereal *);
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *),
        dlaset_(char *, integer *, integer *, doublereal *, doublereal *,
        doublereal *, integer *), xerbla_(char *, integer *);
    
    
    
    extern
        外部声明关键字，用于声明下面几个子程序的接口
    
    /* Subroutine */
        标记以下是一个子程序（subroutine），即一个不返回值的过程
    
    dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *)
        dlacpy 子程序的声明，接受多个参数：
        - char *: 字符串指针，用于表示字符参数
        - integer *: 整数指针，用于表示整数参数
        - doublereal *: 双精度实数指针，用于表示双精度实数参数
    
    dlaset_(char *, integer *, integer *, doublereal *, doublereal *,
        doublereal *, integer *)
        dlaset 子程序的声明，接受多个参数，与上述相似
    
    xerbla_(char *, integer *)
        xerbla 子程序的声明，接受两个参数：
        - char *: 字符串指针，用于表示字符参数
        - integer *: 整数指针，用于表示整数参数
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAED3 finds the roots of the secular equation, as defined by the
    values in D, W, and RHO, between 1 and K.  It makes the
    appropriate calls to DLAED4 and then updates the eigenvectors by
    multiplying the matrix of eigenvectors of the pair of eigensystems
    being combined by the matrix of eigenvectors of the K-by-K system
    which is solved here.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    K       (input) INTEGER
            The number of terms in the rational function to be solved by
            DLAED4.  K >= 0.

    N       (input) INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (deflation may result in N>K).

    N1      (input) INTEGER
            The location of the last eigenvalue in the leading submatrix.
            min(1,N) <= N1 <= N/2.

    D       (output) DOUBLE PRECISION array, dimension (N)
            D(I) contains the updated eigenvalues for
            1 <= I <= K.

    Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)
            Initially the first K columns are used as workspace.
            On output the columns 1 to K contain
            the updated eigenvectors.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    RHO     (input) DOUBLE PRECISION
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.

    DLAMDA  (input/output) DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation. May be changed on output by
            having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
            Cray-2, or Cray C-90, as described above.

    Q2      (input) DOUBLE PRECISION array, dimension (LDQ2, N)
            The first K columns of this matrix contain the non-deflated
            eigenvectors for the split problem.

    INDX    (input) INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups (see DLAED2).
            The rows of the eigenvectors found by DLAED4 must be likewise
            permuted before the matrix multiply can take place.
"""
    CTOT    (input) INTEGER array, dimension (4)
            A count of the total number of the various types of columns
            in Q, as described in INDX.  The fourth column type is any
            column which has been deflated.
    # CTOT 是一个整数数组，长度为 4，用来统计 Q 矩阵中不同类型列的总数，根据 INDX 描述。
    # 第四种列类型是任何已经被缩小的列。

    W       (input/output) DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector. Destroyed on
            output.
    # W 是一个双精度浮点数数组，长度为 K。输入时包含经过缩小调整的更新向量的组成部分。
    # 输出时内容被销毁。

    S       (workspace) DOUBLE PRECISION array, dimension (N1 + 1)*K
            Will contain the eigenvectors of the repaired matrix which
            will be multiplied by the previously accumulated eigenvectors
            to update the system.
    # S 是一个工作空间的双精度浮点数数组，长度为 (N1 + 1)*K。
    # 它将包含修复后矩阵的特征向量，这些向量将与之前累积的特征向量相乘，用于更新系统。

    LDS     (input) INTEGER
            The leading dimension of S.  LDS >= max(1,K).
    # LDS 是整数，表示 S 的主维度。要求 LDS >= max(1,K)。

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
    # INFO 是一个整数，用于输出函数的执行状态：
    # 0 表示成功完成。
    # 负数表示某个参数有非法值。
    # 正数 1 表示某个特征值没有收敛。

    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA
    Modified by Francoise Tisseur, University of Tennessee.

    =====================================================================


       Test the input parameters.
    # 测试输入参数的有效性。
    /* Parameter adjustments */
    --d__;                              // 调整参数d__的指针
    q_dim1 = *ldq;                      // 设置q_dim1为ldq，用于二维数组q的计算
    q_offset = 1 + q_dim1;              // 设置q_offset为1 + q_dim1，用于二维数组q的偏移量
    q -= q_offset;                      // 调整q的指针，使其指向正确的起始位置
    --dlamda;                           // 调整参数dlamda的指针
    --q2;                               // 调整参数q2的指针
    --indx;                             // 调整参数indx的指针
    --ctot;                             // 调整参数ctot的指针
    --w;                                // 调整参数w的指针
    --s;                                // 调整参数s的指针

    /* Function Body */
    *info = 0;                          // 初始化info为0，表示无错误

    if (*k < 0)```
    if (*k < 0) {                       // 检查k是否小于0
        *info = -1;                     // 若是，将info设为-1表示错误
    } else if (*n < *k) {               
        *info = -2;                     // 若n小于k，将info设为-2表示错误
    } else if (*ldq < max(1,*n)) {      
        *info = -6;                     // 若ldq小于1或n中的最大值，将info设为-6表示错误
    }
    if (*info != 0) {                   // 若info不为0，表示有错误发生
        i__1 = -(*info);                
        xerbla_("DLAED3", &i__1);        // 调用xerbla_函数报告错误并终止
        return 0;                       // 返回0，表示执行失败
    }

    /* Quick return if possible */
    if (*k == 0) {                      // 若k为0，无需执行后续操作，直接返回
        return 0;
    }

    /*
       Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
       which on any of these machines zeros out the bottommost
       bit of DLAMDA(I) if it is 1; this makes the subsequent
       subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DLAMDA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DLAMDA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DLAMBDA(I) to prevent optimizing compilers from eliminating
       this code.
    */

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dlamda[i__] = dlamc3_(&dlamda[i__], &dlamda[i__]) - dlamda[i__];
        // 修改dlamda[i__]的值以提高相对精度，避免计算中的溢出或下溢
    }

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dlaed4_(k, &j, &dlamda[1], &w[1], &q[j * q_dim1 + 1], rho, &d__[j], info);
        // 调用dlaed4_函数进行特征值计算和更新
        // 若零点查找失败，则终止计算
        if (*info != 0) {
            goto L120;
        }
    }

    if (*k == 1) {                      // 若k为1，跳转到L110处继续执行
        goto L110;
    }
    if (*k == 2) {                      // 若k为2，重新排序q矩阵的列
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            w[1] = q[j * q_dim1 + 1];
            w[2] = q[j * q_dim1 + 2];
            ii = indx[1];
            q[j * q_dim1 + 1] = w[ii];
            ii = indx[2];
            q[j * q_dim1 + 2] = w[ii];
        }
        goto L110;                      // 跳转到L110处继续执行
    }

    /* Compute updated W. */
    dcopy_(k, &w[1], &c__1, &s[1], &c__1);
    // 复制w到s，保留w的副本

    /* Initialize W(I) = Q(I,I) */
    i__1 = *ldq + 1;
    dcopy_(k, &q[q_offset], &i__1, &w[1], &c__1);
    // 将q的主对角线元素复制到w中

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
        }
    }
    // 计算更新后的w值，使用q和dlamda进行计算

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        d__1 = sqrt(-w[i__]);
        w[i__] = d_sign(&d__1, &s[i__]);
    }
    // 将w的每个元素取负平方根，并根据s的符号修正w的值
/*     Compute eigenvectors of the modified rank-1 modification. */

/* Loop over columns of Q */
i__1 = *k;
for (j = 1; j <= i__1; ++j) {
    /* Compute scaled vector s */
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        s[i__] = w[i__] / q[i__ + j * q_dim1];
        /* L80: */
    }
    /* Compute Euclidean norm of s */
    temp = dnrm2_(k, &s[1], &c__1);
    /* Normalize columns of Q */
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        ii = indx[i__];
        q[i__ + j * q_dim1] = s[ii] / temp;
        /* L90: */
    }
    /* L100: */
}

/*     Compute the updated eigenvectors. */

L110:

/* Compute dimensions */
n2 = *n - *n1;
n12 = ctot[1] + ctot[2];
n23 = ctot[2] + ctot[3];

/* Copy parts of Q matrix */
dlacpy_("A", &n23, k, &q[ctot[1] + 1 + q_dim1], ldq, &s[1], &n23);
/* Compute offset */
iq2 = *n1 * n12 + 1;
/* Perform matrix multiplication if n23 is non-zero */
if (n23 != 0) {
    dgemm_("N", "N", &n2, k, &n23, &c_b15, &q2[iq2], &n2, &s[1], &n23, &
        c_b29, &q[*n1 + 1 + q_dim1], ldq);
} else {
    /* Set Q matrix to zero if n23 is zero */
    dlaset_("A", &n2, k, &c_b29, &c_b29, &q[*n1 + 1 + q_dim1], ldq);
}

/* Copy another part of Q matrix */
dlacpy_("A", &n12, k, &q[q_offset], ldq, &s[1], &n12);
/* Perform matrix multiplication if n12 is non-zero */
if (n12 != 0) {
    dgemm_("N", "N", n1, k, &n12, &c_b15, &q2[1], n1, &s[1], &n12, &c_b29,
         &q[q_offset], ldq);
} else {
    /* Set Q matrix to zero if n12 is zero */
    dlaset_("A", n1, k, &c_b29, &c_b29, &q[q_dim1 + 1], ldq);
}

L120:
return 0;

/*     End of DLAED3 */

} /* dlaed3_ */

/* Subroutine */ int dlaed4_(integer *n, integer *i__, doublereal *d__,
doublereal *z__, doublereal *delta, doublereal *rho, doublereal *dlam,
integer *info)
{
/* System generated locals */
integer i__1;
doublereal d__1;

/* Local variables */
static doublereal a, b, c__;
static integer j;
static doublereal w;
static integer ii;
static doublereal dw, zz[3];
static integer ip1;
static doublereal del, eta, phi, eps, tau, psi;
static integer iim1, iip1;
static doublereal dphi, dpsi;
static integer iter;
static doublereal temp, prew, temp1, dltlb, dltub, midpt;
static integer niter;
static logical swtch;
extern /* Subroutine */ int dlaed5_(integer *, doublereal *, doublereal *,
doublereal *, doublereal *, doublereal *), dlaed6_(integer *,
logical *, doublereal *, doublereal *, doublereal *, doublereal *,
doublereal *, integer *);
static logical swtch3;

static logical orgati;
static doublereal erretm, rhoinv;


/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee, --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
November 2006


Purpose
=======

This subroutine computes the I-th updated eigenvalue of a symmetric
rank-one modification to a diagonal matrix whose elements are
given in the array d, and that

D(i) < D(j) for i < j

and that RHO > 0. This is arranged by the calling routine, and is
no loss in generality. The rank-one modified system is thus

diag( D ) + RHO * Z * Z_transpose.

where we assume the Euclidean norm of Z is 1.

*/


注释：
    # 这个方法通过简单的插值有理函数来逼近标准方程中的有理函数。

    # Arguments
    # =========

    # N      (input) INTEGER
    #        所有数组的长度。

    # I      (input) INTEGER
    #        要计算的特征值的索引。 1 <= I <= N。

    # D      (input) DOUBLE PRECISION array, dimension (N)
    #        原始特征值数组。假设它们已经按顺序排列，即 D(I) < D(J) 对于所有 I < J。

    # Z      (input) DOUBLE PRECISION array, dimension (N)
    #        更新向量的分量。

    # DELTA  (output) DOUBLE PRECISION array, dimension (N)
    #        如果 N > 2，则 DELTA 的第 j 个分量包含 (D(j) - lambda_I)。
    #        如果 N = 1，则 DELTA(1) = 1。
    #        如果 N = 2，请参阅 DLAED5 的详细说明。
    #        向量 DELTA 包含构建特征向量所需的信息，由 DLAED3 和 DLAED9 使用。

    # RHO    (input) DOUBLE PRECISION
    #        对称更新公式中的标量。

    # DLAM   (output) DOUBLE PRECISION
    #        计算得到的 lambda_I，第 I 个更新后的特征值。

    # INFO   (output) INTEGER
    #        = 0:  成功退出
    #        > 0:  如果 INFO = 1，则更新过程失败。

    # Internal Parameters
    # ===================

    # Logical variable ORGATI (origin-at-i?) 用于区分
    # 是否将 D(i) 或 D(i+1) 视为起点。

    #           ORGATI = .true.    起点在 i
    #           ORGATI = .false.   起点在 i+1

    # Logical variable SWTCH3 (switch-for-3-poles?) 用于标记
    # 是否在处理三极点！

    # MAXIT 是允许每个特征值的最大迭代次数。

    # Further Details
    # ===============

    # 基于以下贡献
    #    Ren-Cang Li, 加利福尼亚大学伯克利分校，计算机科学部，美国

    # =====================================================================

       # 由于这个例程在内部循环中被调用，我们不进行参数检查。

       # 对于 N=1 和 2 的快速返回。
    /* Parameter adjustments */
    --delta;    // Adjust the pointer to the array delta to point to the correct starting index
    --z__;      // Adjust the pointer to the array z__ to point to the correct starting index
    --d__;      // Adjust the pointer to the array d__ to point to the correct starting index

    /* Function Body */
    *info = 0;  // Initialize info to 0 (presumably indicating successful execution)
    if (*n == 1) {

/*         Presumably, I=1 upon entry */

    *dlam = d__[1] + *rho * z__[1] * z__[1];   // Compute dlam as specified
    delta[1] = 1.;   // Set delta[1] to 1
    return 0;    // Return with success
    }
    if (*n == 2) {
    dlaed5_(i__, &d__[1], &z__[1], &delta[1], rho, dlam);    // Call external function dlaed5_
    return 0;    // Return with success
    }

/*     Compute machine epsilon */

    eps = EPSILON;    // Set eps to the value of EPSILON (presumably a constant defined elsewhere)
    rhoinv = 1. / *rho;    // Compute the reciprocal of rho

/*     The case I = N */

    if (*i__ == *n) {

/*        Initialize some basic variables */

    ii = *n - 1;    // Set ii to n-1
    niter = 1;    // Initialize niter to 1

/*        Calculate initial guess */

    midpt = *rho / 2.;    // Compute midpt as rho / 2

/*
          If ||Z||_2 is not one, then TEMP should be set to
          RHO * ||Z||_2^2 / TWO
*/

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        delta[j] = d__[j] - d__[*i__] - midpt;    // Compute delta[j] as specified
/* L10: */
    }

    psi = 0.;    // Initialize psi to 0
    i__1 = *n - 2;
    for (j = 1; j <= i__1; ++j) {
        psi += z__[j] * z__[j] / delta[j];    // Accumulate psi as specified
/* L20: */
    }

    c__ = rhoinv + psi;    // Compute c__ as specified
    w = c__ + z__[ii] * z__[ii] / delta[ii] + z__[*n] * z__[*n] / delta[*n];    // Compute w as specified

    if (w <= 0.) {
        temp = z__[*n - 1] * z__[*n - 1] / (d__[*n] - d__[*n - 1] + *rho)
            + z__[*n] * z__[*n] / *rho;    // Compute temp as specified
        if (c__ <= temp) {
        tau = *rho;    // Set tau to rho
        } else {
        del = d__[*n] - d__[*n - 1];    // Compute del as specified
        a = -c__ * del + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];    // Compute a as specified
        b = z__[*n] * z__[*n] * del;    // Compute b as specified
        if (a < 0.) {
            tau = b * 2. / (sqrt(a * a + b * 4. * c__) - a);    // Compute tau as specified
        } else {
            tau = (a + sqrt(a * a + b * 4. * c__)) / (c__ * 2.);    // Compute tau as specified
        }
        }

/*
             It can be proved that
                 D(N)+RHO/2 <= LAMBDA(N) < D(N)+TAU <= D(N)+RHO
*/

        dltlb = midpt;    // Set dltlb to midpt
        dltub = *rho;    // Set dltub to rho
    } else {
        del = d__[*n] - d__[*n - 1];    // Compute del as specified
        a = -c__ * del + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];    // Compute a as specified
        b = z__[*n] * z__[*n] * del;    // Compute b as specified
        if (a < 0.) {
        tau = b * 2. / (sqrt(a * a + b * 4. * c__) - a);    // Compute tau as specified
        } else {
        tau = (a + sqrt(a * a + b * 4. * c__)) / (c__ * 2.);    // Compute tau as specified
        }

/*
             It can be proved that
                 D(N) < D(N)+TAU < LAMBDA(N) < D(N)+RHO/2
*/

        dltlb = 0.;    // Set dltlb to 0
        dltub = midpt;    // Set dltub to midpt
    }

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        delta[j] = d__[j] - d__[*i__] - tau;    // Compute delta[j] as specified
/* L30: */
    }

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.;    // Initialize dpsi to 0
    psi = 0.;    // Initialize psi to 0
    erretm = 0.;    // Initialize erretm to 0
    i__1 = ii;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / delta[j];    // Compute temp as specified
        psi += z__[j] * temp;    // Accumulate psi as specified
        dpsi += temp * temp;    // Accumulate dpsi as specified
        erretm += psi;    // Accumulate erretm as specified
/* L40: */
    }
    erretm = abs(erretm);    // Compute absolute value of erretm

/*        Evaluate PHI and the derivative DPHI */

    temp = z__[*n] / delta[*n];    // Compute temp as specified
    phi = z__[*n] * temp;    // Compute phi as specified
    dphi = temp * temp;    // Compute dphi as specified
    erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (dpsi
        + dphi);    // Compute erretm as specified

    w = rhoinv + phi + psi;    // Recompute w as specified

/*        Test for convergence */
    # 如果 w 的绝对值小于等于 eps 与 erretm 的乘积，则执行以下操作
    if (abs(w) <= eps * erretm) {
        # 将 dlam 设置为 d__[i__] 加上 tau，并跳转到标签 L250 处
        *dlam = d__[*i__] + tau;
        goto L250;
    }

    # 如果 w 小于等于 0
    if (w <= 0.) {
        # 将 dltlb 设为 dltlb 和 tau 中的较大值
        dltlb = max(dltlb, tau);
    } else {
        # 将 dltub 设为 dltub 和 tau 中的较小值
        dltub = min(dltub, tau);
    }
/*        Calculate the new step */
/* 计算新的步长 */

    ++niter;
    /* Increment iteration counter */
    c__ = w - delta[*n - 1] * dpsi - delta[*n] * dphi;
    /* Compute intermediate value c__ */
    a = (delta[*n - 1] + delta[*n]) * w - delta[*n - 1] * delta[*n] * (
        dpsi + dphi);
    /* Compute intermediate value a */
    b = delta[*n - 1] * delta[*n] * w;
    /* Compute intermediate value b */
    if (c__ < 0.) {
        c__ = abs(c__);
    }
    /* Adjust c__ to be non-negative if it's negative */
    if (c__ == 0.) {
/*
            ETA = B/A
             ETA = RHO - TAU
*/
        eta = dltub - tau;
        /* Compute eta if c__ is zero */
    } else if (a >= 0.) {
        eta = (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (c__
            * 2.);
        /* Compute eta using the quadratic formula if a is non-negative */
    } else {
        eta = b * 2. / (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))
            );
        /* Compute eta using the alternative formula if a is negative */
    }

/*
          Note, eta should be positive if w is negative, and
          eta should be negative otherwise. However,
          if for some reason caused by roundoff, eta*w > 0,
          we simply use one Newton step instead. This way
          will guarantee eta*w < 0.
*/
/* 注意，如果 w 是负数，eta 应该是正数，否则应该是负数。
   然而，如果由于舍入误差的原因，eta*w > 0，
   我们简单地使用一个牛顿步骤。这样可以确保 eta*w < 0。 */

    if (w * eta > 0.) {
        eta = -w / (dpsi + dphi);
        /* Adjust eta to use a Newton step if necessary to maintain sign */
    }
    temp = tau + eta;
    /* Update temporary variable temp */
    if (temp > dltub || temp < dltlb) {
        if (w < 0.) {
        eta = (dltub - tau) / 2.;
        } else {
        eta = (dltlb - tau) / 2.;
        }
        /* Adjust eta to stay within bounds if temp is out of bounds */
    }
    i__1 = *n;
    /* Initialize loop counter */
    for (j = 1; j <= i__1; ++j) {
        delta[j] -= eta;
/* L50: */
    }
    /* Update each element in the delta array */

    tau += eta;
    /* Update tau */

/*        Evaluate PSI and the derivative DPSI */
/* 计算 PSI 和它的导数 DPSI */

    dpsi = 0.;
    /* Reset dpsi */
    psi = 0.;
    /* Reset psi */
    erretm = 0.;
    /* Reset error estimate */
    i__1 = ii;
    /* Set loop limit */
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / delta[j];
        /* Compute temporary value temp */
        psi += z__[j] * temp;
        /* Update psi */
        dpsi += temp * temp;
        /* Update dpsi */
        erretm += psi;
/* L60: */
    }
    /* Update error estimate */

    erretm = abs(erretm);
    /* Compute absolute value of error estimate */

/*        Evaluate PHI and the derivative DPHI */
/* 计算 PHI 和它的导数 DPHI */

    temp = z__[*n] / delta[*n];
    /* Compute temporary value temp */
    phi = z__[*n] * temp;
    /* Update phi */
    dphi = temp * temp;
    /* Update dphi */
    erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (dpsi
        + dphi);
    /* Update error estimate */

    w = rhoinv + phi + psi;
    /* Update w */

/*        Main loop to update the values of the array   DELTA */
/* 主循环来更新数组 DELTA 的值 */

    iter = niter + 1;
    /* Initialize iteration counter */

    for (niter = iter; niter <= 30; ++niter) {

/*           Test for convergence */
/* 检查是否收敛 */

        if (abs(w) <= eps * erretm) {
        *dlam = d__[*i__] + tau;
        goto L250;
        }
        /* Check convergence condition and exit loop if met */

        if (w <= 0.) {
        dltlb = max(dltlb,tau);
        } else {
        dltub = min(dltub,tau);
        }
        /* Adjust bounds based on the sign of w */

/*           Calculate the new step */
/* 计算新的步长 */

        c__ = w - delta[*n - 1] * dpsi - delta[*n] * dphi;
        /* Compute intermediate value c__ */
        a = (delta[*n - 1] + delta[*n]) * w - delta[*n - 1] * delta[*n] *
            (dpsi + dphi);
        /* Compute intermediate value a */
        b = delta[*n - 1] * delta[*n] * w;
        /* Compute intermediate value b */
        if (a >= 0.) {
        eta = (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
            c__ * 2.);
        /* Compute eta using the quadratic formula if a is non-negative */
        } else {
        eta = b * 2. / (a - sqrt((d__1 = a * a - b * 4. * c__, abs(
            d__1))));
        /* Compute eta using the alternative formula if a is negative */
        }

/*
             Note, eta should be positive if w is negative, and
             eta should be negative otherwise. However,
             if for some reason caused by roundoff, eta*w > 0,
             we simply use one Newton step instead. This way
             will guarantee eta*w < 0.
*/
/* 注意，如果 w 是负数，eta 应该是正数，否则应该是负数。
   然而，如果由于舍入误差的原因，eta*w > 0，
   我们简单地使用一个牛顿步骤。这样可以确保 eta*w < 0。 */

    }
/* End of main loop */
        if (w * eta > 0.) {
        // 如果 w * eta 大于 0，则调整 eta 的值使其满足条件
        eta = -w / (dpsi + dphi);
        }
        temp = tau + eta;
        // 如果 temp 超出了上限或者下限范围，则根据 w 的正负调整 eta 的值
        if (temp > dltub || temp < dltlb) {
        if (w < 0.) {
            eta = (dltub - tau) / 2.;
        } else {
            eta = (dltlb - tau) / 2.;
        }
        }
        i__1 = *n;
        // 更新 delta 数组的值，使其减去 eta
        for (j = 1; j <= i__1; ++j) {
        delta[j] -= eta;
/* L70: */
        }

        tau += eta;

/*           Evaluate PSI and the derivative DPSI */

        dpsi = 0.;
        psi = 0.;
        erretm = 0.;
        i__1 = ii;
        // 计算 PSI 及其导数 DPSI
        for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / delta[j];
        psi += z__[j] * temp;
        dpsi += temp * temp;
        erretm += psi;
/* L80: */
        }
        erretm = abs(erretm);

/*           Evaluate PHI and the derivative DPHI */

        temp = z__[*n] / delta[*n];
        // 计算 PHI 及其导数 DPHI
        phi = z__[*n] * temp;
        dphi = temp * temp;
        erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (
            dpsi + dphi);

        w = rhoinv + phi + psi;
/* L90: */
    }

/*        Return with INFO = 1, NITER = MAXIT and not converged */

    *info = 1;
    *dlam = d__[*i__] + tau;
    // 跳转到 L250 处
    goto L250;

/*        End for the case I = N */

    } else {

/*        The case for I < N */

    niter = 1;
    ip1 = *i__ + 1;

/*        Calculate initial guess */

    del = d__[ip1] - d__[*i__];
    midpt = del / 2.;
    i__1 = *n;
    // 计算 delta 数组的初始值
    for (j = 1; j <= i__1; ++j) {
        delta[j] = d__[j] - d__[*i__] - midpt;
/* L100: */
    }

    psi = 0.;
    i__1 = *i__ - 1;
    // 计算 PSI 的初始值
    for (j = 1; j <= i__1; ++j) {
        psi += z__[j] * z__[j] / delta[j];
/* L110: */
    }

    phi = 0.;
    i__1 = *i__ + 2;
    // 计算 PHI 的初始值
    for (j = *n; j >= i__1; --j) {
        phi += z__[j] * z__[j] / delta[j];
/* L120: */
    }
    c__ = rhoinv + psi + phi;
    w = c__ + z__[*i__] * z__[*i__] / delta[*i__] + z__[ip1] * z__[ip1] /
        delta[ip1];

    if (w > 0.) {

/*
             d(i)< the ith eigenvalue < (d(i)+d(i+1))/2

             We choose d(i) as origin.
*/

        orgati = TRUE_;
        // 根据 w 的正负选择 tau 的初始值
        a = c__ * del + z__[*i__] * z__[*i__] + z__[ip1] * z__[ip1];
        b = z__[*i__] * z__[*i__] * del;
        if (a > 0.) {
        tau = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(
            d__1))));
        } else {
        tau = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
            c__ * 2.);
        }
        dltlb = 0.;
        dltub = midpt;
    } else {

/*
             (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)

             We choose d(i+1) as origin.
*/

        orgati = FALSE_;
        // 根据 w 的正负选择 tau 的初始值
        a = c__ * del - z__[*i__] * z__[*i__] - z__[ip1] * z__[ip1];
        b = z__[ip1] * z__[ip1] * del;
        if (a < 0.) {
        tau = b * 2. / (a - sqrt((d__1 = a * a + b * 4. * c__, abs(
            d__1))));
        } else {
        tau = -(a + sqrt((d__1 = a * a + b * 4. * c__, abs(d__1)))) /
            (c__ * 2.);
        }
        dltlb = -midpt;
        dltub = 0.;
    }
    # 如果 orgati 为真，则执行以下代码块
    if (orgati) {
        # 将变量 i__1 设置为指针 n 所指向的值
        i__1 = *n;
        # 循环，j 从 1 到 i__1
        for (j = 1; j <= i__1; ++j) {
            # 计算 delta[j] 的值，等于 d__[j] 减去 d__[*i__] 和 tau 的差
            delta[j] = d__[j] - d__[*i__] - tau;
/* L130: */
        }
    } else {
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
        delta[j] = d__[j] - d__[ip1] - tau;
/* L140: */
        }
    }
    if (orgati) {
        ii = *i__;
    } else {
        ii = *i__ + 1;
    }
    iim1 = ii - 1;
    iip1 = ii + 1;

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.;
    psi = 0.;
    erretm = 0.;
    i__1 = iim1;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / delta[j];
        psi += z__[j] * temp;
        dpsi += temp * temp;
        erretm += psi;
/* L150: */
    }
    erretm = abs(erretm);

/*        Evaluate PHI and the derivative DPHI */

    dphi = 0.;
    phi = 0.;
    i__1 = iip1;
    for (j = *n; j >= i__1; --j) {
        temp = z__[j] / delta[j];
        phi += z__[j] * temp;
        dphi += temp * temp;
        erretm += phi;
/* L160: */
    }

    w = rhoinv + phi + psi;

/*
          W is the value of the secular function with
          its ii-th element removed.
*/

    swtch3 = FALSE_;
    if (orgati) {
        if (w < 0.) {
        swtch3 = TRUE_;
        }
    } else {
        if (w > 0.) {
        swtch3 = TRUE_;
        }
    }
    if (ii == 1 || ii == *n) {
        swtch3 = FALSE_;
    }

    temp = z__[ii] / delta[ii];
    dw = dpsi + dphi + temp * temp;
    temp = z__[ii] * temp;
    w += temp;
    erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3. +
        abs(tau) * dw;

/*        Test for convergence */

    if (abs(w) <= eps * erretm) {
        if (orgati) {
        *dlam = d__[*i__] + tau;
        } else {
        *dlam = d__[ip1] + tau;
        }
        goto L250;
    }

    if (w <= 0.) {
        dltlb = max(dltlb,tau);
    } else {
        dltub = min(dltub,tau);
    }

/*        Calculate the new step */

    ++niter;
    if (! swtch3) {
        if (orgati) {
/* Computing 2nd power */
        d__1 = z__[*i__] / delta[*i__];
        c__ = w - delta[ip1] * dw - (d__[*i__] - d__[ip1]) * (d__1 *
            d__1);
        } else {
/* Computing 2nd power */
        d__1 = z__[ip1] / delta[ip1];
        c__ = w - delta[*i__] * dw - (d__[ip1] - d__[*i__]) * (d__1 *
            d__1);
        }
        a = (delta[*i__] + delta[ip1]) * w - delta[*i__] * delta[ip1] *
            dw;
        b = delta[*i__] * delta[ip1] * w;
        if (c__ == 0.) {
        if (a == 0.) {
            if (orgati) {
            a = z__[*i__] * z__[*i__] + delta[ip1] * delta[ip1] *
                (dpsi + dphi);
            } else {
            a = z__[ip1] * z__[ip1] + delta[*i__] * delta[*i__] *
                (dpsi + dphi);
            }
        }
        eta = b / a;
        } else if (a <= 0.) {
        eta = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
            c__ * 2.);
        } else {
        eta = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(
            d__1))));
        }
    } else {
/*
   Interpolation using THREE most relevant poles
*/

temp = rhoinv + psi + phi;
if (orgati) {
    temp1 = z__[iim1] / delta[iim1];
    temp1 *= temp1;
    c__ = temp - delta[iip1] * (dpsi + dphi) - (d__[iim1] - d__[
        iip1]) * temp1;
    zz[0] = z__[iim1] * z__[iim1];
    zz[2] = delta[iip1] * delta[iip1] * (dpsi - temp1 + dphi);
} else {
    temp1 = z__[iip1] / delta[iip1];
    temp1 *= temp1;
    c__ = temp - delta[iim1] * (dpsi + dphi) - (d__[iip1] - d__[
        iim1]) * temp1;
    zz[0] = delta[iim1] * delta[iim1] * (dpsi + (dphi - temp1));
    zz[2] = z__[iip1] * z__[iip1];
}
zz[1] = z__[ii] * z__[ii];
dlaed6_(&niter, &orgati, &c__, &delta[iim1], zz, &w, &eta, info);
if (*info != 0) {
    goto L250;
}

/*
   Note, eta should be positive if w is negative, and
   eta should be negative otherwise. However,
   if for some reason caused by roundoff, eta*w > 0,
   we simply use one Newton step instead. This way
   will guarantee eta*w < 0.
*/
if (w * eta >= 0.) {
    eta = -w / dw;
}
temp = tau + eta;
if (temp > dltub || temp < dltlb) {
    if (w < 0.) {
        eta = (dltub - tau) / 2.;
    } else {
        eta = (dltlb - tau) / 2.;
    }
}

prew = w;

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    delta[j] -= eta;
}

/*
   Evaluate PSI and the derivative DPSI
*/
dpsi = 0.;
psi = 0.;
erretm = 0.;
i__1 = iim1;
for (j = 1; j <= i__1; ++j) {
    temp = z__[j] / delta[j];
    psi += z__[j] * temp;
    dpsi += temp * temp;
    erretm += psi;
}

erretm = abs(erretm);

/*
   Evaluate PHI and the derivative DPHI
*/
dphi = 0.;
phi = 0.;
i__1 = iip1;
for (j = *n; j >= i__1; --j) {
    temp = z__[j] / delta[j];
    phi += z__[j] * temp;
    dphi += temp * temp;
    erretm += phi;
}

temp = z__[ii] / delta[ii];
dw = dpsi + dphi + temp * temp;
temp = z__[ii] * temp;
w = rhoinv + phi + psi + temp;
erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3. + (
    d__1 = tau + eta, abs(d__1)) * dw;

swtch = FALSE_;
if (orgati) {
    if (-w > abs(prew) / 10.) {
        swtch = TRUE_;
    }
} else {
    if (w > abs(prew) / 10.) {
        swtch = TRUE_;
    }
}

tau += eta;

/*
   Main loop to update the values of the array DELTA
*/
iter = niter + 1;

for (niter = iter; niter <= 30; ++niter) {

    /*
       Test for convergence
    */
    if (abs(w) <= eps * erretm) {
        if (orgati) {
            *dlam = d__[*i__] + tau;
        } else {
            *dlam = d__[ip1] + tau;
        }
        goto L250;
    }

    if (w <= 0.) {
        dltlb = max(dltlb,tau);
    } else {
        dltub = min(dltub,tau);
    }
}
/*           Calculate the new step */

        if (! swtch3) {
        if (! swtch) {
            if (orgati) {
/* Computing 2nd power */
            d__1 = z__[*i__] / delta[*i__];
            // 计算 c__
            c__ = w - delta[ip1] * dw - (d__[*i__] - d__[ip1]) * (
                d__1 * d__1);
            } else {
/* Computing 2nd power */
            d__1 = z__[ip1] / delta[ip1];
            // 计算 c__
            c__ = w - delta[*i__] * dw - (d__[ip1] - d__[*i__]) *
                (d__1 * d__1);
            }
        } else {
            // 计算 temp
            temp = z__[ii] / delta[ii];
            if (orgati) {
            // 更新 dpsi
            dpsi += temp * temp;
            } else {
            // 更新 dphi
            dphi += temp * temp;
            }
            // 计算 c__
            c__ = w - delta[*i__] * dpsi - delta[ip1] * dphi;
        }
        // 计算 a 和 b
        a = (delta[*i__] + delta[ip1]) * w - delta[*i__] * delta[ip1]
            * dw;
        b = delta[*i__] * delta[ip1] * w;
        if (c__ == 0.) {
            if (a == 0.) {
            if (! swtch) {
                if (orgati) {
                // 更新 a
                a = z__[*i__] * z__[*i__] + delta[ip1] *
                    delta[ip1] * (dpsi + dphi);
                } else {
                // 更新 a
                a = z__[ip1] * z__[ip1] + delta[*i__] * delta[
                    *i__] * (dpsi + dphi);
                }
            } else {
                // 更新 a
                a = delta[*i__] * delta[*i__] * dpsi + delta[ip1]
                    * delta[ip1] * dphi;
            }
            }
            // 计算 eta
            eta = b / a;
        } else if (a <= 0.) {
            // 计算 eta
            eta = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1))))
                 / (c__ * 2.);
        } else {
            // 计算 eta
            eta = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__,
                abs(d__1))));
        }
        } else {

/*              Interpolation using THREE most relevant poles */

        temp = rhoinv + psi + phi;
        if (swtch) {
            // 计算 c__
            c__ = temp - delta[iim1] * dpsi - delta[iip1] * dphi;
            // 更新 zz[0] 和 zz[2]
            zz[0] = delta[iim1] * delta[iim1] * dpsi;
            zz[2] = delta[iip1] * delta[iip1] * dphi;
        } else {
            if (orgati) {
            // 计算 temp1
            temp1 = z__[iim1] / delta[iim1];
            temp1 *= temp1;
            // 计算 c__
            c__ = temp - delta[iip1] * (dpsi + dphi) - (d__[iim1]
                - d__[iip1]) * temp1;
            // 更新 zz[0] 和 zz[2]
            zz[0] = z__[iim1] * z__[iim1];
            zz[2] = delta[iip1] * delta[iip1] * (dpsi - temp1 +
                dphi);
            } else {
            // 计算 temp1
            temp1 = z__[iip1] / delta[iip1];
            temp1 *= temp1;
            // 计算 c__
            c__ = temp - delta[iim1] * (dpsi + dphi) - (d__[iip1]
                - d__[iim1]) * temp1;
            // 更新 zz[0] 和 zz[2]
            zz[0] = delta[iim1] * delta[iim1] * (dpsi + (dphi -
                temp1));
            zz[2] = z__[iip1] * z__[iip1];
            }
        }
        // 调用 dlaed6_ 函数进行插值计算
        dlaed6_(&niter, &orgati, &c__, &delta[iim1], zz, &w, &eta,
            info);
        // 检查插值计算结果
        if (*info != 0) {
            // 跳转到错误处理标签
            goto L250;
        }
        }
/*
        Note, eta should be positive if w is negative, and
        eta should be negative otherwise. However,
        if for some reason caused by roundoff, eta*w > 0,
        we simply use one Newton step instead. This way
        will guarantee eta*w < 0.
*/
if (w * eta >= 0.) {
    eta = -w / dw;
}

temp = tau + eta;
if (temp > dltub || temp < dltlb) {
    if (w < 0.) {
        eta = (dltub - tau) / 2.;
    } else {
        eta = (dltlb - tau) / 2.;
    }
}

i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    delta[j] -= eta;
    /* L210: */
}

tau += eta;
prew = w;

/* Evaluate PSI and the derivative DPSI */
dpsi = 0.;
psi = 0.;
erretm = 0.;
i__1 = iim1;
for (j = 1; j <= i__1; ++j) {
    temp = z__[j] / delta[j];
    psi += z__[j] * temp;
    dpsi += temp * temp;
    erretm += psi;
    /* L220: */
}
erretm = abs(erretm);

/* Evaluate PHI and the derivative DPHI */
dphi = 0.;
phi = 0.;
i__1 = iip1;
for (j = *n; j >= i__1; --j) {
    temp = z__[j] / delta[j];
    phi += z__[j] * temp;
    dphi += temp * temp;
    erretm += phi;
    /* L230: */
}

temp = z__[ii] / delta[ii];
dw = dpsi + dphi + temp * temp;
temp = z__[ii] * temp;
w = rhoinv + phi + psi + temp;
erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3.
        + abs(tau) * dw;
if (w * prew > 0. && abs(w) > abs(prew) / 10.) {
    swtch = ! swtch;
}

/* L240: */

}

/* Return with INFO = 1, NITER = MAXIT and not converged */
*info = 1;
if (orgati) {
    *dlam = d__[*i__] + tau;
} else {
    *dlam = d__[ip1] + tau;
}
}

L250:

return 0;

/* End of DLAED4 */
} /* dlaed4_ */
    ! 输入参数：双精度数组 D，维度为 (2)
    !           原始特征值。假设 D(1) < D(2)。
    D      (input) DOUBLE PRECISION array, dimension (2)
           The original eigenvalues.  We assume D(1) < D(2).

    ! 输入参数：双精度数组 Z，维度为 (2)
    !           更新向量的分量。
    Z      (input) DOUBLE PRECISION array, dimension (2)
           The components of the updating vector.

    ! 输出参数：双精度数组 DELTA，维度为 (2)
    !           向量 DELTA 包含构建特征向量所需的信息。
    DELTA  (output) DOUBLE PRECISION array, dimension (2)
           The vector DELTA contains the information necessary
           to construct the eigenvectors.

    ! 输入参数：双精度标量 RHO
    !           对称更新公式中的标量。
    RHO    (input) DOUBLE PRECISION
           The scalar in the symmetric updating formula.

    ! 输出参数：双精度标量 DLAM
    !           计算得到的 lambda_I，第 I 个更新后的特征值。
    DLAM   (output) DOUBLE PRECISION
           The computed lambda_I, the I-th updated eigenvalue.

    ! 进一步细节
    ! ==========
    ! 根据以下贡献进行开发：
    !    Ren-Cang Li, 加利福尼亚大学伯克利分校，计算机科学系，美国
    Further Details
    ===============

    Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA

    ! =====================================================================
    /* Parameter adjustments */
    --delta;
    --z__;
    --d__;

    /* Function Body */
    // 计算 del，即 d(2) - d(1)
    del = d__[2] - d__[1];

    // 根据 i__ 的值选择不同的计算分支
    if (*i__ == 1) {
        // 计算 w
        w = *rho * 2. * (z__[2] * z__[2] - z__[1] * z__[1]) / del + 1.;

        // 根据 w 的值进行分支处理
        if (w > 0.) {
            // 计算 b 和 c__
            b = del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[1] * z__[1] * del;

            // 计算 tau，确保分母不为零
            tau = c__ * 2. / (b + sqrt((d__1 = b * b - c__ * 4., abs(d__1))));
            // 计算 dlam 和 delta[1], delta[2]
            *dlam = d__[1] + tau;
            delta[1] = -z__[1] / tau;
            delta[2] = z__[2] / (del - tau);
        } else {
            // 计算 b 和 c__
            b = -del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[2] * z__[2] * del;

            // 根据 b 的值选择不同的计算方法
            if (b > 0.) {
                tau = c__ * -2. / (b + sqrt(b * b + c__ * 4.));
            } else {
                tau = (b - sqrt(b * b + c__ * 4.)) / 2.;
            }
            // 计算 dlam 和 delta[1], delta[2]
            *dlam = d__[2] + tau;
            delta[1] = -z__[1] / (del + tau);
            delta[2] = -z__[2] / tau;
        }

        // 归一化 delta 向量
        temp = sqrt(delta[1] * delta[1] + delta[2] * delta[2]);
        delta[1] /= temp;
        delta[2] /= temp;
    } else {
        // 当 i__ = 2 时的计算分支

        // 计算 b 和 c__
        b = -del + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
        c__ = *rho * z__[2] * z__[2] * del;

        // 根据 b 的值选择不同的计算方法
        if (b > 0.) {
            tau = (b + sqrt(b * b + c__ * 4.)) / 2.;
        } else {
            tau = c__ * 2. / (-b + sqrt(b * b + c__ * 4.));
        }
        // 计算 dlam 和 delta[1], delta[2]
        *dlam = d__[2] + tau;
        delta[1] = -z__[1] / (del + tau);
        delta[2] = -z__[2] / tau;

        // 归一化 delta 向量
        temp = sqrt(delta[1] * delta[1] + delta[2] * delta[2]);
        delta[1] /= temp;
        delta[2] /= temp;
    }

    // 返回 0 表示成功
    return 0;

/*     End OF DLAED5 */

} /* dlaed5_ */
    the root sought is the smallest in magnitude, though it might not be
    in some extremely rare situations.



    Arguments
    =========

    KNITER       (input) INTEGER
                 Refer to DLAED4 for its significance.



    ORGATI       (input) LOGICAL
                 If ORGATI is true, the needed root is between d(2) and
                 d(3); otherwise it is between d(1) and d(2).  See
                 DLAED4 for further details.



    RHO          (input) DOUBLE PRECISION
                 Refer to the equation f(x) above.



    D            (input) DOUBLE PRECISION array, dimension (3)
                 D satisfies d(1) < d(2) < d(3).



    Z            (input) DOUBLE PRECISION array, dimension (3)
                 Each of the elements in z must be positive.



    FINIT        (input) DOUBLE PRECISION
                 The value of f at 0. It is more accurate than the one
                 evaluated inside this routine (if someone wants to do
                 so).



    TAU          (output) DOUBLE PRECISION
                 The root of the equation f(x).



    INFO         (output) INTEGER
                 = 0: successful exit
                 > 0: if INFO = 1, failure to converge



    Further Details
    ===============

    30/06/99: Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA



    10/02/03: This version has a few statements commented out for thread
    safety (machine parameters are computed on each entry). SJH.



    05/10/06: Modified from a new version of Ren-Cang Li, use
       Gragg-Thornton-Warner cubic convergent scheme for better stability.



    =====================================================================
    /* Parameter adjustments */
    --z__;  // z__ 是一个指针，向量 z 的起始地址
    --d__;  // d__ 是一个指针，向量 d 的起始地址

    /* Function Body */
    *info = 0;  // 初始化 info 为 0

    if (*orgati) {  // 如果 orgati 为真
    lbd = d__[2];  // 将 d[2] 赋给 lbd
    ubd = d__[3];  // 将 d[3] 赋给 ubd
    } else {  // 否则
    lbd = d__[1];  // 将 d[1] 赋给 lbd
    ubd = d__[2];  // 将 d[2] 赋给 ubd
    }
    if (*finit < 0.) {  // 如果 finit 小于 0
    lbd = 0.;  // 将 lbd 设为 0
    } else {  // 否则
    ubd = 0.;  // 将 ubd 设为 0
    }

    niter = 1;  // 初始化 niter 为 1
    *tau = 0.;  // 初始化 tau 为 0
    if (*kniter == 2) {  // 如果 kniter 等于 2
    if (*orgati) {  // 如果 orgati 为真
        temp = (d__[3] - d__[2]) / 2.;  // 计算 temp
        c__ = *rho + z__[1] / (d__[1] - d__[2] - temp);  // 计算 c__
        a = c__ * (d__[2] + d__[3]) + z__[2] + z__[3];  // 计算 a
        b = c__ * d__[2] * d__[3] + z__[2] * d__[3] + z__[3] * d__[2];  // 计算 b
    } else {  // 否则
        temp = (d__[1] - d__[2]) / 2.;  // 计算 temp
        c__ = *rho + z__[3] / (d__[3] - d__[2] - temp);  // 计算 c__
        a = c__ * (d__[1] + d__[2]) + z__[1] + z__[2];  // 计算 a
        b = c__ * d__[1] * d__[2] + z__[1] * d__[2] + z__[2] * d__[1];  // 计算 b
    }
/* Computing MAX */
    d__1 = abs(a), d__2 = abs(b), d__1 = max(d__1,d__2), d__2 = abs(c__);
    temp = max(d__1,d__2);  // 计算 temp
    a /= temp;  // 归一化 a
    b /= temp;  // 归一化 b
    c__ /= temp;  // 归一化 c__
    if (c__ == 0.) {  // 如果 c__ 等于 0
        *tau = b / a;  // 计算 tau
    } else if (a <= 0.) {  // 否则如果 a 小于等于 0
        *tau = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
            c__ * 2.);  // 计算 tau
    } else {  // 否则
        *tau = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1))
            ));  // 计算 tau
    }
    if (*tau < lbd || *tau > ubd) {  // 如果 tau 不在 lbd 和 ubd 之间
        *tau = (lbd + ubd) / 2.;  // 将 tau 设置为 lbd 和 ubd 的中间值
    }
    if (d__[1] == *tau || d__[2] == *tau || d__[3] == *tau) {  // 如果 tau 等于 d[1]、d[2] 或 d[3]
        *tau = 0.;  // 将 tau 设为 0
    } else {  // 否则
        temp = *finit + *tau * z__[1] / (d__[1] * (d__[1] - *tau)) + *tau
            * z__[2] / (d__[2] * (d__[2] - *tau)) + *tau * z__[3] / (
            d__[3] * (d__[3] - *tau));  // 计算 temp
        if (temp <= 0.) {  // 如果 temp 小于等于 0
        lbd = *tau;  // 将 tau 赋给 lbd
        } else {  // 否则
        ubd = *tau;  // 将 tau 赋给 ubd
        }
        if (abs(*finit) <= abs(temp)) {  // 如果 finit 的绝对值小于等于 temp 的绝对值
        *tau = 0.;  // 将 tau 设为 0
        }
    }
    }

/*
       get machine parameters for possible scaling to avoid overflow

       modified by Sven: parameters SMALL1, SMINV1, SMALL2,
       SMINV2, EPS are not SAVEd anymore between one call to the
       others but recomputed at each call
*/

    eps = EPSILON;  // 将 EPSILON 赋给 eps
    base = BASE;  // 将 BASE 赋给 base
    i__1 = (integer) (log(SAFEMINIMUM) / log(base) / 3.);  // 计算 i__1
    small1 = pow_di(&base, &i__1);  // 计算 small1
    sminv1 = 1. / small1;  // 计算 sminv1
    small2 = small1 * small1;  // 计算 small2
    sminv2 = sminv1 * sminv1;  // 计算 sminv2

/*
       Determine if scaling of inputs necessary to avoid overflow
       when computing 1/TEMP**3
*/

    if (*orgati) {  // 如果 orgati 为真
/* Computing MIN */
    d__3 = (d__1 = d__[2] - *tau, abs(d__1)), d__4 = (d__2 = d__[3] - *
        tau, abs(d__2));
    temp = min(d__3,d__4);  // 计算 temp
    } else {  // 否则
/* Computing MIN */
    d__3 = (d__1 = d__[1] - *tau, abs(d__1)), d__4 = (d__2 = d__[2] - *
        tau, abs(d__2));
    temp = min(d__3,d__4);  // 计算 temp
    }
    scale = FALSE_;  // 初始化 scale 为 FALSE
    if (temp <= small1) {  // 如果 temp 小于等于 small1
    scale = TRUE_;  // 设置 scale 为 TRUE
    if (temp <= small2) {  // 如果 temp 小于等于 small2

/*        Scale up by power of radix nearest 1/SAFMIN**(2/3) */

        sclfac = sminv2;  // 将 sminv2 赋给 sclfac
        sclinv = small2;  // 将 small2 赋给 sclinv
    } else {  // 否则
/*        Scale up by power of radix nearest 1/SAFMIN**(1/3) */
/*        通过接近 1/SAFMIN**(1/3) 的基数幂来放大 */

sclfac = sminv1;
sclinv = small1;
}

/*        Scaling up safe because D, Z, TAU scaled elsewhere to be O(1) */
/*        由于在其他地方对 D、Z、TAU 进行了缩放使其为 O(1)，因此放大是安全的 */

for (i__ = 1; i__ <= 3; ++i__) {
    dscale[i__ - 1] = d__[i__] * sclfac;
    zscale[i__ - 1] = z__[i__] * sclfac;
/* L10: */
}
*tau *= sclfac;
lbd *= sclfac;
ubd *= sclfac;
} else {

/*        Copy D and Z to DSCALE and ZSCALE */
/*        将 D 和 Z 复制到 DSCALE 和 ZSCALE */

for (i__ = 1; i__ <= 3; ++i__) {
    dscale[i__ - 1] = d__[i__];
    zscale[i__ - 1] = z__[i__];
/* L20: */
}
}

fc = 0.;
df = 0.;
ddf = 0.;
for (i__ = 1; i__ <= 3; ++i__) {
temp = 1. / (dscale[i__ - 1] - *tau);
temp1 = zscale[i__ - 1] * temp;
temp2 = temp1 * temp;
temp3 = temp2 * temp;
fc += temp1 / dscale[i__ - 1];
df += temp2;
ddf += temp3;
/* L30: */
}
f = *finit + *tau * fc;

if (abs(f) <= 0.) {
goto L60;
}
if (f <= 0.) {
lbd = *tau;
} else {
ubd = *tau;
}

/*
      Iteration begins -- Use Gragg-Thornton-Warner cubic convergent
                          scheme

   It is not hard to see that

         1) Iterations will go up monotonically
            if FINIT < 0;

         2) Iterations will go down monotonically
            if FINIT > 0.
*/
/*
      迭代开始 - 使用 Gragg-Thornton-Warner 立方收敛方案

   不难看出：

         1) 如果 FINIT < 0，则迭代会单调增加；

         2) 如果 FINIT > 0，则迭代会单调减少。
*/

iter = niter + 1;

for (niter = iter; niter <= 40; ++niter) {

if (*orgati) {
    temp1 = dscale[1] - *tau;
    temp2 = dscale[2] - *tau;
} else {
    temp1 = dscale[0] - *tau;
    temp2 = dscale[1] - *tau;
}
a = (temp1 + temp2) * f - temp1 * temp2 * df;
b = temp1 * temp2 * f;
c__ = f - (temp1 + temp2) * df + temp1 * temp2 * ddf;
/* Computing MAX */
d__1 = abs(a), d__2 = abs(b), d__1 = max(d__1,d__2), d__2 = abs(c__);
temp = max(d__1,d__2);
a /= temp;
b /= temp;
c__ /= temp;
if (c__ == 0.) {
    eta = b / a;
} else if (a <= 0.) {
    eta = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (c__
        * 2.);
} else {
    eta = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))
        );
}
if (f * eta >= 0.) {
    eta = -f / df;
}

*tau += eta;
if (*tau < lbd || *tau > ubd) {
    *tau = (lbd + ubd) / 2.;
}

fc = 0.;
erretm = 0.;
df = 0.;
ddf = 0.;
for (i__ = 1; i__ <= 3; ++i__) {
    temp = 1. / (dscale[i__ - 1] - *tau);
    temp1 = zscale[i__ - 1] * temp;
    temp2 = temp1 * temp;
    temp3 = temp2 * temp;
    temp4 = temp1 / dscale[i__ - 1];
    fc += temp4;
    erretm += abs(temp4);
    df += temp2;
    ddf += temp3;
/* L40: */
}
f = *finit + *tau * fc;
erretm = (abs(*finit) + abs(*tau) * erretm) * 8. + abs(*tau) * df;
if (abs(f) <= eps * erretm) {
    goto L60;
}
if (f <= 0.) {
    lbd = *tau;
} else {
    ubd = *tau;
}
/* L50: */
}
*info = 1;
L60:
/*     Undo scaling */

if (scale) {
*tau *= sclinv;
}
return 0;


// 如果需要，将 tau 恢复为其未经缩放的值
if (scale) {
*tau *= sclinv;
}
// 返回状态码 0，表明函数执行成功

/*     End of DLAED6 */

} /* dlaed6_ */

/* Subroutine */ int dlaed7_(integer *icompq, integer *n, integer *qsiz,
    integer *tlvls, integer *curlvl, integer *curpbm, doublereal *d__,
    doublereal *q, integer *ldq, integer *indxq, doublereal *rho, integer
    *cutpnt, doublereal *qstore, integer *qptr, integer *prmptr, integer *
    perm, integer *givptr, integer *givcol, doublereal *givnum,
    doublereal *work, integer *iwork, integer *info)
{
/* System generated locals */
integer q_dim1, q_offset, i__1, i__2;

/* Local variables */
static integer i__, k, n1, n2, is, iw, iz, iq2, ptr, ldq2, indx, curr;
extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
    integer *, doublereal *, doublereal *, integer *, doublereal *,
    integer *, doublereal *, doublereal *, integer *);
static integer indxc, indxp;
extern /* Subroutine */ int dlaed8_(integer *, integer *, integer *,
    integer *, doublereal *, doublereal *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
     integer *, doublereal *, integer *, integer *, integer *,
    doublereal *, integer *, integer *, integer *), dlaed9_(integer *,
     integer *, integer *, integer *, doublereal *, doublereal *,
    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
     integer *, integer *), dlaeda_(integer *, integer *, integer *,
    integer *, integer *, integer *, integer *, integer *, doublereal
    *, doublereal *, integer *, doublereal *, doublereal *, integer *);
static integer idlmda;
extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
    integer *, integer *, integer *), xerbla_(char *, integer *);
static integer coltyp;

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006

Purpose
=======

DLAED7 computes the updated eigensystem of a diagonal
matrix after modification by a rank-one symmetric matrix. This
routine is used only for the eigenproblem which requires all
eigenvalues and optionally eigenvectors of a dense symmetric matrix
that has been reduced to tridiagonal form.  DLAED1 handles
the case in which all eigenvalues and eigenvectors of a symmetric
    # 在修复对称三对角矩阵的过程中，通过更新特征值和特征向量来维持对称三对角矩阵的结构。这个过程涉及到将问题的维度逐步缩小和计算更新后的特征值与特征向量。

      T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
       在这里，Z = Q'u，其中 u 是长度为 N 的向量，在 CUTPNT 和 CUTPNT + 1 的位置为1，其他位置为0。
       原矩阵的特征向量存储在 Q 中，特征值存储在 D 中。算法包括三个阶段：

          第一阶段是在存在多个特征值或者 Z 向量中存在零元素时，缩小问题的规模。每次出现这种情况时，通过减少零点的数量来减小截断方程的问题维度。此阶段由例程 DLAED8 执行。

          第二阶段是计算更新后的特征值。通过求解截断方程的根来实现，使用例程 DLAED4（由 DLAED9 调用）。该例程还计算当前问题的特征向量。

          最后阶段是直接计算使用更新后的特征值的更新后的特征向量。当前问题的特征向量与整体问题的特征向量相乘。

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            = 0: 仅计算特征值。
            = 1: 同时计算原始密集对称矩阵的特征向量。在输入时，Q 包含用于将原始矩阵减少为三对角形式的正交矩阵。

    N      (input) INTEGER
           对称三对角矩阵的维度。N >= 0。

    QSIZ   (input) INTEGER
           用于将完整矩阵减少为三对角形式的正交矩阵的维度。如果 ICOMPQ = 1，则 QSIZ >= N。

    TLVLS  (input) INTEGER
           整体分治树中的总合并级别数。

    CURLVL (input) INTEGER
           整体合并例程中的当前级别，0 <= CURLVL <= TLVLS。

    CURPBM (input) INTEGER
           整体合并例程中当前级别的当前问题（从左上到右下计数）。

    D      (input/output) DOUBLE PRECISION 数组，维度为 (N)
           输入时，是受单秩扰动矩阵的特征值。退出时，是修复后矩阵的特征值。

    Q      (input/output) DOUBLE PRECISION 数组，维度为 (LDQ, N)
           输入时，是受单秩扰动矩阵的特征向量。退出时，是修复的三对角矩阵的特征向量。

    LDQ    (input) INTEGER
           数组 Q 的领导维度。LDQ >= max(1,N)。

    INDXQ  (output) INTEGER 数组，维度为 (N)
           将刚解决的子问题重新集成到排序顺序中的置换，即 D( INDXQ( I = 1, N ) ) 将以升序排列。
    ! RHO (输入) 双精度实数
    !      用于创建一级修改的次对角元素。
    ! 
    ! CUTPNT (输入) 整数
    !        包含主导子矩阵中最后一个特征值的位置。min(1,N) <= CUTPNT <= N。
    !
    ! QSTORE (输入/输出) 双精度数组, 维度为 (N**2+1)
    !        存储在分治过程中遇到的子矩阵的特征向量，紧密打包在一起。QPTR 指向
    !        子矩阵的起始位置。
    !
    ! QPTR (输入/输出) 整数数组, 维度为 (N+2)
    !      指示存储在 QSTORE 中子矩阵起始位置的索引列表。子矩阵从分治树的底部
    !      左侧开始编号，从左到右，从底部到顶部。
    !
    ! PRMPTR (输入) 整数数组, 维度为 (N lg N)
    !        包含指针列表，指示每个级别的置换存储在 PERM 中的位置。
    !        PRMPTR(i+1) - PRMPTR(i) 指示置换的大小，也是完整非缩减问题的大小。
    !
    ! PERM (输入) 整数数组, 维度为 (N lg N)
    !      包含要应用于每个特征块的置换（来自缩减和排序）。
    !
    ! GIVPTR (输入) 整数数组, 维度为 (N lg N)
    !        包含指针列表，指示每个级别的 Givens 旋转存储在 GIVCOL 中的位置。
    !        GIVPTR(i+1) - GIVPTR(i) 指示 Givens 旋转的数量。
    !
    ! GIVCOL (输入) 整数数组, 维度为 (2, N lg N)
    !        每对数字指示参与 Givens 旋转的两列。
    !
    ! GIVNUM (输入) 双精度数组, 维度为 (2, N lg N)
    !        每个数字指示对应 Givens 旋转中要使用的 S 值。
    !
    ! WORK (工作空间) 双精度数组, 维度为 (3*N+QSIZ*N)
    !
    ! IWORK (工作空间) 整数数组, 维度为 (4*N)
    !
    ! INFO (输出) 整数
    !      = 0: 成功退出。
    !      < 0: 如果 INFO = -i，则第 i 个参数具有非法值。
    !      > 0: 如果 INFO = 1，则一个特征值未收敛。
    !
    ! 进一步细节
    ! ============
    ! 基于以下贡献
    !    Jeff Rutter, 加利福尼亚大学伯克利分校，美国计算机科学系
    !
    ! =====================================================================
    !
    ! 测试输入参数。
    /* Parameter adjustments */
    --d__;                   // 调整参数 d__ 指针，指向数组 d__ 的第一个元素
    q_dim1 = *ldq;           // 维度参数 q_dim1 等于 ldq
    q_offset = 1 + q_dim1;   // q_offset 设置为 q 的起始偏移量
    q -= q_offset;           // 调整 q 指针，使其指向数组 q 的第一个元素
    --indxq;                 // 调整 indxq 指针，使其指向数组 indxq 的第一个元素
    --qstore;                // 调整 qstore 指针，使其指向数组 qstore 的第一个元素
    --qptr;                  // 调整 qptr 指针，使其指向数组 qptr 的第一个元素
    --prmptr;                // 调整 prmptr 指针，使其指向数组 prmptr 的第一个元素
    --perm;                  // 调整 perm 指针，使其指向数组 perm 的第一个元素
    --givptr;                // 调整 givptr 指针，使其指向数组 givptr 的第一个元素
    givcol -= 3;             // 调整 givcol 指针，使其指向数组 givcol 的第一个元素的偏移量为 -3
    givnum -= 3;             // 调整 givnum 指针，使其指向数组 givnum 的第一个元素的偏移量为 -3
    --work;                  // 调整 work 指针，使其指向数组 work 的第一个元素
    --iwork;                 // 调整 iwork 指针，使其指向数组 iwork 的第一个元素

    /* Function Body */
    *info = 0;               // 初始化 info 为 0

    if (*icompq < 0 || *icompq > 1) {   // 检查 icompq 的值是否在有效范围内
    *info = -1;
    } else if (*n < 0) {                // 检查 n 是否为负数
    *info = -2;
    } else if (*icompq == 1 && *qsiz < *n) {  // 当 icompq 为 1 时，检查 qsiz 是否小于 n
    *info = -4;
    } else if (*ldq < max(1,*n)) {       // 检查 ldq 是否小于 max(1, n)
    *info = -9;
    } else if (min(1,*n) > *cutpnt || *n < *cutpnt) {  // 检查 cutpnt 的范围是否有效
    *info = -12;
    }
    if (*info != 0) {                    // 如果 info 不为 0，则调用错误处理程序 xerbla_
    i__1 = -(*info);
    xerbla_("DLAED7", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {           // 如果 n 等于 0，则直接返回
    return 0;
    }

/*
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in DLAED8 and DLAED9.
*/

    if (*icompq == 1) {       // 根据 icompq 的值选择 ldq2 的大小
    ldq2 = *qsiz;
    } else {
    ldq2 = *n;
    }

    iz = 1;                   // 初始化 iz
    idlmda = iz + *n;         // 初始化 idlmda
    iw = idlmda + *n;         // 初始化 iw
    iq2 = iw + *n;            // 初始化 iq2
    is = iq2 + *n * ldq2;     // 初始化 is

    indx = 1;                 // 初始化 indx
    indxc = indx + *n;        // 初始化 indxc
    coltyp = indxc + *n;      // 初始化 coltyp
    indxp = coltyp + *n;      // 初始化 indxp

/*
       Form the z-vector which consists of the last row of Q_1 and the
       first row of Q_2.
*/

    ptr = pow_ii(&c__2, tlvls) + 1;     // 计算指数函数的结果，并加 1
    i__1 = *curlvl - 1;                 // 计算循环次数
    for (i__ = 1; i__ <= i__1; ++i__) { // 循环处理
    i__2 = *tlvls - i__;                // 计算指数函数的指数
    ptr += pow_ii(&c__2, &i__2);        // 更新 ptr
/* L10: */                             // 循环标签
    }
    curr = ptr + *curpbm;               // 计算 curr 的值
    dlaeda_(n, tlvls, curlvl, curpbm, &prmptr[1], &perm[1], &givptr[1], &
        givcol[3], &givnum[3], &qstore[1], &qptr[1], &work[iz], &work[iz
        + *n], info);                  // 调用 dlaeda_ 函数

/*
       When solving the final problem, we no longer need the stored data,
       so we will overwrite the data from this level onto the previously
       used storage space.
*/

    if (*curlvl == *tlvls) {             // 如果当前层级等于总层级数
    qptr[curr] = 1;                      // 将 qptr[curr] 设置为 1
    prmptr[curr] = 1;                    // 将 prmptr[curr] 设置为 1
    givptr[curr] = 1;                    // 将 givptr[curr] 设置为 1
    }

/*     Sort and Deflate eigenvalues. */

    dlaed8_(icompq, &k, n, qsiz, &d__[1], &q[q_offset], ldq, &indxq[1], rho,
        cutpnt, &work[iz], &work[idlmda], &work[iq2], &ldq2, &work[iw], &
        perm[prmptr[curr]], &givptr[curr + 1], &givcol[(givptr[curr] << 1)
         + 1], &givnum[(givptr[curr] << 1) + 1], &iwork[indxp], &iwork[
        indx], info);                    // 调用 dlaed8_ 函数
    prmptr[curr + 1] = prmptr[curr] + *n; // 更新 prmptr[curr + 1]
    givptr[curr + 1] += givptr[curr];     // 更新 givptr[curr + 1]

/*     Solve Secular Equation. */

    if (k != 0) {                         // 如果 k 不等于 0
    dlaed9_(&k, &c__1, &k, n, &d__[1], &work[is], &k, rho, &work[idlmda],
        &work[iw], &qstore[qptr[curr]], &k, info);  // 调用 dlaed9_ 函数
    if (*info != 0) {                    // 如果 info 不为 0
        goto L30;                        // 跳转到 L30 标签处
    }
    if (*icompq == 1) {                  // 如果 icompq 为 1
        dgemm_("N", "N", qsiz, &k, &k, &c_b15, &work[iq2], &ldq2, &qstore[
            qptr[curr]], &k, &c_b29, &q[q_offset], ldq);  // 调用 dgemm_ 函数
    }
/* Computing 2nd power */
    i__1 = k;                            // 计算 k 的平方
    qptr[curr + 1] = qptr[curr] + i__1 * i__1;  // 更新 qptr[curr + 1]

/*     Prepare the INDXQ sorting permutation. */

    n1 = k;                              // 初始化 n1
    n2 = *n - k;                         // 初始化 n2
    dlamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &indxq[1]);

调用 `dlamrg_` 函数，该函数可能是用于合并排序的子程序，具体作用是合并两个有序序列。


    } else {

如果前面的条件不成立（即前面的 `if` 语句条件为假），执行以下操作：


    qptr[curr + 1] = qptr[curr];

将数组 `qptr` 中索引为 `curr` 的元素的值复制给索引为 `curr + 1` 的位置，实现数组的复制操作。


    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

对于变量 `i__` 从 1 到 `*n` 进行循环遍历：


        indxq[i__] = i__;

将索引 `i__` 的值设置为 `i__`，初始化或重置 `indxq` 数组的值，使其顺序包含整数序列 `1` 到 `*n`。
/* L20: */
    }
    }

L30:
    return 0;

/*     End of DLAED7 */

} /* dlaed7_ */

/* Subroutine */ int dlaed8_(integer *icompq, integer *k, integer *n, integer
    *qsiz, doublereal *d__, doublereal *q, integer *ldq, integer *indxq,
    doublereal *rho, integer *cutpnt, doublereal *z__, doublereal *dlamda,
    doublereal *q2, integer *ldq2, doublereal *w, integer *perm, integer
    *givptr, integer *givcol, doublereal *givnum, integer *indxp, integer
    *indx, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, q2_dim1, q2_offset, i__1;
    doublereal d__1;

    /* Local variables */
    static doublereal c__;
    static integer i__, j;
    static doublereal s, t;
    static integer k2, n1, n2, jp, n1p1;
    static doublereal eps, tau, tol;
    static integer jlam, imax, jmax;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *), dscal_(
        integer *, doublereal *, doublereal *, integer *), dcopy_(integer
        *, doublereal *, integer *, doublereal *, integer *);

    extern integer idamax_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *), dlacpy_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLAED8 merges the two sets of eigenvalues together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    eigenvalues are close together or if there is a tiny element in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.

    K      (output) INTEGER
           The number of non-deflated eigenvalues, and the order of the
           related secular equation.

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    QSIZ   (input) INTEGER
           The dimension of the orthogonal matrix used to reduce
           the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
*/
    D      (input/output) DOUBLE PRECISION array, dimension (N)
           ! 入口时，包含待合并的两个子矩阵的特征值。出口时，包含排列成递增顺序的尾部(N-K)更新后的特征值（已缩减的特征值）。

    Q      (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
           ! 如果 ICOMPQ = 0，则不引用 Q。否则，
           ! 入口时，Q 包含先前与其他部分解决的特征系统在矩阵乘法中更新过的部分解决系统的特征向量。
           ! 出口时，Q 包含其最后 N-K 列中排列成递增顺序的尾部(N-K)更新后的特征向量（已缩减的特征向量）。

    LDQ    (input) INTEGER
           ! 数组 Q 的主维度。LDQ >= max(1,N)。

    INDXQ  (input) INTEGER array, dimension (N)
           ! 将数组 D 中的两个子问题分别按升序排列的置换。注意，第二半部分的这些置换元素必须先加上 CUTPNT 以便准确。

    RHO    (input/output) DOUBLE PRECISION
           ! 入口时，与原始分割两个现在重新组合的子矩阵的秩-1截断相关的非对角线元素。
           ! 出口时，RHO 已被修改为 DLAED3 所需的值。

    CUTPNT (input) INTEGER
           ! 主子矩阵中最后一个特征值的位置。min(1,N) <= CUTPNT <= N。

    Z      (input) DOUBLE PRECISION array, dimension (N)
           ! 入口时，包含更新向量（第一个子特征向量矩阵的最后一行和第二个子特征向量矩阵的第一行）。
           ! 出口时，Z 的内容已被更新过程破坏。

    DLAMDA (output) DOUBLE PRECISION array, dimension (N)
           ! 将由 DLAED3 使用的第一个 K 个特征值的副本，用于形成封闭方程。

    Q2     (output) DOUBLE PRECISION array, dimension (LDQ2,N)
           ! 如果 ICOMPQ = 0，则不引用 Q2。否则，
           ! DLAED7 中的矩阵乘法（DGEMM）将使用的第一个 K 个特征向量的副本。

    LDQ2   (input) INTEGER
           ! 数组 Q2 的主维度。LDQ2 >= max(1,N)。

    W      (output) DOUBLE PRECISION array, dimension (N)
           ! 最终缩减变更的 z-向量的前 k 个值，将传递给 DLAED3。

    PERM   (output) INTEGER array, dimension (N)
           ! 将应用于每个特征块的排列（来自缩减和排序）。

    GIVPTR (output) INTEGER
           ! 在这个子问题中发生的 Givens 旋转的数量。
    # GIVCOL (output) INTEGER array, dimension (2, N)
    # 每一对数字表示进行 Givens 旋转的一对列的索引

    # GIVNUM (output) DOUBLE PRECISION array, dimension (2, N)
    # 每个数字表示对应 Givens 旋转中使用的 S 值

    # INDXP  (workspace) INTEGER array, dimension (N)
    # 用于将 D 的缩减值放置在数组末尾的排列。INDXP(1:K) 指向非缩减的 D 值，INDXP(K+1:N) 指向缩减的特征值。

    # INDX   (workspace) INTEGER array, dimension (N)
    # 用于将 D 的内容按升序排序的排列。

    # INFO   (output) INTEGER
    # = 0: 成功退出。
    # < 0: 如果 INFO = -i，则第 i 个参数具有非法值。

    # Further Details
    # ===============
    # 根据以下贡献提供信息：
    #    Jeff Rutter，加州大学伯克利分校计算机科学系，美国

    # =====================================================================

    # 测试输入参数。
    /* Parameter adjustments */
    --d__;                   // 调整参数数组 d__
    q_dim1 = *ldq;           // 计算矩阵 Q 的第一维度大小
    q_offset = 1 + q_dim1;   // 计算 Q 数组的偏移量
    q -= q_offset;           // 调整 Q 数组的起始位置
    --indxq;                 // 调整参数数组 indxq
    --z__;                   // 调整参数数组 z__
    --dlamda;                // 调整参数数组 dlamda
    q2_dim1 = *ldq2;         // 计算矩阵 Q2 的第一维度大小
    q2_offset = 1 + q2_dim1; // 计算 Q2 数组的偏移量
    q2 -= q2_offset;         // 调整 Q2 数组的起始位置
    --w;                     // 调整参数数组 w
    --perm;                  // 调整参数数组 perm
    givcol -= 3;             // 调整参数数组 givcol
    givnum -= 3;             // 调整参数数组 givnum
    --indxp;                 // 调整参数数组 indxp
    --indx;                  // 调整参数数组 indx

    /* Function Body */
    *info = 0;               // 将 info 初始化为 0

    if (*icompq < 0 || *icompq > 1) {  // 检查参数 icompq 的有效性
        *info = -1;
    } else if (*n < 0) {                // 检查参数 n 的有效性
        *info = -3;
    } else if (*icompq == 1 && *qsiz < *n) {  // 检查参数 icompq 和 qsiz 的有效性
        *info = -4;
    } else if (*ldq < max(1,*n)) {      // 检查参数 ldq 的有效性
        *info = -7;
    } else if (*cutpnt < min(1,*n) || *cutpnt > *n) {  // 检查参数 cutpnt 的有效性
        *info = -10;
    } else if (*ldq2 < max(1,*n)) {     // 检查参数 ldq2 的有效性
        *info = -14;
    }
    if (*info != 0) {         // 如果有错误信息，则调用 xerbla 函数报错并返回
        i__1 = -(*info);
        xerbla_("DLAED8", &i__1);
        return 0;
    }

    /*
       Need to initialize GIVPTR to O here in case of quick exit
       to prevent an unspecified code behavior (usually sigfault)
       when IWORK array on entry to *stedc is not zeroed
       (or at least some IWORK entries which used in *laed7 for GIVPTR).
    */
    *givptr = 0;  // 初始化 givptr 为 0，以防止未初始化导致的问题

    /* Quick return if possible */
    if (*n == 0) {  // 如果 n 为 0，则直接返回
        return 0;
    }

    n1 = *cutpnt;   // 设置 n1 为 cutpnt
    n2 = *n - n1;   // 设置 n2 为 n - cutpnt
    n1p1 = n1 + 1;  // 设置 n1p1 为 n1 + 1

    if (*rho < 0.) {  // 如果 rho 小于 0，则对 z__ 的部分进行缩放
        dscal_(&n2, &c_b151, &z__[n1p1], &c__1);
    }

    /* Normalize z so that norm(z) = 1 */
    t = 1. / sqrt(2.);  // 计算缩放系数 t
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        indx[j] = j;  // 初始化 indx 数组
    }
    dscal_(n, &t, &z__[1], &c__1);  // 对 z__ 进行缩放
    *rho = (d__1 = *rho * 2., abs(d__1));  // 更新 rho 的值

    /* Sort the eigenvalues into increasing order */
    i__1 = *n;
    for (i__ = *cutpnt + 1; i__ <= i__1; ++i__) {
        indxq[i__] += *cutpnt;  // 更新 indxq 数组
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dlamda[i__] = d__[indxq[i__]];  // 更新 dlamda 数组
        w[i__] = z__[indxq[i__]];        // 更新 w 数组
    }
    i__ = 1;
    j = *cutpnt + 1;
    dlamrg_(&n1, &n2, &dlamda[1], &c__1, &c__1, &indx[1]);  // 对 dlamda 和 indx 进行排序
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        d__[i__] = dlamda[indx[i__]];  // 根据排序更新 d__ 数组
        z__[i__] = w[indx[i__]];       // 根据排序更新 z__ 数组
    }

    /* Calculate the allowable deflation tolerence */
    imax = idamax_(n, &z__[1], &c__1);  // 计算 z__ 中绝对值最大元素的索引
    jmax = idamax_(n, &d__[1], &c__1);  // 计算 d__ 中绝对值最大元素的索引
    eps = EPSILON;  // 获取机器精度
    tol = eps * 8. * (d__1 = d__[jmax], abs(d__1));  // 计算容许的累积阈值

    /*
       If the rank-1 modifier is small enough, no more needs to be done
       except to reorganize Q so that its columns correspond with the
       elements in D.
    */
    if (*rho * (d__1 = z__[imax], abs(d__1)) <= tol) {
        *k = 0;  // 设置 k 为 0
        if (*icompq == 0) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                perm[j] = indxq[indx[j]];  // 根据 indxq 和 indx 更新 perm 数组
            }
        } else {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                perm[j] = indxq[indx[j]];  // 根据 indxq 和 indx 更新 perm 数组
                dcopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1
                    + 1], &c__1);          // 复制 Q 的列到 Q2
            }
            dlacpy_("A", qsiz, n, &q2[q2_dim1 + 1], ldq2, &q[q_dim1 + 1], ldq);  // 复制 Q2 到 Q
        }
        return 0;
    }
/*
   如果存在多个特征值，则问题会进行缩减。在这里找到相等特征值的数量。
   每当找到一个相等的特征值时，就计算一个元素反射器，以旋转对应的特征子空间，
   使得在这个新基础上 Z 的相应分量为零。
*/

*k = 0;                 // 初始化相等特征值计数器为0
k2 = *n + 1;            // k2 初始值为 n + 1
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
if (*rho * (d__1 = z__[j], abs(d__1)) <= tol) {

/*           由于 z 分量很小，进行缩减。 */

    --k2;               // k2 减一
    indxp[k2] = j;      // 记录缩减的特征值索引
    if (j == *n) {
    goto L110;          // 若 j 等于 n，则跳转到 L110
    }
} else {
    jlam = j;           // 记录当前的特征值索引
    goto L80;           // 跳转到 L80
}
/* L70: */
}
L80:
++j;                    // j 自增
if (j > *n) {
goto L100;              // 若 j 大于 n，则跳转到 L100
}
if (*rho * (d__1 = z__[j], abs(d__1)) <= tol) {

/*        由于 z 分量很小，进行缩减。 */

--k2;                   // k2 减一
indxp[k2] = j;          // 记录缩减的特征值索引
} else {

/*        检查特征值是否足够接近以允许缩减。 */

s = z__[jlam];          // s 为之前记录的特征值
c__ = z__[j];           // c__ 为当前特征值

/*
      找到 sqrt(a**2+b**2)，避免溢出或破坏性下溢。
*/

tau = dlapy2_(&c__, &s);    // 计算 sqrt(c__^2 + s^2)
t = d__[j] - d__[jlam];     // t 为对应特征值的差
c__ /= tau;
s = -s / tau;
if ((d__1 = t * c__ * s, abs(d__1)) <= tol) {

/*           可以进行缩减。 */

    z__[j] = tau;           // 更新特征值
    z__[jlam] = 0.;         // 将之前的特征值置零

/*           记录适当的 Givens 旋转 */

    ++(*givptr);            // Givens 旋转计数器加一
    givcol[(*givptr << 1) + 1] = indxq[indx[jlam]];  // 记录索引
    givcol[(*givptr << 1) + 2] = indxq[indx[j]];     // 记录索引
    givnum[(*givptr << 1) + 1] = c__;                // 记录旋转参数
    givnum[(*givptr << 1) + 2] = s;                  // 记录旋转参数
    if (*icompq == 1) {
    drot_(qsiz, &q[indxq[indx[jlam]] * q_dim1 + 1], &c__1, &q[
        indxq[indx[j]] * q_dim1 + 1], &c__1, &c__, &s);  // 对 Q 进行旋转
    }
    t = d__[jlam] * c__ * c__ + d__[j] * s * s;     // 更新特征值
    d__[j] = d__[jlam] * s * s + d__[j] * c__ * c__; // 更新特征值
    d__[jlam] = t;          // 更新特征值
    --k2;                   // k2 减一
    i__ = 1;
L90:
    if (k2 + i__ <= *n) {
    if (d__[jlam] < d__[indxp[k2 + i__]]) {
        indxp[k2 + i__ - 1] = indxp[k2 + i__];     // 调整索引顺序
        indxp[k2 + i__] = jlam;                    // 插入 jlam
        ++i__;
        goto L90;
    } else {
        indxp[k2 + i__ - 1] = jlam;                // 插入 jlam
    }
    } else {
    indxp[k2 + i__ - 1] = jlam;                    // 插入 jlam
    }
    jlam = j;               // 更新 jlam
} else {
    ++(*k);                 // 特征值计数加一
    w[*k] = z__[jlam];      // 记录特征值
    dlamda[*k] = d__[jlam]; // 记录特征值对应的原始特征值
    indxp[*k] = jlam;       // 记录特征值索引
    jlam = j;               // 更新 jlam
}
}
goto L80;                   // 跳转到 L80
L100:

/*     记录最后一个特征值。 */

++(*k);                     // 特征值计数加一
w[*k] = z__[jlam];          // 记录特征值
dlamda[*k] = d__[jlam];     // 记录特征值对应的原始特征值
indxp[*k] = jlam;           // 记录特征值索引

L110:

/*
   对特征值和相应的特征向量按 DLAMDA 和 Q2 进行排序。
   没有缩减的特征值/向量放在 DLAMDA 和 Q2 的前 K 个位置，
   而缩减了的放在后面的 N - K 个位置。
*/

if (*icompq == 0) {
i__1 = *n;
    // 对于每一个 j 从 1 到 i__1 执行循环，其中 i__1 是一个变量或常量
    for (j = 1; j <= i__1; ++j) {
        // 将 indxp 数组中第 j 个位置的值赋给 jp
        jp = indxp[j];
        // 将 d__ 数组中 indxp[j] 索引位置的值赋给 dlamda[j]
        dlamda[j] = d__[jp];
        // 将 indxq 数组中 indx[jp] 索引位置的值赋给 perm[j]
        perm[j] = indxq[indx[jp]];
/*
   L120: */
    }
    } else {
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        jp = indxp[j];
        dlamda[j] = d__[jp];
        perm[j] = indxq[indx[jp]];
        dcopy_(qsiz, &q[perm[j] * q_dim1 + 1], &c__1, &q2[j * q2_dim1 + 1]
            , &c__1);
/* L130: */
    }
    }

/*
       The deflated eigenvalues and their corresponding vectors go back
       into the last N - K slots of D and Q respectively.
*/

    if (*k < *n) {
    if (*icompq == 0) {
        i__1 = *n - *k;
        dcopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
    } else {
        i__1 = *n - *k;
        dcopy_(&i__1, &dlamda[*k + 1], &c__1, &d__[*k + 1], &c__1);
        i__1 = *n - *k;
        dlacpy_("A", qsiz, &i__1, &q2[(*k + 1) * q2_dim1 + 1], ldq2, &q[(*
            k + 1) * q_dim1 + 1], ldq);
    }
    }

    return 0;

/*     End of DLAED8 */

} /* dlaed8_ */

/* Subroutine */ int dlaed9_(integer *k, integer *kstart, integer *kstop,
    integer *n, doublereal *d__, doublereal *q, integer *ldq, doublereal *
    rho, doublereal *dlamda, doublereal *w, doublereal *s, integer *lds,
    integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, s_dim1, s_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j;
    static doublereal temp;
    extern doublereal dnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dlaed4_(integer *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, integer *);
    extern doublereal dlamc3_(doublereal *, doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAED9 finds the roots of the secular equation, as defined by the
    values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
    appropriate calls to DLAED4 and then stores the new matrix of
    eigenvectors for use in calculating the next level of Z vectors.

    Arguments
    =========

    K       (input) INTEGER
            The number of terms in the rational function to be solved by
            DLAED4.  K >= 0.

    KSTART  (input) INTEGER
    KSTOP   (input) INTEGER
            The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
            are to be computed.  1 <= KSTART <= KSTOP <= K.

    N       (input) INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (delation may result in N > K).

    D       (output) DOUBLE PRECISION array, dimension (N)
            D(I) contains the updated eigenvalues
            for KSTART <= I <= KSTOP.

    Q       (workspace) DOUBLE PRECISION array, dimension (LDQ,N)
*/
    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).
            Q 数组的前导维度。LDQ 必须满足 LDQ >= max( 1, N )。

    RHO     (input) DOUBLE PRECISION
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.
            在一阶更新方程中的参数值。需要 RHO >= 0。

    DLAMDA  (input) DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.
            这个数组的前 K 个元素包含了旧的根，用于处理累计更新问题。这些是时序方程的极点。

    W       (input) DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector.
            这个数组的前 K 个元素包含了处理后的累计更新向量的各分量。

    S       (output) DOUBLE PRECISION array, dimension (LDS, K)
            Will contain the eigenvectors of the repaired matrix which
            will be stored for subsequent Z vector calculation and
            multiplied by the previously accumulated eigenvectors
            to update the system.
            将包含修复矩阵的特征向量，用于存储后续的 Z 向量计算，并与先前累计的特征向量相乘以更新系统。

    LDS     (input) INTEGER
            The leading dimension of S.  LDS >= max( 1, K ).
            S 数组的前导维度。LDS 必须满足 LDS >= max( 1, K )。

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            返回值：
            = 0：成功退出。
            < 0：如果 INFO = -i，则第 i 个参数值非法。
            > 0：如果 INFO = 1，则某个特征值未收敛。

    Further Details
    ===============

    Based on contributions by
       Jeff Rutter, Computer Science Division, University of California
       at Berkeley, USA
    根据 Jeff Rutter 在美国加州大学伯克利分校计算机科学系的贡献。

    =====================================================================


       Test the input parameters.
       测试输入参数是否合法。
    /* Parameter adjustments */
    --d__;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --dlamda;
    --w;
    s_dim1 = *lds;
    s_offset = 1 + s_dim1;
    s -= s_offset;

    /* Function Body */
    *info = 0;

    if (*k < 0) {
    *info = -1;
    } else if (*kstart < 1 || *kstart > max(1,*k)) {
    *info = -2;
    } else if (max(1,*kstop) < *kstart || *kstop > max(1,*k)) {
    *info = -3;
    } else if (*n < *k) {
    *info = -4;
    } else if (*ldq < max(1,*k)) {
    *info = -7;
    } else if (*lds < max(1,*k)) {
    *info = -12;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DLAED9", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*k == 0) {
    return 0;
    }

/*
       Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
       which on any of these machines zeros out the bottommost
       bit of DLAMDA(I) if it is 1; this makes the subsequent
       subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DLAMDA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DLAMDA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DLAMBDA(I) to prevent optimizing compilers from eliminating
       this code.
*/

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    dlamda[i__] = dlamc3_(&dlamda[i__], &dlamda[i__]) - dlamda[i__];
/* L10: */
    }

    i__1 = *kstop;
    for (j = *kstart; j <= i__1; ++j) {
    dlaed4_(k, &j, &dlamda[1], &w[1], &q[j * q_dim1 + 1], rho, &d__[j],
        info);

/*        If the zero finder fails, the computation is terminated. */

    if (*info != 0) {
        goto L120;
    }
/* L20: */
    }

    if (*k == 1 || *k == 2) {
    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = *k;
        for (j = 1; j <= i__2; ++j) {
        s[j + i__ * s_dim1] = q[j + i__ * q_dim1];
/* L30: */
        }
/* L40: */
    }
    goto L120;
    }

/*     Compute updated W. */

    dcopy_(k, &w[1], &c__1, &s[s_offset], &c__1);

/*     Initialize W(I) = Q(I,I) */

    i__1 = *ldq + 1;
    dcopy_(k, &q[q_offset], &i__1, &w[1], &c__1);
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    i__2 = j - 1;
    for (i__ = 1; i__ <= i__2; ++i__) {
        w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
/* L50: */
    }
    i__2 = *k;
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        w[i__] *= q[i__ + j * q_dim1] / (dlamda[i__] - dlamda[j]);
/* L60: */
    }
/* L70: */
    }
    i__1 = *k;
    // 循环遍历数组 w，计算其每个元素的负数的平方根并取负号
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 计算 w[i__] 的负数的平方根
        d__1 = sqrt(-w[i__]);
        // 将该平方根值乘以 s[i__+s_dim1] 的符号，并赋值给 w[i__]
        w[i__] = d_sign(&d__1, &s[i__ + s_dim1]);
    }
/* L80: */
    }

/*     Compute eigenvectors of the modified rank-1 modification. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        q[i__ + j * q_dim1] = w[i__] / q[i__ + j * q_dim1];
/* L90: */
    }
    temp = dnrm2_(k, &q[j * q_dim1 + 1], &c__1);
    i__2 = *k;
    for (i__ = 1; i__ <= i__2; ++i__) {
        s[i__ + j * s_dim1] = q[i__ + j * q_dim1] / temp;
/* L100: */
    }
/* L110: */
    }

L120:
    return 0;

/*     End of DLAED9 */

} /* dlaed9_ */

/* Subroutine */ int dlaeda_(integer *n, integer *tlvls, integer *curlvl,
    integer *curpbm, integer *prmptr, integer *perm, integer *givptr,
    integer *givcol, doublereal *givnum, doublereal *q, integer *qptr,
    doublereal *z__, doublereal *ztemp, integer *info)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k, mid, ptr;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);
    static integer curr, bsiz1, bsiz2, psiz1, psiz2, zptr1;
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *), dcopy_(integer *,
        doublereal *, integer *, doublereal *, integer *), xerbla_(char *,
         integer *);

/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    DLAEDA computes the Z vector corresponding to the merge step in the
    CURLVLth step of the merge process with TLVLS steps for the CURPBMth
    problem.

    Arguments
    =========

    N      (input) INTEGER
           The dimension of the symmetric tridiagonal matrix.  N >= 0.

    TLVLS  (input) INTEGER
           The total number of merging levels in the overall divide and
           conquer tree.

    CURLVL (input) INTEGER
           The current level in the overall merge routine,
           0 <= curlvl <= tlvls.

    CURPBM (input) INTEGER
           The current problem in the current level in the overall
           merge routine (counting from upper left to lower right).

    PRMPTR (input) INTEGER array, dimension (N lg N)
           Contains a list of pointers which indicate where in PERM a
           level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
           indicates the size of the permutation and incidentally the
           size of the full, non-deflated problem.

    PERM   (input) INTEGER array, dimension (N lg N)
           Contains the permutations (from deflation and sorting) to be
           applied to each eigenblock.
*/


注释部分包括了对每个变量和数组的功能性描述，以及对函数用途的总结。
       ! 测试输入参数的合法性
       IF (N .LT. 0) THEN
           ! 如果 N 小于零，设置错误码并退出
           INFO = -1
           RETURN
       END IF

       ! 检查指针数组 GIVPTR 的长度是否大于等于 N+1
       IF (SIZE(GIVPTR) .LT. N+1) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -2
           RETURN
       END IF

       ! 检查列索引数组 GIVCOL 的维度是否为 (2, N lg N)
       IF (SIZE(GIVCOL, 1) .NE. 2 .OR. SIZE(GIVCOL, 2) .NE. N * LOG(N)) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -3
           RETURN
       END IF

       ! 检查旋转值数组 GIVNUM 的维度是否为 (2, N lg N)
       IF (SIZE(GIVNUM, 1) .NE. 2 .OR. SIZE(GIVNUM, 2) .NE. N * LOG(N)) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -4
           RETURN
       END IF

       ! 检查 Q 数组的长度是否为 N**2
       IF (SIZE(Q) .NE. N**2) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -5
           RETURN
       END IF

       ! 检查指针数组 QPTR 的长度是否大于等于 N+2
       IF (SIZE(QPTR) .LT. N+2) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -6
           RETURN
       END IF

       ! 检查输出数组 Z 的长度是否为 N
       IF (SIZE(Z) .NE. N) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -7
           RETURN
       END IF

       ! 检查临时工作数组 ZTEMP 的长度是否为 N
       IF (SIZE(ZTEMP) .NE. N) THEN
           ! 如果不满足条件，设置错误码并退出
           INFO = -8
           RETURN
       END IF

       ! 默认情况下，将错误码设置为 0，表示成功
       INFO = 0
       RETURN
    /* Parameter adjustments */
    --ztemp;
    --z__;
    --qptr;
    --q;
    givnum -= 3;
    givcol -= 3;
    --givptr;
    --perm;
    --prmptr;

    /* Function Body */
    *info = 0;

    if (*n < 0) {
        *info = -1;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLAEDA", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /* Determine location of first number in second half. */
    mid = *n / 2 + 1;

    /* Gather last/first rows of appropriate eigenblocks into center of Z */
    ptr = 1;

    /*
       Determine location of lowest level subproblem in the full storage
       scheme
    */
    i__1 = *curlvl - 1;
    curr = ptr + *curpbm * pow_ii(&c__2, curlvl) + pow_ii(&c__2, &i__1) - 1;

    /*
       Determine size of these matrices.  We add HALF to the value of
       the SQRT in case the machine underestimates one of these square
       roots.
    */
    bsiz1 = (integer) (sqrt((doublereal) (qptr[curr + 1] - qptr[curr])) + .5);
    bsiz2 = (integer) (sqrt((doublereal) (qptr[curr + 2] - qptr[curr + 1])) +
                      .5);
    i__1 = mid - bsiz1 - 1;
    for (k = 1; k <= i__1; ++k) {
        z__[k] = 0.;
    }

    dcopy_(&bsiz1, &q[qptr[curr] + bsiz1 - 1], &bsiz1, &z__[mid - bsiz1], &c__1);
    dcopy_(&bsiz2, &q[qptr[curr + 1]], &bsiz2, &z__[mid], &c__1);

    i__1 = *n;
    for (k = mid + bsiz2; k <= i__1; ++k) {
        z__[k] = 0.;
    }

    /*
       Loop through remaining levels 1 -> CURLVL applying the Givens
       rotations and permutation and then multiplying the center matrices
       against the current Z.
    */
    ptr = pow_ii(&c__2, tlvls) + 1;
    i__1 = *curlvl - 1;
    for (k = 1; k <= i__1; ++k) {
        i__2 = *curlvl - k;
        i__3 = *curlvl - k - 1;
        curr = ptr + *curpbm * pow_ii(&c__2, &i__2) + pow_ii(&c__2, &i__3) - 1;
        psiz1 = prmptr[curr + 1] - prmptr[curr];
        psiz2 = prmptr[curr + 2] - prmptr[curr + 1];
        zptr1 = mid - psiz1;

        /* Apply Givens at CURR and CURR+1 */
        i__2 = givptr[curr + 1] - 1;
        for (i__ = givptr[curr]; i__ <= i__2; ++i__) {
            drot_(&c__1, &z__[zptr1 + givcol[(i__ << 1) + 1] - 1], &c__1,
                  &z__[zptr1 + givcol[(i__ << 1) + 2] - 1], &c__1,
                  &givnum[(i__ << 1) + 1], &givnum[(i__ << 1) + 2]);
        }

        i__2 = givptr[curr + 2] - 1;
        for (i__ = givptr[curr + 1]; i__ <= i__2; ++i__) {
            drot_(&c__1, &z__[mid - 1 + givcol[(i__ << 1) + 1]], &c__1,
                  &z__[mid - 1 + givcol[(i__ << 1) + 2]], &c__1,
                  &givnum[(i__ << 1) + 1], &givnum[(i__ << 1) + 2]);
        }

        psiz1 = prmptr[curr + 1] - prmptr[curr];
        psiz2 = prmptr[curr + 2] - prmptr[curr + 1];
        i__2 = psiz1 - 1;
        for (i__ = 0; i__ <= i__2; ++i__) {
            ztemp[i__ + 1] = z__[zptr1 + perm[prmptr[curr] + i__] - 1];
        }
    }
    # 循环遍历索引范围从 0 到 i__2
    for (i__ = 0; i__ <= i__2; ++i__) {
        # 将 z__ 中的特定元素复制到 ztemp 中的特定位置
        ztemp[psiz1 + i__ + 1] = z__[mid + perm[prmptr[curr + 1] + i__] - 1];
/* L60: */
    }

/*
          Multiply Blocks at CURR and CURR+1

          Determine size of these matrices.  We add HALF to the value of
          the SQRT in case the machine underestimates one of these
          square roots.
*/

    bsiz1 = (integer) (sqrt((doublereal) (qptr[curr + 1] - qptr[curr])) +
        .5);
    bsiz2 = (integer) (sqrt((doublereal) (qptr[curr + 2] - qptr[curr + 1])
        ) + .5);
    if (bsiz1 > 0) {
        dgemv_("T", &bsiz1, &bsiz1, &c_b15, &q[qptr[curr]], &bsiz1, &
            ztemp[1], &c__1, &c_b29, &z__[zptr1], &c__1);
    }
    i__2 = psiz1 - bsiz1;
    dcopy_(&i__2, &ztemp[bsiz1 + 1], &c__1, &z__[zptr1 + bsiz1], &c__1);
    if (bsiz2 > 0) {
        dgemv_("T", &bsiz2, &bsiz2, &c_b15, &q[qptr[curr + 1]], &bsiz2, &
            ztemp[psiz1 + 1], &c__1, &c_b29, &z__[mid], &c__1);
    }
    i__2 = psiz2 - bsiz2;
    dcopy_(&i__2, &ztemp[psiz1 + bsiz2 + 1], &c__1, &z__[mid + bsiz2], &
        c__1);

    i__2 = *tlvls - k;
    ptr += pow_ii(&c__2, &i__2);
/* L70: */
    }

    return 0;

/*     End of DLAEDA */

} /* dlaeda_ */

/* Subroutine */ int dlaev2_(doublereal *a, doublereal *b, doublereal *c__,
    doublereal *rt1, doublereal *rt2, doublereal *cs1, doublereal *sn1)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    static doublereal ab, df, cs, ct, tb, sm, tn, rt, adf, acs;
    static integer sgn1, sgn2;
    static doublereal acmn, acmx;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
       [  A   B  ]
       [  B   C  ].
    On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
    eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
    eigenvector for RT1, giving the decomposition

       [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
       [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].

    Arguments
    =========

    A       (input) DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.

    B       (input) DOUBLE PRECISION
            The (1,2) element and the conjugate of the (2,1) element of
            the 2-by-2 matrix.

    C       (input) DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.

    RT1     (output) DOUBLE PRECISION
            The eigenvalue of larger absolute value.

    RT2     (output) DOUBLE PRECISION
            The eigenvalue of smaller absolute value.

    CS1     (output) DOUBLE PRECISION
    SN1     (output) DOUBLE PRECISION
            The vector (CS1, SN1) is a unit right eigenvector for RT1.

    Further Details
    ===============

    RT1 is accurate to a few ulps barring over/underflow.

    RT2 may be inaccurate if there is massive cancellation in the
*/
    determinant A*C-B*B; higher precision or correctly rounded or
    correctly truncated arithmetic would be needed to compute RT2
    accurately in all cases.


# 计算行列式 A*C-B*B；在所有情况下精确计算 RT2 需要更高精度或正确舍入的算术。



    CS1 and SN1 are accurate to a few ulps barring over/underflow.


# CS1 和 SN1 准确到几个 ulp（单位最后位）除非发生过度/欠流。



    Overflow is possible only if RT1 is within a factor of 5 of overflow.
    Underflow is harmless if the input data is 0 or exceeds
       underflow_threshold / macheps.


# 只有在 RT1 接近溢出的 5 倍因子时才可能发生溢出。
# 如果输入数据为 0 或超过 underflow_threshold / macheps，则欠流是无害的。



   =====================================================================


# 分隔线，标志着下一节的开始



       Compute the eigenvalues


# 计算特征值
    sm = *a + *c__;

计算两个指针所指向的变量的和，将结果保存在变量 `sm` 中。


    df = *a - *c__;

计算两个指针所指向的变量的差，将结果保存在变量 `df` 中。


    adf = abs(df);

计算 `df` 的绝对值，将结果保存在变量 `adf` 中。


    tb = *b + *b;

将指针 `b` 所指向的变量的值乘以2，将结果保存在变量 `tb` 中。


    ab = abs(tb);

计算 `tb` 的绝对值，将结果保存在变量 `ab` 中。


    if (abs(*a) > abs(*c__)) {

判断 `a` 指针指向的变量的绝对值是否大于 `c` 指针指向的变量的绝对值。


    acmx = *a;
    acmn = *c__;

如果上述条件成立，将 `a` 指针指向的变量的值赋给 `acmx`，将 `c` 指针指向的变量的值赋给 `acmn`；否则交换赋值。


    if (adf > ab) {

如果 `adf` 大于 `ab`，执行以下操作：


    d__1 = ab / adf;
    rt = adf * sqrt(d__1 * d__1 + 1.);

计算一个数的平方根。


    } else if (adf < ab) {

如果 `adf` 小于 `ab`，执行以下操作：


    d__1 = adf / ab;
    rt = ab * sqrt(d__1 * d__1 + 1.);

计算一个数的平方根。


    } else {

如果 `adf` 等于 `ab`，执行以下操作：


    rt = ab * sqrt(2.);

计算一个数的平方根。


    if (sm < 0.) {

如果 `sm` 小于0，执行以下操作：


    *rt1 = (sm - rt) * .5;

执行以下操作。


    } else if (sm > 0.) {
`` are
    # 声明外部函数 dlanv2_ 和 dlasy2_，这些函数是在其他地方定义的子程序
    extern /* Subroutine */ int dlanv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *), dlasy2_(
        logical *, logical *, integer *, integer *, integer *, doublereal
        *, integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);

    # 声明外部函数 dlamch_ 和 dlange_，这些函数是在其他地方定义的，用于计算数值和范数
    extern doublereal dlamch_(char *), dlange_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *);

    # 声明外部子程序 dlarfg_ 和 dlacpy_，这些子程序在其他地方定义，用于向量操作和矩阵复制
    extern /* Subroutine */ int dlarfg_(integer *, doublereal *, doublereal *,
         integer *, doublereal *), dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *);

    # 声明外部函数 dlartg_ 和 dlarfx_，这些函数是在其他地方定义的，用于旋转和向量操作
    extern /* Subroutine */ void dlartg_(doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *), dlarfx_(char *, integer *, integer *, doublereal *,
         doublereal *, doublereal *, integer *, doublereal *);

    # 声明静态变量 thresh 和 smlnum，这些变量在整个程序运行过程中保持不变
    static doublereal thresh, smlnum;
/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
    an upper quasi-triangular matrix T by an orthogonal similarity
    transformation.

    T must be in Schur canonical form, that is, block upper triangular
    with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
    has its diagonal elements equal and its off-diagonal elements of
    opposite sign.

    Arguments
    =========

    WANTQ   (input) LOGICAL
            = .TRUE. : accumulate the transformation in the matrix Q;
            = .FALSE.: do not accumulate the transformation.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            canonical form.
            On exit, the updated matrix T, again in Schur canonical form.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
            On exit, if WANTQ is .TRUE., the updated matrix Q.
            If WANTQ is .FALSE., Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.
            LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.

    J1      (input) INTEGER
            The index of the first row of the first block T11.

    N1      (input) INTEGER
            The order of the first block T11. N1 = 0, 1 or 2.

    N2      (input) INTEGER
            The order of the second block T22. N2 = 0, 1 or 2.

    WORK    (workspace) DOUBLE PRECISION array, dimension (N)

    INFO    (output) INTEGER
            = 0: successful exit
            = 1: the transformed matrix T would be too far from Schur
                 form; the blocks are not swapped and T and Q are
                 unchanged.

    =====================================================================
*/


    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --work;

    /* Function Body */
    *info = 0;

    /* Quick return if possible */
    // 如果矩阵的维度为0或者要交换的块的维度为0，则直接返回
    if (*n == 0 || *n1 == 0 || *n2 == 0) {
        return 0;
    }
    // 如果第一个块的结束行大于矩阵的维度，则直接返回
    if (*j1 + *n1 > *n) {
        return 0;
    }

    j2 = *j1 + 1;
    j3 = *j1 + 2;
    j4 = *j1 + 3;

    if (*n1 == 1 && *n2 == 1) {

        /* Swap two 1-by-1 blocks. */
        // 获取第一个块 T11 和第二个块 T22 的对角元素
        t11 = t[*j1 + *j1 * t_dim1];
        t22 = t[j2 + j2 * t_dim1];

        /* Determine the transformation to perform the interchange. */
        // 计算交换变换所需的参数
        d__1 = t22 - t11;
        dlartg_(&t[*j1 + j2 * t_dim1], &d__1, &cs, &sn, &temp);


注：这里只注释了部分代码，剩余部分应根据类似的方式继续注释。
/*        Apply transformation to the matrix T. */

if (j3 <= *n) {
    /* Compute rotation for the columns j1 to j3-1 of matrix T */
    i__1 = *n - *j1 - 1;
    drot_(&i__1, &t[*j1 + j3 * t_dim1], ldt, &t[j2 + j3 * t_dim1],
          ldt, &cs, &sn);
}
/* Compute rotation for the rows 1 to j1-1 of matrix T */
i__1 = *j1 - 1;
drot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &c__1,
      &cs, &sn);

/* Update diagonal elements of T */
t[*j1 + *j1 * t_dim1] = t22;
t[j2 + j2 * t_dim1] = t11;

if (*wantq) {
    /* Accumulate transformation in the matrix Q */
    drot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &c__1,
          &cs, &sn);
}

} else {

/*
      Swapping involves at least one 2-by-2 block.

      Copy the diagonal block of order N1+N2 to the local array D
      and compute its norm.
*/

nd = *n1 + *n2;
dlacpy_("Full", &nd, &nd, &t[*j1 + *j1 * t_dim1], ldt, d__, &c__4);
dnorm = dlange_("Max", &nd, &nd, d__, &c__4, &work[1]);

/*
      Compute machine-dependent threshold for test for accepting
      swap.
*/

eps = PRECISION;
smlnum = SAFEMINIMUM / eps;
/* Computing MAX */
d__1 = eps * 10. * dnorm;
thresh = max(d__1,smlnum);

/* Solve T11*X - X*T22 = scale*T12 for X */
dlasy2_(&c_false, &c_false, &c_n1, n1, n2, d__, &c__4, &d__[*n1 + 1 +
    (*n1 + 1 << 2) - 5], &c__4, &d__[(*n1 + 1 << 2) - 4], &c__4, &
    scale, x, &c__2, &xnorm, &ierr);

/* Swap the adjacent diagonal blocks */
k = *n1 + *n1 + *n2 - 3;
switch (k) {
    case 1:  goto L10;
    case 2:  goto L20;
    case 3:  goto L30;
}

L10:

/*
      N1 = 1, N2 = 2: generate elementary reflector H so that:

      ( scale, X11, X12 ) H = ( 0, 0, * )
*/

u[0] = scale;
u[1] = x[0];
u[2] = x[2];
dlarfg_(&c__3, &u[2], u, &c__1, &tau);
u[2] = 1.;
t11 = t[*j1 + *j1 * t_dim1];

/* Perform swap provisionally on diagonal block in D */
dlarfx_("L", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
dlarfx_("R", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);

/*
      Test whether to reject swap.

   Computing MAX
*/
d__2 = abs(d__[2]), d__3 = abs(d__[6]), d__2 = max(d__2,d__3), d__3 =
    (d__1 = d__[10] - t11, abs(d__1));
if (max(d__2,d__3) > thresh) {
    goto L50;
}

/* Accept swap: apply transformation to the entire matrix T */
i__1 = *n - *j1 + 1;
dlarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + *j1 * t_dim1], ldt, &
    work[1]);
dlarfx_("R", &j2, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);

t[j3 + *j1 * t_dim1] = 0.;
t[j3 + j2 * t_dim1] = 0.;
t[j3 + j3 * t_dim1] = t11;

if (*wantq) {
    /* Accumulate transformation in the matrix Q */
    dlarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[
        1]);
}
goto L40;

L20:

/*
      N1 = 2, N2 = 1: generate elementary reflector H so that:

      H (  -X11 ) = ( * )
        (  -X21 ) = ( 0 )
        ( scale ) = ( 0 )
*/

u[0] = -x[0];
    # 设置 u[1] 的值为 -x[1]
    u[1] = -x[1];
    # 设置 u[2] 的值为 scale
    u[2] = scale;
    # 调用 dlarfg_ 函数，对向量 u 进行 Householder 变换
    dlarfg_(&c__3, u, &u[1], &c__1, &tau);
    # 设置 u[0] 的值为 1.0，作为 Householder 向量的第一个元素
    u[0] = 1.;
    # 获取矩阵 t 的第 j3 行 j3 列的元素，存储在变量 t33 中
    t33 = t[j3 + j3 * t_dim1];
/*        Perform swap provisionally on diagonal block in D. */
/*        在 D 的对角块上临时执行交换操作 */

dlarfx_("L", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
/*        在左侧应用 Householder 变换到 u 和 tau 所指定的区域 */
/*        c__3 表示操作的行数，c__4 是矩阵 D 的列数 */

dlarfx_("R", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
/*        在右侧应用 Householder 变换到 u 和 tau 所指定的区域 */
/*        c__3 表示操作的列数，c__4 是矩阵 D 的列数 */

/*
          Test whether to reject swap.

   Computing MAX
*/
/*        测试是否拒绝交换操作 */
d__2 = abs(d__[1]), d__3 = abs(d__[2]), d__2 = max(d__2,d__3), d__3 =
    (d__1 = d__[0] - t33, abs(d__1));
/*        计算绝对值并找出最大值 */
if (max(d__2,d__3) > thresh) {
    goto L50;
}

/*        Accept swap: apply transformation to the entire matrix T. */
/*        接受交换操作：将变换应用到整个矩阵 T */

dlarfx_("R", &j3, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);
/*        在右侧应用 Householder 变换到指定区域 */
/*        j3 是操作的行数 */

i__1 = *n - *j1;
dlarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + j2 * t_dim1], ldt, &work[
    1]);
/*        在左侧应用 Householder 变换到指定区域 */
/*        c__3 是操作的列数，*n - *j1 是操作的行数 */

t[*j1 + *j1 * t_dim1] = t33;
/*        更新矩阵 T 的元素 */
t[j2 + *j1 * t_dim1] = 0.;
/*        更新矩阵 T 的元素 */
t[j3 + *j1 * t_dim1] = 0.;
/*        更新矩阵 T 的元素 */

if (*wantq) {

/*           Accumulate transformation in the matrix Q. */
/*           在矩阵 Q 中累积变换 */

    dlarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[
        1]);
}

goto L40;

L30:

/*
          N1 = 2, N2 = 2: generate elementary reflectors H(1) and H(2) so
          that:

          H(2) H(1) (  -X11  -X12 ) = (  *  * )
                    (  -X21  -X22 )   (  0  * )
                    ( scale    0  )   (  0  0 )
                    (    0  scale )   (  0  0 )
*/

/*        生成初等反射器 H(1) 和 H(2) */

u1[0] = -x[0];
/*        设置 u1 的元素 */
u1[1] = -x[1];
/*        设置 u1 的元素 */
u1[2] = scale;
/*        设置 u1 的元素 */
dlarfg_(&c__3, u1, &u1[1], &c__1, &tau1);
/*        计算 Householder 变换，更新 u1 和 tau1 */

u1[0] = 1.;
/*        更新 u1 的元素 */

temp = -tau1 * (x[2] + u1[1] * x[3]);
/*        计算临时变量 temp */
u2[0] = -temp * u1[1] - x[3];
/*        设置 u2 的元素 */
u2[1] = -temp * u1[2];
/*        设置 u2 的元素 */
u2[2] = scale;
/*        设置 u2 的元素 */
dlarfg_(&c__3, u2, &u2[1], &c__1, &tau2);
/*        计算 Householder 变换，更新 u2 和 tau2 */

u2[0] = 1.;
/*        更新 u2 的元素 */

/*        Perform swap provisionally on diagonal block in D. */
/*        在 D 的对角块上临时执行交换操作 */

dlarfx_("L", &c__3, &c__4, u1, &tau1, d__, &c__4, &work[1]);
/*        在左侧应用 Householder 变换到 u1 和 tau1 所指定的区域 */
/*        c__3 表示操作的行数，c__4 是矩阵 D 的列数 */

dlarfx_("R", &c__4, &c__3, u1, &tau1, d__, &c__4, &work[1]);
/*        在右侧应用 Householder 变换到 u1 和 tau1 所指定的区域 */
/*        c__3 表示操作的列数，c__4 是矩阵 D 的列数 */

dlarfx_("L", &c__3, &c__4, u2, &tau2, &d__[1], &c__4, &work[1]);
/*        在左侧应用 Householder 变换到 u2 和 tau2 所指定的区域 */
/*        c__3 表示操作的行数，c__4 是矩阵 D 的列数 */

dlarfx_("R", &c__4, &c__3, u2, &tau2, &d__[4], &c__4, &work[1]);
/*        在右侧应用 Householder 变换到 u2 和 tau2 所指定的区域 */
/*        c__3 表示操作的列数，c__4 是矩阵 D 的列数 */

/*
          Test whether to reject swap.

   Computing MAX
*/
/*        测试是否拒绝交换操作 */
d__1 = abs(d__[2]), d__2 = abs(d__[6]), d__1 = max(d__1,d__2), d__2 =
    abs(d__[3]), d__1 = max(d__1,d__2), d__2 = abs(d__[7]);
/*        计算绝对值并找出最大值 */
if (max(d__1,d__2) > thresh) {
    goto L50;
}

/*        Accept swap: apply transformation to the entire matrix T. */
/*        接受交换操作：将变换应用到整个矩阵 T */

i__1 = *n - *j1 + 1;
dlarfx_("L", &c__3, &i__1, u1, &tau1, &t[*j1 + *j1 * t_dim1], ldt, &
    work[1]);
/*        在左侧应用 Householder 变换到指定区域 */
/*        c__3 是操作的行数 */

dlarfx_("R", &j4, &c__3, u1, &tau1, &t[*j1 * t_dim1 + 1], ldt, &work[
    1]);
/*        在右侧应用 Householder 变换到指定区域 */
/*        j4 是操作的列数 */

i__1 = *n - *j1 + 1;
dlarfx_("L", &c__3, &i__1, u2, &tau2, &t[j2 + *j1 * t_dim1], ldt, &
    work[1]);
/*        在左侧应用 Householder 变换到指定区域 */
/*        c__3 是操作的行数 */

dlarfx_("R", &j4, &c__3, u2, &tau2, &t[j2 * t_dim1 + 1], ldt, &work[1]
    );
/*        在右侧应用 Householder 变换到指定区域 */
/*        j4 是操作的列数 */

t[j3 + *j1 * t_dim1] = 0.;
/*        更新矩阵 T 的元素 */
t[j3 + j2 * t_dim1] =
/*           Accumulate transformation in the matrix Q. */

/* 累积变换到矩阵 Q 中 */

dlarfx_("R", n, &c__3, u1, &tau1, &q[*j1 * q_dim1 + 1], ldq, &
    work[1]);
/* 对矩阵 Q 中的列进行 Householder 变换，将 u1 的变换累积到 Q 的指定位置 */
dlarfx_("R", n, &c__3, u2, &tau2, &q[j2 * q_dim1 + 1], ldq, &work[
    1]);
/* 对矩阵 Q 中的列进行 Householder 变换，将 u2 的变换累积到 Q 的指定位置 */

}

L40:

if (*n2 == 2) {

/*           Standardize new 2-by-2 block T11 */

/* 标准化新的 2x2 块 T11 */

dlanv2_(&t[*j1 + *j1 * t_dim1], &t[*j1 + j2 * t_dim1], &t[j2 + *
    j1 * t_dim1], &t[j2 + j2 * t_dim1], &wr1, &wi1, &wr2, &
    wi2, &cs, &sn);
/* 计算旋转矩阵，将 T11 块对角化 */
i__1 = *n - *j1 - 1;
drot_(&i__1, &t[*j1 + (*j1 + 2) * t_dim1], ldt, &t[j2 + (*j1 + 2)
    * t_dim1], ldt, &cs, &sn);
/* 对 T11 块下面的部分进行旋转 */
i__1 = *j1 - 1;
drot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &
    c__1, &cs, &sn);
/* 对 T11 块左边的部分进行旋转 */
if (*wantq) {
drot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &
    c__1, &cs, &sn);
/* 如果需要计算 Q 矩阵，则对 Q 的对应列也进行旋转 */
}
}

if (*n1 == 2) {

/*           Standardize new 2-by-2 block T22 */

/* 标准化新的 2x2 块 T22 */

j3 = *j1 + *n2;
j4 = j3 + 1;
dlanv2_(&t[j3 + j3 * t_dim1], &t[j3 + j4 * t_dim1], &t[j4 + j3 *
    t_dim1], &t[j4 + j4 * t_dim1], &wr1, &wi1, &wr2, &wi2, &
    cs, &sn);
/* 计算旋转矩阵，将 T22 块对角化 */
if (j3 + 2 <= *n) {
i__1 = *n - j3 - 1;
drot_(&i__1, &t[j3 + (j3 + 2) * t_dim1], ldt, &t[j4 + (j3 + 2)
     * t_dim1], ldt, &cs, &sn);
/* 对 T22 块下面的部分进行旋转 */
}
i__1 = j3 - 1;
drot_(&i__1, &t[j3 * t_dim1 + 1], &c__1, &t[j4 * t_dim1 + 1], &
    c__1, &cs, &sn);
/* 对 T22 块左边的部分进行旋转 */
if (*wantq) {
drot_(n, &q[j3 * q_dim1 + 1], &c__1, &q[j4 * q_dim1 + 1], &
    c__1, &cs, &sn);
/* 如果需要计算 Q 矩阵，则对 Q 的对应列也进行旋转 */
}
}

}
return 0;

/*     Exit with INFO = 1 if swap was rejected. */

L50:
*info = 1;
return 0;

/*     End of DLAEXC */

} /* dlaexc_ */

/* Subroutine */ int dlahqr_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal
    *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__,
    integer *ldz, integer *info)
{
/* QR 方法求解特征值问题 */

/* System generated locals */
integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3;
doublereal d__1, d__2, d__3, d__4;

/* Local variables */
static integer i__, j, k, l, m;
static doublereal s, v[3];
static integer i1, i2;
static doublereal t1, t2, t3, v2, v3, aa, ab, ba, bb, h11, h12, h21, h22,
    cs;
static integer nh;
static doublereal sn;
static integer nr;
static doublereal tr;
static integer nz;
static doublereal det, h21s;
static integer its;
static doublereal ulp, sum, tst, rt1i, rt2i, rt1r, rt2r;
    ! 声明外部子程序 drot_, dcopy_, dlanv2_, dlabad_ 的接口
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *), dcopy_(
        integer *, doublereal *, integer *, doublereal *, integer *),
        dlanv2_(doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *), dlabad_(doublereal *, doublereal *);

    ! 声明静态变量 safmin, safmax, rtdisc, smlnum 的类型为 doublereal
    static doublereal safmin, safmax, rtdisc, smlnum;
    /* Parameter adjustments */
    h_dim1 = *ldh;  // 计算 h_dim1 的值，即 h 数组第一维的长度
    h_offset = 1 + h_dim1;  // 计算 h 数组的偏移量
    h__ -= h_offset;  // 调整 h 数组的起始地址
    --wr;  // 将 wr 指针向前移动一个位置
    --wi;  // 将 wi 指针向前移动一个位置
    z_dim1 = *ldz;  // 计算 z_dim1 的值，即 z 数组第一维的长度
    z_offset = 1 + z_dim1;  // 计算 z 数组的偏移量
    z__ -= z_offset;  // 调整 z 数组的起始地址

    /* Function Body */
    *info = 0;  // 将 info 参数初始化为 0

    /* Quick return if possible */
    if (*n == 0) {  // 如果 n 等于 0，则直接返回
        return 0;
    }
    if (*ilo == *ihi) {  // 如果 ilo 等于 ihi，则直接将对角元素复制到 wr 和 wi
        wr[*ilo] = h__[*ilo + *ilo * h_dim1];
        wi[*ilo] = 0.;
        return 0;
    }

    /* ==== clear out the trash ==== */
    i__1 = *ihi - 3;
    for (j = *ilo; j <= i__1; ++j) {
        h__[j + 2 + j * h_dim1] = 0.;  // 清除对角线以下第二行的元素
        h__[j + 3 + j * h_dim1] = 0.;  // 清除对角线以下第三行的元素
        /* L10: */
    }
    if (*ilo <= *ihi - 2) {
        h__[*ihi + (*ihi - 2) * h_dim1] = 0.;  // 清除对角线以上第二列的元素
    }

    nh = *ihi - *ilo + 1;  // 计算矩阵 H 的有效行数
    nz = *ihiz - *iloz + 1;  // 计算矩阵 Z 的有效列数

    /* Set machine-dependent constants for the stopping criterion. */
    safmin = SAFEMINIMUM;  // 设置最小安全值
    safmax = 1. / safmin;  // 设置最大安全值的倒数
    dlabad_(&safmin, &safmax);  // 调用函数 dlabad_ 来设置安全范围
    ulp = PRECISION;  // 设置机器精度
    smlnum = safmin * ((doublereal) nh / ulp);  // 计算小数值 smlnum

    /*
       I1 and I2 are the indices of the first row and last column of H
       to which transformations must be applied. If eigenvalues only are
       being computed, I1 and I2 are set inside the main loop.
    */
    if (*wantt) {  // 如果要计算转换矩阵 T，则设置 I1 和 I2
        i1 = 1;
        i2 = *n;
    }

    /*
       The main loop begins here. I is the loop index and decreases from
       IHI to ILO in steps of 1 or 2. Each iteration of the loop works
       with the active submatrix in rows and columns L to I.
       Eigenvalues I+1 to IHI have already converged. Either L = ILO or
       H(L,L-1) is negligible so that the matrix splits.
    */
    i__ = *ihi;
L20:
    l = *ilo;
    if (i__ < *ilo) {
        goto L160;  // 跳转到标号 L160 处
    }

    /*
       Perform QR iterations on rows and columns ILO to I until a
       submatrix of order 1 or 2 splits off at the bottom because a
       subdiagonal element has become negligible.
    */
    for (its = 0; its <= 30; ++its) {

        /* Look for a single small subdiagonal element. */
        i__1 = l + 1;
        for (k = i__; k >= i__1; --k) {
            if ((d__1 = h__[k + (k - 1) * h_dim1], abs(d__1)) <= smlnum) {
                goto L40;  // 如果找到小的次对角元素，跳转到标号 L40 处
            }
            tst = (d__1 = h__[k - 1 + (k - 1) * h_dim1], abs(d__1)) + (d__2 =
                h__[k + k * h_dim1], abs(d__2));
            if (tst == 0.) {
                if (k - 2 >= *ilo) {
                    tst += (d__1 = h__[k - 1 + (k - 2) * h_dim1], abs(d__1));
                }
                if (k + 1 <= *ihi) {
                    tst += (d__1 = h__[k + 1 + k * h_dim1], abs(d__1));
                }
            }
            /*
               ==== The following is a conservative small subdiagonal
               .    deflation  criterion due to Ahues & Tisseur (LAWN 122,
               .    1997). It has better mathematical foundation and
               .    improves accuracy in some cases.  ====
            */
            if ((d__1 = h__[k + (k - 1) * h_dim1], abs(d__1)) <= ulp * tst) {
                /* Computing MAX */
                d__3 = (d__1 = h__[k + (k - 1) * h_dim1], abs(d__1)), d__4 = (
                    d__2 = h__[k - 1 + k * h_dim1], abs(d__2));
                ab = max(d__3,d__4);  // 计算 ab 的最大值
/* Computing MIN */
        // 计算两个数的最小值，用于确定 ba 的值
        d__3 = (d__1 = h__[k + (k - 1) * h_dim1], abs(d__1)), d__4 = (
            d__2 = h__[k - 1 + k * h_dim1], abs(d__2));
        ba = min(d__3,d__4);

/* Computing MAX */
        // 计算两个数的最大值，用于确定 aa 的值
        d__3 = (d__1 = h__[k + k * h_dim1], abs(d__1)), d__4 = (d__2 =
             h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1],
            abs(d__2));
        aa = max(d__3,d__4);

/* Computing MIN */
        // 计算两个数的最小值，用于确定 bb 的值
        d__3 = (d__1 = h__[k + k * h_dim1], abs(d__1)), d__4 = (d__2 =
             h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1],
            abs(d__2));
        bb = min(d__3,d__4);

        // 计算 s 的值
        s = aa + ab;

/* Computing MAX */
        // 计算两个数的最大值，用于条件判断
        d__1 = smlnum, d__2 = ulp * (bb * (aa / s));
        if (ba * (ab / s) <= max(d__1,d__2)) {
            // 若满足条件则跳转到标签 L40 处
            goto L40;
        }

/* L30: */
    }

L40:
    // 更新 l 的值为 k
    l = k;
    // 如果 l 大于 *ilo，则将 H(L,L-1) 置为零
    if (l > *ilo) {
        h__[l + (l - 1) * h_dim1] = 0.;
    }

    // 如果 l 大于等于 i__-1，则跳转到标签 L150 处
    if (l >= i__ - 1) {
        goto L150;
    }

    // 现在活动子矩阵位于行和列 L 到 I 之间。若仅计算特征值，则只需转换活动子矩阵。
    if (! (*wantt)) {
        i1 = l;
        i2 = i__;
    }

    // 若 its 等于 10，则执行下面的操作
    if (its == 10) {

/*           Exceptional shift. */

        // 计算 s 的值
        s = (d__1 = h__[l + 1 + l * h_dim1], abs(d__1)) + (d__2 = h__[l +
            2 + (l + 1) * h_dim1], abs(d__2));
        // 计算特殊的 h11, h12, h21, h22
        h11 = s * .75 + h__[l + l * h_dim1];
        h12 = s * -.4375;
        h21 = s;
        h22 = h11;
    } else if (its == 20) {

/*           Exceptional shift. */

        // 计算 s 的值
        s = (d__1 = h__[i__ + (i__ - 1) * h_dim1], abs(d__1)) + (d__2 =
            h__[i__ - 1 + (i__ - 2) * h_dim1], abs(d__2));
        // 计算特殊的 h11, h12, h21, h22
        h11 = s * .75 + h__[i__ + i__ * h_dim1];
        h12 = s * -.4375;
        h21 = s;
        h22 = h11;
    } else {

/*
             Prepare to use Francis' double shift
             (i.e. 2nd degree generalized Rayleigh quotient)
*/

        // 准备使用 Francis 双位移策略
        h11 = h__[i__ - 1 + (i__ - 1) * h_dim1];
        h21 = h__[i__ + (i__ - 1) * h_dim1];
        h12 = h__[i__ - 1 + i__ * h_dim1];
        h22 = h__[i__ + i__ * h_dim1];
    }

    // 计算 s 的值
    s = abs(h11) + abs(h12) + abs(h21) + abs(h22);

    // 如果 s 等于 0，则将所有的实部和虚部置为 0
    if (s == 0.) {
        rt1r = 0.;
        rt1i = 0.;
        rt2r = 0.;
        rt2i = 0.;
    } else {
        // 对 h11, h21, h12, h22 进行缩放
        h11 /= s;
        h21 /= s;
        h12 /= s;
        h22 /= s;
        // 计算 tr, det, rtdisc
        tr = (h11 + h22) / 2.;
        det = (h11 - tr) * (h22 - tr) - h12 * h21;
        rtdisc = sqrt((abs(det)));
        // 根据 det 的正负情况计算特征值
        if (det >= 0.) {

/*              ==== complex conjugate shifts ==== */

        rt1r = tr * s;
        rt2r = rt1r;
        rt1i = rtdisc * s;
        rt2i = -rt1i;
        } else {
/*              ==== real shifts (use only one of them)  ==== */

        rt1r = tr + rtdisc;  // Calculate first real shift
        rt2r = tr - rtdisc;  // Calculate second real shift
        if ((d__1 = rt1r - h22, abs(d__1)) <= (d__2 = rt2r - h22, abs(
            d__2))) {
            rt1r *= s;  // Scale first real shift
            rt2r = rt1r;  // Set second real shift to first if condition is true
        } else {
            rt2r *= s;  // Scale second real shift
            rt1r = rt2r;  // Set first real shift to second if condition is false
        }
        rt1i = 0.;  // Initialize imaginary part of first shift
        rt2i = 0.;  // Initialize imaginary part of second shift
        }
    }

/*        Look for two consecutive small subdiagonal elements. */

    i__1 = l;
    for (m = i__ - 2; m >= i__1; --m) {
/*
             Determine the effect of starting the double-shift QR
             iteration at row M, and see if this would make H(M,M-1)
             negligible.  (The following uses scaling to avoid
             overflows and most underflows.)
*/

        h21s = h__[m + 1 + m * h_dim1];  // Store subdiagonal element H(m+1, m)
        s = (d__1 = h__[m + m * h_dim1] - rt2r, abs(d__1)) + abs(rt2i) +
            abs(h21s);  // Calculate scaling factor
        h21s = h__[m + 1 + m * h_dim1] / s;  // Scale H(m+1, m) by factor s
        v[0] = h21s * h__[m + (m + 1) * h_dim1] + (h__[m + m * h_dim1] -
            rt1r) * ((h__[m + m * h_dim1] - rt2r) / s) - rt1i * (rt2i
            / s);  // Compute first component of vector v
        v[1] = h21s * (h__[m + m * h_dim1] + h__[m + 1 + (m + 1) * h_dim1]
             - rt1r - rt2r);  // Compute second component of vector v
        v[2] = h21s * h__[m + 2 + (m + 1) * h_dim1];  // Compute third component of vector v
        s = abs(v[0]) + abs(v[1]) + abs(v[2]);  // Compute scaling factor s
        v[0] /= s;  // Normalize first component of vector v
        v[1] /= s;  // Normalize second component of vector v
        v[2] /= s;  // Normalize third component of vector v
        if (m == l) {
        goto L60;  // Exit loop if condition is met
        }
        if ((d__1 = h__[m + (m - 1) * h_dim1], abs(d__1)) * (abs(v[1]) +
            abs(v[2])) <= ulp * abs(v[0]) * ((d__2 = h__[m - 1 + (m -
            1) * h_dim1], abs(d__2)) + (d__3 = h__[m + m * h_dim1],
            abs(d__3)) + (d__4 = h__[m + 1 + (m + 1) * h_dim1], abs(
            d__4)))) {
        goto L60;  // Exit loop if condition is met
        }
/* L50: */
    }
L60:

/*        Double-shift QR step */

    i__1 = i__ - 1;
    for (k = m; k <= i__1; ++k) {

/*
             The first iteration of this loop determines a reflection G
             from the vector V and applies it from left and right to H,
             thus creating a nonzero bulge below the subdiagonal.

             Each subsequent iteration determines a reflection G to
             restore the Hessenberg form in the (K-1)th column, and thus
             chases the bulge one step toward the bottom of the active
             submatrix. NR is the order of G.

   Computing MIN
*/
        i__2 = 3, i__3 = i__ - k + 1;
        nr = min(i__2,i__3);  // Determine order of reflection G
        if (k > m) {
        dcopy_(&nr, &h__[k + (k - 1) * h_dim1], &c__1, v, &c__1);  // Copy elements to vector v
        }
        dlarfg_(&nr, v, &v[1], &c__1, &t1);  // Compute reflection G and apply to vector v
        if (k > m) {
        h__[k + (k - 1) * h_dim1] = v[0];  // Update H matrix
        h__[k + 1 + (k - 1) * h_dim1] = 0.;
        if (k < i__ - 1) {
            h__[k + 2 + (k - 1) * h_dim1] = 0.;
        }
        } else if (m > l) {
/*
                 ==== Use the following instead of
                 .    H( K, K-1 ) = -H( K, K-1 ) to
                 .    avoid a bug when v(2) and v(3)
                 .    underflow. ====
*/
/*
        将 h 矩阵的特定区域应用 Givens 变换。
        该变换将影响从第 K 列到 I2 列的矩阵行。
*/
i__2 = i2;
for (j = k; j <= i__2; ++j) {
    // 计算当前列的线性组合
    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1]
        + v3 * h__[k + 2 + j * h_dim1];
    // 应用 Givens 变换到 h 矩阵的特定列
    h__[k + j * h_dim1] -= sum * t1;
    h__[k + 1 + j * h_dim1] -= sum * t2;
    h__[k + 2 + j * h_dim1] -= sum * t3;
    /* L70: */
}

/*
        将 h 矩阵的特定区域应用 Givens 变换。
        该变换将影响从第 I1 行到 min(K+3, I) 行的矩阵列。
*/
i__3 = k + 3;
i__2 = min(i__3,i__);
for (j = i1; j <= i__2; ++j) {
    // 计算当前行的线性组合
    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
         + v3 * h__[j + (k + 2) * h_dim1];
    // 应用 Givens 变换到 h 矩阵的特定行
    h__[j + k * h_dim1] -= sum * t1;
    h__[j + (k + 1) * h_dim1] -= sum * t2;
    h__[j + (k + 2) * h_dim1] -= sum * t3;
    /* L80: */
}

if (*wantz) {
    /*
        将变换累积到矩阵 Z 中。
        这个变换会影响从第 *iloz 行到第 *ihiz 行的列。
    */
    i__2 = *ihiz;
    for (j = *iloz; j <= i__2; ++j) {
        // 计算 Z 矩阵的特定区域的线性组合
        sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) * z_dim1]
              + v3 * z__[j + (k + 2) * z_dim1];
        // 应用 Givens 变换到 Z 矩阵的特定区域
        z__[j + k * z_dim1] -= sum * t1;
        z__[j + (k + 1) * z_dim1] -= sum * t2;
        z__[j + (k + 2) * z_dim1] -= sum * t3;
        /* L90: */
    }
}
} else if (nr == 2) {
    /*
        将 h 矩阵的特定区域应用 Givens 变换。
        该变换将影响从第 K 列到 I2 列的矩阵行。
    */
i__2 = i2;
for (j = k; j <= i__2; ++j) {
    // 计算当前列的线性组合
    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1];
    // 应用 Givens 变换到 h 矩阵的特定列
    h__[k + j * h_dim1] -= sum * t1;
    h__[k + 1 + j * h_dim1] -= sum * t2;
    /* L100: */
}

/*
        将 h 矩阵的特定区域应用 Givens 变换。
        该变换将影响从第 I1 行到 min(K+3, I) 行的矩阵列。
    */
i__2 = i__;
for (j = i1; j <= i__2; ++j) {
    // 计算当前行的线性组合
    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1];
    // 应用 Givens 变换到 h 矩阵的特定行
    h__[j + k * h_dim1] -= sum * t1;
    h__[j + (k + 1) * h_dim1] -= sum * t2;
    /* L110: */
}

if (*wantz) {
    /*
        将变换累积到矩阵 Z 中。
        这个变换会影响从第 *iloz 行到第 *ihiz 行的列。
    */
    i__2 = *ihiz;
    for (j = *iloz; j <= i__2; ++j) {
        // 计算 Z 矩阵的特定区域的线性组合
        sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) * z_dim1];
        // 应用 Givens 变换到 Z 矩阵的特定区域
        z__[j + k * z_dim1] -= sum * t1;
        z__[j + (k + 1) * z_dim1] -= sum * t2;
        /* L120: */
    }
}
}
/* L130: */
}

/* L140: */
}

/*     没有在剩余迭代中收敛 */

*info = i__;
return 0;

L150:

if (l == i__) {
/*        H(I,I-1) is negligible: one eigenvalue has converged. */

    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.;
    } else if (l == i__ - 1) {

/*
          H(I-1,I-2) is negligible: a pair of eigenvalues have converged.

          Transform the 2-by-2 submatrix to standard Schur form,
          and compute and store the eigenvalues.
*/

    dlanv2_(&h__[i__ - 1 + (i__ - 1) * h_dim1], &h__[i__ - 1 + i__ *
        h_dim1], &h__[i__ + (i__ - 1) * h_dim1], &h__[i__ + i__ *
        h_dim1], &wr[i__ - 1], &wi[i__ - 1], &wr[i__], &wi[i__], &cs,
        &sn);

    if (*wantt) {

/*           Apply the transformation to the rest of H. */

        if (i2 > i__) {
        i__1 = i2 - i__;
        drot_(&i__1, &h__[i__ - 1 + (i__ + 1) * h_dim1], ldh, &h__[
            i__ + (i__ + 1) * h_dim1], ldh, &cs, &sn);
        }
        i__1 = i__ - i1 - 1;
        drot_(&i__1, &h__[i1 + (i__ - 1) * h_dim1], &c__1, &h__[i1 + i__ *
             h_dim1], &c__1, &cs, &sn);
    }
    if (*wantz) {

/*           Apply the transformation to Z. */

        drot_(&nz, &z__[*iloz + (i__ - 1) * z_dim1], &c__1, &z__[*iloz +
            i__ * z_dim1], &c__1, &cs, &sn);
    }
    }

/*     return to start of the main loop with new value of I. */

    i__ = l - 1;
    goto L20;

L160:
    return 0;

/*     End of DLAHQR */

} /* dlahqr_ */

/* Subroutine */ int dlahr2_(integer *n, integer *k, integer *nb, doublereal *
    a, integer *lda, doublereal *tau, doublereal *t, integer *ldt,
    doublereal *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__;
    static doublereal ei;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dgemm_(char *, char *, integer *, integer *, integer *
        , doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *), dgemv_(
        char *, integer *, integer *, doublereal *, doublereal *, integer
        *, doublereal *, integer *, doublereal *, doublereal *, integer *), dcopy_(integer *, doublereal *, integer *, doublereal *,
         integer *), dtrmm_(char *, char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *), daxpy_(integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *),
        dtrmv_(char *, char *, char *, integer *, doublereal *, integer *,
         doublereal *, integer *), dlarfg_(
        integer *, doublereal *, doublereal *, integer *, doublereal *),
        dlacpy_(char *, integer *, integer *, doublereal *, integer *,
        doublereal *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --

*/


注释：


/*        H(I,I-1) is negligible: one eigenvalue has converged. */

    wr[i__] = h__[i__ + i__ * h_dim1];
    wi[i__] = 0.;
    // 当前位置的下标为 i__ 的实部特征值已经收敛，虚部设置为零
    } else if (l == i__ - 1) {

/*
          H(I-1,I-2) is negligible: a pair of eigenvalues have converged.

          Transform the 2-by-2 submatrix to standard Schur form,
          and compute and store the eigenvalues.
*/

    dlanv2_(&h__[i__ - 1 + (i__ - 1) * h_dim1], &h__[i__ - 1 + i__ *
        h_dim1], &h__[i__ + (i__ - 1) * h_dim1], &h__[i__ + i__ *
        h_dim1], &wr[i__ - 1], &wi[i__ - 1], &wr[i__], &wi[i__], &cs,
        &sn);
    // 调用 dlanv2 函数将一个 2x2 子矩阵转换为标准舒尔形式，并计算存储特征值

    if (*wantt) {

/*           Apply the transformation to the rest of H. */

        if (i2 > i__) {
        i__1 = i2 - i__;
        drot_(&i__1, &h__[i__ - 1 + (i__ + 1) * h_dim1], ldh, &h__[
            i__ + (i__ + 1) * h_dim1], ldh, &cs, &sn);
        }
        i__1 = i__ - i1 - 1;
        drot_(&i__1, &h__[i1 + (i__ - 1) * h_dim1], &c__1, &h__[i1 + i__ *
             h_dim1], &c__1, &cs, &sn);
    }
    // 如果 wantt 标志为真，则将变换应用于 H 的其余部分

    if (*wantz) {

/*           Apply the transformation to Z. */

        drot_(&nz, &z__[*iloz + (i__ - 1) * z_dim1], &c__1, &z__[*iloz +
            i__ * z_dim1], &c__1, &cs, &sn);
    }
    // 如果 wantz 标志为真，则将变换应用于 Z

    }

/*     return to start of the main loop with new value of I. */

    i__ = l - 1;
    // 使用新的 I 值返回到主循环的起始位置
    goto L20;

L160:
    return 0;
    // 子程序结束，返回 0

/*     End of DLAHQR */

} /* dlahqr_ */

/* Subroutine */ int dlahr2_(integer *n, integer *k, integer *nb, doublereal *
    a, integer *lda, doublereal *tau, doublereal *t, integer *ldt,
    doublereal *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2,
        i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__;
    static doublereal ei;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dgemm_(char *, char *, integer *, integer *, integer *
        , doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *), dgemv_(
        char *, integer *, integer *, doublereal *, doublereal *, integer
        *, doublereal *, integer *, doublereal *, doublereal *, integer *), dcopy_(integer *, doublereal *, integer *, doublereal *,
         integer *), dtrmm_(char *, char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *), daxpy_(integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *),
        dtrmv_(char *, char *, char *, integer *, doublereal *, integer *,
         doublereal *, integer *), dlarfg_(
        integer *, doublereal *, doublereal *, integer *, doublereal *),
        dlacpy_(char *, integer *, integer *, doublereal *, integer *,
        doublereal *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2.1)                        --
    -- LAPACK is
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    -- April 2009                                                      --
    
    # 定义函数目的及功能说明
    # DLAHR2函数用于对实数一般矩阵A的前NB列进行变换，使得第k条对角线以下的元素为零。
    # 变换通过正交相似变换Q' * A * Q来实现。该函数返回决定Q的矩阵V和T，以及矩阵Y = A * V * T。
    
    # 参数说明
    # N：矩阵A的阶数。
    # K：变换的偏移量。前NB列中第k条对角线以下的元素将被归零。
    # NB：需要进行变换的列数。
    # A：输入/输出，双精度数组，维度为(LDA, N-K+1)。输入时为n-by-(n-k+1)的一般矩阵A，输出时前NB列中第k条对角线及以上的元素被变换为对应的归约矩阵；k条对角线以下的元素用TAU数组表示Q的元素反射的乘积。A的其他列保持不变。
    # LDA：数组A的第一维度。LDA >= max(1,N)。
    # TAU：输出，双精度数组，维度为(NB)。元素反射的标量因子。
    # T：输出，双精度数组，维度为(LDT, NB)。上三角矩阵T。
    # LDT：数组T的第一维度。LDT >= NB。
    # Y：输出，双精度数组，维度为(LDY, NB)。n-by-nb矩阵Y。
    # LDY：数组Y的第一维度。LDY >= N。
    
    # 进一步细节
    # 矩阵Q表示为nb个元素反射的乘积：Q = H(1) H(2) . . . H(nb)。
    # 每个H(i)的形式为H(i) = I - tau * v * v'，其中tau是实数标量，v是实向量，满足v(1:i+k-1) = 0, v(i+k) = 1；v(i+k+1:n)在退出时存储在A(i+k+1:n,i)中，tau存储在TAU(i)中。
    # 向量v的元素共同形成(n-k+1)-by-nb矩阵V，与T和Y一起，用于对矩阵的未归约部分应用变换，形式为：A := (I - V*T*V') * (A - Y*V')。
    
    # A的退出时的内容由以下示例说明：
    # 如果 k 大于等于 n 或者 nb 小于等于 1，则直接返回，因为不需要做任何操作
    if k >= n or nb <= 1:
        return
    /* Parameter adjustments */
    --tau;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    y_dim1 = *ldy;
    y_offset = 1 + y_dim1;
    y -= y_offset;

    /* Function Body */
    if (*n <= 1) {
        return 0;
    }

    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if (i__ > 1) {

            /* Update A(K+1:N,I)
               Update I-th column of A - Y * V' */

            i__2 = *n - *k;
            i__3 = i__ - 1;
            dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151, &y[*k + 1 + y_dim1],
                   ldy, &a[*k + i__ - 1 + a_dim1], lda, &c_b15, &a[*k + 1 +
                   i__ * a_dim1], &c__1);

            /* Apply I - V * T' * V' to this column (call it b) from the
               left, using the last column of T as workspace
               
               Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows)
                        ( V2 )             ( b2 )

               where V1 is unit lower triangular
               
               w := V1' * b1 */

            i__2 = i__ - 1;
            dcopy_(&i__2, &a[*k + 1 + i__ * a_dim1], &c__1, &t[*nb * t_dim1 +
                   1], &c__1);
            i__2 = i__ - 1;
            dtrmv_("Lower", "Transpose", "UNIT", &i__2, &a[*k + 1 + a_dim1],
                   lda, &t[*nb * t_dim1 + 1], &c__1);

            /* w := w + V2'*b2 */

            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[*k + i__ + a_dim1],
                   lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b15, &t[*nb *
                   t_dim1 + 1], &c__1);

            /* w := T'*w */

            i__2 = i__ - 1;
            dtrmv_("Upper", "Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
                   &t[*nb * t_dim1 + 1], &c__1);

            /* b2 := b2 - V2*w */

            i__2 = *n - *k - i__ + 1;
            i__3 = i__ - 1;
            dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151, &a[*k + i__ +
                   a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1, &c_b15, &a[*k
                   + i__ + i__ * a_dim1], &c__1);

            /* b1 := b1 - V1*w */

            i__2 = i__ - 1;
            dtrmv_("Lower", "NO TRANSPOSE", "UNIT", &i__2, &a[*k + 1 + a_dim1],
                   lda, &t[*nb * t_dim1 + 1], &c__1);
            i__2 = i__ - 1;
            daxpy_(&i__2, &c_b151, &t[*nb * t_dim1 + 1], &c__1, &a[*k + 1 +
                   i__ * a_dim1], &c__1);

            a[*k + i__ - 1 + (i__ - 1) * a_dim1] = ei;
        }

        /* Generate the elementary reflector H(I) to annihilate
           A(K+I+1:N,I) */

        i__2 = *n - *k - i__ + 1;
        /* Computing MIN */
        i__3 = *k + i__ + 1;
        dlarfg_(&i__2, &a[*k + i__ + i__ * a_dim1], &a[min(i__3,*n) + i__ *
            a_dim1], &c__1, &tau[i__]);
        ei = a[*k + i__ + i__ * a_dim1];
        a[*k + i__ + i__ * a_dim1] = 1.;

        /* Compute Y(K+1:N,I) */

        i__2 = *n - *k;
        i__3 = *n - *k - i__ + 1;
        dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b15, &a[*k + 1 + (i__ + 1) *
            a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b29, &y[*
            k + 1 + i__ * y_dim1], &c__1);
    }
    # 计算数组的长度，用于下面的计算
    i__2 = *n - *k - i__ + 1;
    # 计算矩阵乘法中的列数
    i__3 = i__ - 1;
    # 执行矩阵向量乘法操作，计算结果存储在 t[i__ * t_dim1 + 1] 中
    dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[*k + i__ + a_dim1], lda,
           &a[*k + i__ + i__ * a_dim1], &c__1, &c_b29, &t[i__ * t_dim1 + 1], &c__1);
    # 计算矩阵乘法中的列数
    i__2 = *n - *k;
    # 执行矩阵向量乘法操作，计算结果存储在 y[*k + 1 + i__ * y_dim1] 中
    dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b151, &y[*k + 1 + y_dim1],
           ldy, &t[i__ * t_dim1 + 1], &c__1, &c_b15, &y[*k + 1 + i__ * y_dim1], &c__1);
    # 对矩阵中的一列进行缩放操作
    i__2 = *n - *k;
    dscal_(&i__2, &tau[i__], &y[*k + 1 + i__ * y_dim1], &c__1);
/*
    Compute T(1:I,I)
*/

    // 计算向量的长度
    i__2 = i__ - 1;
    // 计算缩放因子
    d__1 = -tau[i__];
    // 对向量进行缩放
    dscal_(&i__2, &d__1, &t[i__ * t_dim1 + 1], &c__1);
    // 对上三角矩阵进行向量-矩阵乘法
    i__2 = i__ - 1;
    dtrmv_("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
        &t[i__ * t_dim1 + 1], &c__1)
        ;
    // 将 tau[i] 的值存入矩阵 T 的对角线元素
    t[i__ + i__ * t_dim1] = tau[i];

/* L10: */
    }
    // 将 ei 存入矩阵 A
    a[*k + *nb + *nb * a_dim1] = ei;

/*
    Compute Y(1:K,1:NB)
*/

    // 复制矩阵 A 的部分内容到矩阵 Y
    dlacpy_("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
    // 对下三角矩阵进行矩阵-矩阵乘法
    dtrmm_("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b15, &a[*k + 1
        + a_dim1], lda, &y[y_offset], ldy);
    // 如果 n 大于 k + nb，则进行矩阵-矩阵乘法
    if (*n > *k + *nb) {
        i__1 = *n - *k - *nb;
        dgemm_("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b15, &a[(*nb
            + 2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &
            c_b15, &y[y_offset], ldy);
    }
    // 对上三角矩阵进行矩阵-矩阵乘法
    dtrmm_("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b15, &t[
        t_offset], ldt, &y[y_offset], ldy);

    // 返回函数执行成功
    return 0;

/*
    End of DLAHR2
*/

} /* dlahr2_ */

/*
    Check for NaNs by comparing two arguments
*/

logical dlaisnan_(doublereal *din1, doublereal *din2)
{
    /* System generated locals */
    logical ret_val;

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    This routine is not for general use.  It exists solely to avoid
    over-optimization in DISNAN.

    DLAISNAN checks for NaNs by comparing its two arguments for
    inequality.  NaN is the only floating-point value where NaN != NaN
    returns .TRUE.  To check for NaNs, pass the same variable as both
    arguments.

    A compiler must assume that the two arguments are
    not the same variable, and the test will not be optimized away.
    Interprocedural or whole-program optimization may delete this
    test.  The ISNAN functions will be replaced by the correct
    Fortran 03 intrinsic once the intrinsic is widely available.

    Arguments
    =========

    DIN1    (input) DOUBLE PRECISION

    DIN2    (input) DOUBLE PRECISION
            Two numbers to compare for inequality.

    =====================================================================
*/

    // 检查两个参数是否不相等，以判断是否有 NaN
    ret_val = *din1 != *din2;
    return ret_val;
} /* dlaisnan_ */

/*
    Solve a generalized Sylvester matrix equation
*/

/* Subroutine */ int dlaln2_(logical *ltrans, integer *na, integer *nw,
    doublereal *smin, doublereal *ca, doublereal *a, integer *lda,
    doublereal *d1, doublereal *d2, doublereal *b, integer *ldb,
    doublereal *wr, doublereal *wi, doublereal *x, integer *ldx,
    doublereal *scale, doublereal *xnorm, integer *info)
{
    /* Initialized data */

    static logical zswap[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical rswap[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };
    static integer ipivot[16]    /* was [4][4] */ = { 1,2,3,4,2,1,4,3,3,4,1,2,
        4,3,2,1 };

    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, x_dim1, x_offset;
    # 定义六个双精度浮点数变量
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    # 定义静态数组，长度为4，存储双精度浮点数，用于等效处理
    static doublereal equiv_0[4], equiv_1[4];

    # 定义静态整型变量 j，用于循环或索引
    /* Local variables */
    static integer j;
#define ci (equiv_0)
#define cr (equiv_1)
    static doublereal bi1, bi2, br1, br2, xi1, xi2, xr1, xr2, ci21, ci22,
        cr21, cr22, li21, csi, ui11, lr21, ui12, ui22;
#define civ (equiv_0)
    static doublereal csr, ur11, ur12, ur22;
#define crv (equiv_1)
    static doublereal bbnd, cmax, ui11r, ui12s, temp, ur11r, ur12s, u22abs;
    static integer icmax;
    static doublereal bnorm, cnorm, smini;

    extern /* Subroutine */ int dladiv_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *);
    static doublereal bignum, smlnum;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLALN2 solves a system of the form  (ca A - w D ) X = s B
    or (ca A' - w D) X = s B   with possible scaling ("s") and
    perturbation of A.  (A' means A-transpose.)

    A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
    real diagonal matrix, w is a real or complex value, and X and B are
    NA x 1 matrices -- real if w is real, complex if w is complex.  NA
    may be 1 or 2.

    If w is complex, X and B are represented as NA x 2 matrices,
    the first column of each being the real part and the second
    being the imaginary part.

    "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
    so chosen that X can be computed without overflow.  X is further
    scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
    than overflow.

    If both singular values of (ca A - w D) are less than SMIN,
    SMIN*identity will be used instead of (ca A - w D).  If only one
    singular value is less than SMIN, one element of (ca A - w D) will be
    perturbed enough to make the smallest singular value roughly SMIN.
    If both singular values are at least SMIN, (ca A - w D) will not be
    perturbed.  In any case, the perturbation will be at most some small
    multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
    are computed by infinity-norm approximations, and thus will only be
    correct to a factor of 2 or so.

    Note: all input quantities are assumed to be smaller than overflow
    by a reasonable factor.  (See BIGNUM.)

    Arguments
    ==========

    LTRANS  (input) LOGICAL
            =.TRUE.:  A-transpose will be used.
            =.FALSE.: A will be used (not transposed.)

    NA      (input) INTEGER
            The size of the matrix A.  It may (only) be 1 or 2.

    NW      (input) INTEGER
            1 if "w" is real, 2 if "w" is complex.  It may only be 1
            or 2.
    SMIN    (input) DOUBLE PRECISION
            The desired lower bound on the singular values of A.  This
            should be a safe distance away from underflow or overflow,
            say, between (underflow/machine precision) and  (machine
            precision * overflow ).  (See BIGNUM and ULP.)

    CA      (input) DOUBLE PRECISION
            The coefficient c, which A is multiplied by.

    A       (input) DOUBLE PRECISION array, dimension (LDA,NA)
            The NA x NA matrix A.

    LDA     (input) INTEGER
            The leading dimension of A.  It must be at least NA.

    D1      (input) DOUBLE PRECISION
            The 1,1 element in the diagonal matrix D.

    D2      (input) DOUBLE PRECISION
            The 2,2 element in the diagonal matrix D.  Not used if NW=1.

    B       (input) DOUBLE PRECISION array, dimension (LDB,NW)
            The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
            complex), column 1 contains the real part of B and column 2
            contains the imaginary part.

    LDB     (input) INTEGER
            The leading dimension of B.  It must be at least NA.

    WR      (input) DOUBLE PRECISION
            The real part of the scalar "w".

    WI      (input) DOUBLE PRECISION
            The imaginary part of the scalar "w".  Not used if NW=1.

    X       (output) DOUBLE PRECISION array, dimension (LDX,NW)
            The NA x NW matrix X (unknowns), as computed by DLALN2.
            If NW=2 ("w" is complex), on exit, column 1 will contain
            the real part of X and column 2 will contain the imaginary
            part.

    LDX     (input) INTEGER
            The leading dimension of X.  It must be at least NA.

    SCALE   (output) DOUBLE PRECISION
            The scale factor that B must be multiplied by to insure
            that overflow does not occur when computing X.  Thus,
            (ca A - w D) X  will be SCALE*B, not B (ignoring
            perturbations of A.)  It will be at most 1.

    XNORM   (output) DOUBLE PRECISION
            The infinity-norm of X, when X is regarded as an NA x NW
            real matrix.

    INFO    (output) INTEGER
            An error flag.  It will be set to zero if no error occurs,
            a negative number if an argument is in error, or a positive
            number if  ca A - w D  had to be perturbed.
            The possible values are:
            = 0: No error occurred, and (ca A - w D) did not have to be
                   perturbed.
            = 1: (ca A - w D) had to be perturbed to make its smallest
                 (or only) singular value greater than SMIN.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.

   =====================================================================
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;

    /* Function Body */

    /* Compute BIGNUM */

    smlnum = 2. * SAFEMINIMUM;
    bignum = 1. / smlnum;
    smini = max(*smin,smlnum);

    /* Don't check for input errors */

    *info = 0;

    /* Standard Initializations */

    *scale = 1.;

    if (*na == 1) {

        /* 1 x 1 (i.e., scalar) system C X = B */

        if (*nw == 1) {

            /*
                 Real 1x1 system.

                 C = ca A - w D
            */

            csr = *ca * a[a_dim1 + 1] - *wr * *d1;
            cnorm = abs(csr);

            /* If | C | < SMINI, use C = SMINI */

            if (cnorm < smini) {
                csr = smini;
                cnorm = smini;
                *info = 1;
            }

            /* Check scaling for X = B / C */

            bnorm = (d__1 = b[b_dim1 + 1], abs(d__1));
            if (cnorm < 1. && bnorm > 1.) {
                if (bnorm > bignum * cnorm) {
                    *scale = 1. / bnorm;
                }
            }

            /* Compute X */

            x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / csr;
            *xnorm = (d__1 = x[x_dim1 + 1], abs(d__1));
        } else {

            /*
                 Complex 1x1 system (w is complex)

                 C = ca A - w D
            */

            csr = *ca * a[a_dim1 + 1] - *wr * *d1;
            csi = -(*wi) * *d1;
            cnorm = abs(csr) + abs(csi);

            /* If | C | < SMINI, use C = SMINI */

            if (cnorm < smini) {
                csr = smini;
                csi = 0.;
                cnorm = smini;
                *info = 1;
            }

            /* Check scaling for X = B / C */

            bnorm = (d__1 = b[b_dim1 + 1], abs(d__1)) + (d__2 = b[(b_dim1 <<
                1) + 1], abs(d__2));
            if (cnorm < 1. && bnorm > 1.) {
                if (bnorm > bignum * cnorm) {
                    *scale = 1. / bnorm;
                }
            }

            /* Compute X */

            d__1 = *scale * b[b_dim1 + 1];
            d__2 = *scale * b[(b_dim1 << 1) + 1];
            dladiv_(&d__1, &d__2, &csr, &csi, &x[x_dim1 + 1], &x[(x_dim1 << 1)
                 + 1]);
            *xnorm = (d__1 = x[x_dim1 + 1], abs(d__1)) + (d__2 = x[(x_dim1 <<
                1) + 1], abs(d__2));
        }

    } else {

        /*
              2x2 System

              Compute the real part of C = ca A - w D (or ca A' - w D )
        */

        cr[0] = *ca * a[a_dim1 + 1] - *wr * *d1;
        cr[3] = *ca * a[(a_dim1 << 1) + 2] - *wr * *d2;
        if (*ltrans) {
            cr[2] = *ca * a[a_dim1 + 2];
            cr[1] = *ca * a[(a_dim1 << 1) + 1];
        } else {
            cr[1] = *ca * a[a_dim1 + 2];
            cr[2] = *ca * a[(a_dim1 << 1) + 1];
        }

        if (*nw == 1) {

            /*
                 Real 2x2 system (w is real)

                 Find the largest element in C
            */

            cmax = 0.;
            icmax = 0;

            for (j = 1; j <= 4; ++j) {
                if ((d__1 = crv[j - 1], abs(d__1)) > cmax) {
                    cmax = (d__1 = crv[j - 1], abs(d__1));
                    icmax = j;
                }
                /* L10: */
            }
        /* 如果 norm(C) < SMINI，则使用 SMINI*单位矩阵。 */

        if (cmax < smini) {
            /* 计算最大值 */
            d__3 = (d__1 = b[b_dim1 + 1], abs(d__1)), d__4 = (d__2 = b[
                b_dim1 + 2], abs(d__2));
            bnorm = max(d__3,d__4);
            if (smini < 1. && bnorm > 1.) {
                if (bnorm > bignum * smini) {
                    *scale = 1. / bnorm;
                }
            }
            temp = *scale / smini;
            x[x_dim1 + 1] = temp * b[b_dim1 + 1];
            x[x_dim1 + 2] = temp * b[b_dim1 + 2];
            *xnorm = temp * bnorm;
            *info = 1;
            return 0;
        }

        /* 使用完全主元高斯消元法。 */

        ur11 = crv[icmax - 1];
        cr21 = crv[ipivot[(icmax << 2) - 3] - 1];
        ur12 = crv[ipivot[(icmax << 2) - 2] - 1];
        cr22 = crv[ipivot[(icmax << 2) - 1] - 1];
        ur11r = 1. / ur11;
        lr21 = ur11r * cr21;
        ur22 = cr22 - ur12 * lr21;

        /* 如果较小的主元 < SMINI，则使用 SMINI。 */

        if (abs(ur22) < smini) {
            ur22 = smini;
            *info = 1;
        }
        if (rswap[icmax - 1]) {
            br1 = b[b_dim1 + 2];
            br2 = b[b_dim1 + 1];
        } else {
            br1 = b[b_dim1 + 1];
            br2 = b[b_dim1 + 2];
        }
        br2 -= lr21 * br1;
        /* 计算最大值 */
        d__2 = (d__1 = br1 * (ur22 * ur11r), abs(d__1)), d__3 = abs(br2);
        bbnd = max(d__2,d__3);
        if (bbnd > 1. && abs(ur22) < 1.) {
            if (bbnd >= bignum * abs(ur22)) {
                *scale = 1. / bbnd;
            }
        }

        xr2 = br2 * *scale / ur22;
        xr1 = *scale * br1 * ur11r - xr2 * (ur11r * ur12);
        if (zswap[icmax - 1]) {
            x[x_dim1 + 1] = xr2;
            x[x_dim1 + 2] = xr1;
        } else {
            x[x_dim1 + 1] = xr1;
            x[x_dim1 + 2] = xr2;
        }
        /* 计算最大值 */
        d__1 = abs(xr1), d__2 = abs(xr2);
        *xnorm = max(d__1,d__2);

        /* 如果 norm(A) * norm(X) > overflow，则进一步缩放。 */

        if (*xnorm > 1. && cmax > 1.) {
            if (*xnorm > bignum / cmax) {
                temp = cmax / bignum;
                x[x_dim1 + 1] = temp * x[x_dim1 + 1];
                x[x_dim1 + 2] = temp * x[x_dim1 + 2];
                *xnorm = temp * *xnorm;
                *scale = temp * *scale;
            }
        }
    } else {

        /*
                     复数 2x2 系统（w 是复数）

                     找出 C 中最大的元素
        */

        ci[0] = -(*wi) * *d1;
        ci[1] = 0.;
        ci[2] = 0.;
        ci[3] = -(*wi) * *d2;
        cmax = 0.;
        icmax = 0;

        for (j = 1; j <= 4; ++j) {
            if ((d__1 = crv[j - 1], abs(d__1)) + (d__2 = civ[j - 1], abs(
                d__2)) > cmax) {
                cmax = (d__1 = crv[j - 1], abs(d__1)) + (d__2 = civ[j - 1]
                    , abs(d__2));
                icmax = j;
            }
            /* L20: */
        }

        /* 如果 norm(C) < SMINI，则使用 SMINI*单位矩阵。 */

        if (cmax < smini) {

            /* 如果 norm(C) < SMINI，则使用 SMINI*单位矩阵。 */

            if (cmax < smini) {
/* Computing MAX */
/* 计算绝对值之和，确定最大值 */
d__5 = (d__1 = b[b_dim1 + 1], abs(d__1)) + (d__2 = b[(b_dim1 << 1) + 1], abs(d__2)), d__6 = (d__3 = b[b_dim1 + 2], abs(d__3)) + (d__4 = b[(b_dim1 << 1) + 2], abs(d__4));
bnorm = max(d__5,d__6);  // 计算最大值，确定矩阵B的范数

if (smini < 1. && bnorm > 1.) {
    // 如果 smini 小于 1 并且 bnorm 大于 1
    if (bnorm > bignum * smini) {
        *scale = 1. / bnorm;  // 设置尺度为1/bnorm
    }
}

temp = *scale / smini;  // 计算临时比例
x[x_dim1 + 1] = temp * b[b_dim1 + 1];  // 计算并存储更新后的向量x的第一个元素
x[x_dim1 + 2] = temp * b[b_dim1 + 2];  // 计算并存储更新后的向量x的第二个元素
x[(x_dim1 << 1) + 1] = temp * b[(b_dim1 << 1) + 1];  // 计算并存储更新后的向量x的第三个元素
x[(x_dim1 << 1) + 2] = temp * b[(b_dim1 << 1) + 2];  // 计算并存储更新后的向量x的第四个元素
*xnorm = temp * bnorm;  // 计算并存储更新后的向量x的范数
*info = 1;  // 设置信息码为1，表示成功
return 0;  // 返回0，表示函数执行成功结束
}

/*           Gaussian elimination with complete pivoting. */
/* 使用完全主元高斯消元法 */

ur11 = crv[icmax - 1];  // 设置变量ur11为crv数组的第(icmax-1)个元素
ui11 = civ[icmax - 1];  // 设置变量ui11为civ数组的第(icmax-1)个元素
cr21 = crv[ipivot[(icmax << 2) - 3] - 1];  // 设置变量cr21为crv数组中根据ipivot数组计算出的索引值
ci21 = civ[ipivot[(icmax << 2) - 3] - 1];  // 设置变量ci21为civ数组中根据ipivot数组计算出的索引值
ur12 = crv[ipivot[(icmax << 2) - 2] - 1];  // 设置变量ur12为crv数组中根据ipivot数组计算出的索引值
ui12 = civ[ipivot[(icmax << 2) - 2] - 1];  // 设置变量ui12为civ数组中根据ipivot数组计算出的索引值
cr22 = crv[ipivot[(icmax << 2) - 1] - 1];  // 设置变量cr22为crv数组中根据ipivot数组计算出的索引值
ci22 = civ[ipivot[(icmax << 2) - 1] - 1];  // 设置变量ci22为civ数组中根据ipivot数组计算出的索引值

if (icmax == 1 || icmax == 4) {
    // 如果icmax等于1或4

/*              Code when off-diagonals of pivoted C are real */
/*              当旋转后的C的非对角线元素为实数时的代码 */

    if (abs(ur11) > abs(ui11)) {
        temp = ui11 / ur11;  // 计算比例系数
        ur11r = 1. / (ur11 * (temp * temp + 1.));  // 计算ur11r
        ui11r = -temp * ur11r;  // 计算ui11r
    } else {
        temp = ur11 / ui11;  // 计算比例系数
        ui11r = -1. / (ui11 * (temp * temp + 1.));  // 计算ui11r
        ur11r = -temp * ui11r;  // 计算ur11r
    }
    lr21 = cr21 * ur11r;  // 计算lr21
    li21 = cr21 * ui11r;  // 计算li21
    ur12s = ur12 * ur11r;  // 计算ur12s
    ui12s = ur12 * ui11r;  // 计算ui12s
    ur22 = cr22 - ur12 * lr21;  // 计算ur22
    ui22 = ci22 - ur12 * li21;  // 计算ui22
} else {

/*              Code when diagonals of pivoted C are real */
/*              当旋转后的C的对角线元素为实数时的代码 */

    ur11r = 1. / ur11;  // 计算ur11r
    ui11r = 0.;  // 设置ui11r为0
    lr21 = cr21 * ur11r;  // 计算lr21
    li21 = ci21 * ur11r;  // 计算li21
    ur12s = ur12 * ur11r;  // 计算ur12s
    ui12s = ui12 * ur11r;  // 计算ui12s
    ur22 = cr22 - ur12 * lr21 + ui12 * li21;  // 计算ur22
    ui22 = -ur12 * li21 - ui12 * lr21;  // 计算ui22
}
u22abs = abs(ur22) + abs(ui22);  // 计算ur22和ui22的绝对值之和

/*           If smaller pivot < SMINI, use SMINI */
/*           如果较小的主元小于SMINI，则使用SMINI */

if (u22abs < smini) {
    ur22 = smini;  // 设置ur22为smini
    ui22 = 0.;  // 设置ui22为0
    *info = 1;  // 设置信息码为1，表示成功
}

if (rswap[icmax - 1]) {
    // 如果rswap数组中的第(icmax-1)个元素为真
    br2 = b[b_dim1 + 1];  // 设置br2为b矩阵的特定元素
    br1 = b[b_dim1 + 2];  // 设置br1为b矩阵的特定元素
    bi2 = b[(b_dim1 << 1) + 1];  // 设置bi2为b矩阵的特定元素
    bi1 = b[(b_dim1 << 1) + 2];  // 设置bi1为b矩阵的特定元素
} else {
    // 如果rswap数组中的第(icmax-1)个元素为假
    br1 = b[b_dim1 + 1];  // 设置br1为b矩阵的特定元素
    br2 = b[b_dim1 + 2];  // 设置br2为b矩阵的特定元素
    bi1 = b[(b_dim1 << 1) + 1];  // 设置bi1为b矩阵的特定元素
    bi2 = b[(b_dim1 << 1) + 2];  // 设置bi2为b矩阵的特定元素
}

br2 = br2 - lr21 * br1 + li21 * bi1;  // 计算并更新br2
bi2 = bi2 - li21 * br1 - lr21 * bi1;  // 计算并更新bi2
/* Computing MAX */
/* 计算两个表达式的最大值 */
        d__1 = (abs(br1) + abs(bi1)) * (u22abs * (abs(ur11r) + abs(ui11r))
            ), d__2 = abs(br2) + abs(bi2);
        bbnd = max(d__1,d__2);
        /* 如果 bbnd 超过了 1 并且 u22abs 小于 1 */
        if (bbnd > 1. && u22abs < 1.) {
        /* 如果 bbnd 大于等于 bignum 与 u22abs 的乘积 */
            if (bbnd >= bignum * u22abs) {
                *scale = 1. / bbnd;
                br1 = *scale * br1;
                bi1 = *scale * bi1;
                br2 = *scale * br2;
                bi2 = *scale * bi2;
            }
        }

        /* 调用 dladiv_ 函数计算复数的除法 */
        dladiv_(&br2, &bi2, &ur22, &ui22, &xr2, &xi2);
        /* 计算更新后的 x 向量的部分 */
        xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2;
        xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2;
        /* 根据 zswap[icmax - 1] 的值来交换 x 向量的元素 */
        if (zswap[icmax - 1]) {
            x[x_dim1 + 1] = xr2;
            x[x_dim1 + 2] = xr1;
            x[(x_dim1 << 1) + 1] = xi2;
            x[(x_dim1 << 1) + 2] = xi1;
        } else {
            x[x_dim1 + 1] = xr1;
            x[x_dim1 + 2] = xr2;
            x[(x_dim1 << 1) + 1] = xi1;
            x[(x_dim1 << 1) + 2] = xi2;
        }
/* Computing MAX */
/* 计算两个表达式的最大值 */
        d__1 = abs(xr1) + abs(xi1), d__2 = abs(xr2) + abs(xi2);
        *xnorm = max(d__1,d__2);

/*           Further scaling if  norm(A) norm(X) > overflow */
/* 如果 norm(A) 和 norm(X) 的乘积大于 overflow，则进一步缩放 */

        if (*xnorm > 1. && cmax > 1.) {
        /* 如果 xnorm 大于 bignum 与 cmax 的比值 */
            if (*xnorm > bignum / cmax) {
                temp = cmax / bignum;
                x[x_dim1 + 1] = temp * x[x_dim1 + 1];
                x[x_dim1 + 2] = temp * x[x_dim1 + 2];
                x[(x_dim1 << 1) + 1] = temp * x[(x_dim1 << 1) + 1];
                x[(x_dim1 << 1) + 2] = temp * x[(x_dim1 << 1) + 2];
                *xnorm = temp * *xnorm;
                *scale = temp * *scale;
            }
        }
    }
    }

    return 0;

/*     End of DLALN2 */

} /* dlaln2_ */

#undef crv
#undef civ
#undef cr
#undef ci


/* Subroutine */ int dlals0_(integer *icompq, integer *nl, integer *nr,
    integer *sqre, integer *nrhs, doublereal *b, integer *ldb, doublereal
    *bx, integer *ldbx, integer *perm, integer *givptr, integer *givcol,
    integer *ldgcol, doublereal *givnum, integer *ldgnum, doublereal *
    poles, doublereal *difl, doublereal *difr, doublereal *z__, integer *
    k, doublereal *c__, doublereal *s, doublereal *work, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, b_dim1, b_offset, bx_dim1, bx_offset,
        difr_dim1, difr_offset, givnum_dim1, givnum_offset, poles_dim1,
        poles_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, m, n;
    static doublereal dj;
    static integer nlp1;
    static doublereal temp;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);
    extern doublereal dnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    static doublereal diflj, difrj, dsigj;
    # 声明外部函数 dgemv_ 和 dcopy_，这些函数是在其他地方定义的，用于执行矩阵向量乘法和向量复制操作
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *), dcopy_(integer *,
        doublereal *, integer *, doublereal *, integer *);

    # 声明外部函数 dlamc3_、dlascl_、dlacpy_ 和 xerbla_，这些函数也是在其他地方定义的，
    # 分别用于机器精度控制、矩阵缩放、矩阵复制和错误处理
    extern doublereal dlamc3_(doublereal *, doublereal *);
    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), dlacpy_(char *, integer *, integer
        *, doublereal *, integer *, doublereal *, integer *),
        xerbla_(char *, integer *);

    # 声明静态变量 dsigjp，用于存储双精度浮点数类型的值，其作用域仅限于当前文件
    static doublereal dsigjp;
"""
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======
DLALS0 applies back the multiplying factors of either the left or the
right singular vector matrix of a diagonal matrix appended by a row
to the right hand side matrix B in solving the least squares problem
using the divide-and-conquer SVD approach.

For the left singular vector matrix, three types of orthogonal
matrices are involved:

(1L) Givens rotations: the number of such rotations is GIVPTR; the
     pairs of columns/rows they were applied to are stored in GIVCOL;
     and the C- and S-values of these rotations are stored in GIVNUM.

(2L) Permutation. The (NL+1)-st row of B is to be moved to the first
     row, and for J=2:N, PERM(J)-th row of B is to be moved to the
     J-th row.

(3L) The left singular vector matrix of the remaining matrix.

For the right singular vector matrix, four types of orthogonal
matrices are involved:

(1R) The right singular vector matrix of the remaining matrix.

(2R) If SQRE = 1, one extra Givens rotation to generate the right
     null space.

(3R) The inverse transformation of (2L).

(4R) The inverse transformation of (1L).

Arguments
=========
ICOMPQ (input) INTEGER
       Specifies whether singular vectors are to be computed in
       factored form:
       = 0: Left singular vector matrix.
       = 1: Right singular vector matrix.

NL     (input) INTEGER
       The row dimension of the upper block. NL >= 1.

NR     (input) INTEGER
       The row dimension of the lower block. NR >= 1.

SQRE   (input) INTEGER
       = 0: the lower block is an NR-by-NR square matrix.
       = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

       The bidiagonal matrix has row dimension N = NL + NR + 1,
       and column dimension M = N + SQRE.

NRHS   (input) INTEGER
       The number of columns of B and BX. NRHS must be at least 1.

B      (input/output) DOUBLE PRECISION array, dimension ( LDB, NRHS )
       On input, B contains the right hand sides of the least
       squares problem in rows 1 through M. On output, B contains
       the solution X in rows 1 through N.

LDB    (input) INTEGER
       The leading dimension of B. LDB must be at least
       max(1,MAX( M, N ) ).

BX     (workspace) DOUBLE PRECISION array, dimension ( LDBX, NRHS )

LDBX   (input) INTEGER
       The leading dimension of BX.

PERM   (input) INTEGER array, dimension ( N )
       The permutations (from deflation and sorting) applied
       to the two blocks.

GIVPTR (input) INTEGER
       The number of Givens rotations which took place in this
       subproblem.
"""
    # GIVCOL 是一个输入的整数数组，维度为 (LDGCOL, 2)。
    # 每一对数表示参与 Givens 旋转的行或列。

    # LDGCOL 是 GIVCOL 的前导维度，至少为 N。

    # GIVNUM 是一个输入的双精度浮点数数组，维度为 (LDGNUM, 2)。
    # 每个数表示相应 Givens 旋转中使用的 C 或 S 值。

    # LDGNUM 是数组 DIFR、POLES 和 GIVNUM 的前导维度，至少为 K。

    # POLES 是一个输入的双精度浮点数数组，维度为 (LDGNUM, 2)。
    # 在输入时，POLES(1:K, 1) 包含从解特征方程得到的新奇异值，
    # POLES(1:K, 2) 是包含特征方程中极点的数组。

    # DIFL 是一个输入的双精度浮点数数组，维度为 (K)。
    # 在输入时，DIFL(I) 是第 I 个更新（未缩减）奇异值与第 I 个旧（未缩减）奇异值之间的距离。

    # DIFR 是一个输入的双精度浮点数数组，维度为 (LDGNUM, 2)。
    # 在输入时，DIFR(I, 1) 包含第 I 个更新（未缩减）奇异值与第 I+1 个（未缩减）旧奇异值之间的距离。
    # DIFR(I, 2) 是第 I 个右奇异向量的归一化因子。

    # Z 是一个输入的双精度浮点数数组，维度为 (K)。
    # 包含调整缩减后的更新行向量的分量。

    # K 是一个输入的整数，表示非缩减矩阵的维度，
    # 这是相关特征方程的阶数。1 <= K <= N。

    # C 是一个输入的双精度浮点数。
    # 如果 SQRE = 0，则 C 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 C 值。

    # S 是一个输入的双精度浮点数。
    # 如果 SQRE = 0，则 S 包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 S 值。

    # WORK 是一个工作区的双精度浮点数数组，维度为 (K)。

    # INFO 是输出的整数。
    # = 0 表示成功退出。
    # < 0 表示如果 INFO = -i，则第 i 个参数具有非法值。

    # 进一步的细节
    # ===============
    # 根据以下贡献编写：
    #    Ming Gu 和 Ren-Cang Li，加州大学伯克利分校，计算机科学部，美国
    #    Osni Marques，LBNL/NERSC，美国

    # =====================================================================

    # 测试输入参数。
    /*
        参数调整
    */
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    --perm;
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    difr_dim1 = *ldgnum;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    poles_dim1 = *ldgnum;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    givnum_dim1 = *ldgnum;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    --difl;
    --z__;
    --work;

    /*
        函数体
    */
    *info = 0;

    /*
        检查参数 *icompq 的合法性
    */
    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*nl < 1) {
        *info = -2;
    } else if (*nr < 1) {
        *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -4;
    }

    /*
        计算矩阵的维度 n
    */
    n = *nl + *nr + 1;

    /*
        检查参数 *nrhs 的合法性
    */
    if (*nrhs < 1) {
        *info = -5;
    } else if (*ldb < n) {
        *info = -7;
    } else if (*ldbx < n) {
        *info = -9;
    } else if (*givptr < 0) {
        *info = -11;
    } else if (*ldgcol < n) {
        *info = -13;
    } else if (*ldgnum < n) {
        *info = -15;
    } else if (*k < 1) {
        *info = -20;
    }

    /*
        如果存在错误，调用错误处理函数 xerbla_
    */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLALS0", &i__1);
        return 0;
    }

    /*
        计算矩阵的行数 m 和 nlp1
    */
    m = n + *sqre;
    nlp1 = *nl + 1;

    /*
        如果 *icompq == 0，执行以下步骤：
    */

    /*
        步骤 (1L): 对左侧应用反正交变换
    */
    i__1 = *givptr;
    for (i__ = 1; i__ <= i__1; ++i__) {
        drot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &givnum[i__ + givnum_dim1]);
    }

    /*
        步骤 (2L): 排列 B 的行
    */
    dcopy_(nrhs, &b[nlp1 + b_dim1], ldb, &bx[bx_dim1 + 1], ldbx);
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        dcopy_(nrhs, &b[perm[i__] + b_dim1], ldb, &bx[i__ + bx_dim1],
            ldbx);
    }

    /*
        步骤 (3L): 对 BX 应用左奇异向量矩阵的逆
    */
    if (*k == 1) {
        dcopy_(nrhs, &bx[bx_offset], ldbx, &b[b_offset], ldb);
        if (z__[1] < 0.) {
            dscal_(nrhs, &c_b151, &b[b_offset], ldb);
        }
    }
    } else {
        // 如果条件不满足上面的情况，则执行以下循环
        i__1 = *k;
        // 循环从1到*k，对每个j执行以下操作
        for (j = 1; j <= i__1; ++j) {
            // 获取difl数组的第j个元素
            diflj = difl[j];
            // 获取poles数组的第j行第二列的元素
            dj = poles[j + poles_dim1];
            // 获取poles数组的第j行第三列的元素，并取负数
            dsigj = -poles[j + (poles_dim1 << 1)];
            // 如果j小于*k，执行以下操作
            if (j < *k) {
                // 获取difr数组的第j行第一列的元素，并取负数
                difrj = -difr[j + difr_dim1];
                // 获取poles数组的第j+1行第三列的元素，并取负数
                dsigjp = -poles[j + 1 + (poles_dim1 << 1)];
            }
            // 如果z__数组的第j个元素等于0或者poles数组的第j行第三列的元素等于0
            if (z__[j] == 0. || poles[j + (poles_dim1 << 1)] == 0.) {
                // 将work数组的第j个元素设为0
                work[j] = 0.;
            } else {
                // 否则，根据给定公式计算work数组的第j个元素的值
                work[j] = -poles[j + (poles_dim1 << 1)] * z__[j] / diflj /
                     (poles[j + (poles_dim1 << 1)] + dj);
            }
            // 设置i__2为j-1
            i__2 = j - 1;
            // 循环从1到i__2，对每个i__执行以下操作
            for (i__ = 1; i__ <= i__2; ++i__) {
                // 如果z__数组的第i__个元素等于0或者poles数组的第i__行第三列的元素等于0
                if (z__[i__] == 0. || poles[i__ + (poles_dim1 << 1)] ==
                    0.) {
                    // 将work数组的第i__个元素设为0
                    work[i__] = 0.;
                } else {
                    // 否则，根据给定公式计算work数组的第i__个元素的值
                    work[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                        / (dlamc3_(&poles[i__ + (poles_dim1 << 1)], &
                        dsigj) - diflj) / (poles[i__ + (poles_dim1 <<
                        1)] + dj);
                }
                // 继续下一个i__的循环
            }
            // 继续下一个j的循环

                // 继续下一个i__的循环
            }
            // 继续下一个j的循环
        }
        // 如果条件不满足上面的情况，函数执行完毕
    }
/* L30: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            // 如果 z__[i__] 或 poles[i__ + (poles_dim1 << 1)] 为零，则将 work[i__] 设为零
            if (z__[i__] == 0. || poles[i__ + (poles_dim1 << 1)] == 0.) {
                work[i__] = 0.;
            } else {
                // 根据公式计算 work[i__]
                work[i__] = poles[i__ + (poles_dim1 << 1)] * z__[i__]
                    / (dlamc3_(&poles[i__ + (poles_dim1 << 1)], &
                    dsigjp) + difrj) / (poles[i__ + (poles_dim1 <<
                     1)] + dj);
            }
/* L40: */
        }
        // 将 work[1] 设为 -1
        work[1] = -1.;
        // 计算向量的二范数
        temp = dnrm2_(k, &work[1], &c__1);
        // 执行矩阵-向量乘法，将结果累加到 B 的相应列
        dgemv_("T", k, nrhs, &c_b15, &bx[bx_offset], ldbx, &work[1], &
            c__1, &c_b29, &b[j + b_dim1], ldb);
        // 将 B 的部分行进行缩放
        dlascl_("G", &c__0, &c__0, &temp, &c_b15, &c__1, nrhs, &b[j +
            b_dim1], ldb, info);
/* L50: */
        }
    }

/*        Move the deflated rows of BX to B also. */

    // 如果 k < max(m,n)，则将 BX 的一部分行复制到 B
    if (*k < max(m,n)) {
        i__1 = n - *k;
        dlacpy_("A", &i__1, nrhs, &bx[*k + 1 + bx_dim1], ldbx, &b[*k + 1
            + b_dim1], ldb);
    }
    } else {

/*
          Apply back the right orthogonal transformations.

          Step (1R): apply back the new right singular vector matrix
          to B.
*/

    // 如果 k == 1，直接复制 B 的内容到 BX
    if (*k == 1) {
        dcopy_(nrhs, &b[b_offset], ldb, &bx[bx_offset], ldbx);
    } else {
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
        dsigj = poles[j + (poles_dim1 << 1)];
        // 如果 z__[j] 为零，则将 work[j] 设为零
        if (z__[j] == 0.) {
            work[j] = 0.;
        } else {
            // 根据公式计算 work[j]
            work[j] = -z__[j] / difl[j] / (dsigj + poles[j +
                poles_dim1]) / difr[j + (difr_dim1 << 1)];
        }
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            // 如果 z__[j] 为零，则将 work[i__] 设为零
            if (z__[j] == 0.) {
            work[i__] = 0.;
            } else {
                // 根据公式计算 work[i__]
                d__1 = -poles[i__ + 1 + (poles_dim1 << 1)];
                work[i__] = z__[j] / (dlamc3_(&dsigj, &d__1) - difr[
                    i__ + difr_dim1]) / (dsigj + poles[i__ +
                    poles_dim1]) / difr[i__ + (difr_dim1 << 1)];
            }
/* L60: */
        }
        i__2 = *k;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            // 如果 z__[j] 为零，则将 work[i__] 设为零
            if (z__[j] == 0.) {
            work[i__] = 0.;
            } else {
                // 根据公式计算 work[i__]
                d__1 = -poles[i__ + (poles_dim1 << 1)];
                work[i__] = z__[j] / (dlamc3_(&dsigj, &d__1) - difl[
                    i__]) / (dsigj + poles[i__ + poles_dim1]) /
                    difr[i__ + (difr_dim1 << 1)];
            }
/* L70: */
        }
        // 执行矩阵-向量乘法，将结果累加到 BX 的相应列
        dgemv_("T", k, nrhs, &c_b15, &b[b_offset], ldb, &work[1], &
            c__1, &c_b29, &bx[j + bx_dim1], ldbx);
/* L80: */
        }
    }

/*
          Step (2R): if SQRE = 1, apply back the rotation that is
          related to the right null space of the subproblem.
*/

    // 如果 SQRE = 1，将 B 的部分内容复制到 BX，并进行旋转
    if (*sqre == 1) {
        dcopy_(nrhs, &b[m + b_dim1], ldb, &bx[m + bx_dim1], ldbx);
        drot_(nrhs, &bx[bx_dim1 + 1], ldbx, &bx[m + bx_dim1], ldbx, c__,
            s);
    }
    # 如果 k 的值小于 m 和 n 中的较大值时，执行以下操作
    if (*k < max(m,n)) {
        # 计算要复制的元素数量
        i__1 = n - *k;
        # 调用 dlacpy 函数，将 b[*k + 1 + b_dim1] 处的子矩阵复制到 bx[*k + 1 + bx_dim1] 处
        dlacpy_("A", &i__1, nrhs, &b[*k + 1 + b_dim1], ldb, &bx[*k + 1 + bx_dim1], ldbx);
    }
/*        Step (3R): permute rows of B. */

    dcopy_(nrhs, &bx[bx_dim1 + 1], ldbx, &b[nlp1 + b_dim1], ldb);
    // 将 B 的部分行按照 perm 数组中的排列顺序重新排列

    if (*sqre == 1) {
        dcopy_(nrhs, &bx[m + bx_dim1], ldbx, &b[m + b_dim1], ldb);
        // 如果 sqre 等于 1，再次按照 perm 数组中的排列顺序重新排列 B 的另一部分行
    }

    // 对于每个 i，将 bx[i__+bx_dim1] 的内容复制到 b[perm[i__]+b_dim1] 处
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
        dcopy_(nrhs, &bx[i__ + bx_dim1], ldbx, &b[perm[i__] + b_dim1],
            ldb);
        // permute 行的操作，将 bx 中的行数据复制到 b 中对应位置，依据 perm 数组的排列顺序
    }
/* L90: */

/*        Step (4R): apply back the Givens rotations performed. */

    // 逆向应用之前执行的 Givens 旋转
    for (i__ = *givptr; i__ >= 1; --i__) {
        // 计算旋转的参数
        d__1 = -givnum[i__ + givnum_dim1];
        // 应用 Givens 旋转到 b 中的列向量
        drot_(nrhs, &b[givcol[i__ + (givcol_dim1 << 1)] + b_dim1], ldb, &
            b[givcol[i__ + givcol_dim1] + b_dim1], ldb, &givnum[i__ +
            (givnum_dim1 << 1)], &d__1);
/* L100: */
    }
    // 返回成功的标志
    }

    return 0;

/*     End of DLALS0 */

} /* dlals0_ */

/* Subroutine */ int dlalsa_(integer *icompq, integer *smlsiz, integer *n,
    integer *nrhs, doublereal *b, integer *ldb, doublereal *bx, integer *
    ldbx, doublereal *u, integer *ldu, doublereal *vt, integer *k,
    doublereal *difl, doublereal *difr, doublereal *z__, doublereal *
    poles, integer *givptr, integer *givcol, integer *ldgcol, integer *
    perm, doublereal *givnum, doublereal *c__, doublereal *s, doublereal *
    work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, b_dim1,
        b_offset, bx_dim1, bx_offset, difl_dim1, difl_offset, difr_dim1,
        difr_offset, givnum_dim1, givnum_offset, poles_dim1, poles_offset,
         u_dim1, u_offset, vt_dim1, vt_offset, z_dim1, z_offset, i__1,
        i__2;

    /* Local variables */
    static integer i__, j, i1, ic, lf, nd, ll, nl, nr, im1, nlf, nrf, lvl,
        ndb1, nlp1, lvl2, nrp1, nlvl, sqre;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static integer inode, ndiml, ndimr;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dlals0_(integer *, integer *, integer *,
         integer *, integer *, doublereal *, integer *, doublereal *,
        integer *, integer *, integer *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, integer *, doublereal *, doublereal *, doublereal *,
         integer *), dlasdt_(integer *, integer *, integer *, integer *,
        integer *, integer *, integer *), xerbla_(char *, integer *);

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DLALSA is an intermediate step in solving the least squares problem
    by computing the SVD of the coefficient matrix in compact form (The
    ```
    singular vectors are computed as products of simple orthorgonal
    matrices.).



    If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
    matrix of an upper bidiagonal matrix to the right hand side; and if
    ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
    right hand side. The singular vector matrices were generated in
    compact form by DLALSA.



    Arguments
    =========



    ICOMPQ (input) INTEGER
           Specifies whether the left or the right singular vector
           matrix is involved.
           = 0: Left singular vector matrix
           = 1: Right singular vector matrix



    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.



    N      (input) INTEGER
           The row and column dimensions of the upper bidiagonal matrix.



    NRHS   (input) INTEGER
           The number of columns of B and BX. NRHS must be at least 1.



    B      (input/output) DOUBLE PRECISION array, dimension ( LDB, NRHS )
           On input, B contains the right hand sides of the least
           squares problem in rows 1 through M.
           On output, B contains the solution X in rows 1 through N.



    LDB    (input) INTEGER
           The leading dimension of B in the calling subprogram.
           LDB must be at least max(1,MAX( M, N ) ).



    BX     (output) DOUBLE PRECISION array, dimension ( LDBX, NRHS )
           On exit, the result of applying the left or right singular
           vector matrix to B.



    LDBX   (input) INTEGER
           The leading dimension of BX.



    U      (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
           On entry, U contains the left singular vector matrices of all
           subproblems at the bottom level.



    LDU    (input) INTEGER, LDU = > N.
           The leading dimension of arrays U, VT, DIFL, DIFR,
           POLES, GIVNUM, and Z.



    VT     (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
           On entry, VT' contains the right singular vector matrices of
           all subproblems at the bottom level.



    K      (input) INTEGER array, dimension ( N ).



    DIFL   (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
           where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.



    DIFR   (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
           distances between singular values on the I-th level and
           singular values on the (I -1)-th level, and DIFR(*, 2 * I)
           record the normalizing factors of the right singular vectors
           matrices of subproblems on I-th level.



    Z      (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
           On entry, Z(1, I) contains the components of the deflation-
           adjusted updating row vector for subproblems on the I-th
           level.
    ! POLES 是一个输入参数，是一个大小为 (LDU, 2 * NLVL) 的双精度数组。
    ! 在输入时，POLES(*, 2 * I - 1: 2 * I) 包含了第 I 级别上参与的奇异值的新旧值。
    POLES  (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
           singular values involved in the secular equations on the I-th
           level.

    ! GIVPTR 是一个输入参数，是一个大小为 N 的整数数组。
    ! 在输入时，GIVPTR( I ) 记录了计算树上第 I 个问题上执行的 Givens 旋转的数量。
    GIVPTR (input) INTEGER array, dimension ( N ).
           On entry, GIVPTR( I ) records the number of Givens
           rotations performed on the I-th problem on the computation
           tree.

    ! GIVCOL 是一个输入参数，是一个大小为 (LDGCOL, 2 * NLVL) 的整数数组。
    ! 对于每个 I，GIVCOL(*, 2 * I - 1: 2 * I) 记录了计算树上第 I 级别上执行的 Givens 旋转的位置。
    GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
           On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
           locations of Givens rotations performed on the I-th level on
           the computation tree.

    ! LDGCOL 是一个输入参数，是整数，LDGCOL = > N。
    ! 数组 GIVCOL 和 PERM 的前导维度。
    LDGCOL (input) INTEGER, LDGCOL = > N.
           The leading dimension of arrays GIVCOL and PERM.

    ! PERM 是一个输入参数，是一个大小为 (LDGCOL, NLVL) 的整数数组。
    ! 在输入时，PERM(*, I) 记录了在计算树的第 I 级别上执行的排列。
    PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
           On entry, PERM(*, I) records permutations done on the I-th
           level of the computation tree.

    ! GIVNUM 是一个输入参数，是一个大小为 (LDU, 2 * NLVL) 的双精度数组。
    ! 在输入时，GIVNUM(*, 2 *I -1 : 2 * I) 记录了在计算树的第 I 级别上执行的 Givens 旋转的 C 和 S 值。
    GIVNUM (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
           On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
           values of Givens rotations performed on the I-th level on the
           computation tree.

    ! C 是一个输入参数，是一个大小为 N 的双精度数组。
    ! 如果第 I 个子问题不是方形的，在输入时，C( I ) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 C 值。
    C      (input) DOUBLE PRECISION array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           C( I ) contains the C-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    ! S 是一个输入参数，是一个大小为 N 的双精度数组。
    ! 如果第 I 个子问题不是方形的，在输入时，S( I ) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 S 值。
    S      (input) DOUBLE PRECISION array, dimension ( N ).
           On entry, if the I-th subproblem is not square,
           S( I ) contains the S-value of a Givens rotation related to
           the right null space of the I-th subproblem.

    ! WORK 是一个工作空间数组，是一个大小至少为 N 的双精度数组。
    WORK   (workspace) DOUBLE PRECISION array.
           The dimension must be at least N.

    ! IWORK 是一个工作空间数组，是一个大小至少为 3 * N 的整数数组。
    IWORK  (workspace) INTEGER array.
           The dimension must be at least 3 * N

    ! INFO 是一个输出参数，是一个整数。
    ! = 0: 成功退出。
    ! < 0: 如果 INFO = -i，则第 i 个参数具有非法值。
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    ! 进一步的细节
    ! ===============
    ! 基于以下贡献
    !    Ming Gu 和 Ren-Cang Li, 加州大学伯克利分校，美国计算机科学部
    !    Osni Marques, LBNL/NERSC, 美国

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    ! 测试输入参数。
    =====================================================================

    ! 测试输入参数。
       Test the input parameters.
    /* Parameter adjustments */
    // Adjusting the pointer and offset for matrix B
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    // Adjusting the pointer and offset for matrix BX
    bx_dim1 = *ldbx;
    bx_offset = 1 + bx_dim1;
    bx -= bx_offset;
    // Adjusting the pointer and offset for matrix Givens rotations
    givnum_dim1 = *ldu;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;
    // Adjusting the pointer and offset for matrix poles
    poles_dim1 = *ldu;
    poles_offset = 1 + poles_dim1;
    poles -= poles_offset;
    // Adjusting the pointer and offset for matrix Z
    z_dim1 = *ldu;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    // Adjusting the pointer and offset for matrix difr
    difr_dim1 = *ldu;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    // Adjusting the pointer and offset for matrix difl
    difl_dim1 = *ldu;
    difl_offset = 1 + difl_dim1;
    difl -= difl_offset;
    // Adjusting the pointer and offset for matrix VT
    vt_dim1 = *ldu;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    // Adjusting the pointer and offset for matrix U
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    // Adjusting the indices for k and givptr
    --k;
    --givptr;
    // Adjusting the pointer and offset for matrix perm
    perm_dim1 = *ldgcol;
    perm_offset = 1 + perm_dim1;
    perm -= perm_offset;
    // Adjusting the pointer and offset for matrix givcol
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;
    // Adjusting the pointers for arrays c__, s, work, and iwork
    --c__;
    --s;
    --work;
    --iwork;

    /* Function Body */
    // Initialize info to 0
    *info = 0;

    // Checking validity of icompq parameter
    if (*icompq < 0 || *icompq > 1) {
        // Set info to indicate invalid parameter
        *info = -1;
    } else if (*smlsiz < 3) {
        // Set info to indicate invalid smlsiz parameter
        *info = -2;
    } else if (*n < *smlsiz) {
        // Set info to indicate invalid n parameter
        *info = -3;
    } else if (*nrhs < 1) {
        // Set info to indicate invalid nrhs parameter
        *info = -4;
    } else if (*ldb < *n) {
        // Set info to indicate invalid ldb parameter
        *info = -6;
    } else if (*ldbx < *n) {
        // Set info to indicate invalid ldbx parameter
        *info = -8;
    } else if (*ldu < *n) {
        // Set info to indicate invalid ldu parameter
        *info = -10;
    } else if (*ldgcol < *n) {
        // Set info to indicate invalid ldgcol parameter
        *info = -19;
    }
    // If info is not 0, call error handling routine and return
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLALSA", &i__1);
        return 0;
    }

    /* Book-keeping and setting up the computation tree. */

    // Initialize inode, ndiml, and ndimr
    inode = 1;
    ndiml = inode + *n;
    ndimr = ndiml + *n;

    // Call utility function to set up divide-and-conquer tree
    dlasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr], smlsiz);

/*
   The following code applies back the left singular vector factors.
   For applying back the right singular vector factors, go to 50.
*/

    // Check if applying left singular vectors is required
    if (*icompq == 1) {
        goto L50;
    }

/*
   The nodes on the bottom level of the tree were solved
   by DLASDQ. The corresponding left and right singular vector
   matrices are in explicit form. First apply back the left
   singular vector matrices.
*/

    // Determine starting index for applying left singular vectors
    ndb1 = (nd + 1) / 2;
    // Loop over nodes to apply left singular vector matrices
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
      IC : center row of each node
      NL : number of rows of left subproblem
      NR : number of rows of right subproblem
      NLF: starting row of the left subproblem
      NRF: starting row of the right subproblem
*/

        i1 = i__ - 1;
        ic = iwork[inode + i1];
        nl = iwork[ndiml + i1];
        nr = iwork[ndimr + i1];
        nlf = ic - nl;
        nrf = ic + 1;
        // Apply left singular vector matrices
        dgemm_("T", "N", &nl, nrhs, &nl, &c_b15, &u[nlf + u_dim1], ldu, &b[
            nlf + b_dim1], ldb, &c_b29, &bx[nlf + bx_dim1], ldbx);
        dgemm_("T", "N", &nr, nrhs, &nr, &c_b15, &u[nrf + u_dim1], ldu, &b[
            nrf + b_dim1], ldb, &c_b29, &bx[nrf + bx_dim1], ldbx);
    }

/*
   Next copy the rows of B that correspond to unchanged rows
   in the bidiagonal matrix to BX.
*/

    // Continue with the next part of the algorithm
    i__1 = nd;
    # 循环遍历从 1 到 i__1 的整数序列，其中 i__1 是循环上限
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 获取索引值 ic，该值从数组 iwork 中获取，使用节点 inode 和当前循环变量 i__ 计算得到
        ic = iwork[inode + i__ - 1];
        # 调用名为 dcopy_ 的函数，复制长度为 nrhs 的向量 b[ic + b_dim1] 到 bx[ic + bx_dim1]
        # ldb 是 b 数组的列数，ldb 是 bx 数组的列数
        dcopy_(nrhs, &b[ic + b_dim1], ldb, &bx[ic + bx_dim1], ldbx);
/* L20: */
    }

/*
       Finally go through the left singular vector matrices of all
       the other subproblems bottom-up on the tree.
*/

    j = pow_ii(&c__2, &nlvl);
    sqre = 0;

    for (lvl = nlvl; lvl >= 1; --lvl) {
    lvl2 = (lvl << 1) - 1;

/*
          find the first node LF and last node LL on
          the current level LVL
*/

    if (lvl == 1) {
        lf = 1;  // 如果当前层级是第一层，则第一个节点 LF 是 1
        ll = 1;  // 如果当前层级是第一层，则最后一个节点 LL 是 1
    } else {
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);  // 计算非第一层的第一个节点 LF
        ll = (lf << 1) - 1;         // 计算非第一层的最后一个节点 LL
    }
    i__1 = ll;
    for (i__ = lf; i__ <= i__1; ++i__) {
        im1 = i__ - 1;
        ic = iwork[inode + im1];  // 获取节点的索引
        nl = iwork[ndiml + im1];  // 获取左维度
        nr = iwork[ndimr + im1];  // 获取右维度
        nlf = ic - nl;            // 左边的节点索引
        nrf = ic + 1;             // 右边的节点索引
        --j;
        dlals0_(icompq, &nl, &nr, &sqre, nrhs, &bx[nlf + bx_dim1], ldbx, &
            b[nlf + b_dim1], ldb, &perm[nlf + lvl * perm_dim1], &
            givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
            givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
             poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
            lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
            j], &s[j], &work[1], info);
/* L30: */
    }
/* L40: */
    }
    goto L90;

/*     ICOMPQ = 1: applying back the right singular vector factors. */

L50:

/*
       First now go through the right singular vector matrices of all
       the tree nodes top-down.
*/

    j = 0;
    i__1 = nlvl;
    for (lvl = 1; lvl <= i__1; ++lvl) {
    lvl2 = (lvl << 1) - 1;

/*
          Find the first node LF and last node LL on
          the current level LVL.
*/

    if (lvl == 1) {
        lf = 1;  // 如果当前层级是第一层，则第一个节点 LF 是 1
        ll = 1;  // 如果当前层级是第一层，则最后一个节点 LL 是 1
    } else {
        i__2 = lvl - 1;
        lf = pow_ii(&c__2, &i__2);  // 计算非第一层的第一个节点 LF
        ll = (lf << 1) - 1;         // 计算非第一层的最后一个节点 LL
    }
    i__2 = lf;
    for (i__ = ll; i__ >= i__2; --i__) {
        im1 = i__ - 1;
        ic = iwork[inode + im1];  // 获取节点的索引
        nl = iwork[ndiml + im1];  // 获取左维度
        nr = iwork[ndimr + im1];  // 获取右维度
        nlf = ic - nl;            // 左边的节点索引
        nrf = ic + 1;             // 右边的节点索引
        if (i__ == ll) {
        sqre = 0;  // 如果是当前层级的最后一个节点，则 sqre 设为 0
        } else {
        sqre = 1;  // 否则设为 1
        }
        ++j;
        dlals0_(icompq, &nl, &nr, &sqre, nrhs, &b[nlf + b_dim1], ldb, &bx[
            nlf + bx_dim1], ldbx, &perm[nlf + lvl * perm_dim1], &
            givptr[j], &givcol[nlf + lvl2 * givcol_dim1], ldgcol, &
            givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 *
             poles_dim1], &difl[nlf + lvl * difl_dim1], &difr[nlf +
            lvl2 * difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[
            j], &s[j], &work[1], info);
/* L60: */
    }
/* L70: */
    }

/*
       The nodes on the bottom level of the tree were solved
       by DLASDQ. The corresponding right singular vector
       matrices are in explicit form. Apply them back.
*/

    ndb1 = (nd + 1) / 2;  // 计算底层节点的起始索引
    i__1 = nd;
    for (i__ = ndb1; i__ <= i__1; ++i__) {
    i1 = i__ - 1;
    ic = iwork[inode + i1];  // 获取节点的索引
    nl = iwork[ndiml + i1];  // 获取左维度
    nr = iwork[ndimr + i1];  // 获取右维度
    nlp1 = nl + 1;           // 左维度加一
    // 检查 i__ 是否等于 nd，根据条件设置 nrp1 的值
    if (i__ == nd) {
        nrp1 = nr;
    } else {
        nrp1 = nr + 1;
    }
    // 计算 nlf 和 nrf 的值
    nlf = ic - nl;
    nrf = ic + 1;
    // 调用 BLAS 库函数 dgemm_，进行矩阵乘法运算
    // 第一个矩阵转置（"T"），第二个矩阵不转置（"N"）
    // 大小分别为 nlp1 x nrhs
    dgemm_("T", "N", &nlp1, nrhs, &nlp1, &c_b15, &vt[nlf + vt_dim1], ldu,
           &b[nlf + b_dim1], ldb, &c_b29, &bx[nlf + bx_dim1], ldbx);
    // 继续调用 dgemm_，大小为 nrp1 x nrhs
    dgemm_("T", "N", &nrp1, nrhs, &nrp1, &c_b15, &vt[nrf + vt_dim1], ldu,
           &b[nrf + b_dim1], ldb, &c_b29, &bx[nrf + bx_dim1], ldbx);
/* L80: */
    }

L90:

    return 0;

/*     End of DLALSA */

} /* dlalsa_ */

/* Subroutine */ int dlalsd_(char *uplo, integer *smlsiz, integer *n, integer
    *nrhs, doublereal *d__, doublereal *e, doublereal *b, integer *ldb,
    doublereal *rcond, integer *rank, doublereal *work, integer *iwork,
    integer *info)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer c__, i__, j, k;
    static doublereal r__;
    static integer s, u, z__;
    static doublereal cs;
    static integer bx;
    static doublereal sn;
    static integer st, vt, nm1, st1;
    static doublereal eps;
    static integer iwk;
    static doublereal tol;
    static integer difl, difr;
    static doublereal rcnd;
    static integer perm, nsub;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);
    static integer nlvl, sqre, bxst;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *),
         dcopy_(integer *, doublereal *, integer *, doublereal *, integer
        *);
    static integer poles, sizei, nsize, nwork, icmpq1, icmpq2;

    extern /* Subroutine */ int dlasda_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         integer *), dlalsa_(integer *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        doublereal *, doublereal *, integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         integer *, integer *), dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *);
    extern integer idamax_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dlasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, doublereal *, doublereal *, doublereal *,
         integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *), dlacpy_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *), dlartg_(doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *), dlaset_(char *, integer *, integer *,
         doublereal *, doublereal *, doublereal *, integer *),
        xerbla_(char *, integer *);
    static integer givcol;
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);

    /* Insert comments for the following code block */
    {
        // Declare local variables
        integer i__1, i__2;  // Local integer variables for loop indices
        doublereal d__1;     // Local double-precision floating-point variable

        // Initialize local variables
        static integer c__, i__, j, k;  // Static integers for various purposes
        static doublereal r__;          // Static double-precision variable
        static integer s, u, z__;       // Static integers
        static doublereal cs;           // Static double-precision variable
        static integer bx;              // Static integer
        static doublereal sn;           // Static double-precision variable
        static integer st, vt, nm1, st1; // Static integers
        static doublereal eps;          // Static double-precision variable
        static integer iwk;             // Static integer
        static doublereal tol;          // Static double-precision variable
        static integer difl, difr;      // Static integers
        static doublereal rcnd;         // Static double-precision variable
        static integer perm, nsub;      // Static integers
        static integer nlvl, sqre, bxst; // Static integers
        static integer poles, sizei, nsize, nwork, icmpq1, icmpq2; // Static integers

        // External subroutine declarations
        extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
            doublereal *, integer *, doublereal *, doublereal *);
        extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
            integer *, doublereal *, doublereal *, integer *, doublereal *,
            integer *, doublereal *, doublereal *, integer *);
        extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
            doublereal *, integer *);
        extern /* Subroutine */ int dlasda_(integer *, integer *, integer *,
            integer *, doublereal *, doublereal *, doublereal *, integer *,
            doublereal *, integer *, doublereal *, doublereal *, doublereal *,
             doublereal *, integer *, integer *, integer *, integer *,
            doublereal *, doublereal *, doublereal *, doublereal *, integer *,
             integer *);
        extern /* Subroutine */ int dlalsa_(integer *, integer *, integer *,
            integer *, doublereal *, integer *, doublereal *, integer *,
            doublereal *, integer *, doublereal *, integer *, doublereal *,
            doublereal *, doublereal *, doublereal *, integer *, integer *,
            integer *, integer *, doublereal *, doublereal *, doublereal *,
            doublereal *, integer *, integer *);
        extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
            doublereal *, doublereal *, integer *, integer *, doublereal *,
            integer *, integer *);
        extern integer idamax_(integer *, doublereal *, integer *);
        extern /* Subroutine */ int dlasdq_(char *, integer *, integer *, integer
            *, integer *, integer *, doublereal *, doublereal *, doublereal *,
             integer *, doublereal *, integer *, doublereal *, integer *,
            doublereal *, integer *);
        extern /* Subroutine */ int dlacpy_(char *, integer *, integer *,
            doublereal *, integer *, doublereal *, integer *);
        extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, doublereal *,
            doublereal *, doublereal *);
        extern /* Subroutine */ int dlaset_(char *, integer *, integer *,
             doublereal *, doublereal *, doublereal *, integer *);
        extern /* Subroutine */ int xerbla_(char *, integer *);
        
        // Insert comments for the subsequent lines of code
        
    }
    # 定义一个外部子程序（外部函数）dlasrt_，该子程序接受以下参数：
    # - char *: 字符指针，通常用于指定参数的类型或属性
    # - integer *: 整数指针，通常用于传递整数变量的地址
    # - doublereal *: 双精度实数指针，通常用于传递双精度浮点数变量的地址
    # - integer *: 整数指针，通常用于传递整数变量的地址
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *,
        integer *);

    # 静态变量，用于存储原始的范数值
    static doublereal orgnrm;

    # 静态变量，用于存储 Givens 变换的数量
    static integer givnum;

    # 静态变量，用于存储 Givens 变换的指针位置
    static integer givptr;

    # 静态变量，用于存储最小的尺寸参数
    static integer smlszp;
/*
    -- LAPACK routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLALSD uses the singular value decomposition of A to solve the least
    squares problem of finding X to minimize the Euclidean norm of each
    column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
    are N-by-NRHS. The solution X overwrites B.

    The singular values of A smaller than RCOND times the largest
    singular value are treated as zero in solving the least squares
    problem; in this case a minimum norm solution is returned.
    The actual singular values are returned in D in ascending order.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Arguments
    =========

    UPLO   (input) CHARACTER*1
           = 'U': D and E define an upper bidiagonal matrix.
           = 'L': D and E define a  lower bidiagonal matrix.

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The dimension of the  bidiagonal matrix.  N >= 0.

    NRHS   (input) INTEGER
           The number of columns of B. NRHS must be at least 1.

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry D contains the main diagonal of the bidiagonal
           matrix. On exit, if INFO = 0, D contains its singular values.

    E      (input/output) DOUBLE PRECISION array, dimension (N-1)
           Contains the super-diagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    B      (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
           On input, B contains the right hand sides of the least
           squares problem. On output, B contains the solution X.

    LDB    (input) INTEGER
           The leading dimension of B in the calling subprogram.
           LDB must be at least max(1,N).

    RCOND  (input) DOUBLE PRECISION
           The singular values of A less than or equal to RCOND times
           the largest singular value are treated as zero in solving
           the least squares problem. If RCOND is negative,
           machine precision is used instead.
           For example, if diag(S)*X=B were the least squares problem,
           where diag(S) is a diagonal matrix of singular values, the
           solution would be X(i) = B(i) / S(i) if S(i) is greater than
           RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
           RCOND*max(S).
*/
    # 输出参数，表示大于 RCOND 倍最大奇异值的奇异值数量
    RANK   (output) INTEGER
           The number of singular values of A greater than RCOND times
           the largest singular value.

    # 工作空间，用于存储各种临时数据，包括双精度浮点数数组
    WORK   (workspace) DOUBLE PRECISION array, dimension at least
           (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),
           where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).

    # 工作空间，用于存储各种临时数据，包括整数数组
    IWORK  (workspace) INTEGER array, dimension at least
           (3*N*NLVL + 11*N)

    # 输出参数，表示函数执行状态
    INFO   (output) INTEGER
           = 0:  successful exit.
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  The algorithm failed to compute a singular value while
                 working on the submatrix lying in rows and columns
                 INFO/(N+1) through MOD(INFO,N+1).

    # 进一步的细节说明，列出了贡献者信息和算法基本信息
    Further Details
    ===============

    Based on contributions by
       Ming Gu and Ren-Cang Li, Computer Science Division, University of
         California at Berkeley, USA
       Osni Marques, LBNL/NERSC, USA

    =====================================================================


       # 测试输入参数的有效性。
       Test the input parameters.
    /* Parameter adjustments */
    --d__;                  // 调整指针数组 d__，使其指向正确的位置
    --e;                    // 调整指针数组 e，使其指向正确的位置
    b_dim1 = *ldb;          // 设置矩阵 b 的第一维度大小为 ldb
    b_offset = 1 + b_dim1;  // 计算 b 数组的偏移量
    b -= b_offset;          // 调整矩阵 b 的起始地址，使其指向正确的位置
    --work;                 // 调整指针数组 work，使其指向正确的位置
    --iwork;                // 调整指针数组 iwork，使其指向正确的位置

    /* Function Body */
    *info = 0;              // 初始化 info，用于存储函数的返回状态

    if (*n < 0) {           // 检查参数 n 是否小于零
    *info = -3;             // 若是，设置 info 为 -3 表示参数错误
    } else if (*nrhs < 1) { // 检查参数 nrhs 是否小于 1
    *info = -4;             // 若是，设置 info 为 -4 表示参数错误
    } else if (*ldb < 1 || *ldb < *n) { // 检查 ldb 是否小于 1 或小于 n
    *info = -8;             // 若是，设置 info 为 -8 表示参数错误
    }
    if (*info != 0) {       // 如果发现参数错误
    i__1 = -(*info);        // 将错误码取反传递给 BLAS 和 LAPACK 错误处理函数
    xerbla_("DLALSD", &i__1); // 调用 BLAS 和 LAPACK 错误处理函数
    return 0;               // 返回，不再继续执行
    }

    eps = EPSILON;          // 获取机器精度值 EPSILON

/*     Set up the tolerance. */

    if (*rcond <= 0. || *rcond >= 1.) { // 检查 rcond 是否在有效范围内
    rcnd = eps;             // 若不在范围内，使用默认的机器精度
    } else {
    rcnd = *rcond;          // 否则使用传入的 rcond
    }

    *rank = 0;              // 初始化 rank，用于存储矩阵的秩

/*     Quick return if possible. */

    if (*n == 0) {          // 如果 n 为 0
    return 0;               // 直接返回，无需进行后续计算
    } else if (*n == 1) {   // 如果 n 为 1
    if (d__[1] == 0.) {     // 检查主对角元素是否为零
        dlaset_("A", &c__1, nrhs, &c_b29, &c_b29, &b[b_offset], ldb); // 将 b 矩阵设为零
    } else {
        *rank = 1;          // 设置秩为 1
        dlascl_("G", &c__0, &c__0, &d__[1], &c_b15, &c__1, nrhs, &b[
            b_offset], ldb, info); // 调用矩阵缩放函数
        d__[1] = abs(d__[1]); // 取主对角元素的绝对值
    }
    return 0;               // 返回，不再继续执行
    }

/*     Rotate the matrix if it is lower bidiagonal. */

    if (*(unsigned char *)uplo == 'L') { // 检查矩阵是否为下三角形式
    i__1 = *n - 1;          // 循环遍历的上限
    for (i__ = 1; i__ <= i__1; ++i__) { // 循环遍历每个子对角块
        dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__); // 计算 Givens 旋转参数
        d__[i__] = r__;     // 更新对角元素
        e[i__] = sn * d__[i__ + 1]; // 更新下对角元素
        d__[i__ + 1] = cs * d__[i__ + 1]; // 更新下对角元素
        if (*nrhs == 1) {
        drot_(&c__1, &b[i__ + b_dim1], &c__1, &b[i__ + 1 + b_dim1], &
            c__1, &cs, &sn); // 应用 Givens 旋转到右侧向量 b
        } else {
        work[(i__ << 1) - 1] = cs; // 保存 Givens 旋转参数用于后续的右侧向量 b
        work[i__ * 2] = sn; // 保存 Givens 旋转参数用于后续的右侧向量 b
        }
/* L10: */
    }
    if (*nrhs > 1) {        // 如果有多个右侧向量
        i__1 = *nrhs;       // 循环遍历每个右侧向量
        for (i__ = 1; i__ <= i__1; ++i__) {
        i__2 = *n - 1;      // 循环遍历每个子对角块
        for (j = 1; j <= i__2; ++j) {
            cs = work[(j << 1) - 1]; // 获取 Givens 旋转参数
            sn = work[j * 2];        // 获取 Givens 旋转参数
            drot_(&c__1, &b[j + i__ * b_dim1], &c__1, &b[j + 1 + i__ *
                 b_dim1], &c__1, &cs, &sn); // 应用 Givens 旋转到右侧向量 b
/* L20: */
        }
/* L30: */
        }
    }
    }

/*     Scale. */

    nm1 = *n - 1;           // 计算 n-1
    orgnrm = dlanst_("M", n, &d__[1], &e[1]); // 计算矩阵的范数
    if (orgnrm == 0.) {     // 检查矩阵范数是否为零
    dlaset_("A", n, nrhs, &c_b29, &c_b29, &b[b_offset], ldb); // 若为零，将 b 矩阵设为零
    return 0;               // 返回，不再继续执行
    }

    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, &c__1, &d__[1], n, info); // 对 d 缩放
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &nm1, &c__1, &e[1], &nm1,
        info);              // 对 e 缩放

/*
       If N is smaller than the minimum divide size SMLSIZ, then solve
       the problem with another solver.
*/

    if (*n <= *smlsiz) {    // 检查是否需要调用其他求解器
    nwork = *n * *n + 1;    // 计算所需工作空间大小
    dlaset_("A", n, n, &c_b29, &c_b15, &work[1], n); // 初始化工作空间
    dlasdq_("U", &c__0, n, n, &c__0, nrhs, &d__[1], &e[1], &work[1], n, &
        work[1], n, &b[b_offset], ldb, &work[nwork], info); // 调用求解函数
    if (*info != 0) {
        return 0;           // 若出错，则返回
    }
    tol = rcnd * (d__1 = d__[idamax_(n, &d__[1], &c__1)], abs(d__1)); // 计算残差容限
    i__1 = *n;
    ! 循环遍历数组 d__，范围从 1 到 i__1
    do i__ = 1, i__1
        ! 如果 d__[i__] 小于等于 tol，则执行以下操作
        if (d__[i__] <= tol) then
            ! 将矩阵 b 的第 i__ 行设置为 0
            dlaset_("A", &c__1, nrhs, &c_b29, &c_b29, &b[i__ + b_dim1], ldb)
        ! 如果 d__[i__] 大于 tol，则执行以下操作
        else
            ! 将矩阵 b 的第 i__ 行按照缩放因子 d__[i__] 进行缩放
            dlascl_("G", &c__0, &c__0, &d__[i__], &c_b15, &c__1, nrhs, &b[i__ + b_dim1], ldb, info)
            ! 增加 rank 的计数值
            ++(*rank)
        ! 结束 if 语句
        endif
    ! 结束 do 循环
    end do
/* L40: */
    }
    // 调用 BLAS 库中的 DGEMM 函数，进行矩阵乘法运算
    dgemm_("T", "N", n, nrhs, n, &c_b15, &work[1], n, &b[b_offset], ldb, &
        c_b29, &work[nwork], n);
    // 将结果复制到矩阵 B 中
    dlacpy_("A", n, nrhs, &work[nwork], n, &b[b_offset], ldb);

/*        Unscale. */

    // 对矩阵 D 进行缩放操作
    dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n,
        info);
    // 对数组 D 进行排序
    dlasrt_("D", n, &d__[1], info);
    // 对矩阵 B 进行缩放操作
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, nrhs, &b[b_offset],
        ldb, info);

    // 函数结束，返回成功状态
    return 0;
    }

/*     Book-keeping and setting up some constants. */

    // 计算 NLVL 的值，表示分割级别
    nlvl = (integer) (log((doublereal) (*n) / (doublereal) (*smlsiz + 1)) /
        log(2.)) + 1;

    // 计算 SMLSIZP 的值
    smlszp = *smlsiz + 1;

    // 初始化 U 的值为 1
    u = 1;
    // 初始化 VT 的值
    vt = *smlsiz * *n + 1;
    // 计算 DIFL 的值
    difl = vt + smlszp * *n;
    // 计算 DIFR 的值
    difr = difl + nlvl * *n;
    // 计算 Z 的值
    z__ = difr + (nlvl * *n << 1);
    // 计算 C 的值
    c__ = z__ + nlvl * *n;
    // 计算 S 的值
    s = c__ + *n;
    // 计算 POLES 的值
    poles = s + *n;
    // 计算 GIVNUM 的值
    givnum = poles + (nlvl << 1) * *n;
    // 计算 BX 的值
    bx = givnum + (nlvl << 1) * *n;
    // 计算 NWORK 的值
    nwork = bx + *n * *nrhs;

    // 初始化 SIZEI 的值
    sizei = *n + 1;
    // 初始化 K 的值
    k = sizei + *n;
    // 初始化 GIVPTR 的值
    givptr = k + *n;
    // 初始化 PERM 的值
    perm = givptr + *n;
    // 初始化 GIVCOL 的值
    givcol = perm + nlvl * *n;
    // 初始化 IWK 的值
    iwk = givcol + (nlvl * *n << 1);

    // 初始化 ST 的值为 1
    st = 1;
    // 初始化 SQRE 的值为 0
    sqre = 0;
    // 初始化 ICMPQ1 的值为 1
    icmpq1 = 1;
    // 初始化 ICMPQ2 的值为 0
    icmpq2 = 0;
    // 初始化 NSUB 的值为 0
    nsub = 0;

    // 循环遍历数组 D
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 如果 D[i] 的绝对值小于 eps，则将其设置为 eps 的符号值
    if ((d__1 = d__[i__], abs(d__1)) < eps) {
        d__[i__] = d_sign(&eps, &d__[i__]);
    }
/* L50: */
    }

    // 循环遍历数组 E
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
    // 如果 E[i] 的绝对值小于 eps 或者 i 等于 nm1，则进入条件
    if ((d__1 = e[i__], abs(d__1)) < eps || i__ == nm1) {
        // 增加子问题计数器
        ++nsub;
        // 设置 IWORK 数组的值
        iwork[nsub] = st;

/*
             Subproblem found. First determine its size and then
             apply divide and conquer on it.
*/

        // 如果 i 小于 nm1，则处理 E[I] 小的子问题
        if (i__ < nm1) {

/*              A subproblem with E(I) small for I < NM1. */

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else if ((d__1 = e[i__], abs(d__1)) >= eps) {

/*              A subproblem with E(NM1) not too small but I = NM1. */

        nsize = *n - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        } else {

/*
                A subproblem with E(NM1) small. This implies an
                1-by-1 subproblem at D(N), which is not solved
                explicitly.
*/

        nsize = i__ - st + 1;
        iwork[sizei + nsub - 1] = nsize;
        ++nsub;
        iwork[nsub] = *n;
        iwork[sizei + nsub - 1] = 1;
        // 复制矩阵 B 的部分数据到工作区
        dcopy_(nrhs, &b[*n + b_dim1], ldb, &work[bx + nm1], n);
        }
        // 更新 ST1 的值
        st1 = st - 1;
        // 如果 nsize 等于 1，则不显式求解此 1x1 子问题
        if (nsize == 1) {

/*
                This is a 1-by-1 subproblem and is not solved
                explicitly.
*/

        dcopy_(nrhs, &b[st + b_dim1], ldb, &work[bx + st1], n);
        } else if (nsize <= *smlsiz) {
/*              This is a small subproblem and is solved by DLASDQ. */
/*              这是一个小型子问题，通过DLASDQ来解决。 */

        dlaset_("A", &nsize, &nsize, &c_b29, &c_b15, &work[vt + st1],
            n);
        /* 设置矩阵或数组的值为常数或零，这里将work[vt + st1]的部分初始化为0 */
        dlasdq_("U", &c__0, &nsize, &nsize, &c__0, nrhs, &d__[st], &e[
            st], &work[vt + st1], n, &work[nwork], n, &b[st +
            b_dim1], ldb, &work[nwork], info);
        /* 调用DLASDQ来求解特征值问题，计算结果存储在b[st + b_dim1]中 */
        if (*info != 0) {
            return 0;
        }
        /* 如果DLASDQ返回错误信息，则退出函数 */

        dlacpy_("A", &nsize, nrhs, &b[st + b_dim1], ldb, &work[bx +
            st1], n);
        /* 复制矩阵或数组的值，将b[st + b_dim1]复制到work[bx + st1] */
        } else {

/*              A large problem. Solve it using divide and conquer. */
/*              一个较大的问题，使用分治法来解决。 */

        dlasda_(&icmpq1, smlsiz, &nsize, &sqre, &d__[st], &e[st], &
            work[u + st1], n, &work[vt + st1], &iwork[k + st1], &
            work[difl + st1], &work[difr + st1], &work[z__ + st1],
             &work[poles + st1], &iwork[givptr + st1], &iwork[
            givcol + st1], n, &iwork[perm + st1], &work[givnum +
            st1], &work[c__ + st1], &work[s + st1], &work[nwork],
            &iwork[iwk], info);
        /* 调用DLASDA来解决特征值问题，计算结果存储在多个数组中 */
        if (*info != 0) {
            return 0;
        }
        /* 如果DLASDA返回错误信息，则退出函数 */
        bxst = bx + st1;
        dlalsa_(&icmpq2, smlsiz, &nsize, nrhs, &b[st + b_dim1], ldb, &
            work[bxst], n, &work[u + st1], n, &work[vt + st1], &
            iwork[k + st1], &work[difl + st1], &work[difr + st1],
            &work[z__ + st1], &work[poles + st1], &iwork[givptr +
            st1], &iwork[givcol + st1], n, &iwork[perm + st1], &
            work[givnum + st1], &work[c__ + st1], &work[s + st1],
            &work[nwork], &iwork[iwk], info);
        /* 调用DLALSA来解决特征值问题，计算结果存储在多个数组中 */
        if (*info != 0) {
            return 0;
        }
        }
        st = i__ + 1;
    }
/* L60: */
    }

/*     Apply the singular values and treat the tiny ones as zero. */
/*     应用奇异值，并将非常小的奇异值视为零。 */

    tol = rcnd * (d__1 = d__[idamax_(n, &d__[1], &c__1)], abs(d__1));
    /* 计算奇异值的阈值tol，用于判断哪些奇异值可以视为零 */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*
          Some of the elements in D can be negative because 1-by-1
          subproblems were not solved explicitly.
*/
/*        因为1x1的子问题未被显式解决，D中的一些元素可能是负数。 */

    if ((d__1 = d__[i__], abs(d__1)) <= tol) {
        dlaset_("A", &c__1, nrhs, &c_b29, &c_b29, &work[bx + i__ - 1], n);
    } else {
        ++(*rank);
        dlascl_("G", &c__0, &c__0, &d__[i__], &c_b15, &c__1, nrhs, &work[
            bx + i__ - 1], n, info);
    }
    /* 如果奇异值小于等于tol，则将对应位置的矩阵或数组值设为常数或零；否则，调整矩阵或数组的缩放因子 */
    d__[i__] = (d__1 = d__[i__], abs(d__1));
/* L70: */
    }

/*     Now apply back the right singular vectors. */
/*     现在应用右奇异向量。 */

    icmpq2 = 1;
    i__1 = nsub;
    for (i__ = 1; i__ <= i__1; ++i__) {
    st = iwork[i__];
    st1 = st - 1;
    nsize = iwork[sizei + i__ - 1];
    bxst = bx + st1;
    if (nsize == 1) {
        dcopy_(nrhs, &work[bxst], n, &b[st + b_dim1], ldb);
    } else if (nsize <= *smlsiz) {
        dgemm_("T", "N", &nsize, nrhs, &nsize, &c_b15, &work[vt + st1], n,
             &work[bxst], n, &c_b29, &b[st + b_dim1], ldb);
    }
    /* 根据nsize的大小和条件，执行矩阵乘法或简单的复制操作 */
    } else {
        // 调用dlalsa_函数执行特定的线性代数操作，处理复杂参数列表
        dlalsa_(&icmpq2, smlsiz, &nsize, nrhs, &work[bxst], n, &b[st +
            b_dim1], ldb, &work[u + st1], n, &work[vt + st1], &iwork[
            k + st1], &work[difl + st1], &work[difr + st1], &work[z__
            + st1], &work[poles + st1], &iwork[givptr + st1], &iwork[
            givcol + st1], n, &iwork[perm + st1], &work[givnum + st1],
             &work[c__ + st1], &work[s + st1], &work[nwork], &iwork[
            iwk], info);
        // 检查操作的结果，如果出错则返回0
        if (*info != 0) {
            return 0;
        }
    }
/* L80: */
    }

/*     Unscale and sort the singular values. */

    // 将奇异值反缩放并排序。
    dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d__[1], n, info);
    // 按降序对奇异值进行排序。
    dlasrt_("D", n, &d__[1], info);
    // 将反缩放后的右端矩阵 b 进行缩放。
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, n, nrhs, &b[b_offset], ldb,
        info);

    // 返回成功代码。
    return 0;

/*     End of DLALSD */

} /* dlalsd_ */

/* Subroutine */ int dlamrg_(integer *n1, integer *n2, doublereal *a, integer
    *dtrd1, integer *dtrd2, integer *index)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, ind1, ind2, n1sv, n2sv;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAMRG will create a permutation list which will merge the elements
    of A (which is composed of two independently sorted sets) into a
    single set which is sorted in ascending order.

    Arguments
    =========

    N1     (input) INTEGER
    N2     (input) INTEGER
           These arguments contain the respective lengths of the two
           sorted lists to be merged.

    A      (input) DOUBLE PRECISION array, dimension (N1+N2)
           The first N1 elements of A contain a list of numbers which
           are sorted in either ascending or descending order.  Likewise
           for the final N2 elements.

    DTRD1  (input) INTEGER
    DTRD2  (input) INTEGER
           These are the strides to be taken through the array A.
           Allowable strides are 1 and -1.  They indicate whether a
           subset of A is sorted in ascending (DTRDx = 1) or descending
           (DTRDx = -1) order.

    INDEX  (output) INTEGER array, dimension (N1+N2)
           On exit this array will contain a permutation such that
           if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
           sorted in ascending order.

    =====================================================================
*/


    /* Parameter adjustments */
    --index;
    --a;

    /* Function Body */
    // 保存输入参数 N1 和 N2 的初始值。
    n1sv = *n1;
    n2sv = *n2;
    // 根据 DTRD1 和 DTRD2 确定起始指针的位置。
    if (*dtrd1 > 0) {
    ind1 = 1;
    } else {
    ind1 = *n1;
    }
    if (*dtrd2 > 0) {
    ind2 = *n1 + 1;
    } else {
    ind2 = *n1 + *n2;
    }
    // 初始化计数器。
    i__ = 1;
/*     while ( (N1SV > 0) & (N2SV > 0) ) */
L10:
    // 当两个子集都还有元素时继续执行。
    if (n1sv > 0 && n2sv > 0) {
    // 比较当前两个子集的第一个元素，将较小的放入索引数组中。
    if (a[ind1] <= a[ind2]) {
        index[i__] = ind1;
        ++i__;
        ind1 += *dtrd1;
        --n1sv;
    } else {
        index[i__] = ind2;
        ++i__;
        ind2 += *dtrd2;
        --n2sv;
    }
    // 继续比较下一个元素。
    goto L10;
    }
/*     end while */
    // 当一个子集已经为空时，将剩余的元素直接加入索引数组中。
    if (n1sv == 0) {
    i__1 = n2sv;
    for (n1sv = 1; n1sv <= i__1; ++n1sv) {
        index[i__] = ind2;
        ++i__;
        ind2 += *dtrd2;
/* L20: */
    }
    } else {
/*     N2SV .EQ. 0 */
    i__1 = n1sv;
    for (n2sv = 1; n2sv <= i__1; ++n2sv) {
        index[i__] = ind1;
        ++i__;
        ind1 += *dtrd1;
/* L30: */
    }
    }
/*     End of Dlamrg */

} /* dlamrg_ */
    }
    // 结束 main 函数的主体部分，返回整数值 0 表示程序成功执行
    }

    // 返回整数值 0，表示程序顺利结束
    return 0;
/*     End of DLAMRG */
} /* dlamrg_ */

/* 计算矩阵 A 的某种范数值，返回结果 */
doublereal dlange_(char *norm, integer *m, integer *n, doublereal *a, integer
    *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal ret_val, d__1, d__2, d__3;

    /* Local variables */
    static integer i__, j;
    static doublereal sum, scale;
    extern logical lsame_(char *, char *);
    static doublereal value;
    extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *,
        doublereal *, doublereal *);

    /*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======
    
    DLANGE  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    real matrix A.

    Description
    ===========
    
    DLANGE returns the value
    
       DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
    
    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
    
    Arguments
    =========
    
    NORM    (input) CHARACTER*1
            Specifies the value to be returned in DLANGE as described
            above.
    
    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            DLANGE is set to zero.
    
    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            DLANGE is set to zero.
    
    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.
    
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
    
    WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
    
    =====================================================================
    */
    
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (min(*m,*n) == 0) {
        value = 0.;
    } else if (lsame_(norm, "M")) {
        
        /* Find max(abs(A(i,j))). */
        value = 0.;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                /* Computing MAX */
                d__2 = value, d__3 = (d__1 = a[i__ + j * a_dim1], abs(d__1));
                value = max(d__2,d__3);
                /* L10: */
            }
        }
/* L20: */
    }
    } else if (lsame_(norm, "O") || *(unsigned char *)
        norm == '1') {

/*        Find norm1(A). */

    value = 0.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        sum = 0.;
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            sum += (d__1 = a[i__ + j * a_dim1], abs(d__1));
/* L30: */
        }
        value = max(value,sum);
/* L40: */
    }
    } else if (lsame_(norm, "I")) {

/*        Find normI(A). */

    i__1 = *m;
    for (i__ = 1; i__ <= i__1; ++i__) {
        work[i__] = 0.;
/* L50: */
    }
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            work[i__] += (d__1 = a[i__ + j * a_dim1], abs(d__1));
/* L60: */
        }
/* L70: */
    }
    value = 0.;
    i__1 = *m;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
        d__1 = value, d__2 = work[i__];
        value = max(d__1,d__2);
/* L80: */
    }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

    scale = 0.;
    sum = 1.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        dlassq_(m, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
/* L90: */
    }
    value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of DLANGE */

} /* dlange_ */

doublereal dlanst_(char *norm, integer *n, doublereal *d__, doublereal *e)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val, d__1, d__2, d__3, d__4, d__5;

    /* Local variables */
    static integer i__;
    static doublereal sum, scale;
    extern logical lsame_(char *, char *);
    static doublereal anorm;
    extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *,
        doublereal *, doublereal *);


/*    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLANST  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    real symmetric tridiagonal matrix A.

    Description
    ===========

    DLANST returns the value

       DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

    Arguments
    =========

*/
    NORM    (input) CHARACTER*1
            Specifies the value to be returned in DLANST as described
            above.
    指定了作为 DLANST 返回值的参数类型，是一个字符类型，长度为1。

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, DLANST is
            set to zero.
    矩阵 A 的阶数。N 必须大于等于0。当 N = 0 时，DLANST 返回值被设置为零。

    D       (input) DOUBLE PRECISION array, dimension (N)
            The diagonal elements of A.
    A 的对角线元素数组，数据类型为双精度浮点数，长度为 N。

    E       (input) DOUBLE PRECISION array, dimension (N-1)
            The (n-1) sub-diagonal or super-diagonal elements of A.
    A 的次对角线或者超对角线元素数组，数据类型为双精度浮点数，长度为 N-1。

    =====================================================================
    /* Parameter adjustments */
    --e;
    --d__;

    /* Function Body */
    if (*n <= 0) {
    anorm = 0.;
    } else if (lsame_(norm, "M")) {

/*        Find max(abs(A(i,j))). */

    anorm = (d__1 = d__[*n], abs(d__1));
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
        d__2 = anorm, d__3 = (d__1 = d__[i__], abs(d__1));
        anorm = max(d__2,d__3);
/* Computing MAX */
        d__2 = anorm, d__3 = (d__1 = e[i__], abs(d__1));
        anorm = max(d__2,d__3);
/* L10: */
    }
    } else if (lsame_(norm, "O") || *(unsigned char *)
        norm == '1' || lsame_(norm, "I")) {

/*        Find norm1(A). */

    if (*n == 1) {
        anorm = abs(d__[1]);
    } else {
/* Computing MAX */
        d__3 = abs(d__[1]) + abs(e[1]), d__4 = (d__1 = e[*n - 1], abs(
            d__1)) + (d__2 = d__[*n], abs(d__2));
        anorm = max(d__3,d__4);
        i__1 = *n - 1;
        for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing MAX */
        d__4 = anorm, d__5 = (d__1 = d__[i__], abs(d__1)) + (d__2 = e[
            i__], abs(d__2)) + (d__3 = e[i__ - 1], abs(d__3));
        anorm = max(d__4,d__5);
/* L20: */
        }
    }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

    scale = 0.;
    sum = 1.;
    if (*n > 1) {
        i__1 = *n - 1;
        dlassq_(&i__1, &e[1], &c__1, &scale, &sum);
        sum *= 2;
    }
    dlassq_(n, &d__[1], &c__1, &scale, &sum);
    anorm = scale * sqrt(sum);
    }

    ret_val = anorm;
    return ret_val;

/*     End of DLANST */

} /* dlanst_ */

doublereal dlansy_(char *norm, char *uplo, integer *n, doublereal *a, integer
    *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal ret_val, d__1, d__2, d__3;

    /* Local variables */
    static integer i__, j;
    static doublereal sum, absa, scale;
    extern logical lsame_(char *, char *);
    static doublereal value;
    extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *,
        doublereal *, doublereal *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLANSY  returns the value of the one norm,  or the Frobenius norm, or
    the  infinity norm,  or the  element of  largest absolute value  of a
    real symmetric matrix A.

    Description
    ===========

    DLANSY returns the value

       DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                (
                ( norm1(A),         NORM = '1', 'O' or 'o'
                (
                ( normI(A),         NORM = 'I' or 'i'
                (
                ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

    where  norm1  denotes the  one norm of a matrix (maximum column sum),
*/


注释：
    normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
    normF  denotes the  Frobenius norm of a matrix (square root of sum of
    squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

    Arguments
    =========

    NORM    (input) CHARACTER*1
            Specifies the value to be returned in DLANSY as described
            above.
            指定 DLANSY 函数返回的矩阵范数类型：
            - 'I': 无穷范数（矩阵每行绝对值最大值之和）
            - '1': 一范数（矩阵每列绝对值最大值之和）
            - 'O': 无范数（Frobenius 范数，即矩阵元素绝对值平方和的平方根）

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            指定对称矩阵 A 的上三角部分或下三角部分的引用方式：
            - 'U': 引用 A 的上三角部分
            - 'L': 引用 A 的下三角部分

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
            set to zero.
            矩阵 A 的阶数。N >= 0。当 N = 0 时，DLANSY 返回值为零。

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            对称矩阵 A。如果 UPLO = 'U'，则 A 的前 n 行 n 列是 A 的上三角部分，
            且不引用严格的下三角部分。如果 UPLO = 'L'，则 A 的前 n 行 n 列是 A 的下三角部分，
            且不引用严格的上三角部分。

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            数组 A 的前导维度。LDA >= max(N,1)。

    WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            工作空间数组，用于存储计算过程中的中间结果。当 NORM = 'I' 或 '1' 或 'O' 时，
            需要分配至少 N 个元素的空间；否则，WORK 数组不被引用。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
        value = 0.;
    } else if (lsame_(norm, "M")) {

/*        Find max(abs(A(i,j))). */

        value = 0.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = j;
                for (i__ = 1; i__ <= i__2; ++i__) {
/* Computing MAX */
                    d__2 = value, d__3 = (d__1 = a[i__ + j * a_dim1], abs(
                        d__1));
                    value = max(d__2,d__3);
/* L10: */
                }
/* L20: */
            }
        } else {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n;
                for (i__ = j; i__ <= i__2; ++i__) {
/* Computing MAX */
                    d__2 = value, d__3 = (d__1 = a[i__ + j * a_dim1], abs(
                        d__1));
                    value = max(d__2,d__3);
/* L30: */
                }
/* L40: */
            }
        }
    } else if (lsame_(norm, "I") || lsame_(norm, "O") || *(unsigned char *)norm == '1') {

/*        Find normI(A) ( = norm1(A), since A is symmetric). */

        value = 0.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = 0.;
                i__2 = j - 1;
                for (i__ = 1; i__ <= i__2; ++i__) {
                    absa = (d__1 = a[i__ + j * a_dim1], abs(d__1));
                    sum += absa;
                    work[i__] += absa;
/* L50: */
                }
                work[j] = sum + (d__1 = a[j + j * a_dim1], abs(d__1));
/* L60: */
            }
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
                d__1 = value, d__2 = work[i__];
                value = max(d__1,d__2);
/* L70: */
            }
        } else {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                work[i__] = 0.;
/* L80: */
            }
            i__1 = *n;
            for (j = 1; j <= i__1; ++j) {
                sum = work[j] + (d__1 = a[j + j * a_dim1], abs(d__1));
                i__2 = *n;
                for (i__ = j + 1; i__ <= i__2; ++i__) {
                    absa = (d__1 = a[i__ + j * a_dim1], abs(d__1));
                    sum += absa;
                    work[i__] += absa;
/* L90: */
                }
                value = max(value,sum);
/* L100: */
            }
        }
    } else if (lsame_(norm, "F") || lsame_(norm, "E")) {

/*        Find normF(A). */

        scale = 0.;
        sum = 1.;
        if (lsame_(uplo, "U")) {
            i__1 = *n;
            for (j = 2; j <= i__1; ++j) {
                i__2 = j - 1;
                dlassq_(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
/* L110: */
            }
        } else {
            i__1 = *n - 1;
            for (j = 1; j <= i__1; ++j) {
                i__2 = *n - j;
                dlassq_(&i__2, &a[j + 1 + j * a_dim1], &c__1, &scale, &sum);
/* L120: */
            }
        }
        sum *= 2;
        i__1 = *lda + 1;
        dlassq_(n, &a[a_offset], &i__1, &scale, &sum);
        value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of DLANSY */

} /* dlansy_ */


注释：这段代码是一个 Fortran 子程序 `dlansy_`，用于计算对称矩阵的各种范数。根据输入的参数 `norm` 的不同取值，分别计算矩阵的最大值范数、1-范数（或无穷范数）、Frobenius 范数。具体的计算过程中包含了循环遍历矩阵元素，并根据不同的上/下三角性质进行不同的累加操作。
    doublereal *d__, doublereal *rt1r, doublereal *rt1i, doublereal *rt2r,
     doublereal *rt2i, doublereal *cs, doublereal *sn)



# 声明一个 Fortran 函数的参数列表
# d__: 指向双精度实数的指针，用于传递数组或变量的地址
# rt1r: 指向双精度实数的指针，用于传递变量 rt1r 的地址
# rt1i: 指向双精度实数的指针，用于传递变量 rt1i 的地址
# rt2r: 指向双精度实数的指针，用于传递变量 rt2r 的地址
# rt2i: 指向双精度实数的指针，用于传递变量 rt2i 的地址
# cs: 指向双精度实数的指针，用于传递变量 cs 的地址
# sn: 指向双精度实数的指针，用于传递变量 sn 的地址
    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal p, z__, aa, bb, cc, dd, cs1, sn1, sab, sac, eps, tau,
        temp, scale, bcmax, bcmis, sigma;

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
    matrix in standard form:

         [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
         [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]

    where either
    1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
    2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
    conjugate eigenvalues.

    Arguments
    =========

    A       (input/output) DOUBLE PRECISION
    B       (input/output) DOUBLE PRECISION
    C       (input/output) DOUBLE PRECISION
    D       (input/output) DOUBLE PRECISION
            On entry, the elements of the input matrix.
            On exit, they are overwritten by the elements of the
            standardised Schur form.

    RT1R    (output) DOUBLE PRECISION
    RT1I    (output) DOUBLE PRECISION
    RT2R    (output) DOUBLE PRECISION
    RT2I    (output) DOUBLE PRECISION
            The real and imaginary parts of the eigenvalues. If the
            eigenvalues are a complex conjugate pair, RT1I > 0.

    CS      (output) DOUBLE PRECISION
    SN      (output) DOUBLE PRECISION
            Parameters of the rotation matrix.

    Further Details
    ===============

    Modified by V. Sima, Research Institute for Informatics, Bucharest,
    Romania, to reduce the risk of cancellation errors,
    when computing real eigenvalues, and to ensure, if possible, that
    abs(RT1R) >= abs(RT2R).

    =====================================================================
*/

    eps = PRECISION;
    // 判断 C 是否为零，决定旋转角度参数
    if (*c__ == 0.) {
        *cs = 1.;
        *sn = 0.;
        goto L10;

    } else if (*b == 0.) {
        // 若 B 为零，则交换矩阵的行和列
        *cs = 0.;
        *sn = 1.;
        temp = *d__;
        *d__ = *a;
        *a = temp;
        *b = -(*c__);
        *c__ = 0.;
        goto L10;
    } else if (*a - *d__ == 0. && d_sign(&c_b15, b) != d_sign(&c_b15, c__)) {
        // 若 A 和 D 相等且 B 和 C 乘积为负数，则 A 和 D 是实特征值
        *cs = 1.;
        *sn = 0.;
        goto L10;
    } else {
        // 计算用于决定特征值类型的参数和中间变量
        temp = *a - *d__;
        p = temp * .5;
        // 计算最大和最小的绝对值及其乘积
        d__1 = abs(*b), d__2 = abs(*c__);
        bcmax = max(d__1,d__2);
        d__1 = abs(*b), d__2 = abs(*c__);
        bcmis = min(d__1,d__2) * d_sign(&c_b15, b) * d_sign(&c_b15, c__);
        // 计算尺度因子和参数 Z
        d__1 = abs(p);
        scale = max(d__1,bcmax);
        z__ = p / scale * p + bcmax / scale * bcmis;

        // 若 Z 大于等于机器精度的四倍，则推迟对特征值性质的决定
        if (z__ >= eps * 4.) {
/*           Real eigenvalues. Compute A and D. */

        d__1 = sqrt(scale) * sqrt(z__);  // 计算 sqrt(scale) * sqrt(z__) 并赋给 d__1
        z__ = p + d_sign(&d__1, &p);  // 计算 p + sign(sqrt(scale) * sqrt(z__), p) 并赋给 z__
        *a = *d__ + z__;  // 计算 *a = *d__ + z__
        *d__ -= bcmax / z__ * bcmis;  // 计算 *d__ -= bcmax / z__ * bcmis

/*           Compute B and the rotation matrix */

        tau = dlapy2_(c__, &z__);  // 调用 dlapy2_ 计算 tau = sqrt(|*c__|^2 + |z__|^2)
        *cs = z__ / tau;  // 计算 *cs = z__ / tau
        *sn = *c__ / tau;  // 计算 *sn = *c__ / tau
        *b -= *c__;  // 计算 *b -= *c__
        *c__ = 0.;  // 将 *c__ 置零
    } else {

/*
             Complex eigenvalues, or real (almost) equal eigenvalues.
             Make diagonal elements equal.
*/

        sigma = *b + *c__;  // 计算 sigma = *b + *c__
        tau = dlapy2_(&sigma, &temp);  // 调用 dlapy2_ 计算 tau = sqrt(|sigma|^2 + |temp|^2)
        *cs = sqrt((abs(sigma) / tau + 1.) * .5);  // 计算 *cs = sqrt((|sigma| / tau + 1) / 2)
        *sn = -(p / (tau * *cs)) * d_sign(&c_b15, &sigma);  // 计算 *sn = -p / (tau * *cs) * sign(1.0, sigma)

/*
             Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
                     [ CC  DD ]   [ C  D ] [ SN  CS ]
*/

        aa = *a * *cs + *b * *sn;  // 计算 aa = *a * *cs + *b * *sn
        bb = -(*a) * *sn + *b * *cs;  // 计算 bb = -(*a) * *sn + *b * *cs
        cc = *c__ * *cs + *d__ * *sn;  // 计算 cc = *c__ * *cs + *d__ * *sn
        dd = -(*c__) * *sn + *d__ * *cs;  // 计算 dd = -(*c__) * *sn + *d__ * *cs

/*
             Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
                     [ C  D ]   [-SN  CS ] [ CC  DD ]
*/

        *a = aa * *cs + cc * *sn;  // 计算 *a = aa * *cs + cc * *sn
        *b = bb * *cs + dd * *sn;  // 计算 *b = bb * *cs + dd * *sn
        *c__ = -aa * *sn + cc * *cs;  // 计算 *c__ = -aa * *sn + cc * *cs
        *d__ = -bb * *sn + dd * *cs;  // 计算 *d__ = -bb * *sn + dd * *cs

        temp = (*a + *d__) * .5;  // 计算 temp = (*a + *d__) / 2
        *a = temp;  // 将 *a 更新为 temp
        *d__ = temp;  // 将 *d__ 更新为 temp

        if (*c__ != 0.) {
        if (*b != 0.) {
            if (d_sign(&c_b15, b) == d_sign(&c_b15, c__)) {

/*                    Real eigenvalues: reduce to upper triangular form */

            sab = sqrt((abs(*b)));  // 计算 sab = sqrt(|*b|)
            sac = sqrt((abs(*c__)));  // 计算 sac = sqrt(|*c__|)
            d__1 = sab * sac;  // 计算 d__1 = sab * sac
            p = d_sign(&d__1, c__);  // 计算 p = sign(d__1, *c__)
            tau = 1. / sqrt((d__1 = *b + *c__, abs(d__1)));  // 计算 tau = 1 / sqrt(|*b + *c__|)
            *a = temp + p;  // 计算 *a = temp + p
            *d__ = temp - p;  // 计算 *d__ = temp - p
            *b -= *c__;  // 计算 *b -= *c__
            *c__ = 0.;  // 将 *c__ 置零
            cs1 = sab * tau;  // 计算 cs1 = sab * tau
            sn1 = sac * tau;  // 计算 sn1 = sac * tau
            temp = *cs * cs1 - *sn * sn1;  // 计算 temp = *cs * cs1 - *sn * sn1
            *sn = *cs * sn1 + *sn * cs1;  // 计算 *sn = *cs * sn1 + *sn * cs1
            *cs = temp;  // 将 *cs 更新为 temp
            }
        } else {
            *b = -(*c__);  // 将 *b 更新为 -(*c__)
            *c__ = 0.;  // 将 *c__ 置零
            temp = *cs;  // 交换 *cs 和 *sn
            *cs = -(*sn);
            *sn = temp;
        }
        }
    }

    }

L10:

/*     Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I). */

    *rt1r = *a;  // 存储 *a 到 *rt1r
    *rt2r = *d__;  // 存储 *d__ 到 *rt2r
    if (*c__ == 0.) {
    *rt1i = 0.;  // 如果 *c__ 为零，则将 *rt1i 置零
    *rt2i = 0.;  // 将 *rt2i 置零
    } else {
    *rt1i = sqrt((abs(*b))) * sqrt((abs(*c__)));  // 计算 *rt1i = sqrt(|*b|) * sqrt(|*c__|)
    *rt2i = -(*rt1i);  // 计算 *rt2i = -(*rt1i)
    }
    return 0;  // 返回 0 表示正常结束

/*     End of DLANV2 */

} /* dlanv2_ */

doublereal dlapy2_(doublereal *x, doublereal *y)
{
    /* System generated locals */
    doublereal ret_val, d__1;

    /* Local variables */
    static doublereal w, z__, xabs, yabs;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
    overflow.

    Arguments
    =========


*/
    X       (input) DOUBLE PRECISION
    Y       (input) DOUBLE PRECISION
            X and Y specify the values x and y.
/* Subroutine */ int dlaqr0_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal
    *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__,
    integer *ldz, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    static integer i__, k;  // 声明整数变量 i 和 k
    static doublereal aa, bb, cc, dd;  // 声明双精度浮点数变量 aa, bb, cc, dd
    static integer ld;  // 声明整数变量 ld
    static doublereal cs;  // 声明双精度浮点数变量 cs
    static integer nh, it, ks, kt;  // 声明整数变量 nh, it, ks, kt
    static doublereal sn;  // 声明双精度浮点数变量 sn
    static integer ku, kv, ls, ns;  // 声明整数变量 ku, kv, ls, ns
    static doublereal ss;  // 声明双精度浮点数变量 ss
    static integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl,
        kbot, nmin;  // 声明一系列整数变量
    static doublereal swap;  // 声明双精度浮点数变量 swap
    static integer ktop;  // 声明整数变量 ktop
    static doublereal zdum[1];  // 声明双精度浮点数数组 zdum，长度为1
    static integer kacc22, itmax, nsmax, nwmax, kwtop;  // 声明一系列整数变量

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
    unnecessary overflow.

    Arguments
    =========

    X       (input) DOUBLE PRECISION
    Y       (input) DOUBLE PRECISION
    Z       (input) DOUBLE PRECISION
            X, Y and Z specify the values x, y and z.

    =====================================================================
*/


    xabs = abs(*x);  // 计算 x 的绝对值
    yabs = abs(*y);  // 计算 y 的绝对值
    zabs = abs(*z__);  // 计算 z 的绝对值
/* Computing MAX */
    d__1 = max(xabs,yabs);  // 计算 xabs 和 yabs 的最大值
    w = max(d__1,zabs);  // 计算 d__1 和 zabs 的最大值，赋值给 w
    if (w == 0.) {
/*
       W can be zero for max(0,nan,0)
       adding all three entries together will make sure
       NaN will not disappear.
*/
    ret_val = xabs + yabs + zabs;  // 如果 w 等于 0，返回 xabs + yabs + zabs
    } else {
/* Computing 2nd power */
    d__1 = xabs / w;  // 计算 xabs / w 的平方
/* Computing 2nd power */
    d__2 = yabs / w;  // 计算 yabs / w 的平方
/* Computing 2nd power */
    d__3 = zabs / w;  // 计算 zabs / w 的平方
    ret_val = w * sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);  // 计算 w * sqrt(d__1^2 + d__2^2 + d__3^2)，赋值给 ret_val
    }
    return ret_val;

/*     End of DLAPY3 */

} /* dlapy3_ */
    ! 外部子程序声明：dlanv2_、dlaqr3_、dlaqr4_、dlaqr5_、dlahqr_、dlacpy_、ilaenv_
    extern /* Subroutine */ int dlanv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *), 
        dlaqr3_(logical *, logical *, integer *, integer *, integer *, integer *,
        doublereal *, integer *, integer *, integer *, doublereal *,
        integer *, integer *, integer *, doublereal *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *);
    ! 静态整型变量声明：nibble
    static integer nibble;
    ! 外部子程序声明：dlaqr4_
    extern /* Subroutine */ int dlaqr4_(logical *, logical *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *,
        integer *);
    ! 外部子程序声明：dlaqr5_
    extern /* Subroutine */ int dlaqr5_(logical *, logical *, integer *, integer *, integer *,
        integer *, integer *, doublereal *, doublereal *, doublereal *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *, integer *, doublereal *, integer *, integer *,
        doublereal *, integer *);
    ! 静态整型变量声明：sorted、nwupbd、lwkopt
    static logical sorted;
    static integer nwupbd;
    static integer lwkopt;
    ! 外部子程序声明：dlahqr_
    extern /* Subroutine */ int dlahqr_(logical *, logical *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *);
    ! 外部子程序声明：dlacpy_
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, integer *);
    ! 外部函数声明：ilaenv_
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 静态字符数组声明：jbcmpz
    static char jbcmpz[2];
/*
    Parameter adjustments
*/
    // 设置矩阵H的行和列偏移
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;  // 调整H的起始地址，将其指向实际数据部分
    // 调整wr, wi, z__和work数组的指针
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;  // 调整Z矩阵的起始地址，将其指向实际数据部分
    --work;

    /* Function Body */
    *info = 0;  // 将info参数初始化为0，用于存储函数执行的状态信息

/*     ==== Quick return for N = 0: nothing to do. ==== */

    if (*n == 0) {
        // 当矩阵维度N为0时，直接返回，将工作数组中第一个元素设为1
        work[1] = 1.;
        return 0;  // 返回0表示成功执行
    }

    if (*n <= 11) {

/*        ==== Tiny matrices must use DLAHQR. ==== */

    lwkopt = 1;  // 对于小于等于11的矩阵，设置工作空间大小为1
    if (*lwork != -1) {
        // 如果不是查询工作空间大小，则调用DLAHQR函数进行QR分解
        dlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
            wi[1], iloz, ihiz, &z__[z_offset], ldz, info);
    }
    } else {

/*
          ==== Use small bulge multi-shift QR with aggressive early
          .    deflation on larger-than-tiny matrices. ====

          ==== Hope for the best. ====
*/

    *info = 0;  // 将info参数重新初始化为0

/*        ==== Set up job flags for ILAENV. ==== */

    if (*wantt) {
        // 根据wantt参数设置jbcmpz数组的第一个字符
        *(unsigned char *)jbcmpz = 'S';
    } else {
        // 根据wantt参数设置jbcmpz数组的第一个字符
        *(unsigned char *)jbcmpz = 'E';
    }
    if (*wantz) {
        // 根据wantz参数设置jbcmpz数组的第二个字符
        *(unsigned char *)&jbcmpz[1] = 'V';
    } else {
        // 根据wantz参数设置jbcmpz数组的第二个字符
        *(unsigned char *)&jbcmpz[1] = 'N';
    }

/*
          ==== NWR = recommended deflation window size.  At this
          .    point,  N .GT. NTINY = 11, so there is enough
          .    subdiagonal workspace for NWR.GE.2 as required.
          .    (In fact, there is enough subdiagonal space for
          .    NWR.GE.3.) ====
*/

    nwr = ilaenv_(&c__13, "DLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);  // 调用ILAENV函数查询NWR的推荐值
    nwr = max(2,nwr);  // 取NWR和2的最大值作为最终的NWR值
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);  // 计算NWR的上限
    nwr = min(i__1,nwr);

/*
          ==== NSR = recommended number of simultaneous shifts.
          .    At this point N .GT. NTINY = 11, so there is at
          .    enough subdiagonal workspace for NSR to be even
          .    and greater than or equal to two as required. ====
*/

    nsr = ilaenv_(&c__15, "DLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);  // 调用ILAENV函数查询NSR的推荐值
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;  // 计算NSR的上限
    nsr = min(i__1,i__2);
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;  // 确保NSR为偶数并大于等于2
    nsr = max(i__1,i__2);

/*
          ==== Estimate optimal workspace ====

          ==== Workspace query call to DLAQR3 ====
*/

    i__1 = nwr + 1;  // 设置DLAQR3函数所需的工作空间大小
    dlaqr3_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
        h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset],
        ldh, &work[1], &c_n1);  // 调用DLAQR3函数查询工作空间大小

/*
          ==== Optimal workspace = MAX(DLAQR5, DLAQR3) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1];  // 计算DLAQR5和DLAQR3的最大工作空间大小
    lwkopt = max(i__1,i__2);

/*        ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {
        // 如果是查询工作空间大小，则将work数组的第一个元素设为lwkopt的值，然后返回
        work[1] = (doublereal) lwkopt;
        return 0;  // 返回0表示成功执行
    }

/*        ==== DLAHQR/DLAQR0 crossover point ==== */
    # 调用外部函数ilaenv_，获取计算机配置参数，返回值赋给nmin
    nmin = ilaenv_(&c__12, "DLAQR0", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
        6, (ftnlen)2);
    # 将nmin与11比较，取较大的值作为最终的nmin值
    nmin = max(11,nmin);
/*        ==== Nibble crossover point ==== */

    nibble = ilaenv_(&c__14, "DLAQR0", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 调用 ilaenv_ 函数获取参数 c__14 对应的值，用于控制算法中的某个阈值（nibble）
    nibble = max(0,nibble);

/*
          ==== Accumulate reflections during ttswp?  Use block
          .    2-by-2 structure during matrix-matrix multiply? ====
*/

    kacc22 = ilaenv_(&c__16, "DLAQR0", jbcmpz, n, ilo, ihi, lwork, (
        ftnlen)6, (ftnlen)2);
    // 调用 ilaenv_ 函数获取参数 c__16 对应的值，用于控制算法中的另一个阈值（kacc22）
    kacc22 = max(0,kacc22);
    kacc22 = min(2,kacc22);

/*
          ==== NWMAX = the largest possible deflation window for
          .    which there is sufficient workspace. ====

   Computing MIN
*/
    i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
    // 计算最大的挤压窗口大小，确保工作空间足够
    nwmax = min(i__1,i__2);
    nw = nwmax;

/*
          ==== NSMAX = the Largest number of simultaneous shifts
          .    for which there is sufficient workspace. ====

   Computing MIN
*/
    i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
    // 计算最大的同时移位数，确保工作空间足够
    nsmax = min(i__1,i__2);
    nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

    ndfl = 1;
    // 初始化迭代计数器，用于在挤压过程中重新启动

/*
          ==== ITMAX = iteration limit ====

   Computing MAX
*/
    i__1 = 10, i__2 = *ihi - *ilo + 1;
    // 计算迭代次数上限，基于一些参数的最大值
    itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

    kbot = *ihi;
    // 活动区块中的最后一行和列的索引

/*        ==== Main Loop ==== */

    i__1 = itmax;
    for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

        if (kbot < *ilo) {
        goto L90;
        }
        // 如果 kbot 小于 ilo，则跳转到标签 L90 结束主循环

/*           ==== Locate active block ==== */

        i__2 = *ilo + 1;
        // 定位活动区块的起始列
        for (k = kbot; k >= i__2; --k) {
        if (h__[k + (k - 1) * h_dim1] == 0.) {
            goto L20;
        }
/* L10: */
        }
        k = *ilo;
L20:
        ktop = k;
        // 确定活动区块的顶部行和列

/*
             ==== Select deflation window size:
             .    Typical Case:
             .      If possible and advisable, nibble the entire
             .      active block.  If not, use size MIN(NWR,NWMAX)
             .      or MIN(NWR+1,NWMAX) depending upon which has
             .      the smaller corresponding subdiagonal entry
             .      (a heuristic).
             .
             .    Exceptional Case:
             .      If there have been no deflations in KEXNW or
             .      more iterations, then vary the deflation window
             .      size.   At first, because, larger windows are,
             .      in general, more powerful than smaller ones,
             .      rapidly increase the window to the maximum possible.
             .      Then, gradually reduce the window size. ====
*/

        nh = kbot - ktop + 1;
        // 计算活动区块的大小
        nwupbd = min(nh,nwmax);
        // 选择挤压窗口的大小
        if (ndfl < 5) {
        nw = min(nwupbd,nwr);
        } else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
        /* 将 nw 调整为 nwupbd 和 2*nw 中的较小值 */

        }
        if (nw < nwmax) {
        /* 如果 nw 小于 nwmax，则执行以下操作 */
        if (nw >= nh - 1) {
            /* 如果 nw 大于等于 nh - 1，则将 nw 设为 nh */
            nw = nh;
        } else {
            kwtop = kbot - nw + 1;
            /* 计算 kwtop，用于后续的判断 */
            if ((d__1 = h__[kwtop + (kwtop - 1) * h_dim1], abs(d__1))
                > (d__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1],
                abs(d__2))) {
            ++nw;
            }
        }
        }
        if (ndfl < 5) {
        /* 如果 ndfl 小于 5，则执行以下操作 */
        ndec = -1;
        /* 将 ndec 设为 -1 */
        } else if (ndec >= 0 || nw >= nwupbd) {
        /* 否则如果 ndec 大于等于 0 或者 nw 大于等于 nwupbd，则执行以下操作 */
        ++ndec;
        /* ndec 自增 */
        if (nw - ndec < 2) {
            /* 如果 nw - ndec 小于 2，则将 ndec 设为 0 */
            ndec = 0;
        }
        nw -= ndec;
        /* nw 减去 ndec */
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/

/* 进行积极的早期缩减处理：
   将次对角线下的工作空间分割为
     - 左下角的 nw × nw 工作数组 V，
     - 底边的 NW × 至少 NW 但更多更好的水平工作数组（NW × NHO），
     - 左边缘的至少 NW 但更多更好的垂直工作数组（NHV × NW）。
*/

        kv = *n - nw + 1;
        /* 计算 kv */
        kt = nw + 1;
        /* 计算 kt */
        nho = *n - nw - 1 - kt + 1;
        /* 计算 nho */
        kwv = nw + 2;
        /* 计算 kwv */
        nve = *n - nw - kwv + 1;
        /* 计算 nve */

/*           ==== Aggressive early deflation ==== */

/* 进行积极的早期缩减处理 */

        dlaqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
             &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

/* 调整 KBOT 来考虑新的缩减 */

        kbot -= ld;

/*           ==== KS points to the shifts. ==== */

/* KS 指向移位值 */

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/

/* 如果有部分启发式原因表明许多特征值会在没有QR扫描的情况下缩减，则跳过昂贵的QR扫描。
   如果刚刚有许多特征值被缩减或者剩余的活跃块很小，则跳过QR扫描。 */

        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if DLAQR3
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* NS = 预期的同时移位数。
   如果 DLAQR3 没有提供那么多的移位，可能会稍微降低这个值。 */

        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
        ns = min(i__2,i__3);
        ns -= ns % 2;
        /* 计算 ns，使其成为 nsmax 和 min(2, kbot-ktop) 的较小值，并确保 ns 是偶数 */

/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    DLAQR3 above or from the eigenvalues
                .    of a trailing principal submatrix. ====

*/
/* 如果在 KEXSH 的倍数迭代中没有缩减，则尝试使用异常移位。
   否则使用 DLAQR3 提供的移位或者来自尾部主子矩阵的特征值。 */
        if (ndfl % 6 == 0) {
            ks = kbot - ns + 1;
/*
               计算 MAX 函数的结果
               计算 ks + 1 和 ktop + 2 中的最大值
*/
            i__3 = max(ks + 1, ktop + 2);
            for (i__ = kbot; i__ >= i__3; i__ += -2) {
/*
               计算 ss，aa，bb，cc 和 dd 的值
               使用 dlanv2 函数计算特征值对
*/
            ss = (d__1 = h__[i__ + (i__ - 1) * h_dim1], abs(d__1))
                 + (d__2 = h__[i__ - 1 + (i__ - 2) * h_dim1],
                abs(d__2));
            aa = ss * .75 + h__[i__ + i__ * h_dim1];
            bb = ss;
            cc = ss * -.4375;
            dd = aa;
            dlanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
                , &wr[i__], &wi[i__], &cs, &sn);
/*
               循环的标签
*/
            }
            if (ks == ktop) {
/*
               设置 wr 和 wi 的值
*/
            wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
            wi[ks + 1] = 0.;
            wr[ks] = wr[ks + 1];
            wi[ks] = wi[ks + 1];
            }
        } else {

/*
                   ==== Got NS/2 or fewer shifts? Use DLAQR4 or
                   .    DLAHQR on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====

               如果 kbot - ks + 1 小于等于 ns / 2，则执行以下操作
*/
            if (kbot - ks + 1 <= ns / 2) {
            ks = kbot - ns + 1;
            kt = *n - ns + 1;
/*
               复制数组 h__ 的一部分到另一部分
*/
            dlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
                h__[kt + h_dim1], ldh);
            if (ns > nmin) {
/*
               使用 dlaqr4_ 函数计算特征值
*/
                dlaqr4_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                    kt + h_dim1], ldh, &wr[ks], &wi[ks], &
                    c__1, &c__1, zdum, &c__1, &work[1], lwork,
                     &inf);
            } else {
/*
               使用 dlahqr_ 函数计算特征值
*/
                dlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
                    kt + h_dim1], ldh, &wr[ks], &wi[ks], &
                    c__1, &c__1, zdum, &c__1, &inf);
            }
            ks += inf;

/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  ====

               如果 ks 大于等于 kbot，则执行以下操作
*/
            if (ks >= kbot) {
/*
               使用 dlanv2 函数计算特征值对
*/
                aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
                cc = h__[kbot + (kbot - 1) * h_dim1];
                bb = h__[kbot - 1 + kbot * h_dim1];
                dd = h__[kbot + kbot * h_dim1];
                dlanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
                    kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
                    ;
                ks = kbot - 1;
            }
            }

            if (kbot - ks + 1 > ns) {

/*
                      ==== Sort the shifts (Helps a little)
                      .    Bubble sort keeps complex conjugate
                      .    pairs together. ====

               如果 kbot - ks + 1 大于 ns，则执行排序操作
*/
            sorted = FALSE_;
            // 初始化排序标志为假

            i__2 = ks + 1;
            // 设置循环边界为 ks + 1
            for (k = kbot; k >= i__2; --k) {
                // 从 kbot 循环到 ks + 1，每次减少1
                if (sorted) {
                // 如果已经排序，跳转到 L60
                goto L60;
                }
                // 设置排序标志为真
                sorted = TRUE_;
                // 设置内循环边界为 k - 1
                i__3 = k - 1;
                for (i__ = ks; i__ <= i__3; ++i__) {
                // 从 ks 循环到 k - 1，每次增加1
                if ((d__1 = wr[i__], abs(d__1)) + (d__2 = wi[
                    i__], abs(d__2)) < (d__3 = wr[i__ + 1]
                    , abs(d__3)) + (d__4 = wi[i__ + 1],
                    abs(d__4))) {
                    // 如果当前元素的模小于下一个元素的模，设置排序标志为假

                    sorted = FALSE_;

                    // 交换实部
                    swap = wr[i__];
                    wr[i__] = wr[i__ + 1];
                    wr[i__ + 1] = swap;

                    // 交换虚部
                    swap = wi[i__];
                    wi[i__] = wi[i__ + 1];
                    wi[i__ + 1] = swap;
                }
/* L40: */
                }
/* L50: */
            }
L60:
            // 标签 L60

            // 执行代码块结束，无操作
            ;
            }

/*
                   ==== Shuffle shifts into pairs of real shifts
                   .    and pairs of complex conjugate shifts
                   .    assuming complex conjugate shifts are
                   .    already adjacent to one another. (Yes,
                   .    they are.)  ====
*/

            i__2 = ks + 2;
            // 设置循环边界为 ks + 2
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
            // 从 kbot 循环到 ks + 2，每次减少2
            if (wi[i__] != -wi[i__ - 1]) {
                // 如果当前元素与前一个元素的虚部不相反

                // 交换实部
                swap = wr[i__];
                wr[i__] = wr[i__ - 1];
                wr[i__ - 1] = wr[i__ - 2];
                wr[i__ - 2] = swap;

                // 交换虚部
                swap = wi[i__];
                wi[i__] = wi[i__ - 1];
                wi[i__ - 1] = wi[i__ - 2];
                wi[i__ - 2] = swap;
            }
/* L70: */
            }
        }

/*
                ==== If there are only two shifts and both are
                .    real, then use only one.  ====
*/

        if (kbot - ks + 1 == 2) {
            // 如果只有两个移位且都是实数，则只使用一个

            if (wi[kbot] == 0.) {
                // 如果最后一个元素的虚部为0

                if ((d__1 = wr[kbot] - h__[kbot + kbot * h_dim1], abs(
                    d__1)) < (d__2 = wr[kbot - 1] - h__[kbot +
                    kbot * h_dim1], abs(d__2))) {
                    // 比较两个实数移位的偏差，选择更小的一个
                    wr[kbot - 1] = wr[kbot];
                } else {
                    wr[kbot] = wr[kbot - 1];
                }
            }
        }

/*
                ==== Use up to NS of the smallest magnatiude
                .    shifts.  If there aren't NS shifts available,
                .    then use them all, possibly dropping one to
                .    make the number of shifts even. ====

   Computing MIN
*/
        i__2 = ns, i__3 = kbot - ks + 1;
        // 计算 ns 和 kbot - ks + 1 中的较小值
        ns = min(i__2,i__3);
        // 取得的最小值减去其模2的余数
        ns -= ns % 2;
        // 重新计算 ks
        ks = kbot - ns + 1;
        /* ==== Small-bulge multi-shift QR sweep: ====
           .    split workspace under the subdiagonal into
           .    - a KDU-by-KDU work array U in the lower
           .      left-hand-corner,
           .    - a KDU-by-at-least-KDU-but-more-is-better
           .      (KDU-by-NHo) horizontal work array WH along
           .      the bottom edge,
           .    - and an at-least-KDU-but-more-is-better-by-KDU
           .      (NVE-by-KDU) vertical work array WV arrow along
           .      the left-hand-edge. ====
        */

        kdu = ns * 3 - 3;  /* Calculate the size of KDU */
        ku = *n - kdu + 1;  /* Calculate the starting index for U */
        kwh = kdu + 1;      /* Calculate the starting index for WH */
        nho = *n - kdu - 3 - (kdu + 1) + 1;  /* Calculate the size of NHo */
        kwv = kdu + 4;      /* Calculate the starting index for WV */
        nve = *n - kdu - kwv + 1;  /* Calculate the size of NVE */

        /* ==== Small-bulge multi-shift QR sweep ==== */

        dlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks],
            &wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
            z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku +
            kwh * h_dim1], ldh);
        }

        /* ==== Note progress (or the lack of it). ==== */

        if (ld > 0) {
        ndfl = 1;  /* Set ndfl to 1 if ld > 0 */
        } else {
        ++ndfl;    /* Increment ndfl if ld <= 0 */
        }

        /*
             ==== End of main loop ====
        L80:
        */
    }

    /*
          ==== Iteration limit exceeded.  Set INFO to show where
          .    the problem occurred and exit. ====
    */

    *info = kbot;  /* Set INFO to kbot value */
L90:
    ;
    }

    /* ==== Return the optimal value of LWORK. ==== */

    work[1] = (doublereal) lwkopt;  /* Set work[1] to the optimal LWORK value */

    /* ==== End of DLAQR0 ==== */

    return 0;
} /* dlaqr0_ */

/* Subroutine */ int dlaqr1_(integer *n, doublereal *h__, integer *ldh,
    doublereal *sr1, doublereal *si1, doublereal *sr2, doublereal *si2,
    doublereal *v)
{
    /* System generated locals */
    integer h_dim1, h_offset;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    static doublereal s, h21s, h31s;
    -- LAPACK辅助例程（版本3.2）--
       来自田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和NAG有限公司。
       2006年11月


         给定一个2×2或3×3矩阵H，DLAQR1设置v为以下乘积的第一列的标量倍数：

         (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)

         这里进行了缩放以避免溢出和大多数下溢。假设满足以下条件之一：

                 1) sr1 = sr2 且 si1 = -si2
             或
                 2) si1 = si2 = 0.

         这对于启动QR算法中的双隐式移位膨胀很有用。


         N      （输入）整数
                矩阵H的阶数。N必须为2或3。

         H      （输入）DOUBLE PRECISION数组，维度为（LDH，N）
                矩阵H在(*)中的2×2或3×3形式。

         LDH    （输入）整数
                H的主维度，即在调用过程中声明的LDH.GE.N。

         SR1    （输入）DOUBLE PRECISION
         SI1    (*)中的移位。
         SR2
         SI2

         V      （输出）DOUBLE PRECISION数组，维度为N
                矩阵K在(*)中第一列的标量倍数。

       ================================================================
       基于以下贡献：
          Karen Braman 和 Ralph Byers，数学系，
          美国堪萨斯大学

       ================================================================
    /* Parameter adjustments */
    // 定义工作数组的维度
    h_dim1 = *ldh;
    // 计算h__数组的偏移量
    h_offset = 1 + h_dim1;
    // 调整h__数组的指针以匹配偏移量
    h__ -= h_offset;
    // 调整v数组的指针以匹配偏移量
    --v;

    /* Function Body */
    // 根据n的值选择计算过程
    if (*n == 2) {
        // 计算s的值作为规范化因子
        s = (d__1 = h__[h_dim1 + 1] - *sr2, abs(d__1)) + abs(*si2) + (d__2 =
            h__[h_dim1 + 2], abs(d__2));
        // 如果s为零，设置v向量为零
        if (s == 0.) {
            v[1] = 0.;
            v[2] = 0.;
        } else {
            // 计算非零s情况下的v向量值
            h21s = h__[h_dim1 + 2] / s;
            v[1] = h21s * h__[(h_dim1 << 1) + 1] + (h__[h_dim1 + 1] - *sr1) *
                ((h__[h_dim1 + 1] - *sr2) / s) - *si1 * (*si2 / s);
            v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
                sr2);
        }
    } else {
        // 计算s的值作为规范化因子
        s = (d__1 = h__[h_dim1 + 1] - *sr2, abs(d__1)) + abs(*si2) + (d__2 =
            h__[h_dim1 + 2], abs(d__2)) + (d__3 = h__[h_dim1 + 3], abs(
            d__3));
        // 如果s为零，设置v向量为零
        if (s == 0.) {
            v[1] = 0.;
            v[2] = 0.;
            v[3] = 0.;
        } else {
            // 计算非零s情况下的v向量值
            h21s = h__[h_dim1 + 2] / s;
            h31s = h__[h_dim1 + 3] / s;
            v[1] = (h__[h_dim1 + 1] - *sr1) * ((h__[h_dim1 + 1] - *sr2) / s)
                - *si1 * (*si2 / s) + h__[(h_dim1 << 1) + 1] * h21s + h__[
                h_dim1 * 3 + 1] * h31s;
            v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
                sr2) + h__[h_dim1 * 3 + 2] * h31s;
            v[3] = h31s * (h__[h_dim1 + 1] + h__[h_dim1 * 3 + 3] - *sr1 - *
                sr2) + h21s * h__[(h_dim1 << 1) + 3];
        }
    }
    // 返回操作成功
    return 0;
} /* dlaqr1_ */

/* Subroutine */ int dlaqr2_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, doublereal *h__, integer *
    ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz,
    integer *ns, integer *nd, doublereal *sr, doublereal *si, doublereal *
    v, integer *ldv, integer *nh, doublereal *t, integer *ldt, integer *
    nv, doublereal *wv, integer *ldwv, doublereal *work, integer *lwork)
{
    /* System generated locals */
    // 系统生成的局部变量声明
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    // 局部变量声明
    static integer i__, j, k;
    static doublereal s, aa, bb, cc, dd, cs, sn;
    static integer jw;
    static doublereal evi, evk, foo;
    static integer kln;
    static doublereal tau, ulp;
    static integer lwk1, lwk2;
    static doublereal beta;
    static integer kend, kcol, info, ifst, ilst, ltop, krow;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *), dgemm_(char *, char *, integer *, integer *
        , integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    static logical bulge;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer infqr, kwtop;
    外部声明，指定了一些 Fortran 子例程的接口
    extern /* Subroutine */ int dlanv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *),

    外部声明，指定了一些 Fortran 子例程的接口
    dlabad_(
        doublereal *, doublereal *);

    外部声明，指定了一些 Fortran 子例程的接口
    extern /* Subroutine */ int dgehrd_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *),

    外部声明，指定了一些 Fortran 子例程的接口
    dlarfg_(integer *, doublereal *, doublereal *,
        integer *, doublereal *),

    外部声明，指定了一些 Fortran 子例程的接口
    dlahqr_(logical *, logical *, integer *,
         integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *),

    外部声明，指定了一些 Fortran 子例程的接口
    dlacpy_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, integer *);

    静态变量声明，定义了一个双精度浮点数变量 safmin
    static doublereal safmin;

    外部声明，指定了一些 Fortran 子例程的接口
    extern /* Subroutine */ int dlaset_(char *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *);

    静态变量声明，定义了一个双精度浮点数变量 safmax
    static doublereal safmax;

    外部声明，指定了一些 Fortran 子例程的接口
    extern /* Subroutine */ int dtrexc_(char *, integer *, doublereal *,
        integer *, doublereal *, integer *, integer *, integer *,
        doublereal *, integer *);

    外部声明，指定了一些 Fortran 子例程的接口
    dormhr_(char *, char *, integer
        *, integer *, integer *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        integer *);

    静态变量声明，定义了一个逻辑变量 sorted
    static logical sorted;

    静态变量声明，定义了一个双精度浮点数变量 smlnum
    static doublereal smlnum;

    静态变量声明，定义了一个整型变量 lwkopt
    static integer lwkopt;
/*
    -- LAPACK auxiliary routine (version 3.2.2)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

/* Parameter adjustments */
h_dim1 = *ldh;
h_offset = 1 + h_dim1;
h__ -= h_offset;
z_dim1 = *ldz;
z_offset = 1 + z_dim1;
z__ -= z_offset;
--sr;
--si;
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;
t_dim1 = *ldt;
t_offset = 1 + t_dim1;
t -= t_offset;
wv_dim1 = *ldwv;
wv_offset = 1 + wv_dim1;
wv -= wv_offset;
--work;

/* Function Body */
/* Computing MIN */
i__1 = *nw, i__2 = *kbot - *ktop + 1;
jw = min(i__1,i__2);

if (jw <= 2) {
    lwkopt = 1;
} else {
    /* ==== Workspace query call to DGEHRD ==== */
    i__1 = jw - 1;
    dgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
        c_n1, &info);
    lwk1 = (integer) work[1];

    /* ==== Workspace query call to DORMHR ==== */
    i__1 = jw - 1;
    dormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
         &v[v_offset], ldv, &work[1], &c_n1, &info);
    lwk2 = (integer) work[1];

    /* ==== Optimal workspace ==== */
    lwkopt = jw + max(lwk1,lwk2);
}

/* ==== Quick return in case of workspace query. ==== */
if (*lwork == -1) {
    work[1] = (doublereal) lwkopt;
    return 0;
}

/*
   ==== Nothing to do ...
   ... for an empty active block ... ====
*/
*ns = 0;
*nd = 0;
work[1] = 1.;
if (*ktop > *kbot) {
    return 0;
}
/* ... nor for an empty deflation window. ==== */
if (*nw < 1) {
    return 0;
}

/* ==== Machine constants ==== */
safmin = SAFEMINIMUM;
safmax = 1. / safmin;
dlabad_(&safmin, &safmax);
ulp = PRECISION;
smlnum = safmin * ((doublereal) (*n) / ulp);

/*
   ==== Setup deflation window ====

   Computing MIN
*/
i__1 = *nw, i__2 = *kbot - *ktop + 1;
jw = min(i__1,i__2);
kwtop = *kbot - jw + 1;
if (kwtop == *ktop) {
    s = 0.;
} else {
    s = h__[kwtop + (kwtop - 1) * h_dim1];
}

if (*kbot == kwtop) {
    /* ==== 1-by-1 deflation window: not much to do ==== */
    sr[kwtop] = h__[kwtop + kwtop * h_dim1];
    si[kwtop] = 0.;
    *ns = 1;
    *nd = 0;
    /* Computing MAX */
    d__2 = smlnum, d__3 = ulp * (d__1 = h__[kwtop + kwtop * h_dim1], abs(
        d__1));
    if (abs(s) <= max(d__2,d__3)) {
        *ns = 0;
        *nd = 1;
        if (kwtop > *ktop) {
            h__[kwtop + (kwtop - 1) * h_dim1] = 0.;
        }
    }
    work[1] = 1.;
    return 0;
}

/*
   ==== Convert to spike-triangular form.  (In case of a
   .    rare QR failure, this routine continues to do
   .    aggressive early deflation using that part of
   .    the deflation window that converged using INFQR
   .    here and there to keep track.) ====
*/

dlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
    ldt);
    # 将数组 h__ 中的部分数据复制到数组 t 中的指定位置
    i__1 = jw - 1;  # 计算要复制的元素个数
    i__2 = *ldh + 1;  # 数组 h__ 的列数
    i__3 = *ldt + 1;  # 数组 t 的列数
    dcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &i__3);
    
    # 将数组 v 中的部分区域初始化为特定的值
    dlaset_("A", &jw, &jw, &c_b29, &c_b15, &v[v_offset], ldv);
    
    # 对矩阵 t 进行 Hessenberg QR 分解，生成特征值和 Schur 形式
    dlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[kwtop], &si[kwtop], 
            &c__1, &jw, &v[v_offset], ldv, &infqr);
/*     ==== DTREXC needs a clean margin near the diagonal ==== */

/* 循环将矩阵 T 的特定区域清零，以满足 DTREXC 在对角附近的工作需求 */
i__1 = jw - 3;
for (j = 1; j <= i__1; ++j) {
    t[j + 2 + j * t_dim1] = 0.;
    t[j + 3 + j * t_dim1] = 0.;
/* L10: */
}

/* 如果 jw 大于 2，则进一步清零特定位置，以满足 DTREXC 的要求 */
if (jw > 2) {
    t[jw + (jw - 2) * t_dim1] = 0.;
}

/*     ==== Deflation detection loop ==== */

/* 设置 *ns 为当前工作的列数 */
*ns = jw;
/* 初始化 ilst 为 infqr + 1 */
ilst = infqr + 1;
L20:
/* 在 ilst 小于等于 *ns 的条件下循环进行判断 */
if (ilst <= *ns) {
    /* 如果 *ns 等于 1，则不存在 deflation */
    if (*ns == 1) {
        bulge = FALSE_;
    } else {
        /* 检查是否存在 bulge */
        bulge = t[*ns + (*ns - 1) * t_dim1] != 0.;
    }

    /*        ==== Small spike tip test for deflation ==== */

    /* 如果不存在 bulge */
    if (! bulge) {

        /*           ==== Real eigenvalue ==== */

        /* 计算并检查实特征值的大小 */
        foo = (d__1 = t[*ns + *ns * t_dim1], abs(d__1));
        if (foo == 0.) {
            foo = abs(s);
        }
        /* 计算阈值 */
        /* Computing MAX */
        d__2 = smlnum, d__3 = ulp * foo;
        if ((d__1 = s * v[*ns * v_dim1 + 1], abs(d__1)) <= max(d__2,d__3)) {

            /*              ==== Deflatable ==== */

            /* *ns 减少表示发现一个可缩减的特征值 */
            --(*ns);
        } else {

            /*
                    ==== Undeflatable.   Move it up out of the way.
                    .    (DTREXC can not fail in this case.) ====
            */

            /* 标记未能缩减的情况，使用 DTREXC 进行调整 */
            ifst = *ns;
            dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                     &ilst, &work[1], &info);
            /* 增加 ilst，继续检测下一个特征值 */
            ++ilst;
        }
    } else {

        /*           ==== Complex conjugate pair ==== */

        /* 计算并检查复合特征值对的大小 */
        foo = (d__3 = t[*ns + *ns * t_dim1], abs(d__3)) + sqrt((d__1 = t[
            *ns + (*ns - 1) * t_dim1], abs(d__1))) * sqrt((d__2 = t[
            *ns - 1 + *ns * t_dim1], abs(d__2)));
        if (foo == 0.) {
            foo = abs(s);
        }
        /* 计算阈值 */
        /* Computing MAX */
        d__3 = (d__1 = s * v[*ns * v_dim1 + 1], abs(d__1)), d__4 = (d__2 =
                 s * v[(*ns - 1) * v_dim1 + 1], abs(d__2));
        /* Computing MAX */
        d__5 = smlnum, d__6 = ulp * foo;
        if (max(d__3,d__4) <= max(d__5,d__6)) {

            /*              ==== Deflatable ==== */

            /* *ns 减少 2 表示发现一个可缩减的特征值对 */
            *ns += -2;
        } else {

            /*
                    ==== Undeflatable. Move them up out of the way.
                    .    Fortunately, DTREXC does the right thing with
                    .    ILST in case of a rare exchange failure. ====
            */

            /* 标记未能缩减的情况，使用 DTREXC 进行调整 */
            ifst = *ns;
            dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                     &ilst, &work[1], &info);
            /* 增加 ilst，继续检测下一个特征值对 */
            ilst += 2;
        }
    }

    /*        ==== End deflation detection loop ==== */

    /* 回到 L20 继续进行检测 */
    goto L20;
}

/*        ==== Return to Hessenberg form ==== */

/* 如果 *ns 为 0，将 s 置为 0 */
if (*ns == 0) {
    s = 0.;
}

/* 如果 *ns 小于 jw，则对 T 的对角块进行排序以提高精度 */
if (*ns < jw) {

    /*
          ==== sorting diagonal blocks of T improves accuracy for
          .    graded matrices.  Bubble sort deals well with
          .    exchange failures. ====
    */

    /* 初始化排序标志 */
    sorted = FALSE_;
    /* 设置循环起始位置 */
    i__ = *ns + 1;
L30:
    /* 如果已经排序完成，则跳转至 L50 */
    if (sorted) {
        goto L50;
    }
    /* 设置排序标志为真 */
    sorted = TRUE_;

    /* 设置 kend 为 i__ - 1 */
    kend = i__ - 1;
    /* 初始化 i__ 为 infqr + 1 */
    i__ = infqr + 1;
    /* 根据条件设定 k 的起始值 */
    if (i__ == *ns) {
        k = i__ + 1;
    } else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
        k = i__ + 1;
    } else {
        k = i__ + 2;
    }
L40:
    # 检查是否满足循环终止条件
    if (k <= kend):
        # 如果当前处理的列 k 是上三角矩阵的对角元素之一
        if (k == i__ + 1):
            # 计算并存储对角元素的绝对值
            evi = (d__1 = t[i__ + i__ * t_dim1], abs(d__1));
        else:
            # 计算并存储非对角元素的绝对值，并根据公式计算对角元素的绝对值
            evi = (d__3 = t[i__ + i__ * t_dim1], abs(d__3)) + sqrt((d__1 =
                 t[i__ + 1 + i__ * t_dim1], abs(d__1))) * sqrt((d__2 =
                 t[i__ + (i__ + 1) * t_dim1], abs(d__2)));

        # 如果当前处理的列 k 是最后一列
        if (k == kend):
            # 计算并存储最后一列的对角元素的绝对值
            evk = (d__1 = t[k + k * t_dim1], abs(d__1));
        # 如果下一行的元素为零
        elif (t[k + 1 + k * t_dim1] == 0.):
            # 计算并存储当前列的对角元素的绝对值
            evk = (d__1 = t[k + k * t_dim1], abs(d__1));
        else:
            # 计算并存储非对角元素的绝对值，并根据公式计算对角元素的绝对值
            evk = (d__3 = t[k + k * t_dim1], abs(d__3)) + sqrt((d__1 = t[
                k + 1 + k * t_dim1], abs(d__1))) * sqrt((d__2 = t[k +
                (k + 1) * t_dim1], abs(d__2)));

        # 如果当前处理的列的对角元素的绝对值大于等于上一列的对角元素的绝对值
        if (evi >= evk):
            # 更新当前处理的列索引为 k
            i__ = k;
        else:
            # 设置排序标志为假
            sorted = FALSE_;
            # 记录交换发生的行列范围
            ifst = i__;
            ilst = k;
            # 调用特定函数 dtrexc_ 执行特定操作
            dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                 &ilst, &work[1], &info);
            # 如果操作成功，更新当前处理的列索引为 ilst，否则为 k
            if (info == 0):
                i__ = ilst;
            else:
                i__ = k;

        # 根据当前处理的列是否是最后一列或下一行的元素是否为零，更新 k 的值
        if (i__ == kend):
            k = i__ + 1;
        elif (t[i__ + 1 + i__ * t_dim1] == 0.):
            k = i__ + 1;
        else:
            k = i__ + 2;

        # 转到循环开始处继续处理下一列或下一行
        goto L40;

    # 循环继续条件不满足时，转到结束处理标签
    goto L30;
L50:
    ;
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__ = jw;
L60:
    if (i__ >= infqr + 1) {
    // 如果 i__ 大于等于 infqr + 1，则执行以下操作
    if (i__ == infqr + 1) {
        // 如果 i__ 等于 infqr + 1，则将 t[i__ + i__ * t_dim1] 的值赋给 sr[kwtop + i__ - 1]，si[kwtop + i__ - 1] 被赋值为 0
        sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
        si[kwtop + i__ - 1] = 0.;
        // 将 i__ 减一
        --i__;
    } else if (t[i__ + (i__ - 1) * t_dim1] == 0.) {
        // 否则，如果 t[i__ + (i__ - 1) * t_dim1] 等于 0，则将 t[i__ + i__ * t_dim1] 的值赋给 sr[kwtop + i__ - 1]，si[kwtop + i__ - 1] 被赋值为 0
        sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
        si[kwtop + i__ - 1] = 0.;
        // 将 i__ 减一
        --i__;
    } else {
        // 否则，执行以下操作：
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];
        cc = t[i__ + (i__ - 1) * t_dim1];
        bb = t[i__ - 1 + i__ * t_dim1];
        dd = t[i__ + i__ * t_dim1];
        // 调用 dlanv2_ 函数，更新 sr[kwtop + i__ - 2], si[kwtop + i__ - 2], sr[kwtop + i__ - 1], si[kwtop + i__ - 1]，cs，sn 的值
        dlanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        // 将 i__ 减二
        i__ += -2;
    }
    // 跳转到标签 L60
    goto L60;
    }

    if (*ns < jw || s == 0.) {
    // 如果 *ns 小于 jw 或者 s 等于 0，则执行以下操作
    if (*ns > 1 && s != 0.) {

/*           ==== Reflect spike back into lower triangle ==== */

        // 将 v[v_offset] 复制到 work[1] 中
        dcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
        // 将 work[1] 赋值给 beta
        beta = work[1];
        // 调用 dlarfg_ 函数，更新 beta，work[2]，tau 的值
        dlarfg_(ns, &beta, &work[2], &c__1, &tau);
        // 将 1 赋值给 work[1]
        work[1] = 1.;

        // 设置 i__1 和 i__2 的值
        i__1 = jw - 2;
        i__2 = jw - 2;
        // 将矩阵 t[t_dim1 + 3] 的左下部分设置为常数 c_b29
        dlaset_("L", &i__1, &i__2, &c_b29, &c_b29, &t[t_dim1 + 3], ldt);

        // 调用 dlarf_ 函数，更新 t[t_offset] 的值
        dlarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        dlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
            work[jw + 1]);
        dlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
            work[jw + 1]);

        // 设置 i__1 的值
        i__1 = *lwork - jw;
        // 调用 dgehrd_ 函数，更新 t[t_offset] 和 work[1] 的值
        dgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
            , &i__1, &info);
    }

/*        ==== Copy updated reduced window into place ==== */

    // 如果 kwtop 大于 1，则执行以下操作
    if (kwtop > 1) {
        // 将 s * v[v_dim1 + 1] 赋值给 h__[kwtop + (kwtop - 1) * h_dim1]
        h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
    }
    // 将 t[t_offset] 复制到 h__[kwtop + kwtop * h_dim1] 中
    dlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
        , ldh);
    // 设置 i__1、i__2、i__3 的值
    i__1 = jw - 1;
    i__2 = *ldt + 1;
    i__3 = *ldh + 1;
    // 将 t[t_dim1 + 2] 复制到 h__[kwtop + 1 + kwtop * h_dim1] 中
    dcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
         &i__3);

/*
          ==== Accumulate orthogonal matrix in order update
          .    H and Z, if requested.  ====
*/

    // 如果 *ns 大于 1 并且 s 不等于 0，则执行以下操作
    if (*ns > 1 && s != 0.) {
        // 设置 i__1 的值
        i__1 = *lwork - jw;
        // 调用 dormhr_ 函数，更新 t[t_offset] 和 v[v_offset] 的值
        dormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
             &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
    }

/*        ==== Update vertical slab in H ==== */

    // 如果 *wantt 为真，则将 1 赋值给 ltop，否则将 *ktop 赋值给 ltop
    if (*wantt) {
        ltop = 1;
    } else {
        ltop = *ktop;
    }
    // 设置 i__1 和 i__2 的值
    i__1 = kwtop - 1;
    i__2 = *nv;
    // 循环，krow 的步长为 i__2
    for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
        i__2) {
/* Computing MIN */
        // 计算 min(i__2, kwtop - krow) 的值，赋给 kln
        i__3 = *nv, i__4 = kwtop - krow;
        kln = min(i__3,i__4);
        // 调用 dgemm_ 函数，更新 wv[wv_offset] 的值
        dgemm_("N", "N", &kln, &jw, &jw, &c_b15, &h__[krow + kwtop *
            h_dim1], ldh, &v[v_offset], ldv, &c_b29, &wv[wv_offset],
            ldwv);
        // 将 wv[wv_offset] 复制到 h__[krow + kwtop * h_dim1] 中
        dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop *
            h_dim1], ldh);
/* L70: */
    }
/*        ==== Update horizontal slab in H ==== */

/* 检查是否需要更新 H 中的水平矩形块 */
if (*wantt) {
    /* 循环遍历 H 中的水平矩形块 */
    i__2 = *n;
    i__1 = *nh;
    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2;
        kcol += i__1) {
        /* 计算当前块的大小 */
        /* Computing MIN */
        i__3 = *nh, i__4 = *n - kcol + 1;
        kln = min(i__3,i__4);
        /* 执行矩阵乘法操作 */
        dgemm_("C", "N", &jw, &kln, &jw, &c_b15, &v[v_offset], ldv, &
            h__[kwtop + kcol * h_dim1], ldh, &c_b29, &t[t_offset],
             ldt);
        /* 将结果复制回 H 中 */
        dlacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
             h_dim1], ldh);
        /* L80: */
    }
}

/*        ==== Update vertical slab in Z ==== */

/* 检查是否需要更新 Z 中的垂直矩形块 */
if (*wantz) {
    /* 循环遍历 Z 中的垂直矩形块 */
    i__1 = *ihiz;
    i__2 = *nv;
    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
         i__2) {
        /* 计算当前块的大小 */
        /* Computing MIN */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
        kln = min(i__3,i__4);
        /* 执行矩阵乘法操作 */
        dgemm_("N", "N", &kln, &jw, &jw, &c_b15, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b29, &wv[
            wv_offset], ldwv);
        /* 将结果复制回 Z 中 */
        dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
        /* L90: */
    }
}
}

/*     ==== Return the number of deflations ... ==== */

/* 返回缩小窗口的次数 */
*nd = jw - *ns;

/*
   ==== ... and the number of shifts. (Subtracting
   .    INFQR from the spike length takes care
   .    of the case of a rare QR failure while
   .    calculating eigenvalues of the deflation
   .    window.)  ====
*/

/* 返回移位操作的次数 */
*ns -= infqr;

/*      ==== Return optimal workspace. ==== */

/* 返回最优工作空间大小 */
work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR2 ==== */

/* DLAQR2 的结束 */
return 0;
} /* dlaqr2_ */

/* Subroutine */ int dlaqr3_(logical *wantt, logical *wantz, integer *n,
    integer *ktop, integer *kbot, integer *nw, doublereal *h__, integer *
    ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz,
    integer *ns, integer *nd, doublereal *sr, doublereal *si, doublereal *
    v, integer *ldv, integer *nh, doublereal *t, integer *ldt, integer *
    nv, doublereal *wv, integer *ldwv, doublereal *work, integer *lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
        wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    static integer i__, j, k;
    static doublereal s, aa, bb, cc, dd, cs, sn;
    static integer jw;
    static doublereal evi, evk, foo;
    static integer kln;
    static doublereal tau, ulp;
    static integer lwk1, lwk2, lwk3;
    static doublereal beta;
    static integer kend, kcol, info, nmin, ifst, ilst, ltop, krow;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *);
    ! 外部声明：用于应用程序的 BLAS（Basic Linear Algebra Subprograms）子例程 dlarf
    
    static logical bulge;
    ! 静态变量：逻辑类型，用于算法中的控制
    
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    ! 外部声明：用于应用程序的 BLAS 子例程 dcopy
    
    static integer infqr, kwtop;
    ! 静态变量：整数类型，用于算法中的控制
    
    extern /* Subroutine */ int dlanv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *);
    ! 外部声明：用于 LAPACK（Linear Algebra PACKage）库中的 dlanv2 子例程
    
    extern /* Subroutine */ int dlaqr4_(
        logical *, logical *, integer *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dlaqr4 子例程
    
    extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);
    ! 外部声明：用于 LAPACK 库中的 dlabad 子例程
    
    extern /* Subroutine */ int dgehrd_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *);
    ! 外部声明：用于 LAPACK 库中的 dgehrd 子例程
    
    extern /* Subroutine */ int dlarfg_(integer *, doublereal *, doublereal *,
        integer *, doublereal *);
    ! 外部声明：用于 LAPACK 库中的 dlarfg 子例程
    
    extern /* Subroutine */ int dlahqr_(
        logical *, logical *, integer *, integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, integer *,
        doublereal *, integer *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dlahqr 子例程
    
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dlacpy 子例程
    
    static doublereal safmin;
    ! 静态变量：双精度浮点数，用于算法中的控制
    
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 外部声明：用于 LAPACK 库中的 ilaenv 子例程
    
    static doublereal safmax;
    ! 静态变量：双精度浮点数，用于算法中的控制
    
    extern /* Subroutine */ int dlaset_(char *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dlaset 子例程
    
    extern /* Subroutine */ int dtrexc_(char *, integer *, doublereal *, integer *,
        doublereal *, integer *, integer *, integer *, doublereal *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dtrexc 子例程
    
    extern /* Subroutine */ int dormhr_(char *, char *, integer *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    ! 外部声明：用于 LAPACK 库中的 dormhr 子例程
    
    static logical sorted;
    ! 静态变量：逻辑类型，用于算法中的控制
    
    static doublereal smlnum;
    ! 静态变量：双精度浮点数，用于算法中的控制
    
    static integer lwkopt;
    ! 静态变量：整数类型，用于算法中的控制
/*
    -- LAPACK auxiliary routine (version 3.2.2)                        --
       Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
*/

    /* Parameter adjustments */
    h_dim1 = *ldh;  // 计算参数 h 的第一维度大小
    h_offset = 1 + h_dim1;  // 计算偏移量
    h__ -= h_offset;  // 调整数组 h__ 的指针，指向正确位置
    z_dim1 = *ldz;  // 计算参数 z 的第一维度大小
    z_offset = 1 + z_dim1;  // 计算偏移量
    z__ -= z_offset;  // 调整数组 z__ 的指针，指向正确位置
    --sr;  // 将 sr 指针前移一位
    --si;  // 将 si 指针前移一位
    v_dim1 = *ldv;  // 计算参数 v 的第一维度大小
    v_offset = 1 + v_dim1;  // 计算偏移量
    v -= v_offset;  // 调整数组 v 的指针，指向正确位置
    t_dim1 = *ldt;  // 计算参数 t 的第一维度大小
    t_offset = 1 + t_dim1;  // 计算偏移量
    t -= t_offset;  // 调整数组 t 的指针，指向正确位置
    wv_dim1 = *ldwv;  // 计算参数 wv 的第一维度大小
    wv_offset = 1 + wv_dim1;  // 计算偏移量
    wv -= wv_offset;  // 调整数组 wv 的指针，指向正确位置
    --work;  // 将 work 指针前移一位

    /* Function Body */
/* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;  // 计算 jw 为 nw 和 kbot-ktop+1 的最小值
    jw = min(i__1,i__2);  // 将结果保存到 jw 中
    if (jw <= 2) {
    lwkopt = 1;  // 如果 jw 小于等于 2，则设置 lwkopt 为 1
    } else {

/*        ==== Workspace query call to DGEHRD ==== */

    i__1 = jw - 1;  // 计算 jw - 1
    dgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
        c_n1, &info);  // 调用 DGEHRD 查询工作空间大小，并存储结果在 work 数组中
    lwk1 = (integer) work[1];  // 将结果转换为整数并存储在 lwk1 中

/*        ==== Workspace query call to DORMHR ==== */

    i__1 = jw - 1;  // 计算 jw - 1
    dormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
         &v[v_offset], ldv, &work[1], &c_n1, &info);  // 调用 DORMHR 查询工作空间大小，并存储结果在 work 数组中
    lwk2 = (integer) work[1];  // 将结果转换为整数并存储在 lwk2 中

/*        ==== Workspace query call to DLAQR4 ==== */

    dlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[1],
        &si[1], &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &
        infqr);  // 调用 DLAQR4 查询工作空间大小，并存储结果在 work 数组中
    lwk3 = (integer) work[1];  // 将结果转换为整数并存储在 lwk3 中

/*
          ==== Optimal workspace ====

   Computing MAX
*/
    i__1 = jw + max(lwk1,lwk2);  // 计算 jw + max(lwk1, lwk2)
    lwkopt = max(i__1,lwk3);  // 取 jw + max(lwk1, lwk2) 和 lwk3 的最大值作为最优工作空间大小
    }

/*     ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {  // 如果 lwork 等于 -1，表示在查询工作空间大小
    work[1] = (doublereal) lwkopt;  // 将最优工作空间大小存储在 work 数组的第一个元素中
    return 0;  // 返回 0 表示正常完成
    }

/*
       ==== Nothing to do ...
       ... for an empty active block ... ====
*/
    *ns = 0;  // 将 ns 设置为 0
    *nd = 0;  // 将 nd 设置为 0
    work[1] = 1.;  // 将 work 数组的第一个元素设置为 1.0
    if (*ktop > *kbot) {  // 如果 ktop 大于 kbot，表示活动块为空
    return 0;  // 返回 0 表示正常完成
    }
/*     ... nor for an empty deflation window. ==== */
    if (*nw < 1) {  // 如果 nw 小于 1，表示缺少缩小窗口
    return 0;  // 返回 0 表示正常完成
    }

/*     ==== Machine constants ==== */

    safmin = SAFEMINIMUM;  // 将 SAFEMINIMUM 赋值给 safmin
    safmax = 1. / safmin;  // 计算 safmax
    dlabad_(&safmin, &safmax);  // 调用 dlabad 函数更新 safmin 和 safmax
    ulp = PRECISION;  // 将 PRECISION 赋值给 ulp
    smlnum = safmin * ((doublereal) (*n) / ulp);  // 计算 smlnum

/*
       ==== Setup deflation window ====

   Computing MIN
*/
    i__1 = *nw, i__2 = *kbot - *ktop + 1;  // 计算 jw 为 nw 和 kbot-ktop+1 的最小值
    jw = min(i__1,i__2);  // 将结果保存到 jw 中
    kwtop = *kbot - jw + 1;  // 计算 kwtop
    if (kwtop == *ktop) {  // 如果 kwtop 等于 ktop
    s = 0.;  // 将 s 设置为 0
    } else {
    s = h__[kwtop + (kwtop - 1) * h_dim1];  // 否则从 h 数组中获取 s
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

    sr[kwtop] = h__[kwtop + kwtop * h_dim1];  // 将 h 数组中的值赋给 sr 数组
    si[kwtop] = 0.;  // 将 si 数组中的值设置为 0
    *ns = 1;  // 将 ns 设置为 1
    *nd = 0;  // 将 nd 设置为 0
/* Computing MAX */
    d__2 = smlnum, d__3 = ulp * (d__1 = h__[kwtop + kwtop * h_dim1], abs(
        d__1));  // 计算 max(smlnum, ulp * abs(h[kwtop, kwtop]))
    if (abs(s) <= max(d__2,d__3)) {  // 如果 abs(s) 小于等于 max(smlnum, ulp * abs(h[kwtop, kwtop]))
        *ns = 0;  // 将 ns 设置为 0
        *nd = 1;  // 将 nd 设置为 1
        if (kwtop > *ktop) {
        h__[kwtop + (kwtop - 1) * h_dim1] = 0.;  // 如果 kwtop 大于 ktop，则将 h 数组中的值
/*
       ==== Convert to spike-triangular form.  (In case of a
       .    rare QR failure, this routine continues to do
       .    aggressive early deflation using that part of
       .    the deflation window that converged using INFQR
       .    here and there to keep track.) ====
*/
dlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset],
    ldt);
/*
   复制上三角矩阵 h 的一部分到矩阵 t
*/
i__1 = jw - 1;
i__2 = *ldh + 1;
i__3 = *ldt + 1;
dcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
    i__3);
/*
   复制 h 的另一部分到 t 的另一个区域
*/

dlaset_("A", &jw, &jw, &c_b29, &c_b15, &v[v_offset], ldv);
/*
   将矩阵 v 的元素设置为指定值
*/
nmin = ilaenv_(&c__12, "DLAQR3", "SV", &jw, &c__1, &jw, lwork, (ftnlen)6,
    (ftnlen)2);
/*
   调用 ilaenv 获取参数 nmin 的值
*/
if (jw > nmin) {
    /*
       如果 jw 大于 nmin，调用 dlaqr4 进行特征值计算
    */
    dlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
        kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &work[1],
        lwork, &infqr);
} else {
    /*
       否则，调用 dlahqr 进行特征值计算
    */
    dlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
        kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
}

/*
   ==== DTREXC needs a clean margin near the diagonal ====
*/
i__1 = jw - 3;
for (j = 1; j <= i__1; ++j) {
    /*
       将 t 矩阵中特定位置的元素设为零
    */
    t[j + 2 + j * t_dim1] = 0.;
    t[j + 3 + j * t_dim1] = 0.;
    /* L10: */
}
if (jw > 2) {
    /*
       如果 jw 大于 2，将 t 矩阵中的特定元素设为零
    */
    t[jw + (jw - 2) * t_dim1] = 0.;
}

/*
   ==== Deflation detection loop ====
*/
*ns = jw;
ilst = infqr + 1;
L20:
if (ilst <= *ns) {
    /*
       如果 ilst 小于等于 ns，进行以下操作
    */
    if (*ns == 1) {
        /*
           如果 ns 等于 1，设置 bulge 为 FALSE_
        */
        bulge = FALSE_;
    } else {
        /*
           否则，检查是否有突出部分用于判断是否需要进行缩小
        */
        bulge = t[*ns + (*ns - 1) * t_dim1] != 0.;
    }

    /*
       ==== Small spike tip test for deflation ====
    */
    if (! bulge) {
        /*
           如果没有突出部分，处理实数特征值
        */
        foo = (d__1 = t[*ns + *ns * t_dim1], abs(d__1));
        if (foo == 0.) {
            foo = abs(s);
        }
        /*
           计算阈值，判断是否可缩小
        */
        if ((d__1 = s * v[*ns * v_dim1 + 1], abs(d__1)) <= max(smlnum, ulp * foo)) {
            /*
               如果满足条件，减小 ns
            */
            --(*ns);
        } else {
            /*
               否则，将不可缩小的部分移开
            */
            ifst = *ns;
            dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
                 &ilst, &work[1], &info);
            ++ilst;
        }
    } else {
        /*
           复数共轭对的处理
        */
        foo = (d__3 = t[*ns + *ns * t_dim1], abs(d__3)) + sqrt((d__1 = t[
            *ns + (*ns - 1) * t_dim1], abs(d__1))) * sqrt((d__2 = t[
            *ns - 1 + *ns * t_dim1], abs(d__2)));
        if (foo == 0.) {
            foo = abs(s);
        }
        /*
           计算阈值，判断是否可缩小
        */
        if (max((d__1 = s * v[*ns * v_dim1 + 1], abs(d__1)), (d__2 =
             s * v[(*ns - 1) * v_dim1 + 1], abs(d__2))) <= max(smlnum,
             ulp * foo)) {
            /*
               如果满足条件，减小 ns
            */
            *ns += -2;
        } else {
/*
    ==== Undeflatable. Move them up out of the way. ====
    这段代码在处理矩阵中的特定元素，用于某种特殊情况的处理。
    在这个上下文中，它处理了可能出现的一些稀有交换失败的情况。
*/

ifst = *ns;
// 调用特定函数 dtrexc_ 处理矩阵的交换，V 是一个参数，其他参数依次是指针、整数、矩阵等。
dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
        &ilst, &work[1], &info);
ilst += 2;
}

/* ==== End deflation detection loop ==== */
// 退出了一个检测矩阵缩减的循环。

goto L20;
}

/* ==== Return to Hessenberg form ==== */
// 回到 Hessenberg 形式的处理过程。

if (*ns == 0) {
s = 0.;
}

if (*ns < jw) {

/*
    ==== sorting diagonal blocks of T improves accuracy for
    .    graded matrices.  Bubble sort deals well with
    .    exchange failures. ====
*/
// 对 T 矩阵的对角块进行排序，可以提高渐进矩阵的计算精度。
sorted = FALSE_;
i__ = *ns + 1;
L30:
if (sorted) {
    goto L50;
}
sorted = TRUE_;

kend = i__ - 1;
i__ = infqr + 1;
if (i__ == *ns) {
    k = i__ + 1;
} else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
    k = i__ + 1;
} else {
    k = i__ + 2;
}
L40:
if (k <= kend) {
    if (k == i__ + 1) {
    evi = (d__1 = t[i__ + i__ * t_dim1], abs(d__1));
    } else {
    evi = (d__3 = t[i__ + i__ * t_dim1], abs(d__3)) + sqrt((d__1 =
        t[i__ + 1 + i__ * t_dim1], abs(d__1))) * sqrt((d__2 =
        t[i__ + (i__ + 1) * t_dim1], abs(d__2)));
    }

    if (k == kend) {
    evk = (d__1 = t[k + k * t_dim1], abs(d__1));
    } else if (t[k + 1 + k * t_dim1] == 0.) {
    evk = (d__1 = t[k + k * t_dim1], abs(d__1));
    } else {
    evk = (d__3 = t[k + k * t_dim1], abs(d__3)) + sqrt((d__1 = t[
        k + 1 + k * t_dim1], abs(d__1))) * sqrt((d__2 = t[k +
        (k + 1) * t_dim1], abs(d__2)));
    }

    if (evi >= evk) {
    i__ = k;
    } else {
    sorted = FALSE_;
    ifst = i__;
    ilst = k;
    dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
            &ilst, &work[1], &info);
    if (info == 0) {
        i__ = ilst;
    } else {
        i__ = k;
    }
    }
    if (i__ == kend) {
    k = i__ + 1;
    } else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
    k = i__ + 1;
    } else {
    k = i__ + 2;
    }
    goto L40;
}
goto L30;
L50:
;
}

/* ==== Restore shift/eigenvalue array from T ==== */
// 从 T 矩阵中恢复转移/特征值数组。

i__ = jw;
L60:
if (i__ >= infqr + 1) {
if (i__ == infqr + 1) {
    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
    si[kwtop + i__ - 1] = 0.;
    --i__;
} else if (t[i__ + (i__ - 1) * t_dim1] == 0.) {
    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
    si[kwtop + i__ - 1] = 0.;
    --i__;
}
    } else {
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];
        cc = t[i__ + (i__ - 1) * t_dim1];
        bb = t[i__ - 1 + i__ * t_dim1];
        dd = t[i__ + i__ * t_dim1];
        dlanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        i__ += -2;
    }
    goto L60;
    }



    } else {
        # 若条件不满足，则执行以下操作：
        # - 从矩阵 t 中获取元素 aa, cc, bb, dd，这些元素的索引基于 i__ 的值
        aa = t[i__ - 1 + (i__ - 1) * t_dim1];
        cc = t[i__ + (i__ - 1) * t_dim1];
        bb = t[i__ - 1 + i__ * t_dim1];
        dd = t[i__ + i__ * t_dim1];
        
        # 调用 dlanv2_ 函数，对给定的四个值进行特征值分解
        dlanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__
            - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
            sn);
        
        # 更新 i__ 的值，减去 2
        i__ += -2;
    }
    
    # 跳转至标号为 L60 的代码行
    goto L60;
    }



    if (*ns < jw || s == 0.) {
    if (*ns > 1 && s != 0.) {



    if (*ns < jw || s == 0.) {
        # 如果 ns 小于 jw 或者 s 等于 0，则执行以下操作：
        
    if (*ns > 1 && s != 0.) {
        # 如果 ns 大于 1 并且 s 不等于 0，则执行以下操作：
/*           ==== Reflect spike back into lower triangle ==== */

/* 将尖峰反射回下三角部分 */

dcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
/* 复制向量 v 的前 ns 个元素到 work 中 */

beta = work[1];
/* 设置 beta 为 work 的第一个元素 */

dlarfg_(ns, &beta, &work[2], &c__1, &tau);
/* 计算反射系数 tau，并更新 beta 和 work 的值 */

work[1] = 1.;
/* 将 work 的第一个元素设置为 1 */

i__1 = jw - 2;
i__2 = jw - 2;
dlaset_("L", &i__1, &i__2, &c_b29, &c_b29, &t[t_dim1 + 3], ldt);
/* 将 t 的左下部分设置为零矩阵 */

dlarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &work[jw + 1]);
/* 应用 Householder 变换来更新 t 的左下部分 */

dlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &work[jw + 1]);
/* 应用 Householder 变换来更新 t 的右下部分 */

dlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &work[jw + 1]);
/* 应用 Householder 变换来更新 v 的右侧部分 */

i__1 = *lwork - jw;
dgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1], &i__1, &info);
/* 对 t 进行纠化变换，以准备下一步迭代 */

/*        ==== Copy updated reduced window into place ==== */

/* 将更新后的减少窗口复制到指定位置 */

if (kwtop > 1) {
    h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
}
/* 如果 kwtop 大于 1，则更新 h 矩阵的特定位置 */

dlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1], ldh);
/* 复制 t 的上三角部分到 h 的指定位置 */

i__1 = jw - 1;
i__2 = *ldt + 1;
i__3 = *ldh + 1;
dcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1], &i__3);
/* 复制 t 的下三角部分到 h 的指定位置 */

/*
      ==== Accumulate orthogonal matrix in order update
      .    H and Z, if requested.  ====
*/

/*
   累积正交矩阵，用于更新 H 和 Z（如果需要的话）。
*/

if (*ns > 1 && s != 0.) {
    i__1 = *lwork - jw;
    dormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1], &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
}
/* 如果 ns 大于 1 并且 s 不等于 0，则更新正交矩阵 */

/*        ==== Update vertical slab in H ==== */

/* 更新 H 中的垂直块 */

if (*wantt) {
    ltop = 1;
} else {
    ltop = *ktop;
}
/* 根据 wantt 的值来设置 ltop */

i__1 = kwtop - 1;
i__2 = *nv;
for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += i__2) {
    /* 循环迭代 krow，更新 H 的特定垂直块 */
    /* 计算 kln 的值，kln 是更新的块的行数 */
    /* 调用 dgemm 函数更新 H 的特定块 */
    /* 调用 dlacpy 函数复制更新后的块到 H 的指定位置 */
}

/*        ==== Update horizontal slab in H ==== */

/* 更新 H 中的水平块 */

if (*wantt) {
    i__2 = *n;
    i__1 = *nh;
    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2; kcol += i__1) {
        /* 循环迭代 kcol，更新 H 的特定水平块 */
        /* 计算 kln 的值，kln 是更新的块的列数 */
        /* 调用 dgemm 函数更新 H 的特定块 */
        /* 调用 dlacpy 函数复制更新后的块到 H 的指定位置 */
    }
}

/*        ==== Update vertical slab in Z ==== */

/* 更新 Z 中的垂直块 */

if (*wantz) {
    /* 如果 wantz 为真，则继续执行以下循环 */
    /* 循环迭代 krow，更新 Z 的特定垂直块 */
    /* 计算 kln 的值，kln 是更新的块的行数 */
    /* 调用 dgemm 函数更新 Z 的特定块 */
    /* 调用 dlacpy 函数复制更新后的块到 Z 的指定位置 */
}
/* Computing MIN */
/* 计算最小值 */
        i__3 = *nv, i__4 = *ihiz - krow + 1;
/* 取 *nv 和 *ihiz - krow + 1 中的较小值 */
        kln = min(i__3,i__4);
/* 将较小值赋给 kln */
        dgemm_("N", "N", &kln, &jw, &jw, &c_b15, &z__[krow + kwtop *
            z_dim1], ldz, &v[v_offset], ldv, &c_b29, &wv[
            wv_offset], ldwv);
/* 执行矩阵乘法运算 */
        dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow +
            kwtop * z_dim1], ldz);
/* 复制矩阵 */
/* L90: */
        }
    }
    }

/*     ==== Return the number of deflations ... ==== */
/* 返回缩减数目 */

    *nd = jw - *ns;

/*
       ==== ... and the number of shifts. (Subtracting
       .    INFQR from the spike length takes care
       .    of the case of a rare QR failure while
       .    calculating eigenvalues of the deflation
       .    window.)  ====
*/
/*
       返回移位数目。从尖峰长度中减去 INFQR 可处理稀有的 QR 失败情况，
       这种情况发生在计算缩减窗口的特征值时。
*/

    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */
/* 返回最佳工作空间 */

    work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR3 ==== */
/* DLAQR3 结束 */

    return 0;
} /* dlaqr3_ */

/* Subroutine */ int dlaqr4_(logical *wantt, logical *wantz, integer *n,
    integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal
    *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__,
    integer *ldz, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    static integer i__, k;
    static doublereal aa, bb, cc, dd;
    static integer ld;
    static doublereal cs;
    static integer nh, it, ks, kt;
    static doublereal sn;
    static integer ku, kv, ls, ns;
    static doublereal ss;
    static integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl,
        kbot, nmin;
    static doublereal swap;
    static integer ktop;
    static doublereal zdum[1]    /* was [1][1] */;
    static integer kacc22, itmax, nsmax, nwmax, kwtop;
    extern /* Subroutine */ int dlaqr2_(logical *, logical *, integer *,
        integer *, integer *, integer *, doublereal *, integer *, integer
        *, integer *, doublereal *, integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *, integer *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        doublereal *, integer *), dlanv2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *), dlaqr5_(
        logical *, logical *, integer *, integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *, doublereal *, integer *);
    static integer nibble;
    # 声明外部函数 dlahqr_ 和 dlacpy_
    extern /* Subroutine */ int dlahqr_(logical *, logical *, integer *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, integer *, doublereal *, integer *,
        integer *);
    
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, integer *);

    # 声明静态变量 jbcmpz，类型为字符数组，长度为 2
    static char jbcmpz[2];

    # 声明静态变量 nwupbd，类型为整数
    static integer nwupbd;

    # 声明静态变量 sorted，类型为逻辑型（logical）
    static logical sorted;

    # 声明静态变量 lwkopt，类型为整数
    static integer lwkopt;
/*
*/
    /* Parameter adjustments */
    h_dim1 = *ldh;                           // 设置矩阵 H 的第一维度为 ldh
    h_offset = 1 + h_dim1;                   // 计算 h__ 的偏移量
    h__ -= h_offset;                         // 调整 h__ 指针，使其指向正确的内存位置
    --wr;                                    // wr 指针前移，指向存储实部特征值的数组
    --wi;                                    // wi 指针前移，指向存储虚部特征值的数组
    z_dim1 = *ldz;                           // 设置矩阵 Z 的第一维度为 ldz
    z_offset = 1 + z_dim1;                   // 计算 z__ 的偏移量
    z__ -= z_offset;                         // 调整 z__ 指针，使其指向正确的内存位置
    --work;                                  // work 指针前移，指向工作空间数组

    /* Function Body */
    *info = 0;                               // 将 info 设置为 0，表示无错误

/*     ==== Quick return for N = 0: nothing to do. ==== */

    if (*n == 0) {                           // 如果 n = 0，则直接返回
    work[1] = 1.;                            // 设置工作空间的第一个元素为 1.0
    return 0;                                // 返回
    }

    if (*n <= 11) {

/*        ==== Tiny matrices must use DLAHQR. ==== */

    lwkopt = 1;                               // 设置推荐的工作空间大小为 1
    if (*lwork != -1) {                       // 如果不是在查询工作空间大小
        dlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
            wi[1], iloz, ihiz, &z__[z_offset], ldz, info);  // 调用 DLAHQR 处理小型矩阵
    }
    } else {

/*
          ==== Use small bulge multi-shift QR with aggressive early
          .    deflation on larger-than-tiny matrices. ====

          ==== Hope for the best. ====
*/

    *info = 0;                               // 再次将 info 设置为 0，以确保没有错误

/*        ==== Set up job flags for ILAENV. ==== */

    if (*wantt) {                             // 根据 wantt 设置 jbcmpz 的第一个字符
        *(unsigned char *)jbcmpz = 'S';
    } else {
        *(unsigned char *)jbcmpz = 'E';
    }
    if (*wantz) {                             // 根据 wantz 设置 jbcmpz 的第二个字符
        *(unsigned char *)&jbcmpz[1] = 'V';
    } else {
        *(unsigned char *)&jbcmpz[1] = 'N';
    }

/*
          ==== NWR = recommended deflation window size.  At this
          .    point,  N .GT. NTINY = 11, so there is enough
          .    subdiagonal workspace for NWR.GE.2 as required.
          .    (In fact, there is enough subdiagonal space for
          .    NWR.GE.3.) ====
*/

    nwr = ilaenv_(&c__13, "DLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);                          // 调用 ILAENV 获取推荐的窗口大小 NWR
    nwr = max(2,nwr);                         // 将 NWR 设置为 2 和推荐值之间的最大值
/* Computing MIN */
    i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = min(i__1,i__2);
    nwr = min(i__1,nwr);                      // 将 NWR 设置为当前计算出的值和推荐值之间的最小值

/*
          ==== NSR = recommended number of simultaneous shifts.
          .    At this point N .GT. NTINY = 11, so there is at
          .    enough subdiagonal workspace for NSR to be even
          .    and greater than or equal to two as required. ====
*/

    nsr = ilaenv_(&c__15, "DLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)6,
         (ftnlen)2);                          // 调用 ILAENV 获取推荐的同时移位数 NSR
/* Computing MIN */
    i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = min(i__1,i__2), i__2 = *ihi -
        *ilo;
    nsr = min(i__1,i__2);                     // 将 NSR 设置为当前计算出的值和推荐值之间的最小值
/* Computing MAX */
    i__1 = 2, i__2 = nsr - nsr % 2;
    nsr = max(i__1,i__2);                     // 将 NSR 设置为 2 和计算出的偶数值之间的最大值

/*
          ==== Estimate optimal workspace ====

          ==== Workspace query call to DLAQR2 ====
*/

    i__1 = nwr + 1;
    dlaqr2_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz,
        ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
        h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset],
        ldh, &work[1], &c_n1);                 // 调用 DLAQR2 进行工作空间查询

/*
          ==== Optimal workspace = MAX(DLAQR5, DLAQR2) ====

   Computing MAX
*/
    i__1 = nsr * 3 / 2, i__2 = (integer) work[1];
    lwkopt = max(i__1,i__2);                   // 设置最优工作空间大小为 DLAQR5 和 DLAQR2 的最大值

/*        ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {                        // 如果是在查询工作空间大小
        work[1] = (doublereal) lwkopt;         // 将工作空间的第一个元素设置为推荐的最优工作空间大小
        return 0;                              // 返回
    }

/*        ==== DLAHQR/DLAQR0 crossover point ==== */
    # 调用外部函数 ilaenv_，获取返回值并赋给 nmin
    nmin = ilaenv_(&c__12, "DLAQR4", jbcmpz, n, ilo, ihi, lwork, (ftnlen)
        6, (ftnlen)2);
    # 将 nmin 与 11 比较，取较大值，更新 nmin 的值
    nmin = max(11,nmin);
/*        ==== Nibble crossover point ==== */

/* 获取一个用于选择阈值的整数值，该阈值决定了是否执行操作 */
nibble = ilaenv_(&c__14, "DLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
/* 确保阈值非负 */
nibble = max(0,nibble);

/*
      ==== Accumulate reflections during ttswp?  Use block
      .    2-by-2 structure during matrix-matrix multiply? ====
*/

/* 获取一个整数值，该值指示是否在ttswp过程中积累反射，并在矩阵乘法中使用2×2块结构 */
kacc22 = ilaenv_(&c__16, "DLAQR4", jbcmpz, n, ilo, ihi, lwork, (
    ftnlen)6, (ftnlen)2);
/* 确保阈值非负，并不超过2 */
kacc22 = max(0,kacc22);
kacc22 = min(2,kacc22);

/*
      ==== NWMAX = the largest possible deflation window for
      .    which there is sufficient workspace. ====

   Computing MIN
*/

/* 计算可能的最大缩减窗口大小，其不超过所提供的工作空间的一半 */
i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
nwmax = min(i__1,i__2);
nw = nwmax;

/*
      ==== NSMAX = the Largest number of simultaneous shifts
      .    for which there is sufficient workspace. ====

   Computing MIN
*/

/* 计算同时可用的最大移位数，以保证不超过所提供的工作空间的1/3 */
i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
nsmax = min(i__1,i__2);
nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

/* 定义一个从新缩减开始的迭代计数 */
ndfl = 1;

/*
      ==== ITMAX = iteration limit ====

   Computing MAX
*/

/* 计算迭代次数上限，以保证其不低于一个固定值与当前活跃块的大小乘积的30倍 */
i__1 = 10, i__2 = *ihi - *ilo + 1;
itmax = max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

/* 确定当前活跃块的最后一行和最后一列 */
kbot = *ihi;

/*        ==== Main Loop ==== */

/* 主循环 */
i__1 = itmax;
for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

/* 当 KBOT 小于 ILO 时跳出循环 */
if (kbot < *ilo) {
    goto L90;
}

/*           ==== Locate active block ==== */

/* 定位当前活跃块 */
i__2 = *ilo + 1;
for (k = kbot; k >= i__2; --k) {
if (h__[k + (k - 1) * h_dim1] == 0.) {
    goto L20;
}
/* L10: */
}
k = *ilo;
L20:
ktop = k;

/*
     ==== Select deflation window size:
     .    Typical Case:
     .      If possible and advisable, nibble the entire
     .      active block.  If not, use size MIN(NWR,NWMAX)
     .      or MIN(NWR+1,NWMAX) depending upon which has
     .      the smaller corresponding subdiagonal entry
     .      (a heuristic).
     .
     .    Exceptional Case:
     .      If there have been no deflations in KEXNW or
     .      more iterations, then vary the deflation window
     .      size.   At first, because, larger windows are,
     .      in general, more powerful than smaller ones,
     .      rapidly increase the window to the maximum possible.
     .      Then, gradually reduce the window size. ====
*/

/* 确定缩减窗口的大小 */
nh = kbot - ktop + 1;
/* 确定缩减窗口的上限，不超过预设的最大值 */
nwupbd = min(nh,nwmax);
if (ndfl < 5) {
nw = min(nwupbd,nwr);
} else {
/* Computing MIN */
/* 计算最小值 */
        i__2 = nwupbd, i__3 = nw << 1;
        nw = min(i__2,i__3);
/* 设置 nw 为 nwupbd 和 2*nw 中的较小值 */

        }
/* 结束 if 语句块 */

        if (nw < nwmax) {
/* 如果 nw 小于 nwmax，则执行以下代码块 */
        if (nw >= nh - 1) {
/* 如果 nw 大于等于 nh - 1，则执行以下代码块 */
            nw = nh;
/* 将 nw 设置为 nh */
        } else {
/* 否则执行以下代码块 */
            kwtop = kbot - nw + 1;
/* 设置 kwtop 为 kbot - nw + 1 */
            if ((d__1 = h__[kwtop + (kwtop - 1) * h_dim1], abs(d__1))
                > (d__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1],
                abs(d__2))) {
/* 如果 h 中指定位置的绝对值大于另一个位置的绝对值 */
            ++nw;
/* 增加 nw 的值 */
            }
        }
        }

        if (ndfl < 5) {
/* 如果 ndfl 小于 5 */
        ndec = -1;
/* ndec 设置为 -1 */
        } else if (ndec >= 0 || nw >= nwupbd) {
/* 或者如果 ndec 大于等于 0 或者 nw 大于等于 nwupbd */
        ++ndec;
/* 增加 ndec */
        if (nw - ndec < 2) {
/* 如果 nw - ndec 小于 2 */
            ndec = 0;
/* ndec 设置为 0 */
        }
        nw -= ndec;
/* 减去 ndec */
        }

/*
             ==== Aggressive early deflation:
             .    split workspace under the subdiagonal into
             .      - an nw-by-nw work array V in the lower
             .        left-hand-corner,
             .      - an NW-by-at-least-NW-but-more-is-better
             .        (NW-by-NHO) horizontal work array along
             .        the bottom edge,
             .      - an at-least-NW-but-more-is-better (NHV-by-NW)
             .        vertical work array along the left-hand-edge.
             .        ====
*/
/* 侵略性早期缩小：将次对角线下的工作空间分割为几个部分 */

        kv = *n - nw + 1;
/* kv 设置为 n - nw + 1 */
        kt = nw + 1;
/* kt 设置为 nw + 1 */
        nho = *n - nw - 1 - kt + 1;
/* nho 设置为 n - nw - 1 - kt + 1 */
        kwv = nw + 2;
/* kwv 设置为 nw + 2 */
        nve = *n - nw - kwv + 1;
/* nve 设置为 n - nw - kwv + 1 */

/*           ==== Aggressive early deflation ==== */
/* 侵略性早期缩小 */

        dlaqr2_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh,
            iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
             &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */
/* 调整 KBOT 以考虑新的缩小 */

        kbot -= ld;
/* 减去 ld */

/*           ==== KS points to the shifts. ==== */
/* KS 指向移位 */

/*
             ==== Skip an expensive QR sweep if there is a (partly
             .    heuristic) reason to expect that many eigenvalues
             .    will deflate without it.  Here, the QR sweep is
             .    skipped if many eigenvalues have just been deflated
             .    or if the remaining active block is small.
*/
/* 如果有部分启发性的理由表明许多特征值将在没有它的情况下被缩小，则跳过昂贵的 QR 扫描 */

        if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > min(
            nmin,nwmax)) {

/*
                ==== NS = nominal number of simultaneous shifts.
                .    This may be lowered (slightly) if DLAQR2
                .    did not provide that many shifts. ====

   Computing MIN
   Computing MAX
*/
/* NS = 预期的同时移位数目。如果 DLAQR2 没有提供那么多的移位，则可能会稍微降低 */

        i__4 = 2, i__5 = kbot - ktop;
        i__2 = min(nsmax,nsr), i__3 = max(i__4,i__5);
        ns = min(i__2,i__3);
/* 设置 ns 为 nsmax 和 max(2, kbot - ktop) 中的较小值 */

        ns -= ns % 2;
/* 将 ns 调整为偶数 */

/*
                ==== If there have been no deflations
                .    in a multiple of KEXSH iterations,
                .    then try exceptional shifts.
                .    Otherwise use shifts provided by
                .    DLAQR2 above or from the eigenvalues
                .    of a trailing principal submatrix. ====
*/
/* 如果在 KEXSH 的多个迭代中没有缩小，则尝试特殊移位。否则使用 DLAQR2 提供的移位或来自尾部主要子矩阵的特征值 */
        if (ndfl % 6 == 0) {
            ks = kbot - ns + 1;
            // 计算 MAX
            i__3 = ks + 1, i__4 = ktop + 2;
            i__2 = max(i__3,i__4);
            // 循环处理特定范围内的索引
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
                // 计算 ss
                ss = (d__1 = h__[i__ + (i__ - 1) * h_dim1], abs(d__1))
                     + (d__2 = h__[i__ - 1 + (i__ - 2) * h_dim1],
                    abs(d__2));
                aa = ss * .75 + h__[i__ + i__ * h_dim1];
                bb = ss;
                cc = ss * -.4375;
                dd = aa;
                // 调用 dlanv2 处理一对特征值
                dlanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
                    , &wr[i__], &wi[i__], &cs, &sn);
                // 循环标签
                // L30: 
            }
            // 处理特殊情况
            if (ks == ktop) {
                wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
                wi[ks + 1] = 0.;
                wr[ks] = wr[ks + 1];
                wi[ks] = wi[ks + 1];
            }
        } else {

/*
                   ==== Got NS/2 or fewer shifts? Use DLAHQR
                   .    on a trailing principal submatrix to
                   .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                   .    there is enough space below the subdiagonal
                   .    to fit an NS-by-NS scratch array.) ====
*/

            if (kbot - ks + 1 <= ns / 2) {
                ks = kbot - ns + 1;
                kt = *n - ns + 1;
                // 复制矩阵片段
                dlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
                    h__[kt + h_dim1], ldh);
                // 调用 dlahqr 处理特征值问题
                dlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[kt
                    + h_dim1], ldh, &wr[ks], &wi[ks], &c__1, &
                    c__1, zdum, &c__1, &inf);
                ks += inf;

/*
                      ==== In case of a rare QR failure use
                      .    eigenvalues of the trailing 2-by-2
                      .    principal submatrix.  ====
*/

                if (ks >= kbot) {
                    aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
                    cc = h__[kbot + (kbot - 1) * h_dim1];
                    bb = h__[kbot - 1 + kbot * h_dim1];
                    dd = h__[kbot + kbot * h_dim1];
                    // 调用 dlanv2 处理一对特征值
                    dlanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
                        kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
                        ;
                    ks = kbot - 1;
                }
            }

            // 处理特殊情况
            if (kbot - ks + 1 > ns) {

/*
                      ==== Sort the shifts (Helps a little)
                      .    Bubble sort keeps complex conjugate
                      .    pairs together. ====
*/
/*
   初始化变量 `sorted` 为假
   设置循环变量 `i__2` 为 `ks + 1`
   从 `kbot` 循环到 `i__2`
*/
            sorted = FALSE_;
            i__2 = ks + 1;
            for (k = kbot; k >= i__2; --k) {
                // 如果已排序，跳转到标签 L60
                if (sorted) {
                goto L60;
                }
                // 设置 `sorted` 为真
                sorted = TRUE_;
                // 设置循环变量 `i__3` 为 `k - 1`
                i__3 = k - 1;
                // 从 `ks` 到 `i__3` 循环
                for (i__ = ks; i__ <= i__3; ++i__) {
                    // 如果第 `i__` 和第 `i__ + 1` 个元素的绝对值之和
                    // 小于第 `i__ + 1` 和第 `i__ + 2` 个元素的绝对值之和
                    if ((d__1 = wr[i__], abs(d__1)) + (d__2 = wi[
                        i__], abs(d__2)) < (d__3 = wr[i__ + 1]
                        , abs(d__3)) + (d__4 = wi[i__ + 1],
                        abs(d__4))) {
                        // 设置 `sorted` 为假
                        sorted = FALSE_;

                        // 交换 `wr[i__]` 和 `wr[i__ + 1]` 的值
                        swap = wr[i__];
                        wr[i__] = wr[i__ + 1];
                        wr[i__ + 1] = swap;

                        // 交换 `wi[i__]` 和 `wi[i__ + 1]` 的值
                        swap = wi[i__];
                        wi[i__] = wi[i__ + 1];
                        wi[i__ + 1] = swap;
                    }
/* L40: */
                }
/* L50: */
            }
// 标签 L60
L60:
            ;
            }

/*
   对于 `i__` 从 `kbot` 到 `ks + 2` 每隔两个元素进行循环
   如果 `wi[i__]` 不等于 `-wi[i__ - 1]`
*/
            i__2 = ks + 2;
            for (i__ = kbot; i__ >= i__2; i__ += -2) {
            if (wi[i__] != -wi[i__ - 1]) {

                // 交换 `wr[i__]` 和 `wr[i__ - 1]` 的值
                swap = wr[i__];
                wr[i__] = wr[i__ - 1];
                wr[i__ - 1] = wr[i__ - 2];
                wr[i__ - 2] = swap;

                // 交换 `wi[i__]` 和 `wi[i__ - 1]` 的值
                swap = wi[i__];
                wi[i__] = wi[i__ - 1];
                wi[i__ - 1] = wi[i__ - 2];
                wi[i__ - 2] = swap;
            }
/* L70: */
            }
        }

/*
   如果 `kbot - ks + 1` 等于 2
   如果 `wi[kbot]` 等于 0
   如果 `wr[kbot] - h__[kbot + kbot * h_dim1]` 的绝对值小于
   `wr[kbot - 1] - h__[kbot + kbot * h_dim1]` 的绝对值
*/
        if (kbot - ks + 1 == 2) {
            if (wi[kbot] == 0.) {
            if ((d__1 = wr[kbot] - h__[kbot + kbot * h_dim1], abs(
                d__1)) < (d__2 = wr[kbot - 1] - h__[kbot +
                kbot * h_dim1], abs(d__2))) {
                // 将 `wr[kbot - 1]` 设置为 `wr[kbot]`
                wr[kbot - 1] = wr[kbot];
            } else {
                // 将 `wr[kbot]` 设置为 `wr[kbot - 1]`
                wr[kbot] = wr[kbot - 1];
            }
            }
        }

/*
   设置 `ns` 为 `ns` 和 `kbot - ks + 1` 的最小值
   `ns` 减去 `ns` 除以 2 的余数
   设置 `ks` 为 `kbot - ns + 1`
*/
        i__2 = ns, i__3 = kbot - ks + 1;
        ns = min(i__2,i__3);
        ns -= ns % 2;
        ks = kbot - ns + 1;
/*
                ==== Small-bulge multi-shift QR sweep:
                .    split workspace under the subdiagonal into
                .    - a KDU-by-KDU work array U in the lower
                .      left-hand-corner,
                .    - a KDU-by-at-least-KDU-but-more-is-better
                .      (KDU-by-NHo) horizontal work array WH along
                .      the bottom edge,
                .    - and an at-least-KDU-but-more-is-better-by-KDU
                .      (NVE-by-KDU) vertical work array WV along
                .      the left-hand-edge. ====
*/

        kdu = ns * 3 - 3;
        // 计算 KDU 的大小
        ku = *n - kdu + 1;
        // 计算 KU 的起始索引
        kwh = kdu + 1;
        // 计算 KWH 的大小
        nho = *n - kdu - 3 - (kdu + 1) + 1;
        // 计算 NHO 的大小
        kwv = kdu + 4;
        // 计算 KWV 的大小
        nve = *n - kdu - kwv + 1;
        // 计算 NVE 的大小

/*              ==== Small-bulge multi-shift QR sweep ==== */

        dlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks],
            &wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
            z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1],
            ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku +
            kwh * h_dim1], ldh);
        // 调用 dlaqr5_ 函数进行 QR 算法迭代

/*           ==== Note progress (or the lack of it). ==== */

        if (ld > 0) {
        ndfl = 1;
        // 如果 ld 大于 0，将 ndfl 置为 1
        } else {
        ++ndfl;
        // 否则递增 ndfl
        }

/*
             ==== End of main loop ====
   L80:
*/
    }

/*
          ==== Iteration limit exceeded.  Set INFO to show where
          .    the problem occurred and exit. ====
*/

    *info = kbot;
    // 设置 INFO 以指示问题出现的位置并退出
L90:
    ;
    }

/*     ==== Return the optimal value of LWORK. ==== */

    work[1] = (doublereal) lwkopt;
    // 返回最优的 LWORK 值

/*     ==== End of DLAQR4 ==== */

    return 0;
} /* dlaqr4_ */

/* Subroutine */ int dlaqr5_(logical *wantt, logical *wantz, integer *kacc22,
    integer *n, integer *ktop, integer *kbot, integer *nshfts, doublereal
    *sr, doublereal *si, doublereal *h__, integer *ldh, integer *iloz,
    integer *ihiz, doublereal *z__, integer *ldz, doublereal *v, integer *
    ldv, doublereal *u, integer *ldu, integer *nv, doublereal *wv,
    integer *ldwv, integer *nh, doublereal *wh, integer *ldwh)
{
    /* System generated locals */
    integer h_dim1, h_offset, u_dim1, u_offset, v_dim1, v_offset, wh_dim1,
        wh_offset, wv_dim1, wv_offset, z_dim1, z_offset, i__1, i__2, i__3,
         i__4, i__5, i__6, i__7;
    doublereal d__1, d__2, d__3, d__4, d__5;

    /* Local variables */
    static integer i__, j, k, m, i2, j2, i4, j4, k1;
    static doublereal h11, h12, h21, h22;
    static integer m22, ns, nu;
    static doublereal vt[3], scl;
    static integer kdu, kms;
    static doublereal ulp;
    static integer knz, kzs;
    static doublereal tst1, tst2, beta;
    static logical blk22, bmp22;
    static integer mend, jcol, jlen, jbot, mbot;
    static doublereal swap;
    static integer jtop, jrow, mtop;
    static doublereal alpha;
    static logical accum;
    # 外部声明一个双精度矩阵乘法子程序 dgemm_
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);

    # 静态声明几个整型变量和一个双精度浮点数变量
    static integer ndcol, incol, krcol, nbmps;

    # 外部声明一个双精度三角矩阵乘法子程序 dtrmm_
    extern /* Subroutine */ int dtrmm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);

    # 外部声明一个计算特征值问题的子程序 dlaqr1_
    extern /* Subroutine */ int dlaqr1_(
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);

    # 外部声明一个调整双精度数值的子程序 dlabad_
    extern /* Subroutine */ int dlabad_(doublereal *,
        doublereal *);

    # 外部声明一个生成一个 Householder 变换的子程序 dlarfg_
    extern /* Subroutine */ int dlarfg_(integer *, doublereal *, doublereal *,
         integer *, doublereal *);

    # 外部声明一个复制矩阵的子程序 dlacpy_
    extern /* Subroutine */ int dlacpy_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *);

    # 静态声明两个双精度浮点数变量
    static doublereal safmin;
    static doublereal safmax, refsum;

    # 静态声明一个整型变量和一个双精度浮点数变量
    static integer mstart;
    static doublereal smlnum;
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
*/

/* Parameter adjustments */
--sr;
--si;
h_dim1 = *ldh;
h_offset = 1 + h_dim1;
h__ -= h_offset;
z_dim1 = *ldz;
z_offset = 1 + z_dim1;
z__ -= z_offset;
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
v -= v_offset;
u_dim1 = *ldu;
u_offset = 1 + u_dim1;
u -= u_offset;
wv_dim1 = *ldwv;
wv_offset = 1 + wv_dim1;
wv -= wv_offset;
wh_dim1 = *ldwh;
wh_offset = 1 + wh_dim1;
wh -= wh_offset;

/* Function Body */
if (*nshfts < 2) {
return 0;
}

/*
   ==== If the active block is empty or 1-by-1, then there
   .    is nothing to do. ====
*/

if (*ktop >= *kbot) {
return 0;
}

/*
   ==== Shuffle shifts into pairs of real shifts and pairs
   .    of complex conjugate shifts assuming complex
   .    conjugate shifts are already adjacent to one
   .    another. ====
*/

i__1 = *nshfts - 2;
for (i__ = 1; i__ <= i__1; i__ += 2) {
if (si[i__] != -si[i__ + 1]) {

    swap = sr[i__];
    sr[i__] = sr[i__ + 1];
    sr[i__ + 1] = sr[i__ + 2];
    sr[i__ + 2] = swap;

    swap = si[i__];
    si[i__] = si[i__ + 1];
    si[i__ + 1] = si[i__ + 2];
    si[i__ + 2] = swap;
}
/* L10: */
}

/*
   ==== NSHFTS is supposed to be even, but if it is odd,
   .    then simply reduce it by one.  The shuffle above
   .    ensures that the dropped shift is real and that
   .    the remaining shifts are paired. ====
*/

ns = *nshfts - *nshfts % 2;

/*     ==== Machine constants for deflation ==== */

safmin = SAFEMINIMUM;
safmax = 1. / safmin;
dlabad_(&safmin, &safmax);
ulp = PRECISION;
smlnum = safmin * ((doublereal) (*n) / ulp);

/*
   ==== Use accumulated reflections to update far-from-diagonal
   .    entries ? ====
*/

accum = *kacc22 == 1 || *kacc22 == 2;

/*     ==== If so, exploit the 2-by-2 block structure? ==== */

blk22 = ns > 2 && *kacc22 == 2;

/*     ==== clear trash ==== */

if (*ktop + 2 <= *kbot) {
h__[*ktop + 2 + *ktop * h_dim1] = 0.;
}

/*     ==== NBMPS = number of 2-shift bulges in the chain ==== */

nbmps = ns / 2;

/*     ==== KDU = width of slab ==== */

kdu = nbmps * 6 - 3;

/*     ==== Create and chase chains of NBMPS bulges ==== */

i__1 = *kbot - 2;
i__2 = nbmps * 3 - 2;
for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 :
    incol <= i__1; incol += i__2) {
ndcol = incol + kdu;
if (accum) {
    dlaset_("ALL", &kdu, &kdu, &c_b29, &c_b15, &u[u_offset], ldu);
}


注释：


/*
    -- LAPACK辅助例程（版本3.2）--
    -- LAPACK是由田纳西大学提供的软件包 --
*/

/* 参数调整 */
--sr;             // 将指针 sr 前移一个位置
--si;             // 将指针 si 前移一个位置
h_dim1 = *ldh;    // 计算矩阵 h__ 的第一维大小
h_offset = 1 + h_dim1;  // 计算 h__ 在一维展开后的偏移量
h__ -= h_offset;   // 调整 h__ 指针，使其指向正确的起始位置
z_dim1 = *ldz;    // 计算矩阵 z__ 的第一维大小
z_offset = 1 + z_dim1;  // 计算 z__ 在一维展开后的偏移量
z__ -= z_offset;   // 调整 z__ 指针，使其指向正确的起始位置
v_dim1 = *ldv;    // 计算矩阵 v 的第一维大小
v_offset = 1 + v_dim1;  // 计算 v 在一维展开后的偏移量
v -= v_offset;     // 调整 v 指针，使其指向正确的起始位置
u_dim1 = *ldu;    // 计算矩阵 u 的第一维大小
u_offset = 1 + u_dim1;  // 计算 u 在一维展开后的偏移量
u -= u_offset;     // 调整 u 指针，使其指向正确的起始位置
wv_dim1 = *ldwv;  // 计算矩阵 wv 的第一维大小
wv_offset = 1 + wv_dim1;  // 计算 wv 在一维展开后的偏移量
wv -= wv_offset;   // 调整 wv 指针，使其指向正确的起始位置
wh_dim1 = *ldwh;  // 计算矩阵 wh 的第一维大小
wh_offset = 1 + wh_dim1;  // 计算 wh 在一维展开后的偏移量
wh -= wh_offset;   // 调整 wh 指针，使其指向正确的起始位置

/* 函数主体 */
if (*nshfts < 2) {   // 如果输入的 nshfts 小于 2，则直接返回
return 0;
}

/*
   ==== 如果活动块为空或为1×1，则无需操作 ====
*/

if (*ktop >= *kbot) {   // 如果活动块的顶部大于等于底部，则直接返回
return 0;
}

/*
   ==== 将移位调整为一对实移位和一对复共轭移位，假设复共轭移位已经相邻 ====
*/

i__1 = *nshfts - 2;
for (i__ = 1; i__ <= i__1; i__ += 2) {
if (si[i__] != -si[i__ + 1]) {   // 如果当前复部分移位不是共轭的

    swap = sr[i__];     // 交换实部分移位
    sr[i__] = sr[i__ + 1];
    sr[i__ + 1] = sr[i__ + 2];
    sr[i__ + 2] = swap;

    swap = si[i__];     // 交换虚部分移位
    si[i__] = si[i__ + 1];
    si[i__ + 1] = si[i__ + 2];
    si[i__ + 2] = swap;
}
/* L10: */
}

/*
   ==== 如果 nshfts 应该是偶数，但如果是奇数，
   .    则简单地减少一半。上面的循环保证删除的移位是实数，
   .    并且剩余的移位是成对的。 ====
*/

ns = *nshfts - *nshfts % 2;   // 计算修正后的移位数

/*     ==== 用于缩小的机器常数 ==== */

safmin = SAFEMINIMUM;    // 安全最小值
safmax = 1. / safmin;    // 安全最大值
dlabad_(&safmin, &safmax);   // 设置安全最小和最大值
ulp = PRECISION;   // 精度单位舍入值
smlnum = safmin * ((doublereal) (*n) / ulp);   // 计算小数值
/*
          ==== Near-the-diagonal bulge chase.  The following loop
          .    performs the near-the-diagonal part of a small bulge
          .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
          .    chunk extends from column INCOL to column NDCOL
          .    (including both column INCOL and column NDCOL). The
          .    following loop chases a 3*NBMPS column long chain of
          .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
          .    may be less than KTOP and and NDCOL may be greater than
          .    KBOT indicating phantom columns from which to chase
          .    bulges before they are actually introduced or to which
          .    to chase bulges beyond column KBOT.)  ====

   Computing MIN
*/
    i__4 = incol + nbmps * 3 - 3, i__5 = *kbot - 2;
    i__3 = min(i__4, i__5);
    for (krcol = incol; krcol <= i__3; ++krcol) {

/*
             ==== Bulges number MTOP to MBOT are active double implicit
             .    shift bulges.  There may or may not also be small
             .    2-by-2 bulge, if there is room.  The inactive bulges
             .    (if any) must wait until the active bulges have moved
             .    down the diagonal to make room.  The phantom matrix
             .    paradigm described above helps keep track.  ====

   Computing MAX
*/
        i__4 = 1, i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
        mtop = max(i__4, i__5);
/* Computing MIN */
        i__4 = nbmps, i__5 = (*kbot - krcol) / 3;
        mbot = min(i__4, i__5);
        m22 = mbot + 1;
        bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

/*
             ==== Generate reflections to chase the chain right
             .    one column.  (The minimum value of K is KTOP-1.) ====
*/

        i__4 = mbot;
        for (m = mtop; m <= i__4; ++m) {
            k = krcol + (m - 1) * 3;
            if (k == *ktop - 1) {
                // Apply single shift QR step
                dlaqr1_(&c__3, &h__[*ktop + *ktop * h_dim1], ldh, &sr[(m << 1) - 1], &si[(m << 1) - 1], &sr[m * 2], &si[m * 2], &v[m * v_dim1 + 1]);
                alpha = v[m * v_dim1 + 1];
                dlarfg_(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);
            } else {
                beta = h__[k + 1 + k * h_dim1];
                v[m * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
                v[m * v_dim1 + 3] = h__[k + 3 + k * h_dim1];
                dlarfg_(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);

/*
                   ==== A Bulge may collapse because of vigilant
                   .    deflation or destructive underflow.  In the
                   .    underflow case, try the two-small-subdiagonals
                   .    trick to try to reinflate the bulge.  ====
*/

                if (h__[k + 3 + k * h_dim1] != 0. || h__[k + 3 + (k + 1) * h_dim1] != 0. || h__[k + 3 + (k + 2) * h_dim1] == 0.) {
                    // Attempt to reinflate the bulge using two-small-subdiagonals trick

                    // Handle the situation where a bulge collapses due to deflation or underflow
                    // Try the two-small-subdiagonals trick to reinflate the bulge
                    // Check conditions to determine if reinflation is possible
                    // Specific actions depend on the conditions of subdiagonals
                    // Perform necessary steps to potentially reinflate the bulge
/*                    ==== Typical case: not collapsed (yet). ==== */

                h__[k + 1 + k * h_dim1] = beta;  // 设置 h__(k+1,k) 为 beta
                h__[k + 2 + k * h_dim1] = 0.;    // 设置 h__(k+2,k) 为 0
                h__[k + 3 + k * h_dim1] = 0.;    // 设置 h__(k+3,k) 为 0
            } else {

/*
                      ==== Atypical case: collapsed.  Attempt to
                      .    reintroduce ignoring H(K+1,K) and H(K+2,K).
                      .    If the fill resulting from the new
                      .    reflector is too large, then abandon it.
                      .    Otherwise, use the new one. ====
*/

                // 调用子程序 dlaqr1_，尝试通过新的反射器重新引入，忽略 H(K+1,K) 和 H(K+2,K)
                // 如果由新反射器引起的填充过大，则放弃
                // 否则使用新的反射器
                dlaqr1_(&c__3, &h__[k + 1 + (k + 1) * h_dim1], ldh, &
                    sr[(m << 1) - 1], &si[(m << 1) - 1], &sr[m *
                    2], &si[m * 2], vt);
                alpha = vt[0];
                // 调用子程序 dlarfg_
                dlarfg_(&c__3, &alpha, &vt[1], &c__1, vt);
                refsum = vt[0] * (h__[k + 1 + k * h_dim1] + vt[1] *
                    h__[k + 2 + k * h_dim1]);

                if ((d__1 = h__[k + 2 + k * h_dim1] - refsum * vt[1],
                    abs(d__1)) + (d__2 = refsum * vt[2], abs(d__2)
                    ) > ulp * ((d__3 = h__[k + k * h_dim1], abs(
                    d__3)) + (d__4 = h__[k + 1 + (k + 1) * h_dim1]
                    , abs(d__4)) + (d__5 = h__[k + 2 + (k + 2) *
                    h_dim1], abs(d__5)))) {

/*
                         ==== Starting a new bulge here would
                         .    create non-negligible fill.  Use
                         .    the old one with trepidation. ====
*/

                    // 如果从这里开始新的 bulge 会导致非常大的填充，使用旧的 bulge
                    h__[k + 1 + k * h_dim1] = beta;
                    h__[k + 2 + k * h_dim1] = 0.;
                    h__[k + 3 + k * h_dim1] = 0.;
                } else {

/*
                         ==== Stating a new bulge here would
                         .    create only negligible fill.
                         .    Replace the old reflector with
                         .    the new one. ====
*/

                    // 如果从这里开始新的 bulge 只会导致微不足道的填充，使用新的反射器替换旧的
                    h__[k + 1 + k * h_dim1] -= refsum;
                    h__[k + 2 + k * h_dim1] = 0.;
                    h__[k + 3 + k * h_dim1] = 0.;
                    v[m * v_dim1 + 1] = vt[0];
                    v[m * v_dim1 + 2] = vt[1];
                    v[m * v_dim1 + 3] = vt[2];
                }
            }
        }
/* L20: */
        }
/*           ==== Generate a 2-by-2 reflection, if needed. ==== */

/* 计算反射矩阵的列索引 */
k = krcol + (m22 - 1) * 3;
/* 如果需要生成2×2的反射矩阵 */
if (bmp22) {
    /* 检查是否需要在顶部执行反射 */
    if (k == *ktop - 1) {
        /* 调用 LAPACK 子程序 dlaqr1，生成2×2的反射矩阵 */
        dlaqr1_(&c__2, &h__[k + 1 + (k + 1) * h_dim1], ldh, &sr[(m22 << 1) - 1], &si[(m22 << 1) - 1], &sr[m22 * 2], &si[m22 * 2], &v[m22 * v_dim1 + 1]);
        /* 提取反射矩阵的第一个元素 */
        beta = v[m22 * v_dim1 + 1];
        /* 调用 LAPACK 子程序 dlarfg，生成反射向量 */
        dlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
    } else {
        /* 提取矩阵中的 beta 值 */
        beta = h__[k + 1 + k * h_dim1];
        /* 保存反射向量的第二个元素 */
        v[m22 * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
        /* 调用 LAPACK 子程序 dlarfg，生成反射向量 */
        dlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
        /* 更新矩阵中的元素 */
        h__[k + 1 + k * h_dim1] = beta;
        h__[k + 2 + k * h_dim1] = 0.;
    }
}

/*           ==== Multiply H by reflections from the left ==== */

/* 如果需要累积结果 */
if (accum) {
    /* 设置 jbot 为 ndcol 和 *kbot 的较小值 */
    jbot = min(ndcol,*kbot);
} else if (*wantt) {
    /* 如果需要整个 H 矩阵的转置 */
    jbot = *n;
} else {
    /* 否则设置 jbot 为 *kbot */
    jbot = *kbot;
}
/* 循环遍历列 */
i__4 = jbot;
for (j = max(*ktop,krcol); j <= i__4; ++j) {
    /* 计算 m 的上限 */
    /* Computing MIN */
    i__5 = mbot, i__6 = (j - krcol + 2) / 3;
    mend = min(i__5,i__6);
    /* 循环遍历每个 m */
    i__5 = mend;
    for (m = mtop; m <= i__5; ++m) {
        /* 计算列索引 k */
        k = krcol + (m - 1) * 3;
        /* 计算反射的和 */
        refsum = v[m * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] + v[m * v_dim1 + 2] * h__[k + 2 + j * h_dim1] + v[m * v_dim1 + 3] * h__[k + 3 + j * h_dim1]);
        /* 更新 H 矩阵的元素 */
        h__[k + 1 + j * h_dim1] -= refsum;
        h__[k + 2 + j * h_dim1] -= refsum * v[m * v_dim1 + 2];
        h__[k + 3 + j * h_dim1] -= refsum * v[m * v_dim1 + 3];
    }
}

/* 如果存在 bmp22，则继续处理 */
if (bmp22) {
    /* 计算列索引 k */
    k = krcol + (m22 - 1) * 3;
    /* 计算 j 的下限 */
    /* Computing MAX */
    i__4 = k + 1;
    i__5 = jbot;
    /* 循环遍历 j */
    for (j = max(i__4,*ktop); j <= i__5; ++j) {
        /* 计算反射的和 */
        refsum = v[m22 * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] + v[m22 * v_dim1 + 2] * h__[k + 2 + j * h_dim1]);
        /* 更新 H 矩阵的元素 */
        h__[k + 1 + j * h_dim1] -= refsum;
        h__[k + 2 + j * h_dim1] -= refsum * v[m22 * v_dim1 + 2];
    }
}

/*
             ==== Multiply H by reflections from the right.
             .    Delay filling in the last row until the
             .    vigilant deflation check is complete. ====
*/

/* 如果存在累积结果 */
if (accum) {
    /* 设置 jtop 为 *ktop 和 incol 的较大值 */
    jtop = max(*ktop,incol);
} else if (*wantt) {
    /* 如果需要整个 H 矩阵的转置 */
    jtop = 1;
} else {
    /* 否则设置 jtop 为 *ktop */
    jtop = *ktop;
}
/* 循环遍历 m */
i__5 = mbot;
for (m = mtop; m <= i__5; ++m) {
    /* 检查是否反射向量不为零 */
    if (v[m * v_dim1 + 1] != 0.) {
        /* 计算列索引 k */
        k = krcol + (m - 1) * 3;
/* Computing MIN */
        i__6 = *kbot, i__7 = k + 3;
        /* 取两个值的最小值 */
        i__4 = min(i__6,i__7);
        /* 循环，j 从 jtop 到 i__4 */
        for (j = jtop; j <= i__4; ++j) {
            /* 计算反射和 */
            refsum = v[m * v_dim1 + 1] * (h__[j + (k + 1) *
                h_dim1] + v[m * v_dim1 + 2] * h__[j + (k + 2)
                * h_dim1] + v[m * v_dim1 + 3] * h__[j + (k +
                3) * h_dim1]);
            /* 更新 h__ 的值 */
            h__[j + (k + 1) * h_dim1] -= refsum;
            h__[j + (k + 2) * h_dim1] -= refsum * v[m * v_dim1 +
                2];
            h__[j + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 +
                3];
/* L60: */
        }

        if (accum) {

/*
                  ==== Accumulate U. (If necessary, update Z later
                  .    with an efficient matrix-matrix
                  .    multiply.) ====
*/

        /* 计算 kms 的值 */
        kms = k - incol;
/* Computing MAX */
        /* 取两个值的最大值 */
        i__4 = 1, i__6 = *ktop - incol;
        i__7 = kdu;
        /* 循环，j 从 max(i__4,i__6) 到 i__7 */
        for (j = max(i__4,i__6); j <= i__7; ++j) {
            /* 计算反射和 */
            refsum = v[m * v_dim1 + 1] * (u[j + (kms + 1) *
                u_dim1] + v[m * v_dim1 + 2] * u[j + (kms
                + 2) * u_dim1] + v[m * v_dim1 + 3] * u[j
                + (kms + 3) * u_dim1]);
            /* 更新 u 的值 */
            u[j + (kms + 1) * u_dim1] -= refsum;
            u[j + (kms + 2) * u_dim1] -= refsum * v[m *
                v_dim1 + 2];
            u[j + (kms + 3) * u_dim1] -= refsum * v[m *
                v_dim1 + 3];
/* L70: */
        }
        } else if (*wantz) {

/*
                  ==== U is not accumulated, so update Z
                  .    now by multiplying by reflections
                  .    from the right. ====
*/

        i__7 = *ihiz;
        /* 循环，j 从 *iloz 到 i__7 */
        for (j = *iloz; j <= i__7; ++j) {
            /* 计算反射和 */
            refsum = v[m * v_dim1 + 1] * (z__[j + (k + 1) *
                z_dim1] + v[m * v_dim1 + 2] * z__[j + (k
                + 2) * z_dim1] + v[m * v_dim1 + 3] * z__[
                j + (k + 3) * z_dim1]);
            /* 更新 z__ 的值 */
            z__[j + (k + 1) * z_dim1] -= refsum;
            z__[j + (k + 2) * z_dim1] -= refsum * v[m *
                v_dim1 + 2];
            z__[j + (k + 3) * z_dim1] -= refsum * v[m *
                v_dim1 + 3];
/* L80: */
        }
        }
    }
/* L90: */
    }

/*           ==== Special case: 2-by-2 reflection (if needed) ==== */

    /* 计算 k 的值 */
    k = krcol + (m22 - 1) * 3;
    /* 如果 bmp22 为真且 v[m22 * v_dim1 + 1] 不等于 0. */
    if (bmp22 && v[m22 * v_dim1 + 1] != 0.) {
/* Computing MIN */
    i__7 = *kbot, i__4 = k + 3;
    /* 取两个值的最小值 */
    i__5 = min(i__7,i__4);
    /* 循环，j 从 jtop 到 i__5 */
    for (j = jtop; j <= i__5; ++j) {
        /* 计算反射和 */
        refsum = v[m22 * v_dim1 + 1] * (h__[j + (k + 1) * h_dim1]
            + v[m22 * v_dim1 + 2] * h__[j + (k + 2) * h_dim1])
            ;
        /* 更新 h__ 的值 */
        h__[j + (k + 1) * h_dim1] -= refsum;
        h__[j + (k + 2) * h_dim1] -= refsum * v[m22 * v_dim1 + 2];
/* L100: */
    }

    if (accum) {
        /* 计算 kms 的值 */
        kms = k - incol;
/* Computing MAX */
/* 计算 MAX */
i__5 = 1, i__7 = *ktop - incol;
i__4 = kdu;
for (j = max(i__5,i__7); j <= i__4; ++j) {
/* 循环遍历 j，从 max(i__5, i__7) 开始直到 i__4 */
refsum = v[m22 * v_dim1 + 1] * (u[j + (kms + 1) * u_dim1] + v[m22 * v_dim1 + 2] * u[j + (kms + 2) * u_dim1]);
/* 计算 refsum 的值 */
u[j + (kms + 1) * u_dim1] -= refsum;
/* 更新 u[j + (kms + 1) * u_dim1] 的值 */
u[j + (kms + 2) * u_dim1] -= refsum * v[m22 * v_dim1 + 2];
/* 更新 u[j + (kms + 2) * u_dim1] 的值 */
/* L110: */
/* 循环的标签 */
}
} else if (*wantz) {
/* 否则如果 *wantz 为真 */
i__4 = *ihiz;
for (j = *iloz; j <= i__4; ++j) {
/* 循环遍历 j，从 *iloz 到 *ihiz */
refsum = v[m22 * v_dim1 + 1] * (z__[j + (k + 1) * z_dim1] + v[m22 * v_dim1 + 2] * z__[j + (k + 2) * z_dim1]);
/* 计算 refsum 的值 */
z__[j + (k + 1) * z_dim1] -= refsum;
/* 更新 z__[j + (k + 1) * z_dim1] 的值 */
z__[j + (k + 2) * z_dim1] -= refsum * v[m22 * v_dim1 + 2];
/* 更新 z__[j + (k + 2) * z_dim1] 的值 */
/* L120: */
/* 循环的标签 */
}
}

/* ==== Vigilant deflation check ==== */
/* 严格的缩小检查 */

mstart = mtop;
/* 设置 mstart 为 mtop */
if (krcol + (mstart - 1) * 3 < *ktop) {
/* 如果 krcol + (mstart - 1) * 3 小于 *ktop */
++mstart;
/* 则增加 mstart */
}
mend = mbot;
/* 设置 mend 为 mbot */
if (bmp22) {
/* 如果 bmp22 为真 */
++mend;
/* 则增加 mend */
}
if (krcol == *kbot - 2) {
/* 如果 krcol 等于 *kbot - 2 */
++mend;
/* 则增加 mend */
}
i__4 = mend;
/* 设置循环的上界为 mend */
for (m = mstart; m <= i__4; ++m) {
/* 循环遍历 m，从 mstart 到 i__4 */
/* Computing MIN */
/* 计算最小值 */
i__5 = *kbot - 1, i__7 = krcol + (m - 1) * 3;
k = min(i__5,i__7);
/* 设置 k 为 i__5 和 i__7 的最小值 */

/*
        ==== The following convergence test requires that
        .    the tradition small-compared-to-nearby-diagonals
        .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
        .    criteria both be satisfied.  The latter improves
        .    accuracy in some examples. Falling back on an
        .    alternate convergence criterion when TST1 or TST2
        .    is zero (as done here) is traditional but probably
        .    unnecessary. ====
*/
/*
        以下收敛测试要求传统的与附近对角线相比较小的标准和 Ahues & Tisseur (LAWN 122, 1997) 标准都得到满足。后者在某些示例中提高了精度。在 TST1 或 TST2 为零时（如此处所做），退回到备用的收敛标准，虽然传统但可能是不必要的。
*/

if (h__[k + 1 + k * h_dim1] != 0.) {
/* 如果 h__[k + 1 + k * h_dim1] 不等于 0 */
tst1 = (d__1 = h__[k + k * h_dim1], abs(d__1)) + (d__2 =
    h__[k + 1 + (k + 1) * h_dim1], abs(d__2));
/* 计算 tst1 的值 */
if (tst1 == 0.) {
/* 如果 tst1 等于 0 */
if (k >= *ktop + 1) {
/* 如果 k 大于等于 *ktop + 1 */
tst1 += (d__1 = h__[k + (k - 1) * h_dim1], abs(
    d__1));
}
if (k >= *ktop + 2) {
/* 如果 k 大于等于 *ktop + 2 */
tst1 += (d__1 = h__[k + (k - 2) * h_dim1], abs(
    d__1));
}
if (k >= *ktop + 3) {
/* 如果 k 大于等于 *ktop + 3 */
tst1 += (d__1 = h__[k + (k - 3) * h_dim1], abs(
    d__1));
}
if (k <= *kbot - 2) {
/* 如果 k 小于等于 *kbot - 2 */
tst1 += (d__1 = h__[k + 2 + (k + 1) * h_dim1],
    abs(d__1));
}
if (k <= *kbot - 3) {
/* 如果 k 小于等于 *kbot - 3 */
tst1 += (d__1 = h__[k + 3 + (k + 1) * h_dim1],
    abs(d__1));
}
if (k <= *kbot - 4) {
/* 如果 k 小于等于 *kbot - 4 */
tst1 += (d__1 = h__[k + 4 + (k + 1) * h_dim1],
    abs(d__1));
}
}
}
/* Computing MAX */
/* 计算最大值 */
d__2 = smlnum, d__3 = ulp * tst1;
if ((d__1 = h__[k + 1 + k * h_dim1], abs(d__1)) <= max(
    d__2,d__3)) {
    /* 如果 h[k+1+k*h_dim1] 的绝对值小于等于 smlnum 和 ulp*tst1 的最大值，则执行以下操作 */
    /* Computing MAX */
    /* 计算最大值 */
    d__3 = (d__1 = h__[k + 1 + k * h_dim1], abs(d__1)),
        d__4 = (d__2 = h__[k + (k + 1) * h_dim1], abs(
        d__2));
    h12 = max(d__3,d__4);
    /* 计算 h12 为 h[k+1+k*h_dim1] 和 h[k+(k+1)*h_dim1] 的绝对值的最大值 */
    /* Computing MIN */
    /* 计算最小值 */
    d__3 = (d__1 = h__[k + 1 + k * h_dim1], abs(d__1)),
        d__4 = (d__2 = h__[k + (k + 1) * h_dim1], abs(
        d__2));
    h21 = min(d__3,d__4);
    /* 计算 h21 为 h[k+1+k*h_dim1] 和 h[k+(k+1)*h_dim1] 的绝对值的最小值 */
    /* Computing MAX */
    /* 计算最大值 */
    d__3 = (d__1 = h__[k + 1 + (k + 1) * h_dim1], abs(
        d__1)), d__4 = (d__2 = h__[k + k * h_dim1] -
        h__[k + 1 + (k + 1) * h_dim1], abs(d__2));
    h11 = max(d__3,d__4);
    /* 计算 h11 为 h[k+1+(k+1)*h_dim1] 和 h[k+k*h_dim1]-h[k+1+(k+1)*h_dim1] 的绝对值的最大值 */
    /* Computing MIN */
    /* 计算最小值 */
    d__3 = (d__1 = h__[k + 1 + (k + 1) * h_dim1], abs(
        d__1)), d__4 = (d__2 = h__[k + k * h_dim1] -
        h__[k + 1 + (k + 1) * h_dim1], abs(d__2));
    h22 = min(d__3,d__4);
    /* 计算 h22 为 h[k+1+(k+1)*h_dim1] 和 h[k+k*h_dim1]-h[k+1+(k+1)*h_dim1] 的绝对值的最小值 */
    scl = h11 + h12;
    /* 计算 scl 为 h11 + h12 */
    tst2 = h22 * (h11 / scl);
    /* 计算 tst2 为 h22 * (h11 / scl) */

    /* Computing MAX */
    /* 计算最大值 */
    d__1 = smlnum, d__2 = ulp * tst2;
    if (tst2 == 0. || h21 * (h12 / scl) <= max(d__1,d__2)) {
        /* 如果 tst2 等于 0 或者 h21 * (h12 / scl) 小于等于 smlnum 和 ulp*tst2 的最大值，则执行以下操作 */
        h__[k + 1 + k * h_dim1] = 0.;
        /* 将 h[k+1+k*h_dim1] 置为 0 */
    }
}
/* 结束 if ((d__1 = h__[k + 1 + k * h_dim1], abs(d__1)) <= max(...) 的条件判断 */

/* L130: */
/* 标记 L130 位置 */
}

/*
     ==== Fill in the last row of each bulge. ====

   Computing MIN
*/
/* 填充每个突起的最后一行 */

i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
mend = min(i__4,i__5);
/* 计算 mend 为 nbmps 和 (*kbot - krcol - 1) / 3 的最小值 */
i__4 = mend;
for (m = mtop; m <= i__4; ++m) {
    /* 循环 m 从 mtop 到 mend */
    k = krcol + (m - 1) * 3;
    /* 计算 k 为 krcol + (m - 1) * 3 */
    refsum = v[m * v_dim1 + 1] * v[m * v_dim1 + 3] * h__[k + 4 + (
        k + 3) * h_dim1];
    /* 计算 refsum */
    h__[k + 4 + (k + 1) * h_dim1] = -refsum;
    /* 设置 h[k+4+(k+1)*h_dim1] 为 -refsum */
    h__[k + 4 + (k + 2) * h_dim1] = -refsum * v[m * v_dim1 + 2];
    /* 设置 h[k+4+(k+2)*h_dim1] 为 -refsum * v[m*v_dim1+2] */
    h__[k + 4 + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 + 3];
    /* 更新 h[k+4+(k+3)*h_dim1] */
/* L140: */
/* 标记 L140 位置 */
}

/*
     ==== End of near-the-diagonal bulge chase. ====

   L150:
*/
/* 标记 L150 位置 */
}

/*
  ==== Use U (if accumulated) to update far-from-diagonal
       entries in H.  If required, use U to update Z as
       well. ====
*/
/* 使用 U（如果已积累）来更新 H 中远离对角线的条目。如果需要，也要使用 U 来更新 Z。 */

if (accum) {
    /* 如果积累了 U */
    if (*wantt) {
        /* 如果需要计算 T */
        jtop = 1;
        jbot = *n;
        /* 设置 jtop 和 jbot */
    } else {
        jtop = *ktop;
        jbot = *kbot;
        /* 设置 jtop 和 jbot */
    }
    if (! blk22 || incol < *ktop || ndcol > *kbot || ns <= 2) {
        /* 如果不利用 U 的 2x2 块结构来更新 */

        /*
            ==== Updates not exploiting the 2-by-2 block
                 structure of U.  K1 and NU keep track of
                 the location and size of U in the special
                 cases of introducing bulges and chasing
                 bulges off the bottom.  In these special
                 cases and in case the number of shifts
                 is NS = 2, there is no 2-by-2 block
                 structure to exploit.  ====

       Computing MAX
        */
        /* 计算最大值 */
        i__3 = 1, i__4 = *ktop - incol;
        k1 = max(i__3,i__4);
        /* 计算 k1 为 1 和 (*ktop - incol) 的最大值 */
/* Computing MAX */
i__3 = 0, i__4 = ndcol - *kbot;
nu = kdu - max(i__3,i__4) - k1 + 1;
/* Calculate the dimension nu based on the maximum of 0 and ndcol - *kbot,
   subtracting k1 and adjusting by 1. */

/* ==== Horizontal Multiply ==== */

i__3 = jbot;
i__4 = *nh;
for (jcol = min(ndcol,*kbot) + 1; i__4 < 0 ? jcol >= i__3 :
    jcol <= i__3; jcol += i__4) {
/* Computing MIN */
i__5 = *nh, i__7 = jbot - jcol + 1;
jlen = min(i__5,i__7);
/* Determine jlen as the minimum of *nh and the remaining columns (jbot - jcol + 1). */

dgemm_("C", "N", &nu, &jlen, &nu, &c_b15, &u[k1 + k1 *
    u_dim1], ldu, &h__[incol + k1 + jcol * h_dim1],
    ldh, &c_b29, &wh[wh_offset], ldwh);
/* Perform matrix multiplication using BLAS routine dgemm to update wh
   based on columns from u and h__. */

dlacpy_("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h__[
    incol + k1 + jcol * h_dim1], ldh);
/* Copy the computed results from wh back into h__ for further computation. */
/* L160: */
}

/* ==== Vertical Multiply ==== */

i__4 = max(*ktop,incol) - 1;
i__3 = *nv;
for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
    jrow += i__3) {
/* Computing MIN */
i__5 = *nv, i__7 = max(*ktop,incol) - jrow;
jlen = min(i__5,i__7);
/* Determine jlen as the minimum of *nv and the remaining rows (max(*ktop,incol) - jrow). */

dgemm_("N", "N", &jlen, &nu, &nu, &c_b15, &h__[jrow + (
    incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1],
    ldu, &c_b29, &wv[wv_offset], ldwv);
/* Perform matrix multiplication using BLAS routine dgemm to update wv
   based on rows from h__ and u. */

dlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h__[
    jrow + (incol + k1) * h_dim1], ldh);
/* Copy the computed results from wv back into h__ for further computation. */
/* L170: */
}

/* ==== Z Multiply (also Vertical) ==== */

if (*wantz) {
    i__3 = *ihiz;
    i__4 = *nv;
    for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
         jrow += i__4) {
    /* Computing MIN */
    i__5 = *nv, i__7 = *ihiz - jrow + 1;
    jlen = min(i__5,i__7);
    /* Determine jlen as the minimum of *nv and the remaining rows (*ihiz - jrow + 1). */

    dgemm_("N", "N", &jlen, &nu, &nu, &c_b15, &z__[jrow +
        (incol + k1) * z_dim1], ldz, &u[k1 + k1 *
        u_dim1], ldu, &c_b29, &wv[wv_offset], ldwv);
    /* Perform matrix multiplication using BLAS routine dgemm to update wv
       based on rows from z__ and u. */

    dlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z__[
        jrow + (incol + k1) * z_dim1], ldz);
    /* Copy the computed results from wv back into z__ for further computation. */
    /* L180: */
    }
} else {

/*
        ==== Updates exploiting U's 2-by-2 block structure.
        .    (I2, I4, J2, J4 are the last rows and columns
        .    of the blocks.) ====
*/

i2 = (kdu + 1) / 2;
i4 = kdu;
j2 = i4 - i2;
j4 = kdu;

/*
        ==== KZS and KNZ deal with the band of zeros
        .    along the diagonal of one of the triangular
        .    blocks. ====
*/

kzs = j4 - j2 - (ns + 1);
knz = ns + 1;
}

/* ==== Horizontal Multiply ==== */

i__4 = jbot;
i__3 = *nh;
for (jcol = min(ndcol,*kbot) + 1; i__3 < 0 ? jcol >= i__4 :
    jcol <= i__4; jcol += i__3) {
/* Computing MIN */
i__5 = *nh, i__7 = jbot - jcol + 1;
jlen = min(i__5,i__7);
/* Determine jlen as the minimum of *nh and the remaining columns (jbot - jcol + 1). */
/*
                   ==== Copy bottom of H to top+KZS of scratch ====
                    (The first KZS rows get multiplied by zero.) ====
*/
dlacpy_("ALL", &knz, &jlen, &h__[incol + 1 + j2 + jcol *
    h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U21' ==== */
dlaset_("ALL", &kzs, &jlen, &c_b29, &c_b29, &wh[wh_offset]
    , ldwh);
dtrmm_("L", "U", "C", "N", &knz, &jlen, &c_b15, &u[j2 + 1
    + (kzs + 1) * u_dim1], ldu, &wh[kzs + 1 + wh_dim1]
    , ldwh);

/*                 ==== Multiply top of H by U11' ==== */
dgemm_("C", "N", &i2, &jlen, &j2, &c_b15, &u[u_offset],
    ldu, &h__[incol + 1 + jcol * h_dim1], ldh, &c_b15,
    &wh[wh_offset], ldwh);

/*                 ==== Copy top of H to bottom of WH ==== */
dlacpy_("ALL", &j2, &jlen, &h__[incol + 1 + jcol * h_dim1]
    , ldh, &wh[i2 + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U21' ==== */
dtrmm_("L", "L", "C", "N", &j2, &jlen, &c_b15, &u[(i2 + 1)
     * u_dim1 + 1], ldu, &wh[i2 + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U22 ==== */
i__5 = i4 - i2;
i__7 = j4 - j2;
dgemm_("C", "N", &i__5, &jlen, &i__7, &c_b15, &u[j2 + 1 +
    (i2 + 1) * u_dim1], ldu, &h__[incol + 1 + j2 +
    jcol * h_dim1], ldh, &c_b15, &wh[i2 + 1 + wh_dim1]
    , ldwh);

/*                 ==== Copy it back ==== */
dlacpy_("ALL", &kdu, &jlen, &wh[wh_offset], ldwh, &h__[
    incol + 1 + jcol * h_dim1], ldh);
/* L190: */
}

/*              ==== Vertical multiply ==== */

i__3 = max(incol,*ktop) - 1;
i__4 = *nv;
for (jrow = jtop; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
    jrow += i__4) {
/* Computing MIN */
i__5 = *nv, i__7 = max(incol,*ktop) - jrow;
jlen = min(i__5,i__7);

/*
                   ==== Copy right of H to scratch (the first KZS
                   .    columns get multiplied by zero) ====
*/
dlacpy_("ALL", &jlen, &knz, &h__[jrow + (incol + 1 + j2) *
     h_dim1], ldh, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U21 ==== */
dlaset_("ALL", &jlen, &kzs, &c_b29, &c_b29, &wv[wv_offset]
    , ldwv);
dtrmm_("R", "U", "N", "N", &jlen, &knz, &c_b15, &u[j2 + 1
    + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1) *
    wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U11 ==== */
dgemm_("N", "N", &jlen, &i2, &j2, &c_b15, &h__[jrow + (
    incol + 1) * h_dim1], ldh, &u[u_offset], ldu, &
    c_b15, &wv[wv_offset], ldwv);
/*                 ==== Copy left of H to right of scratch ==== */
复制 H 的左侧内容到 scratch 的右侧

            dlacpy_("ALL", &jlen, &j2, &h__[jrow + (incol + 1) *
                h_dim1], ldh, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U21 ==== */
用 U21 进行乘法运算

            i__5 = i4 - i2;
            dtrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b15, &u[(i2 +
                1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * wv_dim1 + 1]
                , ldwv);

/*                 ==== Multiply by U22 ==== */
用 U22 进行乘法运算

            i__5 = i4 - i2;
            i__7 = j4 - j2;
            dgemm_("N", "N", &jlen, &i__5, &i__7, &c_b15, &h__[jrow +
                (incol + 1 + j2) * h_dim1], ldh, &u[j2 + 1 + (i2
                + 1) * u_dim1], ldu, &c_b15, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/*                 ==== Copy it back ==== */
将结果复制回原位置

            dlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h__[
                jrow + (incol + 1) * h_dim1], ldh);
/* L200: */
        }

/*              ==== Multiply Z (also vertical) ==== */
对 Z 进行乘法运算（包括垂直方向）

        if (*wantz) {
            i__4 = *ihiz;
            i__3 = *nv;
            for (jrow = *iloz; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
                 jrow += i__3) {
/* Computing MIN */
            i__5 = *nv, i__7 = *ihiz - jrow + 1;
            jlen = min(i__5,i__7);

/*
                      ==== Copy right of Z to left of scratch (first
                      .     KZS columns get multiplied by zero) ====
*/
复制 Z 的右侧内容到 scratch 的左侧（前 KZS 列乘以零）

            dlacpy_("ALL", &jlen, &knz, &z__[jrow + (incol + 1 +
                j2) * z_dim1], ldz, &wv[(kzs + 1) * wv_dim1 +
                1], ldwv);

/*                    ==== Multiply by U12 ==== */
用 U12 进行乘法运算

            dlaset_("ALL", &jlen, &kzs, &c_b29, &c_b29, &wv[
                wv_offset], ldwv);
            dtrmm_("R", "U", "N", "N", &jlen, &knz, &c_b15, &u[j2
                + 1 + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1)
                * wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U11 ==== */
用 U11 进行乘法运算

            dgemm_("N", "N", &jlen, &i2, &j2, &c_b15, &z__[jrow +
                (incol + 1) * z_dim1], ldz, &u[u_offset], ldu,
                 &c_b15, &wv[wv_offset], ldwv);

/*                    ==== Copy left of Z to right of scratch ==== */
复制 Z 的左侧内容到 scratch 的右侧

            dlacpy_("ALL", &jlen, &j2, &z__[jrow + (incol + 1) *
                z_dim1], ldz, &wv[(i2 + 1) * wv_dim1 + 1],
                ldwv);

/*                    ==== Multiply by U21 ==== */
用 U21 进行乘法运算

            i__5 = i4 - i2;
            dtrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b15, &u[(
                i2 + 1) * u_dim1 + 1], ldu, &wv[(i2 + 1) *
                wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U22 ==== */
用 U22 进行乘法运算

            i__5 = i4 - i2;
            i__7 = j4 - j2;
            dgemm_("N", "N", &jlen, &i__5, &i__7, &c_b15, &z__[
                jrow + (incol + 1 + j2) * z_dim1], ldz, &u[j2
                + 1 + (i2 + 1) * u_dim1], ldu, &c_b15, &wv[(
                i2 + 1) * wv_dim1 + 1], ldwv);
/*                    ==== Copy the result back to Z ==== */

dlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &
    z__[jrow + (incol + 1) * z_dim1], ldz);
/* L210: */
}

}
}
/* L220: */
}

/*     ==== End of DLAQR5 ==== */

return 0;
} /* dlaqr5_ */

/* Subroutine */ int dlarf_(char *side, integer *m, integer *n, doublereal *v,
     integer *incv, doublereal *tau, doublereal *c__, integer *ldc,
    doublereal *work)
{
/* System generated locals */
integer c_dim1, c_offset;
doublereal d__1;

/* Local variables */
static integer i__;
static logical applyleft;
extern /* Subroutine */ int dger_(integer *, integer *, doublereal *,
    doublereal *, integer *, doublereal *, integer *, doublereal *,
    integer *);
extern logical lsame_(char *, char *);
extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
    doublereal *, doublereal *, integer *, doublereal *, integer *,
    doublereal *, doublereal *, integer *);
static integer lastc, lastv;
extern integer iladlc_(integer *, integer *, doublereal *, integer *),
    iladlr_(integer *, integer *, doublereal *, integer *);


/*
-- LAPACK auxiliary routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

DLARF applies a real elementary reflector H to a real m by n matrix
C, from either the left or the right. H is represented in the form

      H = I - tau * v * v'

where tau is a real scalar and v is a real vector.

If tau = 0, then H is taken to be the unit matrix.

Arguments
=========

SIDE    (input) CHARACTER*1
        = 'L': form  H * C
        = 'R': form  C * H

M       (input) INTEGER
        The number of rows of the matrix C.

N       (input) INTEGER
        The number of columns of the matrix C.

V       (input) DOUBLE PRECISION array, dimension
                   (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
        The vector v in the representation of H. V is not used if
        TAU = 0.

INCV    (input) INTEGER
        The increment between elements of v. INCV <> 0.

TAU     (input) DOUBLE PRECISION
        The value tau in the representation of H.

C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
        On entry, the m by n matrix C.
        On exit, C is overwritten by the matrix H * C if SIDE = 'L',
        or C * H if SIDE = 'R'.

LDC     (input) INTEGER
        The leading dimension of the array C. LDC >= max(1,M).

WORK    (workspace) DOUBLE PRECISION array, dimension
                       (N) if SIDE = 'L'
                    or (M) if SIDE = 'R'


注释：
    # 定义一个名为 `process_data` 的函数，接收一个名为 `data` 的参数
    def process_data(data):
        # 如果 `data` 是空列表或者 `None`，则返回空列表
        if not data:
            return []
        # 初始化一个空列表 `result`
        result = []
        # 遍历 `data` 中的每个元素，使用 `enumerate` 函数获取索引和元素本身
        for index, value in enumerate(data):
            # 如果 `index` 为偶数（索引从0开始算），则执行以下操作
            if index % 2 == 0:
                # 将当前元素的长度添加到 `result` 列表中
                result.append(len(value))
            # 否则，执行以下操作
            else:
                # 将当前元素的文本内容添加到 `result` 列表中，转换为小写后再添加
                result.append(value.lower())
        # 返回处理后的结果列表 `result`
        return result
    /* Parameter adjustments */
    --v;  // 对参数数组 v 进行调整，将索引向前偏移一个位置
    c_dim1 = *ldc;  // 将 c_dim1 设为参数 ldc 的值
    c_offset = 1 + c_dim1;  // 计算 c_offset，用于定位 C 数组的偏移量
    c__ -= c_offset;  // 调整 C 数组的起始地址，使其正确对齐
    --work;  // 调整参数数组 work 的起始地址，使其正确对齐

    /* Function Body */
    applyleft = lsame_(side, "L");  // 判断参数 side 是否为 'L'，确定是否在左侧应用变换
    lastv = 0;  // 初始化 lastv 为 0，用于跟踪 V 中最后一个非零行的位置
    lastc = 0;  // 初始化 lastc 为 0，用于跟踪 C 中最后一个非零列或行的位置
    if (*tau != 0.) {
/*
       Set up variables for scanning V.  LASTV begins pointing to the end
       of V.
*/
    if (applyleft) {
        lastv = *m;  // 如果在左侧应用变换，则 lastv 等于参数 m
    } else {
        lastv = *n;  // 如果在右侧应用变换，则 lastv 等于参数 n
    }
    if (*incv > 0) {
        i__ = (lastv - 1) * *incv + 1;  // 根据参数 incv 计算索引 i__
    } else {
        i__ = 1;  // 如果参数 incv 不大于 0，则索引 i__ 从 1 开始
    }
/*     Look for the last non-zero row in V. */
    while(lastv > 0 && v[i__] == 0.) {  // 循环查找 V 中最后一个非零行的位置
        --lastv;  // 如果当前行为零，将 lastv 减一
        i__ -= *incv;  // 调整索引 i__，以查找下一个可能的非零行
    }
    if (applyleft) {
/*     Scan for the last non-zero column in C(1:lastv,:). */
        lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);  // 在 C 的左侧应用变换时，查找 C 中最后一个非零列
    } else {
/*     Scan for the last non-zero row in C(:,1:lastv). */
        lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);  // 在 C 的右侧应用变换时，查找 C 中最后一个非零行
    }
    }
/*
       Note that lastc.eq.0 renders the BLAS operations null; no special
       case is needed at this level.
*/
    if (applyleft) {

/*        Form  H * C */

    if (lastv > 0) {

/*           w(1:lastc,1) := C(1:lastv,1:lastc)' * v(1:lastv,1) */

        dgemv_("Transpose", &lastv, &lastc, &c_b15, &c__[c_offset], ldc, &
            v[1], incv, &c_b29, &work[1], &c__1);  // 计算矩阵乘法 C^T * v，结果存储在向量 w 中

/*           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)' */

        d__1 = -(*tau);  // 计算 -tau
        dger_(&lastv, &lastc, &d__1, &v[1], incv, &work[1], &c__1, &c__[
            c_offset], ldc);  // 执行矩阵更新操作 C := C - tau * v * w^T
    }
    } else {

/*        Form  C * H */

    if (lastv > 0) {

/*           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1) */

        dgemv_("No transpose", &lastc, &lastv, &c_b15, &c__[c_offset],
            ldc, &v[1], incv, &c_b29, &work[1], &c__1);  // 计算矩阵乘法 C * v，结果存储在向量 w 中

/*           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)' */

        d__1 = -(*tau);  // 计算 -tau
        dger_(&lastc, &lastv, &d__1, &work[1], &c__1, &v[1], incv, &c__[
            c_offset], ldc);  // 执行矩阵更新操作 C := C - tau * w * v^T
    }
    }
    return 0;

/*     End of DLARF */

} /* dlarf_ */

/* Subroutine */ int dlarfb_(char *side, char *trans, char *direct, char *
    storev, integer *m, integer *n, integer *k, doublereal *v, integer *
    ldv, doublereal *t, integer *ldt, doublereal *c__, integer *ldc,
    doublereal *work, integer *ldwork)
{
    /* System generated locals */
    integer c_dim1, c_offset, t_dim1, t_offset, v_dim1, v_offset, work_dim1,
        work_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    extern logical lsame_(char *, char *);
    static integer lastc;
    # 外部声明两个子程序 dcopy_ 和 dtrmm_
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dtrmm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);

    # 静态声明变量 lastv，用于存储上一次操作的值
    static integer lastv;

    # 外部声明两个函数 iladlc_ 和 iladlr_
    extern integer iladlc_(integer *, integer *, doublereal *, integer *),
        iladlr_(integer *, integer *, doublereal *, integer *);

    # 静态声明字符数组 transt，长度为 1
    static char transt[1];
/*
    Parameter adjustments
*/
// 计算 V 和 T 数组的偏移量
v_dim1 = *ldv;
v_offset = 1 + v_dim1;
// 根据偏移量调整 V 数组指针
v -= v_offset;

// 计算 T 数组的偏移量
t_dim1 = *ldt;
t_offset = 1 + t_dim1;
// 根据偏移量调整 T 数组指针
t -= t_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    work_dim1 = *ldwork;
    work_offset = 1 + work_dim1;
    work -= work_offset;


    // 设置数组 c__ 的起始偏移量，使其能正确访问到 c 的第一列
    c_dim1 = *ldc;
    // 计算 c__ 的偏移量，确保可以访问到 c 的数据
    c_offset = 1 + c_dim1;
    // 调整 c__ 的指针，使其指向 c 的起始位置
    c__ -= c_offset;

    // 设置数组 work 的起始偏移量，使其能正确访问到 work 的第一列
    work_dim1 = *ldwork;
    // 计算 work 的偏移量，确保可以访问到 work 的数据
    work_offset = 1 + work_dim1;
    // 调整 work 的指针，使其指向 work 的起始位置
    work -= work_offset;


    /* Function Body */
    // 如果 m 或者 n 小于等于 0，则返回 0
    if (*m <= 0 || *n <= 0) {
        return 0;
    }

    // 如果 trans 表示的是 "N"，则将 transt 设置为 'T'；否则设置为 'N'
    if (lsame_(trans, "N")) {
        *(unsigned char *)transt = 'T';
    } else {
        *(unsigned char *)transt = 'N';
    }

    // 如果 storev 表示的是 "C"
    if (lsame_(storev, "C")) {

        // 如果 direct 表示的是 "F"
        if (lsame_(direct, "F")) {


        // 在这里添加进一步的代码注释
/*
    Let  V =  ( V1 )    (first K rows)
              ( V2 )
    where  V1  is unit lower triangular.
*/

if (lsame_(side, "L")) {

    /*
        Form  H * C  or  H' * C  where  C = ( C1 )
                                            ( C2 )

        Computing MAX
    */
    i__1 = *k, i__2 = iladlr_(m, k, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);

    /*
        W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

        W := C1'
    */
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dcopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
        /* L10: */
    }

    /* W := W * V1 */
    dtrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
    if (lastv > *k) {

        /* W := W + C2'*V2 */
        i__1 = lastv - *k;
        dgemm_("Transpose", "No transpose", &lastc, k, &i__1, &c_b15, &c__[*k + 1 + c_dim1], ldc, &v[*k + 1 + v_dim1], ldv, &c_b15, &work[work_offset], ldwork);
    }

    /* W := W * T'  or  W * T */
    dtrmm_("Right", "Upper", transt, "Non-unit", &lastc, k, &c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

    /* C := C - V * W' */
    if (lastv > *k) {

        /* C2 := C2 - V2 * W' */
        i__1 = lastv - *k;
        dgemm_("No transpose", "Transpose", &i__1, &lastc, k, &c_b151, &v[*k + 1 + v_dim1], ldv, &work[work_offset], ldwork, &c_b15, &c__[*k + 1 + c_dim1], ldc);
    }

    /* W := W * V1' */
    dtrmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

    /* C1 := C1 - W' */
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        i__2 = lastc;
        for (i__ = 1; i__ <= i__2; ++i__) {
            c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
            /* L20: */
        }
        /* L30: */
    }

} else if (lsame_(side, "R")) {

    /*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

        Computing MAX
    */
    i__1 = *k, i__2 = iladlr_(n, k, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);

    /*
        W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

        W := C1
    */
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dcopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j * work_dim1 + 1], &c__1);
        /* L40: */
    }

    /* W := W * V1 */
    dtrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
    if (lastv > *k) {
/*                 W := W + C2 * V2 */

        // 计算 W = W + C2 * V2，其中 C2 是部分更新的矩阵 C，V2 是上三角矩阵
        i__1 = lastv - *k;
        dgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
            c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k +
            1 + v_dim1], ldv, &c_b15, &work[work_offset],
            ldwork);
    }

/*              W := W * T  or  W * T' */

    // 根据 trans 参数选择性地计算 W = W * T 或者 W * T'，T 是上三角矩阵
    dtrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b15,
         &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */

    // 计算 C = C - W * V'，其中 V 是矩阵 V 的转置
    if (lastv > *k) {

/*                 C2 := C2 - W * V2' */

        // 计算部分更新的 C2 = C2 - W * V2'，其中 V2 是上三角矩阵
        i__1 = lastv - *k;
        dgemm_("No transpose", "Transpose", &lastc, &i__1, k, &
            c_b151, &work[work_offset], ldwork, &v[*k + 1 +
            v_dim1], ldv, &c_b15, &c__[(*k + 1) * c_dim1 + 1],
             ldc);
    }

/*              W := W * V1' */

    // 计算 W = W * V1'，其中 V1 是下三角矩阵
    dtrmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
        c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */

    // 更新 C1 = C1 - W
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        i__2 = lastc;
        for (i__ = 1; i__ <= i__2; ++i__) {
            c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L50: */
        }
/* L60: */
    }

} else {

/*
         Let  V =  ( V1 )
                   ( V2 )    (last K rows)
         where  V2  is unit upper triangular.
*/

    if (lsame_(side, "L")) {

/*
            Form  H * C  or  H' * C  where  C = ( C1 )
                                                ( C2 )

   Computing MAX
*/
    // 计算 lastv 和 lastc，用于确定矩阵的有效维度
    i__1 = *k, i__2 = iladlr_(m, k, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);

/*
            W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)

            W := C2'
*/

    // 计算 W = C' * V，其中 V 是矩阵 V，存储在 WORK 中
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dcopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
            j * work_dim1 + 1], &c__1);
/* L70: */
    }

/*              W := W * V2 */

    // 计算 W = W * V2，其中 V2 是上三角矩阵
    dtrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
        c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
        work_offset], ldwork);
    if (lastv > *k) {

/*                 W := W + C1'*V1 */

        // 更新 W = W + C1'*V1
        i__1 = lastv - *k;
        dgemm_("Transpose", "No transpose", &lastc, k, &i__1, &
            c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
            c_b15, &work[work_offset], ldwork);
    }

/*              W := W * T'  or  W * T */

    // 根据 transt 参数选择性地计算 W = W * T' 或者 W * T，T 是上三角矩阵
    dtrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
        c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V * W' */

    // 计算 C = C - V * W'，其中 V 是矩阵 V
    if (lastv > *k) {
/*                 C1 := C1 - V1 * W' */

            // 计算矩阵乘法 C1 := C1 - V1 * W'
            i__1 = lastv - *k;
            dgemm_("No transpose", "Transpose", &i__1, &lastc, k, &
                c_b151, &v[v_offset], ldv, &work[work_offset],
                ldwork, &c_b15, &c__[c_offset], ldc);
        }

/*              W := W * V2' */

        // 计算矩阵乘法 W := W * V2'
        dtrmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);

/*              C2 := C2 - W' */

        // 更新矩阵 C2 := C2 - W'
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            c__[lastv - *k + j + i__ * c_dim1] -= work[i__ + j *
                work_dim1];
/* L80: */
            }
/* L90: */
        }

        } else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
        // 计算最大值，确定矩阵维度
        i__1 = *k, i__2 = iladlr_(n, k, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)

                W := C2
*/

        // 复制矩阵 C2 到工作区域 W
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            dcopy_(&lastc, &c__[(*n - *k + j) * c_dim1 + 1], &c__1, &
                work[j * work_dim1 + 1], &c__1);
/* L100: */
        }

/*              W := W * V2 */

        // 计算矩阵乘法 W := W * V2
        dtrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1 * V1 */

            // 计算矩阵乘法 W := W + C1 * V1
            i__1 = lastv - *k;
            dgemm_("No transpose", "No transpose", &lastc, k, &i__1, &
                c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
                c_b15, &work[work_offset], ldwork);
        }

/*              W := W * T  or  W * T' */

        // 计算矩阵乘法 W := W * T 或 W * T'
        dtrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V' */

        // 计算矩阵乘法 C := C - W * V'
        if (lastv > *k) {

/*                 C1 := C1 - W * V1' */

            // 计算矩阵乘法 C1 := C1 - W * V1'
            i__1 = lastv - *k;
            dgemm_("No transpose", "Transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[v_offset],
                ldv, &c_b15, &c__[c_offset], ldc);
        }

/*              W := W * V2' */

        // 计算矩阵乘法 W := W * V2'
        dtrmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[lastv - *k + 1 + v_dim1], ldv, &work[
            work_offset], ldwork);

/*              C2 := C2 - W */

        // 更新矩阵 C2 := C2 - W
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            c__[i__ + (lastv - *k + j) * c_dim1] -= work[i__ + j *
                 work_dim1];
/* L110: */
            }
/* L120: */
        }
        }
    }

    } else if (lsame_(storev, "R")) {

    if (lsame_(direct, "F")) {
/*
             Let  V =  ( V1  V2 )    (V1: first K columns)
             where  V1  is unit upper triangular.
*/

if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
    // 计算 lastv 和 lastc 的值，用于后续操作
    i__1 = *k, i__2 = iladlc_(k, m, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C1'
*/
    // 将 C1' 的内容复制到工作区域
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dcopy_(&lastc, &c__[j + c_dim1], ldc, &work[j * work_dim1
            + 1], &c__1);
/* L130: */
    }

/*              W := W * V1' */
    // 计算 W = W * V1'
    dtrmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
        c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
    if (lastv > *k) {

/*                 W := W + C2'*V2' */
        // 如果 V2' 存在，则计算 W = W + C2'*V2'
        i__1 = lastv - *k;
        dgemm_("Transpose", "Transpose", &lastc, k, &i__1, &c_b15,
             &c__[*k + 1 + c_dim1], ldc, &v[(*k + 1) * v_dim1
            + 1], ldv, &c_b15, &work[work_offset], ldwork);
    }

/*              W := W * T'  or  W * T */
    // 计算 W = W * T' 或者 W = W * T
    dtrmm_("Right", "Upper", transt, "Non-unit", &lastc, k, &
        c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */
    // 更新 C = C - V' * W'
    if (lastv > *k) {

/*                 C2 := C2 - V2' * W' */
        // 如果 V2' 存在，则计算 C2 = C2 - V2' * W'
        i__1 = lastv - *k;
        dgemm_("Transpose", "Transpose", &i__1, &lastc, k, &
            c_b151, &v[(*k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork, &c_b15, &c__[*k + 1 +
            c_dim1], ldc);
    }

/*              W := W * V1 */
    // 计算 W = W * V1
    dtrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
        c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W' */
    // 更新 C1 = C1 - W'
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        i__2 = lastc;
        for (i__ = 1; i__ <= i__2; ++i__) {
        c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
/* L140: */
        }
/* L150: */
    }

} else if (lsame_(side, "R")) {

/*
                Form  C * H  or  C * H'  where  C = ( C1  C2 )

   Computing MAX
*/
    // 计算 lastv 和 lastc 的值，用于后续操作
    i__1 = *k, i__2 = iladlc_(k, n, &v[v_offset], ldv);
    lastv = max(i__1,i__2);
    lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);

/*
                W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

                W := C1
*/
    // 将 C1 的内容复制到工作区域
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dcopy_(&lastc, &c__[j * c_dim1 + 1], &c__1, &work[j *
            work_dim1 + 1], &c__1);
/* L160: */
    }

/*              W := W * V1' */
    // 计算 W = W * V1'
    dtrmm_("Right", "Upper", "Transpose", "Unit", &lastc, k, &
        c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);
    if (lastv > *k) {

/*                 W := W + C2*V2' */
        // 如果 V2' 存在，则计算 W = W + C2*V2'
        i__1 = lastv - *k;
        dgemm_("Transpose", "Transpose", &lastc, k, &i__1, &c_b15,
             &c__[(*k + 1) * c_dim1 + 1], ldc, &v[(*k + 1) *
            v_dim1 + 1], ldv, &c_b15, &work[work_offset], ldwork);
    }
/*                 W := W + C2 * V2' */

        // 计算 W = W + C2 * V2'，其中 C2 是矩阵 C 的右下部分，V2 是矩阵 V 的最后 K 列
        i__1 = lastv - *k;
        dgemm_("No transpose", "Transpose", &lastc, k, &i__1, &
            c_b15, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[(*k +
            1) * v_dim1 + 1], ldv, &c_b15, &work[work_offset],
             ldwork);
        }

/*              W := W * T  or  W * T' */

        // 计算 W = W * T 或者 W * T'，其中 T 是上三角矩阵，trans 控制是否转置 T
        dtrmm_("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b15,
             &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

        // 计算 C = C - W * V，其中 V 是矩阵 V 的全部列或部分列

        if (lastv > *k) {

/*                 C2 := C2 - W * V2 */

            // 计算 C2 = C2 - W * V2，其中 V2 是矩阵 V 的最后 K 列
            i__1 = lastv - *k;
            dgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
                c_b151, &work[work_offset], ldwork, &v[(*k + 1) *
                v_dim1 + 1], ldv, &c_b15, &c__[(*k + 1) * c_dim1
                + 1], ldc);
        }

/*              W := W * V1 */

        // 计算 W = W * V1，其中 V1 是矩阵 V 的前面的列

        dtrmm_("Right", "Upper", "No transpose", "Unit", &lastc, k, &
            c_b15, &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */

        // 计算 C1 = C1 - W，其中 W 是之前计算的结果

        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            i__2 = lastc;
            for (i__ = 1; i__ <= i__2; ++i__) {
            c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L170: */
            }
/* L180: */
        }

        }

    } else {

/*
             Let  V =  ( V1  V2 )    (V2: last K columns)
             where  V2  is unit lower triangular.
*/

        if (lsame_(side, "L")) {

/*
                Form  H * C  or  H' * C  where  C = ( C1 )
                                                    ( C2 )

   Computing MAX
*/
        i__1 = *k, i__2 = iladlc_(k, m, &v[v_offset], ldv);
        lastv = max(i__1,i__2);
        lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);

/*
                W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)

                W := C2'
*/

        // 计算 W = C' * V'，其中 V 是矩阵 V 的全部列或部分列，C 是矩阵 C 的转置
        i__1 = *k;
        for (j = 1; j <= i__1; ++j) {
            dcopy_(&lastc, &c__[lastv - *k + j + c_dim1], ldc, &work[
                j * work_dim1 + 1], &c__1);
/* L190: */
        }

/*              W := W * V2' */

        // 计算 W = W * V2'，其中 V2 是矩阵 V 的最后 K 列的转置
        dtrmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
            c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
            work_offset], ldwork);
        if (lastv > *k) {

/*                 W := W + C1'*V1' */

            // 计算 W = W + C1'*V1'，其中 V1 是矩阵 V 的前面的列的转置
            i__1 = lastv - *k;
            dgemm_("Transpose", "Transpose", &lastc, k, &i__1, &c_b15,
                 &c__[c_offset], ldc, &v[v_offset], ldv, &c_b15, &
                work[work_offset], ldwork);
        }

/*              W := W * T'  or  W * T */

        // 计算 W = W * T' 或者 W * T，其中 T 是下三角矩阵，transt 控制是否转置 T
        dtrmm_("Right", "Lower", transt, "Non-unit", &lastc, k, &
            c_b15, &t[t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V' * W' */

        // 计算 C = C - V' * W'，其中 V 是矩阵 V 的全部列或部分列，W 是之前计算的结果的转置
        if (lastv > *k) {
/*                 C1 := C1 - V1' * W' */

/* 计算 C1 = C1 - V1' * W'，其中 C1 是一个子矩阵，V1 是矩阵 V 的一个子集，W 是工作矩阵 */

i__1 = lastv - *k;
/* 计算行数 i__1，等于 lastv - *k */

dgemm_("Transpose", "Transpose", &i__1, &lastc, k, &
    c_b151, &v[v_offset], ldv, &work[work_offset],
    ldwork, &c_b15, &c__[c_offset], ldc);
/* 调用 BLAS 函数 dgemm，计算矩阵乘法 V1' * W'，结果减去到 C1 上 */

}

/*              W := W * V2 */

/* 计算 W = W * V2，其中 W 和 V2 是矩阵 */

dtrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
    c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
    work_offset], ldwork);

/* 调用 BLAS 函数 dtrmm，计算矩阵乘法 W * V2，结果存储在 W 中 */

/*              C2 := C2 - W' */

/* 计算 C2 = C2 - W'，其中 C2 是一个子矩阵，W 是工作矩阵 */

i__1 = *k;
/* 计算列数 i__1，等于 *k */

for (j = 1; j <= i__1; ++j) {
    /* 外循环：遍历列 */
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 内循环：遍历行 */
        c__[lastv - *k + j + i__ * c_dim1] -= work[i__ + j *
            work_dim1];
        /* 计算 C2 的元素减去 W' 的对应元素 */
/* L200: */
    }
/* L210: */
}

} else if (lsame_(side, "R")) {

/*
        Form  C * H  or  C * H'  where  C = ( C1  C2 )

Computing MAX
*/
i__1 = *k, i__2 = iladlc_(k, n, &v[v_offset], ldv);
/* 计算 lastv，作为 *k 和 iladlc_ 函数计算结果的最大值 */

lastv = max(i__1,i__2);
/* 取 i__1 和 i__2 的最大值作为 lastv */

lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);
/* 调用 iladlr_ 函数，计算 lastc */

/*
        W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)

        W := C2
*/

i__1 = *k;
/* 计算列数 i__1，等于 *k */

for (j = 1; j <= i__1; ++j) {
    /* 外循环：遍历列 */
    dcopy_(&lastc, &c__[(lastv - *k + j) * c_dim1 + 1], &c__1,
         &work[j * work_dim1 + 1], &c__1);
    /* 调用 BLAS 函数 dcopy，复制 C2 到工作数组 W 中 */
/* L220: */
}

/*              W := W * V2' */

/* 计算 W = W * V2'，其中 W 和 V2 是矩阵 */

dtrmm_("Right", "Lower", "Transpose", "Unit", &lastc, k, &
    c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
    work_offset], ldwork);
/* 调用 BLAS 函数 dtrmm，计算矩阵乘法 W * V2'，结果存储在 W 中 */

if (lastv > *k) {

/*                 W := W + C1 * V1' */

i__1 = lastv - *k;
/* 计算行数 i__1，等于 lastv - *k */

dgemm_("No transpose", "Transpose", &lastc, k, &i__1, &
    c_b15, &c__[c_offset], ldc, &v[v_offset], ldv, &
    c_b15, &work[work_offset], ldwork);
/* 调用 BLAS 函数 dgemm，计算矩阵乘法 C1 * V1'，结果加到 W 中 */
}

/*              W := W * T  or  W * T' */

/* 计算 W = W * T 或者 W * T'，其中 W 和 T 是矩阵 */

dtrmm_("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b15,
     &t[t_offset], ldt, &work[work_offset], ldwork);
/* 调用 BLAS 函数 dtrmm，计算矩阵乘法 W * T 或者 W * T'，结果存储在 W 中 */

/*              C := C - W * V */

/* 计算 C = C - W * V，其中 W 和 V 是矩阵 */

if (lastv > *k) {

/*                 C1 := C1 - W * V1 */

i__1 = lastv - *k;
/* 计算行数 i__1，等于 lastv - *k */

dgemm_("No transpose", "No transpose", &lastc, &i__1, k, &
    c_b151, &work[work_offset], ldwork, &v[v_offset],
    ldv, &c_b15, &c__[c_offset], ldc);
/* 调用 BLAS 函数 dgemm，计算矩阵乘法 W * V1，结果减到 C1 上 */
}

/*              W := W * V2 */

/* 计算 W = W * V2，其中 W 和 V2 是矩阵 */

dtrmm_("Right", "Lower", "No transpose", "Unit", &lastc, k, &
    c_b15, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[
    work_offset], ldwork);
/* 调用 BLAS 函数 dtrmm，计算矩阵乘法 W * V2，结果存储在 W 中 */

/*              C1 := C1 - W */

/* 计算 C1 = C1 - W，其中 W 是矩阵 */

i__1 = *k;
/* 计算列数 i__1，等于 *k */

for (j = 1; j <= i__1; ++j) {
    /* 外循环：遍历列 */
    i__2 = lastc;
    for (i__ = 1; i__ <= i__2; ++i__) {
        /* 内循环：遍历行 */
        c__[i__ + (lastv - *k + j) * c_dim1] -= work[i__ + j *
             work_dim1];
        /* 计算 C1 的元素减去 W 的对应元素 */
/* L230: */
    }
/* L240: */
}

}

}

return 0;

/*     End of DLARFB */

} /* dlarfb_ */
/* Subroutine */ int dlarfg_(integer *n, doublereal *alpha, doublereal *x,
    integer *incx, doublereal *tau)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    static integer j, knt;
    static doublereal beta;
    extern doublereal dnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    static doublereal xnorm;

    static doublereal safmin, rsafmn;


    /*
        -- LAPACK auxiliary routine (version 3.2) --
        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
           November 2006


        Purpose
        =======

        DLARFG generates a real elementary reflector H of order n, such
        that

              H * ( alpha ) = ( beta ),   H' * H = I.
                  (   x   )   (   0  )

        where alpha and beta are scalars, and x is an (n-1)-element real
        vector. H is represented in the form

              H = I - tau * ( 1 ) * ( 1 v' ) ,
                            ( v )

        where tau is a real scalar and v is a real (n-1)-element
        vector.

        If the elements of x are all zero, then tau = 0 and H is taken to be
        the unit matrix.

        Otherwise  1 <= tau <= 2.

        Arguments
        =========

        N       (input) INTEGER
                The order of the elementary reflector.

        ALPHA   (input/output) DOUBLE PRECISION
                On entry, the value alpha.
                On exit, it is overwritten with the value beta.

        X       (input/output) DOUBLE PRECISION array, dimension
                               (1+(N-2)*abs(INCX))
                On entry, the vector x.
                On exit, it is overwritten with the vector v.

        INCX    (input) INTEGER
                The increment between elements of X. INCX > 0.

        TAU     (output) DOUBLE PRECISION
                The value tau.

        =====================================================================
    */


    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 1) {
        *tau = 0.;
        return 0;
    }

    i__1 = *n - 1;
    xnorm = dnrm2_(&i__1, &x[1], incx);

    if (xnorm == 0.) {

    /*        H  =  I */

        *tau = 0.;
    } else {

    /*        general case */

        d__1 = dlapy2_(alpha, &xnorm);
        beta = -d_sign(&d__1, alpha);
        safmin = SAFEMINIMUM / EPSILON;
        knt = 0;
        if (abs(beta) < safmin) {

    /*           XNORM, BETA may be inaccurate; scale X and recompute them */

            rsafmn = 1. / safmin;
    L10:
            ++knt;
            i__1 = *n - 1;
            dscal_(&i__1, &rsafmn, &x[1], incx);
            beta *= rsafmn;
            *alpha *= rsafmn;
            if (abs(beta) < safmin) {
                goto L10;
            }

    /*           New BETA is at most 1, at least SAFMIN */

            i__1 = *n - 1;
            xnorm = dnrm2_(&i__1, &x[1], incx);
            d__1 = dlapy2_(alpha, &xnorm);
            beta = -d_sign(&d__1, alpha);
        }
        *tau = (beta - *alpha) / beta;
        i__1 = *n - 1;
    # 计算 alpha - beta 的倒数，存储在 d__1 变量中
    d__1 = 1. / (*alpha - beta);
    # 调用外部函数 dscal_，对数组 x 中的元素进行标量乘法操作，乘数为 d__1
    dscal_(&i__1, &d__1, &x[1], incx);
/*
    If ALPHA is subnormal, it may lose relative accuracy
*/

i__1 = knt;
for (j = 1; j <= i__1; ++j) {
    beta *= safmin;
    // 将 beta 乘以 safmin knt 次，可能因 ALPHA 为次正规数而失去相对精度
    // 注意：此处 beta 和 safmin 的定义需要进一步查找以理解具体含义
    // L20:
}
*alpha = beta;
}

return 0;

/*
    End of DLARFG
*/

} /* dlarfg_ */

/* Subroutine */ int dlarft_(char *direct, char *storev, integer *n, integer *
    k, doublereal *v, integer *ldv, doublereal *tau, doublereal *t,
    integer *ldt)
{
/* System generated locals */
integer t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3;
doublereal d__1;

/* Local variables */
static integer i__, j, prevlastv;
static doublereal vii;
extern logical lsame_(char *, char *);
extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
    doublereal *, doublereal *, integer *, doublereal *, integer *,
    doublereal *, doublereal *, integer *);
static integer lastv;
extern /* Subroutine */ int dtrmv_(char *, char *, char *, integer *,
    doublereal *, integer *, doublereal *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DLARFT forms the triangular factor T of a real block reflector H
    of order n, which is defined as a product of k elementary reflectors.

    If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;

    If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.

    If STOREV = 'C', the vector which defines the elementary reflector
    H(i) is stored in the i-th column of the array V, and

       H  =  I - V * T * V'

    If STOREV = 'R', the vector which defines the elementary reflector
    H(i) is stored in the i-th row of the array V, and

       H  =  I - V' * T * V

    Arguments
    =========

    DIRECT  (input) CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)

    STOREV  (input) CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise

    N       (input) INTEGER
            The order of the block reflector H. N >= 0.

    K       (input) INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.

    V       (input/output) DOUBLE PRECISION array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.

    LDV     (input) INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.

*/
    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).



    T       (output) DOUBLE PRECISION array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.



    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= K.



    Further Details
    ===============

    The shape of the matrix V and the storage of the vectors which define
    the H(i) is best illustrated by the following example with n = 5 and
    k = 3. The elements equal to 1 are not stored; the corresponding
    array elements are modified but restored on exit. The rest of the
    array is not used.



    DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                 V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                     ( v1  1    )                     (     1 v2 v2 v2 )
                     ( v1 v2  1 )                     (        1 v3 v3 )
                     ( v1 v2 v3 )
                     ( v1 v2 v3 )



    DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                 V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                     ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                     (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                     (     1 v3 )
                     (        1 )



    =====================================================================


       Quick return if possible
    /* Parameter adjustments */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --tau;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;

    /* Function Body */
    if (*n == 0) {
        return 0;
    }

    if (lsame_(direct, "F")) {
        prevlastv = *n;
        i__1 = *k;
        for (i__ = 1; i__ <= i__1; ++i__) {
            prevlastv = max(i__, prevlastv);
            if (tau[i__] == 0.) {

/*              H(i)  =  I */

                i__2 = i__;
                for (j = 1; j <= i__2; ++j) {
                    t[j + i__ * t_dim1] = 0.;
/* L10: */
                }
            } else {

/*              general case */

                vii = v[i__ + i__ * v_dim1];
                v[i__ + i__ * v_dim1] = 1.;
                if (lsame_(storev, "C")) {
/*                 Skip any trailing zeros. */
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        if (v[lastv + i__ * v_dim1] != 0.) {
                            goto L15;
                        }
                    }
L15:
                    j = min(lastv, prevlastv);

/*                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)' * V(i:j,i) */

                    i__2 = j - i__ + 1;
                    i__3 = i__ - 1;
                    d__1 = -tau[i__];
                    dgemv_("Transpose", &i__2, &i__3, &d__1, &v[i__ + v_dim1],
                         ldv, &v[i__ + i__ * v_dim1], &c__1, &c_b29, &t[
                        i__ * t_dim1 + 1], &c__1);
                } else {
/*                 Skip any trailing zeros. */
                    i__2 = i__ + 1;
                    for (lastv = *n; lastv >= i__2; --lastv) {
                        if (v[i__ + lastv * v_dim1] != 0.) {
                            goto L16;
                        }
                    }
L16:
                    j = min(lastv, prevlastv);

/*                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)' */

                    i__2 = i__ - 1;
                    i__3 = j - i__ + 1;
                    d__1 = -tau[i__];
                    dgemv_("No transpose", &i__2, &i__3, &d__1, &v[i__ *
                        v_dim1 + 1], ldv, &v[i__ + i__ * v_dim1], ldv, &
                        c_b29, &t[i__ * t_dim1 + 1], &c__1);
                }
                v[i__ + i__ * v_dim1] = vii;

/*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) */

                i__2 = i__ - 1;
                dtrmv_("Upper", "No transpose", "Non-unit", &i__2, &t[
                    t_offset], ldt, &t[i__ * t_dim1 + 1], &c__1);
                t[i__ + i__ * t_dim1] = tau[i__];
                if (i__ > 1) {
                    prevlastv = max(prevlastv, lastv);
                } else {
                    prevlastv = lastv;
                }
            }
/* L20: */
        }
    } else {
        prevlastv = 1;
        for (i__ = *k; i__ >= 1; --i__) {
            if (tau[i__] == 0.) {

/*              H(i)  =  I */

                i__1 = *k;
                for (j = i__; j <= i__1; ++j) {
                    t[j + i__ * t_dim1] = 0.;
/* L30: */
                }
            } else {

/*              general case */

                if (i__ < *k) {
                    if (lsame_(storev, "C")) {
                        vii = v[*n - *k + i__ + i__ * v_dim1];
                        v[*n - *k + i__ + i__ * v_dim1] = 1.;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            ! Loop through previous columns to find the last non-zero entry in the current column
            do lastv = 1, i__1
                ! Check if the element is non-zero
                if (v(lastv + i__ * v_dim1) /= 0.) then
                    goto L35
                end if
            end do
L35:
            ! Determine the starting index for further calculations
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(j:n-k+i,i+1:k)' * V(j:n-k+i,i)
*/

            ! Compute a matrix-vector product with a transposed matrix
            i__1 = *n - *k + i__ - j + 1;
            i__2 = *k - i__;
            d__1 = -tau[i__];
            dgemv_("Transpose", &i__1, &i__2, &d__1, &v[j + (i__
                + 1) * v_dim1], ldv, &v[j + i__ * v_dim1], &
                c__1, &c_b29, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            ! Store the diagonal element of T
            v[*n - *k + i__ + i__ * v_dim1] = vii;
            else {
            vii = v[i__ + (*n - *k + i__) * v_dim1];
            v[i__ + (*n - *k + i__) * v_dim1] = 1.;
/*                    Skip any leading zeros. */
            i__1 = i__ - 1;
            do lastv = 1, i__1
                if (v[i__ + lastv * v_dim1] /= 0.) then
                goto L36
                end if
            end do
L36:
            ! Determine the starting index for further calculations
            j = max(lastv,prevlastv);

/*
                      T(i+1:k,i) :=
                              - tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)'
*/

            ! Compute a matrix-vector product without transposing
            i__1 = *k - i__;
            i__2 = *n - *k + i__ - j + 1;
            d__1 = -tau[i__];
            dgemv_("No transpose", &i__1, &i__2, &d__1, &v[i__ +
                1 + j * v_dim1], ldv, &v[i__ + j * v_dim1],
                ldv, &c_b29, &t[i__ + 1 + i__ * t_dim1], &
                c__1);
            ! Restore the original value of the matrix V
            v[i__ + (*n - *k + i__) * v_dim1] = vii;
            }

/*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) */

            ! Multiply a triangular matrix by a vector
            i__1 = *k - i__;
            dtrmv_("Lower", "No transpose", "Non-unit", &i__1, &t[i__
                + 1 + (i__ + 1) * t_dim1], ldt, &t[i__ + 1 + i__ *
                 t_dim1], &c__1)
                ;
            if (i__ > 1) {
            prevlastv = min(prevlastv,lastv);
            } else {
            prevlastv = lastv;
            }
        }
        ! Store the scalar factor in T
        t[i__ + i__ * t_dim1] = tau[i__];
        }
/* L40: */
    }
    }
    return 0;

/*     End of DLARFT */

} /* dlarft_ */

/* Subroutine */ int dlarfx_(char *side, integer *m, integer *n, doublereal *
    v, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work)
{
    /* System generated locals */
    integer c_dim1, c_offset, i__1;

    /* Local variables */
    static integer j;
    static doublereal t1, t2, t3, t4, t5, t6, t7, t8, t9, v1, v2, v3, v4, v5,
        v6, v7, v8, v9, t10, v10, sum;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *);
    extern logical lsame_(char *, char *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    # 以下是一个用于应用实数埃尔米特反射器 H 到实数 m × n 矩阵 C 的子程序 DLARFX。
    # H 的表示形式为 H = I - tau * v * v'，其中 tau 是一个实数标量，v 是一个实数向量。
    # 如果 tau = 0，则 H 被视为单位矩阵。
    # 当 H 的阶数小于 11 时，这个版本使用内联代码。
    
    # Arguments 参数说明：
    
    # SIDE (输入) CHARACTER*1
    #       = 'L': 表示 H * C
    #       = 'R': 表示 C * H
    #       指定反射器 H 是作用在矩阵 C 的左侧还是右侧。
    
    # M (输入) INTEGER
    #       矩阵 C 的行数。
    
    # N (输入) INTEGER
    #       矩阵 C 的列数。
    
    # V (输入) DOUBLE PRECISION 数组，维度为 (M) 如果 SIDE = 'L'，或者 (N) 如果 SIDE = 'R'
    #       反射器 H 的向量 v。
    
    # TAU (输入) DOUBLE PRECISION
    #       反射器 H 的表示中的 tau 值。
    
    # C (输入/输出) DOUBLE PRECISION 数组，维度为 (LDC,N)
    #       输入时，是一个 m × n 的矩阵 C。
    #       输出时，如果 SIDE = 'L'，则被矩阵 H * C 覆盖；如果 SIDE = 'R'，则被矩阵 C * H 覆盖。
    
    # LDC (输入) INTEGER
    #       数组 C 的主维度。LDC >= max(1, M)。
    
    # WORK (工作空间) DOUBLE PRECISION 数组，维度为 (N) 如果 SIDE = 'L'，或者 (M) 如果 SIDE = 'R'
    #       当 H 的阶数 >= 11 时使用。在本代码中未被引用。
    
    # =====================================================================
    /* Parameter adjustments */
    --v;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    if (*tau == 0.) {
        return 0;
    }
    if (lsame_(side, "L")) {

        /* Form  H * C, where H has order m. */

        switch (*m) {
            case 1:  goto L10;
            case 2:  goto L30;
            case 3:  goto L50;
            case 4:  goto L70;
            case 5:  goto L90;
            case 6:  goto L110;
            case 7:  goto L130;
            case 8:  goto L150;
            case 9:  goto L170;
            case 10:  goto L190;
        }

        /* Code for general M */

        dlarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);
        goto L410;
    L10:

        /* Special code for 1 x 1 Householder */

        t1 = 1. - *tau * v[1] * v[1];
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            c__[j * c_dim1 + 1] = t1 * c__[j * c_dim1 + 1];
        }
        goto L410;
    L30:

        /* Special code for 2 x 2 Householder */

        v1 = v[1];
        t1 = *tau * v1;
        v2 = v[2];
        t2 = *tau * v2;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2];
            c__[j * c_dim1 + 1] -= sum * t1;
            c__[j * c_dim1 + 2] -= sum * t2;
        }
        goto L410;
    L50:

        /* Special code for 3 x 3 Householder */

        v1 = v[1];
        t1 = *tau * v1;
        v2 = v[2];
        t2 = *tau * v2;
        v3 = v[3];
        t3 = *tau * v3;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
                c__[j * c_dim1 + 3];
            c__[j * c_dim1 + 1] -= sum * t1;
            c__[j * c_dim1 + 2] -= sum * t2;
            c__[j * c_dim1 + 3] -= sum * t3;
        }
        goto L410;
    L70:

        /* Special code for 4 x 4 Householder */

        v1 = v[1];
        t1 = *tau * v1;
        v2 = v[2];
        t2 = *tau * v2;
        v3 = v[3];
        t3 = *tau * v3;
        v4 = v[4];
        t4 = *tau * v4;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
                c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4];
            c__[j * c_dim1 + 1] -= sum * t1;
            c__[j * c_dim1 + 2] -= sum * t2;
            c__[j * c_dim1 + 3] -= sum * t3;
            c__[j * c_dim1 + 4] -= sum * t4;
        }
        goto L410;
    L90:

        /* Special code for 5 x 5 Householder */

        v1 = v[1];
        t1 = *tau * v1;
        v2 = v[2];
        t2 = *tau * v2;
        v3 = v[3];
        t3 = *tau * v3;
        v4 = v[4];
        t4 = *tau * v4;
        v5 = v[5];
        t5 = *tau * v5;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
                c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
                j * c_dim1 + 5];
            c__[j * c_dim1 + 1] -= sum * t1;
            c__[j * c_dim1 + 2] -= sum * t2;
            c__[j * c_dim1 + 3] -= sum * t3;
            c__[j * c_dim1 + 4] -= sum * t4;
            c__[j * c_dim1 + 5] -= sum * t5;
        }
        goto L410;
    # 跳转到代码标签 L410 处继续执行
    goto L410;
/*        Special code for 6 x 6 Householder */
特殊处理 6 x 6 Householder 的代码

    v1 = v[1];
    // 从向量 v 中获取第一个元素赋值给 v1
    t1 = *tau * v1;
    // 计算 tau 乘以 v1 的值，赋值给 t1
    v2 = v[2];
    // 从向量 v 中获取第二个元素赋值给 v2
    t2 = *tau * v2;
    // 计算 tau 乘以 v2 的值，赋值给 t2
    v3 = v[3];
    // 从向量 v 中获取第三个元素赋值给 v3
    t3 = *tau * v3;
    // 计算 tau 乘以 v3 的值，赋值给 t3
    v4 = v[4];
    // 从向量 v 中获取第四个元素赋值给 v4
    t4 = *tau * v4;
    // 计算 tau 乘以 v4 的值，赋值给 t4
    v5 = v[5];
    // 从向量 v 中获取第五个元素赋值给 v5
    t5 = *tau * v5;
    // 计算 tau 乘以 v5 的值，赋值给 t5
    v6 = v[6];
    // 从向量 v 中获取第六个元素赋值给 v6
    t6 = *tau * v6;
    // 计算 tau 乘以 v6 的值，赋值给 t6
    i__1 = *n;
    // 将 n 赋值给 i__1
    for (j = 1; j <= i__1; ++j) {
        // 循环 j 从 1 到 i__1
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6];
        // 计算 v1 到 v6 和 c__ 数组中特定索引值的乘积并求和，赋值给 sum
        c__[j * c_dim1 + 1] -= sum * t1;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t1 的结果
        c__[j * c_dim1 + 2] -= sum * t2;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t2 的结果
        c__[j * c_dim1 + 3] -= sum * t3;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t3 的结果
        c__[j * c_dim1 + 4] -= sum * t4;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t4 的结果
        c__[j * c_dim1 + 5] -= sum * t5;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t5 的结果
        c__[j * c_dim1 + 6] -= sum * t6;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t6 的结果
/* L120: */
/* L120: */
    }
    // 跳转到标签 L410 处
    goto L410;
L130:

/*        Special code for 7 x 7 Householder */
特殊处理 7 x 7 Householder 的代码

    v1 = v[1];
    // 从向量 v 中获取第一个元素赋值给 v1
    t1 = *tau * v1;
    // 计算 tau 乘以 v1 的值，赋值给 t1
    v2 = v[2];
    // 从向量 v 中获取第二个元素赋值给 v2
    t2 = *tau * v2;
    // 计算 tau 乘以 v2 的值，赋值给 t2
    v3 = v[3];
    // 从向量 v 中获取第三个元素赋值给 v3
    t3 = *tau * v3;
    // 计算 tau 乘以 v3 的值，赋值给 t3
    v4 = v[4];
    // 从向量 v 中获取第四个元素赋值给 v4
    t4 = *tau * v4;
    // 计算 tau 乘以 v4 的值，赋值给 t4
    v5 = v[5];
    // 从向量 v 中获取第五个元素赋值给 v5
    t5 = *tau * v5;
    // 计算 tau 乘以 v5 的值，赋值给 t5
    v6 = v[6];
    // 从向量 v 中获取第六个元素赋值给 v6
    t6 = *tau * v6;
    // 计算 tau 乘以 v6 的值，赋值给 t6
    v7 = v[7];
    // 从向量 v 中获取第七个元素赋值给 v7
    t7 = *tau * v7;
    // 计算 tau 乘以 v7 的值，赋值给 t7
    i__1 = *n;
    // 将 n 赋值给 i__1
    for (j = 1; j <= i__1; ++j) {
        // 循环 j 从 1 到 i__1
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
            c_dim1 + 7];
        // 计算 v1 到 v7 和 c__ 数组中特定索引值的乘积并求和，赋值给 sum
        c__[j * c_dim1 + 1] -= sum * t1;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t1 的结果
        c__[j * c_dim1 + 2] -= sum * t2;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t2 的结果
        c__[j * c_dim1 + 3] -= sum * t3;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t3 的结果
        c__[j * c_dim1 + 4] -= sum * t4;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t4 的结果
        c__[j * c_dim1 + 5] -= sum * t5;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t5 的结果
        c__[j * c_dim1 + 6] -= sum * t6;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t6 的结果
        c__[j * c_dim1 + 7] -= sum * t7;
        // 将 c__ 数组中特定索引位置的值减去 sum 乘以 t7 的结果
/* L140: */
/* L140: */
    }
    // 跳转到标签 L410 处
    goto L410;
L150:

/*        Special code for 8 x 8 Householder */
特殊处理 8 x 8 Householder 的代码

    v1 = v[1];
    // 从向量 v 中获取第一个元素赋值给 v1
    t1 = *tau * v1;
    // 计算 tau 乘以 v1 的值，赋值给 t1
    v2 = v[2];
    // 从向量 v 中获取第二个元素赋值给 v2
    t2 = *tau * v2;
    // 计算 t7，等于 tau 乘以 v7
    t7 = *tau * v7;
    // 获取向量 v 的第 8 个元素
    v8 = v[8];
    // 计算 t8，等于 tau 乘以 v8
    t8 = *tau * v8;
    // 获取向量 v 的第 9 个元素
    v9 = v[9];
    // 计算 t9，等于 tau 乘以 v9
    t9 = *tau * v9;
    // 对矩阵 c 的每一列进行遍历
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        // 计算 sum，为 v 向量与矩阵 c 第 j 行对应元素的乘积之和
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
            c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j *
            c_dim1 + 9];
        // 更新矩阵 c 第 j 行各元素的值
        c__[j * c_dim1 + 1] -= sum * t1;
        c__[j * c_dim1 + 2] -= sum * t2;
        c__[j * c_dim1 + 3] -= sum * t3;
        c__[j * c_dim1 + 4] -= sum * t4;
        c__[j * c_dim1 + 5] -= sum * t5;
        c__[j * c_dim1 + 6] -= sum * t6;
        c__[j * c_dim1 + 7] -= sum * t7;
        c__[j * c_dim1 + 8] -= sum * t8;
        c__[j * c_dim1 + 9] -= sum * t9;
    }
/* L180: */
    }
    goto L410;
L190:

/*        Special code for 10 x 10 Householder */

    // 从向量 v 中获取每个元素并乘以 tau 得到 t1 到 t10
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    v9 = v[9];
    t9 = *tau * v9;
    v10 = v[10];
    t10 = *tau * v10;
    
    // 循环遍历矩阵 C 的列
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        // 计算 Householder 变换对 C 的影响并更新每一列
        sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 *
            c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
            j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j *
            c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j *
            c_dim1 + 9] + v10 * c__[j * c_dim1 + 10];
        // 更新矩阵 C 中的每一列
        c__[j * c_dim1 + 1] -= sum * t1;
        c__[j * c_dim1 + 2] -= sum * t2;
        c__[j * c_dim1 + 3] -= sum * t3;
        c__[j * c_dim1 + 4] -= sum * t4;
        c__[j * c_dim1 + 5] -= sum * t5;
        c__[j * c_dim1 + 6] -= sum * t6;
        c__[j * c_dim1 + 7] -= sum * t7;
        c__[j * c_dim1 + 8] -= sum * t8;
        c__[j * c_dim1 + 9] -= sum * t9;
        c__[j * c_dim1 + 10] -= sum * t10;
/* L200: */
    }
    goto L410;
    } else {

/*        Form  C * H, where H has order n. */

    // 根据矩阵 C 的列数 *n 进行分支处理
    switch (*n) {
        // 对于不同的 n 值执行不同的 Householder 变换操作
        case 1:  goto L210;
        case 2:  goto L230;
        case 3:  goto L250;
        case 4:  goto L270;
        case 5:  goto L290;
        case 6:  goto L310;
        case 7:  goto L330;
        case 8:  goto L350;
        case 9:  goto L370;
        case 10:  goto L390;
    }

/*        Code for general N */

    // 调用 BLAS 库中的 dlarf 函数，对矩阵 C 进行 Householder 变换
    dlarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);
    // 跳转到标签 L410 处
    goto L410;
L210:

/*        Special code for 1 x 1 Householder */

    // 对于1 x 1 Householder 变换的特殊处理
    t1 = 1. - *tau * v[1] * v[1];
    // 循环遍历矩阵 C 的行
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 更新矩阵 C 的元素
        c__[j + c_dim1] = t1 * c__[j + c_dim1];
/* L220: */
    }
    // 跳转到标签 L410 处
    goto L410;
L230:

/*        Special code for 2 x 2 Householder */

    // 对于2 x 2 Householder 变换的特殊处理
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    // 循环遍历矩阵 C 的行
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算 Householder 变换对 C 的影响并更新每一列
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)];
        // 更新矩阵 C 的元素
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
/* L240: */
    }
    // 跳转到标签 L410 处
    goto L410;
L250:

/*        Special code for 3 x 3 Householder */

    // 对于3 x 3 Householder 变换的特殊处理
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    // 循环遍历矩阵 C 的行
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算 Householder 变换对 C 的影响并更新每一列
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3];
        // 更新矩阵 C 的元素
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
/* L260: */
    }
    // 跳转到标签 L410 处
    goto L410;
L270:

/*        Special code for 4 x 4 Householder */

    // 对于4 x 4 Householder 变换的特殊处理
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    // 计算 t4 的值，t4 是 tau 和 v4 的乘积
    t4 = *tau * v4;
    // 循环遍历矩阵的列索引，从 1 到 m
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算矩阵列 j 上的线性组合，并存储在 sum 中
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)];
        // 更新矩阵的第 j 列，分别减去 sum 乘以 t1、t2、t3 和 t4 后的结果
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
/* L280: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L290:

/*        Special code for 5 x 5 Householder */

    // 从向量 v 中取出对应元素，计算 tau 乘以这些元素的值
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    // 对矩阵 c 的每一列进行操作
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算一列上的乘积和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5];
        // 更新矩阵 c 中每行对应位置的值
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
/* L300: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L310:

/*        Special code for 6 x 6 Householder */

    // 从向量 v 中取出对应元素，计算 tau 乘以这些元素的值
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    // 对矩阵 c 的每一列进行操作
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算一列上的乘积和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6];
        // 更新矩阵 c 中每行对应位置的值
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
/* L320: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L330:

/*        Special code for 7 x 7 Householder */

    // 从向量 v 中取出对应元素，计算 tau 乘以这些元素的值
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    // 对矩阵 c 的每一列进行操作
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        // 计算一列上的乘积和
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7];
        // 更新矩阵 c 中每行对应位置的值
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
/* L340: */
    }
    // 转到标签 L410 处继续执行
    goto L410;
L350:

/*        Special code for 8 x 8 Householder */

    // 从向量 v 中取出对应元素，计算 tau 乘以这些元素的值
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    // 对矩阵 c 的每一列进行操作
    i__1 = *m;
    // 对矩阵 c__ 的每一列进行迭代，j 从 1 到 i__1
    for (j = 1; j <= i__1; ++j) {
        // 计算线性组合的结果 sum，其中 v1 到 v8 是系数，c__ 表示矩阵 c__，c_dim1 是其第一维的长度
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)];
        // 更新矩阵 c__ 的第 j 行第一列的元素
        c__[j + c_dim1] -= sum * t1;
        // 更新矩阵 c__ 的第 j 行第二列的元素
        c__[j + (c_dim1 << 1)] -= sum * t2;
        // 更新矩阵 c__ 的第 j 行第三列的元素
        c__[j + c_dim1 * 3] -= sum * t3;
        // 更新矩阵 c__ 的第 j 行第四列的元素
        c__[j + (c_dim1 << 2)] -= sum * t4;
        // 更新矩阵 c__ 的第 j 行第五列的元素
        c__[j + c_dim1 * 5] -= sum * t5;
        // 更新矩阵 c__ 的第 j 行第六列的元素
        c__[j + c_dim1 * 6] -= sum * t6;
        // 更新矩阵 c__ 的第 j 行第七列的元素
        c__[j + c_dim1 * 7] -= sum * t7;
        // 更新矩阵 c__ 的第 j 行第八列的元素
        c__[j + (c_dim1 << 3)] -= sum * t8;
    }
/* L360: */
    }
    goto L410;
L370:

/*        Special code for 9 x 9 Householder */

    // 将向量 v 中的前 9 个元素分别乘以 tau，并存储到临时变量 t1 到 t9 中
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    v9 = v[9];
    t9 = *tau * v9;
    // 对矩阵 c 的每一列进行更新，减去特定的线性组合乘以 t1 到 t9
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
            j + c_dim1 * 9];
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
        c__[j + (c_dim1 << 3)] -= sum * t8;
        c__[j + c_dim1 * 9] -= sum * t9;
/* L380: */
    }
    goto L410;
L390:

/*        Special code for 10 x 10 Householder */

    // 将向量 v 中的前 10 个元素分别乘以 tau，并存储到临时变量 t1 到 t10 中
    v1 = v[1];
    t1 = *tau * v1;
    v2 = v[2];
    t2 = *tau * v2;
    v3 = v[3];
    t3 = *tau * v3;
    v4 = v[4];
    t4 = *tau * v4;
    v5 = v[5];
    t5 = *tau * v5;
    v6 = v[6];
    t6 = *tau * v6;
    v7 = v[7];
    t7 = *tau * v7;
    v8 = v[8];
    t8 = *tau * v8;
    v9 = v[9];
    t9 = *tau * v9;
    v10 = v[10];
    t10 = *tau * v10;
    // 对矩阵 c 的每一列进行更新，减去特定的线性组合乘以 t1 到 t10
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
        sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 *
            c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 *
            c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
            j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
            j + c_dim1 * 9] + v10 * c__[j + c_dim1 * 10];
        c__[j + c_dim1] -= sum * t1;
        c__[j + (c_dim1 << 1)] -= sum * t2;
        c__[j + c_dim1 * 3] -= sum * t3;
        c__[j + (c_dim1 << 2)] -= sum * t4;
        c__[j + c_dim1 * 5] -= sum * t5;
        c__[j + c_dim1 * 6] -= sum * t6;
        c__[j + c_dim1 * 7] -= sum * t7;
        c__[j + (c_dim1 << 3)] -= sum * t8;
        c__[j + c_dim1 * 9] -= sum * t9;
        c__[j + c_dim1 * 10] -= sum * t10;
/* L400: */
    }
    goto L410;
    }
L410:
    return 0;

/*     End of DLARFX */

} /* dlarfx_ */

/* Subroutine */ int dlartg_(doublereal *f, doublereal *g, doublereal *cs,
    doublereal *sn, doublereal *r__)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__;
    static doublereal f1, g1, eps, scale;
    static integer count;
    static doublereal safmn2, safmx2;

    static doublereal safmin;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    # 定义了一个逻辑变量 FIRST，用于标记是否是第一次调用该函数
    LOGICAL            FIRST
    # 定义了几个静态变量，用于保存计算机参数，确保线程安全
    SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
    # 静态变量 FIRST 初始化为 TRUE
    DATA               FIRST / .TRUE. /
    
    # 如果是第一次调用该函数，则执行以下代码块
    IF( FIRST ) THEN
/*
    safmin = SAFEMINIMUM;
    eps = EPSILON;
    d__1 = BASE;
    i__1 = (integer) (log(safmin / eps) / log(BASE) / 2.);
    safmn2 = pow_di(&d__1, &i__1);
    safmx2 = 1. / safmn2;
*/
    // 设置安全最小值和机器精度
    safmin = SAFEMINIMUM;
    eps = EPSILON;
    // 计算 BASE 的对数，用于确定 safmn2 和 safmx2
    d__1 = BASE;
    i__1 = (integer) (log(safmin / eps) / log(BASE) / 2.);
    // 计算 safmn2 的 BASE 次幂
    safmn2 = pow_di(&d__1, &i__1);
    // 计算 safmx2 作为 safmn2 的倒数
    safmx2 = 1. / safmn2;
/*
          FIRST = .FALSE.
       END IF
*/
    // 初始化标志变量 FIRST 为假
    // 在这段代码中没有直接对应的初始化 FIRST 的语句，可能是其他地方的标志使用
    // 此处暂不进行具体的设置
    if (*g == 0.) {
        *cs = 1.;
        *sn = 0.;
        *r__ = *f;
    } else if (*f == 0.) {
        *cs = 0.;
        *sn = 1.;
        *r__ = *g;
    } else {
        f1 = *f;
        g1 = *g;
/* Computing MAX */
        d__1 = abs(f1), d__2 = abs(g1);
        // 计算 f1 和 g1 的绝对值的最大值，作为尺度因子
        scale = max(d__1,d__2);
        if (scale >= safmx2) {
            count = 0;
L10:
            ++count;
            f1 *= safmn2;
            g1 *= safmn2;
/* Computing MAX */
            d__1 = abs(f1), d__2 = abs(g1);
            // 再次计算调整后的 f1 和 g1 的绝对值的最大值
            scale = max(d__1,d__2);
            if (scale >= safmx2) {
                goto L10;
            }
/* Computing 2nd power */
            d__1 = f1;
/* Computing 2nd power */
            d__2 = g1;
            // 计算旋转矩阵的 r
            *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
            *cs = f1 / *r__;
            *sn = g1 / *r__;
            i__1 = count;
            // 将 r 缩放 count 次
            for (i__ = 1; i__ <= i__1; ++i__) {
                *r__ *= safmx2;
/* L20: */
            }
        } else if (scale <= safmn2) {
            count = 0;
L30:
            ++count;
            f1 *= safmx2;
            g1 *= safmx2;
/* Computing MAX */
            d__1 = abs(f1), d__2 = abs(g1);
            // 再次计算调整后的 f1 和 g1 的绝对值的最大值
            scale = max(d__1,d__2);
            if (scale <= safmn2) {
                goto L30;
            }
/* Computing 2nd power */
            d__1 = f1;
/* Computing 2nd power */
            d__2 = g1;
            // 计算旋转矩阵的 r
            *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
            *cs = f1 / *r__;
            *sn = g1 / *r__;
            i__1 = count;
            // 将 r 缩放 count 次
            for (i__ = 1; i__ <= i__1; ++i__) {
                *r__ *= safmn2;
/* L40: */
            }
        } else {
/* Computing 2nd power */
            d__1 = f1;
/* Computing 2nd power */
            d__2 = g1;
            // 计算旋转矩阵的 r
            *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
            *cs = f1 / *r__;
            *sn = g1 / *r__;
        }
        // 如果 f 的绝对值大于 g 的绝对值且 cs 为负数，则取反 cs、sn 和 r
        if (abs(*f) > abs(*g) && *cs < 0.) {
            *cs = -(*cs);
            *sn = -(*sn);
            *r__ = -(*r__);
        }
    }
    // 返回正常退出
    return 0;

/*     End of DLARTG */

} /* dlartg_ */

/* Subroutine */ int dlas2_(doublereal *f, doublereal *g, doublereal *h__,
    doublereal *ssmin, doublereal *ssmax)
{
    // 局部变量声明
    // c, fa, ga, ha, as, at, au, fhmn, fhmx;
    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal c__, fa, ga, ha, as, at, au, fhmn, fhmx;

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAS2  computes the singular values of the 2-by-2 matrix
       [  F   G  ]
       [  0   H  ].
    On return, SSMIN is the smaller singular value and SSMAX is the
    larger singular value.

    Arguments
    =========

    F       (input) DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.

    G       (input) DOUBLE PRECISION
            The (1,2) element of the 2-by-2 matrix.
*/
    H       (input) DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.
    输入参数 H，类型为双精度浮点数，表示一个2x2矩阵的第二行第二列元素。

    SSMIN   (output) DOUBLE PRECISION
            The smaller singular value.
    输出参数 SSMIN，类型为双精度浮点数，表示计算得到的较小奇异值。

    SSMAX   (output) DOUBLE PRECISION
            The larger singular value.
    输出参数 SSMAX，类型为双精度浮点数，表示计算得到的较大奇异值。

    Further Details
    ===============
    进一步细节
    ===============

    Barring over/underflow, all output quantities are correct to within
    a few units in the last place (ulps), even in the absence of a guard
    digit in addition/subtraction.
    除了溢出/下溢的情况外，所有输出值在最后一位的几个单位（ulp，最小单位）内是正确的，即使在加法/减法中没有保护位。

    In IEEE arithmetic, the code works correctly if one matrix element is
    infinite.
    在IEEE算术中，如果一个矩阵元素是无穷大，该代码能够正确工作。

    Overflow will not occur unless the largest singular value itself
    overflows, or is within a few ulps of overflow. (On machines with
    partial overflow, like the Cray, overflow may occur if the largest
    singular value is within a factor of 2 of overflow.)
    只有在最大奇异值本身溢出，或者接近溢出的几个ulp时才会发生溢出。在存在部分溢出的机器上（如Cray），如果最大奇异值接近溢出的两倍，则可能发生溢出。

    Underflow is harmless if underflow is gradual. Otherwise, results
    may correspond to a matrix modified by perturbations of size near
    the underflow threshold.
    如果下溢是渐进的，则无害。否则，结果可能对应于由接近下溢阈值大小的扰动修改过的矩阵。
    
    ====================================================================
    fa = abs(*f);
    ga = abs(*g);
    ha = abs(*h__);
    fhmn = min(fa,ha);
    fhmx = max(fa,ha);


    # 计算指针 f、g、h__ 所指向的值的绝对值，并赋给 fa、ga、ha
    fa = abs(*f);
    ga = abs(*g);
    ha = abs(*h__);
    # 计算 fa 和 ha 的最小值和最大值，分别赋给 fhmn 和 fhmx
    fhmn = min(fa,ha);
    fhmx = max(fa,ha);



    if (fhmn == 0.) {
        *ssmin = 0.;
        if (fhmx == 0.) {
            *ssmax = ga;
        } else {


        # 如果 fhmn 等于 0
        if (fhmn == 0.) {
            # 设置 ssmin 为 0
            *ssmin = 0.;
            # 如果 fhmx 也等于 0
            if (fhmx == 0.) {
                # 设置 ssmax 为 ga
                *ssmax = ga;
            } else {



/* Computing 2nd power */
            d__1 = min(fhmx,ga) / max(fhmx,ga);
            *ssmax = max(fhmx,ga) * sqrt(d__1 * d__1 + 1.);
        }
    } else {


                # 计算 min(fhmx,ga) 的平方除以 max(fhmx,ga)
                d__1 = min(fhmx,ga) / max(fhmx,ga);
                # 计算 ssmax
                *ssmax = max(fhmx,ga) * sqrt(d__1 * d__1 + 1.);
            }
        } else {



    if (ga < fhmx) {
        as = fhmn / fhmx + 1.;
        at = (fhmx - fhmn) / fhmx;
/* Computing 2nd power */
        d__1 = ga / fhmx;
        au = d__1 * d__1;
        c__ = 2. / (sqrt(as * as + au) + sqrt(at * at + au));
        *ssmin = fhmn * c__;
        *ssmax = fhmx / c__;
    } else {


        # 如果 ga 小于 fhmx
        if (ga < fhmx) {
            # 计算 as 和 at
            as = fhmn / fhmx + 1.;
            at = (fhmx - fhmn) / fhmx;
            # 计算 ga/fhmx 的平方
            d__1 = ga / fhmx;
            au = d__1 * d__1;
            # 计算 c__
            c__ = 2. / (sqrt(as * as + au) + sqrt(at * at + au));
            # 计算 ssmin 和 ssmax
            *ssmin = fhmn * c__;
            *ssmax = fhmx / c__;
        } else {



        au = fhmx / ga;
        if (au == 0.) {

/*
                Avoid possible harmful underflow if exponent range
                asymmetric (true SSMIN may not underflow even if
                AU underflows)
*/

        *ssmin = fhmn * fhmx / ga;
        *ssmax = ga;
        } else {
        as = fhmn / fhmx + 1.;
        at = (fhmx - fhmn) / fhmx;
/* Computing 2nd power */
        d__1 = as * au;
/* Computing 2nd power */
        d__2 = at * au;
        c__ = 1. / (sqrt(d__1 * d__1 + 1.) + sqrt(d__2 * d__2 + 1.));
        *ssmin = fhmn * c__ * au;
        *ssmin += *ssmin;
        *ssmax = ga / (c__ + c__);
        }
    }


            # 计算 au
            au = fhmx / ga;
            # 如果 au 等于 0
            if (au == 0.) {
                /*
                    避免可能的有害下溢，如果指数范围不对称（即使 AU 下溢，真实的 SSMIN 可能不会下溢）
                */
                # 计算 ssmin 和 ssmax
                *ssmin = fhmn * fhmx / ga;
                *ssmax = ga;
            } else {
                # 计算 as 和 at
                as = fhmn / fhmx + 1.;
                at = (fhmx - fhmn) / fhmx;
                # 计算 as*au 和 at*au 的平方
                d__1 = as * au;
                d__2 = at * au;
                # 计算 c__
                c__ = 1. / (sqrt(d__1 * d__1 + 1.) + sqrt(d__2 * d__2 + 1.));
                # 计算 ssmin 和 ssmax
                *ssmin = fhmn * c__ * au;
                *ssmin += *ssmin;
                *ssmax = ga / (c__ + c__);
            }
        }
    }



    return 0;

/*     End of DLAS2 */

} /* dlas2_ */

/* Subroutine */ int dlascl_(char *type__, integer *kl, integer *ku,
    doublereal *cfrom, doublereal *cto, integer *m, integer *n,
    doublereal *a, integer *lda, integer *info)
{


    # 返回 0，结束 DLAS2 过程
    return 0;

    /*     End of DLAS2 */

} /* dlas2_ */

/* Subroutine */ int dlascl_(char *type__, integer *kl, integer *ku,
    doublereal *cfrom, doublereal *cto, integer *m, integer *n,
    doublereal *a, integer *lda, integer *info)
{



    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k1, k2, k3, k4;
    static doublereal mul, cto1;
    static logical done;
    static doublereal ctoc;
    extern logical lsame_(char *, char *);
    static integer itype;
    static doublereal cfrom1;

    static doublereal cfromc;
    extern logical disnan_(doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal bignum, smlnum;


    # 系统生成的本地变量和局部变量声明
    static integer i__, j, k1, k2, k3, k4;
    static doublereal mul, cto1;
    static logical done;
    static doublereal ctoc;
    extern logical lsame_(char *, char *);
    static integer itype;
    static doublereal cfrom1;
    static doublereal cfromc;
    extern logical disnan_(doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal bignum, smlnum;



/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASCL multiplies the M by N real matrix A by the real scalar
    CTO/CFROM.  This is done without over/underflow as long as the final
    result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
    A may be full, upper triangular, lower triangular, upper Hessenberg,
    or banded.

    Arguments
    =========


    /*
        LAPACK 辅助例程（版本 3.2）
        LAPACK 是由田纳西大学、加利福尼亚大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。
        2006年11月

        Purpose
        =======
        DLASCL 将 M x N 的实矩阵 A 乘以实标量 CTO/CFROM。只要最终结果 CTO*A(I,J)/CFROM 不会溢出/下溢，就可以安全进行此操作。
        TYPE 指定 A 可能是完整的、上三角形、下三角形、上 Hessenberg 或带状的矩阵。

        Arguments
        =========
    */
    ! 定义输入参数的存储类型：'G'表示全矩阵，'L'表示下三角矩阵，'U'表示上三角矩阵，
    ! 'H'表示上Hessenberg矩阵，'B'表示带状对称矩阵（只存储下半部分），'Q'表示带状对称矩阵（只存储上半部分），
    ! 'Z'表示带状矩阵。
    TYPE    (input) CHARACTER*1

    ! A是一个对称带状矩阵时，指定其下带宽KL和上带宽KU。只有当TYPE为'B'、'Q'或'Z'时才被引用。
    KL      (input) INTEGER

    ! A是一个对称带状矩阵时，指定其上带宽KU。只有当TYPE为'B'、'Q'或'Z'时才被引用。
    KU      (input) INTEGER

    ! 矩阵A乘以CTO/CFROM的比例因子。如果结果CTO*A(I,J)/CFROM可以在不溢出的情况下表示，则A(I,J)计算不会发生溢出或下溢。
    ! CFROM必须非零。
    CFROM   (input) DOUBLE PRECISION
    CTO     (input) DOUBLE PRECISION

    ! 矩阵A的行数。M >= 0。
    M       (input) INTEGER

    ! 矩阵A的列数。N >= 0。
    N       (input) INTEGER

    ! 需要进行乘法操作的矩阵A。根据TYPE的不同存储类型进行解释。
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)

    ! 数组A的第一个维度，即其行数。LDA >= max(1,M)。
    LDA     (input) INTEGER

    ! 函数返回状态信息：0表示成功，<0表示参数错误（-INFO对应参数错误的序号）。
    INFO    (output) INTEGER
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;  // 初始化 info 变量为 0

    if (lsame_(type__, "G")) {  // 判断 type__ 是否为 "G"
        itype = 0;
    } else if (lsame_(type__, "L")) {  // 判断 type__ 是否为 "L"
        itype = 1;
    } else if (lsame_(type__, "U")) {  // 判断 type__ 是否为 "U"
        itype = 2;
    } else if (lsame_(type__, "H")) {  // 判断 type__ 是否为 "H"
        itype = 3;
    } else if (lsame_(type__, "B")) {  // 判断 type__ 是否为 "B"
        itype = 4;
    } else if (lsame_(type__, "Q")) {  // 判断 type__ 是否为 "Q"
        itype = 5;
    } else if (lsame_(type__, "Z")) {  // 判断 type__ 是否为 "Z"
        itype = 6;
    } else {
        itype = -1;  // 如果 type__ 不符合上述任何类型，则设置 itype 为 -1
    }

    if (itype == -1) {  // 如果 itype 为 -1
        *info = -1;  // 设置 info 为 -1，表示错误类型
    } else if (*cfrom == 0. || disnan_(cfrom)) {  // 如果 cfrom 为 0 或者是 NaN
        *info = -4;  // 设置 info 为 -4，表示 cfrom 非法
    } else if (disnan_(cto)) {  // 如果 cto 是 NaN
        *info = -5;  // 设置 info 为 -5，表示 cto 非法
    } else if (*m < 0) {  // 如果 m 小于 0
        *info = -6;  // 设置 info 为 -6，表示 m 非法
    } else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m) {
        *info = -7;  // 设置 info 为 -7，表示 n 非法
    } else if (itype <= 3 && *lda < max(1,*m)) {
        *info = -9;  // 设置 info 为 -9，表示 lda 非法
    } else if (itype >= 4) {  // 如果 itype 大于等于 4
        /* Computing MAX */
        i__1 = *m - 1;
        if (*kl < 0 || *kl > max(i__1,0)) {
            *info = -2;  // 设置 info 为 -2，表示 kl 非法
        } else {
            /* Computing MAX */
            i__1 = *n - 1;
            if (*ku < 0 || *ku > max(i__1,0) || (itype == 4 || itype == 5) &&
                *kl != *ku) {
                *info = -3;  // 设置 info 为 -3，表示 ku 非法
            } else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *
                ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1) {
                *info = -9;  // 设置 info 为 -9，表示 lda 非法
            }
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLASCL", &i__1);  // 调用错误处理函数 xerbla_
        return 0;  // 返回 0 表示出错
    }

/*     Quick return if possible */

    if (*n == 0 || *m == 0) {  // 如果 n 或者 m 为 0
        return 0;  // 直接返回，不做进一步处理
    }

/*     Get machine parameters */

    smlnum = SAFEMINIMUM;  // 获取机器参数 SAFEMINIMUM
    bignum = 1. / smlnum;  // 计算 bignum

    cfromc = *cfrom;  // 将 cfrom 赋值给 cfromc
    ctoc = *cto;  // 将 cto 赋值给 ctoc

L10:
    cfrom1 = cfromc * smlnum;  // 计算 cfrom1
    if (cfrom1 == cfromc) {
        /*
              CFROMC is an inf.  Multiply by a correctly signed zero for
              finite CTOC, or a NaN if CTOC is infinite.
        */
        mul = ctoc / cfromc;  // 计算 mul
        done = TRUE_;  // 设置 done 为 TRUE
        cto1 = ctoc;  // 将 ctoc 赋值给 cto1
    } else {
        cto1 = ctoc / bignum;  // 计算 cto1
        if (cto1 == ctoc) {
            /*
                 CTOC is either 0 or an inf.  In both cases, CTOC itself
                 serves as the correct multiplication factor.
            */
            mul = ctoc;  // 设置 mul 为 ctoc
            done = TRUE_;  // 设置 done 为 TRUE
            cfromc = 1.;  // 设置 cfromc 为 1
        } else if (abs(cfrom1) > abs(ctoc) && ctoc != 0.) {
            mul = smlnum;  // 设置 mul 为 smlnum
            done = FALSE_;  // 设置 done 为 FALSE
            cfromc = cfrom1;  // 更新 cfromc
        } else if (abs(cto1) > abs(cfromc)) {
            mul = bignum;  // 设置 mul 为 bignum
            done = FALSE_;  // 设置 done 为 FALSE
            ctoc = cto1;  // 更新 ctoc
        } else {
            mul = ctoc / cfromc;  // 设置 mul
            done = TRUE_;  // 设置 done 为 TRUE
        }
    }

    if (itype == 0) {
        /*        Full matrix */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] *= mul;  // 对全矩阵元素乘以 mul
            }
        }
    } else if (itype == 1) {
        /*        Lower triangular matrix */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = j; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] *= mul;  // 对下三角矩阵元素乘以 mul
            }
        }
`
/* L40: */
        }
/* L50: */
    }

    } else if (itype == 2) {

/*        Upper triangular matrix */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = min(j,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L60: */
        }
/* L70: */
    }

    } else if (itype == 3) {

/*        Upper Hessenberg matrix */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
        i__3 = j + 1;
        i__2 = min(i__3,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L80: */
        }
/* L90: */
    }

    } else if (itype == 4) {

/*        Lower half of a symmetric band matrix */

    k3 = *kl + 1;
    k4 = *n + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
        i__3 = k3, i__4 = k4 - j;
        i__2 = min(i__3,i__4);
        for (i__ = 1; i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L100: */
        }
/* L110: */
    }

    } else if (itype == 5) {

/*        Upper half of a symmetric band matrix */

    k1 = *ku + 2;
    k3 = *ku + 1;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
        i__2 = k1 - j;
        i__3 = k3;
        for (i__ = max(i__2,1); i__ <= i__3; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L120: */
        }
/* L130: */
    }

    } else if (itype == 6) {

/*        Band matrix */

    k1 = *kl + *ku + 2;
    k2 = *kl + 1;
    k3 = (*kl << 1) + *ku + 1;
    k4 = *kl + *ku + 1 + *m;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
        i__3 = k1 - j;
/* Computing MIN */
        i__4 = k3, i__5 = k4 - j;
        i__2 = min(i__4,i__5);
        for (i__ = max(i__3,k2); i__ <= i__2; ++i__) {
        a[i__ + j * a_dim1] *= mul;
/* L140: */
        }
/* L150: */
    }

    }

    if (! done) {
    goto L10;
    }

    return 0;

/*     End of DLASCL */

} /* dlascl_ */

/* Subroutine */ int dlasd0_(integer *n, integer *sqre, doublereal *d__,
    doublereal *e, doublereal *u, integer *ldu, doublereal *vt, integer *
    ldvt, integer *smlsiz, integer *iwork, doublereal *work, integer *
    info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, m, i1, ic, lf, nd, ll, nl, nr, im1, ncc, nlf, nrf,
        iwk, lvl, ndb1, nlp1, nrp1;
    static doublereal beta;
    static integer idxq, nlvl;
    static doublereal alpha;
    static integer inode, ndiml, idxqc, ndimr, itemp, sqrei;
    ! 声明调用外部 Fortran 子例程 dlasd1_
    extern /* Subroutine */ int dlasd1_(integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         doublereal *, integer *, integer *, integer *, doublereal *,
        integer *);
    
    ! 声明调用外部 Fortran 子例程 dlasdq_
    ! dlasdq_ 用于奇异值分解的主要子例程
    ! char * 表示字符参数
    dlasdq_(char *, integer *, integer *, integer *,
        integer *, integer *, doublereal *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *);
    
    ! 声明调用外部 Fortran 子例程 dlasdt_
    dlasdt_(integer *, integer *,
        integer *, integer *, integer *, integer *, integer *);
    
    ! 声明调用外部 Fortran 子例程 xerbla_
    ! xerbla_ 处理 LAPACK 子例程中的错误信息
    xerbla_(char *, integer *);
/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    Using a divide and conquer approach, DLASD0 computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M
    matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
    The algorithm computes orthogonal matrices U and VT such that
    B = U * S * VT. The singular values S are overwritten on D.

    A related subroutine, DLASDA, computes only the singular values,
    and optionally, the singular vectors in compact form.

    Arguments
    =========

    N      (input) INTEGER
           On entry, the row dimension of the upper bidiagonal matrix.
           This is also the dimension of the main diagonal array D.

    SQRE   (input) INTEGER
           Specifies the column dimension of the bidiagonal matrix.
           = 0: The bidiagonal matrix has column dimension M = N;
           = 1: The bidiagonal matrix has column dimension M = N+1;

    D      (input/output) DOUBLE PRECISION array, dimension (N)
           On entry D contains the main diagonal of the bidiagonal
           matrix.
           On exit D, if INFO = 0, contains its singular values.

    E      (input) DOUBLE PRECISION array, dimension (M-1)
           Contains the subdiagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    U      (output) DOUBLE PRECISION array, dimension at least (LDU, N)
           On exit, U contains the left singular vectors.

    LDU    (input) INTEGER
           On entry, leading dimension of U.

    VT     (output) DOUBLE PRECISION array, dimension at least (LDVT, M)
           On exit, VT' contains the right singular vectors.

    LDVT   (input) INTEGER
           On entry, leading dimension of VT.

    SMLSIZ (input) INTEGER
           On entry, maximum size of the subproblems at the
           bottom of the computation tree.

    IWORK  (workspace) INTEGER work array.
           Dimension must be at least (8 * N)

    WORK   (workspace) DOUBLE PRECISION work array.
           Dimension must be at least (3 * M**2 + 2 * M)

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================


       Test the input parameters.
*/

/* Parameter adjustments */
--d__;               // d__ 是指向数组 D 的指针
--e;                 // e 是指向数组 E 的指针
u_dim1 = *ldu;       // u_dim1 是 U 的第一维的尺寸
u_offset = 1 + u_dim1; // 偏移量用于访问 U 的元素
u -= u_offset;       // 重新定位 U 的指针以匹配给定的维度
vt_dim1 = *ldvt;     // vt_dim1 是 VT 的第一维的尺寸
vt_offset = 1 + vt_dim1; // 偏移量用于访问 VT 的元素
vt -= vt_offset;     // 重新定位 VT 的指针以匹配给定的维度
--iwork;             // iwork 是指向工作数组 IWORK 的指针
--work;              // work 是指向工作数组 WORK 的指针

/* Function Body */
    *info = 0;

# 将指针指向的变量info设置为0，用于存储错误信息码或状态信息


    if (*n < 0) {
    *info = -1;
    } else if (*sqre < 0 || *sqre > 1) {
    *info = -2;
    }

# 检查指针指向的变量n的值是否小于0，若是则将info设为-1；否则，检查sqre的值是否小于0或大于1，若是则将info设为-2


    m = *n + *sqre;

# 计算n和sqre指针指向变量的和，并将结果存入变量m中


    if (*ldu < *n) {
    *info = -6;
    } else if (*ldvt < m) {
    *info = -8;
    } else if (*smlsiz < 3) {
    *info = -9;
    }

# 检查ldu指针指向变量是否小于n指针指向变量，若是则将info设为-6；否则，检查ldvt指针指向变量是否小于m的值，若是则将info设为-8；否则，检查smlsiz指针指向变量是否小于3，若是则将info设为-9


    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DLASD0", &i__1);
    return 0;
    }

# 如果info的值不等于0，则将info取反存入i__1中，并调用xerbla函数进行错误处理，最后返回0
/* 如果输入矩阵尺寸太小，则调用 DLASDQ 执行奇异值分解（SVD）。 */

if (*n <= *smlsiz) {
    dlasdq_("U", sqre, n, &m, n, &c__0, &d__[1], &e[1], &vt[vt_offset],
            ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[1], info);
    return 0;
}

/* 设置计算树结构。 */

inode = 1;
ndiml = inode + *n;
ndimr = ndiml + *n;
idxq = ndimr + *n;
iwk = idxq + *n;
dlasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr], smlsiz);

/*
   对于树的底层节点，通过 DLASDQ 解决它们的子问题。
*/

ndb1 = (nd + 1) / 2;
ncc = 0;
i__1 = nd;
for (i__ = ndb1; i__ <= i__1; ++i__) {

    /*
       IC : 每个节点的中心行
       NL : 左子问题的行数
       NR : 右子问题的行数
       NLF: 左子问题的起始行
       NRF: 右子问题的起始行
    */

    i1 = i__ - 1;
    ic = iwork[inode + i1];
    nl = iwork[ndiml + i1];
    nlp1 = nl + 1;
    nr = iwork[ndimr + i1];
    nrp1 = nr + 1;
    nlf = ic - nl;
    nrf = ic + 1;
    sqrei = 1;
    dlasdq_("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d__[nlf], &e[nlf], &vt[
            nlf + nlf * vt_dim1], ldvt, &u[nlf + nlf * u_dim1], ldu, &u[
            nlf + nlf * u_dim1], ldu, &work[1], info);
    if (*info != 0) {
        return 0;
    }
    itemp = idxq + nlf - 2;
    i__2 = nl;
    for (j = 1; j <= i__2; ++j) {
        iwork[itemp + j] = j;
        /* L10: */
    }
    if (i__ == nd) {
        sqrei = *sqre;
    } else {
        sqrei = 1;
    }
    nrp1 = nr + sqrei;
    dlasdq_("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d__[nrf], &e[nrf], &vt[
            nrf + nrf * vt_dim1], ldvt, &u[nrf + nrf * u_dim1], ldu, &u[
            nrf + nrf * u_dim1], ldu, &work[1], info);
    if (*info != 0) {
        return 0;
    }
    itemp = idxq + ic;
    i__2 = nr;
    for (j = 1; j <= i__2; ++j) {
        iwork[itemp + j - 1] = j;
        /* L20: */
    }
    /* L30: */
}

/* 现在自底向上征服每个子问题。 */

for (lvl = nlvl; lvl >= 1; --lvl) {

    /*
       在当前级别 LVL 找到第一个节点 LF 和最后一个节点 LL。
    */

    if (lvl == 1) {
        lf = 1;
        ll = 1;
    } else {
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);
        ll = (lf << 1) - 1;
    }
    i__1 = ll;
    for (i__ = lf; i__ <= i__1; ++i__) {
        im1 = i__ - 1;
        ic = iwork[inode + im1];
        nl = iwork[ndiml + im1];
        nr = iwork[ndimr + im1];
        nlf = ic - nl;
        if (*sqre == 0 && i__ == ll) {
            sqrei = *sqre;
        } else {
            sqrei = 1;
        }
        idxqc = idxq + nlf - 1;
        alpha = d__[ic];
        beta = e[ic];
        dlasd1_(&nl, &nr, &sqrei, &d__[nlf], &alpha, &beta, &u[nlf + nlf *
                 u_dim1], ldu, &vt[nlf + nlf * vt_dim1], ldvt, &iwork[
                 idxqc], &iwork[iwk], &work[1], info);
        if (*info != 0) {
            return 0;
        }
        /* L40: */
    }
    /* L50: */
}

return 0;
/*     End of DLASD0 */

} /* dlasd0_ */

/* Subroutine */ int dlasd1_(integer *nl, integer *nr, integer *sqre,
    doublereal *d__, doublereal *alpha, doublereal *beta, doublereal *u,
    integer *ldu, doublereal *vt, integer *ldvt, integer *idxq, integer *
    iwork, doublereal *work, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, vt_dim1, vt_offset, i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, k, m, n, n1, n2, iq, iz, iu2, ldq, idx, ldu2, ivt2,
        idxc, idxp, ldvt2;
    extern /* Subroutine */ int dlasd2_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, integer *,
        integer *, integer *, integer *, integer *), dlasd3_(
        integer *, integer *, integer *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, integer *, integer *, doublereal *, integer *);
    static integer isigma;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal orgnrm;
    static integer coltyp;


/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
    where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.

    A related subroutine DLASD7 handles the case in which the singular
    values (and the singular vectors in factored form) are desired.

    DLASD1 computes the SVD as follows:

                  ( D1(in)  0    0     0 )
      B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
                  (   0     0   D2(in) 0 )

        = U(out) * ( D(out) 0) * VT(out)

    where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The left singular vectors of the original matrix are stored in U, and
    the transpose of the right singular vectors are stored in VT, and the
*/

/* Subroutine DLASD1 computes the SVD of an upper bidiagonal matrix B. */

{
    /* Initialize local variables */
    /* Dimensions of matrices */
    n = *nl + *nr + 1; /* Calculate total rows */
    m = n + *sqre; /* Calculate total columns */

    /* Allocate space for temporary arrays */
    iwork[1] = 0; /* Initialize first element of iwork array */

    /* Call LAPACK subroutine DLASD2 for further computation */
    dlasd2_(&n, &m, nl, nr, d__, &alpha[1], &beta[1], u, ldu, vt, ldvt, &
        idxc, &ctemp, &work[1], &iwork[1], info);

    /* Handle errors if any occur */
    if (*info != 0) {
        xerbla_("DLASD1", info);
        return 0;
    }

    /* Scale singular vectors if necessary */
    if (*sqre == 0) {
        dlascl_("G", &c__0, &c__0, &orgnrm, &sigma, &n1, &c__1, u, &ldq,
            info);
        dlascl_("G", &c__0, &c__0, &orgnrm, &sigma, &n2, &c__1, vt, &ldvt,
            info);
    } else {
        dlascl_("G", &c__0, &c__0, &orgnrm, &sigma, &n1, &c__1, u, &ldq,
            info);
        dlascl_("G", &c__0, &c__0, &orgnrm, &sigma, &n2, &c__1, vt, &ldvt,
            info);
    }

    /* Merge the singular values and vectors */
    dlamrg_(&n1, &n2, d__, &sigma, &idx, &iwork[1]);

    /* Apply transformation */
    dlasd3_(&n, &m, nl, nr, d__, &sigma, &u2, vt, &idxq[1], &iq, &n, &k,
        &z, &c_n1, &q, &p, &iwork[1], &iwork[1], &u, &vt, info);

    return 0;
}
    singular values are in D.  The algorithm consists of three stages:

       The first stage consists of deflating the size of the problem
       when there are multiple singular values or when there are zeros in
       the Z vector.  For each such occurence the dimension of the
       secular equation problem is reduced by one.  This stage is
       performed by the routine DLASD2.

       The second stage consists of calculating the updated
       singular values. This is done by finding the square roots of the
       roots of the secular equation via the routine DLASD4 (as called
       by DLASD3). This routine also calculates the singular vectors of
       the current problem.

       The final stage consists of computing the updated singular vectors
       directly using the updated singular values.  The singular vectors
       for the current problem are multiplied with the singular vectors
       from the overall problem.

    Arguments
    =========

    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has row dimension N = NL + NR + 1,
           and column dimension M = N + SQRE.

    D      (input/output) DOUBLE PRECISION array,
                          dimension (N = NL+NR+1).
           On entry D(1:NL,1:NL) contains the singular values of the
           upper block; and D(NL+2:N) contains the singular values of
           the lower block. On exit D(1:N) contains the singular values
           of the modified matrix.

    ALPHA  (input/output) DOUBLE PRECISION
           Contains the diagonal element associated with the added row.

    BETA   (input/output) DOUBLE PRECISION
           Contains the off-diagonal element associated with the added
           row.

    U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
           On entry U(1:NL, 1:NL) contains the left singular vectors of
           the upper block; U(NL+2:N, NL+2:N) contains the left singular
           vectors of the lower block. On exit U contains the left
           singular vectors of the bidiagonal matrix.

    LDU    (input) INTEGER
           The leading dimension of the array U.  LDU >= max( 1, N ).

    VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
           where M = N + SQRE.
           On entry VT(1:NL+1, 1:NL+1)' contains the right singular
           vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
           the right singular vectors of the lower block. On exit
           VT' contains the right singular vectors of the
           bidiagonal matrix.

    LDVT   (input) INTEGER
           The leading dimension of the array VT.  LDVT >= max( 1, M ).
    # IDXQ 是一个输出参数，是整数数组，维度为 N
    # 这个数组包含了将刚刚解决的子问题重新整合回排序顺序的排列，
    # 即 D(IDXQ(I = 1, N)) 将按升序排列。

    # IWORK 是一个工作空间，是整数数组，维度为 4 * N

    # WORK 是一个工作空间，是双精度浮点数数组，维度为 3*M**2 + 2*M

    # INFO 是一个输出参数，是整数
    # = 0: 操作成功完成。
    # < 0: 如果 INFO = -i，则第 i 个参数具有非法值。
    # > 0: 如果 INFO = 1，则某个奇异值未收敛。

    # 进一步细节
    # ===============
    # 本部分基于以下贡献：
    # Ming Gu 和 Huan Ren，加州大学伯克利分校，计算机科学系，美国

    # =====================================================================

    # 测试输入参数。
    /* Parameter adjustments */
    --d__;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    --idxq;
    --iwork;
    --work;

    /* Function Body */
    *info = 0;

    if (*nl < 1) {
        *info = -1;
    } else if (*nr < 1) {
        *info = -2;
    } else if (*sqre < 0 || *sqre > 1) {
        *info = -3;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLASD1", &i__1);
        return 0;
    }

    n = *nl + *nr + 1;
    m = n + *sqre;

/*
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in DLASD2 and DLASD3.
*/

    ldu2 = n;
    ldvt2 = m;

    iz = 1;
    isigma = iz + m;
    iu2 = isigma + n;
    ivt2 = iu2 + ldu2 * n;
    iq = ivt2 + ldvt2 * m;

    idx = 1;
    idxc = idx + n;
    coltyp = idxc + n;
    idxp = coltyp + n;

/*
       Scale.

   Computing MAX
*/
    d__1 = abs(*alpha), d__2 = abs(*beta);
    orgnrm = max(d__1,d__2);
    d__[*nl + 1] = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
        if ((d__1 = d__[i__], abs(d__1)) > orgnrm) {
            orgnrm = (d__1 = d__[i__], abs(d__1));
        }
    }
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &n, &c__1, &d__[1], &n, info);
    *alpha /= orgnrm;
    *beta /= orgnrm;

/*     Deflate singular values. */

    dlasd2_(nl, nr, sqre, &k, &d__[1], &work[iz], alpha, beta, &u[u_offset],
        ldu, &vt[vt_offset], ldvt, &work[isigma], &work[iu2], &ldu2, &
        work[ivt2], &ldvt2, &iwork[idxp], &iwork[idx], &iwork[idxc], &
        idxq[1], &iwork[coltyp], info);

/*     Solve Secular Equation and update singular vectors. */

    ldq = k;
    dlasd3_(nl, nr, sqre, &k, &d__[1], &work[iq], &ldq, &work[isigma], &u[
        u_offset], ldu, &work[iu2], &ldu2, &vt[vt_offset], ldvt, &work[
        ivt2], &ldvt2, &iwork[idxc], &iwork[coltyp], &work[iz], info);
    if (*info != 0) {
        return 0;
    }

/*     Unscale. */

    dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &n, &c__1, &d__[1], &n, info);

/*     Prepare the IDXQ sorting permutation. */

    n1 = k;
    n2 = n - k;
    dlamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &idxq[1]);

    return 0;

/*     End of DLASD1 */

} /* dlasd1_ */

/* Subroutine */ int dlasd2_(integer *nl, integer *nr, integer *sqre, integer
    *k, doublereal *d__, doublereal *z__, doublereal *alpha, doublereal *
    beta, doublereal *u, integer *ldu, doublereal *vt, integer *ldvt,
    doublereal *dsigma, doublereal *u2, integer *ldu2, doublereal *vt2,
    integer *ldvt2, integer *idxp, integer *idx, integer *idxc, integer *
    idxq, integer *coltyp, integer *info)
{
    /* System generated locals */
    integer u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1, vt_offset,
        vt2_dim1, vt2_offset, i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal c__;
    static integer i__, j, m, n;
    # 声明静态变量 s、k2、z1、ct、jp、eps、tau、tol、psm、nlp1、nlp2、idxi、idxj
    static doublereal s;
    static integer k2;
    static doublereal z1;
    static integer ct, jp;
    static doublereal eps, tau, tol;
    static integer psm[4], nlp1, nlp2, idxi, idxj;
    
    # 声明外部子程序 drot_、dcopy_、dlamrg_、dlacpy_、dlaset_、xerbla_
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *);
    extern /* Subroutine */ int dlacpy_(char *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *);
    extern /* Subroutine */ int dlaset_(char *, integer *, integer *, doublereal *,
        doublereal *, doublereal *, integer *);
    extern /* Subroutine */ int xerbla_(char *,
        integer *);
    
    # 声明静态数组 ctot、idxjp
    static integer ctot[4], idxjp;
    
    # 声明静态变量 jprev、hlftol
    static integer jprev;
    static doublereal hlftol;
"""
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASD2 merges the two sets of singular values together into a single
    sorted set.  Then it tries to deflate the size of the problem.
    There are two ways in which deflation can occur:  when two or more
    singular values are close together or if there is a tiny entry in the
    Z vector.  For each such occurrence the order of the related secular
    equation problem is reduced by one.

    DLASD2 is called from DLASD1.

    Arguments
    =========

    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has N = NL + NR + 1 rows and
           M = N + SQRE >= N columns.

    K      (output) INTEGER
           Contains the dimension of the non-deflated matrix,
           This is the order of the related secular equation. 1 <= K <=N.

    D      (input/output) DOUBLE PRECISION array, dimension(N)
           On entry D contains the singular values of the two submatrices
           to be combined.  On exit D contains the trailing (N-K) updated
           singular values (those which were deflated) sorted into
           increasing order.

    Z      (output) DOUBLE PRECISION array, dimension(N)
           On exit Z contains the updating row vector in the secular
           equation.

    ALPHA  (input) DOUBLE PRECISION
           Contains the diagonal element associated with the added row.

    BETA   (input) DOUBLE PRECISION
           Contains the off-diagonal element associated with the added
           row.

    U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
           On entry U contains the left singular vectors of two
           submatrices in the two square blocks with corners at (1,1),
           (NL, NL), and (NL+2, NL+2), (N,N).
           On exit U contains the trailing (N-K) updated left singular
           vectors (those which were deflated) in its last N-K columns.

    LDU    (input) INTEGER
           The leading dimension of the array U.  LDU >= N.

    VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
           On entry VT' contains the right singular vectors of two
           submatrices in the two square blocks with corners at (1,1),
           (NL+1, NL+1), and (NL+2, NL+2), (M,M).
           On exit VT' contains the trailing (N-K) updated right singular
           vectors (those which were deflated) in its last N-K columns.
           In case SQRE =1, the last row of VT spans the right null
           space.
"""
    ! LDVT   (input) INTEGER
           ! The leading dimension of the array VT.  LDVT >= M.

    ! DSIGMA (output) DOUBLE PRECISION array, dimension (N)
           ! Contains a copy of the diagonal elements (K-1 singular values
           ! and one zero) in the secular equation.

    ! U2     (output) DOUBLE PRECISION array, dimension(LDU2,N)
           ! Contains a copy of the first K-1 left singular vectors which
           ! will be used by DLASD3 in a matrix multiply (DGEMM) to solve
           ! for the new left singular vectors. U2 is arranged into four
           ! blocks. The first block contains a column with 1 at NL+1 and
           ! zero everywhere else; the second block contains non-zero
           ! entries only at and above NL; the third contains non-zero
           ! entries only below NL+1; and the fourth is dense.

    ! LDU2   (input) INTEGER
           ! The leading dimension of the array U2.  LDU2 >= N.

    ! VT2    (output) DOUBLE PRECISION array, dimension(LDVT2,N)
           ! VT2' contains a copy of the first K right singular vectors
           ! which will be used by DLASD3 in a matrix multiply (DGEMM) to
           ! solve for the new right singular vectors. VT2 is arranged into
           ! three blocks. The first block contains a row that corresponds
           ! to the special 0 diagonal element in SIGMA; the second block
           ! contains non-zeros only at and before NL +1; the third block
           ! contains non-zeros only at and after  NL +2.

    ! LDVT2  (input) INTEGER
           ! The leading dimension of the array VT2.  LDVT2 >= M.

    ! IDXP   (workspace) INTEGER array dimension(N)
           ! This will contain the permutation used to place deflated
           ! values of D at the end of the array. On output IDXP(2:K)
           ! points to the nondeflated D-values and IDXP(K+1:N)
           ! points to the deflated singular values.

    ! IDX    (workspace) INTEGER array dimension(N)
           ! This will contain the permutation used to sort the contents of
           ! D into ascending order.

    ! IDXC   (output) INTEGER array dimension(N)
           ! This will contain the permutation used to arrange the columns
           ! of the deflated U matrix into three groups:  the first group
           ! contains non-zero entries only at and above NL, the second
           ! contains non-zero entries only below NL+2, and the third is
           ! dense.

    ! IDXQ   (input/output) INTEGER array dimension(N)
           ! This contains the permutation which separately sorts the two
           ! sub-problems in D into ascending order.  Note that entries in
           ! the first half of this permutation must first be moved one
           ! position backward; and entries in the second half
           ! must first have NL+1 added to their values.
    # COLTYP 是一个整数数组，作为工作空间或输出，维度为 N。
    # 该数组用于标识 U2 矩阵中的列或 VT2 矩阵中的行的类型：
    # 1：仅在上半部分非零
    # 2：仅在下半部分非零
    # 3：密集型
    # 4：已缩减
    COLTYP (workspace/output) INTEGER array dimension(N)
           As workspace, this will contain a label which will indicate
           which of the following types a column in the U2 matrix or a
           row in the VT2 matrix is:
           1 : non-zero in the upper half only
           2 : non-zero in the lower half only
           3 : dense
           4 : deflated

           On exit, it is an array of dimension 4, with COLTYP(I) being
           the dimension of the I-th type columns.

    # INFO 是一个输出参数，是一个整数。
    # = 0：成功退出。
    # < 0：如果 INFO = -i，则表示第 i 个参数具有非法值。
    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步细节
    # ===============
    # 根据以下贡献
    # Ming Gu 和 Huan Ren, 加利福尼亚大学伯克利分校，美国计算机科学部门
    Further Details
    ===============

    # 测试输入参数的有效性。
    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;              // 调整参数 d__ 数组
    --z__;              // 调整参数 z__ 数组
    u_dim1 = *ldu;      // 设置 u 的第一维大小
    u_offset = 1 + u_dim1;
    u -= u_offset;      // 调整参数 u 数组

    vt_dim1 = *ldvt;    // 设置 vt 的第一维大小
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;    // 调整参数 vt 数组

    --dsigma;           // 调整参数 dsigma 数组
    u2_dim1 = *ldu2;    // 设置 u2 的第一维大小
    u2_offset = 1 + u2_dim1;
    u2 -= u2_offset;    // 调整参数 u2 数组

    vt2_dim1 = *ldvt2;  // 设置 vt2 的第一维大小
    vt2_offset = 1 + vt2_dim1;
    vt2 -= vt2_offset;  // 调整参数 vt2 数组

    --idxp;             // 调整参数 idxp 数组
    --idx;              // 调整参数 idx 数组
    --idxc;             // 调整参数 idxc 数组
    --idxq;             // 调整参数 idxq 数组
    --coltyp;           // 调整参数 coltyp 数组

    /* Function Body */
    *info = 0;          // 将 info 初始化为 0

    if (*nl < 1) {      // 检查 nl 是否小于 1
    *info = -1;         // 如果是，将 info 设置为 -1
    } else if (*nr < 1) {   // 检查 nr 是否小于 1
    *info = -2;         // 如果是，将 info 设置为 -2
    } else if (*sqre != 1 && *sqre != 0) {    // 检查 sqre 是否为 0 或 1
    *info = -3;         // 如果不是，将 info 设置为 -3
    }

    n = *nl + *nr + 1;  // 计算 n 的值
    m = n + *sqre;      // 计算 m 的值

    if (*ldu < n) {     // 检查 ldu 是否小于 n
    *info = -10;        // 如果是，将 info 设置为 -10
    } else if (*ldvt < m) {     // 检查 ldvt 是否小于 m
    *info = -12;        // 如果是，将 info 设置为 -12
    } else if (*ldu2 < n) {     // 检查 ldu2 是否小于 n
    *info = -15;        // 如果是，将 info 设置为 -15
    } else if (*ldvt2 < m) {    // 检查 ldvt2 是否小于 m
    *info = -17;        // 如果是，将 info 设置为 -17
    }
    if (*info != 0) {   // 如果 info 不等于 0
    i__1 = -(*info);    // 计算 -info
    xerbla_("DLASD2", &i__1);    // 调用 xerbla 函数报错
    return 0;           // 返回 0
    }

    nlp1 = *nl + 1;     // 计算 nl + 1
    nlp2 = *nl + 2;     // 计算 nl + 2

/*
       Generate the first part of the vector Z; and move the singular
       values in the first part of D one position backward.
*/

    z1 = *alpha * vt[nlp1 + nlp1 * vt_dim1];    // 计算 z1
    z__[1] = z1;        // 将 z1 存入 z__ 的第一个位置
    for (i__ = *nl; i__ >= 1; --i__) {   // 循环计算 z__ 和 d__
    z__[i__ + 1] = *alpha * vt[i__ + nlp1 * vt_dim1];   // 计算 z__
    d__[i__ + 1] = d__[i__];    // 将 d__ 向后移动一位
    idxq[i__ + 1] = idxq[i__] + 1;  // 更新 idxq
/* L10: */              // 循环结束
    }

/*     Generate the second part of the vector Z. */

    i__1 = m;            // 循环生成 z__ 的第二部分
    for (i__ = nlp2; i__ <= i__1; ++i__) {
    z__[i__] = *beta * vt[i__ + nlp2 * vt_dim1];   // 计算 z__
/* L20: */              // 循环结束
    }

/*     Initialize some reference arrays. */

    i__1 = nlp1;         // 初始化 coltyp 数组的前半部分
    for (i__ = 2; i__ <= i__1; ++i__) {
    coltyp[i__] = 1;     // 设置 coltyp 的值为 1
/* L30: */              // 循环结束
    }
    i__1 = n;            // 初始化 coltyp 数组的后半部分
    for (i__ = nlp2; i__ <= i__1; ++i__) {
    coltyp[i__] = 2;     // 设置 coltyp 的值为 2
/* L40: */              // 循环结束
    }

/*     Sort the singular values into increasing order */

    i__1 = n;            // 将 singular values 排序为增序
    for (i__ = nlp2; i__ <= i__1; ++i__) {
    idxq[i__] += nlp1;   // 更新 idxq
/* L50: */              // 循环结束
    }

/*
       DSIGMA, IDXC, IDXC, and the first column of U2
       are used as storage space.
*/

    i__1 = n;            // 将 dsigma, idxc, idxc 和 u2 的第一列用作存储空间
    for (i__ = 2; i__ <= i__1; ++i__) {
    dsigma[i__] = d__[idxq[i__]];   // 将 d__ 复制到 dsigma
    u2[i__ + u2_dim1] = z__[idxq[i__]];   // 将 z__ 复制到 u2 的第一列
    idxc[i__] = coltyp[idxq[i__]];  // 更新 idxc
/* L60: */              // 循环结束
    }

    dlamrg_(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);   // 调用 dlamrg 函数排序

    i__1 = n;            // 更新 d__, z__ 和 coltyp
    for (i__ = 2; i__ <= i__1; ++i__) {
    idxi = idx[i__] + 1;    // 计算 idxi
    d__[i__] = dsigma[idxi];    // 更新 d__
    z__[i__] = u2[idxi + u2_dim1];   // 更新 z__
    coltyp[i__] = idxc[idxi];   // 更新 coltyp
/* L70: */              // 循环结束
    }

/*     Calculate the allowable deflation tolerance */

    eps = EPSILON;       // 设置 eps 为 EPSILON
/* Computing MAX */     // 计算最大值
    d__1 = abs(*alpha), d__2 = abs(*beta);
    tol = max(d__1,d__2);   // 计算 alpha 和 beta 的绝对值的最大值
/* Computing MAX */     // 计算最大值
    d__2 = (d__1 = d__[n], abs(d__1));
    tol = eps * 8. * max(d__2,tol);    // 计算公式所需的最大值
/*
   There are 2 kinds of deflation -- first a value in the z-vector
   is small, second two (or more) singular values are very close
   together (their difference is small).

   If the value in the z-vector is small, we simply permute the
   array so that the corresponding singular value is moved to the
   end.

   If two values in the D-vector are close, we perform a two-sided
   rotation designed to make one of the corresponding z-vector
   entries zero, and then permute the array so that the deflated
   singular value is moved to the end.

   If there are multiple singular values then the problem deflates.
   Here the number of equal singular values are found.  As each equal
   singular value is found, an elementary reflector is computed to
   rotate the corresponding singular subspace so that the
   corresponding components of Z are zero in this new basis.
*/

*k = 1; // Initialize the counter k to 1, which tracks the number of singular values
k2 = n + 1; // Initialize k2 to n + 1, used as an index for storing indices of deflated singular values
i__1 = n;
for (j = 2; j <= i__1; ++j) {
if ((d__1 = z__[j], abs(d__1)) <= tol) {

/* Deflate due to small z component. */

--k2; // Decrement k2 to store the index j where z[j] is small
idxp[k2] = j; // Store the index j in idxp array
coltyp[j] = 4; // Mark column j in coltyp array indicating it's deflated
if (j == n) {
goto L120; // If j is the last column, jump to label L120
}
} else {
jprev = j; // Store current j in jprev to handle the case of close singular values
goto L90; // Jump to label L90
}
/* L80: */
}
L90:
j = jprev; // Set j to jprev, handling the continuation after a jump
L100:
++j; // Increment j to process the next column
if (j > n) {
goto L110; // If j exceeds n, jump to label L110 to finish processing
}
if ((d__1 = z__[j], abs(d__1)) <= tol) {

/* Deflate due to small z component. */

--k2; // Decrement k2 to store the index j where z[j] is small
idxp[k2] = j; // Store the index j in idxp array
coltyp[j] = 4; // Mark column j in coltyp array indicating it's deflated
} else {

/* Check if singular values are close enough to allow deflation. */

if ((d__1 = d__[j] - d__[jprev], abs(d__1)) <= tol) {

/* Deflation is possible. */

s = z__[jprev]; // Store z[jprev] in s
c__ = z__[j]; // Store z[j] in c__

/*
   Find sqrt(a**2+b**2) without overflow or
   destructive underflow.
*/

tau = dlapy2_(&c__, &s); // Compute sqrt(c__^2 + s^2) and store in tau
c__ /= tau; // Normalize c__ by tau
s = -s / tau; // Normalize s by -tau (conjugate)

z__[j] = tau; // Store tau back into z[j]
z__[jprev] = 0.; // Set z[jprev] to zero

/*
   Apply back the Givens rotation to the left and right
   singular vector matrices.
*/

idxjp = idxq[idx[jprev] + 1]; // Get index of corresponding vector in u
idxj = idxq[idx[j] + 1]; // Get index of corresponding vector in u
if (idxjp <= nlp1) {
--idxjp; // Adjust index for u if necessary
}
if (idxj <= nlp1) {
--idxj; // Adjust index for u if necessary
}
drot_(&n, &u[idxjp * u_dim1 + 1], &c__1, &u[idxj * u_dim1 + 1], &
    c__1, &c__, &s); // Apply Givens rotation to u
drot_(&m, &vt[idxjp + vt_dim1], ldvt, &vt[idxj + vt_dim1], ldvt, &
    c__, &s); // Apply Givens rotation to vt
if (coltyp[j] != coltyp[jprev]) {
coltyp[j] = 3; // Mark column j as type 3 in coltyp array
}
coltyp[jprev] = 4; // Mark column jprev as type 4 in coltyp array
--k2; // Decrement k2 to store the index jprev in idxp array
idxp[k2] = jprev; // Store jprev in idxp array
jprev = j; // Update jprev to j for next iteration
} else {
++(*k); // Increment k to count another singular value
u2[*k + u2_dim1] = z__[jprev]; // Store z[jprev] in u2 array
dsigma[*k] = d__[jprev]; // Store d[jprev] in dsigma array
idxp[*k] = jprev; // Store jprev in idxp array
jprev = j; // Update jprev to j for next iteration
}
}
goto L100; // Jump back to label L100 to continue iterating through columns
L110:

/* Record the last singular value. */

++(*k); // Increment k to count the last singular value
u2[*k + u2_dim1] = z__[jprev]; // Store z[jprev] in u2 array
dsigma[*k] = d__[jprev]; // Store d[jprev] in dsigma array
idxp[*k] = jprev; // Store jprev in idxp array

L120:
/*
       Count up the total number of the various types of columns, then
       form a permutation which positions the four column types into
       four groups of uniform structure (although one or more of these
       groups may be empty).
*/
for (j = 1; j <= 4; ++j) {
    ctot[j - 1] = 0;
}
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    ct = coltyp[j];
    ++ctot[ct - 1];
}

/*
   PSM(*) = Position in SubMatrix (of types 1 through 4)
*/
psm[0] = 2;
psm[1] = ctot[0] + 2;
psm[2] = psm[1] + ctot[1];
psm[3] = psm[2] + ctot[2];

/*
       Fill out the IDXC array so that the permutation which it induces
       will place all type-1 columns first, all type-2 columns next,
       then all type-3's, and finally all type-4's, starting from the
       second column. This applies similarly to the rows of VT.
*/
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    ct = coltyp[jp];
    idxc[psm[ct - 1]] = j;
    ++psm[ct - 1];
}

/*
       Sort the singular values and corresponding singular vectors into
       DSIGMA, U2, and VT2 respectively.  The singular values/vectors
       which were not deflated go into the first K slots of DSIGMA, U2,
       and VT2 respectively, while those which were deflated go into the
       last N - K slots, except that the first column/row will be treated
       separately.
*/
i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    dsigma[j] = d__[jp];
    idxj = idxq[idx[idxp[idxc[j]]] + 1];
    if (idxj <= nlp1) {
        --idxj;
    }
    dcopy_(&n, &u[idxj * u_dim1 + 1], &c__1, &u2[j * u2_dim1 + 1], &c__1);
    dcopy_(&m, &vt[idxj + vt_dim1], ldvt, &vt2[j + vt2_dim1], ldvt2);
}

/*     Determine DSIGMA(1), DSIGMA(2) and Z(1) */
dsigma[1] = 0.;
hlftol = tol / 2.;
if (abs(dsigma[2]) <= hlftol) {
    dsigma[2] = hlftol;
}
if (m > n) {
    z__[1] = dlapy2_(&z1, &z__[m]);
    if (z__[1] <= tol) {
        c__ = 1.;
        s = 0.;
        z__[1] = tol;
    } else {
        c__ = z1 / z__[1];
        s = z__[m] / z__[1];
    }
} else {
    if (abs(z1) <= tol) {
        z__[1] = tol;
    } else {
        z__[1] = z1;
    }
}

/*     Move the rest of the updating row to Z. */
i__1 = *k - 1;
dcopy_(&i__1, &u2[u2_dim1 + 2], &c__1, &z__[2], &c__1);

/*
       Determine the first column of U2, the first row of VT2 and the
       last row of VT.
*/
dlaset_("A", &n, &c__1, &c_b29, &c_b29, &u2[u2_offset], ldu2);
u2[nlp1 + u2_dim1] = 1.;
if (m > n) {
    i__1 = nlp1;
    for (i__ = 1; i__ <= i__1; ++i__) {
        vt[m + i__ * vt_dim1] = -s * vt[nlp1 + i__ * vt_dim1];
        vt2[i__ * vt2_dim1 + 1] = c__ * vt[nlp1 + i__ * vt_dim1];
    }
    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        vt2[i__ * vt2_dim1 + 1] = s * vt[m + i__ * vt_dim1];
        vt[m + i__ * vt_dim1] = c__ * vt[m + i__ * vt_dim1];
    }
} else {
    # 调用外部函数 dcopy_ 复制矩阵数据，将 vt 的部分行复制到 vt2 的对应位置
    dcopy_(&m, &vt[nlp1 + vt_dim1], ldvt, &vt2[vt2_dim1 + 1], ldvt2);
    }
    # 如果 m 大于 n，则继续执行下面的条件语句块
    if (m > n) {
    # 调用外部函数 dcopy_ 复制矩阵数据，将 vt 的剩余部分行复制到 vt2 的对应位置
    dcopy_(&m, &vt[m + vt_dim1], ldvt, &vt2[m + vt2_dim1], ldvt2);
    }
/*
       The deflated singular values and their corresponding vectors go
       into the back of D, U, and V respectively.
*/
if (n > *k) {
    // Calculate the number of deflated singular values
    i__1 = n - *k;
    // Copy deflated singular values from dsigma to d__
    dcopy_(&i__1, &dsigma[*k + 1], &c__1, &d__[*k + 1], &c__1);
    // Copy corresponding columns of U2 to U
    i__1 = n - *k;
    dlacpy_("A", &n, &i__1, &u2[(*k + 1) * u2_dim1 + 1], ldu2, &u[(*k + 1) * u_dim1 + 1], ldu);
    // Copy corresponding rows of VT2 to VT
    i__1 = n - *k;
    dlacpy_("A", &i__1, &m, &vt2[*k + 1 + vt2_dim1], ldvt2, &vt[*k + 1 + vt_dim1], ldvt);
}

/*     Copy CTOT into COLTYP for referencing in DLASD3. */
for (j = 1; j <= 4; ++j) {
    // Copy elements from CTOT to COLTYP
    coltyp[j] = ctot[j - 1];
    // Loop L190: No operation
}

return 0;

/*     End of DLASD2 */
} /* dlasd2_ */

/* Subroutine */ int dlasd3_(integer *nl, integer *nr, integer *sqre, integer *k,
    doublereal *d__, doublereal *q, integer *ldq, doublereal *dsigma,
    doublereal *u, integer *ldu, doublereal *u2, integer *ldu2,
    doublereal *vt, integer *ldvt, doublereal *vt2, integer *ldvt2,
    integer *idxc, integer *ctot, doublereal *z__, integer *info)
{
/* System generated locals */
integer q_dim1, q_offset, u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1,
    vt_offset, vt2_dim1, vt2_offset, i__1, i__2;
doublereal d__1, d__2;

/* Local variables */
static integer i__, j, m, n, jc;
static doublereal rho;
static integer nlp1, nlp2, nrp1;
static doublereal temp;
extern doublereal dnrm2_(integer *, doublereal *, integer *);
extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
    integer *, doublereal *, doublereal *, integer *, doublereal *,
    integer *, doublereal *, doublereal *, integer *);
static integer ctemp;
extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
    doublereal *, integer *);
static integer ktemp;
extern doublereal dlamc3_(doublereal *, doublereal *);
extern /* Subroutine */ int dlasd4_(integer *, integer *, doublereal *,
    doublereal *, doublereal *, doublereal *, doublereal *,
    doublereal *, integer *), dlascl_(char *, integer *, integer *,
    doublereal *, doublereal *, integer *, integer *, doublereal *,
    integer *, integer *), dlacpy_(char *, integer *, integer
    *, doublereal *, integer *, doublereal *, integer *),
    xerbla_(char *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010

    Purpose
    =======

    DLASD3 finds all the square roots of the roots of the secular
    equation, as defined by the values in D and Z.  It makes the
    appropriate calls to DLASD4 and then updates the singular
    vectors by matrix multiplication.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
*/
    which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    DLASD3 is called from DLASD1.

    Arguments
    =========

    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.
    对于上部分块的行维度，NL 必须大于等于1。

    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.
    对于下部分块的行维度，NR 必须大于等于1。

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has N = NL + NR + 1 rows and
           M = N + SQRE >= N columns.
    = 0: 下部分块是一个NR × NR的方阵。
    = 1: 下部分块是一个NR × (NR+1)的矩形矩阵。

           双对角矩阵有N = NL + NR + 1行和M = N + SQRE列。

    K      (input) INTEGER
           The size of the secular equation, 1 =< K = < N.
    积分方程的大小，1 <= K <= N。

    D      (output) DOUBLE PRECISION array, dimension(K)
           On exit the square roots of the roots of the secular equation,
           in ascending order.
    在退出时，这是积分方程根的平方根，按升序排列。

    Q      (workspace) DOUBLE PRECISION array,
                       dimension at least (LDQ,K).

    LDQ    (input) INTEGER
           The leading dimension of the array Q.  LDQ >= K.
    数组Q的领先维度。LDQ必须大于等于K。

    DSIGMA (input) DOUBLE PRECISION array, dimension(K)
           The first K elements of this array contain the old roots
           of the deflated updating problem.  These are the poles
           of the secular equation.
    数组DSIGMA的前K个元素包含了缩小更新问题的旧根。这些是积分方程的极点。

    U      (output) DOUBLE PRECISION array, dimension (LDU, N)
           The last N - K columns of this matrix contain the deflated
           left singular vectors.
    矩阵的最后N-K列包含了缩小的左奇异向量。

    LDU    (input) INTEGER
           The leading dimension of the array U.  LDU >= N.
    数组U的领先维度。LDU必须大于等于N。

    U2     (input/output) DOUBLE PRECISION array, dimension (LDU2, N)
           The first K columns of this matrix contain the non-deflated
           left singular vectors for the split problem.
    矩阵的前K列包含了分裂问题的非缩小左奇异向量。

    LDU2   (input) INTEGER
           The leading dimension of the array U2.  LDU2 >= N.
    数组U2的领先维度。LDU2必须大于等于N。

    VT     (output) DOUBLE PRECISION array, dimension (LDVT, M)
           The last M - K columns of VT' contain the deflated
           right singular vectors.
    VT'的最后M-K列包含了缩小的右奇异向量。

    LDVT   (input) INTEGER
           The leading dimension of the array VT.  LDVT >= N.
    数组VT的领先维度。LDVT必须大于等于N。

    VT2    (input/output) DOUBLE PRECISION array, dimension (LDVT2, N)
           The first K columns of VT2' contain the non-deflated
           right singular vectors for the split problem.
    VT2'的前K列包含了分裂问题的非缩小右奇异向量。

    LDVT2  (input) INTEGER
           The leading dimension of the array VT2.  LDVT2 >= N.
    数组VT2的领先维度。LDVT2必须大于等于N。
    # IDXC是一个整数数组，用于指定如何排列矩阵U的列（以及VT的行）分成三组：
    # 第一组仅包含在NL+1及其以上（或之前）位置有非零元素的列；
    # 第二组仅包含在NL+2及其以下（或之后）位置有非零元素的列；
    # 第三组是密集的。但是，U的第一列和VT的行被单独处理。
    # 在DLASD4找到的奇异向量的行在矩阵乘法发生之前也必须进行同样的置换。

    # CTOT是一个整数数组，大小为4，用于计算U中各种类型列（或VT中的行）的总数。
    # 这些类型如IDXC所述。第四种列类型是任何已经被排除的列。

    # Z是一个双精度数组，大小为K，其中前K个元素包含调整后的更新行向量的分量。

    # INFO是一个整数输出参数：
    # = 0：成功退出。
    # < 0：如果INFO = -i，则第i个参数具有非法值。
    # > 0：如果INFO = 1，则某个奇异值未收敛。

    # 进一步的细节：
    # 根据Ming Gu和Huan Ren在美国加州大学伯克利分校计算机科学系的贡献。

    # 测试输入参数。
    /* Parameter adjustments */
    --d__;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --dsigma;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    u2_dim1 = *ldu2;
    u2_offset = 1 + u2_dim1;
    u2 -= u2_offset;
    vt_dim1 = *ldvt;
    vt_offset = 1 + vt_dim1;
    vt -= vt_offset;
    vt2_dim1 = *ldvt2;
    vt2_offset = 1 + vt2_dim1;
    vt2 -= vt2_offset;
    --idxc;
    --ctot;
    --z__;

    /* Function Body */
    *info = 0;

    if (*nl < 1) {
        *info = -1;
    } else if (*nr < 1) {
        *info = -2;
    } else if (*sqre != 1 && *sqre != 0) {
        *info = -3;
    }

    n = *nl + *nr + 1;
    m = n + *sqre;
    nlp1 = *nl + 1;
    nlp2 = *nl + 2;

    if (*k < 1 || *k > n) {
        *info = -4;
    } else if (*ldq < *k) {
        *info = -7;
    } else if (*ldu < n) {
        *info = -10;
    } else if (*ldu2 < n) {
        *info = -12;
    } else if (*ldvt < m) {
        *info = -14;
    } else if (*ldvt2 < m) {
        *info = -16;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLASD3", &i__1);
        return 0;
    }

/*     Quick return if possible */

    if (*k == 1) {
        d__[1] = abs(z__[1]);
        dcopy_(&m, &vt2[vt2_dim1 + 1], ldvt2, &vt[vt_dim1 + 1], ldvt);
        if (z__[1] > 0.) {
            dcopy_(&n, &u2[u2_dim1 + 1], &c__1, &u[u_dim1 + 1], &c__1);
        } else {
            i__1 = n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                u[i__ + u_dim1] = -u2[i__ + u2_dim1];
                /* Negate the singular vectors in 'u' if 'z__' is negative */
/* L10: */
            }
        }
        return 0;
    }

/*
       Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
       which on any of these machines zeros out the bottommost
       bit of DSIGMA(I) if it is 1; this makes the subsequent
       subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DSIGMA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DSIGMA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DSIGMA(I) to prevent optimizing compilers from eliminating
       this code.
*/

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dsigma[i__] = dlamc3_(&dsigma[i__], &dsigma[i__]) - dsigma[i__];
        /* Adjust DSIGMA(i) to improve numerical accuracy for subsequent computations */
/* L20: */
    }

/*     Keep a copy of Z. */

    dcopy_(k, &z__[1], &c__1, &q[q_offset], &c__1);
    /* Copy z__ into q for further manipulation */

/*     Normalize Z. */

    rho = dnrm2_(k, &z__[1], &c__1);
    /* Compute the 2-norm of z__ */
    dlascl_("G", &c__0, &c__0, &rho, &c_b15, k, &c__1, &z__[1], k, info);
    /* Scale z__ to have norm 'rho' */
    rho *= rho;
    /* Square rho for further use */

/*     Find the new singular values. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        /* Loop over singular values */
    // 调用名为 dlasd4_ 的函数，传入以下参数：
    // k - 整数类型的指针，指向变量 k 的地址
    // &j - 整数类型的指针，指向变量 j 的地址
    // &dsigma[1] - 双精度浮点数组 dsigma 的第二个元素的地址（数组从1开始索引）
    // &z__[1] - 双精度浮点数组 z__ 的第二个元素的地址（数组从1开始索引）
    // &u[j * u_dim1 + 1] - 双精度浮点二维数组 u 中第 j 行第一列元素的地址（行列索引从1开始）
    // &rho - 双精度浮点数 rho 的地址
    // &d__[j] - 双精度浮点数组 d__ 中第 j 个元素的地址
    // &vt[j * vt_dim1 + 1] - 双精度浮点二维数组 vt 中第 j 行第一列元素的地址（行列索引从1开始）
    // info - 整数类型的指针，指向变量 info 的地址
    dlasd4_(k, &j, &dsigma[1], &z__[1], &u[j * u_dim1 + 1], &rho, &d__[j], &vt[j * vt_dim1 + 1], info);
/*        If the zero finder fails, the computation is terminated. */

if (*info != 0) {
    return 0;
}
/* L30: */
}

/*     Compute updated Z. */

i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
z__[i__] = u[i__ + *k * u_dim1] * vt[i__ + *k * vt_dim1];
i__2 = i__ - 1;
for (j = 1; j <= i__2; ++j) {
    z__[i__] *= u[i__ + j * u_dim1] * vt[i__ + j * vt_dim1] / (dsigma[
        i__] - dsigma[j]) / (dsigma[i__] + dsigma[j]);
/* L40: */
}
i__2 = *k - 1;
for (j = i__; j <= i__2; ++j) {
    z__[i__] *= u[i__ + j * u_dim1] * vt[i__ + j * vt_dim1] / (dsigma[
        i__] - dsigma[j + 1]) / (dsigma[i__] + dsigma[j + 1]);
/* L50: */
}
d__2 = sqrt((d__1 = z__[i__], abs(d__1)));
z__[i__] = d_sign(&d__2, &q[i__ + q_dim1]);
/* L60: */
}

/*
   Compute left singular vectors of the modified diagonal matrix,
   and store related information for the right singular vectors.
*/

i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
vt[i__ * vt_dim1 + 1] = z__[1] / u[i__ * u_dim1 + 1] / vt[i__ *
    vt_dim1 + 1];
u[i__ * u_dim1 + 1] = -1.;
i__2 = *k;
for (j = 2; j <= i__2; ++j) {
    vt[j + i__ * vt_dim1] = z__[j] / u[j + i__ * u_dim1] / vt[j + i__
        * vt_dim1];
    u[j + i__ * u_dim1] = dsigma[j] * vt[j + i__ * vt_dim1];
/* L70: */
}
temp = dnrm2_(k, &u[i__ * u_dim1 + 1], &c__1);
q[i__ * q_dim1 + 1] = u[i__ * u_dim1 + 1] / temp;
i__2 = *k;
for (j = 2; j <= i__2; ++j) {
    jc = idxc[j];
    q[j + i__ * q_dim1] = u[jc + i__ * u_dim1] / temp;
/* L80: */
}
/* L90: */
}

/*     Update the left singular vector matrix. */

if (*k == 2) {
dgemm_("N", "N", &n, k, k, &c_b15, &u2[u2_offset], ldu2, &q[q_offset],
     ldq, &c_b29, &u[u_offset], ldu);
goto L100;
}
if (ctot[1] > 0) {
dgemm_("N", "N", nl, k, &ctot[1], &c_b15, &u2[(u2_dim1 << 1) + 1],
    ldu2, &q[q_dim1 + 2], ldq, &c_b29, &u[u_dim1 + 1], ldu);
if (ctot[3] > 0) {
    ktemp = ctot[1] + 2 + ctot[2];
    dgemm_("N", "N", nl, k, &ctot[3], &c_b15, &u2[ktemp * u2_dim1 + 1]
        , ldu2, &q[ktemp + q_dim1], ldq, &c_b15, &u[u_dim1 + 1],
        ldu);
}
} else if (ctot[3] > 0) {
ktemp = ctot[1] + 2 + ctot[2];
dgemm_("N", "N", nl, k, &ctot[3], &c_b15, &u2[ktemp * u2_dim1 + 1],
    ldu2, &q[ktemp + q_dim1], ldq, &c_b29, &u[u_dim1 + 1], ldu);
} else {
dlacpy_("F", nl, k, &u2[u2_offset], ldu2, &u[u_offset], ldu);
}
dcopy_(k, &q[q_dim1 + 1], ldq, &u[nlp1 + u_dim1], ldu);
ktemp = ctot[1] + 2;
ctemp = ctot[2] + ctot[3];
dgemm_("N", "N", nr, k, &ctemp, &c_b15, &u2[nlp2 + ktemp * u2_dim1], ldu2,
     &q[ktemp + q_dim1], ldq, &c_b29, &u[nlp2 + u_dim1], ldu);

/*     Generate the right singular vectors. */

L100:
i__1 = *k;
for (i__ = 1; i__ <= i__1; ++i__) {
temp = dnrm2_(k, &vt[i__ * vt_dim1 + 1], &c__1);
q[i__ + q_dim1] = vt[i__ * vt_dim1 + 1] / temp;
    i__2 = *k;
    # 从指针 k 中读取值，赋给 i__2，这里可能是某种索引或计数器
    for (j = 2; j <= i__2; ++j) {
        # 循环 j 从 2 到 i__2
        jc = idxc[j];
        # 从数组 idxc 中取出索引 j 对应的值，赋给 jc
        q[i__ + j * q_dim1] = vt[jc + i__ * vt_dim1] / temp;
        # 计算并赋值给 q 数组的元素，使用 vt 和 temp 进行一些数学操作
/* L110: */
    }
/* L120: */
    }

/*     Update the right singular vector matrix. */

    if (*k == 2) {
    dgemm_("N", "N", k, &m, k, &c_b15, &q[q_offset], ldq, &vt2[vt2_offset]
        , ldvt2, &c_b29, &vt[vt_offset], ldvt);
    return 0;
    }
    ktemp = ctot[1] + 1;
    dgemm_("N", "N", k, &nlp1, &ktemp, &c_b15, &q[q_dim1 + 1], ldq, &vt2[
        vt2_dim1 + 1], ldvt2, &c_b29, &vt[vt_dim1 + 1], ldvt);
    ktemp = ctot[1] + 2 + ctot[2];
    if (ktemp <= *ldvt2) {
    dgemm_("N", "N", k, &nlp1, &ctot[3], &c_b15, &q[ktemp * q_dim1 + 1],
        ldq, &vt2[ktemp + vt2_dim1], ldvt2, &c_b15, &vt[vt_dim1 + 1],
        ldvt);
    }

    ktemp = ctot[1] + 1;
    nrp1 = *nr + *sqre;
    if (ktemp > 1) {
    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        q[i__ + ktemp * q_dim1] = q[i__ + q_dim1];
/* L130: */
    }
    i__1 = m;
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        vt2[ktemp + i__ * vt2_dim1] = vt2[i__ * vt2_dim1 + 1];
/* L140: */
    }
    }
    ctemp = ctot[2] + 1 + ctot[3];
    dgemm_("N", "N", k, &nrp1, &ctemp, &c_b15, &q[ktemp * q_dim1 + 1], ldq, &
        vt2[ktemp + nlp2 * vt2_dim1], ldvt2, &c_b29, &vt[nlp2 * vt_dim1 +
        1], ldvt);

    return 0;

/*     End of DLASD3 */

} /* dlasd3_ */

/* Subroutine */ int dlasd4_(integer *n, integer *i__, doublereal *d__,
    doublereal *z__, doublereal *delta, doublereal *rho, doublereal *
    sigma, doublereal *work, integer *info)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    static doublereal a, b, c__;
    static integer j;
    static doublereal w, dd[3];
    static integer ii;
    static doublereal dw, zz[3];
    static integer ip1;
    static doublereal eta, phi, eps, tau, psi;
    static integer iim1, iip1;
    static doublereal dphi, dpsi;
    static integer iter;
    static doublereal temp, prew, sg2lb, sg2ub, temp1, temp2, dtiim, delsq,
        dtiip;
    static integer niter;
    static doublereal dtisq;
    static logical swtch;
    static doublereal dtnsq;
    extern /* Subroutine */ int dlaed6_(integer *, logical *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *)
        , dlasd5_(integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);
    static doublereal delsq2, dtnsq1;
    static logical swtch3;

    static logical orgati;
    static doublereal erretm, dtipsq, rhoinv;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    This subroutine computes the square root of the I-th updated
    eigenvalue of a positive symmetric rank-one modification to
    a positive diagonal matrix whose entries are given as the squares
    of the corresponding entries in the array d, and that

           0 <= D(i) < D(j)  for  i < j
    # 由于调用程序已经确保 N > 0 和 RHO > 0，所以不会出现特殊情况。
    # 这里描述的是一个一阶修正系统，其形式为 diag( D ) * diag( D ) + RHO * Z * Z_transpose。
    # 假设 Z 的欧几里德范数为 1。

    # 该方法的核心是通过简单的插值有理函数来逼近主元方程中的有理函数。

    # Arguments
    # =========

    # N      (input) INTEGER
    #        所有数组的长度。

    # I      (input) INTEGER
    #        要计算的特征值的索引。1 <= I <= N。

    # D      (input) DOUBLE PRECISION array, dimension ( N )
    #        原始特征值数组。假定它们按顺序排列，即对于 I < J，有 0 <= D(I) < D(J)。

    # Z      (input) DOUBLE PRECISION array, dimension ( N )
    #        更新向量的分量。

    # DELTA  (output) DOUBLE PRECISION array, dimension ( N )
    #        如果 N ≠ 1，则 DELTA 的第 j 个分量包含 (D(j) - sigma_I)。如果 N = 1，则 DELTA(1) = 1。
    #        向量 DELTA 包含构造（奇异的）特征向量所需的信息。

    # RHO    (input) DOUBLE PRECISION
    #        对称更新公式中的标量。

    # SIGMA  (output) DOUBLE PRECISION
    #        计算得到的 sigma_I，即第 I 个更新后的特征值。

    # WORK   (workspace) DOUBLE PRECISION array, dimension ( N )
    #        如果 N ≠ 1，则 WORK 的第 j 个分量包含 (D(j) + sigma_I)。如果 N = 1，则 WORK( 1 ) = 1。

    # INFO   (output) INTEGER
    #        = 0: 成功退出
    #        > 0: 如果 INFO = 1，更新过程失败。

    # Internal Parameters
    # ===================

    # 逻辑变量 ORGATI (origin-at-i?) 用于区分是否将 D(i) 或 D(i+1) 视为原点。
    #           ORGATI = .true.    原点在 i 处
    #           ORGATI = .false.   原点在 i+1 处

    # 逻辑变量 SWTCH3 (switch-for-3-poles?) 用于指示是否正在处理三个极点！

    # MAXIT 是每个特征值允许的最大迭代次数。

    # Further Details
    # ===============

    # 基于以下贡献
    #    Ren-Cang Li, Computer Science Division, University of California
    #    at Berkeley, USA
    /* Parameter adjustments */
    --work;  // 调整工作数组的指针，使其指向数组 work 的第一个元素
    --delta; // 调整 delta 数组的指针，使其指向数组 delta 的第一个元素
    --z__;   // 调整 z__ 数组的指针，使其指向数组 z__ 的第一个元素
    --d__;   // 调整 d__ 数组的指针，使其指向数组 d__ 的第一个元素

    /* Function Body */
    *info = 0;  // 将 info 的值设为 0
    if (*n == 1) {

/*        Presumably, I=1 upon entry */

        *sigma = sqrt(d__[1] * d__[1] + *rho * z__[1] * z__[1]);  // 计算 sigma 值
        delta[1] = 1.;  // 设置 delta[1] 为 1
        work[1] = 1.;   // 设置 work[1] 为 1
        return 0;   // 返回 0 表示成功
    }
    if (*n == 2) {
        dlasd5_(i__, &d__[1], &z__[1], &delta[1], rho, sigma, &work[1]);  // 调用 dlasd5_ 函数
        return 0;   // 返回 0 表示成功
    }

/*     Compute machine epsilon */

    eps = EPSILON;  // 计算机器 epsilon 的值
    rhoinv = 1. / *rho;  // 计算 rho 的倒数

/*     The case I = N */

    if (*i__ == *n) {

/*        Initialize some basic variables */

        ii = *n - 1;  // 初始化 ii 为 n-1
        niter = 1;    // 初始化 niter 为 1

/*        Calculate initial guess */

        temp = *rho / 2.;  // 计算 temp 的初始值

/*
          If ||Z||_2 is not one, then TEMP should be set to
          RHO * ||Z||_2^2 / TWO
*/

        temp1 = temp / (d__[*n] + sqrt(d__[*n] * d__[*n] + temp));  // 计算 temp1 的值
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[*n] + temp1;  // 计算 work[j] 的值
            delta[j] = d__[j] - d__[*n] - temp1; // 计算 delta[j] 的值
/* L10: */       // 循环结束标签 L10
        }

        psi = 0.;   // 初始化 psi 为 0
        i__1 = *n - 2;
        for (j = 1; j <= i__1; ++j) {
            psi += z__[j] * z__[j] / (delta[j] * work[j]);  // 计算 psi 的值
/* L20: */       // 循环结束标签 L20
        }

        c__ = rhoinv + psi;  // 计算 c__ 的值
        w = c__ + z__[ii] * z__[ii] / (delta[ii] * work[ii]) + z__[*n] * z__[*n] / (delta[*n] * work[*n]);  // 计算 w 的值

        if (w <= 0.) {
            temp1 = sqrt(d__[*n] * d__[*n] + *rho);  // 计算 temp1 的值
            temp = z__[*n - 1] * z__[*n - 1] / ((d__[*n - 1] + temp1) * (d__[*n] - d__[*n - 1] + *rho / (d__[*n] + temp1))) + z__[*n] * z__[*n] / *rho;  // 计算 temp 的值

/*
             The following TAU is to approximate
             SIGMA_n^2 - D( N )*D( N )
*/

            if (c__ <= temp) {
                tau = *rho;  // 计算 tau 的值
            } else {
                delsq = (d__[*n] - d__[*n - 1]) * (d__[*n] + d__[*n - 1]);  // 计算 delsq 的值
                a = -c__ * delsq + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];  // 计算 a 的值
                b = z__[*n] * z__[*n] * delsq;  // 计算 b 的值
                if (a < 0.) {
                    tau = b * 2. / (sqrt(a * a + b * 4. * c__) - a);  // 计算 tau 的值
                } else {
                    tau = (a + sqrt(a * a + b * 4. * c__)) / (c__ * 2.);  // 计算 tau 的值
                }
            }

/*
             It can be proved that
                 D(N)^2+RHO/2 <= SIGMA_n^2 < D(N)^2+TAU <= D(N)^2+RHO
*/

        } else {
            delsq = (d__[*n] - d__[*n - 1]) * (d__[*n] + d__[*n - 1]);  // 计算 delsq 的值
            a = -c__ * delsq + z__[*n - 1] * z__[*n - 1] + z__[*n] * z__[*n];  // 计算 a 的值
            b = z__[*n] * z__[*n] * delsq;  // 计算 b 的值

/*
             The following TAU is to approximate
             SIGMA_n^2 - D( N )*D( N )
*/

            if (a < 0.) {
                tau = b * 2. / (sqrt(a * a + b * 4. * c__) - a);  // 计算 tau 的值
            } else {
                tau = (a + sqrt(a * a + b * 4. * c__)) / (c__ * 2.);  // 计算 tau 的值
            }

/*
             It can be proved that
             D(N)^2 < D(N)^2+TAU < SIGMA(N)^2 < D(N)^2+RHO/2
*/

        }

/*        The following ETA is to approximate SIGMA_n - D( N ) */

        eta = tau / (d__[*n] + sqrt(d__[*n] * d__[*n] + tau));  // 计算 eta 的值

        *sigma = d__[*n] + eta;  // 计算 sigma 的值
        i__1 = *n;  // 将 i__1 设为 n
    # 对于循环变量 j，从 1 到 i__1 进行迭代
    for (j = 1; j <= i__1; ++j) {
        # 计算 delta 数组的第 j 个元素
        delta[j] = d__[j] - d__[*i__] - eta;
        # 计算 work 数组的第 j 个元素
        work[j] = d__[j] + d__[*i__] + eta;
/* L30: */
    }

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.;
    psi = 0.;
    erretm = 0.;
    i__1 = ii;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (delta[j] * work[j]);
        psi += z__[j] * temp;  // 计算 PSI
        dpsi += temp * temp;   // 计算 DPSI
        erretm += psi;         // 累加用于误差估计的值
/* L40: */
    }
    erretm = abs(erretm);  // 取误差估计的绝对值

/*        Evaluate PHI and the derivative DPHI */

    temp = z__[*n] / (delta[*n] * work[*n]);
    phi = z__[*n] * temp;    // 计算 PHI
    dphi = temp * temp;      // 计算 DPHI
    erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (dpsi
        + dphi);             // 更新误差估计

    w = rhoinv + phi + psi;  // 计算变量 w

/*        Test for convergence */

    if (abs(w) <= eps * erretm) {  // 检查是否收敛
        goto L240;
    }

/*        Calculate the new step */

    ++niter;
    dtnsq1 = work[*n - 1] * delta[*n - 1];
    dtnsq = work[*n] * delta[*n];
    c__ = w - dtnsq1 * dpsi - dtnsq * dphi;  // 计算 c__
    a = (dtnsq + dtnsq1) * w - dtnsq * dtnsq1 * (dpsi + dphi);  // 计算 a
    b = dtnsq * dtnsq1 * w;  // 计算 b
    if (c__ < 0.) {
        c__ = abs(c__);  // 取 c__ 的绝对值
    }
    if (c__ == 0.) {
        eta = *rho - *sigma * *sigma;  // 根据条件计算 eta
    } else if (a >= 0.) {
        eta = (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (c__
            * 2.);  // 计算 eta
    } else {
        eta = b * 2. / (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))
            );  // 计算 eta
    }

/*
          Note, eta should be positive if w is negative, and
          eta should be negative otherwise. However,
          if for some reason caused by roundoff, eta*w > 0,
          we simply use one Newton step instead. This way
          will guarantee eta*w < 0.
*/

    if (w * eta > 0.) {
        eta = -w / (dpsi + dphi);  // 根据条件调整 eta
    }
    temp = eta - dtnsq;
    if (temp > *rho) {
        eta = *rho + dtnsq;  // 根据条件调整 eta
    }

    tau += eta;  // 更新 tau
    eta /= *sigma + sqrt(eta + *sigma * *sigma);  // 计算 eta 的值
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        delta[j] -= eta;  // 更新 delta 数组的值
        work[j] += eta;   // 更新 work 数组的值
/* L50: */
    }

    *sigma += eta;  // 更新 sigma

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.;
    psi = 0.;
    erretm = 0.;
    i__1 = ii;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (work[j] * delta[j]);
        psi += z__[j] * temp;  // 计算 PSI
        dpsi += temp * temp;   // 计算 DPSI
        erretm += psi;         // 累加用于误差估计的值
/* L60: */
    }
    erretm = abs(erretm);  // 取误差估计的绝对值

/*        Evaluate PHI and the derivative DPHI */

    temp = z__[*n] / (work[*n] * delta[*n]);
    phi = z__[*n] * temp;    // 计算 PHI
    dphi = temp * temp;      // 计算 DPHI
    erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (dpsi
        + dphi);             // 更新误差估计

    w = rhoinv + phi + psi;  // 计算变量 w

/*        Main loop to update the values of the array   DELTA */

    iter = niter + 1;

    for (niter = iter; niter <= 20; ++niter) {

/*           Test for convergence */

        if (abs(w) <= eps * erretm) {
        goto L240;
        }

        if (abs(w) <= eps * erretm) {  // 检查是否收敛
        goto L240;
        }


注释：
/*           Calculate the new step */

/* 计算新的步长 */

        dtnsq1 = work[*n - 1] * delta[*n - 1];
/* 计算 dtnsq1 */

        dtnsq = work[*n] * delta[*n];
/* 计算 dtnsq */

        c__ = w - dtnsq1 * dpsi - dtnsq * dphi;
/* 计算 c__ */

        a = (dtnsq + dtnsq1) * w - dtnsq1 * dtnsq * (dpsi + dphi);
/* 计算 a */

        b = dtnsq1 * dtnsq * w;
/* 计算 b */

        if (a >= 0.) {
/* 如果 a >= 0 */

        eta = (a + sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
            c__ * 2.);
/* 计算 eta，根据公式选择正的根 */

        } else {
/* 否则 */

        eta = b * 2. / (a - sqrt((d__1 = a * a - b * 4. * c__, abs(
            d__1))));
/* 计算 eta，根据公式选择负的根 */

        }

/*
             Note, eta should be positive if w is negative, and
             eta should be negative otherwise. However,
             if for some reason caused by roundoff, eta*w > 0,
             we simply use one Newton step instead. This way
             will guarantee eta*w < 0.
*/

/* 注意，如果 w 是负数，eta 应该是正数，否则应该是负数。但是，如果由于舍入误差的原因，eta*w > 0，
   我们简单地使用一个牛顿步骤。这样可以确保 eta*w < 0。 */

        if (w * eta > 0.) {
/* 如果 w * eta > 0 */

        eta = -w / (dpsi + dphi);
/* 使用一个牛顿步骤修正 eta */

        }

        temp = eta - dtnsq;
/* 计算 temp */

        if (temp <= 0.) {
/* 如果 temp <= 0 */

        eta /= 2.;
/* 将 eta 减半 */

        }

        tau += eta;
/* 更新 tau */

        eta /= *sigma + sqrt(eta + *sigma * *sigma);
/* 计算 eta 并归一化 */

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
/* 循环更新 delta 和 work */

        delta[j] -= eta;
/* 更新 delta */

        work[j] += eta;
/* 更新 work */

/* L70: */
        }

        *sigma += eta;
/* 更新 sigma */

/*           Evaluate PSI and the derivative DPSI */

/* 计算 PSI 和其导数 DPSI */

        dpsi = 0.;
/* 初始化 dpsi */

        psi = 0.;
/* 初始化 psi */

        erretm = 0.;
/* 初始化 erretm */

        i__1 = ii;
        for (j = 1; j <= i__1; ++j) {
/* 循环计算 psi, dpsi 和 erretm */

        temp = z__[j] / (work[j] * delta[j]);
/* 计算临时变量 temp */

        psi += z__[j] * temp;
/* 更新 psi */

        dpsi += temp * temp;
/* 更新 dpsi */

        erretm += psi;
/* 更新 erretm */

/* L80: */
        }

        erretm = abs(erretm);
/* 取 erretm 的绝对值 */

/*           Evaluate PHI and the derivative DPHI */

/* 计算 PHI 和其导数 DPHI */

        temp = z__[*n] / (work[*n] * delta[*n]);
/* 计算临时变量 temp */

        phi = z__[*n] * temp;
/* 计算 phi */

        dphi = temp * temp;
/* 计算 dphi */

        erretm = (-phi - psi) * 8. + erretm - phi + rhoinv + abs(tau) * (
            dpsi + dphi);
/* 更新 erretm */

        w = rhoinv + phi + psi;
/* 更新 w */

/* L90: */
    }

/*        Return with INFO = 1, NITER = MAXIT and not converged */

/* 返回 INFO = 1, NITER = MAXIT 表示迭代次数已达最大但未收敛 */

    *info = 1;
/* 设置 info 为 1 */

    goto L240;

/*        End for the case I = N */

/* 处理 I = N 的情况结束 */

    } else {

/*        The case for I < N */

/* 处理 I < N 的情况 */

    niter = 1;
/* 初始化 niter 为 1 */

    ip1 = *i__ + 1;
/* 设置 ip1 为 i__ 的下一个值 */

/*        Calculate initial guess */

/* 计算初始猜测值 */

    delsq = (d__[ip1] - d__[*i__]) * (d__[ip1] + d__[*i__]);
/* 计算 delsq */

    delsq2 = delsq / 2.;
/* 计算 delsq2 */

    temp = delsq2 / (d__[*i__] + sqrt(d__[*i__] * d__[*i__] + delsq2));
/* 计算 temp */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* 循环计算 work 和 delta */

        work[j] = d__[j] + d__[*i__] + temp;
/* 更新 work */

        delta[j] = d__[j] - d__[*i__] - temp;
/* 更新 delta */

/* L100: */
    }

    psi = 0.;
/* 初始化 psi */

    i__1 = *i__ - 1;
    for (j = 1; j <= i__1; ++j) {
/* 计算 psi */

        psi += z__[j] * z__[j] / (work[j] * delta[j]);
/* 更新 psi */

/* L110: */
    }

    phi = 0.;
/* 初始化 phi */

    i__1 = *i__ + 2;
    for (j = *n; j >= i__1; --j) {
/* 计算 phi */

        phi += z__[j] * z__[j] / (work[j] * delta[j]);
/* 更新 phi */

/* L120: */
    }
    c__ = rhoinv + psi + phi;
/* 计算 c__ */

    w = c__ + z__[*i__] * z__[*i__] / (work[*i__] * delta[*i__]) + z__[
        ip1] * z__[ip1] / (work[ip1] * delta[ip1]);
/* 计算 w */

    if (w > 0.) {

/*
             d(i)^2 < the ith sigma^2 < (d(i)^2+d(i+1)^2)/2

             We choose d(i) as origin.

*/

/* 如果 w > 0 */
/*
        orgati = TRUE_;
        sg2lb = 0.;
        sg2ub = delsq2;
        a = c__ * delsq + z__[*i__] * z__[*i__] + z__[ip1] * z__[ip1];
        b = z__[*i__] * z__[*i__] * delsq;
        if (a > 0.) {
            tau = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(
                d__1))));
        } else {
            tau = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
                c__ * 2.);
        }

        TAU now is an estimation of SIGMA^2 - D( I )^2. The
        following, however, is the corresponding estimation of
        SIGMA - D( I ).
*/
        eta = tau / (d__[*i__] + sqrt(d__[*i__] * d__[*i__] + tau));
    } else {

/*
        (d(i)^2+d(i+1)^2)/2 <= the ith sigma^2 < d(i+1)^2/2

        We choose d(i+1) as origin.
*/
        orgati = FALSE_;
        sg2lb = -delsq2;
        sg2ub = 0.;
        a = c__ * delsq - z__[*i__] * z__[*i__] - z__[ip1] * z__[ip1];
        b = z__[ip1] * z__[ip1] * delsq;
        if (a < 0.) {
            tau = b * 2. / (a - sqrt((d__1 = a * a + b * 4. * c__, abs(
                d__1))));
        } else {
            tau = -(a + sqrt((d__1 = a * a + b * 4. * c__, abs(d__1)))) /
                (c__ * 2.);
        }

/*
        TAU now is an estimation of SIGMA^2 - D( IP1 )^2. The
        following, however, is the corresponding estimation of
        SIGMA - D( IP1 ).
*/
        eta = tau / (d__[ip1] + sqrt((d__1 = d__[ip1] * d__[ip1] + tau,
            abs(d__1))));
    }

    if (orgati) {
        ii = *i__;
        *sigma = d__[*i__] + eta;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[*i__] + eta;
            delta[j] = d__[j] - d__[*i__] - eta;
/* L130: */
        }
    } else {
        ii = *i__ + 1;
        *sigma = d__[ip1] + eta;
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            work[j] = d__[j] + d__[ip1] + eta;
            delta[j] = d__[j] - d__[ip1] - eta;
/* L140: */
        }
    }
    iim1 = ii - 1;
    iip1 = ii + 1;

/*        Evaluate PSI and the derivative DPSI */

    dpsi = 0.;
    psi = 0.;
    erretm = 0.;
    i__1 = iim1;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (work[j] * delta[j]);
        psi += z__[j] * temp;
        dpsi += temp * temp;
        erretm += psi;
/* L150: */
    }
    erretm = abs(erretm);

/*        Evaluate PHI and the derivative DPHI */

    dphi = 0.;
    phi = 0.;
    i__1 = iip1;
    for (j = *n; j >= i__1; --j) {
        temp = z__[j] / (work[j] * delta[j]);
        phi += z__[j] * temp;
        dphi += temp * temp;
        erretm += phi;
/* L160: */
    }

    w = rhoinv + phi + psi;

/*
          W is the value of the secular function with
          its ii-th element removed.
*/

    swtch3 = FALSE_;
    if (orgati) {
        if (w < 0.) {
            swtch3 = TRUE_;
        }
    } else {
        if (w > 0.) {
            swtch3 = TRUE_;
        }
    }
    if (ii == 1 || ii == *n) {
        swtch3 = FALSE_;
    }
    # 计算临时变量，用于更新 dw 值
    temp = z__[ii] / (work[ii] * delta[ii]);

    # 更新 dw 值，加上 dpsi、dphi 和 temp 的平方
    dw = dpsi + dphi + temp * temp;

    # 计算临时变量 temp，并累加到 w 上
    temp = z__[ii] * temp;
    w += temp;

    # 更新 erretm 值，考虑 phi 和 psi 的差、erretm 本身、rhoinv 的两倍、temp 绝对值的三倍、tau 绝对值与 dw 的乘积
    erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3. + abs(tau) * dw;
/*        Test for convergence */
/* 检查收敛性 */

    if (abs(w) <= eps * erretm) {
        goto L240;
    }
    /* 如果 w 的绝对值小于等于 eps 乘以 erretm，则跳转到标签 L240 */

    if (w <= 0.) {
        sg2lb = max(sg2lb,tau);
    } else {
        sg2ub = min(sg2ub,tau);
    }
    /* 如果 w 小于等于 0，则将 sg2lb 更新为 sg2lb 和 tau 的最大值；
       否则将 sg2ub 更新为 sg2ub 和 tau 的最小值 */

/*        Calculate the new step */
/* 计算新的步长 */

    ++niter;
    /* niter 自增1 */

    if (! swtch3) {
        dtipsq = work[ip1] * delta[ip1];
        dtisq = work[*i__] * delta[*i__];
        /* 计算 dtipsq 和 dtisq */

        if (orgati) {
/* Computing 2nd power */
            d__1 = z__[*i__] / dtisq;
            c__ = w - dtipsq * dw + delsq * (d__1 * d__1);
        } else {
/* Computing 2nd power */
            d__1 = z__[ip1] / dtipsq;
            c__ = w - dtisq * dw - delsq * (d__1 * d__1);
        }
        /* 根据 orgati 的值计算 c */

        a = (dtipsq + dtisq) * w - dtipsq * dtisq * dw;
        b = dtipsq * dtisq * w;
        /* 计算 a 和 b */

        if (c__ == 0.) {
            if (a == 0.) {
                if (orgati) {
                    a = z__[*i__] * z__[*i__] + dtipsq * dtipsq * (dpsi +
                        dphi);
                } else {
                    a = z__[ip1] * z__[ip1] + dtisq * dtisq * (dpsi +
                        dphi);
                }
            }
            eta = b / a;
        } else if (a <= 0.) {
            eta = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1)))) / (
                c__ * 2.);
        } else {
            eta = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__, abs(
                d__1))));
        }
        /* 根据 a, b, c 计算 eta */
    } else {
/*           Interpolation using THREE most relevant poles */
/* 使用三个最相关的极点进行插值 */

        dtiim = work[iim1] * delta[iim1];
        dtiip = work[iip1] * delta[iip1];
        /* 计算 dtiim 和 dtiip */

        temp = rhoinv + psi + phi;
        /* 计算 temp */

        if (orgati) {
            temp1 = z__[iim1] / dtiim;
            temp1 *= temp1;
            c__ = temp - dtiip * (dpsi + dphi) - (d__[iim1] - d__[iip1]) *
                 (d__[iim1] + d__[iip1]) * temp1;
            zz[0] = z__[iim1] * z__[iim1];
            /* 计算 c__ 和 zz[0] */
            
            if (dpsi < temp1) {
                zz[2] = dtiip * dtiip * dphi;
            } else {
                zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
            }
        } else {
            temp1 = z__[iip1] / dtiip;
            temp1 *= temp1;
            c__ = temp - dtiim * (dpsi + dphi) - (d__[iip1] - d__[iim1]) *
                 (d__[iim1] + d__[iip1]) * temp1;
            /* 计算 c__ */

            if (dphi < temp1) {
                zz[0] = dtiim * dtiim * dpsi;
            } else {
                zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
            }
            zz[2] = z__[iip1] * z__[iip1];
            /* 计算 zz[0] 和 zz[2] */
        }
        zz[1] = z__[ii] * z__[ii];
        dd[0] = dtiim;
        dd[1] = delta[ii] * work[ii];
        dd[2] = dtiip;
        /* 计算 zz[1] 和 dd */

        dlaed6_(&niter, &orgati, &c__, dd, zz, &w, &eta, info);
        /* 调用 dlaed6_ 函数 */

        if (*info != 0) {
            goto L240;
        }
        /* 如果 info 不为 0，则跳转到标签 L240 */
    }

/*
          Note, eta should be positive if w is negative, and
          eta should be negative otherwise. However,
          if for some reason caused by roundoff, eta*w > 0,
          we simply use one Newton step instead. This way
          will guarantee eta*w < 0.
*/
/* 注意，如果 w 是负数，eta 应该是正数；否则 eta 应该是负数。然而，
   如果由于舍入误差的某些原因，eta*w > 0，则我们简单地使用一个牛顿步骤。
   这样将确保 eta*w < 0。 */

    if (w * eta >= 0.) {
        eta = -w / dw;
    }
    /* 如果 w 乘以 eta 大于等于 0，则将 eta 设置为 -w/dw */

    if (orgati) {
        temp1 = work[*i__] * delta[*i__];
        temp = eta - temp1;
    } else {
        // 计算临时变量 temp1，为 work[ip1] 乘以 delta[ip1]
        temp1 = work[ip1] * delta[ip1];
        // 计算 temp，为 eta 减去 temp1 的结果
        temp = eta - temp1;
    }
    // 检查 temp 是否超出范围 sg2ub 到 sg2lb
    if (temp > sg2ub || temp < sg2lb) {
        // 如果 w 小于 0，则重新计算 eta
        if (w < 0.) {
            eta = (sg2ub - tau) / 2.;
        } else {
            // 否则重新计算 eta
            eta = (sg2lb - tau) / 2.;
        }
    }

    // 更新 tau
    tau += eta;
    // 计算新的 eta 值并更新其值
    eta /= *sigma + sqrt(*sigma * *sigma + eta);

    // 保存之前的 w 值
    prew = w;

    // 更新 *sigma 的值
    *sigma += eta;
    // 循环更新 work 数组和 delta 数组
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        work[j] += eta;
        delta[j] -= eta;
    }

    /* Evaluate PSI and the derivative DPSI */
    dpsi = 0.;
    psi = 0.;
    erretm = 0.;
    i__1 = iim1;
    for (j = 1; j <= i__1; ++j) {
        temp = z__[j] / (work[j] * delta[j]);
        psi += z__[j] * temp;  // 计算 PSI
        dpsi += temp * temp;   // 计算 DPSI
        erretm += psi;         // 计算误差项 erretm
/* L180: */
    }
    erretm = abs(erretm);      // 取 erretm 的绝对值

    /* Evaluate PHI and the derivative DPHI */
    dphi = 0.;
    phi = 0.;
    i__1 = iip1;
    for (j = *n; j >= i__1; --j) {
        temp = z__[j] / (work[j] * delta[j]);
        phi += z__[j] * temp;  // 计算 PHI
        dphi += temp * temp;   // 计算 DPHI
        erretm += phi;         // 将 PHI 加入误差项 erretm
/* L190: */
    }

    temp = z__[ii] / (work[ii] * delta[ii]);
    dw = dpsi + dphi + temp * temp;  // 计算 dw
    temp = z__[ii] * temp;
    w = rhoinv + phi + psi + temp;   // 计算 w
    erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3. +
        abs(tau) * dw;              // 更新 erretm

    if (w <= 0.) {
        sg2lb = max(sg2lb,tau);     // 更新 sg2lb
    } else {
        sg2ub = min(sg2ub,tau);     // 更新 sg2ub
    }

    swtch = FALSE_;
    if (orgati) {
        if (-w > abs(prew) / 10.) {
            swtch = TRUE_;           // 设置 swtch
        }
    } else {
        if (w > abs(prew) / 10.) {
            swtch = TRUE_;           // 设置 swtch
        }
    }

    /* Main loop to update the values of the array DELTA and WORK */
    iter = niter + 1;               // 更新 iter

    for (niter = iter; niter <= 20; ++niter) {

        /* Test for convergence */
        if (abs(w) <= eps * erretm) {
            goto L240;              // 检测是否收敛，跳转到 L240
        }

        /* Calculate the new step */
        if (! swtch3) {
            dtipsq = work[ip1] * delta[ip1];
            dtisq = work[*i__] * delta[*i__];
            if (! swtch) {
                if (orgati) {
                    /* Computing 2nd power */
                    d__1 = z__[*i__] / dtisq;
                    c__ = w - dtipsq * dw + delsq * (d__1 * d__1);  // 计算 c
                } else {
                    /* Computing 2nd power */
                    d__1 = z__[ip1] / dtipsq;
                    c__ = w - dtisq * dw - delsq * (d__1 * d__1);  // 计算 c
                }
            } else {
                temp = z__[ii] / (work[ii] * delta[ii]);
                if (orgati) {
                    dpsi += temp * temp;  // 更新 DPSI
                } else {
                    dphi += temp * temp;  // 更新 DPHI
                }
                c__ = w - dtisq * dpsi - dtipsq * dphi;  // 计算 c
            }
            a = (dtipsq + dtisq) * w - dtipsq * dtipsq * dw;  // 计算 a
            b = dtipsq * dtipsq * w;                        // 计算 b
            if (c__ == 0.) {
                if (a == 0.) {
                    if (! swtch) {
                        if (orgati) {
                            a = z__[*i__] * z__[*i__] + dtipsq * dtipsq *
                                (dpsi + dphi);               // 计算 a
                        } else {
                            a = z__[ip1] * z__[ip1] + dtisq * dtisq *
                                (dpsi + dphi);               // 计算 a
                        }
                    } else {
                        a = dtisq * dtisq * dpsi + dtipsq * dtipsq * dphi;  // 计算 a
                    }
                }
                eta = b / a;  // 计算 eta
            } else if (a <= 0.) {
                eta = (a - sqrt((d__1 = a * a - b * 4. * c__, abs(d__1))))
                     / (c__ * 2.);  // 计算 eta
            } else {
                eta = b * 2. / (a + sqrt((d__1 = a * a - b * 4. * c__,
                    abs(d__1))));  // 计算 eta
            }
        } else {
/*
   使用三个最相关的极点进行插值
*/

dtiim = work[iim1] * delta[iim1];
dtiip = work[iip1] * delta[iip1];
temp = rhoinv + psi + phi;

if (swtch) {
    /*
       如果开关打开，计算插值系数 c__ 和 zz 数组
    */
    c__ = temp - dtiim * dpsi - dtiip * dphi;
    zz[0] = dtiim * dtiim * dpsi;
    zz[2] = dtiip * dtiip * dphi;
} else {
    if (orgati) {
        /*
           如果没有开关，并且 orgati 为真，根据不同情况计算 c__ 和 zz 数组
        */
        temp1 = z__[iim1] / dtiim;
        temp1 *= temp1;
        temp2 = (d__[iim1] - d__[iip1]) * (d__[iim1] + d__[iip1]) * temp1;
        c__ = temp - dtiip * (dpsi + dphi) - temp2;
        zz[0] = z__[iim1] * z__[iim1];
        if (dpsi < temp1) {
            zz[2] = dtiip * dtiip * dphi;
        } else {
            zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
        }
    } else {
        /*
           如果没有开关，并且 orgati 为假，根据不同情况计算 c__ 和 zz 数组
        */
        temp1 = z__[iip1] / dtiip;
        temp1 *= temp1;
        temp2 = (d__[iip1] - d__[iim1]) * (d__[iim1] + d__[iip1]) * temp1;
        c__ = temp - dtiim * (dpsi + dphi) - temp2;
        if (dphi < temp1) {
            zz[0] = dtiim * dtiim * dpsi;
        } else {
            zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
        }
        zz[2] = z__[iip1] * z__[iip1];
    }
}

/*
   设置 dd 数组
*/
dd[0] = dtiim;
dd[1] = delta[ii] * work[ii];
dd[2] = dtiip;

/*
   调用 dlaed6_ 函数进行计算
*/
dlaed6_(&niter, &orgati, &c__, dd, zz, &w, &eta, info);
if (*info != 0) {
    goto L240;
}

/*
   如果 w * eta >= 0，则进行一步牛顿法调整 eta 的值
*/
if (w * eta >= 0.) {
    eta = -w / dw;
}

/*
   根据 orgati 的值选择合适的 temp1 值，并计算 temp
*/
if (orgati) {
    temp1 = work[*i__] * delta[*i__];
    temp = eta - temp1;
} else {
    temp1 = work[ip1] * delta[ip1];
    temp = eta - temp1;
}

/*
   根据 temp 的值调整 eta 的值，以保证在特定区间内
*/
if (temp > sg2ub || temp < sg2lb) {
    if (w < 0.) {
        eta = (sg2ub - tau) / 2.;
    } else {
        eta = (sg2lb - tau) / 2.;
    }
}

/*
   更新 tau 和 *sigma 的值，并更新 work 和 delta 数组
*/
tau += eta;
eta /= *sigma + sqrt(*sigma * *sigma + eta);
*sigma += eta;
i__1 = *n;
for (j = 1; j <= i__1; ++j) {
    work[j] += eta;
    delta[j] -= eta;
}

prew = w;

/*
   计算 PSI 和其导数 DPSI
*/
dpsi = 0.;
psi = 0.;
erretm = 0.;
i__1 = iim1;
for (j = 1; j <= i__1; ++j) {
    temp = z__[j] / (work[j] * delta[j]);
    psi += z__[j] * temp;
    dpsi += temp * temp;
    erretm += psi;
}

erretm = abs(erretm);
/*           Evaluate PHI and the derivative DPHI */

        dphi = 0.;
        phi = 0.;
        i__1 = iip1;
        // 循环计算 phi 和 dphi
        for (j = *n; j >= i__1; --j) {
        temp = z__[j] / (work[j] * delta[j]);
        phi += z__[j] * temp;
        dphi += temp * temp;
        erretm += phi;
/* L220: */
        }

        temp = z__[ii] / (work[ii] * delta[ii]);
        dw = dpsi + dphi + temp * temp;
        temp = z__[ii] * temp;
        w = rhoinv + phi + psi + temp;
        // 计算 erretm 的更新值
        erretm = (phi - psi) * 8. + erretm + rhoinv * 2. + abs(temp) * 3.
            + abs(tau) * dw;
        // 根据 w 和 prew 的符号及大小更新 swtch
        if (w * prew > 0. && abs(w) > abs(prew) / 10.) {
        swtch = ! swtch;
        }

        // 根据 w 的值更新 sg2lb 或 sg2ub
        if (w <= 0.) {
        sg2lb = max(sg2lb,tau);
        } else {
        sg2ub = min(sg2ub,tau);
        }

/* L230: */
    }

/*        Return with INFO = 1, NITER = MAXIT and not converged */

    *info = 1;

    }

L240:
    return 0;

/*     End of DLASD4 */

} /* dlasd4_ */

/* Subroutine */ int dlasd5_(integer *i__, doublereal *d__, doublereal *z__,
    doublereal *delta, doublereal *rho, doublereal *dsigma, doublereal *
    work)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    static doublereal b, c__, w, del, tau, delsq;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    This subroutine computes the square root of the I-th eigenvalue
    of a positive symmetric rank-one modification of a 2-by-2 diagonal
    matrix

               diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .

    The diagonal entries in the array D are assumed to satisfy

               0 <= D(i) < D(j)  for  i < j .

    We also assume RHO > 0 and that the Euclidean norm of the vector
    Z is one.

    Arguments
    =========

    I      (input) INTEGER
           The index of the eigenvalue to be computed.  I = 1 or I = 2.

    D      (input) DOUBLE PRECISION array, dimension ( 2 )
           The original eigenvalues.  We assume 0 <= D(1) < D(2).

    Z      (input) DOUBLE PRECISION array, dimension ( 2 )
           The components of the updating vector.

    DELTA  (output) DOUBLE PRECISION array, dimension ( 2 )
           Contains (D(j) - sigma_I) in its  j-th component.
           The vector DELTA contains the information necessary
           to construct the eigenvectors.

    RHO    (input) DOUBLE PRECISION
           The scalar in the symmetric updating formula.

    DSIGMA (output) DOUBLE PRECISION
           The computed sigma_I, the I-th updated eigenvalue.

    WORK   (workspace) DOUBLE PRECISION array, dimension ( 2 )
           WORK contains (D(j) + sigma_I) in its  j-th component.

    Further Details
    ===============

    Based on contributions by
       Ren-Cang Li, Computer Science Division, University of California
       at Berkeley, USA
    # 定义一个名为 merge_sort 的函数，接收一个列表参数 arr
    def merge_sort(arr):
        # 如果列表的长度小于等于1，直接返回该列表，因为已经是有序的了
        if len(arr) <= 1:
            return arr
        
        # 计算列表的中间位置
        mid = len(arr) // 2
        
        # 递归地对列表的左半部分进行归并排序，并赋值给 left_half
        left_half = merge_sort(arr[:mid])
        # 递归地对列表的右半部分进行归并排序，并赋值给 right_half
        right_half = merge_sort(arr[mid:])
        
        # 调用 merge 函数，将排序好的 left_half 和 right_half 合并起来
        return merge(left_half, right_half)
    
    # 定义一个名为 merge 的函数，接收两个已排序列表 left 和 right 作为参数
    def merge(left, right):
        # 创建一个空列表 result 来存放合并后的结果
        result = []
        # 定义两个指针 i 和 j，分别指向 left 和 right 的起始位置
        i = j = 0
        
        # 循环比较 left 和 right 的元素，将较小的元素依次添加到 result 中
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        # 将剩余的元素添加到 result 中（这两个 while 循环中只有一个会执行）
        result.extend(left[i:])
        result.extend(right[j:])
        
        # 返回合并后的有序列表 result
        return result
/*
    对参数进行调整
*/
    --work;
    --delta;
    --z__;
    --d__;

    /* 函数主体 */
    del = d__[2] - d__[1];
    delsq = del * (d__[2] + d__[1]);
    if (*i__ == 1) {
        // 计算 w
        w = *rho * 4. * (z__[2] * z__[2] / (d__[1] + d__[2] * 3.) - z__[1] *
            z__[1] / (d__[1] * 3. + d__[2])) / del + 1.;
        if (w > 0.) {
            b = delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[1] * z__[1] * delsq;
            // 计算 tau
            tau = c__ * 2. / (b + sqrt((d__1 = b * b - c__ * 4., abs(d__1))));
            tau /= d__[1] + sqrt(d__[1] * d__[1] + tau);
            *dsigma = d__[1] + tau;
            delta[1] = -tau;
            delta[2] = del - tau;
            work[1] = d__[1] * 2. + tau;
            work[2] = d__[1] + tau + d__[2];
        } else {
            b = -delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
            c__ = *rho * z__[2] * z__[2] * delsq;
            if (b > 0.) {
                tau = c__ * -2. / (b + sqrt(b * b + c__ * 4.));
            } else {
                tau = (b - sqrt(b * b + c__ * 4.)) / 2.;
            }
            tau /= d__[2] + sqrt((d__1 = d__[2] * d__[2] + tau, abs(d__1)));
            *dsigma = d__[2] + tau;
            delta[1] = -(del + tau);
            delta[2] = -tau;
            work[1] = d__[1] + tau + d__[2];
            work[2] = d__[2] * 2. + tau;
        }
    } else {
        b = -delsq + *rho * (z__[1] * z__[1] + z__[2] * z__[2]);
        c__ = *rho * z__[2] * z__[2] * delsq;
        if (b > 0.) {
            tau = (b + sqrt(b * b + c__ * 4.)) / 2.;
        } else {
            tau = c__ * 2. / (-b + sqrt(b * b + c__ * 4.));
        }
        tau /= d__[2] + sqrt(d__[2] * d__[2] + tau);
        *dsigma = d__[2] + tau;
        delta[1] = -(del + tau);
        delta[2] = -tau;
        work[1] = d__[1] + tau + d__[2];
        work[2] = d__[2] * 2. + tau;
    }
    return 0;
} 
    # 定义指向 doublereal 类型数组的指针 alpha，用于存储参数 alpha 的地址
    doublereal *alpha,
    # 定义指向 doublereal 类型数组的指针 beta，用于存储参数 beta 的地址
    doublereal *beta,
    # 定义指向 integer 类型数组的指针 idxq，用于存储参数 idxq 的地址
    integer *idxq,
    # 定义指向 integer 类型数组的指针 perm，用于存储参数 perm 的地址
    integer *perm,
    # 定义指向 integer 类型数组的指针 givptr，用于存储参数 givptr 的地址
    integer *givptr,
    # 定义指向 integer 类型数组的指针 givcol，用于存储参数 givcol 的地址
    integer *givcol,
    # 定义指向 integer 类型的指针 ldgcol，用于存储参数 ldgcol 的地址
    integer *ldgcol,
    # 定义指向 doublereal 类型数组的指针 givnum，用于存储参数 givnum 的地址
    doublereal *givnum,
    # 定义指向 integer 类型的指针 ldgnum，用于存储参数 ldgnum 的地址
    integer *ldgnum,
    # 定义指向 doublereal 类型数组的指针 poles，用于存储参数 poles 的地址
    doublereal *poles,
    # 定义指向 doublereal 类型数组的指针 difl，用于存储参数 difl 的地址
    doublereal *difl,
    # 定义指向 doublereal 类型数组的指针 difr，用于存储参数 difr 的地址
    doublereal *difr,
    # 定义指向 doublereal 类型数组的指针 z__，用于存储参数 z__ 的地址
    doublereal *z__,
    # 定义指向 integer 类型的指针 k，用于存储参数 k 的地址
    integer *k,
    # 定义指向 doublereal 类型的指针 c__，用于存储参数 c__ 的地址
    doublereal *c__,
    # 定义指向 doublereal 类型的指针 s，用于存储参数 s 的地址
    doublereal *s,
    # 定义指向 doublereal 类型数组的指针 work，用于存储参数 work 的地址
    doublereal *work,
    # 定义指向 integer 类型数组的指针 iwork，用于存储参数 iwork 的地址
    integer *iwork,
    # 定义指向 integer 类型的指针 info，用于存储参数 info 的地址
    integer *info
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, m, n, n1, n2, iw, idx, idxc, idxp, ivfw, ivlw;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dlasd7_(integer *, integer *, integer *,
         integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, integer *,
        integer *, integer *, integer *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), dlasd8_(
        integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, doublereal *,
         doublereal *, integer *), dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), dlamrg_(integer *, integer *,
        doublereal *, integer *, integer *, integer *);
    static integer isigma;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal orgnrm;


/*
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLASD6 computes the SVD of an updated upper bidiagonal matrix B
    obtained by merging two smaller ones by appending a row. This
    routine is used only for the problem which requires all singular
    values and optionally singular vector matrices in factored form.
    B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
    A related subroutine, DLASD1, handles the case in which all singular
    values and singular vectors of the bidiagonal matrix are desired.

    DLASD6 computes the SVD as follows:

                  ( D1(in)  0    0     0 )
      B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
                  (   0     0   D2(in) 0 )

        = U(out) * ( D(out) 0) * VT(out)

    where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
    with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
    elsewhere; and the entry b is empty if SQRE = 0.

    The singular values of B can be computed using D1, D2, the first
    components of all the right singular vectors of the lower block, and
    the last components of all the right singular vectors of the upper
    block. These components are stored and updated in VF and VL,
    respectively, in DLASD6. Hence U and VT are not explicitly
    referenced.

    The singular values are stored in D. The algorithm consists of two
*/

    // Declare integer variables used for matrix dimensions and offsets
    /* System generated locals */
    integer givcol_dim1, givcol_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, i__1;
    
    // Declare variables used for floating-point computations
    doublereal d__1, d__2;

    // Declare local variables used in the subroutine
    /* Local variables */
    static integer i__, m, n, n1, n2, iw, idx, idxc, idxp, ivfw, ivlw;

    // External subroutine declarations
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dlasd7_(integer *, integer *, integer *,
         integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, integer *,
        integer *, integer *, integer *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), dlasd8_(
        integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, integer *, doublereal *,
         doublereal *, integer *), dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *);

    // Static variables for indexing and error handling
    static integer isigma;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal orgnrm;
    stages:

          The first stage consists of deflating the size of the problem
          when there are multiple singular values or if there is a zero
          in the Z vector. For each such occurence the dimension of the
          secular equation problem is reduced by one. This stage is
          performed by the routine DLASD7.

          The second stage consists of calculating the updated
          singular values. This is done by finding the roots of the
          secular equation via the routine DLASD4 (as called by DLASD8).
          This routine also updates VF and VL and computes the distances
          between the updated singular values and the old singular
          values.

    DLASD6 is called from DLASDA.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether singular vectors are to be computed in
           factored form:
           = 0: Compute singular values only.
           = 1: Compute singular vectors in factored form as well.

    NL     (input) INTEGER
           The row dimension of the upper block.  NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block.  NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has row dimension N = NL + NR + 1,
           and column dimension M = N + SQRE.

    D      (input/output) DOUBLE PRECISION array, dimension ( NL+NR+1 ).
           On entry D(1:NL,1:NL) contains the singular values of the
           upper block, and D(NL+2:N) contains the singular values
           of the lower block. On exit D(1:N) contains the singular
           values of the modified matrix.

    VF     (input/output) DOUBLE PRECISION array, dimension ( M )
           On entry, VF(1:NL+1) contains the first components of all
           right singular vectors of the upper block; and VF(NL+2:M)
           contains the first components of all right singular vectors
           of the lower block. On exit, VF contains the first components
           of all right singular vectors of the bidiagonal matrix.

    VL     (input/output) DOUBLE PRECISION array, dimension ( M )
           On entry, VL(1:NL+1) contains the  last components of all
           right singular vectors of the upper block; and VL(NL+2:M)
           contains the last components of all right singular vectors of
           the lower block. On exit, VL contains the last components of
           all right singular vectors of the bidiagonal matrix.

    ALPHA  (input/output) DOUBLE PRECISION
           Contains the diagonal element associated with the added row.

    BETA   (input/output) DOUBLE PRECISION
           Contains the off-diagonal element associated with the added
           row.
    ! IDXQ 是一个整数数组，维度为 N
    ! 这个数组包含了一个置换，用于将刚刚解决的子问题重新集成到排序顺序中，
    ! 即 D(IDXQ(I)) 将按升序排列。

    ! PERM 是一个整数数组，维度为 N
    ! 这些是用于每个块的排列（从缩小和排序中获得的），如果 ICOMPQ = 0 则不引用。

    ! GIVPTR 是一个整数
    ! 这个变量表示在这个子问题中进行的 Givens 旋转的数量，如果 ICOMPQ = 0 则不引用。

    ! GIVCOL 是一个整数数组，维度为 LDGCOL × 2
    ! 每一对数字指示参与 Givens 旋转的一对列，如果 ICOMPQ = 0 则不引用。

    ! LDGCOL 是一个整数输入
    ! GIVCOL 的主导维度，必须至少为 N。

    ! GIVNUM 是一个双精度浮点数数组，维度为 LDGNUM × 2
    ! 每个数字指示在相应的 Givens 旋转中要使用的 C 或 S 值，如果 ICOMPQ = 0 则不引用。

    ! LDGNUM 是一个整数输入
    ! GIVNUM 和 POLES 的主导维度，必须至少为 N。

    ! POLES 是一个双精度浮点数数组，维度为 LDGNUM × 2
    ! 在退出时，POLES(1,*) 包含从解决伪离散方程中获得的新奇异值，
    ! 而 POLES(2,*) 包含伪离散方程中的极点，如果 ICOMPQ = 0 则不引用。

    ! DIFL 是一个双精度浮点数数组，维度为 N
    ! 在退出时，DIFL(I) 是第 I 个更新（未缩小）奇异值与第 I 个（未缩小）旧奇异值之间的距离。

    ! DIFR 是一个双精度浮点数数组，
    ! 维度为 LDGNUM × 2（如果 ICOMPQ = 1），或维度为 N（如果 ICOMPQ = 0）。
    ! 在退出时，DIFR(I, 1) 是第 I 个更新（未缩小）奇异值与第 I+1 个（未缩小）旧奇异值之间的距离。
    ! 如果 ICOMPQ = 1，则 DIFR(1:K, 2) 是包含右奇异向量矩阵的归一化因子的数组。

    ! Z 是一个双精度浮点数数组，维度为 M
    ! 这个数组的前几个元素包含了调整缩小后的更新行向量的分量。

    ! K 是一个整数
    ! 包含非缩小矩阵的维度，这是相关离散方程的阶数。1 <= K <= N。

    ! C 是一个双精度浮点数
    ! 如果 SQRE = 0，则 C 包含垃圾；如果 SQRE = 1，则 C 包含与右零空间相关的 Givens 旋转的 C 值。

    ! S 是一个双精度浮点数
    ! 如果 SQRE = 0，则 S 包含垃圾；如果 SQRE = 1，则 S 包含与右零空间相关的 Givens 旋转的 S 值。

    ! WORK 是一个双精度浮点数数组，维度为 4 × M
    ! 这是一个工作空间数组，用于算法中的临时存储和计算。
    # IWORK (workspace) 是一个整数数组，维度为 (3 * N)，用于存储中间计算结果的工作空间

    # INFO (输出) 是一个整数
    #     = 0:  操作成功完成。
    #     < 0:  如果 INFO = -i，则第 i 个参数具有非法值。
    #     > 0:  如果 INFO = 1，则某个奇异值未收敛。

    # 进一步细节
    # ===============
    # 这部分提供了更多细节，说明了该程序的基础工作原理。
    # 根据以下贡献者的贡献而来：
    #    Ming Gu 和 Huan Ren，加州大学伯克利分校计算机科学系，美国

    # =====================================================================

    # 测试输入参数的有效性。
/* Parameter adjustments */
    /* 对参数进行调整 */
    --d__;       /* 将数组 d__ 向左偏移 */
    --vf;        /* 将数组 vf 向左偏移 */
    --vl;        /* 将数组 vl 向左偏移 */
    --idxq;      /* 将数组 idxq 向左偏移 */
    --perm;      /* 将数组 perm 向左偏移 */
    givcol_dim1 = *ldgcol;   /* 设置 givcol 的第一维度 */
    givcol_offset = 1 + givcol_dim1;   /* 计算 givcol 的偏移量 */
    givcol -= givcol_offset;   /* 将 givcol 指针偏移到正确位置 */
    poles_dim1 = *ldgnum;     /* 设置 poles 的第一维度 */
    poles_offset = 1 + poles_dim1;     /* 计算 poles 的偏移量 */
    poles -= poles_offset;     /* 将 poles 指针偏移到正确位置 */
    givnum_dim1 = *ldgnum;     /* 设置 givnum 的第一维度 */
    givnum_offset = 1 + givnum_dim1;   /* 计算 givnum 的偏移量 */
    givnum -= givnum_offset;   /* 将 givnum 指针偏移到正确位置 */
    --difl;       /* 将数组 difl 向左偏移 */
    --difr;       /* 将数组 difr 向左偏移 */
    --z__;        /* 将数组 z__ 向左偏移 */
    --work;       /* 将数组 work 向左偏移 */
    --iwork;      /* 将数组 iwork 向左偏移 */

    /* Function Body */
    *info = 0;    /* 初始化 info 为 0 */
    n = *nl + *nr + 1;    /* 计算 n 的值 */
    m = n + *sqre;    /* 计算 m 的值 */

    if (*icompq < 0 || *icompq > 1) {    /* 检查 icompq 是否合法 */
    *info = -1;
    } else if (*nl < 1) {    /* 检查 nl 是否合法 */
    *info = -2;
    } else if (*nr < 1) {    /* 检查 nr 是否合法 */
    *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {    /* 检查 sqre 是否合法 */
    *info = -4;
    } else if (*ldgcol < n) {    /* 检查 ldgcol 是否足够大 */
    *info = -14;
    } else if (*ldgnum < n) {    /* 检查 ldgnum 是否足够大 */
    *info = -16;
    }
    if (*info != 0) {    /* 如果出现错误信息 */
    i__1 = -(*info);
    xerbla_("DLASD6", &i__1);    /* 调用错误处理程序 xerbla */
    return 0;
    }

/*
       The following values are for bookkeeping purposes only.  They are
       integer pointers which indicate the portion of the workspace
       used by a particular array in DLASD7 and DLASD8.
*/

    isigma = 1;    /* 初始化 isigma 为 1 */
    iw = isigma + n;    /* 计算 iw 的值 */
    ivfw = iw + m;    /* 计算 ivfw 的值 */
    ivlw = ivfw + m;    /* 计算 ivlw 的值 */

    idx = 1;    /* 初始化 idx 为 1 */
    idxc = idx + n;    /* 计算 idxc 的值 */
    idxp = idxc + n;    /* 计算 idxp 的值 */

/*
       Scale.

   Computing MAX
*/
    d__1 = abs(*alpha), d__2 = abs(*beta);    /* 计算 alpha 和 beta 的绝对值 */
    orgnrm = max(d__1,d__2);    /* 计算它们的最大值作为 orgnrm */
    d__[*nl + 1] = 0.;    /* 设置 d__[nl + 1] 为 0 */
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {    /* 循环处理数组 d__ */
    if ((d__1 = d__[i__], abs(d__1)) > orgnrm) {    /* 更新 orgnrm 的值 */
        orgnrm = (d__1 = d__[i__], abs(d__1));
    }
/* L10: */
    }
    dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &n, &c__1, &d__[1], &n, info);    /* 调用 DLASCL 对 d__ 进行缩放 */
    *alpha /= orgnrm;    /* 更新 alpha */
    *beta /= orgnrm;    /* 更新 beta */

/*     Sort and Deflate singular values. */

    dlasd7_(icompq, nl, nr, sqre, k, &d__[1], &z__[1], &work[iw], &vf[1], &    /* 调用 DLASD7 处理排序和压缩奇异值 */
        work[ivfw], &vl[1], &work[ivlw], alpha, beta, &work[isigma], &
        iwork[idx], &iwork[idxp], &idxq[1], &perm[1], givptr, &givcol[
        givcol_offset], ldgcol, &givnum[givnum_offset], ldgnum, c__, s,
        info);

/*     Solve Secular Equation, compute DIFL, DIFR, and update VF, VL. */

    dlasd8_(icompq, k, &d__[1], &z__[1], &vf[1], &vl[1], &difl[1], &difr[1],    /* 调用 DLASD8 处理解析方程和更新 vf, vl */
        ldgnum, &work[isigma], &work[iw], info);

/*     Save the poles if ICOMPQ = 1. */

    if (*icompq == 1) {    /* 如果需要保存极点 */
    dcopy_(k, &d__[1], &c__1, &poles[poles_dim1 + 1], &c__1);    /* 复制 d__ 的内容到 poles */
    dcopy_(k, &work[isigma], &c__1, &poles[(poles_dim1 << 1) + 1], &c__1);    /* 复制 work[isigma] 的内容到 poles 的第二行 */
    }

/*     Unscale. */

    dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &n, &c__1, &d__[1], &n, info);    /* 对 d__ 进行反缩放 */

/*     Prepare the IDXQ sorting permutation. */

    n1 = *k;    /* 设置 n1 为 k */
    n2 = n - *k;    /* 设置 n2 为 n - k */
    dlamrg_(&n1, &n2, &d__[1], &c__1, &c_n1, &idxq[1]);    /* 调用 DLAMRG 准备排序索引 */

    return 0;

/*     End of DLASD6 */

} /* dlasd6_ */

/* Subroutine */ int dlasd7_(integer *icompq, integer *nl, integer *nr,
    integer *sqre, integer *k, doublereal *d__, doublereal *z__,
    doublereal *zw, doublereal *vf, doublereal *vfw, doublereal *vl,
    doublereal *vlw, doublereal *alpha, doublereal *beta, doublereal *
    dsigma, integer *idx, integer *idxp, integer *idxq, integer *perm,
     integer *givptr, integer *givcol, integer *ldgcol, doublereal *givnum,
     integer *ldgnum, doublereal *c__, doublereal *s, integer *info)



    dsigma,              ! 输入/输出：双精度标量，用于存储中间结果或者返回特定值
    integer *idx,        ! 输入：整数指针，用于传递索引数组
    integer *idxp,       ! 输入：整数指针，用于传递索引数组
    integer *idxq,       ! 输入：整数指针，用于传递索引数组
    integer *perm,       ! 输入：整数指针，用于传递排列数组
    integer *givptr,     ! 输入：整数指针，指向 Givens 变换数组
    integer *givcol,     ! 输入：整数指针，指向 Givens 变换数组
    integer *ldgcol,     ! 输入：整数指针，指定 Givens 变换数组的列数
    doublereal *givnum,  ! 输入：双精度浮点数指针，指向 Givens 变换数组
    integer *ldgnum,     ! 输入：整数指针，指定 Givens 变换数组的行数
    doublereal *c__,     ! 输入/输出：双精度浮点数，用于存储余弦值或者返回特定值
    doublereal *s,       ! 输入/输出：双精度浮点数，用于存储正弦值或者返回特定值
    integer *info        ! 输出：整数指针，用于传递返回的信息或错误码
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, givnum_dim1, givnum_offset, i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, j, m, n, k2;
    static doublereal z1;
    static integer jp;
    static doublereal eps, tau, tol;
    static integer nlp1, nlp2, idxi, idxj;
    extern /* Subroutine */ int drot_(integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *);
    static integer idxjp;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer jprev;

    extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *,
        integer *, integer *, integer *), xerbla_(char *, integer *);
    static doublereal hlftol;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASD7 merges the two sets of singular values together into a single
    sorted set. Then it tries to deflate the size of the problem. There
    are two ways in which deflation can occur:  when two or more singular
    values are close together or if there is a tiny entry in the Z
    vector. For each such occurrence the order of the related
    secular equation problem is reduced by one.

    DLASD7 is called from DLASD6.

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows:
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper
                 bidiagonal matrix in compact form.

    NL     (input) INTEGER
           The row dimension of the upper block. NL >= 1.

    NR     (input) INTEGER
           The row dimension of the lower block. NR >= 1.

    SQRE   (input) INTEGER
           = 0: the lower block is an NR-by-NR square matrix.
           = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

           The bidiagonal matrix has
           N = NL + NR + 1 rows and
           M = N + SQRE >= N columns.

    K      (output) INTEGER
           Contains the dimension of the non-deflated matrix, this is
           the order of the related secular equation. 1 <= K <=N.

    D      (input/output) DOUBLE PRECISION array, dimension ( N )
           On entry D contains the singular values of the two submatrices
           to be combined. On exit D contains the trailing (N-K) updated
           singular values (those which were deflated) sorted into
           increasing order.

    Z      (output) DOUBLE PRECISION array, dimension ( M )
           On exit Z contains the updating row vector in the secular
           equation.

    ZW     (workspace) DOUBLE PRECISION array, dimension ( M )
           Workspace for Z.

*/

/*
    Declaration of variables and parameters used in DLASD7 routine
*/
    # VF 是一个 DOUBLE PRECISION 数组，存储右奇异向量的首分量
    # 对于上部分块，VF(1:NL+1)存储所有右奇异向量的首分量；
    # 对于下部分块，VF(NL+2:M)存储所有右奇异向量的首分量。
    # 在函数执行后，VF 存储了奇异值分解后所有右奇异向量的首分量。

    # VFW 是 VF 的工作空间，用于临时存储计算过程中的数据。

    # VL 是一个 DOUBLE PRECISION 数组，存储右奇异向量的末分量
    # 对于上部分块，VL(1:NL+1)存储所有右奇异向量的末分量；
    # 对于下部分块，VL(NL+2:M)存储所有右奇异向量的末分量。
    # 在函数执行后，VL 存储了奇异值分解后所有右奇异向量的末分量。

    # VLW 是 VL 的工作空间，用于临时存储计算过程中的数据。

    # ALPHA 是一个 DOUBLE PRECISION 变量，存储添加行对应的对角线元素。

    # BETA 是一个 DOUBLE PRECISION 变量，存储添加行对应的非对角线元素。

    # DSIGMA 是一个 DOUBLE PRECISION 数组，维度为 N，存储平方根估计中的对角线元素。
    # 它包含了一个复制的对角线元素（K-1 个奇异值和一个零）。

    # IDX 是一个 INTEGER 数组，维度为 N，用作工作空间。
    # 它包含了用于将 D 排序为升序的排列。

    # IDXP 是一个 INTEGER 数组，维度为 N，用作工作空间。
    # 在函数返回时，IDXP(2:K)指向非紧缩的 D 值，IDXP(K+1:N)指向紧缩的奇异值。

    # IDXQ 是一个 INTEGER 数组，维度为 N，包含一个排列，将 D 的两个子问题分别排序为升序。
    # 注意：这个排列的前半部分的条目需要向后移动一个位置，后半部分的条目需要加上 NL+1。

    # PERM 是一个 INTEGER 数组，维度为 N，存储用于每个奇异块的排列（从紧缩和排序中得到）。
    # 如果 ICOMPQ = 0，则不被引用。

    # GIVPTR 是一个 INTEGER 变量，存储子问题中发生的 Givens 旋转的数量。
    # 如果 ICOMPQ = 0，则不被引用。

    # GIVCOL 是一个 INTEGER 数组，维度为 LDGCOL x 2，存储每对列用于 Givens 旋转。
    # 如果 ICOMPQ = 0，则不被引用。

    # LDGCOL 是一个 INTEGER 变量，存储 GIVCOL 的主维度，至少为 N。
    # 输出参数 GIVNUM，是一个双精度浮点数组，维度为 (LDGNUM, 2)，每个数表示对应的 Givens 旋转中要使用的 C 或 S 值。
    GIVNUM (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
           Each number indicates the C or S value to be used in the
           corresponding Givens rotation. Not referenced if ICOMPQ = 0.

    # 输入参数 LDGNUM，整数，是数组 GIVNUM 的第一维的长度，必须至少为 N。
    LDGNUM (input) INTEGER
           The leading dimension of GIVNUM, must be at least N.

    # 输出参数 C，双精度浮点数，如果 SQRE = 0，则包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 C 值。
    C      (output) DOUBLE PRECISION
           C contains garbage if SQRE =0 and the C-value of a Givens
           rotation related to the right null space if SQRE = 1.

    # 输出参数 S，双精度浮点数，如果 SQRE = 0，则包含垃圾值；如果 SQRE = 1，则包含与右零空间相关的 Givens 旋转的 S 值。
    S      (output) DOUBLE PRECISION
           S contains garbage if SQRE =0 and the S-value of a Givens
           rotation related to the right null space if SQRE = 1.

    # 输出参数 INFO，整数，返回函数执行的状态：
    #     = 0: 执行成功退出。
    #     < 0: 如果 INFO = -i，则第 i 个参数具有非法值。
    INFO   (output) INTEGER
           = 0:  successful exit.
           < 0:  if INFO = -i, the i-th argument had an illegal value.

    # 进一步细节说明，这段代码的贡献者是 Ming Gu 和 Huan Ren，他们来自加州大学伯克利分校的计算机科学系，美国。
    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    # 测试输入参数的有效性。
    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;        // 参数 d__ 指针减小偏移量
    --z__;        // 参数 z__ 指针减小偏移量
    --zw;         // 参数 zw 指针减小偏移量
    --vf;         // 参数 vf 指针减小偏移量
    --vfw;        // 参数 vfw 指针减小偏移量
    --vl;         // 参数 vl 指针减小偏移量
    --vlw;        // 参数 vlw 指针减小偏移量
    --dsigma;     // 参数 dsigma 指针减小偏移量
    --idx;        // 参数 idx 指针减小偏移量
    --idxp;       // 参数 idxp 指针减小偏移量
    --idxq;       // 参数 idxq 指针减小偏移量
    --perm;       // 参数 perm 指针减小偏移量
    givcol_dim1 = *ldgcol;
    givcol_offset = 1 + givcol_dim1;
    givcol -= givcol_offset;  // givcol 指针向前调整偏移量
    givnum_dim1 = *ldgnum;
    givnum_offset = 1 + givnum_dim1;
    givnum -= givnum_offset;  // givnum 指针向前调整偏移量

    /* Function Body */
    *info = 0;                  // 初始化 info 为 0
    n = *nl + *nr + 1;          // 计算 n 的值
    m = n + *sqre;              // 计算 m 的值

    if (*icompq < 0 || *icompq > 1) {  // 检查 icompq 是否在指定范围内
        *info = -1;
    } else if (*nl < 1) {        // 检查 nl 是否大于等于 1
        *info = -2;
    } else if (*nr < 1) {        // 检查 nr 是否大于等于 1
        *info = -3;
    } else if (*sqre < 0 || *sqre > 1) {  // 检查 sqre 是否在指定范围内
        *info = -4;
    } else if (*ldgcol < n) {    // 检查 ldgcol 是否足够大
        *info = -22;
    } else if (*ldgnum < n) {    // 检查 ldgnum 是否足够大
        *info = -24;
    }
    if (*info != 0) {           // 如果 info 不为 0，则调用错误处理函数并返回
        i__1 = -(*info);
        xerbla_("DLASD7", &i__1);
        return 0;
    }

    nlp1 = *nl + 1;             // 计算 nlp1 的值
    nlp2 = *nl + 2;             // 计算 nlp2 的值
    if (*icompq == 1) {         // 如果 icompq 等于 1，则设置 givptr 为 0
        *givptr = 0;
    }

/*
       Generate the first part of the vector Z and move the singular
       values in the first part of D one position backward.
*/

    z1 = *alpha * vl[nlp1];     // 计算 z1 的值
    vl[nlp1] = 0.;              // 将 vl[nlp1] 置为 0
    tau = vf[nlp1];             // 设置 tau 的值为 vf[nlp1]
    for (i__ = *nl; i__ >= 1; --i__) {
        z__[i__ + 1] = *alpha * vl[i__];  // 生成向量 Z 的第一部分
        vl[i__] = 0.;           // 将 vl[i__] 置为 0
        vf[i__ + 1] = vf[i__];  // 移动 vf 的值
        d__[i__ + 1] = d__[i__];  // 移动 d 的值
        idxq[i__ + 1] = idxq[i__] + 1;  // 更新 idxq
/* L10: */
    }
    vf[1] = tau;                // 设置 vf[1] 的值为 tau

/*     Generate the second part of the vector Z. */

    i__1 = m;                   // 循环生成 Z 的第二部分
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        z__[i__] = *beta * vf[i__];  // 计算 Z 的第二部分
        vf[i__] = 0.;           // 将 vf[i__] 置为 0
/* L20: */
    }

/*     Sort the singular values into increasing order */

    i__1 = n;                   // 对奇异值进行排序
    for (i__ = nlp2; i__ <= i__1; ++i__) {
        idxq[i__] += nlp1;      // 更新 idxq
/* L30: */
    }

/*     DSIGMA, IDXC, IDXC, and ZW are used as storage space. */

    i__1 = n;                   // 使用 DSIGMA, IDXC, IDXC, 和 ZW 作为存储空间
    for (i__ = 2; i__ <= i__1; ++i__) {
        dsigma[i__] = d__[idxq[i__]];  // 存储 dsigma
        zw[i__] = z__[idxq[i__]];  // 存储 zw
        vfw[i__] = vf[idxq[i__]];  // 存储 vfw
        vlw[i__] = vl[idxq[i__]];  // 存储 vlw
/* L40: */
    }

    dlamrg_(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);  // 调用排序函数 dlamrg

    i__1 = n;                   // 对排序后的值进行重新排列
    for (i__ = 2; i__ <= i__1; ++i__) {
        idxi = idx[i__] + 1;    // 更新 idxi
        d__[i__] = dsigma[idxi];  // 更新 d__
        z__[i__] = zw[idxi];    // 更新 z__
        vf[i__] = vfw[idxi];    // 更新 vf
        vl[i__] = vlw[idxi];    // 更新 vl
/* L50: */
    }

/*     Calculate the allowable deflation tolerence */

    eps = EPSILON;              // 设置 eps 为 EPSILON
/* Computing MAX */
    d__1 = abs(*alpha), d__2 = abs(*beta);  // 计算绝对值的最大值
    tol = max(d__1,d__2);       // 计算 tol 的值为最大值
/* Computing MAX */
    d__2 = (d__1 = d__[n], abs(d__1));  // 计算 d__[n] 的绝对值
    tol = eps * 64. * max(d__2,tol);  // 计算 tol 的值
/*
   这段代码用于在奇异值分解过程中进行缩减（deflation）操作。
   奇异值分解时，可能会出现两种情况需要进行缩减：
   1. z 向量中的某个值很小，此时将对应的奇异值移到数组末尾。
   2. D 向量中两个或多个奇异值非常接近，它们的差异很小，此时进行双边旋转操作，使得其中一个 z 向量条目为零，并将对应的奇异值移到数组末尾。

   如果存在多个奇异值，则问题进行缩减。
   此处找到相等奇异值的数量，对于每个相等的奇异值，计算一个反射变换器，旋转相应的奇异子空间，使得 Z 的相应组件在新的基础上为零。
*/
*k = 1;  // 初始化 k 为 1，用于记录缩减后剩余的奇异值个数
k2 = n + 1;  // 初始化 k2 为 n+1，用于记录要缩减的奇异值索引
i__1 = n;
for (j = 2; j <= i__1; ++j) {
if ((d__1 = z__[j], abs(d__1)) <= tol) {

/*           由于 z 分量很小而进行缩减。 */

    --k2;  // k2 减一，表示要缩减的奇异值数量加一
    idxp[k2] = j;  // 记录要缩减的奇异值的索引
    if (j == n) {
    goto L100;  // 如果 j 等于 n，跳转到 L100 标签处
    }
} else {
    jprev = j;
    goto L70;  // 否则跳转到 L70 标签处
}
/* L60: */
}
L70:
j = jprev;  // 设置 j 为 jprev 的值
L80:
++j;  // j 加一
if (j > n) {
goto L90;  // 如果 j 大于 n，跳转到 L90 标签处
}
if ((d__1 = z__[j], abs(d__1)) <= tol) {

/*        由于 z 分量很小而进行缩减。 */

--k2;  // k2 减一，表示要缩减的奇异值数量加一
idxp[k2] = j;  // 记录要缩减的奇异值的索引
} else {

/*        检查奇异值是否足够接近以进行缩减。 */

if ((d__1 = d__[j] - d__[jprev], abs(d__1)) <= tol) {

/*           可以进行缩减。 */

    *s = z__[jprev];  // 记录 z[jprev] 到 s
    *c__ = z__[j];  // 记录 z[j] 到 c__

/*
         找到 sqrt(a**2+b**2) 而不会溢出或破坏性下溢。
*/

    tau = dlapy2_(c__, s);  // 计算 dlapy2 函数的结果到 tau
    z__[j] = tau;  // 将 tau 赋值给 z[j]
    z__[jprev] = 0.;  // 将 z[jprev] 置零
    *c__ /= tau;  // c 除以 tau
    *s = -(*s) / tau;  // s 除以 tau 取负

/*           记录适当的 Givens 旋转 */

    if (*icompq == 1) {
    ++(*givptr);  // givptr 加一
    idxjp = idxq[idx[jprev] + 1];  // 计算 idxjp
    idxj = idxq[idx[j] + 1];  // 计算 idxj
    if (idxjp <= nlp1) {
        --idxjp;  // 如果 idxjp 小于等于 nlp1，idxjp 减一
    }
    if (idxj <= nlp1) {
        --idxj;  // 如果 idxj 小于等于 nlp1，idxj 减一
    }
    givcol[*givptr + (givcol_dim1 << 1)] = idxjp;  // 记录 idxjp 到 givcol
    givcol[*givptr + givcol_dim1] = idxj;  // 记录 idxj 到 givcol
    givnum[*givptr + (givnum_dim1 << 1)] = *c__;  // 记录 c 到 givnum
    givnum[*givptr + givnum_dim1] = *s;  // 记录 s 到 givnum
    }
    drot_(&c__1, &vf[jprev], &c__1, &vf[j], &c__1, c__, s);  // 调用 drot_ 函数
    drot_(&c__1, &vl[jprev], &c__1, &vl[j], &c__1, c__, s);  // 调用 drot_ 函数
    --k2;  // k2 减一
    idxp[k2] = jprev;  // 记录要缩减的奇异值的索引
    jprev = j;  // 设置 jprev 为 j 的值
} else {
    ++(*k);  // k 加一
    zw[*k] = z__[jprev];  // 记录 z[jprev] 到 zw
    dsigma[*k] = d__[jprev];  // 记录 d[jprev] 到 dsigma
    idxp[*k] = jprev;  // 记录要缩减的奇异值的索引
    jprev = j;  // 设置 jprev 为 j 的值
}
}
goto L80;  // 跳转到 L80 标签处
L90:

/*     记录最后一个奇异值。 */

++(*k);  // k 加一
zw[*k] = z__[jprev];  // 记录 z[jprev] 到 zw
dsigma[*k] = d__[jprev];  // 记录 d[jprev] 到 dsigma
idxp[*k] = jprev;  // 记录要缩减的奇异值的索引

L100:
/*
       Sort the singular values into DSIGMA. The singular values which
       were not deflated go into the first K slots of DSIGMA, except
       that DSIGMA(1) is treated separately.
*/

i__1 = n;
for (j = 2; j <= i__1; ++j) {
    jp = idxp[j];
    dsigma[j] = d__[jp];
    vfw[j] = vf[jp];
    vlw[j] = vl[jp];
/* L110: */
}

if (*icompq == 1) {
    i__1 = n;
    for (j = 2; j <= i__1; ++j) {
        jp = idxp[j];
        perm[j] = idxq[idx[jp] + 1];
        if (perm[j] <= nlp1) {
            --perm[j];
        }
/* L120: */
    }
}

/*
       The deflated singular values go back into the last N - K slots of
       D.
*/

i__1 = n - *k;
dcopy_(&i__1, &dsigma[*k + 1], &c__1, &d__[*k + 1], &c__1);

/*
       Determine DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), and
       VL(M).
*/

dsigma[1] = 0.;
hlftol = tol / 2.;
if (abs(dsigma[2]) <= hlftol) {
    dsigma[2] = hlftol;
}

if (m > n) {
    z__[1] = dlapy2_(&z1, &z__[m]);
    if (z__[1] <= tol) {
        *c__ = 1.;
        *s = 0.;
        z__[1] = tol;
    } else {
        *c__ = z1 / z__[1];
        *s = -z__[m] / z__[1];
    }
    drot_(&c__1, &vf[m], &c__1, &vf[1], &c__1, c__, s);
    drot_(&c__1, &vl[m], &c__1, &vl[1], &c__1, c__, s);
} else {
    if (abs(z1) <= tol) {
        z__[1] = tol;
    } else {
        z__[1] = z1;
    }
}

/*     Restore Z, VF, and VL. */

i__1 = *k - 1;
dcopy_(&i__1, &zw[2], &c__1, &z__[2], &c__1);
i__1 = n - 1;
dcopy_(&i__1, &vfw[2], &c__1, &vf[2], &c__1);
i__1 = n - 1;
dcopy_(&i__1, &vlw[2], &c__1, &vl[2], &c__1);

return 0;

/*     End of DLASD7 */
} /* dlasd7_ */

/* Subroutine */ int dlasd8_(integer *icompq, integer *k, doublereal *d__,
    doublereal *z__, doublereal *vf, doublereal *vl, doublereal *difl,
    doublereal *difr, integer *lddifr, doublereal *dsigma, doublereal *
    work, integer *info)
{
/* System generated locals */
integer difr_dim1, difr_offset, i__1, i__2;
doublereal d__1, d__2;

/* Local variables */
static integer i__, j;
static doublereal dj, rho;
static integer iwk1, iwk2, iwk3;
extern doublereal ddot_(integer *, doublereal *, integer *, doublereal *,
    integer *);
static doublereal temp;
extern doublereal dnrm2_(integer *, doublereal *, integer *);
static integer iwk2i, iwk3i;
static doublereal diflj, difrj, dsigj;
extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
    doublereal *, integer *);
extern doublereal dlamc3_(doublereal *, doublereal *);


注释：
    # 外部子程序声明，声明了几个外部函数：dlasd4_, dlascl_, dlaset_, xerbla_
    extern /* Subroutine */ int dlasd4_(integer *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, integer *),

        # 函数声明：dlascl_
        dlascl_(char *, integer *, integer *,
        
        # 参数声明：dlascl_
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        
        # 参数声明：dlascl_
        integer *, integer *),
        
        # 函数声明：dlaset_
        dlaset_(char *, integer *, integer *,
        
        # 参数声明：dlaset_
        doublereal *, doublereal *, doublereal *, integer *),
        
        # 函数声明：xerbla_
        xerbla_(char *, integer *);
    
    # 静态变量声明，声明了一个静态的双精度浮点数变量 dsigjp
    static doublereal dsigjp;
"""
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    DLASD8 finds the square roots of the roots of the secular equation,
    as defined by the values in DSIGMA and Z. It makes the appropriate
    calls to DLASD4, and stores, for each  element in D, the distance
    to its two nearest poles (elements in DSIGMA). It also updates
    the arrays VF and VL, the first and last components of all the
    right singular vectors of the original bidiagonal matrix.

    DLASD8 is called from DLASD6.

    Arguments
    =========

    ICOMPQ  (input) INTEGER
            Specifies whether singular vectors are to be computed in
            factored form in the calling routine:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.

    K       (input) INTEGER
            The number of terms in the rational function to be solved
            by DLASD4.  K >= 1.

    D       (output) DOUBLE PRECISION array, dimension ( K )
            On output, D contains the updated singular values.

    Z       (input/output) DOUBLE PRECISION array, dimension ( K )
            On entry, the first K elements of this array contain the
            components of the deflation-adjusted updating row vector.
            On exit, Z is updated.

    VF      (input/output) DOUBLE PRECISION array, dimension ( K )
            On entry, VF contains  information passed through DBEDE8.
            On exit, VF contains the first K components of the first
            components of all right singular vectors of the bidiagonal
            matrix.

    VL      (input/output) DOUBLE PRECISION array, dimension ( K )
            On entry, VL contains  information passed through DBEDE8.
            On exit, VL contains the first K components of the last
            components of all right singular vectors of the bidiagonal
            matrix.

    DIFL    (output) DOUBLE PRECISION array, dimension ( K )
            On exit, DIFL(I) = D(I) - DSIGMA(I).

    DIFR    (output) DOUBLE PRECISION array,
                     dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                     dimension ( K ) if ICOMPQ = 0.
            On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
            defined and will not be referenced.

            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.

    LDDIFR  (input) INTEGER
            The leading dimension of DIFR, must be at least K.
"""
    DSIGMA  (input/output) DOUBLE PRECISION array, dimension ( K )
            On entry, the first K elements of this array contain the old
            roots of the deflated updating problem.  These are the poles
            of the secular equation.
            On exit, the elements of DSIGMA may be very slightly altered
            in value.

    WORK    (workspace) DOUBLE PRECISION array, dimension at least 3 * K
            Workspace array used for intermediate calculations in the function.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            Integer variable used to indicate the status of the function after execution.

    Further Details
    ===============

    Based on contributions by
       Ming Gu and Huan Ren, Computer Science Division, University of
       California at Berkeley, USA

    =====================================================================


       Test the input parameters.
    /* Parameter adjustments */
    --d__;
    --z__;
    --vf;
    --vl;
    --difl;
    difr_dim1 = *lddifr;
    difr_offset = 1 + difr_dim1;
    difr -= difr_offset;
    --dsigma;
    --work;

    /* Function Body */
    *info = 0;

    if (*icompq < 0 || *icompq > 1) {
        *info = -1;
    } else if (*k < 1) {
        *info = -2;
    } else if (*lddifr < *k) {
        *info = -9;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLASD8", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*k == 1) {
        d__[1] = abs(z__[1]);
        difl[1] = d__[1];
        if (*icompq == 1) {
            difl[2] = 1.;
            difr[(difr_dim1 << 1) + 1] = 1.;
        }
        return 0;
    }

    /*
       Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
       be computed with high relative accuracy (barring over/underflow).
       This is a problem on machines without a guard digit in
       add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
       The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
       which on any of these machines zeros out the bottommost
       bit of DSIGMA(I) if it is 1; this makes the subsequent
       subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
       occurs. On binary machines with a guard digit (almost all
       machines) it does not change DSIGMA(I) at all. On hexadecimal
       and decimal machines with a guard digit, it slightly
       changes the bottommost bits of DSIGMA(I). It does not account
       for hexadecimal or decimal machines without guard digits
       (we know of none). We use a subroutine call to compute
       2*DLAMBDA(I) to prevent optimizing compilers from eliminating
       this code.
    */
    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
        dsigma[i__] = dlamc3_(&dsigma[i__], &dsigma[i__]) - dsigma[i__];
        /* L10: */
    }

    /* Book keeping. */
    iwk1 = 1;
    iwk2 = iwk1 + *k;
    iwk3 = iwk2 + *k;
    iwk2i = iwk2 - 1;
    iwk3i = iwk3 - 1;

    /* Normalize Z. */
    rho = dnrm2_(k, &z__[1], &c__1);
    dlascl_("G", &c__0, &c__0, &rho, &c_b15, k, &c__1, &z__[1], k, info);
    rho *= rho;

    /* Initialize WORK(IWK3). */
    dlaset_("A", k, &c__1, &c_b15, &c_b15, &work[iwk3], k);

    /*
       Compute the updated singular values, the arrays DIFL, DIFR,
       and the updated Z.
    */
    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
        dlasd4_(k, &j, &dsigma[1], &z__[1], &work[iwk1], &rho, &d__[j], &work[iwk2], info);

        /* If the root finder fails, the computation is terminated. */
        if (*info != 0) {
            return 0;
        }

        work[iwk3i + j] = work[iwk3i + j] * work[j] * work[iwk2i + j];
        difl[j] = -work[j];
        difr[j + difr_dim1] = -work[j + 1];
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            work[iwk3i + i__] = work[iwk3i + i__] * work[i__] * work[iwk2i + i__] / (dsigma[i__] - dsigma[j]) / (dsigma[i__] + dsigma[j]);
            /* L20: */
        }
    }
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        // 对于变量 i__，从 j+1 循环到 i__2
        work[iwk3i + i__] = work[iwk3i + i__] * work[i__] * work[iwk2i +
            i__] / (dsigma[i__] - dsigma[j]) / (dsigma[i__] + dsigma[
            j]);
        // 计算 work 数组中的元素，根据给定的表达式进行乘法和除法运算
        // dsigma 是一个数组，使用其元素 dsigma[i__] 和 dsigma[j] 进行数学运算
    }
/* L30: */
    }
/* L40: */
    }

/*     Compute updated Z. */

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
    d__2 = sqrt((d__1 = work[iwk3i + i__], abs(d__1)));
    z__[i__] = d_sign(&d__2, &z__[i__]);
/* L50: */
    }

/*     Update VF and VL. */

    i__1 = *k;
    for (j = 1; j <= i__1; ++j) {
    diflj = difl[j];
    dj = d__[j];
    dsigj = -dsigma[j];
    if (j < *k) {
        difrj = -difr[j + difr_dim1];
        dsigjp = -dsigma[j + 1];
    }
    work[j] = -z__[j] / diflj / (dsigma[j] + dj);
    i__2 = j - 1;
    for (i__ = 1; i__ <= i__2; ++i__) {
        work[i__] = z__[i__] / (dlamc3_(&dsigma[i__], &dsigj) - diflj) / (
            dsigma[i__] + dj);
/* L60: */
    }
    i__2 = *k;
    for (i__ = j + 1; i__ <= i__2; ++i__) {
        work[i__] = z__[i__] / (dlamc3_(&dsigma[i__], &dsigjp) + difrj) /
            (dsigma[i__] + dj);
/* L70: */
    }
    temp = dnrm2_(k, &work[1], &c__1);
    work[iwk2i + j] = ddot_(k, &work[1], &c__1, &vf[1], &c__1) / temp;
    work[iwk3i + j] = ddot_(k, &work[1], &c__1, &vl[1], &c__1) / temp;
    if (*icompq == 1) {
        difr[j + (difr_dim1 << 1)] = temp;
    }
/* L80: */
    }

    dcopy_(k, &work[iwk2], &c__1, &vf[1], &c__1);
    dcopy_(k, &work[iwk3], &c__1, &vl[1], &c__1);

    return 0;

/*     End of DLASD8 */

} /* dlasd8_ */

/* Subroutine */ int dlasda_(integer *icompq, integer *smlsiz, integer *n,
    integer *sqre, doublereal *d__, doublereal *e, doublereal *u, integer
    *ldu, doublereal *vt, integer *k, doublereal *difl, doublereal *difr,
    doublereal *z__, doublereal *poles, integer *givptr, integer *givcol,
    integer *ldgcol, integer *perm, doublereal *givnum, doublereal *c__,
    doublereal *s, doublereal *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
        difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
        poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
        z_dim1, z_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, m, i1, ic, lf, nd, ll, nl, vf, nr, vl, im1, ncc,
        nlf, nrf, vfi, iwk, vli, lvl, nru, ndb1, nlp1, lvl2, nrp1;
    static doublereal beta;
    static integer idxq, nlvl;
    static doublereal alpha;
    static integer inode, ndiml, ndimr, idxqi, itemp;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer sqrei;
    extern /* Subroutine */ int dlasd6_(integer *, integer *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         doublereal *, integer *, integer *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         doublereal *, integer *, integer *);
    static integer nwork1, nwork2;
    extern /* Subroutine */ int dlasdq_(char *, integer *, integer *, integer
        *, integer *, integer *, doublereal *, doublereal *, doublereal *,
         integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *), dlasdt_(integer *, integer *,
        integer *, integer *, integer *, integer *, integer *);

    // 外部声明：dlasdq、dlasdt 和 xerbla 子程序的原型声明

    static integer smlszp;

    // 声明一个静态整数变量 smlszp
"""
    -- LAPACK auxiliary routine (version 3.2.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       June 2010


    Purpose
    =======

    Using a divide and conquer approach, DLASDA computes the singular
    value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
    B with diagonal D and offdiagonal E, where M = N + SQRE. The
    algorithm computes the singular values in the SVD B = U * S * VT.
    The orthogonal matrices U and VT are optionally computed in
    compact form.

    A related subroutine, DLASD0, computes the singular values and
    the singular vectors in explicit form.

    Arguments
    =========

    ICOMPQ (input) INTEGER
           Specifies whether singular vectors are to be computed
           in compact form, as follows
           = 0: Compute singular values only.
           = 1: Compute singular vectors of upper bidiagonal
                matrix in compact form.

    SMLSIZ (input) INTEGER
           The maximum size of the subproblems at the bottom of the
           computation tree.

    N      (input) INTEGER
           The row dimension of the upper bidiagonal matrix. This is
           also the dimension of the main diagonal array D.

    SQRE   (input) INTEGER
           Specifies the column dimension of the bidiagonal matrix.
           = 0: The bidiagonal matrix has column dimension M = N;
           = 1: The bidiagonal matrix has column dimension M = N + 1.

    D      (input/output) DOUBLE PRECISION array, dimension ( N )
           On entry D contains the main diagonal of the bidiagonal
           matrix. On exit D, if INFO = 0, contains its singular values.

    E      (input) DOUBLE PRECISION array, dimension ( M-1 )
           Contains the subdiagonal entries of the bidiagonal matrix.
           On exit, E has been destroyed.

    U      (output) DOUBLE PRECISION array,
           dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
           singular vector matrices of all subproblems at the bottom
           level.

    LDU    (input) INTEGER, LDU = > N.
           The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
           GIVNUM, and Z.

    VT     (output) DOUBLE PRECISION array,
           dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
           if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT' contains the right
           singular vector matrices of all subproblems at the bottom
           level.

    K      (output) INTEGER array,
           dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
           If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
           secular equation on the computation tree.

    DIFL   (output) DOUBLE PRECISION array, dimension ( LDU, NLVL ),
           where NLVL = floor(log_2 (N/SMLSIZ))).

"""
    # DIFR 是一个输出的双精度数组，如果 ICOMPQ = 1，则大小为 (LDU, 2 * NLVL)，如果 ICOMPQ = 0，则大小为 (N)。
    # 如果 ICOMPQ = 1，则在退出时，DIFL(1:N, I) 和 DIFR(1:N, 2 * I - 1) 记录第 I 级别与第 (I - 1) 级别之间奇异值的距离，
    # DIFR(1:N, 2 * I) 包含右奇异向量矩阵的归一化因子。详细信息请参见 DLASD8。

    # Z 是一个输出的双精度数组，如果 ICOMPQ = 1，则大小为 (LDU, NLVL)，如果 ICOMPQ = 0，则大小为 (N)。
    # Z(1, I) 的前 K 个元素包含第 I 级别子问题的平减调整更新行向量的分量。

    # POLES 是一个输出的双精度数组，如果 ICOMPQ = 1，则大小为 (LDU, 2 * NLVL)，如果 ICOMPQ = 0，则不引用。
    # 如果 ICOMPQ = 1，则在退出时，POLES(1, 2*I - 1) 和 POLES(1, 2*I) 包含第 I 级别中涉及的新旧奇异值，在截断方程中的奇异值。

    # GIVPTR 是一个输出的整数数组，如果 ICOMPQ = 1，则大小为 (N)，如果 ICOMPQ = 0，则不引用。
    # 如果 ICOMPQ = 1，则在退出时，GIVPTR(I) 记录在计算树的第 I 个问题上执行的 Givens 旋转的数量。

    # GIVCOL 是一个输出的整数数组，如果 ICOMPQ = 1，则大小为 (LDGCOL, 2 * NLVL)，如果 ICOMPQ = 0，则不引用。
    # 如果 ICOMPQ = 1，则在退出时，对于每个 I，GIVCOL(1, 2 * I - 1) 和 GIVCOL(1, 2 * I) 记录在计算树的第 I 级别上执行的 Givens 旋转的位置。

    # LDGCOL 是一个输入的整数，LDGCOL >= N。数组 GIVCOL 和 PERM 的领先维度。

    # PERM 是一个输出的整数数组，如果 ICOMPQ = 1，则大小为 (LDGCOL, NLVL)，如果 ICOMPQ = 0，则不引用。
    # 如果 ICOMPQ = 1，则在退出时，PERM(1, I) 记录在计算树的第 I 级别上执行的置换。

    # GIVNUM 是一个输出的双精度数组，如果 ICOMPQ = 1，则大小为 (LDU, 2 * NLVL)，如果 ICOMPQ = 0，则不引用。
    # 如果 ICOMPQ = 1，则在退出时，对于每个 I，GIVNUM(1, 2 * I - 1) 和 GIVNUM(1, 2 * I) 记录在计算树的第 I 级别上执行的 Givens 旋转的 C 值和 S 值。

    # C 是一个输出的双精度数组，如果 ICOMPQ = 1，则大小为 (N)，如果 ICOMPQ = 0，则大小为 1。
    # 如果 ICOMPQ = 1 并且第 I 个子问题不是方形的，则在退出时，C(I) 包含与第 I 个子问题的右零空间相关的 Givens 旋转的 C 值。
    # S (output) DOUBLE PRECISION array, dimension ( N ) if
    #    ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
    #    and the I-th subproblem is not square, on exit, S( I )
    #    contains the S-value of a Givens rotation related to
    #    the right null space of the I-th subproblem.
    
    WORK   (workspace) DOUBLE PRECISION array, dimension
           (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).

    IWORK  (workspace) INTEGER array.
           Dimension must be at least (7 * N).

    INFO   (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge

    # Further Details
    # ===============

    # Based on contributions by
    #    Ming Gu and Huan Ren, Computer Science Division, University of
    #    California at Berkeley, USA

    # =====================================================================

    # Test the input parameters.
/* Parameter adjustments */
--d__;                          // 调整参数 d__ 指针
--e;                            // 调整参数 e 指针
givnum_dim1 = *ldu;             // 设置 givnum 的第一维度大小为 ldu
givnum_offset = 1 + givnum_dim1;// 计算 givnum 数组的偏移量
givnum -= givnum_offset;        // 根据偏移量调整 givnum 数组指针
poles_dim1 = *ldu;              // 设置 poles 的第一维度大小为 ldu
poles_offset = 1 + poles_dim1;  // 计算 poles 数组的偏移量
poles -= poles_offset;          // 根据偏移量调整 poles 数组指针
z_dim1 = *ldu;                  // 设置 z__ 的第一维度大小为 ldu
z_offset = 1 + z_dim1;          // 计算 z__ 数组的偏移量
z__ -= z_offset;                // 根据偏移量调整 z__ 数组指针
difr_dim1 = *ldu;               // 设置 difr 的第一维度大小为 ldu
difr_offset = 1 + difr_dim1;    // 计算 difr 数组的偏移量
difr -= difr_offset;            // 根据偏移量调整 difr 数组指针
difl_dim1 = *ldu;               // 设置 difl 的第一维度大小为 ldu
difl_offset = 1 + difl_dim1;    // 计算 difl 数组的偏移量
difl -= difl_offset;            // 根据偏移量调整 difl 数组指针
vt_dim1 = *ldu;                 // 设置 vt 的第一维度大小为 ldu
vt_offset = 1 + vt_dim1;        // 计算 vt 数组的偏移量
vt -= vt_offset;                // 根据偏移量调整 vt 数组指针
u_dim1 = *ldu;                  // 设置 u 的第一维度大小为 ldu
u_offset = 1 + u_dim1;          // 计算 u 数组的偏移量
u -= u_offset;                  // 根据偏移量调整 u 数组指针
--k;                            // 调整参数 k 指针
--givptr;                       // 调整参数 givptr 指针
perm_dim1 = *ldgcol;            // 设置 perm 的第一维度大小为 ldgcol
perm_offset = 1 + perm_dim1;    // 计算 perm 数组的偏移量
perm -= perm_offset;            // 根据偏移量调整 perm 数组指针
givcol_dim1 = *ldgcol;          // 设置 givcol 的第一维度大小为 ldgcol
givcol_offset = 1 + givcol_dim1;// 计算 givcol 数组的偏移量
givcol -= givcol_offset;        // 根据偏移量调整 givcol 数组指针
--c__;                          // 调整参数 c__ 指针
--s;                            // 调整参数 s 指针
--work;                         // 调整 work 数组指针
--iwork;                        // 调整 iwork 数组指针

/* Function Body */
*info = 0;                      // 将 info 设为 0

if (*icompq < 0 || *icompq > 1) {   // 检查 icompq 的取值范围
*info = -1;                         // 若不在范围内，设置 info 为 -1
} else if (*smlsiz < 3) {           // 检查 smlsiz 是否小于 3
*info = -2;                         // 若小于 3，设置 info 为 -2
} else if (*n < 0) {                // 检查 n 是否小于 0
*info = -3;                         // 若小于 0，设置 info 为 -3
} else if (*sqre < 0 || *sqre > 1) { // 检查 sqre 是否在合法范围内
*info = -4;                         // 若不在范围内，设置 info 为 -4
} else if (*ldu < *n + *sqre) {     // 检查 ldu 是否足够大
*info = -8;                         // 若不足够大，设置 info 为 -8
} else if (*ldgcol < *n) {          // 检查 ldgcol 是否足够大
*info = -17;                        // 若不足够大，设置 info 为 -17
}
if (*info != 0) {                   // 若 info 不为 0，表示发现错误
i__1 = -(*info);                    // 计算错误代码的相反数
xerbla_("DLASDA", &i__1);           // 调用 xerbla 处理错误
return 0;                           // 返回
}

m = *n + *sqre;                     // 计算 m 的值

/* If the input matrix is too small, call DLASDQ to find the SVD. */
if (*n <= *smlsiz) {                // 如果输入矩阵大小小于或等于 smlsiz
if (*icompq == 0) {                 // 如果 icompq 为 0
    dlasdq_("U", sqre, n, &c__0, &c__0, &c__0, &d__[1], &e[1], &vt[
        vt_offset], ldu, &u[u_offset], ldu, &u[u_offset], ldu, &
        work[1], info);             // 调用 DLASDQ 计算 SVD
} else {
    dlasdq_("U", sqre, n, &m, n, &c__0, &d__[1], &e[1], &vt[vt_offset]
        , ldu, &u[u_offset], ldu, &u[u_offset], ldu, &work[1],
        info);                      // 调用 DLASDQ 计算 SVD
}
return 0;                           // 返回
}

/* Book-keeping and set up the computation tree. */
inode = 1;                          // 设置节点编号为 1
ndiml = inode + *n;                 // 计算左子问题维度的起始位置
ndimr = ndiml + *n;                 // 计算右子问题维度的起始位置
idxq = ndimr + *n;                  // 计算索引数组的起始位置
iwk = idxq + *n;                    // 计算工作数组的起始位置

ncc = 0;                            // 初始化计数器 ncc
nru = 0;                            // 初始化计数器 nru

smlszp = *smlsiz + 1;               // 计算 smlszp 的值
vf = 1;                             // 设置 vf 的起始位置
vl = vf + m;                        // 计算 vl 的起始位置
nwork1 = vl + m;                    // 计算 nwork1 的起始位置
nwork2 = nwork1 + smlszp * smlszp;  // 计算 nwork2 的起始位置

dlasdt_(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr],
    smlsiz);                        // 调用 dlasdt 初始化树结构

/*
   for the nodes on bottom level of the tree, solve
   their subproblems by DLASDQ.
*/
ndb1 = (nd + 1) / 2;                // 计算底层节点的起始位置
i__1 = nd;
for (i__ = ndb1; i__ <= i__1; ++i__) {

/*
      IC : center row of each node
      NL : number of rows of left  subproblem
      NR : number of rows of right subproblem
      NLF: starting row of the left   subproblem
      NRF: starting row of the right  subproblem
*/

i1 = i__ - 1;                       // 计算当前节点在数组中的索引
ic = iwork[inode + i1];             // 获取当前节点的中心行
nl = iwork[ndiml + i1];             // 获取左子问题的行数
nlp
    # 检查是否需要计算左右奇异向量
    if (*icompq == 0) {
        # 如果不需要计算左右奇异向量，初始化工作区域
        dlaset_("A", &nlp1, &nlp1, &c_b29, &c_b15, &work[nwork1], &smlszp);
        # 执行单边 SVD 分解，只计算右奇异向量
        dlasdq_("U", &sqrei, &nl, &nlp1, &nru, &ncc, &d__[nlf], &e[nlf], &
            work[nwork1], &smlszp, &work[nwork2], &nl, &work[nwork2],
            &nl, &work[nwork2], info);
        # 计算工作区域偏移量
        itemp = nwork1 + nl * smlszp;
        # 复制结果到工作区域
        dcopy_(&nlp1, &work[nwork1], &c__1, &work[vfi], &c__1);
        dcopy_(&nlp1, &work[itemp], &c__1, &work[vli], &c__1);
    } else {
        # 如果需要计算左右奇异向量，初始化工作区域
        dlaset_("A", &nl, &nl, &c_b29, &c_b15, &u[nlf + u_dim1], ldu);
        dlaset_("A", &nlp1, &nlp1, &c_b29, &c_b15, &vt[nlf + vt_dim1],
            ldu);
        # 执行双边 SVD 分解，计算左右奇异向量
        dlasdq_("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d__[nlf], &e[nlf], &
            vt[nlf + vt_dim1], ldu, &u[nlf + u_dim1], ldu, &u[nlf +
            u_dim1], ldu, &work[nwork1], info);
        # 复制结果到工作区域
        dcopy_(&nlp1, &vt[nlf + vt_dim1], &c__1, &work[vfi], &c__1);
        dcopy_(&nlp1, &vt[nlf + nlp1 * vt_dim1], &c__1, &work[vli], &c__1)
            ;
    }
    # 检查 SVD 分解过程中是否出错
    if (*info != 0) {
        return 0;
    }
    # 初始化索引数组，用于记录排序后的奇异值位置
    i__2 = nl;
    for (j = 1; j <= i__2; ++j) {
        iwork[idxqi + j] = j;
/* L10: */
    }
    // 检查是否为最后一个子问题，如果是且 sqre 为 0，则 sqrei 设为 0，否则设为 1
    if (i__ == nd && *sqre == 0) {
        sqrei = 0;
    } else {
        sqrei = 1;
    }
    // 更新索引值
    idxqi += nlp1;
    vfi += nlp1;
    vli += nlp1;
    // 计算新的子问题规模
    nrp1 = nr + sqrei;
    // 根据是否需要计算 Q 矩阵来设置工作空间和调用 SVD 分解函数
    if (*icompq == 0) {
        // 初始化工作空间中的矩阵为零
        dlaset_("A", &nrp1, &nrp1, &c_b29, &c_b15, &work[nwork1], &smlszp);
        // 调用 SVD 分解子例程
        dlasdq_("U", &sqrei, &nr, &nrp1, &nru, &ncc, &d__[nrf], &e[nrf], &
            work[nwork1], &smlszp, &work[nwork2], &nr, &work[nwork2],
            &nr, &work[nwork2], info);
        // 将结果复制回工作空间中
        itemp = nwork1 + (nrp1 - 1) * smlszp;
        dcopy_(&nrp1, &work[nwork1], &c__1, &work[vfi], &c__1);
        dcopy_(&nrp1, &work[itemp], &c__1, &work[vli], &c__1);
    } else {
        // 初始化 U 和 VT 矩阵为零
        dlaset_("A", &nr, &nr, &c_b29, &c_b15, &u[nrf + u_dim1], ldu);
        dlaset_("A", &nrp1, &nrp1, &c_b29, &c_b15, &vt[nrf + vt_dim1],
            ldu);
        // 调用 SVD 分解子例程
        dlasdq_("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d__[nrf], &e[nrf], &
            vt[nrf + vt_dim1], ldu, &u[nrf + u_dim1], ldu, &u[nrf +
            u_dim1], ldu, &work[nwork1], info);
        // 将结果复制回工作空间中
        dcopy_(&nrp1, &vt[nrf + vt_dim1], &c__1, &work[vfi], &c__1);
        dcopy_(&nrp1, &vt[nrf + nrp1 * vt_dim1], &c__1, &work[vli], &c__1);
    }
    // 如果返回的 info 不为 0，直接返回
    if (*info != 0) {
        return 0;
    }
    // 初始化子问题的索引数组
    i__2 = nr;
    for (j = 1; j <= i__2; ++j) {
        iwork[idxqi + j] = j;
/* L20: */
    }
/* L30: */
    }

/*     Now conquer each subproblem bottom-up. */

    // 计算当前层级的子问题数目
    j = pow_ii(&c__2, &nlvl);
    // 从最高层级开始往下解决每个子问题
    for (lvl = nlvl; lvl >= 1; --lvl) {
    lvl2 = (lvl << 1) - 1;

/*
          Find the first node LF and last node LL on
          the current level LVL.
*/

    // 确定当前层级 LVL 上的第一个节点 LF 和最后一个节点 LL
    if (lvl == 1) {
        lf = 1;
        ll = 1;
    } else {
        i__1 = lvl - 1;
        lf = pow_ii(&c__2, &i__1);
        ll = (lf << 1) - 1;
    }
    i__1 = ll;
    // 循环：遍历 lf 到 i__1 之间的每一个 i__
    for (i__ = lf; i__ <= i__1; ++i__) {
        // 计算 im1 作为 i__ 的前一个数值
        im1 = i__ - 1;
        // 从 iwork 中获取 inode + im1 处的值，赋给 ic
        ic = iwork[inode + im1];
        // 从 iwork 中获取 ndiml + im1 处的值，赋给 nl
        nl = iwork[ndiml + im1];
        // 从 iwork 中获取 ndimr + im1 处的值，赋给 nr
        nr = iwork[ndimr + im1];
        // 计算 nlf 作为 ic 减去 nl 的结果
        nlf = ic - nl;
        // 计算 nrf 作为 ic 加上 1 的结果
        nrf = ic + 1;
        
        // 如果 i__ 等于 ll，则将 *sqre 赋给 sqrei，否则将 1 赋给 sqrei
        if (i__ == ll) {
            sqrei = *sqre;
        } else {
            sqrei = 1;
        }
        
        // 计算 vfi、vli、idxqi 分别为 vf、vl、idxq 的偏移量加上 nlf
        vfi = vf + nlf - 1;
        vli = vl + nlf - 1;
        idxqi = idxq + nlf - 1;
        
        // 将 d__[ic] 赋给 alpha，将 e[ic] 赋给 beta
        alpha = d__[ic];
        beta = e[ic];
        
        // 根据 icompq 的值选择不同的操作路径
        if (*icompq == 0) {
            // 调用 dlasd6_ 函数，处理非对称情况
            dlasd6_(icompq, &nl, &nr, &sqrei, &d__[nlf], &work[vfi], &
                work[vli], &alpha, &beta, &iwork[idxqi], &perm[
                perm_offset], &givptr[1], &givcol[givcol_offset],
                ldgcol, &givnum[givnum_offset], ldu, &poles[
                poles_offset], &difl[difl_offset], &difr[difr_offset],
                &z__[z_offset], &k[1], &c__[1], &s[1], &work[nwork1],
                &iwork[iwk], info);
        } else {
            // 调用 dlasd6_ 函数，处理对称情况
            --j;
            dlasd6_(icompq, &nl, &nr, &sqrei, &d__[nlf], &work[vfi], &
                work[vli], &alpha, &beta, &iwork[idxqi], &perm[nlf +
                lvl * perm_dim1], &givptr[j], &givcol[nlf + lvl2 *
                givcol_dim1], ldgcol, &givnum[nlf + lvl2 *
                givnum_dim1], ldu, &poles[nlf + lvl2 * poles_dim1], &
                difl[nlf + lvl * difl_dim1], &difr[nlf + lvl2 *
                difr_dim1], &z__[nlf + lvl * z_dim1], &k[j], &c__[j],
                &s[j], &work[nwork1], &iwork[iwk], info);
        }
        
        // 如果 info 不等于 0，则返回 0
        if (*info != 0) {
            return 0;
        }
    }
    /* L40: */
    }
    /* L50: */
    }

    return 0;

/*     End of DLASDA */

} /* dlasda_ */

/* Subroutine */ int dlasdq_(char *uplo, integer *sqre, integer *n, integer *
    ncvt, integer *nru, integer *ncc, doublereal *d__, doublereal *e,
    doublereal *vt, integer *ldvt, doublereal *u, integer *ldu,
    doublereal *c__, integer *ldc, doublereal *work, integer *info)
{
    /* System generated locals */
    integer c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1,
        i__2;

    /* Local variables */
    static integer i__, j;
    static doublereal r__, cs, sn;
    static integer np1, isub;
    static doublereal smin;
    static integer sqre1;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dlasr_(char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *);
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer iuplo;
    extern /* Subroutine */ int dlartg_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *), xerbla_(char *,
        integer *);
    extern /* Subroutine */ int dbdsqr_(char *, integer *, integer *, integer
        *, integer *, doublereal *, doublereal *, doublereal *, integer *,
         doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *);
    static logical rotate;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASDQ computes the singular value decomposition (SVD) of a real
    (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
    E, accumulating the transformations if desired. Letting B denote
    the input bidiagonal matrix, the algorithm computes orthogonal
    matrices Q and P such that B = Q * S * P' (P' denotes the transpose
    of P). The singular values S are overwritten on D.

    The input matrix U  is changed to U  * Q  if desired.
    The input matrix VT is changed to P' * VT if desired.
    The input matrix C  is changed to Q' * C  if desired.

    See "Computing  Small Singular Values of Bidiagonal Matrices With
    Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
    LAPACK Working Note #3, for a detailed description of the algorithm.

    Arguments
    =========

    UPLO  (input) CHARACTER*1
          On entry, UPLO specifies whether the input bidiagonal matrix
          is upper or lower bidiagonal, and whether it is square or
          not.
             UPLO = 'U' or 'u'   B is upper bidiagonal.
             UPLO = 'L' or 'l'   B is lower bidiagonal.


注释：
    SQRE  (input) INTEGER
          = 0: then the input matrix is N-by-N.
          = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
               (N+1)-by-N if UPLU = 'L'.

          The bidiagonal matrix has
          N = NL + NR + 1 rows and
          M = N + SQRE >= N columns.


    N     (input) INTEGER
          On entry, N specifies the number of rows and columns
          in the matrix. N must be at least 0.


    NCVT  (input) INTEGER
          On entry, NCVT specifies the number of columns of
          the matrix VT. NCVT must be at least 0.


    NRU   (input) INTEGER
          On entry, NRU specifies the number of rows of
          the matrix U. NRU must be at least 0.


    NCC   (input) INTEGER
          On entry, NCC specifies the number of columns of
          the matrix C. NCC must be at least 0.


    D     (input/output) DOUBLE PRECISION array, dimension (N)
          On entry, D contains the diagonal entries of the
          bidiagonal matrix whose SVD is desired. On normal exit,
          D contains the singular values in ascending order.


    E     (input/output) DOUBLE PRECISION array.
          dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
          On entry, the entries of E contain the offdiagonal entries
          of the bidiagonal matrix whose SVD is desired. On normal
          exit, E will contain 0. If the algorithm does not converge,
          D and E will contain the diagonal and superdiagonal entries
          of a bidiagonal matrix orthogonally equivalent to the one
          given as input.


    VT    (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
          On entry, contains a matrix which on exit has been
          premultiplied by P', dimension N-by-NCVT if SQRE = 0
          and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).


    LDVT  (input) INTEGER
          On entry, LDVT specifies the leading dimension of VT as
          declared in the calling (sub) program. LDVT must be at
          least 1. If NCVT is nonzero LDVT must also be at least N.


    U     (input/output) DOUBLE PRECISION array, dimension (LDU, N)
          On entry, contains a  matrix which on exit has been
          postmultiplied by Q, dimension NRU-by-N if SQRE = 0
          and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).


    LDU   (input) INTEGER
          On entry, LDU  specifies the leading dimension of U as
          declared in the calling (sub) program. LDU must be at
          least max( 1, NRU ) .


    C     (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
          On entry, contains an N-by-NCC matrix which on exit
          has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
          and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).


    LDC   (input) INTEGER
          On entry, LDC  specifies the leading dimension of C as
          declared in the calling (sub) program. LDC must be at
          least 1. If NCC is nonzero, LDC must also be at least N.
    # WORK (workspace) 是一个 DOUBLE PRECISION 类型的数组，维度为 (4*N)
    # 工作空间。只有当 NCVT、NRU 或 NCC 中至少一个不为零且 N 至少为 2 时才会被引用。

    # INFO (输出) 是一个整数
    # 在退出时，值为 0 表示成功完成。
    # 如果 INFO < 0，表示第 -INFO 个参数非法。
    # 如果 INFO > 0，表示算法未收敛，INFO 指定了未收敛的超对角线数量。

    # 进一步细节
    # ===============

    # 基于以下贡献而来
    # Ming Gu 和 Huan Ren，加州大学伯克利分校计算机科学系，美国

    # =====================================================================

    # 检测输入参数。
    /* Parameter adjustments */
    --d__;              ! 调整数组 d__，将指针向前移动
    --e;                ! 调整数组 e，将指针向前移动
    vt_dim1 = *ldvt;    ! 计算 vt 数组的第一维大小
    vt_offset = 1 + vt_dim1;  ! 计算 vt 数组的偏移量
    vt -= vt_offset;    ! 调整 vt 数组，根据偏移量进行指针调整
    u_dim1 = *ldu;      ! 计算 u 数组的第一维大小
    u_offset = 1 + u_dim1;    ! 计算 u 数组的偏移量
    u -= u_offset;      ! 调整 u 数组，根据偏移量进行指针调整
    c_dim1 = *ldc;      ! 计算 c__ 数组的第一维大小
    c_offset = 1 + c_dim1;    ! 计算 c__ 数组的偏移量
    c__ -= c_offset;    ! 调整 c__ 数组，根据偏移量进行指针调整
    --work;             ! 调整数组 work，将指针向前移动

    /* Function Body */
    *info = 0;          ! 将 *info 初始化为 0
    iuplo = 0;          ! 初始化 iuplo 为 0
    if (lsame_(uplo, "U")) {    ! 检查 uplo 是否为 "U"
        iuplo = 1;       ! 若是，则设置 iuplo 为 1
    }
    if (lsame_(uplo, "L")) {    ! 检查 uplo 是否为 "L"
        iuplo = 2;       ! 若是，则设置 iuplo 为 2
    }
    if (iuplo == 0) {           ! 如果 iuplo 仍为 0
        *info = -1;      ! 设置 *info 为 -1，表示错误信息
    } else if (*sqre < 0 || *sqre > 1) {   ! 检查 sqre 的取值范围
        *info = -2;      ! 设置 *info 为 -2，表示错误信息
    } else if (*n < 0) {        ! 检查 n 是否小于 0
        *info = -3;      ! 设置 *info 为 -3，表示错误信息
    } else if (*ncvt < 0) {     ! 检查 ncvt 是否小于 0
        *info = -4;      ! 设置 *info 为 -4，表示错误信息
    } else if (*nru < 0) {      ! 检查 nru 是否小于 0
        *info = -5;      ! 设置 *info 为 -5，表示错误信息
    } else if (*ncc < 0) {      ! 检查 ncc 是否小于 0
        *info = -6;      ! 设置 *info 为 -6，表示错误信息
    } else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < max(1,*n)) {    ! 检查 ldvt 的取值范围
        *info = -10;     ! 设置 *info 为 -10，表示错误信息
    } else if (*ldu < max(1,*nru)) {    ! 检查 ldu 的取值范围
        *info = -12;     ! 设置 *info 为 -12，表示错误信息
    } else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < max(1,*n)) {    ! 检查 ldc 的取值范围
        *info = -14;     ! 设置 *info 为 -14，表示错误信息
    }
    if (*info != 0) {           ! 如果 *info 不为 0，则发生错误
        i__1 = -(*info);        ! 计算错误码的相反数
        xerbla_("DLASDQ", &i__1);    ! 调用错误处理函数 xerbla_
        return 0;               ! 返回 0
    }
    if (*n == 0) {              ! 如果 n 等于 0
        return 0;               ! 直接返回 0
    }

/*     ROTATE is true if any singular vectors desired, false otherwise */

    rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;    ! 根据条件判断是否需要旋转矢量
    np1 = *n + 1;               ! 计算 n+1
    sqre1 = *sqre;              ! 将 sqre 赋给 sqre1

/*
       If matrix non-square upper bidiagonal, rotate to be lower
       bidiagonal.  The rotations are on the right.
*/

    if (iuplo == 1 && sqre1 == 1) {     ! 如果上三角且为非方阵
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {   ! 循环处理主对角线以下的元素
            dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__);   ! 计算 Givens 旋转参数
            d__[i__] = r__;         ! 更新 d 数组
            e[i__] = sn * d__[i__ + 1];     ! 更新 e 数组
            d__[i__ + 1] = cs * d__[i__ + 1];   ! 更新 d 数组
            if (rotate) {           ! 如果需要旋转矢量
                work[i__] = cs;     ! 存储旋转参数
                work[*n + i__] = sn;    ! 存储旋转参数
            }
/* L10: */
        }
        dlartg_(&d__[*n], &e[*n], &cs, &sn, &r__);   ! 计算最后一个元素的 Givens 旋转参数
        d__[*n] = r__;          ! 更新 d 数组
        e[*n] = 0.;             ! 将 e 数组最后一个元素置零
        if (rotate) {           ! 如果需要旋转矢量
            work[*n] = cs;      ! 存储旋转参数
            work[*n + *n] = sn;     ! 存储旋转参数
        }
        iuplo = 2;              ! 更新 iuplo
        sqre1 = 0;              ! 更新 sqre1

/*        Update singular vectors if desired. */

        if (*ncvt > 0) {        ! 如果需要更新右奇异向量
            dlasr_("L", "V", "F", &np1, ncvt, &work[1], &work[np1], &vt[
                vt_offset], ldvt);     ! 调用 dlasr 更新右奇异向量
        }
    }

/*
       If matrix lower bidiagonal, rotate to be upper bidiagonal
       by applying Givens rotations on the left.
*/

    if (iuplo == 2) {           ! 如果为下三角矩阵
        i__1 = *n - 1;
        for (i__ = 1; i__ <= i__1; ++i__) {   ! 循环处理主对角线以上的元素
            dlartg_(&d__[i__], &e[i__], &cs, &sn, &r__);   ! 计算 Givens 旋转参数
            d__[i__] = r__;         ! 更新 d 数组
            e[i__] = sn * d__[i__ + 1];     ! 更新 e 数组
            d__[i__ + 1] = cs * d__[i__ + 1];   ! 更新 d 数组
            if (rotate) {           ! 如果需要旋转矢量
                work[i__] = cs;     ! 存储旋转参数
                work[*n + i__] = sn;    ! 存储旋转参数
            }
/* L20: */
        }

/*
          If matrix (N+1)-by-N lower bidiagonal, one additional
          rotation is needed.
*/

        if (sqre1 == 1) {       ! 如果是 (N+1)-by-N 的下三角矩阵
            dlartg_(&d
   `
    # 如果非零行数 nru 大于 0
    if (*nru > 0) {
        # 如果 sqre1 为 0
        if (sqre1 == 0) {
            # 对右侧进行反射变换，结果覆盖原数据
            dlasr_("R", "V", "F", nru, n, &work[1], &work[np1], &u[
                u_offset], ldu);
        } else {
            # 对右侧进行反射变换，结果覆盖原数据
            dlasr_("R", "V", "F", nru, &np1, &work[1], &work[np1], &u[
                u_offset], ldu);
        }
    }
    # 如果非零列数 ncc 大于 0
    if (*ncc > 0) {
        # 如果 sqre1 为 0
        if (sqre1 == 0) {
            # 对左侧进行反射变换，结果覆盖原数据
            dlasr_("L", "V", "F", n, ncc, &work[1], &work[np1], &c__[
                c_offset], ldc);
        } else {
            # 对左侧进行反射变换，结果覆盖原数据
            dlasr_("L", "V", "F", &np1, ncc, &work[1], &work[np1], &c__[
                c_offset], ldc);
        }
    }
/*
       调用 DBDSQR 来计算降维后的实数 N × N 上三角双对角矩阵的奇异值分解（SVD）。
*/

dbdsqr_("U", n, ncvt, nru, ncc, &d__[1], &e[1], &vt[vt_offset], ldvt, &u[
    u_offset], ldu, &c__[c_offset], ldc, &work[1], info);

/*
       将奇异值按升序排序（对奇异值进行插入排序，但每个奇异向量只需进行一次转置）
*/

i__1 = *n;
for (i__ = 1; i__ <= i__1; ++i__) {

/*        扫描最小的 D(I)。*/

    isub = i__;
    smin = d__[i__];
    i__2 = *n;
    for (j = i__ + 1; j <= i__2; ++j) {
        if (d__[j] < smin) {
        isub = j;
        smin = d__[j];
        }
/* L30: */
    }
    if (isub != i__) {

/*           交换奇异值和向量。*/

        d__[isub] = d__[i__];
        d__[i__] = smin;
        if (*ncvt > 0) {
        dswap_(ncvt, &vt[isub + vt_dim1], ldvt, &vt[i__ + vt_dim1],
            ldvt);
        }
        if (*nru > 0) {
        dswap_(nru, &u[isub * u_dim1 + 1], &c__1, &u[i__ * u_dim1 + 1]
            , &c__1);
        }
        if (*ncc > 0) {
        dswap_(ncc, &c__[isub + c_dim1], ldc, &c__[i__ + c_dim1], ldc)
            ;
        }
    }
/* L40: */
}

return 0;

/*     DLASDQ 的结束 */

} /* dlasdq_ */

/* 子程序 dlasdt_ */

/* Subroutine */ int dlasdt_(integer *n, integer *lvl, integer *nd, integer *
    inode, integer *ndiml, integer *ndimr, integer *msub)
{
    /* 系统生成的本地变量 */
    integer i__1, i__2;

    /* 本地变量 */
    static integer i__, il, ir, maxn;
    static doublereal temp;
    static integer nlvl, llst, ncrnt;

/*
    -- LAPACK 辅助子程序（版本 3.2.2）--
    -- LAPACK 是由 Univ. of Tennessee, Univ. of California Berkeley,
       Univ. of Colorado Denver 和 NAG Ltd. 提供的软件包。--
       2010 年 6 月

    目的
    =======

    DLASDT 创建一个用于双对角分解的子问题树。

    参数
    =========

     N      (输入) INTEGER
            输入时，双对角矩阵的对角元素数目。

     LVL    (输出) INTEGER
            输出时，计算树中的层数。

     ND     (输出) INTEGER
            输出时，树中的节点数目。

     INODE  (输出) INTEGER 数组，维度为 ( N )
            输出时，子问题的中心点。

     NDIML  (输出) INTEGER 数组，维度为 ( N )
            输出时，左子节点的行维度。

     NDIMR  (输出) INTEGER 数组，维度为 ( N )
            输出时，右子节点的行维度。

     MSUB   (输入) INTEGER
            输入时，树底部每个子问题的最大行维度。

    更多细节
    ===============

    基于以下贡献
       Ming Gu 和 Huan Ren，加州大学伯克利分校计算机科学系，美国

*/
    =====================================================================
    # 这是一个分隔注释行，用于标记不同部分的代码或功能段落
    /* Parameter adjustments */
    --ndimr;
    --ndiml;
    --inode;

    /* Function Body */
    // 计算最大值，确保不低于1
    maxn = max(1,*n);
    // 计算树的层数
    temp = log((doublereal) maxn / (doublereal) (*msub + 1)) / log(2.);
    *lvl = (integer) temp + 1;

    // 初始化根节点
    i__ = *n / 2;
    inode[1] = i__ + 1;
    ndiml[1] = i__;
    ndimr[1] = *n - i__ - 1;
    il = 0;
    ir = 1;
    llst = 1;
    // 根据树的层数循环构建每一层的节点
    i__1 = *lvl - 1;
    for (nlvl = 1; nlvl <= i__1; ++nlvl) {

/*
          Constructing the tree at (NLVL+1)-st level. The number of
          nodes created on this level is LLST * 2.
*/
    // 在 NLVL+1 层构建树。该层创建的节点数为 LLST * 2
    i__2 = llst - 1;
    for (i__ = 0; i__ <= i__2; ++i__) {
        // 计算左右子节点的索引
        il += 2;
        ir += 2;
        // 当前节点的索引
        ncrnt = llst + i__;
        // 计算左子树的维度
        ndiml[il] = ndiml[ncrnt] / 2;
        // 计算右子树的维度
        ndimr[il] = ndiml[ncrnt] - ndiml[il] - 1;
        // 计算左子节点的索引
        inode[il] = inode[ncrnt] - ndimr[il] - 1;
        // 计算左子树的维度
        ndiml[ir] = ndimr[ncrnt] / 2;
        // 计算右子树的维度
        ndimr[ir] = ndimr[ncrnt] - ndiml[ir] - 1;
        // 计算右子节点的索引
        inode[ir] = inode[ncrnt] + ndiml[ir] + 1;
/* L10: */
    }
    // 更新层级数
    llst <<= 1;
/* L20: */
    }
    // 计算总节点数
    *nd = (llst << 1) - 1;

    return 0;

/*     End of DLASDT */

} /* dlasdt_ */

/* Subroutine */ int dlaset_(char *uplo, integer *m, integer *n, doublereal *
    alpha, doublereal *beta, doublereal *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j;
    extern logical lsame_(char *, char *);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASET initializes an m-by-n matrix A to BETA on the diagonal and
    ALPHA on the offdiagonals.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set; the strictly lower
                        triangular part of A is not changed.
            = 'L':      Lower triangular part is set; the strictly upper
                        triangular part of A is not changed.
            Otherwise:  All of the matrix A is set.

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    ALPHA   (input) DOUBLE PRECISION
            The constant to which the offdiagonal elements are to be set.

    BETA    (input) DOUBLE PRECISION
            The constant to which the diagonal elements are to be set.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On exit, the leading m-by-n submatrix of A is set as follows:

            if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
            if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
            otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,

            and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
/* Parameter adjustments */
a_dim1 = *lda;
a_offset = 1 + a_dim1;
a -= a_offset;

/* Function Body */
if (lsame_(uplo, "U")) {

    /*
      Set the strictly upper triangular or trapezoidal part of the
      array to ALPHA.
    */

    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
        /* Computing MIN */
        i__3 = j - 1;
        i__2 = min(i__3,*m);
        for (i__ = 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = *alpha;
            /* L10: */
        }
        /* L20: */
    }

} else if (lsame_(uplo, "L")) {

    /*
      Set the strictly lower triangular or trapezoidal part of the
      array to ALPHA.
    */

    i__1 = min(*m,*n);
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = *alpha;
            /* L30: */
        }
        /* L40: */
    }

} else {

    /*
      Set the leading m-by-n submatrix to ALPHA.
    */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
        i__2 = *m;
        for (i__ = 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = *alpha;
            /* L50: */
        }
        /* L60: */
    }
}

/* Set the first min(M,N) diagonal elements to BETA. */

i__1 = min(*m,*n);
for (i__ = 1; i__ <= i__1; ++i__) {
    a[i__ + i__ * a_dim1] = *beta;
    /* L70: */
}

return 0;

/* End of DLASET */

} /* dlaset_ */

/* Subroutine */ int dlasq1_(integer *n, doublereal *d__, doublereal *e,
    doublereal *work, integer *info)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    static integer i__;
    static doublereal eps;
    extern /* Subroutine */ int dlas2_(doublereal *, doublereal *, doublereal
        *, doublereal *, doublereal *);
    static doublereal scale;
    static integer iinfo;
    static doublereal sigmn;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static doublereal sigmx;
    extern /* Subroutine */ int dlasq2_(integer *, doublereal *, integer *);

    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *);
    static doublereal safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *), dlasrt_(
        char *, integer *, doublereal *, integer *);

/*
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*/

Purpose
=======
DLASQ1 computes the singular values of a real N-by-N bidiagonal
    # Compute the singular value decomposition (SVD) of a bidiagonal matrix
    # with diagonal D and off-diagonal E. The singular values
    # are computed to high relative accuracy, in the absence of
    # denormalization, underflow and overflow. The algorithm was first
    # presented in
    
    # "Accurate singular values and differential qd algorithms" by K. V.
    # Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
    # 1994,
    
    # and the present implementation is described in "An implementation of
    # the dqds Algorithm (Positive Case)", LAPACK Working Note.
    
    def dlasd0(N, D, E, WORK, INFO):
        # N     (input) INTEGER
        #       The number of rows and columns in the matrix. N >= 0.
    
        # D     (input/output) DOUBLE PRECISION array, dimension (N)
        #       On entry, D contains the diagonal elements of the
        #       bidiagonal matrix whose SVD is desired. On normal exit,
        #       D contains the singular values in decreasing order.
    
        # E     (input/output) DOUBLE PRECISION array, dimension (N)
        #       On entry, elements E(1:N-1) contain the off-diagonal elements
        #       of the bidiagonal matrix whose SVD is desired.
        #       On exit, E is overwritten.
    
        # WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
    
        # INFO  (output) INTEGER
        #       = 0: successful exit
        #       < 0: if INFO = -i, the i-th argument had an illegal value
        #       > 0: the algorithm failed
        #            = 1, a split was marked by a positive value in E
        #            = 2, current block of Z not diagonalized after 30*N
        #                 iterations (in inner while loop)
        #            = 3, termination criterion of outer while loop not met
        #                 (program created more than N unreduced blocks)
    
        # =====================================================================
        
        # Implementation of the dlasd0 algorithm for computing the SVD of a
        # bidiagonal matrix. Refer to LAPACK documentation for details.
    
        # Implementation details are omitted here for brevity and clarity.
        pass
    /* Parameter adjustments */
    --work;  // 调整工作数组的指针，这里将其递减，指向工作数组的起始位置
    --e;     // 调整e数组的指针，同样递减，指向e数组的起始位置
    --d__;   // 调整d__数组的指针，递减，指向d__数组的起始位置

    /* Function Body */
    *info = 0;  // 将info指针所指的值设为0
    if (*n < 0) {   // 如果n小于0
    *info = -2;     // 将info指针所指的值设为-2
    i__1 = -(*info);    // 计算info的绝对值
    xerbla_("DLASQ1", &i__1);    // 调用xerbla_函数处理错误
    return 0;   // 返回0
    } else if (*n == 0) {   // 如果n等于0
    return 0;   // 直接返回0
    } else if (*n == 1) {   // 如果n等于1
    d__[1] = abs(d__[1]);   // 计算d__[1]的绝对值，并赋值给d__[1]
    return 0;   // 返回0
    } else if (*n == 2) {   // 如果n等于2
    dlas2_(&d__[1], &e[1], &d__[2], &sigmn, &sigmx);   // 调用dlas2_函数处理特殊情况
    d__[1] = sigmx;     // 将sigmx的值赋给d__[1]
    d__[2] = sigmn;     // 将sigmn的值赋给d__[2]
    return 0;   // 返回0
    }

/*     Estimate the largest singular value. */

    sigmx = 0.;     // 初始化sigmx为0
    i__1 = *n - 1;   // 计算*n - 1
    for (i__ = 1; i__ <= i__1; ++i__) {     // 循环遍历从1到*n-1
    d__[i__] = (d__1 = d__[i__], abs(d__1));    // 计算d__[i__]的绝对值并赋值给d__[i__]
/* Computing MAX */
    d__2 = sigmx, d__3 = (d__1 = e[i__], abs(d__1));    // 计算e[i__]的绝对值
    sigmx = max(d__2,d__3);     // 计算sigmx和max(d__2, d__3)的最大值并赋给sigmx
/* L10: */
    }
    d__[*n] = (d__1 = d__[*n], abs(d__1));   // 计算d__[*n]的绝对值并赋值给d__[*n]

/*     Early return if SIGMX is zero (matrix is already diagonal). */

    if (sigmx == 0.) {  // 如果sigmx等于0
    dlasrt_("D", n, &d__[1], &iinfo);     // 调用dlasrt_函数对d__数组进行排序
    return 0;   // 返回0
    }

    i__1 = *n;  // 设置循环次数为*n
    for (i__ = 1; i__ <= i__1; ++i__) {     // 循环遍历从1到*n
/* Computing MAX */
    d__1 = sigmx, d__2 = d__[i__];   // 计算sigmx和d__[i__]的最大值
    sigmx = max(d__1,d__2);     // 将计算结果赋给sigmx
/* L20: */
    }

/*
       Copy D and E into WORK (in the Z format) and scale (squaring the
       input data makes scaling by a power of the radix pointless).
*/

    eps = PRECISION;    // 将PRECISION赋值给eps
    safmin = SAFEMINIMUM;   // 将SAFEMINIMUM赋值给safmin
    scale = sqrt(eps / safmin);     // 计算scale的值
    dcopy_(n, &d__[1], &c__1, &work[1], &c__2);   // 调用dcopy_函数复制d__数组到work数组
    i__1 = *n - 1;   // 设置循环次数为*n - 1
    dcopy_(&i__1, &e[1], &c__1, &work[2], &c__2);     // 调用dcopy_函数复制e数组到work数组的第二个元素开始的位置
    i__1 = (*n << 1) - 1;   // 设置i__1为(*n << 1) - 1
    i__2 = (*n << 1) - 1;   // 设置i__2为(*n << 1) - 1
    dlascl_("G", &c__0, &c__0, &sigmx, &scale, &i__1, &c__1, &work[1], &i__2,
        &iinfo);    // 调用dlascl_函数对work数组进行缩放

/*     Compute the q's and e's. */

    i__1 = (*n << 1) - 1;   // 设置循环次数为(*n << 1) - 1
    for (i__ = 1; i__ <= i__1; ++i__) {     // 循环遍历从1到(*n << 1) - 1
/* Computing 2nd power */
    d__1 = work[i__];    // 计算work[i__]的平方
    work[i__] = d__1 * d__1;    // 将计算结果赋给work[i__]
/* L30: */
    }
    work[*n * 2] = 0.;    // 将work[*n * 2]的值设为0

    dlasq2_(n, &work[1], info);     // 调用dlasq2_函数处理剩余的工作

    if (*info == 0) {   // 如果info指针所指的值等于0
    i__1 = *n;  // 设置循环次数为*n
    for (i__ = 1; i__ <= i__1; ++i__) {     // 循环遍历从1到*n
        d__[i__] = sqrt(work[i__]);     // 计算work[i__]的平方根并赋值给d__[i__]
/* L40: */
    }
    dlascl_("G", &c__0, &c__0, &scale, &sigmx, n, &c__1, &d__[1], n, &
        iinfo);    // 调用dlascl_函数对d__数组进行缩放
    }

    return 0;

/*     End of DLASQ1 */

} /* dlasq1_ */
    ! 声明外部子程序 dlasq3_，用于实现某些特定的数值计算功能
    extern /* Subroutine */ int dlasq3_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         integer *, integer *, integer *, logical *, integer *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);

    ! 声明静态变量 deemin，用于存储最小值
    static doublereal deemin;
    ! 声明静态变量 iwhila 和 iwhilb，用于迭代过程中的计数
    static integer iwhila, iwhilb;
    ! 声明静态变量 oldemn，用于存储旧的最小值
    static doublereal oldemn;
    ! 声明静态变量 safmin，用于存储安全最小值
    static doublereal safmin;

    ! 声明外部子程序 xerbla_，用于处理错误信息
    extern /* Subroutine */ int xerbla_(char *, integer *);

    ! 声明外部函数 ilaenv_，用于查询环境参数
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);

    ! 声明外部子程序 dlasrt_，用于排序数组
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *,
        integer *);
"""
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

    Purpose
    =======
    
    DLASQ2 computes all the eigenvalues of the symmetric positive
    definite tridiagonal matrix associated with the qd array Z to high
    relative accuracy are computed to high relative accuracy, in the
    absence of denormalization, underflow and overflow.

    To see the relation of Z to the tridiagonal matrix, let L be a
    unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
    let U be an upper bidiagonal matrix with 1's above and diagonal
    Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
    symmetric tridiagonal to which it is similar.

    Note : DLASQ2 defines a logical variable, IEEE, which is true
    on machines which follow ieee-754 floating-point standard in their
    handling of infinities and NaNs, and false otherwise. This variable
    is passed to DLASQ3.

    Arguments
    =========

    N     (input) INTEGER
          The number of rows and columns in the matrix. N >= 0.

    Z     (input/output) DOUBLE PRECISION array, dimension ( 4*N )
          On entry Z holds the qd array. On exit, entries 1 to N hold
          the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
          trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
          N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
          holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
          shifts that failed.

    INFO  (output) INTEGER
          = 0: successful exit
          < 0: if the i-th argument is a scalar and had an illegal
               value, then INFO = -i, if the i-th argument is an
               array and the j-entry had an illegal value, then
               INFO = -(i*100+j)
          > 0: the algorithm failed
                = 1, a split was marked by a positive value in E
                = 2, current block of Z not diagonalized after 30*N
                     iterations (in inner while loop)
                = 3, termination criterion of outer while loop not met
                     (program created more than N unreduced blocks)

    Further Details
    ===============
    Local Variables: I0:N0 defines a current unreduced segment of Z.
    The shifts are accumulated in SIGMA. Iteration count is in ITER.
    Ping-pong is controlled by PP (alternates between 0 and 1).

    =====================================================================


       Test the input arguments.
       (in case DLASQ2 is not called by DLASQ1)
"""
    /* Parameter adjustments */
    --z__;

    /* Function Body */
    // 初始化 info 为 0
    *info = 0;
    // 设置 eps 为预定义精度值
    eps = PRECISION;
    // 设置 safmin 为预定义的最小安全值
    safmin = SAFEMINIMUM;
    // 设置 tol 为 eps 的 100 倍，用于容差计算
    tol = eps * 100.;
/* Computing 2nd power */
    d__1 = tol;  // Assign tol to d__1
    tol2 = d__1 * d__1;  // Compute tol squared and assign to tol2

    if (*n < 0) {  // Check if n is negative
    *info = -1;  // Set error code to indicate invalid n
    xerbla_("DLASQ2", &c__1);  // Call error handler
    return 0;  // Return with error
    } else if (*n == 0) {  // Check if n is zero
    return 0;  // Return without performing further computation
    } else if (*n == 1) {  // Check if n is one

/*        1-by-1 case. */

    if (z__[1] < 0.) {  // Check if the single element z[1] is negative
        *info = -201;  // Set error code to indicate negative z[1]
        xerbla_("DLASQ2", &c__2);  // Call error handler
    }
    return 0;  // Return
    } else if (*n == 2) {  // Check if n is two

/*        2-by-2 case. */

    if (z__[2] < 0. || z__[3] < 0.) {  // Check if any of the elements z[2] or z[3] are negative
        *info = -2;  // Set error code to indicate negative z[2] or z[3]
        xerbla_("DLASQ2", &c__2);  // Call error handler
        return 0;  // Return with error
    } else if (z__[3] > z__[1]) {  // Check if z[3] is greater than z[1]
        d__ = z__[3];  // Exchange z[1] and z[3]
        z__[3] = z__[1];
        z__[1] = d__;
    }
    z__[5] = z__[1] + z__[2] + z__[3];  // Compute sum of z[1], z[2], and z[3] and store in z[5]
    if (z__[2] > z__[3] * tol2) {  // Check if z[2] is significantly larger than z[3]
        t = (z__[1] - z__[3] + z__[2]) * .5;  // Compute t
        s = z__[3] * (z__[2] / t);  // Compute s
        if (s <= t) {  // Condition check
        s = z__[3] * (z__[2] / (t * (sqrt(s / t + 1.) + 1.)));  // Adjust s
        } else {
        s = z__[3] * (z__[2] / (t + sqrt(t) * sqrt(t + s)));  // Adjust s
        }
        t = z__[1] + (s + z__[2]);  // Update t
        z__[3] *= z__[1] / t;  // Adjust z[3]
        z__[1] = t;  // Update z[1]
    }
    z__[2] = z__[3];  // Update z[2]
    z__[6] = z__[2] + z__[1];  // Compute sum of z[2] and z[1] and store in z[6]
    return 0;  // Return
    }

/*     Check for negative data and compute sums of q's and e's. */

    z__[*n * 2] = 0.;  // Initialize z[n*2] to zero
    emin = z__[2];  // Initialize emin with z[2]
    qmax = 0.;  // Initialize qmax to zero
    zmax = 0.;  // Initialize zmax to zero
    d__ = 0.;  // Initialize d to zero
    e = 0.;  // Initialize e to zero

    i__1 = *n - 1 << 1;  // Compute limit for loop
    for (k = 1; k <= i__1; k += 2) {  // Loop over elements of z
    if (z__[k] < 0.) {  // Check if z[k] is negative
        *info = -(k + 200);  // Set error code to indicate negative z[k]
        xerbla_("DLASQ2", &c__2);  // Call error handler
        return 0;  // Return with error
    } else if (z__[k + 1] < 0.) {  // Check if z[k+1] is negative
        *info = -(k + 201);  // Set error code to indicate negative z[k+1]
        xerbla_("DLASQ2", &c__2);  // Call error handler
        return 0;  // Return with error
    }
    d__ += z__[k];  // Accumulate sum of q's
    e += z__[k + 1];  // Accumulate sum of e's
/* Computing MAX */
    d__1 = qmax, d__2 = z__[k];  // Compute maximum of qmax and z[k]
    qmax = max(d__1,d__2);  // Update qmax
/* Computing MIN */
    d__1 = emin, d__2 = z__[k + 1];  // Compute minimum of emin and z[k+1]
    emin = min(d__1,d__2);  // Update emin
/* Computing MAX */
    d__1 = max(qmax,zmax), d__2 = z__[k + 1];  // Compute maximum of qmax, zmax, and z[k+1]
    zmax = max(d__1,d__2);  // Update zmax
/* L10: */
    }
    if (z__[(*n << 1) - 1] < 0.) {  // Check if z[2n-1] is negative
    *info = -((*n << 1) + 199);  // Set error code to indicate negative z[2n-1]
    xerbla_("DLASQ2", &c__2);  // Call error handler
    return 0;  // Return with error
    }
    d__ += z__[(*n << 1) - 1];  // Accumulate sum of q's
/* Computing MAX */
    d__1 = qmax, d__2 = z__[(*n << 1) - 1];  // Compute maximum of qmax and z[2n-1]
    qmax = max(d__1,d__2);  // Update qmax
    zmax = max(qmax,zmax);  // Update zmax

/*     Check for diagonality. */

    if (e == 0.) {  // Check if e is zero
    i__1 = *n;  // Set loop limit
    for (k = 2; k <= i__1; ++k) {  // Loop over elements of z
        z__[k] = z__[(k << 1) - 1];  // Move elements to maintain diagonal structure
/* L20: */
    }
    dlasrt_("D", n, &z__[1], &iinfo);  // Sort elements
    z__[(*n << 1) - 1] = d__;  // Update z[2n-1]
    return 0;  // Return
    }

    trace = d__ + e;  // Compute trace of matrix

/*     Check for zero data. */

    if (trace == 0.) {  // Check if trace is zero
    z__[(*n << 1) - 1] = 0.;  // Set z[2n-1] to zero
    return 0;  // Return
    }

/*     Check whether the machine is IEEE conformable. */

    ieee = ilaenv_(&c__10, "DLASQ2", "N", &c__1, &c__2, &c__3, &c__4, (ftnlen)
        6, (ftnlen)1) == 1 && ilaenv_(&c__11, "DLASQ2", "N", &c__1, &c__2,
         &c__3, &c__4, (ftnlen)6, (ftnlen)1) == 1;  // Check IEEE conformity

/*     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...). */

    for (k = *n << 1; k >= 2; k += -2) {  // Loop over elements of z in reverse order
    z__[k * 2] = 0.;  // Initialize elements for rearrangement
    z__[(k << 1) - 1] = z__[k];  // Rearrange elements
    z__[(k << 1) - 2] = 0.;  // Initialize elements for rearrangement
    z__[(k << 1) - 3] = z__[k - 1];
/* L30: */
    }

    i0 = 1;  // 设置起始索引 i0 为 1
    n0 = *n;  // 从指针 n 中读取数组长度，并赋值给 n0

/*     Reverse the qd-array, if warranted. */

    // 如果第一个元素小于最后一个元素的1.5倍，则反转数组 z__ 中的元素顺序
    if (z__[(i0 << 2) - 3] * 1.5 < z__[(n0 << 2) - 3]) {
    ipn4 = i0 + n0 << 2;
    i__1 = i0 + n0 - 1 << 1;
    for (i4 = i0 << 2; i4 <= i__1; i4 += 4) {
        temp = z__[i4 - 3];
        z__[i4 - 3] = z__[ipn4 - i4 - 3];
        z__[ipn4 - i4 - 3] = temp;
        temp = z__[i4 - 1];
        z__[i4 - 1] = z__[ipn4 - i4 - 5];
        z__[ipn4 - i4 - 5] = temp;
/* L40: */
    }
    }

/*     Initial split checking via dqd and Li's test. */

    pp = 0;  // 设置变量 pp 为 0

    for (k = 1; k <= 2; ++k) {

    d__ = z__[(n0 << 2) + pp - 3];  // 读取 z__ 中的值赋给 d__
    i__1 = (i0 << 2) + pp;
    for (i4 = (n0 - 1 << 2) + pp; i4 >= i__1; i4 += -4) {
        if (z__[i4 - 1] <= tol2 * d__) {  // 如果 z__[i4 - 1] 小于等于 tol2 乘以 d__
        z__[i4 - 1] = -0.;  // 将 z__[i4 - 1] 设为 -0.
        d__ = z__[i4 - 3];  // 将 z__[i4 - 3] 赋值给 d__
        } else {
        d__ = z__[i4 - 3] * (d__ / (d__ + z__[i4 - 1]));  // 更新 d__
        }
/* L50: */
    }

/*        dqd maps Z to ZZ plus Li's test. */

    emin = z__[(i0 << 2) + pp + 1];  // 读取 z__ 中的值赋给 emin
    d__ = z__[(i0 << 2) + pp - 3];  // 读取 z__ 中的值赋给 d__
    i__1 = (n0 - 1 << 2) + pp;
    for (i4 = (i0 << 2) + pp; i4 <= i__1; i4 += 4) {
        z__[i4 - (pp << 1) - 2] = d__ + z__[i4 - 1];  // 更新 z__[i4 - (pp << 1) - 2]
        if (z__[i4 - 1] <= tol2 * d__) {
        z__[i4 - 1] = -0.;  // 将 z__[i4 - 1] 设为 -0.
        z__[i4 - (pp << 1) - 2] = d__;  // 将 d__ 赋值给 z__[i4 - (pp << 1) - 2]
        z__[i4 - (pp << 1)] = 0.;  // 将 z__[i4 - (pp << 1)] 设为 0.
        d__ = z__[i4 + 1];  // 更新 d__
        } else if (safmin * z__[i4 + 1] < z__[i4 - (pp << 1) - 2] &&
            safmin * z__[i4 - (pp << 1) - 2] < z__[i4 + 1]) {
        temp = z__[i4 + 1] / z__[i4 - (pp << 1) - 2];  // 计算 temp
        z__[i4 - (pp << 1)] = z__[i4 - 1] * temp;  // 更新 z__[i4 - (pp << 1)]
        d__ *= temp;  // 更新 d__
        } else {
        z__[i4 - (pp << 1)] = z__[i4 + 1] * (z__[i4 - 1] / z__[i4 - (
            pp << 1) - 2]);  // 更新 z__[i4 - (pp << 1)]
        d__ = z__[i4 + 1] * (d__ / z__[i4 - (pp << 1) - 2]);  // 更新 d__
        }
/* Computing MIN */
        d__1 = emin, d__2 = z__[i4 - (pp << 1)];
        emin = min(d__1,d__2);  // 更新 emin
/* L60: */
    }
    z__[(n0 << 2) - pp - 2] = d__;  // 更新 z__

/*        Now find qmax. */

    qmax = z__[(i0 << 2) - pp - 2];  // 读取 z__ 中的值赋给 qmax
    i__1 = (n0 << 2) - pp - 2;
    for (i4 = (i0 << 2) - pp + 2; i4 <= i__1; i4 += 4) {
/* Computing MAX */
        d__1 = qmax, d__2 = z__[i4];
        qmax = max(d__1,d__2);  // 更新 qmax
/* L70: */
    }

/*        Prepare for the next iteration on K. */

    pp = 1 - pp;  // 更新 pp
/* L80: */
    }

/*     Initialise variables to pass to DLASQ3. */

    ttype = 0;  // 将 ttype 设为 0
    dmin1 = 0.;  // 将 dmin1 设为 0
    dmin2 = 0.;  // 将 dmin2 设为 0
    dn = 0.;  // 将 dn 设为 0
    dn1 = 0.;  // 将 dn1 设为 0
    dn2 = 0.;  // 将 dn2 设为 0
    g = 0.;  // 将 g 设为 0
    tau = 0.;  // 将 tau 设为 0

    iter = 2;  // 将 iter 设为 2
    nfail = 0;  // 将 nfail 设为 0
    ndiv = n0 - i0 << 1;  // 计算 ndiv

    i__1 = *n + 1;  // 计算循环次数
    for (iwhila = 1; iwhila <= i__1; ++iwhila) {
    if (n0 < 1) {
        goto L170;  // 如果 n0 小于 1，跳转到 L170
    }

/*
          While array unfinished do

          E(N0) holds the value of SIGMA when submatrix in I0:N0
          splits from the rest of the array, but is negated.
*/

    desig = 0.;  // 将 desig 设为 0
    if (n0 == *n) {
        sigma = 0.;  // 如果 n0 等于 *n，将 sigma 设为 0
    } else {
        sigma = -z__[(n0 << 2) - 1];  // 否则，从 z__ 中读取值给 sigma，并取反
    }
    if (sigma < 0.) {
        *info = 1;  // 如果 sigma 小于 0，将 *info 设为 1
        return 0;  // 返回 0
    }
/*
          Find last unreduced submatrix's top index I0, find QMAX and
          EMIN. Find Gershgorin-type bound if Q's much greater than E's.
*/

    emax = 0.;  // 初始化 emax 为 0
    if (n0 > i0) {  // 如果 n0 大于 i0
        emin = (d__1 = z__[(n0 << 2) - 5], abs(d__1));  // 计算 emin 作为 z__[(n0 << 2) - 5] 的绝对值
    } else {
        emin = 0.;  // 否则 emin 为 0
    }
    qmin = z__[(n0 << 2) - 3];  // 初始化 qmin 为 z__[(n0 << 2) - 3]
    qmax = qmin;  // 初始化 qmax 为 qmin
    for (i4 = n0 << 2; i4 >= 8; i4 += -4) {  // 从 n0 << 2 开始到 8，每次减 4 的循环
        if (z__[i4 - 5] <= 0.) {  // 如果 z__[i4 - 5] 小于等于 0
            goto L100;  // 跳转到标签 L100
        }
        if (qmin >= emax * 4.) {  // 如果 qmin 大于等于 emax 的四倍
/* Computing MIN */
        d__1 = qmin, d__2 = z__[i4 - 3];  // 计算 qmin 的最小值
        qmin = min(d__1,d__2);  // 更新 qmin
/* Computing MAX */
        d__1 = emax, d__2 = z__[i4 - 5];  // 计算 emax 的最大值
        emax = max(d__1,d__2);  // 更新 emax
        }
/* Computing MAX */
        d__1 = qmax, d__2 = z__[i4 - 7] + z__[i4 - 5];  // 计算 qmax 的最大值
        qmax = max(d__1,d__2);  // 更新 qmax
/* Computing MIN */
        d__1 = emin, d__2 = z__[i4 - 5];  // 计算 emin 的最小值
        emin = min(d__1,d__2);  // 更新 emin
/* L90: */
    }
    i4 = 4;  // 设置 i4 为 4

L100:
    i0 = i4 / 4;  // 计算 i0 为 i4 除以 4 的商
    pp = 0;  // 初始化 pp 为 0

    if (n0 - i0 > 1) {  // 如果 n0 - i0 大于 1
        dee = z__[(i0 << 2) - 3];  // 设置 dee 为 z__[(i0 << 2) - 3]
        deemin = dee;  // 设置 deemin 为 dee
        kmin = i0;  // 设置 kmin 为 i0
        i__2 = (n0 << 2) - 3;
        for (i4 = (i0 << 2) + 1; i4 <= i__2; i4 += 4) {  // 从 (i0 << 2) + 1 到 (n0 << 2) - 3，每次加 4 的循环
        dee = z__[i4] * (dee / (dee + z__[i4 - 2]));  // 更新 dee
        if (dee <= deemin) {  // 如果 dee 小于等于 deemin
            deemin = dee;  // 更新 deemin
            kmin = (i4 + 3) / 4;  // 更新 kmin
        }
/* L110: */
        }
        if (kmin - i0 << 1 < n0 - kmin && deemin <= z__[(n0 << 2) - 3] *
            .5) {
        ipn4 = i0 + n0 << 2;  // 设置 ipn4 为 (i0 + n0) << 2
        pp = 2;  // 设置 pp 为 2
        i__2 = i0 + n0 - 1 << 1;
        for (i4 = i0 << 2; i4 <= i__2; i4 += 4) {  // 从 i0 << 2 到 i0 + n0 - 1 << 1，每次加 4 的循环
            temp = z__[i4 - 3];  // 交换 z__ 数组中的元素
            z__[i4 - 3] = z__[ipn4 - i4 - 3];
            z__[ipn4 - i4 - 3] = temp;
            temp = z__[i4 - 2];  // 交换 z__ 数组中的元素
            z__[i4 - 2] = z__[ipn4 - i4 - 2];
            z__[ipn4 - i4 - 2] = temp;
            temp = z__[i4 - 1];  // 交换 z__ 数组中的元素
            z__[i4 - 1] = z__[ipn4 - i4 - 5];
            z__[ipn4 - i4 - 5] = temp;
            temp = z__[i4];  // 交换 z__ 数组中的元素
            z__[i4] = z__[ipn4 - i4 - 4];
            z__[ipn4 - i4 - 4] = temp;
/* L120: */
        }
        }
    }

/*
          Put -(initial shift) into DMIN.

   Computing MAX
*/
    d__1 = 0., d__2 = qmin - sqrt(qmin) * 2. * sqrt(emax);  // 计算 dmin__ 的最大值
    dmin__ = -max(d__1,d__2);  // 设置 dmin__ 为计算结果的负值

/*
          Now I0:N0 is unreduced.
          PP = 0 for ping, PP = 1 for pong.
          PP = 2 indicates that flipping was applied to the Z array and
                 and that the tests for deflation upon entry in DLASQ3
                 should not be performed.
*/

    nbig = (n0 - i0 + 1) * 30;  // 设置 nbig
    i__2 = nbig;  // 设置循环上限
    for (iwhilb = 1; iwhilb <= i__2; ++iwhilb) {  // 循环，每次递增 iwhilb
        if (i0 > n0) {  // 如果 i0 大于 n0
        goto L150;  // 跳转到标签 L150
        }

/*           While submatrix unfinished take a good dqds step. */

        dlasq3_(&i0, &n0, &z__[1], &pp, &dmin__, &sigma, &desig, &qmax, &
            nfail, &iter, &ndiv, &ieee, &ttype, &dmin1, &dmin2, &dn, &
            dn1, &dn2, &g, &tau);  // 调用 dlasq3_ 函数

        pp = 1 - pp;  // 更新 pp




注释：
/*           When EMIN is very small check for splits. */
/* 当 EMIN 非常小时，检查是否需要进行分裂 */

if (pp == 0 && n0 - i0 >= 3) {
/* 如果 pp 等于 0 并且 n0 - i0 大于等于 3，则执行以下操作 */

if (z__[n0 * 4] <= tol2 * qmax || z__[(n0 << 2) - 1] <= tol2 * sigma) {
/* 如果 z__[n0 * 4] 小于等于 tol2 * qmax 或者 z__[(n0 << 2) - 1] 小于等于 tol2 * sigma，则执行以下操作 */

splt = i0 - 1;
/* 将 splt 设置为 i0 - 1 */

qmax = z__[(i0 << 2) - 3];
/* 更新 qmax 为 z__[(i0 << 2) - 3] */

emin = z__[(i0 << 2) - 1];
/* 更新 emin 为 z__[(i0 << 2) - 1] */

oldemn = z__[i0 * 4];
/* 更新 oldemn 为 z__[i0 * 4] */

i__3 = n0 - 3 << 2;
/* 计算循环次数上限 */
for (i4 = i0 << 2; i4 <= i__3; i4 += 4) {
/* 开始循环，从 i0 * 4 到 (n0 - 3) * 4，步长为 4 */

if (z__[i4] <= tol2 * z__[i4 - 3] || z__[i4 - 1] <= tol2 * sigma) {
/* 如果 z__[i4] 小于等于 tol2 * z__[i4 - 3] 或者 z__[i4 - 1] 小于等于 tol2 * sigma，则执行以下操作 */

z__[i4 - 1] = -sigma;
/* 将 z__[i4 - 1] 设置为 -sigma */

splt = i4 / 4;
/* 更新 splt 为 i4 / 4 */

qmax = 0.;
/* 将 qmax 设置为 0.0 */

emin = z__[i4 + 3];
/* 更新 emin 为 z__[i4 + 3] */

oldemn = z__[i4 + 4];
/* 更新 oldemn 为 z__[i4 + 4] */

} else {
/* 如果条件不满足，则执行以下操作 */

/* Computing MAX */
d__1 = qmax, d__2 = z__[i4 + 1];
/* 计算 qmax 和 z__[i4 + 1] 的最大值 */
qmax = max(d__1,d__2);

/* Computing MIN */
d__1 = emin, d__2 = z__[i4 - 1];
/* 计算 emin 和 z__[i4 - 1] 的最小值 */
emin = min(d__1,d__2);

/* Computing MIN */
d__1 = oldemn, d__2 = z__[i4];
/* 计算 oldemn 和 z__[i4] 的最小值 */
oldemn = min(d__1,d__2);
}

/* L130: */
/* 循环的标签 */
}

z__[(n0 << 2) - 1] = emin;
/* 更新 z__[(n0 << 2) - 1] 为 emin */

z__[n0 * 4] = oldemn;
/* 更新 z__[n0 * 4] 为 oldemn */

i0 = splt + 1;
/* 更新 i0 为 splt + 1 */
}

/* L140: */
/* 无条件跳转到 L140 标签处 */

}

*info = 2;
/* 将 info 设置为 2 */
return 0;

/*        end IWHILB */
/* 结束 IWHILB 部分 */

L150:
/* L150 标签处 */

/* L160: */
/* 无条件跳转到 L160 标签处 */
;
/* 空语句 */

}

*info = 3;
/* 将 info 设置为 3 */
return 0;

/*     end IWHILA */
/* 结束 IWHILA 部分 */

L170:
/* L170 标签处 */

/*     Move q's to the front. */
/*     将 q 移到前面 */

i__1 = *n;
/* 设置循环上限为 *n */
for (k = 2; k <= i__1; ++k) {
/* 循环从 k = 2 到 k = *n，步长为 1 */

z__[k] = z__[(k << 2) - 3];
/* 将 z__[k] 设置为 z__[(k << 2) - 3] */

/* L180: */
/* 循环的标签 */
}

/*     Sort and compute sum of eigenvalues. */
/*     对特征值进行排序并计算其和 */

dlasrt_("D", n, &z__[1], &iinfo);
/* 调用 dlasrt_ 函数对 z__[1] 到 z__[*n] 进行排序 */

e = 0.;
/* 将 e 设置为 0.0 */
for (k = *n; k >= 1; --k) {
/* 循环从 k = *n 到 k = 1，步长为 -1 */

e += z__[k];
/* 累加 z__[k] 到 e */

/* L190: */
/* 循环的标签 */
}

/*     Store trace, sum(eigenvalues) and information on performance. */
/*     存储迹、特征值之和以及性能信息 */

z__[(*n << 1) + 1] = trace;
/* 将 trace 存储到 z__[(*n << 1) + 1] */

z__[(*n << 1) + 2] = e;
/* 将 e 存储到 z__[(*n << 1) + 2] */

z__[(*n << 1) + 3] = (doublereal) iter;
/* 将 iter 转换为 doublereal 类型后存储到 z__[(*n << 1) + 3] */

/* Computing 2nd power */
i__1 = *n;
/* 计算 *n 的平方 */
z__[(*n << 1) + 4] = (doublereal) ndiv / (doublereal) (i__1 * i__1);
/* 将 ndiv / (*n)^2 存储到 z__[(*n << 1) + 4] */

z__[(*n << 1) + 5] = nfail * 100. / (doublereal) iter;
/* 将 nfail * 100. / iter 存储到 z__[(*n << 1) + 5] */

return 0;

/*     End of DLASQ2 */
/*     DLASQ2 结束 */

} /* dlasq2_ */
/* dlasq2_ 子程序结束 */

/* Subroutine */ int dlasq3_(integer *i0, integer *n0, doublereal *z__,
    integer *pp, doublereal *dmin__, doublereal *sigma, doublereal *desig,
     doublereal *qmax, integer *nfail, integer *iter, integer *ndiv,
    logical *ieee, integer *ttype, doublereal *dmin1, doublereal *dmin2,
    doublereal *dn, doublereal *dn1, doublereal *dn2, doublereal *g,
    doublereal *tau)
{
/* 子程序 dlasq3_ 的定义 */

/* System generated locals */
/* 系统生成的局部变量 */

integer i__1;
doublereal d__1, d__2;
/* 定义系统生成的局部变量 */

/* Local variables */
/* 本地变量 */

static doublereal s, t;
/* 静态变量 s 和 t */

static integer j4, nn;
/* 静态变量 j4 和 nn */

static doublereal eps, tol;
/* 静态变量 eps 和 tol */

static integer n0in, ipn4;
/* 静态变量 n0in 和 ipn4 */

static doublereal tol2, temp;
/* 静态变量 tol2 和 temp */
    # 声明调用外部的 Fortran 子程序 dlasq4_
    extern /* Subroutine */ int dlasq4_(integer *, integer *, doublereal *,
        integer *, integer *, doublereal *, doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *, integer *,
         doublereal *);

    # 声明调用外部的 Fortran 子程序 dlasq5_
    extern /* Subroutine */ int dlasq5_(integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, doublereal *, doublereal *,
         doublereal *, doublereal *, doublereal *, logical *);

    # 声明调用外部的 Fortran 子程序 dlasq6_
    extern /* Subroutine */ int dlasq6_(
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *);

    # 声明调用外部的函数 disnan_
    extern logical disnan_(doublereal *);
/*
    -- LAPACK routine (version 3.2.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- June 2010                                                       --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
    In case of failure it changes shifts, and tries again until output
    is positive.

    Arguments
    =========

    I0     (input) INTEGER
           First index.

    N0     (input/output) INTEGER
           Last index.

    Z      (input) DOUBLE PRECISION array, dimension ( 4*N )
           Z holds the qd array.

    PP     (input/output) INTEGER
           PP=0 for ping, PP=1 for pong.
           PP=2 indicates that flipping was applied to the Z array
           and that the initial tests for deflation should not be
           performed.

    DMIN   (output) DOUBLE PRECISION
           Minimum value of d.

    SIGMA  (output) DOUBLE PRECISION
           Sum of shifts used in current segment.

    DESIG  (input/output) DOUBLE PRECISION
           Lower order part of SIGMA

    QMAX   (input) DOUBLE PRECISION
           Maximum value of q.

    NFAIL  (output) INTEGER
           Number of times shift was too big.

    ITER   (output) INTEGER
           Number of iterations.

    NDIV   (output) INTEGER
           Number of divisions.

    IEEE   (input) LOGICAL
           Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).

    TTYPE  (input/output) INTEGER
           Shift type.

    DMIN1  (input/output) DOUBLE PRECISION

    DMIN2  (input/output) DOUBLE PRECISION

    DN     (input/output) DOUBLE PRECISION

    DN1    (input/output) DOUBLE PRECISION

    DN2    (input/output) DOUBLE PRECISION

    G      (input/output) DOUBLE PRECISION

    TAU    (input/output) DOUBLE PRECISION

           These are passed as arguments in order to save their values
           between calls to DLASQ3.

    =====================================================================
*/

/* Parameter adjustments */
--z__;

/* Function Body */
n0in = *n0;
eps = PRECISION;
tol = eps * 100.;
/* Computing 2nd power */
d__1 = tol;
tol2 = d__1 * d__1;

/*     Check for deflation. */

L10:

if (*n0 < *i0) {
return 0;
}
if (*n0 == *i0) {
goto L20;
}
nn = (*n0 << 2) + *pp;
if (*n0 == *i0 + 1) {
goto L40;
}

/*     Check whether E(N0-1) is negligible, 1 eigenvalue. */

if (z__[nn - 5] > tol2 * (*sigma + z__[nn - 3]) && z__[nn - (*pp << 1) -
    4] > tol2 * z__[nn - 7]) {
goto L30;
}

L20:

z__[(*n0 << 2) - 3] = z__[(*n0 << 2) + *pp - 3] + *sigma;
--(*n0);


注释：

/* Parameter adjustments */
--z__;  // 减少指针 z__，将其向前移动到数组 z 的起始位置

/* Function Body */
n0in = *n0;  // 保存 n0 的初始值
eps = PRECISION;  // 精度常量
tol = eps * 100.;  // 容差阈值
/* Computing 2nd power */
d__1 = tol;
tol2 = d__1 * d__1;  // tol 的平方，用于后续比较

/*     Check for deflation. */

L10:

if (*n0 < *i0) {  // 如果 n0 小于 i0，则返回
return 0;
}
if (*n0 == *i0) {  // 如果 n0 等于 i0，则跳转到 L20
goto L20;
}
nn = (*n0 << 2) + *pp;  // 计算索引 nn
if (*n0 == *i0 + 1) {  // 如果 n0 等于 i0+1，则跳转到 L40
goto L40;
}

/*     Check whether E(N0-1) is negligible, 1 eigenvalue. */

if (z__[nn - 5] > tol2 * (*sigma + z__[nn - 3]) && z__[nn - (*pp << 1) -
    4] > tol2 * z__[nn - 7]) {  // 检查是否 E(N0-1) 很小，即一个特征值
goto L30;
}

L20:

z__[(*n0 << 2) - 3] = z__[(*n0 << 2) + *pp - 3] + *sigma;  // 更新 z__
--(*n0);  // 减少 n0
    # 转到标签 L10 处继续执行
    goto L10;
/*     Check whether E(N0-2) is negligible, 2 eigenvalues. */

L30:
    /* 如果 E(N0-2) 是可忽略的，跳转到 L50 */
    if (z__[nn - 9] > tol2 * *sigma && z__[nn - (*pp << 1) - 8] > tol2 * z__[nn - 11]) {
        goto L50;
    }

L40:
    /* 如果 z__(nn - 3) 大于 z__(nn - 7)，交换它们的位置 */
    if (z__[nn - 3] > z__[nn - 7]) {
        s = z__[nn - 3];
        z__[nn - 3] = z__[nn - 7];
        z__[nn - 7] = s;
    }
    /* 如果 z__(nn - 5) 大于 z__(nn - 3) 的 tol2 倍 */
    if (z__[nn - 5] > z__[nn - 3] * tol2) {
        /* 进行特定计算，更新 z__(nn - 3) 和 z__(nn - 7) 的值 */
        t = (z__[nn - 7] - z__[nn - 3] + z__[nn - 5]) * .5;
        s = z__[nn - 3] * (z__[nn - 5] / t);
        if (s <= t) {
            s = z__[nn - 3] * (z__[nn - 5] / (t * (sqrt(s / t + 1.) + 1.)));
        } else {
            s = z__[nn - 3] * (z__[nn - 5] / (t + sqrt(t) * sqrt(t + s)));
        }
        t = z__[nn - 7] + (s + z__[nn - 5]);
        z__[nn - 3] *= z__[nn - 7] / t;
        z__[nn - 7] = t;
    }
    /* 更新 z__(*n0 << 2 - 7) 和 z__(*n0 << 2 - 3) 的值 */
    z__[(*n0 << 2) - 7] = z__[nn - 7] + *sigma;
    z__[(*n0 << 2) - 3] = z__[nn - 3] + *sigma;
    /* 更新 *n0 的值 */
    *n0 += -2;
    /* 跳转到 L10 */
    goto L10;

L50:
    /* 如果 *pp 等于 2，将 *pp 设为 0 */
    if (*pp == 2) {
        *pp = 0;
    }

/*     Reverse the qd-array, if warranted. */

    /* 如果 *dmin__ 小于等于 0 或者 *n0 小于 n0in，则执行数组反转操作 */
    if (*dmin__ <= 0. || *n0 < n0in) {
        /* 根据条件，反转特定范围内的数组 z__ */
        if (z__[(*i0 << 2) + *pp - 3] * 1.5 < z__[(*n0 << 2) + *pp - 3]) {
            ipn4 = *i0 + *n0 << 2;
            i__1 = *i0 + *n0 - 1 << 1;
            /* 循环内部进行交换操作 */
            for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
                temp = z__[j4 - 3];
                z__[j4 - 3] = z__[ipn4 - j4 - 3];
                z__[ipn4 - j4 - 3] = temp;
                temp = z__[j4 - 2];
                z__[j4 - 2] = z__[ipn4 - j4 - 2];
                z__[ipn4 - j4 - 2] = temp;
                temp = z__[j4 - 1];
                z__[j4 - 1] = z__[ipn4 - j4 - 5];
                z__[ipn4 - j4 - 5] = temp;
                temp = z__[j4];
                z__[j4] = z__[ipn4 - j4 - 4];
                z__[ipn4 - j4 - 4] = temp;
            }
            /* 如果 *n0 - *i0 <= 4，更新特定位置的值 */
            if (*n0 - *i0 <= 4) {
                z__[(*n0 << 2) + *pp - 1] = z__[(*i0 << 2) + *pp - 1];
                z__[(*n0 << 2) - *pp] = z__[(*i0 << 2) - *pp];
            }
            /* 计算最小值并更新 *dmin2 的值 */
            *dmin2 = min(*dmin2, z__[(*n0 << 2) + *pp - 1]);
            *dmin2 = min(*dmin2, z__[(*i0 << 2) + *pp - 1]);
            *dmin2 = min(*dmin2, z__[(*i0 << 2) + *pp + 3]);
            /* 计算最小值并更新 z__(*n0 << 2 - *pp) 的值 */
            z__[(*n0 << 2) + *pp - 1] = min(z__[(*n0 << 2) + *pp - 1], z__[(*i0 << 2) + *pp - 1]);
            z__[(*n0 << 2) - *pp] = min(z__[(*n0 << 2) - *pp], z__[(*i0 << 2) - *pp]);
            /* 计算最大值并更新 *qmax 的值 */
            *qmax = max(*qmax, z__[(*i0 << 2) + *pp - 3]);
            *qmax = max(*qmax, z__[(*i0 << 2) + *pp + 1]);
            *dmin__ = -0.;
        }
    }

/*     Choose a shift. */

    /* 调用 dlasq4_ 函数选择一个移位量 */
    dlasq4_(i0, n0, &z__[1], pp, &n0in, dmin__, dmin1, dmin2, dn, dn1, dn2, tau, ttype, g);

/*     Call dqds until DMIN > 0. */

L70:
    /* 调用 dlasq5_ 函数直到 *dmin__ > 0 */
    dlasq5_(i0, n0, &z__[1], pp, tau, dmin__, dmin1, dmin2, dn, dn1, dn2, ieee);

    /* 更新 *ndiv 的值 */
    *ndiv += *n0 - *i0 + 2;
    /* 更新 *iter 的值 */
    ++(*iter);

/*     Check status. */

    /* 检查状态 */
    if (*dmin__ >= 0. && *dmin1 > 0.) {

/*        Success. */

        /* 成功，跳转到 L90 */
        goto L90;
    }
    // 如果满足以下条件：
    // 1. *dmin__ 小于 0，
    // 2. *dmin1 大于 0，
    // 3. z__[(*n0 - 1 << 2) - *pp] 小于 tol * (*sigma + *dn1)，
    // 4. abs(*dn) 小于 tol * *sigma，
    // 则执行以下操作：
/*        Convergence hidden by negative DN. */

    z__[(*n0 - 1 << 2) - *pp + 2] = 0.;
    *dmin__ = 0.;
    goto L90;
    } else if (*dmin__ < 0.) {

/*        TAU too big. Select new TAU and try again. */

    ++(*nfail);
    if (*ttype < -22) {

/*           Failed twice. Play it safe. */

        *tau = 0.;
    } else if (*dmin1 > 0.) {

/*           Late failure. Gives excellent shift. */

        *tau = (*tau + *dmin__) * (1. - eps * 2.);
        *ttype += -11;
    } else {

/*           Early failure. Divide by 4. */

        *tau *= .25;
        *ttype += -12;
    }
    goto L70;
    } else if (disnan_(dmin__)) {

/*        NaN. */

    if (*tau == 0.) {
        goto L80;
    } else {
        *tau = 0.;
        goto L70;
    }
    } else {

/*        Possible underflow. Play it safe. */

    goto L80;
    }

/*     Risk of underflow. */

L80:
    dlasq6_(i0, n0, &z__[1], pp, dmin__, dmin1, dmin2, dn, dn1, dn2);
    *ndiv += *n0 - *i0 + 2;
    ++(*iter);
    *tau = 0.;

L90:
    if (*tau < *sigma) {
    *desig += *tau;
    t = *sigma + *desig;
    *desig -= t - *sigma;
    } else {
    t = *sigma + *tau;
    *desig = *sigma - (t - *tau) + *desig;
    }
    *sigma = t;

    return 0;

/*     End of DLASQ3 */

} /* dlasq3_ */

/* Subroutine */ int dlasq4_(integer *i0, integer *n0, doublereal *z__,
    integer *pp, integer *n0in, doublereal *dmin__, doublereal *dmin1,
    doublereal *dmin2, doublereal *dn, doublereal *dn1, doublereal *dn2,
    doublereal *tau, integer *ttype, doublereal *g)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal s, a2, b1, b2;
    static integer i4, nn, np;
    static doublereal gam, gap1, gap2;


/*
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    DLASQ4 computes an approximation TAU to the smallest eigenvalue
    using values of d from the previous transform.

    I0    (input) INTEGER
          First index.

    N0    (input) INTEGER
          Last index.

    Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
          Z holds the qd array.

    PP    (input) INTEGER
          PP=0 for ping, PP=1 for pong.

    NOIN  (input) INTEGER
          The value of N0 at start of EIGTEST.

    DMIN  (input) DOUBLE PRECISION
          Minimum value of d.

    DMIN1 (input) DOUBLE PRECISION
          Minimum value of d, excluding D( N0 ).

    DMIN2 (input) DOUBLE PRECISION
          Minimum value of d, excluding D( N0 ) and D( N0-1 ).

*/
    ! DN    (input) DOUBLE PRECISION
    !       d(N)
    !       输入参数，长度为N的数组d的第N个元素

    ! DN1   (input) DOUBLE PRECISION
    !       d(N-1)
    !       输入参数，长度为N的数组d的第N-1个元素

    ! DN2   (input) DOUBLE PRECISION
    !       d(N-2)
    !       输入参数，长度为N的数组d的第N-2个元素

    ! TAU   (output) DOUBLE PRECISION
    !       This is the shift.
    !       输出参数，表示计算得到的移位量。

    ! TTYPE (output) INTEGER
    !       Shift type.
    !       输出参数，表示移位的类型。

    ! G     (input/output) REAL
    !       G is passed as an argument in order to save its value between
    !       calls to DLASQ4.
    !       输入/输出参数，用于在多次调用DLASQ4之间保存其值。

    ! Further Details
    ! ===============
    ! CNST1 = 9/16
    !       常量1，值为9/16。

    ! =====================================================================

    ! A negative DMIN forces the shift to take that absolute value
    ! 如果DMIN为负数，强制移位取其绝对值。

    ! TTYPE records the type of shift.
    ! TTYPE记录移位的类型。
    /* 参数 z__ 调整 */
    --z__;

    /* 函数体开始 */
    if (*dmin__ <= 0.) {
        *tau = -(*dmin__);  // 将 tau 设为负的最小特征值
        *ttype = -1;        // 设置 ttype 为 -1
        return 0;           // 返回
    }

    nn = (*n0 << 2) + *pp;  // 计算 nn
    if (*n0in == *n0) {

        /* 没有特征值被挡掉 */

        if (*dmin__ == *dn || *dmin__ == *dn1) {

            b1 = sqrt(z__[nn - 3]) * sqrt(z__[nn - 5]);  // 计算 b1
            b2 = sqrt(z__[nn - 7]) * sqrt(z__[nn - 9]);  // 计算 b2
            a2 = z__[nn - 7] + z__[nn - 5];               // 计算 a2

            /* 情况 2 和 3 */

            if (*dmin__ == *dn && *dmin1 == *dn1) {
                gap2 = *dmin2 - a2 - *dmin2 * .25;  // 计算 gap2
                if (gap2 > 0. && gap2 > b2) {
                    gap1 = a2 - *dn - b2 / gap2 * b2;  // 计算 gap1
                } else {
                    gap1 = a2 - *dn - (b1 + b2);       // 计算 gap1
                }
                if (gap1 > 0. && gap1 > b1) {
                    /* 计算最大值 */
                    d__1 = *dn - b1 / gap1 * b1;
                    d__2 = *dmin__ * .5;
                    s = max(d__1, d__2);  // 设置 s 为计算的最大值
                    *ttype = -2;          // 设置 ttype 为 -2
                } else {
                    s = 0.;  // 初始化 s
                    if (*dn > b1) {
                        s = *dn - b1;  // 更新 s
                    }
                    if (a2 > b1 + b2) {
                        /* 计算最小值 */
                        d__1 = s;
                        d__2 = a2 - (b1 + b2);
                        s = min(d__1, d__2);  // 设置 s 为计算的最小值
                    }
                    /* 计算最大值 */
                    d__1 = s;
                    d__2 = *dmin__ * .333;
                    s = max(d__1, d__2);  // 设置 s 为计算的最大值
                    *ttype = -3;          // 设置 ttype 为 -3
                }
            } else {

                /* 情况 4 */

                *ttype = -4;         // 设置 ttype 为 -4
                s = *dmin__ * .25;   // 计算 s
                if (*dmin__ == *dn) {
                    gam = *dn;       // 设置 gam 为 *dn
                    a2 = 0.;         // 设置 a2 为 0
                    if (z__[nn - 5] > z__[nn - 7]) {
                        return 0;   // 返回
                    }
                    b2 = z__[nn - 5] / z__[nn - 7];  // 计算 b2
                    np = nn - 9;    // 计算 np
                } else {
                    np = nn - (*pp << 1);   // 计算 np
                    b2 = z__[np - 2];       // 计算 b2
                    gam = *dn1;             // 设置 gam 为 *dn1
                    if (z__[np - 4] > z__[np - 2]) {
                        return 0;   // 返回
                    }
                    a2 = z__[np - 4] / z__[np - 2];  // 计算 a2
                    if (z__[nn - 9] > z__[nn - 11]) {
                        return 0;   // 返回
                    }
                    b2 = z__[nn - 9] / z__[nn - 11];  // 计算 b2
                    np = nn - 13;   // 计算 np
                }

                /* 对 NN-1 之前的近似贡献到范数平方的计算 */

                a2 += b2;  // 更新 a2
                i__1 = (*i0 << 2) - 1 + *pp;  // 计算 i1
                for (i4 = np; i4 >= i__1; i4 += -4) {
                    if (b2 == 0.) {
                        goto L20;  // 跳转到 L20
                    }
                    b1 = b2;  // 更新 b1
                    if (z__[i4] > z__[i4 - 2]) {
                        return 0;  // 返回
                    }
                    b2 *= z__[i4] / z__[i4 - 2];  // 计算 b2
                    a2 += b2;  // 更新 a2
                    if (max(b2, b1) * 100. < a2 || .563 < a2) {
                        goto L20;  // 跳转到 L20
                    }
                    /* L10 标签 */
                }
L20:
                a2 *= 1.05;  // 更新 a2

                /* Rayleigh 商的剩余界限 */

                if (a2 < .563) {
                    s = gam * (1. - sqrt(a2)) / (a2 + 1.);  // 计算 s
                }
            }
        } else if (*dmin__ == *dn2) {

            /* 情况 5 */

            *ttype = -5;         // 设置 ttype 为 -5
            s = *dmin__ * .25;   // 计算 s
/*           Compute contribution to norm squared from I > NN-2. */

/* 计算从 I > NN-2 贡献到范数平方的部分 */

np = nn - (*pp << 1);
/* 计算 np = nn - (*pp << 1)，即 np = nn - 2 * (*pp) */

b1 = z__[np - 2];
/* 从数组 z__ 中获取值赋给 b1，索引为 np - 2 */

b2 = z__[np - 6];
/* 从数组 z__ 中获取值赋给 b2，索引为 np - 6 */

gam = *dn2;
/* 将 *dn2 的值赋给 gam */

if (z__[np - 8] > b2 || z__[np - 4] > b1) {
/* 如果 z__[np - 8] 大于 b2 或者 z__[np - 4] 大于 b1，则执行以下操作 */

return 0;
/* 返回 0 */

}

a2 = z__[np - 8] / b2 * (z__[np - 4] / b1 + 1.);
/* 计算 a2 = z__[np - 8] / b2 * (z__[np - 4] / b1 + 1.) */

/*           Approximate contribution to norm squared from I < NN-2. */

/* 计算近似于从 I < NN-2 贡献到范数平方的部分 */

if (*n0 - *i0 > 2) {
/* 如果 *n0 - *i0 大于 2，则执行以下操作 */

b2 = z__[nn - 13] / z__[nn - 15];
/* 计算 b2 = z__[nn - 13] / z__[nn - 15] */

a2 += b2;
/* 将 b2 加到 a2 上 */

i__1 = (*i0 << 2) - 1 + *pp;
/* 计算 i__1 = (*i0 << 2) - 1 + *pp */

for (i4 = nn - 17; i4 >= i__1; i4 += -4) {
/* 对于循环变量 i4 初始化为 nn - 17，每次迭代减去 4，直到 i4 大于等于 i__1 */

if (b2 == 0.) {
/* 如果 b2 等于 0，则执行以下操作 */

goto L40;
/* 跳转到标签 L40 */

}

b1 = b2;
/* 将 b2 赋给 b1 */

if (z__[i4] > z__[i4 - 2]) {
/* 如果 z__[i4] 大于 z__[i4 - 2]，则执行以下操作 */

return 0;
/* 返回 0 */

}

b2 *= z__[i4] / z__[i4 - 2];
/* 计算 b2 *= z__[i4] / z__[i4 - 2] */

a2 += b2;
/* 将 b2 加到 a2 上 */

if (max(b2,b1) * 100. < a2 || .563 < a2) {
/* 如果 max(b2,b1) * 100. 小于 a2 或者 .563 小于 a2，则执行以下操作 */

goto L40;
/* 跳转到标签 L40 */

}

/* L30: */
}

L40:
/* 标签 L40 */

a2 *= 1.05;
/* 将 a2 乘以 1.05 */

}

if (a2 < .563) {
/* 如果 a2 小于 .563，则执行以下操作 */

s = gam * (1. - sqrt(a2)) / (a2 + 1.);
/* 计算 s = gam * (1. - sqrt(a2)) / (a2 + 1.) */

} else {

/*           Case 6, no information to guide us. */

/* 情况 6，没有信息可以指导我们 */

if (*ttype == -6) {
/* 如果 *ttype 等于 -6，则执行以下操作 */

*g += (1. - *g) * .333;
/* 将 *g 增加 (1. - *g) * .333 */

} else if (*ttype == -18) {
/* 否则如果 *ttype 等于 -18，则执行以下操作 */

*g = .083250000000000005;
/* 将 *g 设为 .083250000000000005 */

} else {
/* 否则 */

*g = .25;
/* 将 *g 设为 .25 */

}

s = *g * *dmin__;
/* 将 *g 乘以 *dmin__ 赋给 s */

*ttype = -6;
/* 将 *ttype 设为 -6 */

}

} else if (*n0in == *n0 + 1) {

/*        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN. */

/*        一个特征值刚刚被消除。使用 DMIN1 和 DN1 代表 DMIN 和 DN。 */

if (*dmin1 == *dn1 && *dmin2 == *dn2) {

/*           Cases 7 and 8. */

/*           情况 7 和 8。 */

*ttype = -7;
/* 将 *ttype 设为 -7 */

s = *dmin1 * .333;
/* 将 *dmin1 乘以 .333 赋给 s */

if (z__[nn - 5] > z__[nn - 7]) {
/* 如果 z__[nn - 5] 大于 z__[nn - 7]，则执行以下操作 */

return 0;
/* 返回 0 */

}

b1 = z__[nn - 5] / z__[nn - 7];
/* 计算 b1 = z__[nn - 5] / z__[nn - 7] */

b2 = b1;
/* 将 b1 赋给 b2 */

if (b2 == 0.) {
/* 如果 b2 等于 0，则执行以下操作 */

goto L60;
/* 跳转到标签 L60 */

}

i__1 = (*i0 << 2) - 1 + *pp;
/* 计算 i__1 = (*i0 << 2) - 1 + *pp */

for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4) {
/* 对于循环变量 i4 初始化为 (*n0 << 2) - 9 + *pp，每次迭代减去 4，直到 i4 大于等于 i__1 */

a2 = b1;
/* 将 b1 赋给 a2 */

if (z__[i4] > z__[i4 - 2]) {
/* 如果 z__[i4] 大于 z__[i4 - 2]，则执行以下操作 */

return 0;
/* 返回 0 */

}

b1 *= z__[i4] / z__[i4 - 2];
/* 计算 b1 *= z__[i4] / z__[i4 - 2] */

b2 += b1;
/* 将 b1 加到 b2 上 */

if (max(b1,a2) * 100. < b2) {
/* 如果 max(b1,a2) * 100. 小于 b2，则执行以下操作 */

goto L60;
/* 跳转到标签 L60 */

}

/* L50: */
}

L60:
/* 标签 L60 */

b2 = sqrt(b2 * 1.05);
/* 计算 b2 = sqrt(b2 * 1.05) */

/* Computing 2nd power */
d__1 = b2;
/* 计算 d__1 = b2 的平方 */

a2 = *dmin1 / (d__1 * d__1 + 1.);
/* 计算 a2 = *dmin1 / (d__1 * d__1 + 1.) */

gap2 = *dmin2 * .5 - a2;
/* 计算 gap2 = *dmin2 * .5 - a2 */

if (gap2 > 0. && gap2 > b2 * a2) {
/* 如果 gap2 大于 0 并且 gap2 大于 b2 * a2，则执行以下操作 */

/* Computing MAX */
d__1 = s, d__2 = a2 * (1. - a2 * 1.01 * (b2 / gap2) * b2);
/* 计算 d__1 和 d__2 中的最大值 */

s = max(d__1,d__2);
/* 将最大值赋给 s */

} else {
/* 否则 */

/* Computing MAX */
d__1 = s, d__2 = a2 * (1. - b2 * 1.01);
/* 计算 d__1 和 d__2 中的最大值 */

s = max(d__1,d__
    # 检查条件：如果 dmin2 指向的值等于 dn2 指向的值，并且 z__ 数组中倒数第 5 个元素的两倍小于倒数第 7 个元素
    if (*dmin2 == *dn2 && z__[nn - 5] * 2. < z__[nn - 7]) {
        # 设置 ttype 指向的值为 -10
        *ttype = -10;
        # 计算 s 的值为 dmin2 指向的值乘以 0.333
        s = *dmin2 * .333;
        # 如果 z__ 数组中倒数第 5 个元素大于倒数第 7 个元素
        if (z__[nn - 5] > z__[nn - 7]) {
            # 返回 0
            return 0;
        }
        # 计算 b1 的值为 z__ 数组中倒数第 5 个元素除以倒数第 7 个元素
        b1 = z__[nn - 5] / z__[nn - 7];
        # 将 b2 初始化为 b1 的值
        b2 = b1;
        # 如果 b2 的值为 0
        if (b2 == 0.) {
            # 转至标签 L80 处继续执行
            goto L80;
        }
        # 循环：从 (*i0 << 2) - 1 + *pp 到 (*n0 << 2) - 9 + *pp，每次递减 4
        for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4) {
            # 如果 z__ 数组中第 i4 个元素大于第 i4 - 2 个元素
            if (z__[i4] > z__[i4 - 2]) {
                # 返回 0
                return 0;
            }
            # 计算 b1 的值乘以 z__ 数组中第 i4 个元素除以第 i4 - 2 个元素，更新 b1
            b1 *= z__[i4] / z__[i4 - 2];
            # 更新 b2 的值为 b2 加上 b1
            b2 += b1;
            # 如果 b1 的值乘以 100 小于 b2，则转至标签 L80 处继续执行
            if (b1 * 100. < b2) {
                goto L80;
            }
/* L70: */
        }
L80:
        b2 = sqrt(b2 * 1.05);
/* Computing 2nd power */
        d__1 = b2;
        a2 = *dmin2 / (d__1 * d__1 + 1.);
        gap2 = z__[nn - 7] + z__[nn - 9] - sqrt(z__[nn - 11]) * sqrt(z__[
            nn - 9]) - a2;
        if (gap2 > 0. && gap2 > b2 * a2) {
/* Computing MAX */
        d__1 = s, d__2 = a2 * (1. - a2 * 1.01 * (b2 / gap2) * b2);
        s = max(d__1,d__2);
        } else {
/* Computing MAX */
        d__1 = s, d__2 = a2 * (1. - b2 * 1.01);
        s = max(d__1,d__2);
        }
    } else {
        s = *dmin2 * .25;
        *ttype = -11;
    }
    } else if (*n0in > *n0 + 2) {

/*        Case 12, more than two eigenvalues deflated. No information. */

    s = 0.;
    *ttype = -12;
    }

    *tau = s;
    return 0;

/*     End of DLASQ4 */

} /* dlasq4_ */

/* Subroutine */ int dlasq5_(integer *i0, integer *n0, doublereal *z__,
    integer *pp, doublereal *tau, doublereal *dmin__, doublereal *dmin1,
    doublereal *dmin2, doublereal *dn, doublereal *dnm1, doublereal *dnm2,
     logical *ieee)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal d__;
    static integer j4, j4p2;
    static doublereal emin, temp;


/*
    -- LAPACK routine (version 3.2)                                    --

    -- Contributed by Osni Marques of the Lawrence Berkeley National   --
    -- Laboratory and Beresford Parlett of the Univ. of California at  --
    -- Berkeley                                                        --
    -- November 2008                                                   --

    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--


    Purpose
    =======

    DLASQ5 computes one dqds transform in ping-pong form, one
    version for IEEE machines another for non IEEE machines.

    Arguments
    =========

    I0    (input) INTEGER
          First index.

    N0    (input) INTEGER
          Last index.

    Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
          Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
          an extra argument.

    PP    (input) INTEGER
          PP=0 for ping, PP=1 for pong.

    TAU   (input) DOUBLE PRECISION
          This is the shift.

    DMIN  (output) DOUBLE PRECISION
          Minimum value of d.

    DMIN1 (output) DOUBLE PRECISION
          Minimum value of d, excluding D( N0 ).

    DMIN2 (output) DOUBLE PRECISION
          Minimum value of d, excluding D( N0 ) and D( N0-1 ).

    DN    (output) DOUBLE PRECISION
          d(N0), the last value of d.

    DNM1  (output) DOUBLE PRECISION
          d(N0-1).

    DNM2  (output) DOUBLE PRECISION
          d(N0-2).

    IEEE  (input) LOGICAL
          Flag for IEEE or non IEEE arithmetic.

    =====================================================================
*/


    /* Parameter adjustments */
    --z__;


注释：这部分代码包含了两个子例程的定义，分别是 `dlasq4_` 和 `dlasq5_`。
    /* 如果 n0 指向的值减去 i0 指向的值再减去 1小于等于0，则执行以下代码 */
    if (*n0 - *i0 - 1 <= 0) {
        /* 返回值为0 */
        return 0;
    }
    
    /* 计算 j4 的值，j4 = (i0 指向的值左移2位) 加上 pp 指向的值再减去 3 */
    j4 = (*i0 << 2) + *pp - 3;
    
    /* 设置 emin 为数组 z__ 中索引为 j4+4 的元素的值 */
    emin = z__[j4 + 4];
    
    /* 计算 d__ 的值，d__ = 数组 z__ 中索引为 j4 的元素的值减去 tau 指向的值 */
    d__ = z__[j4] - *tau;
    
    /* 将 d__ 的值赋给 dmin__ 指向的变量 */
    *dmin__ = d__;
    
    /* 将 -z__ 数组中索引为 j4 的元素的值赋给 dmin1 指向的变量 */
    *dmin1 = -z__[j4];
    
    /* 如果 ieee 指向的值为真，则执行以下代码 */
    if (*ieee) {
/*        Code for IEEE arithmetic. */

    // 如果 pp 等于 0，则执行以下代码块
    if (*pp == 0) {
        // 计算循环的上限 i__1
        i__1 = *n0 - 3 << 2;
        // 从 j4 = *i0 << 2 开始，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
            // 计算 z__[j4 - 2] 的值
            z__[j4 - 2] = d__ + z__[j4 - 1];
            // 计算 temp 的值
            temp = z__[j4 + 1] / z__[j4 - 2];
            // 计算 d__ 的新值
            d__ = d__ * temp - *tau;
            // 更新 *dmin__ 的值为 d__ 和当前 *dmin__ 中的较小值
            *dmin__ = min(*dmin__,d__);
            // 计算 emin 的新值，为 z__[j4] 和当前 emin 中的较小值
            emin = min(z__[j4],emin);
/* L10: */   // 标号 L10，用于跳转
        }
    } else {
        // 如果 pp 不等于 0，则执行以下代码块
        // 计算循环的上限 i__1
        i__1 = *n0 - 3 << 2;
        // 从 j4 = *i0 << 2 开始，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
            // 计算 z__[j4 - 3] 的值
            z__[j4 - 3] = d__ + z__[j4];
            // 计算 temp 的值
            temp = z__[j4 + 2] / z__[j4 - 3];
            // 计算 d__ 的新值
            d__ = d__ * temp - *tau;
            // 更新 *dmin__ 的值为 d__ 和当前 *dmin__ 中的较小值
            *dmin__ = min(*dmin__,d__);
            // 计算 emin 的新值，为 z__[j4 - 1] 和当前 emin 中的较小值
            emin = min(z__[j4 - 1],emin);
/* L20: */   // 标号 L20，用于跳转
        }
    }

/*        Unroll last two steps. */

    // 将最后两步展开
    *dnm2 = d__;
    *dmin2 = *dmin__;
    // 计算 j4 和 j4p2 的值
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp << 1) - 1;
    // 计算 z__[j4 - 2] 的值
    z__[j4 - 2] = *dnm2 + z__[j4p2];
    // 计算 z__[j4] 的值
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    // 计算 *dnm1 的值
    *dnm1 = z__[j4p2 + 2] * (*dnm2 / z__[j4 - 2]) - *tau;
    // 更新 *dmin__ 的值为 *dmin__ 和当前 *dnm1 中的较小值
    *dmin__ = min(*dmin__,*dnm1);

    // 将 *dmin1 更新为当前 *dmin__
    *dmin1 = *dmin__;
    // 计算 j4 和 j4p2 的新值
    j4 += 4;
    j4p2 = j4 + (*pp << 1) - 1;
    // 计算 z__[j4 - 2] 的值
    z__[j4 - 2] = *dnm1 + z__[j4p2];
    // 如果 *dnm1 小于 0，则返回 0
    if (*dnm1 < 0.) {
        return 0;
    } else {
        // 计算 z__[j4] 的值
        z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
        // 计算 *dn 的值
        *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau;
    }
    // 更新 *dmin__ 的值为 *dmin__ 和当前 *dn 中的较小值
    *dmin__ = min(*dmin__,*dn);

    } else {

/*        Code for non IEEE arithmetic. */

    // 如果不是 IEEE 算术，则执行以下代码块
    if (*pp == 0) {
        // 计算循环的上限 i__1
        i__1 = *n0 - 3 << 2;
        // 从 j4 = *i0 << 2 开始，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
            // 计算 z__[j4 - 2] 的值
            z__[j4 - 2] = d__ + z__[j4 - 1];
            // 如果 d__ 小于 0，则返回 0
            if (d__ < 0.) {
                return 0;
            } else {
                // 计算 z__[j4] 的值
                z__[j4] = z__[j4 + 1] * (z__[j4 - 1] / z__[j4 - 2]);
                // 计算 d__ 的新值
                d__ = z__[j4 + 1] * (d__ / z__[j4 - 2]) - *tau;
            }
            // 更新 *dmin__ 的值为 *dmin__ 和当前 d__ 中的较小值
            *dmin__ = min(*dmin__,d__);
            // 计算 emin 的新值，为 emin 和 z__[j4] 中的较小值
/* L30: */   // 标号 L30，用于跳转
            d__1 = emin, d__2 = z__[j4];
            emin = min(d__1,d__2);
        }
    } else {
        // 如果 pp 不等于 0，则执行以下代码块
        // 计算循环的上限 i__1
        i__1 = *n0 - 3 << 2;
        // 从 j4 = *i0 << 2 开始，每次增加 4
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
            // 计算 z__[j4 - 3] 的值
            z__[j4 - 3] = d__ + z__[j4];
            // 如果 d__ 小于 0，则返回 0
            if (d__ < 0.) {
                return 0;
            } else {
                // 计算 z__[j4 - 1] 的值
                z__[j4 - 1] = z__[j4 + 2] * (z__[j4] / z__[j4 - 3]);
                // 计算 d__ 的新值
                d__ = z__[j4 + 2] * (d__ / z__[j4 - 3]) - *tau;
            }
            // 更新 *dmin__ 的值为 *dmin__ 和当前 d__ 中的较小值
            *dmin__ = min(*dmin__,d__);
            // 计算 emin 的新值，为 emin 和 z__[j4 - 1] 中的较小值
/* L40: */   // 标号 L40，用于跳转
            d__1 = emin, d__2 = z__[j4 - 1];
            emin = min(d__1,d__2);
        }
    }

/*        Unroll last two steps. */

    // 将最后两步展开
    *dnm2 = d__;
    *dmin2 = *dmin__;
    // 计算 j4 和 j4p2 的值
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp << 1) - 1;
    // 计算 z__[j4 - 2] 的值
    z__[j4 - 2] = *dnm2 + z__[j4p2];
    // 如果 *dn
    } else {
        z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
        *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]) - *tau;
    }

else 分支：如果条件不满足，执行以下操作。
- 计算并存储 z__ 数组中的元素值，用于更新 z__ 数组的特定位置。


    *dmin__ = min(*dmin__, *dn);

更新 dmin__ 指针指向的位置，将其值设置为 *dmin__ 和 *dn 中较小的值。


    }

结束当前的 else 分支。


    z__[j4 + 2] = *dn;

将 z__ 数组中的特定位置设置为 *dn 的值。


    z__[(*n0 << 2) - *pp] = emin;

将 z__ 数组中的另一个位置设置为 emin 的值，使用 *n0 和 *pp 进行计算。


    return 0;

返回整数值 0，表示函数执行成功并返回。
/*     End of DLASQ5 */
} /* dlasq5_ */

/* Subroutine */ int dlasq6_(integer *i0, integer *n0, doublereal *z__,
    integer *pp, doublereal *dmin__, doublereal *dmin1, doublereal *dmin2,
    doublereal *dn, doublereal *dnm1, doublereal *dnm2)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal d__;
    static integer j4, j4p2;
    static doublereal emin, temp;

    static doublereal safmin;

    /*
        -- LAPACK routine (version 3.2)                                    --

        -- Contributed by Osni Marques of the Lawrence Berkeley National   --
        -- Laboratory and Beresford Parlett of the Univ. of California at  --
        -- Berkeley                                                        --
        -- November 2008                                                   --

        -- LAPACK is a software package provided by Univ. of Tennessee,    --
        -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
    */

    /* Purpose
       =======
       DLASQ6 computes one dqd (shift equal to zero) transform in
       ping-pong form, with protection against underflow and overflow.
    */

    /* Arguments
       =========
       I0    (input) INTEGER
             First index.

       N0    (input) INTEGER
             Last index.

       Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
             Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
             an extra argument.

       PP    (input) INTEGER
             PP=0 for ping, PP=1 for pong.

       DMIN  (output) DOUBLE PRECISION
             Minimum value of d.

       DMIN1 (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ).

       DMIN2 (output) DOUBLE PRECISION
             Minimum value of d, excluding D( N0 ) and D( N0-1 ).

       DN    (output) DOUBLE PRECISION
             d(N0), the last value of d.

       DNM1  (output) DOUBLE PRECISION
             d(N0-1).

       DNM2  (output) DOUBLE PRECISION
             d(N0-2).
    */

    /* Parameter adjustments */
    --z__;

    /* Function Body */
    if (*n0 - *i0 - 1 <= 0) {
        return 0;
    }

    safmin = SAFEMINIMUM;
    j4 = (*i0 << 2) + *pp - 3;
    emin = z__[j4 + 4];
    d__ = z__[j4];
    *dmin__ = d__;

    if (*pp == 0) {
        i__1 = *n0 - 3 << 2;
        for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
            z__[j4 - 2] = d__ + z__[j4 - 1];
            if (z__[j4 - 2] == 0.) {
                z__[j4] = 0.;
                d__ = z__[j4 + 1];
                *dmin__ = d__;
                emin = 0.;
            } else if (safmin * z__[j4 + 1] < z__[j4 - 2] && safmin * z__[j4
                - 2] < z__[j4 + 1]) {
                temp = z__[j4 + 1] / z__[j4 - 2];
                z__[j4] = z__[j4 - 1] * temp;
                d__ *= temp;
            } else {
                z__[j4] = z__[j4 + 1] * (z__[j4 - 1] / z__[j4 - 2]);
                d__ = z__[j4 + 1] * (d__ / z__[j4 - 2]);
            }
            *dmin__ = min(*dmin__, d__);
            /* Computing MIN */
            d__1 = emin, d__2 = z__[j4];
            emin = min(d__1, d__2);
        }
    }
/* L10: */
    }
    } else {
    i__1 = *n0 - 3 << 2;
    // 循环应用到倒数第二个步骤
    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4) {
        z__[j4 - 3] = d__ + z__[j4];
        // 如果 z__[j4 - 3] 为零
        if (z__[j4 - 3] == 0.) {
        z__[j4 - 1] = 0.;
        // 更新 d__ 和 *dmin__ 的值
        d__ = z__[j4 + 2];
        *dmin__ = d__;
        emin = 0.;
        } else if (safmin * z__[j4 + 2] < z__[j4 - 3] && safmin * z__[j4
            - 3] < z__[j4 + 2]) {
        temp = z__[j4 + 2] / z__[j4 - 3];
        // 应用施密特正交化
        z__[j4 - 1] = z__[j4] * temp;
        d__ *= temp;
        } else {
        z__[j4 - 1] = z__[j4 + 2] * (z__[j4] / z__[j4 - 3]);
        d__ = z__[j4 + 2] * (d__ / z__[j4 - 3]);
        }
        // 更新 *dmin__ 和 emin 的最小值
        *dmin__ = min(*dmin__,d__);
/* Computing MIN */
        d__1 = emin, d__2 = z__[j4 - 1];
        emin = min(d__1,d__2);
/* L20: */
    }
    }

/*     Unroll last two steps. */

    *dnm2 = d__;
    *dmin2 = *dmin__;
    j4 = (*n0 - 2 << 2) - *pp;
    j4p2 = j4 + (*pp << 1) - 1;
    // 应用施密特正交化到最后两步
    z__[j4 - 2] = *dnm2 + z__[j4p2];
    // 如果 z__[j4 - 2] 为零
    if (z__[j4 - 2] == 0.) {
    z__[j4] = 0.;
    // 更新 *dnm1 和 *dmin__ 的值
    *dnm1 = z__[j4p2 + 2];
    *dmin__ = *dnm1;
    emin = 0.;
    } else if (safmin * z__[j4p2 + 2] < z__[j4 - 2] && safmin * z__[j4 - 2] <
        z__[j4p2 + 2]) {
    temp = z__[j4p2 + 2] / z__[j4 - 2];
    // 应用施密特正交化
    z__[j4] = z__[j4p2] * temp;
    *dnm1 = *dnm2 * temp;
    } else {
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    *dnm1 = z__[j4p2 + 2] * (*dnm2 / z__[j4 - 2]);
    }
    // 更新 *dmin__ 的最小值
    *dmin__ = min(*dmin__,*dnm1);

    *dmin1 = *dmin__;
    j4 += 4;
    j4p2 = j4 + (*pp << 1) - 1;
    // 应用施密特正交化到倒数第一步
    z__[j4 - 2] = *dnm1 + z__[j4p2];
    // 如果 z__[j4 - 2] 为零
    if (z__[j4 - 2] == 0.) {
    z__[j4] = 0.;
    // 更新 *dn 和 *dmin__ 的值
    *dn = z__[j4p2 + 2];
    *dmin__ = *dn;
    emin = 0.;
    } else if (safmin * z__[j4p2 + 2] < z__[j4 - 2] && safmin * z__[j4 - 2] <
        z__[j4p2 + 2]) {
    temp = z__[j4p2 + 2] / z__[j4 - 2];
    // 应用施密特正交化
    z__[j4] = z__[j4p2] * temp;
    *dn = *dnm1 * temp;
    } else {
    z__[j4] = z__[j4p2 + 2] * (z__[j4p2] / z__[j4 - 2]);
    *dn = z__[j4p2 + 2] * (*dnm1 / z__[j4 - 2]);
    }
    // 更新 *dmin__ 的最小值
    *dmin__ = min(*dmin__,*dn);

    z__[j4 + 2] = *dn;
    z__[(*n0 << 2) - *pp] = emin;
    return 0;

/*     End of DLASQ6 */

} /* dlasq6_ */

/* Subroutine */ int dlasr_(char *side, char *pivot, char *direct, integer *m,
     integer *n, doublereal *c__, doublereal *s, doublereal *a, integer *
    lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, info;
    static doublereal temp;
    static doublereal ctemp, stemp;
    extern logical lsame_(char *, char *);
    static doublereal ctemp, stemp;
    extern /* Subroutine */ int xerbla_(char *, integer *);

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DLASR applies a sequence of plane rotations to a real matrix A,
    from either the left or the right.

    When SIDE = 'L', the transformation takes the form

       A := P*A
    # 当 SIDE = 'L' 时，变换形式为 A := P**T * A
    # 当 SIDE = 'R' 时，变换形式为 A := A * P**T
    # 其中 P 是一个正交矩阵，由一系列 z 平面旋转构成：
    # - 当 SIDE = 'L' 时，z = M
    # - 当 SIDE = 'R' 时，z = N
    # P**T 表示 P 的转置。

    # 当 DIRECT = 'F' (前向顺序) 时，
    # P = P(z-1) * ... * P(2) * P(1)
    # 当 DIRECT = 'B' (反向顺序) 时，
    # P = P(1) * P(2) * ... * P(z-1)
    # 这里 P(k) 是一个二维平面旋转矩阵：
    # R(k) = (  c(k)  s(k) )
    #      = ( -s(k)  c(k) )

    # 当 PIVOT = 'V' (变量枢轴) 时，
    # 旋转应用于平面 (k,k+1)，即 P(k) 的形式为：
    # P(k) = (  1                                    )
    #        (       ...                             )
    #        (              1                        )
    #        (                   c(k)  s(k)          )
    #        (                  -s(k)  c(k)          )
    #        (                           1           )
    #        (                                ...    )
    #        (                                      1 )

    # 当 PIVOT = 'T' (顶部枢轴) 时，
    # 旋转应用于平面 (1,k+1)，即 P(k) 的形式为：
    # P(k) = (  c(k)                s(k)             )
    #        (         1                               )
    #        (              ...                        )
    #        (                     1                   )
    #        ( -s(k)                c(k)             )
    #        (                         1               )
    #        (                              ...        )
    #        (                                     1  )

    # 当 PIVOT = 'B' (底部枢轴) 时，
    # 旋转应用于平面 (k,z)，即 P(k) 的形式为：
    # P(k) = ( 1                                        )
    #        (      ...                                 )
    #        (             1                            )
    #        (                  c(k)                s(k) )
    #        (                         1                 )
    #        (                              ...          )
    #        (                                     1     )
    #        (                 -s(k)                c(k) )

    # 在不显式形成 P(k) 的情况下执行旋转。
    SIDE    (input) CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A := A*P**T

    PIVOT   (input) CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)

    DIRECT  (input) CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)

    M       (input) INTEGER
            The number of rows of the matrix A.  If m <= 1, an immediate
            return is effected.

    N       (input) INTEGER
            The number of columns of the matrix A.  If n <= 1, an
            immediate return is effected.

    C       (input) DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The cosines c(k) of the plane rotations.

    S       (input) DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The sines s(k) of the plane rotations.  The 2-by-2 plane
            rotation part of the matrix P(k), R(k), has the form
            R(k) = (  c(k)  s(k) )
                   ( -s(k)  c(k) ).

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            The M-by-N matrix A.  On exit, A is overwritten by P*A if
            SIDE = 'R' or by A*P**T if SIDE = 'L'.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    =====================================================================


       Test the input parameters
    /* Parameter adjustments */
    --c__;
    --s;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    info = 0;
    if (! (lsame_(side, "L") || lsame_(side, "R"))) {
    info = 1;
    } else if (! (lsame_(pivot, "V") || lsame_(pivot,
        "T") || lsame_(pivot, "B"))) {
    info = 2;
    } else if (! (lsame_(direct, "F") || lsame_(direct,
        "B"))) {
    info = 3;
    } else if (*m < 0) {
    info = 4;
    } else if (*n < 0) {
    info = 5;
    } else if (*lda < max(1,*m)) {
    info = 9;
    }
    if (info != 0) {
    xerbla_("DLASR ", &info);
    return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
    return 0;
    }
    if (lsame_(side, "L")) {

/*        Form  P * A */

    if (lsame_(pivot, "V")) {
        if (lsame_(direct, "F")) {
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[j + 1 + i__ * a_dim1];
                a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp *
                    a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j
                    + i__ * a_dim1];
/* L10: */
            }
            }
/* L20: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *m - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + 1 + i__ * a_dim1];
                a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp *
                    a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j
                    + i__ * a_dim1];
/* L30: */
            }
            }
/* L40: */
        }
        }
    } else if (lsame_(pivot, "T")) {
        if (lsame_(direct, "F")) {
        i__1 = *m;
        for (j = 2; j <= i__1; ++j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = ctemp * temp - stemp * a[
                    i__ * a_dim1 + 1];
                a[i__ * a_dim1 + 1] = stemp * temp + ctemp * a[
                    i__ * a_dim1 + 1];
/* L50: */
            }
            }
/* L60: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *n;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[j + 1 + i__ * a_dim1];
                a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp *
                    a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j
                    + i__ * a_dim1];
/* L70: */
            }
            }
/* L80: */
        }
        } else if (lsame_(direct, "B")) {
        for (j = *m - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *n;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + 1 + i__ * a_dim1];
                a[j + 1 + i__ * a_dim1] = ctemp * temp - stemp *
                    a[j + i__ * a_dim1];
                a[j + i__ * a_dim1] = stemp * temp + ctemp * a[j
                    + i__ * a_dim1];
/* L90: */
            }
            }
/* L100: */
        }
        }
    }

    return 0;
/* L60: */
        }
        } else if (lsame_(direct, "B")) {
        ! 向后填充方向，对角线元素不动
        for (j = *m; j >= 2; --j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *n;
            ! 对每一列进行操作
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + i__ * a_dim1];
                ! 应用 Givens 变换到矩阵的一部分
                a[j + i__ * a_dim1] = ctemp * temp - stemp * a[
                    i__ * a_dim1 + 1];
                a[i__ * a_dim1 + 1] = stemp * temp + ctemp * a[
                    i__ * a_dim1 + 1];
/* L70: */
            }
            }
/* L80: */
        }
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        ! 向前填充方向，对角线元素不动
        i__1 = *m - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *n;
            ! 对每一列进行操作
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[j + i__ * a_dim1];
                ! 应用 Givens 变换到矩阵的一部分
                a[j + i__ * a_dim1] = stemp * a[*m + i__ * a_dim1]
                     + ctemp * temp;
                a[*m + i__ * a_dim1] = ctemp * a[*m + i__ *
                    a_dim1] - stemp * temp;
/* L90: */
            }
            }
/* L100: */
        }
        } else if (lsame_(direct, "B")) {
        ! 向后填充方向，对角线元素不动
        for (j = *m - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *n;
            ! 对每一列进行操作
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[j + i__ * a_dim1];
                ! 应用 Givens 变换到矩阵的一部分
                a[j + i__ * a_dim1] = stemp * a[*m + i__ * a_dim1]
                     + ctemp * temp;
                a[*m + i__ * a_dim1] = ctemp * a[*m + i__ *
                    a_dim1] - stemp * temp;
/* L110: */
            }
            }
/* L120: */
        }
        }
    }
    } else if (lsame_(side, "R")) {

/*        Form A * P' */

    if (lsame_(pivot, "V")) {
        if (lsame_(direct, "F")) {
        ! 向前填充方向，对角线元素不动
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__2 = *m;
            ! 对每一行进行操作
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + (j + 1) * a_dim1];
                ! 应用 Givens 变换到矩阵的一部分
                a[i__ + (j + 1) * a_dim1] = ctemp * temp - stemp *
                     a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * temp + ctemp * a[
                    i__ + j * a_dim1];
/* L130: */
            }
            }
/* L140: */
        }
        } else if (lsame_(direct, "B")) {
        ! 向后填充方向，对角线元素不动
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            i__1 = *m;
            ! 对每一行进行操作
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + (j + 1) * a_dim1];
                ! 应用 Givens 变换到矩阵的一部分
                a[i__ + (j + 1) * a_dim1] = ctemp * temp - stemp *
                     a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * temp + ctemp * a[
                    i__ + j * a_dim1];
/* L150: 结束 if 语句块 */
            }
            /* L160: 结束 if-else 语句块 */
        }
        /* L160: 结束 for 循环块 */
    } else if (lsame_(pivot, "T")) {
        if (lsame_(direct, "F")) {
        /* L170: 开始 for 循环块 */
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1. || stemp != 0.) {
            /* L180: 开始 for 循环块 */
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = ctemp * temp - stemp * a[
                    i__ + a_dim1];
                a[i__ + a_dim1] = stemp * temp + ctemp * a[i__ +
                    a_dim1];
/* L170: 结束 for 循环块 */
            }
            /* L180: 结束 if 语句块 */
            }
/* L180: 结束 for 循环块 */
        }
        /* L160: 结束 if-else 语句块 */
        } else if (lsame_(direct, "B")) {
        /* L190: 开始 for 循环块 */
        for (j = *n; j >= 2; --j) {
            ctemp = c__[j - 1];
            stemp = s[j - 1];
            if (ctemp != 1. || stemp != 0.) {
            /* L200: 开始 for 循环块 */
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = ctemp * temp - stemp * a[
                    i__ + a_dim1];
                a[i__ + a_dim1] = stemp * temp + ctemp * a[i__ +
                    a_dim1];
/* L190: 结束 for 循环块 */
            }
            /* L200: 结束 if 语句块 */
            }
/* L200: 结束 for 循环块 */
        }
        /* L160: 结束 if-else 语句块 */
        }
    } else if (lsame_(pivot, "B")) {
        if (lsame_(direct, "F")) {
        /* L210: 开始 for 循环块 */
        i__1 = *n - 1;
        for (j = 1; j <= i__1; ++j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            /* L220: 开始 for 循环块 */
            i__2 = *m;
            for (i__ = 1; i__ <= i__2; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * a[i__ + *n * a_dim1]
                     + ctemp * temp;
                a[i__ + *n * a_dim1] = ctemp * a[i__ + *n *
                    a_dim1] - stemp * temp;
/* L210: 结束 for 循环块 */
            }
            /* L220: 结束 if 语句块 */
            }
/* L220: 结束 for 循环块 */
        }
        /* L160: 结束 if-else 语句块 */
        } else if (lsame_(direct, "B")) {
        /* L230: 开始 for 循环块 */
        for (j = *n - 1; j >= 1; --j) {
            ctemp = c__[j];
            stemp = s[j];
            if (ctemp != 1. || stemp != 0.) {
            /* L240: 开始 for 循环块 */
            i__1 = *m;
            for (i__ = 1; i__ <= i__1; ++i__) {
                temp = a[i__ + j * a_dim1];
                a[i__ + j * a_dim1] = stemp * a[i__ + *n * a_dim1]
                     + ctemp * temp;
                a[i__ + *n * a_dim1] = ctemp * a[i__ + *n *
                    a_dim1] - stemp * temp;
/* L230: 结束 for 循环块 */
            }
            /* L240: 结束 if 语句块 */
            }
/* L240: 结束 for 循环块 */
        }
        /* L160: 结束 if-else 语句块 */
        }
    }
    /* L160: 结束 if 语句块 */
    }

    /* 返回 0 表示成功执行 */
    return 0;

/*     End of DLASR */

} /* dlasr_ */

/* Subroutine */ int dlasrt_(char *id, integer *n, doublereal *d__, integer *
    info)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, j;
    static doublereal d1, d2, d3;
    static integer dir;
    static doublereal tmp;
    static integer endd;
    extern logical lsame_(char *, char *);
    static integer stack[64]    /* was [2][32] */;
    static doublereal dmnmx;
    static integer start;

/* dlasrt_ 为排序算法，根据指定 id 和数组 d__ 对其进行排序 */
    # 声明一个外部子程序 xerbla_，该子程序接受一个字符指针和一个整数指针作为参数，并返回整型结果
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明一个静态整型变量 stkpnt，静态变量的生命周期延长到整个程序执行期间，其初始值为0
    static integer stkpnt;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    Sort the numbers in D in increasing order (if ID = 'I') or
    in decreasing order (if ID = 'D' ).

    Use Quick Sort, reverting to Insertion sort on arrays of
    size <= 20. Dimension of STACK limits N to about 2**32.

    Arguments
    =========

    ID      (input) CHARACTER*1
            = 'I': sort D in increasing order;
            = 'D': sort D in decreasing order.

    N       (input) INTEGER
            The length of the array D.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the array to be sorted.
            On exit, D has been sorted into increasing order
            (D(1) <= ... <= D(N) ) or into decreasing order
            (D(1) >= ... >= D(N) ), depending on ID.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input paramters.
*/

    /* Parameter adjustments */
    --d__;

    /* Function Body */
    *info = 0;
    dir = -1;
    if (lsame_(id, "D")) {
    dir = 0;
    } else if (lsame_(id, "I")) {
    dir = 1;
    }
    if (dir == -1) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DLASRT", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n <= 1) {
    return 0;
    }

    stkpnt = 1;
    stack[0] = 1;
    stack[1] = *n;
L10:
    start = stack[(stkpnt << 1) - 2];
    endd = stack[(stkpnt << 1) - 1];
    --stkpnt;
    if (endd - start <= 20 && endd - start > 0) {

/*        Do Insertion sort on D( START:ENDD ) */

    if (dir == 0) {

/*           Sort into decreasing order */

        i__1 = endd;
        for (i__ = start + 1; i__ <= i__1; ++i__) {
        i__2 = start + 1;
        for (j = i__; j >= i__2; --j) {
            if (d__[j] > d__[j - 1]) {
            dmnmx = d__[j];
            d__[j] = d__[j - 1];
            d__[j - 1] = dmnmx;
            } else {
            goto L30;
            }
/* L20: */
        }
L30:
        ;
        }

    } else {

/*           Sort into increasing order */

        i__1 = endd;
        for (i__ = start + 1; i__ <= i__1; ++i__) {
        i__2 = start + 1;
        for (j = i__; j >= i__2; --j) {
            if (d__[j] < d__[j - 1]) {
            dmnmx = d__[j];
            d__[j] = d__[j - 1];
            d__[j - 1] = dmnmx;
            } else {
            goto L50;
            }
/* L40: */
        }
L50:
        ;
        }

    }

    } else if (endd - start > 20) {

/*
          Partition D( START:ENDD ) and stack parts, largest one first

          Choose partition entry as median of 3
*/

    d1 = d__[start];
    d2 = d__[endd];
    mid = (start + endd) / 2;
    d3 = d__[mid];
    if (d3 < d1) {
        temp = d1;
        d1 = d3;
        d3 = temp;
    }
    if (d2 < d1) {
        temp = d1;
        d1 = d2;
        d2 = temp;
    }
    if (d3 < d2) {
        temp = d2;
        d2 = d3;
        d3 = temp;
    }
    d__[start] = d1;
    d__[endd] = d3;
    d__[*((integer *)&c__ + 1)] = d2;
    pivot = d2;
    k = start;
    l = endd + 1;
L70:
    --l;
    if (d__[l] <= pivot) {
        goto L80;
    }
    goto L90;
L80:
    ++k;
    if (k < l) {
        temp = d__[k];
        d__[k] = d__[l];
        d__[l] = temp;
        goto L70;
    }
L90:
    if (start < l) {
        if (k < l) {
            --stkpnt;
            stack[(stkpnt << 1) + 1] = l;
            stack[(stkpnt << 1) + 2] = endd;
            ++stkpnt;
            stack[(stkpnt << 1) + 1] = start;
            stack[(stkpnt << 1) + 2] = k;
            if (stkpnt > 30) {
                xerbla_("DLASRT", &c__4);
            }
            goto L10;
        }
    }
    }
    // 从数组 d__ 中获取索引为 endd 的元素赋值给 d2
    d2 = d__[endd];
    // 计算 start 和 endd 的中间索引，并赋值给 i__
    i__ = (start + endd) / 2;
    // 从数组 d__ 中获取索引为 i__ 的元素赋值给 d3
    d3 = d__[i__];
    
    // 根据条件比较 d1、d2、d3 的大小关系，确定 dmnmx 的值
    if (d1 < d2) {
        if (d3 < d1) {
            // 如果 d3 < d1，则 dmnmx 被赋值为 d1
            dmnmx = d1;
        } else if (d3 < d2) {
            // 如果 d1 <= d3 < d2，则 dmnmx 被赋值为 d3
            dmnmx = d3;
        } else {
            // 如果 d1 <= d2 <= d3，则 dmnmx 被赋值为 d2
            dmnmx = d2;
        }
    } else {
        if (d3 < d2) {
            // 如果 d3 < d2，则 dmnmx 被赋值为 d2
            dmnmx = d2;
        } else if (d3 < d1) {
            // 如果 d2 <= d3 < d1，则 dmnmx 被赋值为 d3
            dmnmx = d3;
        } else {
            // 如果 d2 <= d1 <= d3，则 dmnmx 被赋值为 d1
            dmnmx = d1;
        }
    }

    // 如果 dir 等于 0，则执行以下代码块
/*           Sort into decreasing order */

/* 初始化指针变量 i__ 和 j，分别指向排序的起始位置和结束位置 */
        i__ = start - 1;
        j = endd + 1;
L60:
L70:
/* 递减地移动 j 指针，直到找到一个大于 dmnmx 的元素 */
        --j;
        if (d__[j] < dmnmx) {
/* 如果 d__[j] 小于 dmnmx，则继续向前移动 j 指针 */
        goto L70;
        }
L80:
/* 递增地移动 i__ 指针，直到找到一个大于 dmnmx 的元素 */
        ++i__;
        if (d__[i__] > dmnmx) {
/* 如果 d__[i__] 大于 dmnmx，则继续向前移动 i__ 指针 */
        goto L80;
        }
/* 当 i__ < j 时交换 d__[i__] 和 d__[j] 的值 */
        if (i__ < j) {
        tmp = d__[i__];
        d__[i__] = d__[j];
        d__[j] = tmp;
        goto L60;
        }
/* 根据剩余子数组的大小判断下一步排序的子数组范围 */
        if (j - start > endd - j - 1) {
/* 将更大的子数组的起始和结束位置入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        } else {
/* 将更小的子数组的起始和结束位置入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        }
    } else {

/*           Sort into increasing order */

/* 初始化指针变量 i__ 和 j，分别指向排序的起始位置和结束位置 */
        i__ = start - 1;
        j = endd + 1;
L90:
L100:
/* 递减地移动 j 指针，直到找到一个小于 dmnmx 的元素 */
        --j;
        if (d__[j] > dmnmx) {
/* 如果 d__[j] 大于 dmnmx，则继续向前移动 j 指针 */
        goto L100;
        }
L110:
/* 递增地移动 i__ 指针，直到找到一个小于 dmnmx 的元素 */
        ++i__;
        if (d__[i__] < dmnmx) {
/* 如果 d__[i__] 小于 dmnmx，则继续向前移动 i__ 指针 */
        goto L110;
        }
/* 当 i__ < j 时交换 d__[i__] 和 d__[j] 的值 */
        if (i__ < j) {
        tmp = d__[i__];
        d__[i__] = d__[j];
        d__[j] = tmp;
        goto L90;
        }
/* 根据剩余子数组的大小判断下一步排序的子数组范围 */
        if (j - start > endd - j - 1) {
/* 将更大的子数组的起始和结束位置入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        } else {
/* 将更小的子数组的起始和结束位置入栈 */
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = j + 1;
        stack[(stkpnt << 1) - 1] = endd;
        ++stkpnt;
        stack[(stkpnt << 1) - 2] = start;
        stack[(stkpnt << 1) - 1] = j;
        }
    }
    }
/* 如果栈中还有未处理的子数组，则继续处理 */
    if (stkpnt > 0) {
    goto L10;
    }
/* 排序完成，返回 0 */
    return 0;

/*     End of DLASRT */

} /* dlasrt_ */

/* Subroutine */ int dlassq_(integer *n, doublereal *x, integer *incx,
    doublereal *scale, doublereal *sumsq)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer ix;
    static doublereal absxi;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASSQ  returns the values  scl  and  smsq  such that

       ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

    where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
    assumed to be non-negative and  scl  returns the value

       scl = max( scale, abs( x( i ) ) ).

    scale and sumsq must be supplied in SCALE and SUMSQ and
    scl and smsq are overwritten on SCALE and SUMSQ respectively.

    The routine makes only one pass through the vector x.

    Arguments
    =========

    N       (input) INTEGER
            The number of elements to be used from the vector X.


注释：
    X       (input) DOUBLE PRECISION array, dimension (N)
            The vector for which a scaled sum of squares is computed.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.



    INCX    (input) INTEGER
            The increment between successive values of the vector X.
            INCX > 0.



    SCALE   (input/output) DOUBLE PRECISION
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with  scl , the scaling factor
            for the sum of squares.



    SUMSQ   (input/output) DOUBLE PRECISION
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with  smsq , the basic sum of
            squares from which  scl  has been factored out.



   =====================================================================


These comments provide a clear explanation of each parameter in a Fortran subroutine or function, adhering to the required format.
    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n > 0) { // 如果 n 大于 0
        // 计算循环的起始位置 ix 和步长 i__2
        i__1 = (*n - 1) * *incx + 1;
        i__2 = *incx;
        for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {
            if (x[ix] != 0.) { // 如果 x[ix] 不等于 0
                // 计算 x[ix] 的绝对值
                absxi = (d__1 = x[ix], abs(d__1));
                if (*scale < absxi) { // 如果当前的 scale 小于 absxi
                    /* Computing 2nd power */
                    d__1 = *scale / absxi;
                    // 更新 sumsq 的值
                    *sumsq = *sumsq * (d__1 * d__1) + 1;
                    // 更新 scale 的值
                    *scale = absxi;
                } else {
                    /* Computing 2nd power */
                    d__1 = absxi / *scale;
                    // 更新 sumsq 的值
                    *sumsq += d__1 * d__1;
                }
            }
            // L10: 标签，用于循环控制
        }
    }
    return 0;

/*     End of DLASSQ */

} /* dlassq_ */

/* Subroutine */ int dlasv2_(doublereal *f, doublereal *g, doublereal *h__,
    doublereal *ssmin, doublereal *ssmax, doublereal *snr, doublereal *
    csr, doublereal *snl, doublereal *csl)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    static doublereal a, d__, l, m, r__, s, t, fa, ga, ha, ft, gt, ht, mm, tt,
         clt, crt, slt, srt;
    static integer pmax;
    static doublereal temp;
    static logical swap;
    static doublereal tsign;

    static logical gasmal;

/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DLASV2 computes the singular value decomposition of a 2-by-2
    triangular matrix
       [  F   G  ]
       [  0   H  ].
    On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
    smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
    right singular vectors for abs(SSMAX), giving the decomposition

       [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
       [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].

    Arguments
    =========

    F       (input) DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.

    G       (input) DOUBLE PRECISION
            The (1,2) element of the 2-by-2 matrix.

    H       (input) DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.

    SSMIN   (output) DOUBLE PRECISION
            abs(SSMIN) is the smaller singular value.

    SSMAX   (output) DOUBLE PRECISION
            abs(SSMAX) is the larger singular value.

    SNL     (output) DOUBLE PRECISION
    CSL     (output) DOUBLE PRECISION
            The vector (CSL, SNL) is a unit left singular vector for the
            singular value abs(SSMAX).

    SNR     (output) DOUBLE PRECISION
    CSR     (output) DOUBLE PRECISION
            The vector (CSR, SNR) is a unit right singular vector for the
            singular value abs(SSMAX).

    Further Details
    ===============

    Any input parameter may be aliased with any output parameter.

    Barring over/underflow and assuming a guard digit in subtraction, all
*/


这里是给定的代码块及其相应的注释。每行代码都被适当地注释，说明了其功能和作用。
    output quantities are correct to within a few units in the last
    place (ulps).

    In IEEE arithmetic, the code works correctly if one matrix element is
    infinite.

    Overflow will not occur unless the largest singular value itself
    overflows or is within a few ulps of overflow. (On machines with
    partial overflow, like the Cray, overflow may occur if the largest
    singular value is within a factor of 2 of overflow.)

    Underflow is harmless if underflow is gradual. Otherwise, results
    may correspond to a matrix modified by perturbations of size near
    the underflow threshold.

   =====================================================================
/*
       PMAX`
    ft = *f;
    fa = abs(ft);
    ht = *h__;
    ha = abs(*h__);

    /*
       PMAX points to the maximum absolute element of matrix
         PMAX = 1 if F largest in absolute values
         PMAX = 2 if G largest in absolute values
         PMAX = 3 if H largest in absolute values
    */
    pmax = 1;
    swap = ha > fa;
    if (swap) {
        pmax = 3;
        temp = ft;
        ft = ht;
        ht = temp;
        temp = fa;
        fa = ha;
        ha = temp;

        /* Now FA .ge. HA */
    }
    gt = *g;
    ga = abs(gt);
    if (ga == 0.) {

        /* Diagonal matrix */
        *ssmin = ha;
        *ssmax = fa;
        clt = 1.;
        crt = 1.;
        slt = 0.;
        srt = 0.;
    } else {
        gasmal = TRUE_;
        if (ga > fa) {
            pmax = 2;
            if (fa / ga < EPSILON) {

                /* Case of very large GA */
                gasmal = FALSE_;
                *ssmax = ga;
                if (ha > 1.) {
                    *ssmin = fa / (ga / ha);
                } else {
                    *ssmin = fa / ga * ha;
                }
                clt = 1.;
                slt = ht / gt;
                srt = 1.;
                crt = ft / gt;
            }
        }
        if (gasmal) {

            /* Normal case */
            d__ = fa - ha;
            if (d__ == fa) {

                /* Copes with infinite F or H */
                l = 1.;
            } else {
                l = d__ / fa;
            }

            /* Note that 0 .le. L .le. 1 */
            m = gt / ft;

            /* Note that abs(M) .le. 1/macheps */
            t = 2. - l;

            /* Note that T .ge. 1 */
            mm = m * m;
            tt = t * t;
            s = sqrt(tt + mm);

            /* Note that 1 .le. S .le. 1 + 1/macheps */
            if (l == 0.) {
                r__ = abs(m);
            } else {
                r__ = sqrt(l * l + mm);
            }

            /* Note that 0 .le. R .le. 1 + 1/macheps */
            a = (s + r__) * .5;

            /* Note that 1 .le. A .le. 1 + abs(M) */
            *ssmin = ha / a;
            *ssmax = fa * a;
            if (mm == 0.) {

                /* Note that M is very tiny */
                if (l == 0.) {
                    t = d_sign(&c_b3192, &ft) * d_sign(&c_b15, &gt);
                } else {
                    t = gt / d_sign(&d__, &ft) + m / t;
                }
            } else {
                t = (m / (s + t) + m / (r__ + l)) * (a + 1.);
            }
            l = sqrt(t * t + 4.);
            crt = 2. / l;
            srt = t / l;
            clt = (crt + srt * m) / a;
            slt = ht / ft * srt / a;
        }
    }
    if (swap) {
        *csl = srt;
        *snl = crt;
        *csr = slt;
        *snr = clt;
    } else {
        *csl = clt;
        *snl = slt;
        *csr = crt;
        *snr = srt;
    }

    /* Correct signs of SSMAX and SSMIN */
    if (pmax == 1) {
        tsign = d_sign(&c_b15, csr) * d_sign(&c_b15, csl) * d_sign(&c_b15, f);
    }
    if (pmax == 2) {
        tsign = d_sign(&c_b15, snr) * d_sign(&c_b15, csl) * d_sign(&c_b15, g);
    }
    if (pmax == 3) {
        tsign = d_sign(&c_b15, snr) * d_sign(&c_b15, snl) * d_sign(&c_b15,
            h__);
    }
    *ssmax = d_sign(ssmax, &tsign);
    d__1 = tsign * d_sign(&c_b15, f) * d_sign(&c_b15, h__);
    *ssmin = d_sign(ssmin, &d__1);
    return 0;
/*
   -- LAPACK auxiliary routine (version 3.2) --
   -- LAPACK is a software package provided by Univ. of Tennessee,    --
   -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006
*/

/* Subroutine */ int dlaswp_(integer *n, doublereal *a, integer *lda, integer
    *k1, integer *k2, integer *ipiv, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    static doublereal temp;

    /*
       Purpose
       =======
    
       DLASWP performs a series of row interchanges on the matrix A.
       One row interchange is initiated for each of rows K1 through K2 of A.
    
       Arguments
       =========
    
       N       (input) INTEGER
               The number of columns of the matrix A.
    
       A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
               On entry, the matrix of column dimension N to which the row
               interchanges will be applied.
               On exit, the permuted matrix.
    
       LDA     (input) INTEGER
               The leading dimension of the array A.
    
       K1      (input) INTEGER
               The first element of IPIV for which a row interchange will
               be done.
    
       K2      (input) INTEGER
               The last element of IPIV for which a row interchange will
               be done.
    
       IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
               The vector of pivot indices.  Only the elements in positions
               K1 through K2 of IPIV are accessed.
               IPIV(K) = L implies rows K and L are to be interchanged.
    
       INCX    (input) INTEGER
               The increment between successive values of IPIV.  If IPIV
               is negative, the pivots are applied in reverse order.
    
       Further Details
       ===============
    
       Modified by
        R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
    
       =====================================================================
    
    
          Interchange row I with row IPIV(I) for each of rows K1 through K2.
    */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    if (*incx > 0) {
        ix0 = *k1;
        i1 = *k1;
        i2 = *k2;
        inc = 1;
    } else if (*incx < 0) {
        ix0 = (1 - *k2) * *incx + 1;
        i1 = *k2;
        i2 = *k1;
        inc = -1;
    } else {
        return 0;
    }

    n32 = *n / 32 << 5;
    if (n32 != 0) {
        i__1 = n32;
        for (j = 1; j <= i__1; j += 32) {
            ix = ix0;
            i__2 = i2;
            i__3 = inc;
            for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3) {
                ip = ipiv[ix];
                if (ip != i__) {
                    i__4 = j + 31;
                    for (k = j; k <= i__4; ++k) {
                        temp = a[i__ + k * a_dim1];
                        a[i__ + k * a_dim1] = a[ip + k * a_dim1];
                        a[ip + k * a_dim1] = temp;
                    }
                }
                ix += *incx;
            }
        }
    }

    return 0;
}
/* L10: */
            }
        }
        ix += *incx;
/* L20: */
        }
/* L30: */
    }
    }
    if (n32 != *n) {
    ++n32;
    ix = ix0;
    i__1 = i2;
    i__3 = inc;
    for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
        ip = ipiv[ix];
        if (ip != i__) {
        i__2 = *n;
        for (k = n32; k <= i__2; ++k) {
            temp = a[i__ + k * a_dim1];
            a[i__ + k * a_dim1] = a[ip + k * a_dim1];
            a[ip + k * a_dim1] = temp;
/* L40: */
        }
        }
        ix += *incx;
/* L50: */
    }
    }

    return 0;

/*     End of DLASWP */

} /* dlaswp_ */

/* Subroutine */ int dlasy2_(logical *ltranl, logical *ltranr, integer *isgn,
    integer *n1, integer *n2, doublereal *tl, integer *ldtl, doublereal *
    tr, integer *ldtr, doublereal *b, integer *ldb, doublereal *scale,
    doublereal *x, integer *ldx, doublereal *xnorm, integer *info)
{
    /* Initialized data */

    static integer locu12[4] = { 3,4,1,2 };
    static integer locl21[4] = { 2,1,4,3 };
    static integer locu22[4] = { 4,3,2,1 };
    static logical xswpiv[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical bswpiv[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };

    /* System generated locals */
    integer b_dim1, b_offset, tl_dim1, tl_offset, tr_dim1, tr_offset, x_dim1,
        x_offset;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8;

    /* Local variables */
    static integer i__, j, k;
    static doublereal x2[2], l21, u11, u12;
    static integer ip, jp;
    static doublereal u22, t16[16]    /* was [4][4] */, gam, bet, eps, sgn,
        tmp[4], tau1, btmp[4], smin;
    static integer ipiv;
    static doublereal temp;
    static integer jpiv[4];
    static doublereal xmax;
    static integer ipsv, jpsv;
    static logical bswap;
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *), dswap_(integer *, doublereal *, integer
        *, doublereal *, integer *);
    static logical xswap;

    extern integer idamax_(integer *, doublereal *, integer *);
    static doublereal smlnum;


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in

           op(TL)*X + ISGN*X*op(TR) = SCALE*B,

    where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
    -1.  op(T) = T or T', where T' denotes the transpose of T.

    Arguments
    =========

    LTRANL  (input) LOGICAL
            On entry, LTRANL specifies the op(TL):
               = .FALSE., op(TL) = TL,
               = .TRUE., op(TL) = TL'.

    LTRANR  (input) LOGICAL
            On entry, LTRANR specifies the op(TR):
              = .FALSE., op(TR) = TR,
              = .TRUE., op(TR) = TR'.


注释部分由于代码较长，无法在此处完全展示。
    ISGN    (input) INTEGER
            输入参数，指定方程的符号。ISGN只能是1或-1。

    N1      (input) INTEGER
            输入参数，指定矩阵TL的阶数。N1只能是0、1或2。

    N2      (input) INTEGER
            输入参数，指定矩阵TR的阶数。N2只能是0、1或2。

    TL      (input) DOUBLE PRECISION array, dimension (LDTL,2)
            输入参数，TL是一个N1乘N1的矩阵。

    LDTL    (input) INTEGER
            输入参数，矩阵TL的领导维度。LDTL必须大于等于max(1, N1)。

    TR      (input) DOUBLE PRECISION array, dimension (LDTR,2)
            输入参数，TR是一个N2乘N2的矩阵。

    LDTR    (input) INTEGER
            输入参数，矩阵TR的领导维度。LDTR必须大于等于max(1, N2)。

    B       (input) DOUBLE PRECISION array, dimension (LDB,2)
            输入参数，大小为N1乘N2的矩阵B，包含方程的右手边。

    LDB     (input) INTEGER
            输入参数，矩阵B的领导维度。LDB必须大于等于max(1, N1)。

    SCALE   (output) DOUBLE PRECISION
            输出参数，SCALE包含计算结果的比例因子。为防止解溢出，SCALE小于等于1。

    X       (output) DOUBLE PRECISION array, dimension (LDX,2)
            输出参数，大小为N1乘N2的矩阵X，包含解。

    LDX     (input) INTEGER
            输入参数，矩阵X的领导维度。LDX必须大于等于max(1, N1)。

    XNORM   (output) DOUBLE PRECISION
            输出参数，XNORM是解的无穷范数。

    INFO    (output) INTEGER
            输出参数，INFO表示退出状态：
               0: 成功退出。
               1: TL和TR具有过于接近的特征值，因此TL或TR被扰动以获得非奇异方程。
            注意：出于速度考虑，此例程不检查输入错误。
    /* Parameter adjustments */
    tl_dim1 = *ldtl;
    tl_offset = 1 + tl_dim1;
    tl -= tl_offset;
    tr_dim1 = *ldtr;
    tr_offset = 1 + tr_dim1;
    tr -= tr_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;



    /* Function Body */

    /* Do not check the input parameters for errors */
    *info = 0;

    /* Quick return if possible */
    if (*n1 == 0 || *n2 == 0) {
        return 0;
    }

    /* Set constants to control overflow */
    eps = PRECISION;
    smlnum = SAFEMINIMUM / eps;
    sgn = (doublereal) (*isgn);

    k = *n1 + *n1 + *n2 - 2;
    switch (k) {
    case 1:  goto L10;
    case 2:  goto L20;
    case 3:  goto L30;
    case 4:  goto L50;
    }

    /* 1 by 1: TL11*X + SGN*X*TR11 = B11 */
L10:
    tau1 = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    bet = abs(tau1);
    if (bet <= smlnum) {
        tau1 = smlnum;
        bet = smlnum;
        *info = 1;
    }

    *scale = 1.;
    gam = (d__1 = b[b_dim1 + 1], abs(d__1));
    if (smlnum * gam > bet) {
        *scale = 1. / gam;
    }

    x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / tau1;
    *xnorm = (d__1 = x[x_dim1 + 1], abs(d__1));
    return 0;

    /* 1 by 2: */
L20:
    /* Computing MAX */
    d__7 = (d__1 = tl[tl_dim1 + 1], abs(d__1)), d__8 = (d__2 = tr[tr_dim1 + 1], abs(d__2)), d__7 = max(d__7,d__8), d__8 = (d__3 = tr[(tr_dim1 << 1) + 1], abs(d__3)), d__7 = max(d__7,d__8), d__8 = (d__4 = tr[tr_dim1 + 2], abs(d__4)), d__7 = max(d__7,d__8), d__8 = (d__5 = tr[(tr_dim1 << 1) + 2], abs(d__5));
    d__6 = eps * max(d__7,d__8);
    smin = max(d__6,smlnum);
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    tmp[3] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];
    if (*ltranr) {
        tmp[1] = sgn * tr[tr_dim1 + 2];
        tmp[2] = sgn * tr[(tr_dim1 << 1) + 1];
    } else {
        tmp[1] = sgn * tr[(tr_dim1 << 1) + 1];
        tmp[2] = sgn * tr[tr_dim1 + 2];
    }
    btmp[0] = b[b_dim1 + 1];
    btmp[1] = b[(b_dim1 << 1) + 1];
    goto L40;

    /* 2 by 1: */
L30:
    /* Computing MAX */
    d__7 = (d__1 = tr[tr_dim1 + 1], abs(d__1)), d__8 = (d__2 = tl[tl_dim1 + 1], abs(d__2)), d__7 = max(d__7,d__8), d__8 = (d__3 = tl[(tl_dim1 << 1) + 1], abs(d__3)), d__7 = max(d__7,d__8), d__8 = (d__4 = tl[tl_dim1 + 2], abs(d__4)), d__7 = max(d__7,d__8), d__8 = (d__5 = tl[(tl_dim1 << 1) + 2], abs(d__5));
    d__6 = eps * max(d__7,d__8);
    smin = max(d__6,smlnum);
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    tmp[3] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];
    if (*ltranl) {
        tmp[1] = tl[(tl_dim1 << 1) + 1];
        tmp[2] = tl[tl_dim1 + 2];
    } else {
    # 如果条件不成立，执行以下操作：
    tmp[1] = tl[tl_dim1 + 2];
    # 将数组 tmp 的第二个元素设置为 tl 数组中的第 tl_dim1 + 2 个元素
    tmp[2] = tl[(tl_dim1 << 1) + 1];
    # 将数组 tmp 的第三个元素设置为 tl 数组中的第 (tl_dim1 << 1) + 1 个元素
    }
    # 结束条件分支

    btmp[0] = b[b_dim1 + 1];
    # 将数组 btmp 的第一个元素设置为 b 数组中的第 b_dim1 + 1 个元素
    btmp[1] = b[b_dim1 + 2];
    # 将数组 btmp 的第二个元素设置为 b 数组中的第 b_dim1 + 2 个元素
/*
       Solve 2 by 2 system using complete pivoting.
       Set pivots less than SMIN to SMIN.
*/
ipiv = idamax_(&c__4, tmp, &c__1);
// Find index of the element with maximum absolute value in tmp array
u11 = tmp[ipiv - 1];
// u11 is the pivot element from tmp array
if (abs(u11) <= smin) {
// If absolute value of u11 is less than or equal to smin
*info = 1;
// Set info to 1 indicating a pivot less than smin was found
u11 = smin;
// Adjust u11 to be at least smin
}
u12 = tmp[locu12[ipiv - 1] - 1];
// u12 is the element in tmp corresponding to locu12[ipiv - 1]
l21 = tmp[locl21[ipiv - 1] - 1] / u11;
// l21 is the ratio of tmp element at locl21[ipiv - 1] to u11
u22 = tmp[locu22[ipiv - 1] - 1] - u12 * l21;
// u22 is computed using elements from tmp array and u12, l21
xswap = xswpiv[ipiv - 1];
// xswap indicates whether to swap elements in solution vector
bswap = bswpiv[ipiv - 1];
// bswap indicates whether to swap elements in right-hand side vector
if (abs(u22) <= smin) {
// If absolute value of u22 is less than or equal to smin
*info = 1;
// Set info to 1 indicating a pivot less than smin was found
u22 = smin;
// Adjust u22 to be at least smin
}
if (bswap) {
// If bswap is true
temp = btmp[1];
// Store btmp[1] in temp
btmp[1] = btmp[0] - l21 * temp;
// Update btmp[1] using the solution for l21 and temp
btmp[0] = temp;
// Restore original btmp[0] using temp
} else {
// If bswap is false
btmp[1] -= l21 * btmp[0];
// Update btmp[1] using the solution for l21
}
*scale = 1.;
// Initialize scaling factor to 1
if (smlnum * 2. * abs(btmp[1]) > abs(u22) || smlnum * 2. * abs(btmp[0]) > abs(u11)) {
// If the scaling condition is met
/* Computing MAX */
d__1 = abs(btmp[0]), d__2 = abs(btmp[1]);
*scale = .5 / max(d__1,d__2);
// Compute scaling factor to avoid overflow or underflow
btmp[0] *= *scale;
btmp[1] *= *scale;
// Apply scaling to btmp array
}
x2[1] = btmp[1] / u22;
// Compute second component of solution vector x2
x2[0] = btmp[0] / u11 - u12 / u11 * x2[1];
// Compute first component of solution vector x2
if (xswap) {
// If xswap is true
temp = x2[1];
// Swap elements in solution vector
x2[1] = x2[0];
x2[0] = temp;
}
x[x_dim1 + 1] = x2[0];
// Store first component of solution vector in x array
if (*n1 == 1) {
// If n1 equals 1
x[(x_dim1 << 1) + 1] = x2[1];
// Store second component of solution vector in x array
*xnorm = (d__1 = x[x_dim1 + 1], abs(d__1)) + (d__2 = x[(x_dim1 << 1) + 1], abs(d__2));
// Compute norm of solution vector
} else {
// Otherwise
x[x_dim1 + 2] = x2[1];
// Store second component of solution vector in x array
/* Computing MAX */
d__3 = (d__1 = x[x_dim1 + 1], abs(d__1)), d__4 = (d__2 = x[x_dim1 + 2], abs(d__2));
*xnorm = max(d__3,d__4);
// Compute norm of solution vector
}
return 0;

/*
       2 by 2:
       op[TL11 TL12]*[X11 X12] +ISGN* [X11 X12]*op[TR11 TR12] = [B11 B12]
         [TL21 TL22] [X21 X22]        [X21 X22]   [TR21 TR22]   [B21 B22]

       Solve equivalent 4 by 4 system using complete pivoting.
       Set pivots less than SMIN to SMIN.
*/

L50:
/* Computing MAX */
d__5 = (d__1 = tr[tr_dim1 + 1], abs(d__1)), d__6 = (d__2 = tr[(tr_dim1 << 1) + 1], abs(d__2)), d__5 = max(d__5,d__6), d__6 = (d__3 = tr[tr_dim1 + 2], abs(d__3)), d__5 = max(d__5,d__6), d__6 = (d__4 = tr[(tr_dim1 << 1) + 2], abs(d__4));
smin = max(d__5,d__6);
// Compute maximum absolute values in tr array and assign to smin
/* Computing MAX */
d__5 = smin, d__6 = (d__1 = tl[tl_dim1 + 1], abs(d__1)), d__5 = max(d__5, d__6), d__6 = (d__2 = tl[(tl_dim1 << 1) + 1], abs(d__2)), d__5 = max(d__5,d__6), d__6 = (d__3 = tl[tl_dim1 + 2], abs(d__3)), d__5 = max(d__5,d__6), d__6 = (d__4 = tl[(tl_dim1 << 1) + 2], abs(d__4));
smin = max(d__5,d__6);
// Compute maximum absolute values in tl array and update smin
/* Computing MAX */
d__1 = eps * smin;
smin = max(d__1,smlnum);
// Compute new value for smin based on eps and smlnum
btmp[0] = 0.;
// Initialize btmp[0] to zero
dcopy_(&c__16, btmp, &c__0, t16, &c__1);
// Copy elements from btmp to t16 array
t16[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
t16[5] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];
t16[10] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];
t16[15] = tl[(tl_dim1 << 1) + 2] + sgn * tr[(tr_dim1 << 1) + 2];
// Compute elements of t16 array based on tl, tr, and sgn values
if (*ltranl) {
// If ltranl is true
t16[4] = tl[tl_dim1 + 2];
t16[1] = tl[(tl_dim1 << 1) + 1];
t16[14] = tl[tl_dim1 + 2];
t16[11] = tl[(tl_dim1 << 1) + 1];
} else {
// Otherwise
t16[4] = tl[(tl_dim1 << 1) + 1];
    # 将数组 tl 中索引为 tl_dim1 + 2 的元素赋值给 t16 数组的第二个位置
    t16[1] = tl[tl_dim1 + 2];
    # 将数组 tl 中索引为 (tl_dim1 << 1) + 1 的元素赋值给 t16 数组的第十五个位置
    t16[14] = tl[(tl_dim1 << 1) + 1];
    # 将数组 tl 中索引为 tl_dim1 + 2 的元素再次赋值给 t16 数组的第十二个位置
    t16[11] = tl[tl_dim1 + 2];
    }
    # 如果 *ltranr 为真（非零），执行以下代码块
    if (*ltranr) {
    # 将 sgn 乘以 tr 中索引为 (tr_dim1 << 1) + 1 的元素赋值给 t16 数组的第九个位置
    t16[8] = sgn * tr[(tr_dim1 << 1) + 1];
    # 将 sgn 乘以 tr 中索引为 (tr_dim1 << 1) + 1 的元素赋值给 t16 数组的第十四个位置
    t16[13] = sgn * tr[(tr_dim1 << 1) + 1];
    # 将 sgn 乘以 tr 中索引为 tr_dim1 + 2 的元素赋值给 t16 数组的第三个位置
    t16[2] = sgn * tr[tr_dim1 + 2];
    # 将 sgn 乘以 tr 中索引为 tr_dim1 + 2 的元素赋值给 t16 数组的第八个位置
    t16[7] = sgn * tr[tr_dim1 + 2];
    } else {
    # 如果 *ltranr 为假（零），执行以下代码块
    # 将 sgn 乘以 tr 中索引为 tr_dim1 + 2 的元素赋值给 t16 数组的第九个位置
    t16[8] = sgn * tr[tr_dim1 + 2];
    # 将 sgn 乘以 tr 中索引为 tr_dim1 + 2 的元素赋值给 t16 数组的第十四个位置
    t16[13] = sgn * tr[tr_dim1 + 2];
    # 将 sgn 乘以 tr 中索引为 (tr_dim1 << 1) + 1 的元素赋值给 t16 数组的第三个位置
    t16[2] = sgn * tr[(tr_dim1 << 1) + 1];
    # 将 sgn 乘以 tr 中索引为 (tr_dim1 << 1) + 1 的元素赋值给 t16 数组的第八个位置
    t16[7] = sgn * tr[(tr_dim1 << 1) + 1];
    }
    # 将数组 b 中索引为 b_dim1 + 1 的元素赋值给 btmp 数组的第一个位置
    btmp[0] = b[b_dim1 + 1];
    # 将数组 b 中索引为 b_dim1 + 2 的元素赋值给 btmp 数组的第二个位置
    btmp[1] = b[b_dim1 + 2];
    # 将数组 b 中索引为 (b_dim1 << 1) + 1 的元素赋值给 btmp 数组的第三个位置
    btmp[2] = b[(b_dim1 << 1) + 1];
    # 将数组 b 中索引为 (b_dim1 << 1) + 2 的元素赋值给 btmp 数组的第四个位置
    btmp[3] = b[(b_dim1 << 1) + 2];
/*     Perform elimination */

/* 循环i__从1到3，执行消元操作 */
    for (i__ = 1; i__ <= 3; ++i__) {
/* 初始化xmax为0 */
    xmax = 0.;
/* 循环ip从i__到4 */
    for (ip = i__; ip <= 4; ++ip) {
/* 循环jp从i__到4 */
        for (jp = i__; jp <= 4; ++jp) {
/* 检查t16[ip + (jp << 2) - 5]的绝对值是否大于等于xmax，并更新xmax和ipsv、jpsv */
        if ((d__1 = t16[ip + (jp << 2) - 5], abs(d__1)) >= xmax) {
            xmax = (d__1 = t16[ip + (jp << 2) - 5], abs(d__1));
            ipsv = ip;
            jpsv = jp;
        }
/* L60: */
        }
/* L70: */
    }
/* 如果ipsv不等于i__，则交换t16中ipsv行和i__行的数据 */
    if (ipsv != i__) {
        dswap_(&c__4, &t16[ipsv - 1], &c__4, &t16[i__ - 1], &c__4);
        temp = btmp[i__ - 1];
        btmp[i__ - 1] = btmp[ipsv - 1];
        btmp[ipsv - 1] = temp;
    }
/* 如果jpsv不等于i__，则交换t16中jpsv列和i__列的数据 */
    if (jpsv != i__) {
        dswap_(&c__4, &t16[(jpsv << 2) - 4], &c__1, &t16[(i__ << 2) - 4],
            &c__1);
    }
/* 记录第i__次消元的jpsv */
    jpiv[i__ - 1] = jpsv;
/* 如果t16[i__ + (i__ << 2) - 5]的绝对值小于smin，则设置info为1，并将其设置为smin */
    if ((d__1 = t16[i__ + (i__ << 2) - 5], abs(d__1)) < smin) {
        *info = 1;
        t16[i__ + (i__ << 2) - 5] = smin;
    }
/* 对每一行j大于i__的部分进行归一化操作，并更新btmp和t16矩阵 */
    for (j = i__ + 1; j <= 4; ++j) {
        t16[j + (i__ << 2) - 5] /= t16[i__ + (i__ << 2) - 5];
        btmp[j - 1] -= t16[j + (i__ << 2) - 5] * btmp[i__ - 1];
        for (k = i__ + 1; k <= 4; ++k) {
        t16[j + (k << 2) - 5] -= t16[j + (i__ << 2) - 5] * t16[i__ + (
            k << 2) - 5];
/* L80: */
        }
/* L90: */
    }
/* L100: */
    }
/* 如果t16[15]的绝对值小于smin，则将其设置为smin */
    if (abs(t16[15]) < smin) {
    t16[15] = smin;
    }
/* 初始化scale为1. */
    *scale = 1.;
/* 如果某个元素的绝对值小于一定阈值，则对btmp进行缩放，并更新scale */
    if (smlnum * 8. * abs(btmp[0]) > abs(t16[0]) || smlnum * 8. * abs(btmp[1])
         > abs(t16[5]) || smlnum * 8. * abs(btmp[2]) > abs(t16[10]) ||
        smlnum * 8. * abs(btmp[3]) > abs(t16[15])) {
/* 计算绝对值最大的btmp元素，并根据其缩放t16矩阵和btmp */
/* Computing MAX */
    d__1 = abs(btmp[0]), d__2 = abs(btmp[1]), d__1 = max(d__1,d__2), d__2
        = abs(btmp[2]), d__1 = max(d__1,d__2), d__2 = abs(btmp[3]);
    *scale = .125 / max(d__1,d__2);
    btmp[0] *= *scale;
    btmp[1] *= *scale;
    btmp[2] *= *scale;
    btmp[3] *= *scale;
    }
/* 对每一行进行回代，计算解x，并计算x的范数 */
    for (i__ = 1; i__ <= 4; ++i__) {
    k = 5 - i__;
    temp = 1. / t16[k + (k << 2) - 5];
    tmp[k - 1] = btmp[k - 1] * temp;
    for (j = k + 1; j <= 4; ++j) {
        tmp[k - 1] -= temp * t16[k + (j << 2) - 5] * tmp[j - 1];
/* L110: */
    }
/* L120: */
    }
/* 根据jpiv数组重新排列解tmp */
    for (i__ = 1; i__ <= 3; ++i__) {
    if (jpiv[4 - i__ - 1] != 4 - i__) {
        temp = tmp[4 - i__ - 1];
        tmp[4 - i__ - 1] = tmp[jpiv[4 - i__ - 1] - 1];
        tmp[jpiv[4 - i__ - 1] - 1] = temp;
    }
/* L130: */
    }
/* 将解tmp复制到输出数组x中 */
    x[x_dim1 + 1] = tmp[0];
    x[x_dim1 + 2] = tmp[1];
    x[(x_dim1 << 1) + 1] = tmp[2];
    x[(x_dim1 << 1) + 2] = tmp[3];
/* Computing MAX */
/* 计算x的范数 */
    d__1 = abs(tmp[0]) + abs(tmp[2]), d__2 = abs(tmp[1]) + abs(tmp[3]);
    *xnorm = max(d__1,d__2);
/* 返回0，表示正常结束 */
    return 0;

/*     End of DLASY2 */

} /* dlasy2_ */

/* Subroutine */ int dlatrd_(char *uplo, integer *n, integer *nb, doublereal *
    a, integer *lda, doublereal *e, doublereal *tau, doublereal *w,
    integer *ldw)
{
    /* System generated locals */
/* 自动产生的本地变量 */
    integer a_dim1, a_offset, w_dim1, w_offset, i__1, i__2, i__3;

    /* Local variables */
/* 本地变量 */
    static integer i__, iw;
    # 外部函数声明，用于计算两个向量的内积
    extern doublereal ddot_(integer *, doublereal *, integer *, doublereal *,
        integer *);

    # 静态变量声明，用于存储一个标量 alpha
    static doublereal alpha;

    # 外部子程序声明，用于向量的按比例缩放
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);

    # 外部逻辑函数声明，用于比较两个字符是否相同
    extern logical lsame_(char *, char *);

    # 外部子程序声明，用于矩阵向量乘法
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *);

    # 外部子程序声明，用于向量的按比例相加
    extern /* Subroutine */ int daxpy_(integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);

    # 外部子程序声明，用于对称矩阵向量乘法
    extern /* Subroutine */ int dsymv_(char *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *);

    # 外部子程序声明，用于生成 Householder 向量
    extern /* Subroutine */ int dlarfg_(integer *, doublereal *, doublereal *, integer *,
         doublereal *);
# LAPACK 辅助例程（版本 3.2）
# LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。
# 2006年11月

# 函数目的
# DLATRD 将实对称矩阵 A 的最后 NB 行和列通过正交相似变换 Q' * A * Q 变换为对称三对角形式，并返回变换未约化部分所需的矩阵 V 和 W。

# 若 UPLO = 'U'，DLATRD 将矩阵的最后 NB 行和列进行约化，其中提供了上三角部分；
# 若 UPLO = 'L'，DLATRD 将矩阵的前 NB 行和列进行约化，其中提供了下三角部分。

# 这是 DSYTRD 调用的辅助例程。

# 参数说明
# UPLO（输入）：字符*1，指定对称矩阵 A 的上三角部分或下三角部分的存储方式：
#             = 'U'：上三角
#             = 'L'：下三角
# N（输入）：整数，矩阵 A 的阶数。
# NB（输入）：整数，要约化的行和列数。
# A（输入/输出）：双精度数组，维度为 (LDA,N)。
#             输入时，对称矩阵 A。如果 UPLO = 'U'，A 的前 n×n 上三角部分包含矩阵 A 的上三角部分，严格下三角部分未引用。
#             如果 UPLO = 'L'，A 的前 n×n 下三角部分包含矩阵 A 的下三角部分，严格上三角部分未引用。
#             输出时：
#             若 UPLO = 'U'，最后 NB 列已约化为三对角形式，对角元素覆盖 A 的对角元素；数组 TAU 中的元素表示正交矩阵 Q，作为一系列反射变换的乘积。
#             若 UPLO = 'L'，前 NB 列已约化为三对角形式，对角元素覆盖 A 的对角元素；数组 TAU 中的元素表示正交矩阵 Q，作为一系列反射变换的乘积。
#             更多细节请参见下文。
# LDA（输入）：整数，数组 A 的领先维度。LDA >= max(1,N)。
# E（输出）：双精度数组，维度为 (N-1)。
#             若 UPLO = 'U'，E(n-nb:n-1) 包含约化矩阵最后 NB 列的超对角元素。
#             若 UPLO = 'L'，E(1:nb) 包含约化矩阵前 NB 列的次对角元素。
    TAU     (output) DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            存储初等反射器的标量因子，如果 UPLO = 'U'，则存储在 TAU(n-nb:n-1) 中，如果 UPLO = 'L'，则存储在 TAU(1:nb) 中。参见详细说明。

    W       (output) DOUBLE PRECISION array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            更新矩阵 A 的未约化部分所需的 n-by-nb 矩阵 W。

    LDW     (input) INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            数组 W 的主维度。LDW 必须满足 LDW >= max(1,N)。

    Further Details
    ===============

    If UPLO = 'U', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(n) H(n-1) . . . H(n-nb+1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
    and tau in TAU(i-1).

    If UPLO = 'L', the matrix Q is represented as a product of elementary
    reflectors

       Q = H(1) H(2) . . . H(nb).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
    and tau in TAU(i).

    The elements of the vectors v together form the n-by-nb matrix V
    which is needed, with W, to apply the transformation to the unreduced
    part of the matrix, using a symmetric rank-2k update of the form:
    A := A - V*W' - W*V'.
    向量 v 的元素共同形成了 n-by-nb 矩阵 V，与矩阵 W 一起用于对矩阵的未约化部分施加变换，使用对称秩为 2k 的更新形式：A := A - V*W' - W*V'。

    The contents of A on exit are illustrated by the following examples
    with n = 5 and nb = 2:
    离开时，矩阵 A 的内容如下示例所示，其中 n = 5，nb = 2：

    if UPLO = 'U':                       if UPLO = 'L':

      (  a   a   a   v4  v5 )              (  d                  )
      (      a   a   v4  v5 )              (  1   d              )
      (          a   1   v5 )              (  v1  1   a          )
      (              d   1  )              (  v1  v2  a   a      )
      (                  d  )              (  v1  v2  a   a   a  )

    where d denotes a diagonal element of the reduced matrix, a denotes
    an element of the original matrix that is unchanged, and vi denotes
    an element of the vector defining H(i).
    其中 d 表示约化矩阵的对角线元素，a 表示原始矩阵中未改变的元素，vi 表示定义 H(i) 的向量的元素。

    =====================================================================


       Quick return if possible
       如果可能，快速返回
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --e;
    --tau;
    w_dim1 = *ldw;
    w_offset = 1 + w_dim1;
    w -= w_offset;

    /* Function Body */
    if (*n <= 0) {
        return 0;
    }

    if (lsame_(uplo, "U")) {

        /* Reduce last NB columns of upper triangle */

        i__1 = *n - *nb + 1;
        for (i__ = *n; i__ >= i__1; --i__) {
            iw = i__ - *n + *nb;
            if (i__ < *n) {

                /* Update A(1:i,i) */

                i__2 = *n - i__;
                dgemv_("No transpose", &i__, &i__2, &c_b151, &a[(i__ + 1) *
                    a_dim1 + 1], lda, &w[i__ + (iw + 1) * w_dim1], ldw, &
                    c_b15, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = *n - i__;
                dgemv_("No transpose", &i__, &i__2, &c_b151, &w[(iw + 1) *
                    w_dim1 + 1], ldw, &a[i__ + (i__ + 1) * a_dim1], lda, &
                    c_b15, &a[i__ * a_dim1 + 1], &c__1);
            }
            if (i__ > 1) {

                /* Generate elementary reflector H(i) to annihilate
                   A(1:i-2,i) */

                i__2 = i__ - 1;
                dlarfg_(&i__2, &a[i__ - 1 + i__ * a_dim1], &a[i__ * a_dim1 +
                    1], &c__1, &tau[i__ - 1]);
                e[i__ - 1] = a[i__ - 1 + i__ * a_dim1];
                a[i__ - 1 + i__ * a_dim1] = 1.;

                /* Compute W(1:i-1,i) */

                i__2 = i__ - 1;
                dsymv_("Upper", &i__2, &c_b15, &a[a_offset], lda, &a[i__ *
                    a_dim1 + 1], &c__1, &c_b29, &w[iw * w_dim1 + 1], &
                    c__1);
                if (i__ < *n) {
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    dgemv_("Transpose", &i__2, &i__3, &c_b15, &w[(iw + 1) *
                        w_dim1 + 1], ldw, &a[i__ * a_dim1 + 1], &c__1, &
                        c_b29, &w[i__ + 1 + iw * w_dim1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[(i__ + 1)
                         * a_dim1 + 1], lda, &w[i__ + 1 + iw * w_dim1], &
                        c__1, &c_b15, &w[iw * w_dim1 + 1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
                        a_dim1 + 1], lda, &a[i__ * a_dim1 + 1], &c__1, &
                        c_b29, &w[i__ + 1 + iw * w_dim1], &c__1);
                    i__2 = i__ - 1;
                    i__3 = *n - i__;
                    dgemv_("No transpose", &i__2, &i__3, &c_b151, &w[(iw + 1)
                        * w_dim1 + 1], ldw, &w[i__ + 1 + iw * w_dim1], &
                        c__1, &c_b15, &w[iw * w_dim1 + 1], &c__1);
                }
                i__2 = i__ - 1;
                dscal_(&i__2, &tau[i__ - 1], &w[iw * w_dim1 + 1], &c__1);
                i__2 = i__ - 1;
                alpha = tau[i__ - 1] * -.5 * ddot_(&i__2, &w[iw * w_dim1 + 1],
                     &c__1, &a[i__ * a_dim1 + 1], &c__1);
                i__2 = i__ - 1;
                daxpy_(&i__2, &alpha, &a[i__ * a_dim1 + 1], &c__1, &w[iw *
                    w_dim1 + 1], &c__1);
            }
        }
    } else {

        /* Reduce first NB columns of lower triangle */

        i__1 = *nb;


注释：
    # 循环语句，初始化变量 i__ 为 1，每次迭代增加 1，直到达到 i__1 的值为止
    for (i__ = 1; i__ <= i__1; ++i__) {
/*
        Update A(i:n,i
    # 外部声明一个名为 dgemv_ 的子例程（函数），
    # 它接受多个参数，包括字符、整数和双精度浮点数数组，
    # 并计算一个双精度浮点数的向量乘法。
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *);

    # 静态变量声明：逻辑类型的变量 upper，用于标记矩阵是否为上三角形式。
    static logical upper;

    # 外部声明一个名为 xerbla_ 的子例程（函数），
    # 接受一个字符和一个整数参数，用于处理错误信息。
    extern /* Subroutine */ int xerbla_(char *, integer *);
/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAUU2 computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the unblocked form of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/
    /* Parameter adjustments */
    // 计算 A 数组的偏移量
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    // 将 INFO 初始化为 0
    *info = 0;
    // 判断 UPLO 参数是否为 'U' 或 'L'
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        // 若 UPLO 参数不合法则设置 INFO 为 -1
        *info = -1;
    } else if (*n < 0) {
        // 若 N 参数不合法则设置 INFO 为 -2
        *info = -2;
    } else if (*lda < max(1,*n)) {
        // 若 LDA 参数不合法则设置 INFO 为 -4
        *info = -4;
    }
    // 若 INFO 不为 0，则调用 XERBLA 函数报错并返回
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DLAUU2", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 若 N 为 0，则直接返回
    if (*n == 0) {
        return 0;
    }

    // 若上三角形式为 true
    if (upper) {

/*        Compute the product U * U'. */

    i__1 = *n;
    // 对每一列进行处理
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 取出对角线元素
        aii = a[i__ + i__ * a_dim1];
        // 若当前行小于 N，则计算特定的双精度点积
        if (i__ < *n) {
        i__2 = *n - i__ + 1;
        a[i__ + i__ * a_dim1] = ddot_(&i__2, &a[i__ + i__ * a_dim1],
            lda, &a[i__ + i__ * a_dim1], lda);
        i__2 = i__ - 1;
        i__3 = *n - i__;
        // 使用 DGEMV 函数计算向量-矩阵乘积
        dgemv_("No transpose", &i__2, &i__3, &c_b15, &a[(i__ + 1) *
            a_dim1 + 1], lda, &a[i__ + (i__ + 1) * a_dim1], lda, &
            aii, &a[i__ * a_dim1 + 1], &c__1);
        } else {
        // 若当前行等于 N，则使用 DSCAL 函数进行标量-向量乘积
        dscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
        }
/* L10: */
    }

    } else {

/*        Compute the product L' * L. */

    i__1 = *n;
    // 对每一列进行处理
    for (i__ = 1; i__ <= i__1; ++i__) {
        // 取出对角线元素
        aii = a[i__ + i__ * a_dim1];
        // 若当前行小于 N，则计算特定的双精度点积
        if (i__ < *n) {
        i__2 = *n - i__ + 1;
        a[i__ + i__ * a_dim1] = ddot_(&i__2, &a[i__ + i__ * a_dim1],
            lda, &a[i__ + i__ * a_dim1], lda);
        i__2 = i__ - 1;
        i__3 = *n - i__;
        // 使用 DGEMV 函数计算向量-矩阵乘积，这里使用转置
        dgemv_("Transpose", &i__3, &i__2, &c_b15, &a[i__ + 1 + i__ * a_dim1], lda,
            &a[i__ + (i__ + 1) * a_dim1], lda, &aii, &a[i__ * a_dim1 + 1], &c__1);
        } else {
        // 若当前行等于 N，则使用 DSCAL 函数进行标量-向量乘积
        dscal_(&i__, &aii, &a[i__ * a_dim1 + 1], &c__1);
        }
/* L20: */
    }

    }
    for (i__ = 1; i__ <= i__1; ++i__) {
        # 获取当前主元素 aii = a[i__ + i__ * a_dim1]
        aii = a[i__ + i__ * a_dim1];
        # 如果 i__ 小于总元素数 *n
        if (i__ < *n) {
            # 计算剩余元素个数 i__2 = *n - i__ + 1
            i__2 = *n - i__ + 1;
            # 计算 a[i__ + i__ * a_dim1] 内积 a[i__ + i__ * a_dim1]
            a[i__ + i__ * a_dim1] = ddot_(&i__2, &a[i__ + i__ * a_dim1], &
                c__1, &a[i__ + i__ * a_dim1], &c__1);
            # 计算矩阵乘法 dgemv_
            i__2 = *n - i__;
            i__3 = i__ - 1;
            dgemv_("Transpose", &i__2, &i__3, &c_b15, &a[i__ + 1 + a_dim1]
                , lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &aii, &a[
                i__ + a_dim1], lda);
        } else {
            # 执行向量乘法 dscal_
            dscal_(&i__, &aii, &a[i__ + a_dim1], lda);
        }
    }


注释：
这段代码是一个循环，用于对矩阵 `a` 进行对角线元素的处理。根据 `i__` 的值，执行不同的操作：如果 `i__` 小于总元素数 `*n`，则进行内积和矩阵乘法；否则进行向量乘法。
/* L20: */
    }
    }

    return 0;

/*     End of DLAUU2 */

} /* dlauu2_ */

/* Subroutine */ int dlauum_(char *uplo, integer *n, doublereal *a, integer *
    lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, ib, nb;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dtrmm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);
    static logical upper;
    extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         integer *), dlauu2_(char *, integer *,
        doublereal *, integer *, integer *), xerbla_(char *,
        integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);


/*
    -- LAPACK auxiliary routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DLAUUM computes the product U * U' or L' * L, where the triangular
    factor U or L is stored in the upper or lower triangular part of
    the array A.

    If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
    overwriting the factor U in A.
    If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
    overwriting the factor L in A.

    This is the blocked form of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the triangular factor U or L.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U';
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L' * L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */


注释：
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;


    // 设置第一维度的尺寸为指针 lda 所指向的值
    a_dim1 = *lda;
    // 计算偏移量，用于从一维数组 a 访问二维数组的起始位置
    a_offset = 1 + a_dim1;
    // 调整指针 a，使其指向二维数组的起始位置
    a -= a_offset;



    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
    *info = -1;
    } else if (*n < 0) {
    *info = -2;
    } else if (*lda < max(1,*n)) {
    *info = -4;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DLAUUM", &i__1);
    return 0;
    }


    // 初始化 info 指向的值为 0
    *info = 0;
    // 判断 uplo 是否为 "U" 或 "L"，并赋值给 upper
    upper = lsame_(uplo, "U");
    // 如果 uplo 不是 "U" 也不是 "L"，将 info 设置为 -1
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {  // 如果 n 小于 0，将 info 设置为 -2
        *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 1 和 n 中的较大者，将 info 设置为 -4
        *info = -4;
    }
    // 如果 info 不等于 0，即有错误发生
    if (*info != 0) {
        // 将 -info 作为参数传递给错误处理函数 xerbla_
        i__1 = -(*info);
        xerbla_("DLAUUM", &i__1);
        // 返回 0 表示函数执行失败
        return 0;
    }
/*     Quick return if possible */

    if (*n == 0) {
    return 0;
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "DLAUUM", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (
        ftnlen)1);
    // 调用外部函数ilaenv_()获取当前环境下的块大小nb，用于后续的分块计算

    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code */

    dlauu2_(uplo, n, &a[a_offset], lda, info);
    // 使用非分块代码dlauu2_()计算，因为块大小nb不适合进行分块计算
    } else {

/*        Use blocked code */

    if (upper) {

/*           Compute the product U * U'. */

        i__1 = *n;
        i__2 = nb;
        for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
        i__3 = nb, i__4 = *n - i__ + 1;
        ib = min(i__3,i__4);
        // 计算当前块的大小ib，保证不超过剩余未处理部分的大小

        i__3 = i__ - 1;
        dtrmm_("Right", "Upper", "Transpose", "Non-unit", &i__3, &ib,
            &c_b15, &a[i__ + i__ * a_dim1], lda, &a[i__ * a_dim1
            + 1], lda)
            ;
        // 调用dtrmm_()进行矩阵乘法运算，右侧乘法，计算 U * U' 的部分
        dlauu2_("Upper", &ib, &a[i__ + i__ * a_dim1], lda, info);
        // 调用dlauu2_()对上三角矩阵进行紧致化处理

        if (i__ + ib <= *n) {
            i__3 = i__ - 1;
            i__4 = *n - i__ - ib + 1;
            dgemm_("No transpose", "Transpose", &i__3, &ib, &i__4, &
                c_b15, &a[(i__ + ib) * a_dim1 + 1], lda, &a[i__ +
                (i__ + ib) * a_dim1], lda, &c_b15, &a[i__ *
                a_dim1 + 1], lda);
            // 调用dgemm_()进行矩阵乘法运算，计算更新矩阵的其余部分
            i__3 = *n - i__ - ib + 1;
            dsyrk_("Upper", "No transpose", &ib, &i__3, &c_b15, &a[
                i__ + (i__ + ib) * a_dim1], lda, &c_b15, &a[i__ +
                i__ * a_dim1], lda);
            // 调用dsyrk_()进行矩阵乘法运算，更新对称部分
        }
/* L10: */
        }
    } else {

/*           Compute the product L' * L. */

        i__2 = *n;
        i__1 = nb;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {
/* Computing MIN */
        i__3 = nb, i__4 = *n - i__ + 1;
        ib = min(i__3,i__4);
        // 计算当前块的大小ib，保证不超过剩余未处理部分的大小

        i__3 = i__ - 1;
        dtrmm_("Left", "Lower", "Transpose", "Non-unit", &ib, &i__3, &
            c_b15, &a[i__ + i__ * a_dim1], lda, &a[i__ + a_dim1],
            lda);
        // 调用dtrmm_()进行矩阵乘法运算，左侧乘法，计算 L' * L 的部分
        dlauu2_("Lower", &ib, &a[i__ + i__ * a_dim1], lda, info);
        // 调用dlauu2_()对下三角矩阵进行紧致化处理

        if (i__ + ib <= *n) {
            i__3 = i__ - 1;
            i__4 = *n - i__ - ib + 1;
            dgemm_("Transpose", "No transpose", &ib, &i__3, &i__4, &
                c_b15, &a[i__ + ib + i__ * a_dim1], lda, &a[i__ +
                ib + a_dim1], lda, &c_b15, &a[i__ + a_dim1], lda);
            // 调用dgemm_()进行矩阵乘法运算，计算更新矩阵的其余部分
            i__3 = *n - i__ - ib + 1;
            dsyrk_("Lower", "Transpose", &ib, &i__3, &c_b15, &a[i__ +
                ib + i__ * a_dim1], lda, &c_b15, &a[i__ + i__ *
                a_dim1], lda);
            // 调用dsyrk_()进行矩阵乘法运算，更新对称部分
        }
/* L20: */
        }
    }
    }

    return 0;

/*     End of DLAUUM */

} /* dlauum_ */

/* Subroutine */ int dorg2r_(integer *m, integer *n, integer *k, doublereal *
    a, integer *lda, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dlarf_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);



    # 定义外部子程序声明，声明了三个外部函数：dscal、dlarf 和 xerbla
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *),
        # dscal 函数原型：参数为整数指针、双精度浮点数指针和整数指针，返回值为整型
        dlarf_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, doublereal *),
        # dlarf 函数原型：参数为字符指针、整数指针、整数指针、双精度浮点数指针、整数指针、双精度浮点数指针、双精度浮点数指针、整数指针和双精度浮点数指针，返回值为整型
        xerbla_(char *, integer *);
        # xerbla 函数原型：参数为字符指针和整数指针，返回值为整型



        # 注释：此处的 extern 关键字用于声明这些函数是在其他地方实现的，不是在当前文件中定义的
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORG2R generates an m by n real matrix Q with orthonormal columns,
    which is defined as the first n columns of a product of k elementary
    reflectors of order m

          Q  =  H(1) H(2) . . . H(k)

    as returned by DGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by DGEQRF in the first k columns of its array
            argument A.
            On exit, the m-by-n matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.

    WORK    (workspace) DOUBLE PRECISION array, dimension (N)

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    =====================================================================


       Test the input arguments
*/

    /* Parameter adjustments */
    // 计算 A 数组中元素的偏移量
    a_dim1 = *lda;
    // a 数组的起始偏移
    a_offset = 1 + a_dim1;
    // a 指针前移
    a -= a_offset;
    // tau 指针前移
    --tau;
    // work 指针前移
    --work;

    /* Function Body */
    // 设置 INFO 初始值为 0
    *info = 0;
    // 检查参数合法性
    if (*m < 0) {
        // 如果 m < 0，设置 INFO 为 -1
        *info = -1;
    } else if (*n < 0 || *n > *m) {
        // 如果 n < 0 或 n > m，设置 INFO 为 -2
        *info = -2;
    } else if (*k < 0 || *k > *n) {
        // 如果 k < 0 或 k > n，设置 INFO 为 -3
        *info = -3;
    } else if (*lda < max(1,*m)) {
        // 如果 lda < max(1, m)，设置 INFO 为 -5
        *info = -5;
    }
    // 如果 INFO 不为 0，调用 xerbla_ 函数报错并返回
    if (*info != 0) {
        // 计算错误码的绝对值并调用错误处理函数 xerbla_
        i__1 = -(*info);
        xerbla_("DORG2R", &i__1);
        return 0;
    }

/*     Quick return if possible */

    // 如果 n <= 0，直接返回
    if (*n <= 0) {
        return 0;
    }

/*     Initialise columns k+1:n to columns of the unit matrix */

    // 初始化矩阵的右上角为单位阵
    i__1 = *n;
    for (j = *k + 1; j <= i__1; ++j) {
        // 初始化列 j 的上半部分为 0
        i__2 = *m;
        for (l = 1; l <= i__2; ++l) {
            a[l + j * a_dim1] = 0.;
        }
        // 对角线元素设为 1
        a[j + j * a_dim1] = 1.;
    }

    // 逐个应用每个反射变换 H(i) 到矩阵 A 的左侧
    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i) to A(i:m,i:n) from the left */

        // 如果 i < n，对角线元素设为 1
        if (i__ < *n) {
            a[i__ + i__ * a_dim1] = 1.;
            // 计算应用 H(i) 的结果到 A(i:m,i:n)
            i__1 = *m - i__ + 1;
            i__2 = *n - i__;
            dlarf_("Left", &i__1, &i__2, &a[i__ + i__ * a_dim1], &c__1, &tau[
                i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
        }
    }
    # 检查条件：如果 i__ 小于指针变量 m 指向的值
    if (i__ < *m) {
        # 计算数组剩余部分的元素个数
        i__1 = *m - i__;
        # 计算缩放因子为负的值
        d__1 = -tau[i__];
        # 调用 BLAS 库中的 dscal 函数，对数组 a 中的元素进行缩放
        # 第一个参数是剩余元素的个数，第二个参数是缩放因子，第三个参数是起始地址，第四个参数是步长
        dscal_(&i__1, &d__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
    }
    # 设置数组 a 中对角线上的元素为 1 减去 tau 中相应位置的值
    a[i__ + i__ * a_dim1] = 1. - tau[i__];
/*        Set A(1:i-1,i) to zero */

/* 
   将 A(1:i-1, i) 设置为零
   在矩阵 A 中，将第 i 列的前 i-1 行元素设为零
*/
i__1 = i__ - 1;
for (l = 1; l <= i__1; ++l) {
    a[l + i__ * a_dim1] = 0.;
/* L30: */
}

/* L40: */
}

/* 
   结束 DORG2R
*/

} /* dorg2r_ */

/* Subroutine */ int dorgbr_(char *vect, integer *m, integer *n, integer *k,
    doublereal *a, integer *lda, doublereal *tau, doublereal *work,
    integer *lwork, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/* Local variables */
static integer i__, j, nb, mn;
extern logical lsame_(char *, char *);
static integer iinfo;
static logical wantq;
extern /* Subroutine */ int xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int dorglq_(integer *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *,
    integer *), dorgqr_(integer *, integer *, integer *, doublereal *,
     integer *, doublereal *, doublereal *, integer *, integer *);
static integer lwkopt;
static logical lquery;

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DORGBR generates one of the real orthogonal matrices Q or P**T
    determined by DGEBRD when reducing a real matrix A to bidiagonal
    form: A = Q * B * P**T.  Q and P**T are defined as products of
    elementary reflectors H(i) or G(i) respectively.

    If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
    is of order M:
    if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
    columns of Q, where m >= n >= k;
    if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
    M-by-M matrix.

    If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
    is of order N:
    if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
    rows of P**T, where n >= m >= k;
    if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
    an N-by-N matrix.

    Arguments
    =========

    VECT    (input) CHARACTER*1
            Specifies whether the matrix Q or the matrix P**T is
            required, as defined in the transformation applied by DGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**T.

    M       (input) INTEGER
            The number of rows of the matrix Q or P**T to be returned.
            M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q or P**T to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
*/
    ! 测试输入参数

    K       (input) INTEGER
            如果 VECT = 'Q'，原始 M-by-K 矩阵经 DGEBRD 缩减后的列数。
            如果 VECT = 'P'，原始 K-by-N 矩阵经 DGEBRD 缩减后的行数。
            K >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, DGEBRD 返回的定义 elementary reflectors 的向量。
            On exit, 返回 M-by-N 矩阵 Q 或 P**T。

    LDA     (input) INTEGER
            数组 A 的主维度。LDA >= max(1,M).

    TAU     (input) DOUBLE PRECISION array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) 必须包含 elementary reflector H(i) 或 G(i) 的标量因子，
            决定 Q 或 P**T，由 DGEBRD 在其数组参数 TAUQ 或 TAUP 返回。

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, 如果 INFO = 0，WORK(1) 返回最优 LWORK。

    LWORK   (input) INTEGER
            数组 WORK 的维度。LWORK >= max(1,min(M,N)).
            为了最佳性能，建议 LWORK >= min(M,N)*NB，其中 NB 是最优块大小。

            如果 LWORK = -1，则假定为工作空间查询；例程仅计算 WORK 数组的最优大小，
            并将此值作为 WORK 数组的第一个条目返回，并且不会因 LWORK 相关的错误消息而调用 XERBLA。

    INFO    (output) INTEGER
            = 0:  成功退出
            < 0:  如果 INFO = -i，则第 i 个参数值非法
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    wantq = lsame_(vect, "Q");  // 判断 vect 是否为 "Q"，返回结果保存在 wantq 变量中
    mn = min(*m,*n);  // 计算 m 和 n 的最小值，保存在 mn 变量中
    lquery = *lwork == -1;  // 判断是否查询工作空间大小，返回结果保存在 lquery 变量中

    // 检查输入参数是否合法
    if (! wantq && ! lsame_(vect, "P")) {
        *info = -1;  // 如果 vect 不是 "Q" 且不是 "P"，设置 info 为 -1
    } else if (*m < 0) {
        *info = -2;  // 如果 m 小于 0，设置 info 为 -2
    } else if (*n < 0 || wantq && (*n > *m || *n < min(*m,*k)) || ! wantq && (
        *m > *n || *m < min(*n,*k))) {
        *info = -3;  // 如果 n 小于 0，或者 wantq 为真且 n 大于 m 或小于 m 和 k 的最小值，或者 wantq 为假且 m 大于 n 或小于 n 和 k 的最小值，设置 info 为 -3
    } else if (*k < 0) {
        *info = -4;  // 如果 k 小于 0，设置 info 为 -4
    } else if (*lda < max(1,*m)) {
        *info = -6;  // 如果 lda 小于 max(1, m)，设置 info 为 -6
    } else if (*lwork < max(1,mn) && ! lquery) {
        *info = -9;  // 如果 lwork 小于 max(1, mn) 且不是查询工作空间大小，设置 info 为 -9
    }

    if (*info == 0) {
        if (wantq) {
            nb = ilaenv_(&c__1, "DORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);  // 根据参数调用 ilaenv 函数，确定工作空间大小，保存在 nb 变量中
        } else {
            nb = ilaenv_(&c__1, "DORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);  // 根据参数调用 ilaenv 函数，确定工作空间大小，保存在 nb 变量中
        }
        lwkopt = max(1,mn) * nb;  // 计算最优工作空间大小，保存在 lwkopt 变量中
        work[1] = (doublereal) lwkopt;  // 将最优工作空间大小保存在 work 数组的第一个位置
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORGBR", &i__1);  // 如果 info 不等于 0，调用 xerbla 函数报错并返回
        return 0;
    } else if (lquery) {
        return 0;  // 如果是查询工作空间大小，直接返回
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
        work[1] = 1.;  // 如果 m 或 n 为 0，设置 work 数组的第一个位置为 1，并直接返回
        return 0;
    }

    if (wantq) {

/*
          Form Q, determined by a call to DGEBRD to reduce an m-by-k
          matrix
*/

        if (*m >= *k) {

/*           If m >= k, assume m >= n >= k */

            dorgqr_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  // 调用 dorgqr 函数计算 Q 矩阵
        } else {

/*
             If m < k, assume m = n

             Shift the vectors which define the elementary reflectors one
             column to the right, and set the first row and column of Q
             to those of the unit matrix
*/

            for (j = *m; j >= 2; --j) {
                a[j * a_dim1 + 1] = 0.;  // 将第 j 列的第一个元素设为 0
                i__1 = *m;
                for (i__ = j + 1; i__ <= i__1; ++i__) {
                    a[i__ + j * a_dim1] = a[i__ + (j - 1) * a_dim1];  // 向右移动定义基本反射器的向量，并设置 Q 的第一行和第一列为单位矩阵
                }
            }
            a[a_dim1 + 1] = 1.;  // 设置 Q 的第一行和第一列为单位矩阵
            i__1 = *m;
            for (i__ = 2; i__ <= i__1; ++i__) {
                a[i__ + a_dim1] = 0.;  // 设置 Q 的其余部分为零
            }
            if (*m > 1) {

/*              Form Q(2:m,2:m) */

                i__1 = *m - 1;
                i__2 = *m - 1;
                i__3 = *m - 1;
                dorgqr_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
                    1], &work[1], lwork, &iinfo);  // 调用 dorgqr 函数计算 Q 的剩余部分
            }
        }
    } else {

/*
          Form P', determined by a call to DGEBRD to reduce a k-by-n
          matrix
*/

        if (*k < *n) {

/*           If k < n, assume k <= m <= n */

            dorglq_(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &
                iinfo);  // 调用 dorglq 函数计算 P' 矩阵
        } else {

/*
             If k >= n, assume m = n

             Shift the vectors which define the elementary reflectors one
             row downward, and set the first row and column of P' to
             those of the unit matrix
*/

            a[a_dim1 + 1] = 1.;  // 设置 P' 的第一行和第一列为单位矩阵
            i__1 = *n;
            for (i__ = 2; i__ <= i__1; ++i__) {
                a[i__ + a_dim1] = 0.;  // 设置 P' 的其余部分为零
            }
/* L40: */
        }
        i__1 = *n;
        for (j = 2; j <= i__1; ++j) {
        for (i__ = j - 1; i__ >= 2; --i__) {
            a[i__ + j * a_dim1] = a[i__ - 1 + j * a_dim1];
/* L50: */
        }
        a[j * a_dim1 + 1] = 0.;
/* L60: */
        }
        if (*n > 1) {

/*              Form P'(2:n,2:n) */

        i__1 = *n - 1;
        i__2 = *n - 1;
        i__3 = *n - 1;
        dorglq_(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[
            1], &work[1], lwork, &iinfo);
        }
    }
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORGBR */

} /* dorgbr_ */

/* Subroutine */ int dorghr_(integer *n, integer *ilo, integer *ihi,
    doublereal *a, integer *lda, doublereal *tau, doublereal *work,
    integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, nb, nh, iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int dorgqr_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORGHR generates a real orthogonal matrix Q which is defined as the
    product of IHI-ILO elementary reflectors of order N, as returned by
    DGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix Q. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by DGEHRD.
            On exit, the N-by-N orthogonal matrix Q.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,N).

    TAU     (input) DOUBLE PRECISION array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments


注释：

# 测试输入参数的有效性
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  /* 初始化 info 为 0 */

    nh = *ihi - *ilo;  /* 计算 nh = ihi - ilo */

    lquery = *lwork == -1;  /* 检查是否在查询最小工作空间大小 */

    if (*n < 0) {  /* 如果 n < 0，设置错误码为 -1 */
        *info = -1;
    } else if (*ilo < 1 || *ilo > max(1,*n)) {  /* 如果 ilo 不在有效范围内，设置错误码为 -2 */
        *info = -2;
    } else if (*ihi < min(*ilo,*n) || *ihi > *n) {  /* 如果 ihi 不在有效范围内，设置错误码为 -3 */
        *info = -3;
    } else if (*lda < max(1,*n)) {  /* 如果 lda 小于最大(1,n)，设置错误码为 -5 */
        *info = -5;
    } else if (*lwork < max(1,nh) && ! lquery) {  /* 如果 lwork 小于最大(1,nh) 且非查询模式，设置错误码为 -8 */
        *info = -8;
    }

    if (*info == 0) {  /* 如果没有错误，则计算所需的工作空间大小 */
        nb = ilaenv_(&c__1, "DORGQR", " ", &nh, &nh, &nh, &c_n1, (ftnlen)6, (ftnlen)1);
        lwkopt = max(1,nh) * nb;  /* 计算推荐的工作空间大小 */
        work[1] = (doublereal) lwkopt;  /* 将推荐的工作空间大小存入 work 数组 */
    }

    if (*info != 0) {  /* 如果存在错误，调用错误处理程序并返回 */
        i__1 = -(*info);
        xerbla_("DORGHR", &i__1);
        return 0;
    } else if (lquery) {  /* 如果是查询模式，直接返回 */
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {  /* 如果 n 为 0，设置工作空间大小为 1 并返回 */
        work[1] = 1.;
        return 0;
    }

/* Shift the vectors which define the elementary reflectors one
   column to the right, and set the first ilo and the last n-ihi
   rows and columns to those of the unit matrix */

    i__1 = *ilo + 1;
    for (j = *ihi; j >= i__1; --j) {  /* 循环处理每一列 */
        i__2 = j - 1;
        for (i__ = 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = 0.;  /* 将下三角部分置零 */
        }
        i__2 = *ihi;
        for (i__ = j + 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = a[i__ + (j - 1) * a_dim1];  /* 复制上三角的值到当前列 */
        }
        i__2 = *n;
        for (i__ = *ihi + 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = 0.;  /* 将超出 ihi 的部分置零 */
        }
    }

    i__1 = *ilo;
    for (j = 1; j <= i__1; ++j) {  /* 设置第 ilo 行以下为单位矩阵 */
        i__2 = *n;
        for (i__ = 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = 0.;
        }
        a[j + j * a_dim1] = 1.;  /* 主对角线为 1 */
    }

    i__1 = *n;
    for (j = *ihi + 1; j <= i__1; ++j) {  /* 设置第 ihi 行以上为单位矩阵 */
        i__2 = *n;
        for (i__ = 1; i__ <= i__2; ++i__) {
            a[i__ + j * a_dim1] = 0.;
        }
        a[j + j * a_dim1] = 1.;  /* 主对角线为 1 */
    }

    if (nh > 0) {

/*        Generate Q(ilo+1:ihi,ilo+1:ihi) */

        dorgqr_(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*ilo], &work[1], lwork, &iinfo);  /* 调用 QR 分解生成 Q 矩阵 */
    }

    work[1] = (doublereal) lwkopt;  /* 存入推荐的工作空间大小 */
    return 0;

/*     End of DORGHR */

} /* dorghr_ */

/* Subroutine */ int dorgl2_(integer *m, integer *n, integer *k, doublereal *
    a, integer *lda, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, l;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *), dlarf_(char *, integer *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORGL2 generates an m by n real matrix Q with orthonormal rows,
    which is defined as the first m rows of a product of k elementary
    reflectors of order n

          Q  =  H(k) . . . H(2) H(1)

    as returned by DGELQF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. N >= M.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by DGELQF in the first k rows of its array argument A.
            On exit, the m-by-n matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.

    WORK    (workspace) DOUBLE PRECISION array, dimension (M)

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    =====================================================================


       Test the input arguments



    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    注释：文档的作者和日期信息


    Purpose
    =======

    DORGL2 generates an m by n real matrix Q with orthonormal rows,
    which is defined as the first m rows of a product of k elementary
    reflectors of order n

          Q  =  H(k) . . . H(2) H(1)

    as returned by DGELQF.

    注释：说明了函数 DORGL2 的目的，生成一个 m 行 n 列的实矩阵 Q，其行向量正交归一，
         它定义为 n 阶 k 个初等反射器的乘积的前 m 行，这些反射器由 DGELQF 返回。

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    注释：输入参数 M，Q 矩阵的行数，必须大于等于 0。

    N       (input) INTEGER
            The number of columns of the matrix Q. N >= M.

    注释：输入参数 N，Q 矩阵的列数，必须大于等于 M。

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.

    注释：输入参数 K，定义矩阵 Q 的初等反射器数量，必须满足 M >= K >= 0。

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by DGELQF in the first k rows of its array argument A.
            On exit, the m-by-n matrix Q.

    注释：输入/输出参数 A，双精度数组，维度为 (LDA,N)。
         在输入时，每行 i 必须包含定义初等反射器 H(i) 的向量，
         即 DGELQF 返回的其数组参数 A 的前 k 行。
         在输出时，变为 m 行 n 列的矩阵 Q。

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    注释：输入参数 LDA，数组 A 的第一个维度，必须大于等于 max(1,M)。

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.

    注释：输入参数 TAU，双精度数组，维度为 (K)。
         TAU(i) 必须包含初等反射器 H(i) 的标量因子，与 DGELQF 返回的一致。

    WORK    (workspace) DOUBLE PRECISION array, dimension (M)

    注释：工作空间参数 WORK，双精度数组，维度为 (M)。

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument has an illegal value

    注释：输出参数 INFO，整数。
         = 0 表示成功退出。
         < 0 表示参数 INFO = -i，其中第 i 个参数具有非法值。

    =====================================================================


       Test the input arguments



    =====================================================================

    注释：分隔符，标识函数文档部分结束，进入输入参数检测阶段。
    /* Parameter adjustments */
    // 参数调整
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    // 函数体开始
    *info = 0;
    // 初始化 info 为 0
    if (*m < 0) {
    // 如果 m 小于 0
    *info = -1;
    // 设置 info 为 -1
    } else if (*n < *m) {
    // 否则如果 n 小于 m
    *info = -2;
    // 设置 info 为 -2
    } else if (*k < 0 || *k > *m) {
    // 否则如果 k 小于 0 或者 k 大于 m
    *info = -3;
    // 设置 info 为 -3
    } else if (*lda < max(1,*m)) {
    // 否则如果 lda 小于 1 和 m 中的最大值
    *info = -5;
    // 设置 info 为 -5
    }
    if (*info != 0) {
    // 如果 info 不为 0
    i__1 = -(*info);
    // i__1 为 -info
    xerbla_("DORGL2", &i__1);
    // 调用 xerbla 函数，处理错误信息
    return 0;
    // 返回 0
    }

/*     Quick return if possible */

    // 如果 m 小于等于 0，直接返回
    if (*m <= 0) {
    return 0;
    }

    // 如果 k 小于 m
    if (*k < *m) {

/*        Initialise rows k+1:m to rows of the unit matrix */

    // 初始化第 k+1 至 m 行为单位矩阵的行

    i__1 = *n;
    // 循环变量 j，从 1 到 n
    for (j = 1; j <= i__1; ++j) {
        // 循环变量 l，从 k+1 到 m
        i__2 = *m;
        for (l = *k + 1; l <= i__2; ++l) {
        // 将 a[l + j * a_dim1] 设为 0
        a[l + j * a_dim1] = 0.;
/* L10: */
        }
        // 如果 j 大于 k 并且小于等于 m，将 a[j + j * a_dim1] 设为 1
        if (j > *k && j <= *m) {
        a[j + j * a_dim1] = 1.;
        }
/* L20: */
    }
    }

    // 从 k 循环到 1
    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i) to A(i:m,i:n) from the right */

    // 将 H(i) 从右侧应用于 A(i:m,i:n)

    if (i__ < *n) {
        // 如果 i 小于 n
        if (i__ < *m) {
        // 如果 i 小于 m
        a[i__ + i__ * a_dim1] = 1.;
        // 将 a[i__ + i__ * a_dim1] 设为 1
        i__1 = *m - i__;
        // 计算 i__1 为 m - i
        i__2 = *n - i__ + 1;
        // 计算 i__2 为 n - i + 1
        dlarf_("Right", &i__1, &i__2, &a[i__ + i__ * a_dim1], lda, &
            tau[i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
        // 调用 dlarf 函数，对 A(i:m,i:n) 进行操作
        }
        // 计算 i__1 为 n - i
        i__1 = *n - i__;
        // 计算 d__1 为 -tau[i__]
        d__1 = -tau[i__];
        // 对 a[i__ + (i__ + 1) * a_dim1] 进行缩放
        dscal_(&i__1, &d__1, &a[i__ + (i__ + 1) * a_dim1], lda);
    }
    // 将 a[i__ + i__ * a_dim1] 设为 1 - tau[i__]
    a[i__ + i__ * a_dim1] = 1. - tau[i__];

/*        Set A(i,1:i-1) to zero */

    // 将 A(i,1:i-1) 设置为零

    // 循环变量 l，从 1 到 i-1
    i__1 = i__ - 1;
    for (l = 1; l <= i__1; ++l) {
        // 将 a[i__ + l * a_dim1] 设为 0
        a[i__ + l * a_dim1] = 0.;
/* L30: */
    }
/* L40: */
    }
    // 返回 0

/*     End of DORGL2 */

} /* dorgl2_ */

/* Subroutine */ int dorglq_(integer *m, integer *n, integer *k, doublereal *
    a, integer *lda, doublereal *tau, doublereal *work, integer *lwork,
    integer *info)
{
    // LAPACK 版本信息
    /* System generated locals */
    // 系统生成的本地变量声明
    integer a_dim1, a_offset, i__1, i__2, i__3;

    // 局部变量声明
    /* Local variables */
    static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    // 外部函数声明
    extern /* Subroutine */ int dorgl2_(integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *),
        dlarfb_(char *, char *, char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    // 外部函数声明
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    // 本地变量声明
    static integer ldwork, lwkopt;
    static logical lquery;

/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
    # 测试输入参数的合法性
    if M < 0:
        # 如果 M 小于 0，输出错误代码 -1
        return -1
    elif N < M:
        # 如果 N 小于 M，输出错误代码 -2
        return -2
    elif K < 0 or K > M:
        # 如果 K 小于 0 或者大于 M，输出错误代码 -3
        return -3
    elif LDA < max(1, M):
        # 如果 LDA 小于 max(1, M)，输出错误代码 -5
        return -5
    elif LWORK < max(1, M):
        # 如果 LWORK 小于 max(1, M)，输出错误代码 -7
        return -7
    else:
        # 如果参数检查通过，设置 WORK(1) 为 optimal LWORK
        WORK[0] = max(1, M) * NB
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "DORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    lwkopt = max(1,*m) * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
        *info = -1;
    } else if (*n < *m) {
        *info = -2;
    } else if (*k < 0 || *k > *m) {
        *info = -3;
    } else if (*lda < max(1,*m)) {
        *info = -5;
    } else if (*lwork < max(1,*m) && ! lquery) {
        *info = -8;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORGLQ", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

/*     Quick return if possible */

    if (*m <= 0) {
        work[1] = 1.;
        return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *m;
    if (nb > 1 && nb < *k) {

/*          Determine when to cross over from blocked to unblocked code.

   Computing MAX
*/
        i__1 = 0, i__2 = ilaenv_(&c__3, "DORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2);
        if (nx < *k) {

/*               Determine if workspace is large enough for blocked code. */

            ldwork = *m;
            iws = ldwork * nb;
            if (*lwork < iws) {

/*                    Not enough workspace to use optimal NB:  reduce NB and
                      determine the minimum value of NB.
*/
                nb = *lwork / ldwork;
/* Computing MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "DORGLQ", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2);
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*          Use blocked code after the last block.
            The first kk rows are handled by the block method.
*/
        ki = (*k - nx - 1) / nb * nb;
/* Computing MIN */
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2);

/*        Set A(kk+1:m,1:kk) to zero. */
        i__1 = kk;
        for (j = 1; j <= i__1; ++j) {
            i__2 = *m;
            for (i__ = kk + 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] = 0.;
/* L10: */
            }
/* L20: */
        }
    } else {
        kk = 0;
    }

/*     Use unblocked code for the last or only block. */

    if (kk < *m) {
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        dorgl2_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/*        Use blocked code */

        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3);
            if (i__ + ib <= *m) {

/*               Form the triangular factor of the block reflector
                  H = H(i) H(i+1) . . . H(i+ib-1)
*/
                i__2 = *n - i__ + 1;
                dlarft_("Forward", "Rowwise", &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1], &ldwork);
/*              Apply H' to A(i+ib:m,i:n) from the right */

/* 计算右侧矩阵 A(i+ib:m, i:n) * H'，其中 H 是一个 Householder 变换 */

i__2 = *m - i__ - ib + 1;                /* 计算子矩阵的行数 */
i__3 = *n - i__ + 1;                     /* 计算子矩阵的列数 */
dlarfb_("Right", "Transpose", "Forward", "Rowwise", &i__2, &i__3, &ib,
        &a[i__ + i__ * a_dim1], lda, &work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib + 1], &ldwork);
}

/*           Apply H' to columns i:n of current block */

/* 对当前块的列 i:n 应用 Householder 变换 H' */

i__2 = *n - i__ + 1;                    /* 计算当前块的列数 */
dorgl2_(&ib, &i__2, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__],
        &work[1], &iinfo);

/*           Set columns 1:i-1 of current block to zero */

/* 将当前块的第 1 列到第 i-1 列设置为零 */

i__2 = i__ - 1;                         /* 循环的结束条件，遍历列的索引 */
for (j = 1; j <= i__2; ++j) {
    i__3 = i__ + ib - 1;                /* 循环的结束条件，遍历行的索引 */
    for (l = i__; l <= i__3; ++l) {
        a[l + j * a_dim1] = 0.;         /* 设置当前块的元素为零 */
        /* L30: */
    }
    /* L40: */
}
/* L50: */
}

work[1] = (doublereal) iws;             /* 将工作数组的第一个元素设置为 iws */
return 0;

/*     End of DORGLQ */

} /* dorglq_ */

/* Subroutine */ int dorgqr_(integer *m, integer *n, integer *k, doublereal *
    a, integer *lda, doublereal *tau, doublereal *work, integer *lwork,
    integer *info)
{
/*     System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;

/*     Local variables */
static integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
extern /* Subroutine */ int dorg2r_(integer *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *),
    dlarfb_(char *, char *, char *, char *, integer *, integer *,
    integer *, doublereal *, integer *, doublereal *, integer *,
    doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
static integer ldwork, lwkopt;
static logical lquery;

/*
-- LAPACK routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
November 2006

Purpose
=======

DORGQR generates an M-by-N real matrix Q with orthonormal columns,
which is defined as the first N columns of a product of K elementary
reflectors of order M

Q  =  H(1) H(2) . . . H(k)

as returned by DGEQRF.

Arguments
=========

M       (input) INTEGER
The number of rows of the matrix Q. M >= 0.

N       (input) INTEGER
The number of columns of the matrix Q. M >= N >= 0.

K       (input) INTEGER
The number of elementary reflectors whose product defines the
matrix Q. N >= K >= 0.
*/
    ! Test the input arguments
    ! 测试输入参数

    IF (N.LT.0) THEN
        ! If N is negative, set INFO to -4
        ! 如果 N 小于 0，则将 INFO 设置为 -4
        INFO = -4
    ELSE IF (M.LT.N) THEN
        ! If M is less than N, set INFO to -1
        ! 如果 M 小于 N，则将 INFO 设置为 -1
        INFO = -1
    ELSE IF (LDA.LT.MAX(1,M)) THEN
        ! If LDA is less than max(1, M), set INFO to -3
        ! 如果 LDA 小于 max(1, M)，则将 INFO 设置为 -3
        INFO = -3
    ELSE IF (LWORK.LT.MAX(1,N)) THEN
        ! If LWORK is less than max(1, N), set INFO to -7
        ! 如果 LWORK 小于 max(1, N)，则将 INFO 设置为 -7
        INFO = -7
    ELSE
        ! Otherwise, set INFO to 0 indicating successful exit
        ! 否则，将 INFO 设置为 0，表示成功完成
        INFO = 0
    END IF
    /* 参数调整 */
    a_dim1 = *lda;        /* a_dim1 表示数组 a 的第一维度的大小 */
    a_offset = 1 + a_dim1; /* 计算 a 数组的偏移量 */
    a -= a_offset;         /* 调整数组 a 的起始地址 */
    --tau;                 /* 将数组 tau 的指针前移，指向正确的起始位置 */
    --work;                /* 将数组 work 的指针前移，指向正确的起始位置 */

    /* 函数主体 */
    *info = 0;             /* 将 info 设为 0，表示未发生错误 */
    nb = ilaenv_(&c__1, "DORGQR", " ", m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
                           /* 调用 ilaenv 函数获取最优块大小 nb */
    lwkopt = max(1,*n) * nb; /* 计算所需的工作空间大小 */
    work[1] = (doublereal) lwkopt; /* 将工作空间的大小存入 work 数组的第一个位置 */
    lquery = *lwork == -1; /* 检查是否仅查询工作空间需求 */

    if (*m < 0) {          /* 检查 m 的值是否合法 */
        *info = -1;
    } else if (*n < 0 || *n > *m) { /* 检查 n 的值是否合法 */
        *info = -2;
    } else if (*k < 0 || *k > *n) { /* 检查 k 的值是否合法 */
        *info = -3;
    } else if (*lda < max(1,*m)) { /* 检查 lda 的值是否合法 */
        *info = -5;
    } else if (*lwork < max(1,*n) && ! lquery) { /* 检查 lwork 的值是否合法 */
        *info = -8;
    }

    if (*info != 0) {      /* 如果出现错误，调用 xerbla 报错并返回 */
        i__1 = -(*info);
        xerbla_("DORGQR", &i__1);
        return 0;
    } else if (lquery) {   /* 如果仅查询工作空间需求，直接返回 */
        return 0;
    }

/*     如果可能的话，进行快速返回 */

    if (*n <= 0) {         /* 如果 n <= 0，直接将 work[1] 设为 1 并返回 */
        work[1] = 1.;
        return 0;
    }

    nbmin = 2;             /* 设置默认的最小块大小 */
    nx = 0;                 /* 初始化 nx */
    iws = *n;               /* 设置初始工作空间大小为 n */
    if (nb > 1 && nb < *k) { /* 如果 nb 大于 1 且小于 k */

/*
          确定从分块到非分块代码的切换点。

   计算 MAX
*/
        i__1 = 0, i__2 = ilaenv_(&c__3, "DORGQR", " ", m, n, k, &c_n1, (
            ftnlen)6, (ftnlen)1);
        nx = max(i__1,i__2); /* 计算 nx 的值 */

        if (nx < *k) {     /* 如果 nx 小于 k */

/*           检查工作空间是否足够使用分块代码。 */

            ldwork = *n;    /* 设置 ldwork 为 n */
            iws = ldwork * nb; /* 计算所需的工作空间大小 */
            if (*lwork < iws) { /* 如果实际工作空间小于所需的工作空间 */

/*
                工作空间不足以使用最优的 nb 值：减少 nb 并确定最小值 nbmin。
*/

                nb = *lwork / ldwork; /* 调整 nb 的大小 */
/* 计算 MAX */
                i__1 = 2, i__2 = ilaenv_(&c__2, "DORGQR", " ", m, n, k, &c_n1,
                     (ftnlen)6, (ftnlen)1);
                nbmin = max(i__1,i__2); /* 计算 nbmin 的值 */
            }
        }
    }

    if (nb >= nbmin && nb < *k && nx < *k) { /* 如果满足使用分块代码的条件 */

/*
          在最后一个块之后使用分块代码。
          前 kk 列通过块方法处理。
*/

        ki = (*k - nx - 1) / nb * nb; /* 计算 ki 的值 */
/* 计算 MIN */
        i__1 = *k, i__2 = ki + nb;
        kk = min(i__1,i__2); /* 计算 kk 的值 */

/*        将 A(1:kk,kk+1:n) 设为零。 */

        i__1 = *n; /* 遍历列 j */
        for (j = kk + 1; j <= i__1; ++j) {
            i__2 = kk; /* 遍历行 i */
            for (i__ = 1; i__ <= i__2; ++i__) {
                a[i__ + j * a_dim1] = 0.; /* 将 A 的对应元素设为零 */
/* L10: */
            }
/* L20: */
        }
    } else {
        kk = 0; /* 如果不满足分块代码的条件，将 kk 设为 0 */
    }

/*     对于最后一个或唯一的块使用非分块代码。 */

    if (kk < *n) { /* 如果 kk 小于 n，则使用非分块代码处理剩余部分 */
        i__1 = *m - kk;
        i__2 = *n - kk;
        i__3 = *k - kk;
        dorg2r_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &
            tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/*        使用分块代码 */

        i__1 = -nb;
        for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* 计算 MIN */
            i__2 = nb, i__3 = *k - i__ + 1;
            ib = min(i__2,i__3); /* 计算 ib 的值 */
            if (i__ + ib <= *n) {

/*
                形成块反射器的上三角因子
                H = H(i) H(i+1) . . . H(i+ib-1)
*/

                i__2 = *m - i__ + 1; /* 计算 dlarft 函数的参数 */
                dlarft_("Forward", "Columnwise", &i__2, &ib, &a[i__ + i__ *
                    a_dim1], lda, &tau[i__], &work[1], &ldwork);
/*              Apply H to A(i:m,i+ib:n) from the left */

/* 计算 i__2 和 i__3 的值 */
i__2 = *m - i__ + 1;
i__3 = *n - i__ - ib + 1;

/* 调用 dlarfb 函数，将 Householder 变换 H 应用于 A(i:m,i+ib:n) 的左侧 */
dlarfb_("Left", "No transpose", "Forward", "Columnwise", &
    i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
    1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &
    work[ib + 1], &ldwork);
}

/*           Apply H to rows i:m of current block */

/* 计算 i__2 的值 */
i__2 = *m - i__ + 1;

/* 调用 dorg2r 函数，将 Householder 变换 H 应用于当前块的第 i 行到第 m 行 */
dorg2r_(&i__2, &ib, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &
    work[1], &iinfo);

/*           Set rows 1:i-1 of current block to zero */

/* 计算 i__2 的值 */
i__2 = i__ + ib - 1;

/* 循环将当前块的第 1 到 i-1 行设置为零 */
for (j = i__; j <= i__2; ++j) {
i__3 = i__ - 1;
for (l = 1; l <= i__3; ++l) {
    a[l + j * a_dim1] = 0.;
/* L30: */
}
/* L40: */
}
/* L50: */
}
}

/* 设置 work 数组的第一个元素为 iws 的值 */
work[1] = (doublereal) iws;

/* 返回 0 表示正常结束 */

return 0;

/*     End of DORGQR */

} /* dorgqr_ */

/* Subroutine */ int dorm2l_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

/* Local variables */
static integer i__, i1, i2, i3, mi, ni, nq;
static doublereal aii;
static logical left;
extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *,
    doublereal *);
extern logical lsame_(char *, char *);
extern /* Subroutine */ int xerbla_(char *, integer *);
static logical notran;
    # K (输入) 整数
    #   定义矩阵 Q 的元素反射器数量。
    #   如果 SIDE = 'L'，则要求 M >= K >= 0；
    #   如果 SIDE = 'R'，则要求 N >= K >= 0。
    K       (input) INTEGER

    # A (输入) 双精度数组，维度为 (LDA, K)
    #   第 i 列必须包含向量，它定义了第 i 个基本反射器 H(i)。
    #   这些向量由 DGEQLF 返回到其数组参数 A 的最后 k 列中。
    #   程序会修改 A，但在退出时会恢复。
    A       (input) DOUBLE PRECISION array, dimension (LDA,K)

    # LDA (输入) 整数
    #   数组 A 的领导维度。
    #   如果 SIDE = 'L'，则要求 LDA >= max(1,M)；
    #   如果 SIDE = 'R'，则要求 LDA >= max(1,N)。
    LDA     (input) INTEGER

    # TAU (输入) 双精度数组，维度为 (K)
    #   TAU(i) 必须包含基本反射器 H(i) 的标量因子，由 DGEQLF 返回。
    TAU     (input) DOUBLE PRECISION array, dimension (K)

    # C (输入/输出) 双精度数组，维度为 (LDC, N)
    #   在输入时，矩阵 C 是 m 行 n 列。
    #   在退出时，C 被 Q*C、Q'*C、C*Q' 或 C*Q 覆盖。
    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)

    # LDC (输入) 整数
    #   数组 C 的领导维度。要求 LDC >= max(1,M)。
    LDC     (input) INTEGER

    # WORK (工作空间) 双精度数组，维度为
    #   (N) 如果 SIDE = 'L'，
    #   (M) 如果 SIDE = 'R'
    WORK    (workspace) DOUBLE PRECISION array, dimension

    # INFO (输出) 整数
    #   = 0：成功退出
    #   < 0：如果 INFO = -i，则第 i 个参数的值非法
    INFO    (output) INTEGER

    # ================================================================
    # 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

/*     NQ is the order of Q */

    if (left) {
    nq = *m;
    } else {
    nq = *n;
    }
    if (! left && ! lsame_(side, "R")) {
    *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
    *info = -2;
    } else if (*m < 0) {
    *info = -3;
    } else if (*n < 0) {
    *info = -4;
    } else if (*k < 0 || *k > nq) {
    *info = -5;
    } else if (*lda < max(1,nq)) {
    *info = -7;
    } else if (*ldc < max(1,*m)) {
    *info = -10;
    }
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DORM2L", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
    return 0;
    }

    if (left && notran || ! left && ! notran) {
    i1 = 1;
    i2 = *k;
    i3 = 1;
    } else {
    i1 = *k;
    i2 = 1;
    i3 = -1;
    }

    if (left) {
    ni = *n;
    } else {
    mi = *m;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    if (left) {

/*           H(i) is applied to C(1:m-k+i,1:n) */

        mi = *m - *k + i__;
    } else {

/*           H(i) is applied to C(1:m,1:n-k+i) */

        ni = *n - *k + i__;
    }

/*        Apply H(i) */

    aii = a[nq - *k + i__ + i__ * a_dim1];
    a[nq - *k + i__ + i__ * a_dim1] = 1.;
    dlarf_(side, &mi, &ni, &a[i__ * a_dim1 + 1], &c__1, &tau[i__], &c__[
        c_offset], ldc, &work[1]);
    a[nq - *k + i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORM2L */

} /* dorm2l_ */

/* Subroutine */ int dorm2r_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    static doublereal aii;
    static logical left;
    extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
        doublereal *, integer *, doublereal *, doublereal *, integer *,
        doublereal *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static logical notran;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======


*/
    # 测试输入参数的合法性
    IF (LSIDE .NE. 'L' .AND. LSIDE .NE. 'R') THEN
        # 如果 SIDE 参数不是 'L' 也不是 'R'，返回错误信息
        INFO = -1
    ELSE IF (LTRANS .NE. 'N' .AND. LTRANS .NE. 'T') THEN
        # 如果 TRANS 参数不是 'N' 也不是 'T'，返回错误信息
        INFO = -2
    ELSE IF (M .LT. 0) THEN
        # 如果 M 参数小于 0，返回错误信息
        INFO = -3
    ELSE IF (N .LT. 0) THEN
        # 如果 N 参数小于 0，返回错误信息
        INFO = -4
    ELSE IF (K .LT. 0 .OR. (LSIDE .EQ. 'L' .AND. K .GT. M) .OR.
         $          (LSIDE .EQ. 'R' .AND. K .GT. N)) THEN
        # 如果 K 参数小于 0 或者 (SIDE 参数是 'L' 且 K 大于 M) 或者 (SIDE 参数是 'R' 且 K 大于 N)，返回错误信息
        INFO = -5
    ELSE IF (LDA .LT. MAX(1,IF(LSIDE .EQ. 'L',M,N))) THEN
        # 如果 LDA 参数小于 max(1, 如果 SIDE 参数是 'L' 则为 M，否则为 N)，返回错误信息
        INFO = -7
    ELSE IF (LDC .LT. MAX(1,M)) THEN
        # 如果 LDC 参数小于 max(1, M)，返回错误信息
        INFO = -9
    ELSE
        # 输入参数都合法，将 INFO 设置为 0，表示成功
        INFO = 0
    END IF
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");

    /* NQ is the order of Q */
    if (left) {
        nq = *m;
    } else {
        nq = *n;
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORM2R", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        return 0;
    }

    if (left && ! notran || ! left && notran) {
        i1 = 1;
        i2 = *k;
        i3 = 1;
    } else {
        i1 = *k;
        i2 = 1;
        i3 = -1;
    }

    if (left) {
        ni = *n;
        jc = 1;
    } else {
        mi = *m;
        ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
        if (left) {
            /* H(i) is applied to C(i:m,1:n) */
            mi = *m - i__ + 1;
            ic = i__;
        } else {
            /* H(i) is applied to C(1:m,i:n) */
            ni = *n - i__ + 1;
            jc = i__;
        }

        /* Apply H(i) */
        aii = a[i__ + i__ * a_dim1];
        a[i__ + i__ * a_dim1] = 1.;
        dlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &tau[i__], &c__[
            ic + jc * c_dim1], ldc, &work[1]);
        a[i__ + i__ * a_dim1] = aii;
        /* L10: */
    }
    return 0;

    /* End of DORM2R */

} /* dorm2r_ */

/* Subroutine */ int dormbr_(char *vect, char *side, char *trans, integer *m,
    integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau,
    doublereal *c__, integer *ldc, doublereal *work, integer *lwork,
    integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2];
    char ch__1[2];

    /* Local variables */
    static integer i1, i2, nb, mi, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int dormlq_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    static logical notran;
    extern /* Subroutine */ int dormqr_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    # 定义静态变量，表示是否应用查询
    static logical applyq;
    
    # 定义静态字符数组，用于传输数据
    static char transt[1];
    
    # 定义静态整型变量，用于存储工作区大小
    static integer lwkopt;
    
    # 定义静态变量，表示是否进行查询
    static logical lquery;
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
    with
                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      P * C          C * P
    TRANS = 'T':      P**T * C       C * P**T

    Here Q and P**T are the orthogonal matrices determined by DGEBRD when
    reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
    P**T are defined as products of elementary reflectors H(i) and G(i)
    respectively.

    Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
    order of the orthogonal matrix Q or P**T that is applied.

    If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
    if nq >= k, Q = H(1) H(2) . . . H(k);
    if nq < k, Q = H(1) H(2) . . . H(nq-1).

    If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
    if k < nq, P = G(1) G(2) . . . G(k);
    if k >= nq, P = G(1) G(2) . . . G(nq-1).

    Arguments
    =========

    VECT    (input) CHARACTER*1
            = 'Q': apply Q or Q**T;
            = 'P': apply P or P**T.

    SIDE    (input) CHARACTER*1
            = 'L': apply Q, Q**T, P or P**T from the Left;
            = 'R': apply Q, Q**T, P or P**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q  or P;
            = 'T':  Transpose, apply Q**T or P**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by DGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by DGEBRD.
            K >= 0.

    A       (input) DOUBLE PRECISION array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by DGEBRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).

    TAU     (input) DOUBLE PRECISION array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by DGEBRD in the array argument TAUQ or TAUP.
"""
    ! Test the input arguments
    ! 测试输入参数的有效性

    IF (LDC < MAX(1, M)) THEN
        ! If LDC is less than max(1, M), it's an invalid argument
        ! 如果 LDC 小于 max(1, M)，则参数无效
        INFO = -4
        ! Set INFO to -4 indicating an illegal value for the 4th argument
        ! 将 INFO 设为 -4，表示第四个参数的值非法
        RETURN
        ! Exit the subroutine
        ! 退出子程序
    END IF

    IF (LWORK < 1 .AND. LWORK /= -1) THEN
        ! If LWORK is less than 1 and not equal to -1, it's an invalid argument
        ! 如果 LWORK 小于 1 且不等于 -1，则参数无效
        INFO = -6
        ! Set INFO to -6 indicating an illegal value for the 6th argument
        ! 将 INFO 设为 -6，表示第六个参数的值非法
        RETURN
        ! Exit the subroutine
        ! 退出子程序
    ELSE IF (LWORK == -1) THEN
        ! If LWORK is -1, it indicates a workspace query
        ! 如果 LWORK 等于 -1，则进行工作空间查询
        WORK(1) = MAX(1, N) * NB
        ! Set the first entry of WORK array to the optimal size
        ! 将 WORK 数组的第一个元素设置为最优大小
        RETURN
        ! Exit the subroutine
        ! 退出子程序
    END IF

    INFO = 0
    ! Set INFO to 0 indicating successful exit with no errors
    ! 将 INFO 设为 0，表示成功完成且无错误
    /* 参数调整 */
    a_dim1 = *lda;  // 将参数lda赋给a_dim1，lda表示矩阵A的第一维长度
    a_offset = 1 + a_dim1;  // 计算a的偏移量
    a -= a_offset;  // 调整矩阵A的指针，使其指向正确位置
    --tau;  // tau数组向前移动一个位置
    c_dim1 = *ldc;  // 将参数ldc赋给c_dim1，ldc表示矩阵C的第一维长度
    c_offset = 1 + c_dim1;  // 计算c的偏移量
    c__ -= c_offset;  // 调整矩阵C的指针，使其指向正确位置
    --work;  // work数组向前移动一个位置

    /* 函数体 */
    *info = 0;  // 初始化info为0，用于存储错误信息
    applyq = lsame_(vect, "Q");  // 检查vect是否等于"Q"
    left = lsame_(side, "L");  // 检查side是否等于"L"
    notran = lsame_(trans, "N");  // 检查trans是否等于"N"
    lquery = *lwork == -1;  // 检查lwork是否为-1，用于查询所需工作空间大小

    /* NQ是Q或P的阶数，NW是WORK的最小维数 */
    if (left) {
        nq = *m;  // 如果side是"L"，则nq为m
        nw = *n;  // 如果side是"L"，则nw为n
    } else {
        nq = *n;  // 如果side不是"L"，则nq为n
        nw = *m;  // 如果side不是"L"，则nw为m
    }

    if (!applyq && !lsame_(vect, "P")) {  // 如果既不应用Q也不应用P
        *info = -1;  // 设置info为-1，表示错误类型
    } else if (!left && !lsame_(side, "R")) {  // 如果既不是左侧也不是右侧
        *info = -2;  // 设置info为-2，表示错误类型
    } else if (!notran && !lsame_(trans, "T")) {  // 如果既不是不转置也不是转置
        *info = -3;  // 设置info为-3，表示错误类型
    } else if (*m < 0) {  // 如果m小于0
        *info = -4;  // 设置info为-4，表示错误类型
    } else if (*n < 0) {  // 如果n小于0
        *info = -5;  // 设置info为-5，表示错误类型
    } else if (*k < 0) {  // 如果k小于0
        *info = -6;  // 设置info为-6，表示错误类型
    } else {  // 否则
        /* 计算MAX */
        i__1 = 1, i__2 = min(nq,*k);  // 计算nq和k的最小值
        if (applyq && *lda < max(1,nq) || !applyq && *lda < max(i__1,i__2)) {  // 检查lda是否足够大
            *info = -8;  // 设置info为-8，表示错误类型
        } else if (*ldc < max(1,*m)) {  // 检查ldc是否足够大
            *info = -11;  // 设置info为-11，表示错误类型
        } else if (*lwork < max(1,nw) && !lquery) {  // 检查lwork是否足够大
            *info = -13;  // 设置info为-13，表示错误类型
        }
    }

    if (*info == 0) {  // 如果没有错误
        if (applyq) {  // 如果应用Q
            if (left) {  // 如果是左乘
                /* 拼接字符串 */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将side和trans拼接成字符串
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "DORMQR", ch__1, &i__1, n, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用ilaenv_函数获取nb
            } else {  // 如果是右乘
                /* 拼接字符串 */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将side和trans拼接成字符串
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "DORMQR", ch__1, m, &i__1, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用ilaenv_函数获取nb
            }
        } else {  // 如果应用P
            if (left) {  // 如果是左乘
                /* 拼接字符串 */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将side和trans拼接成字符串
                i__1 = *m - 1;
                i__2 = *m - 1;
                nb = ilaenv_(&c__1, "DORMLQ", ch__1, &i__1, n, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用ilaenv_函数获取nb
            } else {  // 如果是右乘
                /* 拼接字符串 */
                i__3[0] = 1, a__1[0] = side;
                i__3[1] = 1, a__1[1] = trans;
                s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 将side和trans拼接成字符串
                i__1 = *n - 1;
                i__2 = *n - 1;
                nb = ilaenv_(&c__1, "DORMLQ", ch__1, m, &i__1, &i__2, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用ilaenv_函数获取nb
            }
        }
        lwkopt = max(1,nw) * nb;  // 计算所需的最大工作空间
        work[1] = (doublereal) lwkopt;  // 将最大工作空间大小存储在work数组的第一个位置
    }

    if (*info != 0) {  // 如果有错误
        i__1 = -(*info);  // 计算info的负值
        xerbla_("DORMBR", &i__1);  // 调用xerbla_函数报告错误
        return 0;  // 返回0
    } else if (lquery) {  // 如果是查询工作空间大小
        return 0;  // 返回0
    }

    /* 如果可能，快速返回 */
    work[1] = 1.;  // 设置工作数组的第一个位置为1
    if (*m == 0 || *n == 0) {  // 如果m或n为0
        return 0;  // 返回0
    }

    if (applyq) {

        /* 应用Q */
        
        if (nq >= *k) {  // 如果nq大于等于k
/*           Q was determined by a call to DGEBRD with nq >= k */
dormqr_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
    c_offset], ldc, &work[1], lwork, &iinfo);
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    IHI-ILO elementary reflectors, as returned by DGEHRD:

    Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.

    A       (input) DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by DGEHRD.

    LDA     (input) INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.

    TAU     (input) DOUBLE PRECISION array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    # INFO (output) INTEGER
    #     = 0:  successful exit
    #     < 0:  if INFO = -i, the i-th argument had an illegal value

    # ================================================================
    # 测试输入参数
/* Parameter adjustments */
/* 调整参数 */
a_dim1 = *lda;
/* 设置矩阵 A 的第一维度长度为 lda */
a_offset = 1 + a_dim1;
/* 计算矩阵 A 的偏移量 */
a -= a_offset;
/* 对矩阵 A 进行偏移操作 */
--tau;
/* 减少数组 tau 的索引 */
c_dim1 = *ldc;
/* 设置矩阵 C 的第一维度长度为 ldc */
c_offset = 1 + c_dim1;
/* 计算矩阵 C 的偏移量 */
c__ -= c_offset;
/* 对矩阵 C 进行偏移操作 */
--work;
/* 减少数组 work 的索引 */

/* Function Body */
/* 函数体 */

*info = 0;
/* 初始化 info 为 0 */
nh = *ihi - *ilo;
/* 计算 nh，即区间 [ilo, ihi) 的长度 */
left = lsame_(side, "L");
/* 判断 side 是否为 'L' */
lquery = *lwork == -1;
/* 判断是否处于查询模式 */

/* NQ is the order of Q and NW is the minimum dimension of WORK */
/* NQ 是 Q 的阶数，NW 是 WORK 的最小维度 */

if (left) {
/* 如果 side 是 'L' */
nq = *m;
/* 设置 nq 为 m */
nw = *n;
/* 设置 nw 为 n */
} else {
/* 否则 */
nq = *n;
/* 设置 nq 为 n */
nw = *m;
/* 设置 nw 为 m */
}
if (! left && ! lsame_(side, "R")) {
/* 如果既不是 'L' 也不是 'R' */
*info = -1;
/* 设置 info 为 -1 */
} else if (! lsame_(trans, "N") && ! lsame_(trans,
    "T")) {
/* 如果 trans 既不是 'N' 也不是 'T' */
*info = -2;
/* 设置 info 为 -2 */
} else if (*m < 0) {
/* 如果 m 小于 0 */
*info = -3;
/* 设置 info 为 -3 */
} else if (*n < 0) {
/* 如果 n 小于 0 */
*info = -4;
/* 设置 info 为 -4 */
} else if (*ilo < 1 || *ilo > max(1,nq)) {
/* 如果 ilo 小于 1 或大于 max(1, nq) */
*info = -5;
/* 设置 info 为 -5 */
} else if (*ihi < min(*ilo,nq) || *ihi > nq) {
/* 如果 ihi 小于 min(ilo, nq) 或大于 nq */
*info = -6;
/* 设置 info 为 -6 */
} else if (*lda < max(1,nq)) {
/* 如果 lda 小于 max(1, nq) */
*info = -8;
/* 设置 info 为 -8 */
} else if (*ldc < max(1,*m)) {
/* 如果 ldc 小于 max(1, m) */
*info = -11;
/* 设置 info 为 -11 */
} else if (*lwork < max(1,nw) && ! lquery) {
/* 如果 lwork 小于 max(1, nw) 并且不是查询模式 */
*info = -13;
/* 设置 info 为 -13 */
}

if (*info == 0) {
/* 如果 info 为 0 */
if (left) {
/* 如果 side 是 'L' */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 调用 ilaenv 函数 */
nb = ilaenv_(&c__1, "DORMQR", ch__1, &nh, n, &nh, &c_n1, (ftnlen)
    6, (ftnlen)2);
} else {
/* 否则 */
/* Writing concatenation */
/* 拼接字符串 */
i__1[0] = 1, a__1[0] = side;
i__1[1] = 1, a__1[1] = trans;
s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
/* 调用 ilaenv 函数 */
nb = ilaenv_(&c__1, "DORMQR", ch__1, m, &nh, &nh, &c_n1, (ftnlen)
    6, (ftnlen)2);
}
lwkopt = max(1,nw) * nb;
/* 计算最优工作空间大小 */
work[1] = (doublereal) lwkopt;
/* 将最优工作空间大小存入 work 数组 */
}

if (*info != 0) {
/* 如果 info 不为 0 */
i__2 = -(*info);
/* 计算错误码的负值 */
xerbla_("DORMHR", &i__2);
/* 调用 xerbla 函数报错 */
return 0;
/* 返回 0 */
} else if (lquery) {
/* 否则如果是查询模式 */
return 0;
/* 直接返回 */
}

/* Quick return if possible */
/* 如果可能，快速返回 */

if (*m == 0 || *n == 0 || nh == 0) {
/* 如果 m 或者 n 为 0，或者 nh 为 0 */
work[1] = 1.;
/* 设置 work 数组的第一个元素为 1. */
return 0;
/* 返回 0 */
}

if (left) {
/* 如果 side 是 'L' */
mi = nh;
/* 设置 mi 为 nh */
ni = *n;
/* 设置 ni 为 n */
i1 = *ilo + 1;
/* 设置 i1 为 ilo + 1 */
i2 = 1;
/* 设置 i2 为 1 */
} else {
/* 否则 */
mi = *m;
/* 设置 mi 为 m */
ni = nh;
/* 设置 ni 为 nh */
i1 = 1;
/* 设置 i1 为 1 */
i2 = *ilo + 1;
/* 设置 i2 为 ilo + 1 */
}

dormqr_(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &
    tau[*ilo], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
/* 调用 dormqr 函数 */

work[1] = (doublereal) lwkopt;
/* 将最优工作空间大小存入 work 数组 */

return 0;

/* End of DORMHR */
/* DORMHR 函数结束 */

} /* dormhr_ */
/* dormhr_ 子程序结束 */

/* Subroutine */ int dorml2_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *info)
{
/* 子程序 dorml2_ */

/* System generated locals */
/* 系统生成的本地变量 */
integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

/* Local variables */
/* 局部变量 */
static integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
/* 静态整型变量 */
static doublereal aii;
/* 静态双精度浮点数变量 */
static logical left;
/* 静态逻辑变量 */
extern /* Subroutine */ int dlarf_(char *, integer *, integer *,
    doublereal *, integer *, doublereal *, doublereal *, integer *,
    doublereal *);
/* 外部子程序声明 */
extern logical lsame_(char *, char *);
/* 外部函数声明 */
extern /* Subroutine */ int xerbla_(char *, integer *);
/* 外部子程序声明 */


这段代码是 Fortran 的子程序 `dormhr_` 和 `dorml2_` 的开头部分，包含了参数调整、错误检查、变量初始化等功能。
    # 定义静态变量 `notran`，其类型为逻辑型
    static logical notran;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORML2 overwrites the general real m by n matrix C with

          Q * C  if SIDE = 'L' and TRANS = 'N', or

          Q'* C  if SIDE = 'L' and TRANS = 'T', or

          C * Q  if SIDE = 'R' and TRANS = 'N', or

          C * Q' if SIDE = 'R' and TRANS = 'T',

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q' from the Left
            = 'R': apply Q or Q' from the Right

    TRANS   (input) CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q' (Transpose)

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace) DOUBLE PRECISION array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments
*/

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;   // Adjust the pointer to array A to account for offset

    --tau;           // Adjust the pointer to array TAU to start from 1

    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset; // Adjust the pointer to array C to account for offset

    --work;          // Adjust the pointer to array WORK to start from 1

    /* Function Body */
    *info = 0;
    # 将指针info所指向的内存位置设置为0，通常用于初始化或清零操作

    left = lsame_(side, "L");
    # 调用lsame_函数，比较side参数是否等于"L"，将结果赋给left变量，用于后续条件判断

    notran = lsame_(trans, "N");
    # 调用lsame_函数，比较trans参数是否等于"N"，将结果赋给notran变量，用于后续条件判断
/*     NQ is the order of Q */

    // 检查左乘标志left，确定NQ的取值
    if (left) {
    nq = *m;  // 如果左乘，NQ取m的值
    } else {
    nq = *n;  // 如果右乘，NQ取n的值
    }

    // 检查特定输入条件，设置info的值以便错误处理
    if (! left && ! lsame_(side, "R")) {
    *info = -1;  // 若非左乘并且side不为'R'，设置info为-1
    } else if (! notran && ! lsame_(trans, "T")) {
    *info = -2;  // 若非转置操作并且trans不为'T'，设置info为-2
    } else if (*m < 0) {
    *info = -3;  // 若m小于0，设置info为-3
    } else if (*n < 0) {
    *info = -4;  // 若n小于0，设置info为-4
    } else if (*k < 0 || *k > nq) {
    *info = -5;  // 若k小于0或大于NQ，设置info为-5
    } else if (*lda < max(1,*k)) {
    *info = -7;  // 若lda小于1或*k，设置info为-7
    } else if (*ldc < max(1,*m)) {
    *info = -10; // 若ldc小于1或*m，设置info为-10
    }

    // 若info非0，输出错误信息并返回
    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DORML2", &i__1);  // 调用错误处理子程序xerbla_
    return 0;
    }

/*     Quick return if possible */

    // 若m、n或k为0，直接返回
    if (*m == 0 || *n == 0 || *k == 0) {
    return 0;
    }

    // 根据左乘和非转置条件，设置循环参数i1、i2、i3
    if (left && notran || ! left && ! notran) {
    i1 = 1;  // 若左乘并且非转置或非左乘并且非转置，设置i1为1
    i2 = *k; // 设置i2为k
    i3 = 1;  // 设置i3为1
    } else {
    i1 = *k; // 否则，设置i1为k
    i2 = 1;  // 设置i2为1
    i3 = -1; // 设置i3为-1
    }

    // 根据左乘标志设置mi或ni的值
    if (left) {
    ni = *n;  // 若左乘，设置ni为n
    jc = 1;   // 设置jc为1
    } else {
    mi = *m;  // 若右乘，设置mi为m
    ic = 1;   // 设置ic为1
    }

    // 执行循环，对每个i进行操作
    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
    if (left) {

/*           H(i) is applied to C(i:m,1:n) */

        mi = *m - i__ + 1;  // 计算mi的值
        ic = i__;           // 设置ic为i__
    } else {

/*           H(i) is applied to C(1:m,i:n) */

        ni = *n - i__ + 1;  // 计算ni的值
        jc = i__;           // 设置jc为i__
    }

/*        Apply H(i) */

    aii = a[i__ + i__ * a_dim1];  // 获取a矩阵中的元素aii
    a[i__ + i__ * a_dim1] = 1.;   // 将a矩阵中的元素aii设为1
    dlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], lda, &tau[i__], &c__[
        ic + jc * c_dim1], ldc, &work[1]);  // 调用larf子程序进行变换
    a[i__ + i__ * a_dim1] = aii;  // 恢复a矩阵中的元素aii原值
/* L10: */
    }
    return 0;

/*     End of DORML2 */

} /* dorml2_ */

/* Subroutine */ int dormlq_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static doublereal t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int dorml2_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *), dlarfb_(char
        *, char *, char *, char *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran;
    static integer ldwork;
    static char transt[1];
    static integer lwkopt;
    static logical lquery;
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006

    Purpose
    =======

    DORMLQ overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.

    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.

    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.

    A       (input) DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,K).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.

    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    # LWORK   (input) INTEGER
    #         The dimension of the array WORK.
    #         If SIDE = 'L', LWORK >= max(1,N);
    #         if SIDE = 'R', LWORK >= max(1,M).
    #         For optimum performance LWORK >= N*NB if SIDE = 'L', and
    #         LWORK >= M*NB if SIDE = 'R', where NB is the optimal
    #         blocksize.
    #
    #         If LWORK = -1, then a workspace query is assumed; the routine
    #         only calculates the optimal size of the WORK array, returns
    #         this value as the first entry of the WORK array, and no error
    #         message related to LWORK is issued by XERBLA.
    #
    # INFO    (output) INTEGER
    #         = 0:  successful exit
    #         < 0:  if INFO = -i, the i-th argument had an illegal value
    #
    # =====================================================================
    #
    # Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;  // 获取数组 a 的第一维度大小，用于访问 a 数组的元素
    a_offset = 1 + a_dim1;  // 计算 a 数组的偏移量
    a -= a_offset;  // 调整 a 数组的起始位置，使得 a[1,1] 对应于 a[a_offset,a_offset]

    --tau;  // tau 数组的起始位置向前移动一个位置，用于访问 tau 数组的元素

    c_dim1 = *ldc;  // 获取数组 c__ 的第一维度大小，用于访问 c__ 数组的元素
    c_offset = 1 + c_dim1;  // 计算 c__ 数组的偏移量
    c__ -= c_offset;  // 调整 c__ 数组的起始位置，使得 c__[1,1] 对应于 c__[c_offset,c_offset]

    --work;  // work 数组的起始位置向前移动一个位置，用于访问 work 数组的元素

    /* Function Body */
    *info = 0;  // 初始化 info 为 0，用于存储函数执行的状态信息
    left = lsame_(side, "L");  // 判断 side 是否为 "L"，返回布尔值给 left
    notran = lsame_(trans, "N");  // 判断 trans 是否为 "N"，返回布尔值给 notran
    lquery = *lwork == -1;  // 判断 lwork 是否为 -1，返回布尔值给 lquery

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;  // 如果 side 是 "L"，则 nq 为 m
        nw = *n;  // 如果 side 是 "L"，则 nw 为 n
    } else {
        nq = *n;  // 如果 side 不是 "L"，则 nq 为 n
        nw = *m;  // 如果 side 不是 "L"，则 nw 为 m
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;  // 如果 side 不是 "L" 或 "R"，设置 info 为 -1
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;  // 如果 trans 不是 "N" 或 "T"，设置 info 为 -2
    } else if (*m < 0) {
        *info = -3;  // 如果 m 小于 0，设置 info 为 -3
    } else if (*n < 0) {
        *info = -4;  // 如果 n 小于 0，设置 info 为 -4
    } else if (*k < 0 || *k > nq) {
        *info = -5;  // 如果 k 小于 0 或者大于 nq，设置 info 为 -5
    } else if (*lda < max(1,*k)) {
        *info = -7;  // 如果 lda 小于 max(1, k)，设置 info 为 -7
    } else if (*ldc < max(1,*m)) {
        *info = -10;  // 如果 ldc 小于 max(1, m)，设置 info 为 -10
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;  // 如果 lwork 小于 max(1, nw) 且不是查询模式，设置 info 为 -12
    }

    if (*info == 0) {

        /* Determine the block size.  NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);  // 拼接 side 和 trans 成字符串 ch__1
        i__1 = 64, i__2 = ilaenv_(&c__1, "DORMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);  // 调用 ilaenv 计算 NB 的推荐值
        nb = min(i__1,i__2);  // 取 i__1 和 i__2 的最小值作为 nb
        lwkopt = max(1,nw) * nb;  // 计算工作数组所需空间的最优大小
        work[1] = (doublereal) lwkopt;  // 将最优工作空间大小存入 work 数组的第一个元素
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORMLQ", &i__1);  // 错误处理函数，输出错误信息
        return 0;  // 返回 0 终止函数
    } else if (lquery) {
        return 0;  // 如果是查询模式，直接返回 0
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1] = 1.;  // 如果 m、n 或 k 有一个为 0，设置 work 数组的第一个元素为 1.0
        return 0;  // 返回 0 终止函数
    }

    nbmin = 2;  // 设置最小块大小为 2
    ldwork = nw;  // 设置 ldwork 为 nw
    if (nb > 1 && nb < *k) {
        iws = nw * nb;  // 计算工作数组所需空间
        if (*lwork < iws) {
            nb = *lwork / ldwork;  // 调整 nb 使得工作数组足够大
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "DORMLQ", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);  // 重新计算 nbmin
            nbmin = max(i__1,i__2);  // 取 i__1 和 i__2 的最大值作为 nbmin
        }
    } else {
        iws = nw;  // 计算工作数组所需空间
    }

    if (nb < nbmin || nb >= *k) {

        /* Use unblocked code */
        dorml2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);  // 调用 unblocked 版本的矩阵乘法运算
    } else {

        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        if (notran) {
            *(unsigned char *)transt = 'T';
        } else {
            *(unsigned char *)transt = 'N';
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);  // 计算当前块的大小
/*
             Form the triangular factor of the block reflector
             H = H(i) H(i+1) . . . H(i+ib-1)
*/

        i__4 = nq - i__ + 1;
        dlarft_("Forward", "Rowwise", &i__4, &ib, &a[i__ + i__ * a_dim1],
            lda, &tau[i__], t, &c__65);
        if (left) {

/*              H or H' is applied to C(i:m,1:n) */

        mi = *m - i__ + 1;
        ic = i__;
        } else {

/*              H or H' is applied to C(1:m,i:n) */

        ni = *n - i__ + 1;
        jc = i__;
        }

/*           Apply H or H' */

        dlarfb_(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__
            + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1],
            ldc, &work[1], &ldwork);
/* L10: */
    }
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMLQ */

} /* dormlq_ */

/* Subroutine */ int dormql_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* Local variables */
    static integer i__;
    static doublereal t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int dorm2l_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *), dlarfb_(char
        *, char *, char *, char *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORMQL overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix defined as the product of k
    elementary reflectors

          Q = H(k) . . . H(2) H(1)

    as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
    if SIDE = 'R'.

    Arguments
    =========

*/

/*     .. Local Scalars .. */
    /* .. Array Arguments .. */
/*     .. External Subroutines .. */
/*     .. External Functions .. */
/*     .. Intrinsics .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --tau;
    --work;
    --c__;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;

/*     Test the input arguments */

    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

/*     Determine the block size */

    nb = ilaenv_(&c__1, "DORMQL", side, m, n, k, &c_n1, (ftnlen)6, (ftnlen)1);
    lwkopt = max(1,*m);

    if (nb <= 1 || nb >= *k) {
        ldwork = *m;
        lwkopt = *m;
    } else {
        ldwork = nb;
        lwkopt = nb * *m;
    }

    if (*m >= *n) {
        /*    Q was determined by a call to DGELQF with M >= N */

/* Computing MAX */
        i__1 = *n << 1;
        nbmin = max(nb, i__1);
    } else {
        /*    Q was determined by a call to DGELQF with M < N */

/* Computing MAX */
        i__1 = *m << 1;
        nbmin = max(nb, i__1);
    }

    if (! lquery && *lwork < lwkopt && *lwork != -1) {
        *info = -12;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORMQL", &i__1);
        return 0;
    } else if (lquery) {
        work[1] = (doublereal) lwkopt;
        return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
        work[1] = 1.;
        return 0;
    }

/*     Determine the number of columns to be modified */

    if (left && ! notran || ! left && notran) {
        nq = *m;
    } else {
        nq = *n;
    }

    if (left) {

/*        H or H' is applied to C(i:m,1:n) */

        mi = *m - i__ + 1;
        ic = i__;
    } else {

/*        H or H' is applied to C(1:m,i:n) */

        ni = *n - i__ + 1;
        jc = i__;
    }

/*     Apply H or H' */

    dlarfb_(side, trans, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__ + i__ *
        a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1], ldc, &
        work[1], &ldwork);
/* L10: */
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMLQ */

} /* dormlq_ */


注释：
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
    A       (input) DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = max(1,*n);
    } else {
        nq = *n;
        nw = max(1,*m);
    }
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    }

    if (*info == 0) {
        if (*m == 0 || *n == 0) {
            lwkopt = 1;
        } else {
            /* Determine the block size. NB may be at most NBMAX, where NBMAX is used to define the local array T. */
            char ch__1[2];
            sprintf(ch__1, "%c%c", *side, *trans);
            i__1 = 64, i__2 = ilaenv_(&c__1, "DORMQL", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nb = min(i__1, i__2);
            lwkopt = nw * nb;
        }
        work[1] = (doublereal) lwkopt;

        if (*lwork < nw && ! lquery) {
            *info = -12;
        }
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORMQL", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0) {
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            /* Adjust NBMIN based on the size of the problem */
            char ch__1[2];
            sprintf(ch__1, "%c%c", *side, *trans);
            i__1 = 2, i__2 = ilaenv_(&c__2, "DORMQL", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nbmin = max(i__1, i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        dorm2l_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && notran || ! left && ! notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
        } else {
            mi = *m;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Determine IB, the current block size */
            ib = min(nb, *k - i__ + 1);
/*
             构造块反射器的三角因子
             H = H(i+ib-1) . . . H(i+1) H(i)
*/

        i__4 = nq - *k + i__ + ib - 1;
        // 调用 LAPACK 中的 DLARFT 函数，计算反射器的三角因子
        dlarft_("Backward", "Columnwise", &i__4, &ib, &a[i__ * a_dim1 + 1]
            , lda, &tau[i__], t, &c__65);
        if (left) {

/*              H 或 H' 作用于 C(1:m-k+i+ib-1,1:n) */

        mi = *m - *k + i__ + ib - 1;
        } else {

/*              H 或 H' 作用于 C(1:m,1:n-k+i+ib-1) */

        ni = *n - *k + i__ + ib - 1;
        }

/*           应用 H 或 H' */

        // 调用 LAPACK 中的 DLARFB 函数，将计算得到的三角因子应用于矩阵 C
        dlarfb_(side, trans, "Backward", "Columnwise", &mi, &ni, &ib, &a[
            i__ * a_dim1 + 1], lda, t, &c__65, &c__[c_offset], ldc, &
            work[1], &ldwork);
/* L10: */
    }
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     DORMQL 的结束 */

} /* dormql_ */

/* 子程序 */ int dormqr_(char *side, char *trans, integer *m, integer *n,
    integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
{
    /* 系统生成的本地变量 */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
        i__5;
    char ch__1[2];

    /* 本地变量 */
    static integer i__;
    static doublereal t[4160]    /* was [65][64] */;
    static integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    extern /* Subroutine */ int dorm2r_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *), dlarfb_(char
        *, char *, char *, char *, integer *, integer *, integer *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal
        *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical notran;
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK 子程序 (版本 3.2) --
    -- LAPACK 是由田纳西大学、加州大学伯克利分校、科罗拉多大学丹佛分校和 NAG Ltd. 提供的软件包。--
       2006年11月


    目的
    =======

    DORMQR 用 Q 乘积覆盖一般实数 M×N 矩阵 C，其中

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    这里 Q 是由 DGEQRF 返回的 k 个基本反射器的乘积

          Q = H(1) H(2) . . . H(k)

    如果 SIDE = 'L'，则 Q 的阶数为 M；如果 SIDE = 'R'，则为 N。

    参数
    =========

*/
    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
    TRANS   (input) CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
    M       (input) INTEGER
            The number of rows of the matrix C. M >= 0.
    N       (input) INTEGER
            The number of columns of the matrix C. N >= 0.
    K       (input) INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
    A       (input) DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
    LDA     (input) INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
    C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
    LDC     (input) INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    =====================================================================


       Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    notran = lsame_(trans, "N");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }

    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! notran && ! lsame_(trans, "T")) {
        *info = -2;
    } else if (*m < 0) {
        *info = -3;
    } else if (*n < 0) {
        *info = -4;
    } else if (*k < 0 || *k > nq) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    if (*info == 0) {
        /* Determine the block size. NB may be at most NBMAX, where NBMAX
           is used to define the local array T. */
        i__3[0] = 1, a__1[0] = side;
        i__3[1] = 1, a__1[1] = trans;
        s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
        i__1 = 64, i__2 = ilaenv_(&c__1, "DORMQR", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
        nb = min(i__1,i__2);
        lwkopt = max(1,nw) * nb;
        work[1] = (doublereal) lwkopt;
    }

    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DORMQR", &i__1);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || *k == 0) {
        work[1] = 1.;
        return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
        iws = nw * nb;
        if (*lwork < iws) {
            nb = *lwork / ldwork;
            i__3[0] = 1, a__1[0] = side;
            i__3[1] = 1, a__1[1] = trans;
            s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
            i__1 = 2, i__2 = ilaenv_(&c__2, "DORMQR", ch__1, m, n, k, &c_n1, (ftnlen)6, (ftnlen)2);
            nbmin = max(i__1,i__2);
        }
    } else {
        iws = nw;
    }

    if (nb < nbmin || nb >= *k) {
        /* Use unblocked code */
        dorm2r_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {
        /* Use blocked code */
        if (left && ! notran || ! left && notran) {
            i1 = 1;
            i2 = *k;
            i3 = nb;
        } else {
            i1 = (*k - 1) / nb * nb + 1;
            i2 = 1;
            i3 = -nb;
        }

        if (left) {
            ni = *n;
            jc = 1;
        } else {
            mi = *m;
            ic = 1;
        }

        i__1 = i2;
        i__2 = i3;
        for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
            /* Computing MIN */
            i__4 = nb, i__5 = *k - i__ + 1;
            ib = min(i__4,i__5);

            /* Form the triangular factor of the block reflector
               H = H(i) H(i+1) . . . H(i+ib-1) */
fortran
/* 

        i__4 = nq - i__ + 1;
        dlarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ *
            a_dim1], lda, &tau[i__], t, &c__65)
            ;
        if (left) {

/*              H or H' is applied to C(i:m,1:n) */

        mi = *m - i__ + 1;
        ic = i__;
        } else {

/*              H or H' is applied to C(1:m,i:n) */

        ni = *n - i__ + 1;
        jc = i__;
        }

/*           Apply H or H' */

        dlarfb_(side, trans, "Forward", "Columnwise", &mi, &ni, &ib, &a[
            i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc *
            c_dim1], ldc, &work[1], &ldwork);
/* L10: */
    }
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMQR */

} /* dormqr_ */

/* Subroutine */ int dormtr_(char *side, char *uplo, char *trans, integer *m,
    integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *
    c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2, i__3;
    char ch__1[2];

    /* Local variables */
    static integer i1, i2, nb, mi, ni, nq, nw;
    static logical left;
    extern logical lsame_(char *, char *);
    static integer iinfo;
    static logical upper;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    extern /* Subroutine */ int dormql_(char *, char *, integer *, integer *,
        integer *, doublereal *, integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *, integer *);
    static integer lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DORMTR overwrites the general real M-by-N matrix C with

                    SIDE = 'L'     SIDE = 'R'
    TRANS = 'N':      Q * C          C * Q
    TRANS = 'T':      Q**T * C       C * Q**T

    where Q is a real orthogonal matrix of order nq, with nq = m if
    SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
    nq-1 elementary reflectors, as returned by DSYTRD:

    if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);

    if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right;


*/
    ! UPLO (input) CHARACTER*1
    ! Specifies whether the upper or lower triangular part of the matrix A contains the elementary reflectors:
    ! = 'U': Upper triangle of A contains elementary reflectors from DSYTRD;
    ! = 'L': Lower triangle of A contains elementary reflectors from DSYTRD.
    
    ! TRANS (input) CHARACTER*1
    ! Specifies whether to apply Q or Q**T:
    ! = 'N': No transpose, apply Q;
    ! = 'T': Transpose, apply Q**T.
    
    ! M (input) INTEGER
    ! The number of rows of the matrix C. M >= 0.
    
    ! N (input) INTEGER
    ! The number of columns of the matrix C. N >= 0.
    
    ! A (input) DOUBLE PRECISION array, dimension (LDA,M) if SIDE = 'L', (LDA,N) if SIDE = 'R'
    ! The vectors which define the elementary reflectors, as returned by DSYTRD.
    
    ! LDA (input) INTEGER
    ! The leading dimension of the array A:
    ! LDA >= max(1,M) if SIDE = 'L';
    ! LDA >= max(1,N) if SIDE = 'R'.
    
    ! TAU (input) DOUBLE PRECISION array, dimension (M-1) if SIDE = 'L', (N-1) if SIDE = 'R'
    ! TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DSYTRD.
    
    ! C (input/output) DOUBLE PRECISION array, dimension (LDC,N)
    ! On entry, the M-by-N matrix C.
    ! On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
    
    ! LDC (input) INTEGER
    ! The leading dimension of the array C. LDC >= max(1,M).
    
    ! WORK (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
    ! On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    ! LWORK (input) INTEGER
    ! The dimension of the array WORK:
    ! If SIDE = 'L', LWORK >= max(1,N);
    ! If SIDE = 'R', LWORK >= max(1,M).
    ! For optimum performance LWORK >= N*NB if SIDE = 'L', and LWORK >= M*NB if SIDE = 'R',
    ! where NB is the optimal blocksize.
    ! If LWORK = -1, then a workspace query is assumed; the routine only calculates
    ! the optimal size of the WORK array, returns this value as the first entry of the WORK array,
    ! and no error message related to LWORK is issued by XERBLA.
    
    ! INFO (output) INTEGER
    ! = 0: successful exit
    ! < 0: if INFO = -i, the i-th argument had an illegal value
    
    ! =====================================================================
    
    ! Test the input arguments
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L");
    upper = lsame_(uplo, "U");
    lquery = *lwork == -1;

    /* NQ is the order of Q and NW is the minimum dimension of WORK */
    if (left) {
        nq = *m;
        nw = *n;
    } else {
        nq = *n;
        nw = *m;
    }

    /* Validate input parameters */
    if (! left && ! lsame_(side, "R")) {
        *info = -1;
    } else if (! upper && ! lsame_(uplo, "L")) {
        *info = -2;
    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
        *info = -3;
    } else if (*m < 0) {
        *info = -4;
    } else if (*n < 0) {
        *info = -5;
    } else if (*lda < max(1,nq)) {
        *info = -7;
    } else if (*ldc < max(1,*m)) {
        *info = -10;
    } else if (*lwork < max(1,nw) && ! lquery) {
        *info = -12;
    }

    /* Check if any errors were detected */
    if (*info == 0) {
        /* Determine optimal block size */
        if (upper) {
            if (left) {
                /* Determine optimal block size for DORMQL */
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *m - 1;
                i__3 = *m - 1;
                nb = ilaenv_(&c__1, "DORMQL", ch__1, &i__2, n, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Determine optimal block size for DORMQL */
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *n - 1;
                i__3 = *n - 1;
                nb = ilaenv_(&c__1, "DORMQL", ch__1, m, &i__2, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        } else {
            if (left) {
                /* Determine optimal block size for DORMQR */
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *m - 1;
                i__3 = *m - 1;
                nb = ilaenv_(&c__1, "DORMQR", ch__1, &i__2, n, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            } else {
                /* Determine optimal block size for DORMQR */
                s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
                i__2 = *n - 1;
                i__3 = *n - 1;
                nb = ilaenv_(&c__1, "DORMQR", ch__1, m, &i__2, &i__3, &c_n1, (ftnlen)6, (ftnlen)2);
            }
        }
        lwkopt = max(1,nw) * nb;
        work[1] = (doublereal) lwkopt;
    }

    /* Handle error case */
    if (*info != 0) {
        i__2 = -(*info);
        xerbla_("DORMTR", &i__2);
        return 0;
    } else if (lquery) {
        return 0;
    }

    /* Quick return if possible */
    if (*m == 0 || *n == 0 || nq == 1) {
        work[1] = 1.;
        return 0;
    }

    /* Determine dimensions based on 'side' parameter */
    if (left) {
        mi = *m - 1;
        ni = *n;
    } else {
        mi = *m;
        ni = *n - 1;
    }

    /* Call appropriate LAPACK routine based on 'upper' parameter */
    if (upper) {
        /* Call DORMQL for upper triangular case */
        i__2 = nq - 1;
        dormql_(side, trans, &mi, &ni, &i__2, &a[(a_dim1 << 1) + 1], lda, &tau[1], &c__[c_offset], ldc, &work[1], lwork, &iinfo);
    } else {
        /* Call DORMQR for lower triangular case */
        i__2 = nq - 1;
        dormqr_(side, trans, &mi, &ni, &i__2, &a[a_offset], lda, &tau[1], &c__[c_offset], ldc, &work[1], lwork, &iinfo);
    }
/*        Q was determined by a call to DSYTRD with UPLO = 'L' */

    // 如果 left 为真，则设置 i1 = 2，i2 = 1；否则，设置 i1 = 1，i2 = 2
    if (left) {
        i1 = 2;
        i2 = 1;
    } else {
        i1 = 1;
        i2 = 2;
    }
    // 计算 i__2 的值为 nq - 1
    i__2 = nq - 1;
    // 调用 dormqr 函数，对矩阵 C 应用 Q，Q 的大小为 mi x ni
    // 参数说明：
    // - side: 'L' 表示左乘 Q，'R' 表示右乘 Q
    // - trans: 转置操作
    // - mi: 矩阵 C 的行数
    // - ni: 矩阵 C 的列数
    // - i__2: Q 的列数
    // - &a[a_dim1 + 2]: 用于构造 Q 的矩阵 A
    // - lda: 矩阵 A 的列数
    // - &tau[1]: 存储了 Q 的元素
    // - &c__[i1 + i2 * c_dim1]: 输出矩阵 C 的起始位置
    // - ldc: 矩阵 C 的列数
    // - &work[1]: 工作空间
    // - lwork: 工作空间的长度
    // - &iinfo: 返回的信息，若为 0 表示成功
    dormqr_(side, trans, &mi, &ni, &i__2, &a[a_dim1 + 2], lda, &tau[1], &
        c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
    }
    // 将 work[1] 设置为 lwkopt 的值
    work[1] = (doublereal) lwkopt;
    // 返回 0 表示成功完成
    return 0;

/*     End of DORMTR */

} /* dormtr_ */

/* Subroutine */ int dpotf2_(char *uplo, integer *n, doublereal *a, integer *
    lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer j;
    static doublereal ajj;
    extern doublereal ddot_(integer *, doublereal *, integer *, doublereal *,
        integer *);
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *);
    static logical upper;
    extern logical disnan_(doublereal *);
    extern /* Subroutine */ int xerbla_(char *, integer *);


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DPOTF2 computes the Cholesky factorization of a real symmetric
    positive definite matrix A.

    The factorization has the form
       A = U' * U ,  if UPLO = 'U', or
       A = L  * L',  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the unblocked version of the algorithm, calling Level 2 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U'*U  or A = L*L'.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).


注释：
    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DPOTF2", &i__1);
        return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
        return 0;
    }

    if (upper) {

/*        Compute the Cholesky factorization A = U'*U. */

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {

/*           Compute U(J,J) and test for non-positive-definiteness. */

            i__2 = j - 1;
            ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j * a_dim1 + 1], &c__1,
                &a[j * a_dim1 + 1], &c__1);
            if (ajj <= 0. || disnan_(&ajj)) {
                a[j + j * a_dim1] = ajj;
                goto L30;
            }
            ajj = sqrt(ajj);
            a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of row J. */

            if (j < *n) {
                i__2 = j - 1;
                i__3 = *n - j;
                dgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(j + 1) *
                    a_dim1 + 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b15, &
                    a[j + (j + 1) * a_dim1], lda);
                i__2 = *n - j;
                d__1 = 1. / ajj;
                dscal_(&i__2, &d__1, &a[j + (j + 1) * a_dim1], lda);
            }
/* L10: */
        }
    } else {

/*        Compute the Cholesky factorization A = L*L'. */

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {

/*           Compute L(J,J) and test for non-positive-definiteness. */

            i__2 = j - 1;
            ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j + a_dim1], lda, &a[j
                + a_dim1], lda);
            if (ajj <= 0. || disnan_(&ajj)) {
                a[j + j * a_dim1] = ajj;
                goto L30;
            }
            ajj = sqrt(ajj);
            a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of column J. */

            if (j < *n) {
                i__2 = *n - j;
                i__3 = j - 1;
                dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[j + 1 +
                    a_dim1], lda, &a[j + a_dim1], lda, &c_b15, &a[j + 1 +
                    j * a_dim1], &c__1);
                i__2 = *n - j;
                d__1 = 1. / ajj;
                dscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);
            }
/* L20: */
        }
    }
    goto L40;

L30:
    *info = j;

L40:
    return 0;

/*     End of DPOTF2 */

} /* dpotf2_ */

/* Subroutine */ int dpotrf_(char *uplo, integer *n, doublereal *a, integer *
    lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer j, jb, nb;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    extern logical lsame_(char *, char *);

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;

    // Determine if the matrix A should be treated as upper or lower triangular
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        // Set *info to -1 if UPLO is not 'U' or 'L'
        *info = -1;
    } else if (*n < 0) {
        // Set *info to -2 if N is negative
        *info = -2;
    } else if (*lda < max(1,*n)) {
        // Set *info to -4 if LDA is less than max(1,N)
        *info = -4;
    }

    // If *info is not 0, call XERBLA and return
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DPOTF2", &i__1);
        return 0;
    }

    // Quick return if N = 0
    if (*n == 0) {
        return 0;
    }

    if (upper) {

        // Compute the Cholesky factorization A = U'*U

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {

            // Compute U(J,J) and test for non-positive-definiteness

            i__2 = j - 1;
            ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j * a_dim1 + 1], &c__1,
                &a[j * a_dim1 + 1], &c__1);
            if (ajj <= 0. || disnan_(&ajj)) {
                // If non-positive-definiteness is detected, set A(J,J) to AJJ and goto L30
                a[j + j * a_dim1] = ajj;
                goto L30;
            }
            ajj = sqrt(ajj);
            a[j + j * a_dim1] = ajj;

            // Compute elements J+1:N of row J

            if (j < *n) {
                i__2 = j - 1;
                i__3 = *n - j;
                dgemv_("Transpose", &i__2, &i__3, &c_b151, &a[(j + 1) *
                    a_dim1 + 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b15, &
                    a[j + (j + 1) * a_dim1], lda);
                i__2 = *n - j;
                d__1 = 1. / ajj;
                dscal_(&i__2, &d__1, &a[j + (j + 1) * a_dim1], lda);
            }
        }
    } else {

        // Compute the Cholesky factorization A = L*L'

        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {

            // Compute L(J,J) and test for non-positive-definiteness

            i__2 = j - 1;
            ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j + a_dim1], lda, &a[j
                + a_dim1], lda);
            if (ajj <= 0. || disnan_(&ajj)) {
                // If non-positive-definiteness is detected, set A(J,J) to AJJ and goto L30
                a[j + j * a_dim1] = ajj;
                goto L30;
            }
            ajj = sqrt(ajj);
            a[j + j * a_dim1] = ajj;

            // Compute elements J+1:N of column J

            if (j < *n) {
                i__2 = *n - j;
                i__3 = j - 1;
                dgemv_("No transpose", &i__2, &i__3, &c_b151, &a[j + 1 +
                    a_dim1], lda, &a[j + a_dim1], lda, &c_b15,
    # 外部声明一个名为 dtrsm_ 的子例程（函数），参数类型分别为字符指针，整数，双精度实数数组和整数
    extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);

    # 静态逻辑变量 upper，可能用于指示矩阵是否为上三角形式
    static logical upper;

    # 外部声明一个名为 dsyrk_ 的子例程（函数），参数类型分别为字符指针，整数，双精度实数数组，双精度实数数组和整数
    extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         integer *);

    # 外部声明一个名为 dpotf2_ 的子例程（函数），参数类型分别为字符指针，整数，双精度实数数组，整数和整数
    extern /* Subroutine */ int dpotf2_(char *, integer *,
        doublereal *, integer *, integer *);

    # 外部声明一个名为 xerbla_ 的子例程（函数），参数类型分别为字符指针和整数
    extern /* Subroutine */ int xerbla_(char *,
        integer *);

    # 外部声明一个名为 ilaenv_ 的函数，返回类型为整数，参数类型分别为整数，字符指针，字符指针，整数，整数，整数，整数，字符指针长度和字符指针长度
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DPOTRF computes the Cholesky factorization of a real symmetric
    positive definite matrix A.

    The factorization has the form
       A = U**T * U,  if UPLO = 'U', or
       A = L  * L**T,  if UPLO = 'L',
    where U is an upper triangular matrix and L is lower triangular.

    This is the block version of the algorithm, calling Level 3 BLAS.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.

            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.

    =====================================================================


       Test the input parameters.
*/
void dpotrf_(char *uplo, integer *n, doublereal *a, integer *lda, integer *info) {
    /* Parameter adjustments */
    integer a_dim1, a_offset;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    logical upper;
    upper = lsame_(uplo, "U");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (*n < 0) {
        *info = -2;
    } else if (*lda < max(1,*n)) {
        *info = -4;
    }
    if (*info != 0) {
        integer i__1;
        i__1 = -(*info);
        xerbla_("DPOTRF", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /* Determine the block size for this environment. */
    integer nb;
    nb = ilaenv_(&c__1, "DPOTRF", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
    if (nb <= 1 || nb >= *n) {

        /* Use unblocked code. */
        dpotf2_(uplo, n, &a[a_offset], lda, info);
    } else {

        /* Use blocked code. */
        if (upper) {
            // Blocked code for upper triangle
        } else {
            // Blocked code for lower triangle
        }
    }
}
/*           Compute the Cholesky factorization A = U'*U. */

/* 循环遍历矩阵 A 的列 */
i__1 = *n;
/* 步长为 nb，从第 1 列开始 */
i__2 = nb;
for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*
        Update and factorize the current diagonal block and test
        for non-positive-definiteness.

   Computing MIN
*/
/* 计算当前对角块的大小 */
i__3 = nb, i__4 = *n - j + 1;
jb = min(i__3,i__4);
/* 更新和因子化当前对角块 */
i__3 = j - 1;
dsyrk_("Upper", "Transpose", &jb, &i__3, &c_b151, &a[j * a_dim1 + 1], lda, &c_b15, &a[j + j * a_dim1], lda);
dpotf2_("Upper", &jb, &a[j + j * a_dim1], lda, info);
if (*info != 0) {
    goto L30;
}
if (j + jb <= *n) {

/*                 Compute the current block row. */

/* 计算当前块的行 */
i__3 = *n - j - jb + 1;
i__4 = j - 1;
dgemm_("Transpose", "No transpose", &jb, &i__3, &i__4, &c_b151, &a[j * a_dim1 + 1], lda, &a[(j + jb) * a_dim1 + 1], lda, &c_b15, &a[j + (j + jb) * a_dim1], lda);
i__3 = *n - j - jb + 1;
dtrsm_("Left", "Upper", "Transpose", "Non-unit", &jb, &i__3, &c_b15, &a[j + j * a_dim1], lda, &a[j + (j + jb) * a_dim1], lda);
}
/* L10: */
}

} else {

/*           Compute the Cholesky factorization A = L*L'. */

/* 循环遍历矩阵 A 的列 */
i__2 = *n;
/* 步长为 nb，从第 1 列开始 */
i__1 = nb;
for (j = 1; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*
        Update and factorize the current diagonal block and test
        for non-positive-definiteness.

   Computing MIN
*/
/* 计算当前对角块的大小 */
i__3 = nb, i__4 = *n - j + 1;
jb = min(i__3,i__4);
/* 更新和因子化当前对角块 */
i__3 = j - 1;
dsyrk_("Lower", "No transpose", &jb, &i__3, &c_b151, &a[j + a_dim1], lda, &c_b15, &a[j + j * a_dim1], lda);
dpotf2_("Lower", &jb, &a[j + j * a_dim1], lda, info);
if (*info != 0) {
    goto L30;
}
if (j + jb <= *n) {

/*                 Compute the current block column. */

/* 计算当前块的列 */
i__3 = *n - j - jb + 1;
i__4 = j - 1;
dgemm_("No transpose", "Transpose", &i__3, &jb, &i__4, &c_b151, &a[j + jb + a_dim1], lda, &a[j + a_dim1], lda, &c_b15, &a[j + jb + j * a_dim1], lda);
i__3 = *n - j - jb + 1;
dtrsm_("Right", "Lower", "Transpose", "Non-unit", &i__3, &jb, &c_b15, &a[j + j * a_dim1], lda, &a[j + jb + j * a_dim1], lda);
}
/* L20: */
}
}
}
goto L40;

L30:
*info = *info + j - 1;

L40:
return 0;

/*     End of DPOTRF */

} /* dpotrf_ */

/* Subroutine */ int dpotri_(char *uplo, integer *n, doublereal *a, integer *
lda, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1;

/* Local variables */
extern logical lsame_(char *, char *);
    # 声明外部的子程序 xerbla_、dlauum_、dtrtri_
    extern /* Subroutine */ int xerbla_(char *, integer *), dlauum_(
        char *, integer *, doublereal *, integer *, integer *),
        dtrtri_(char *, char *, integer *, doublereal *, integer *,
        integer *);
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DPOTRI computes the inverse of a real symmetric positive definite
    matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    computed by DPOTRF.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T, as computed by
            DPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    a_dim1 = *lda;               // 设置矩阵 A 的第一维度
    a_offset = 1 + a_dim1;       // 计算偏移量
    a -= a_offset;               // 调整数组 A 的指针

    /* Function Body */
    *info = 0;                   // 初始化 INFO 为 0
    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {  // 检查 UPLO 参数是否合法
    *info = -1;
    } else if (*n < 0) {         // 检查 N 参数是否合法
    *info = -2;
    } else if (*lda < max(1,*n)) {  // 检查 LDA 参数是否合法
    *info = -4;
    }
    if (*info != 0) {            // 如果参数有误，调用错误处理例程并返回
    i__1 = -(*info);
    xerbla_("DPOTRI", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {               // 如果 N 为 0，直接返回
    return 0;
    }

/*     Invert the triangular Cholesky factor U or L. */

    dtrtri_(uplo, "Non-unit", n, &a[a_offset], lda, info);  // 计算矩阵的逆

    if (*info > 0) {             // 如果 INFO 大于 0，说明逆矩阵计算失败，返回
    return 0;
    }

/*     Form inv(U)*inv(U)' or inv(L)'*inv(L). */

    dlauum_(uplo, n, &a[a_offset], lda, info);  // 计算对称正定矩阵的逆

    return 0;

/*     End of DPOTRI */

} /* dpotri_ */

/* Subroutine */ int dpotrs_(char *uplo, integer *n, integer *nrhs,
    doublereal *a, integer *lda, doublereal *b, integer *ldb, integer *
    info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    extern logical lsame_(char *, char *);  // 外部 lsame_ 函数声明
    extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *);
    static logical upper;  // 静态逻辑变量 upper
    extern /* Subroutine */ int xerbla_(char *, integer *);  // 外部 xerbla_ 函数声明
    # 解决线性方程组 A*X = B，其中 A 是对称正定矩阵，使用由 DPOTRF 计算得出的 Cholesky 分解
    # A = U**T*U 或 A = L*L**T。

    # UPLO (输入) 字符串，字符长度为1
    #       = 'U': A 的上三角存储；
    #       = 'L': A 的下三角存储。

    # N (输入) 整数
    #     矩阵 A 的阶数。N >= 0。

    # NRHS (输入) 整数
    #        右手边的个数，即矩阵 B 的列数。NRHS >= 0。

    # A (输入) 双精度数组，维度为 (LDA,N)
    #     Cholesky 分解得到的三角矩阵 U 或 L，满足 A = U**T*U 或 A = L*L**T。

    # LDA (输入) 整数
    #      数组 A 的第一维的长度。LDA >= max(1,N)。

    # B (输入/输出) 双精度数组，维度为 (LDB,NRHS)
    #     输入时为右手边矩阵 B，输出时为解矩阵 X。

    # LDB (输入) 整数
    #      数组 B 的第一维的长度。LDB >= max(1,N)。

    # INFO (输出) 整数
    #      = 0: 成功退出
    #      < 0: 如果 INFO = -i，则第 i 个参数具有非法值。

    # 测试输入参数的有效性。
/*

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");  // 判断 uplo 是否为 "U"，确定是否为上三角矩阵
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 uplo 不是 "U" 且不是 "L"，则设置错误信息
    *info = -1;
    } else if (*n < 0) {  // 如果 n < 0，设置错误信息
    *info = -2;
    } else if (*nrhs < 0) {  // 如果 nrhs < 0，设置错误信息
    *info = -3;
    } else if (*lda < max(1,*n)) {  // 如果 lda < max(1, n)，设置错误信息
    *info = -5;
    } else if (*ldb < max(1,*n)) {  // 如果 ldb < max(1, n)，设置错误信息
    *info = -7;
    }
    if (*info != 0) {  // 如果存在错误信息，调用错误处理函数并返回
    i__1 = -(*info);
    xerbla_("DPOTRS", &i__1);
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {  // 如果 n 或 nrhs 为 0，则直接返回
    return 0;
    }

    if (upper) {  // 如果是上三角矩阵，则执行以下操作

/*
          Solve A*X = B where A = U'*U.

          Solve U'*X = B, overwriting B with X.
*/

    dtrsm_("Left", "Upper", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
        a_offset], lda, &b[b_offset], ldb);  // 调用 BLAS 中的矩阵求解函数 dtrsm，解 U'*X = B

/*        Solve U*X = B, overwriting B with X. */

    dtrsm_("Left", "Upper", "No transpose", "Non-unit", n, nrhs, &c_b15, &
        a[a_offset], lda, &b[b_offset], ldb);  // 继续调用 dtrsm，解 U*X = B
    } else {  // 如果是下三角矩阵，则执行以下操作

/*
          Solve A*X = B where A = L*L'.

          Solve L*X = B, overwriting B with X.
*/

    dtrsm_("Left", "Lower", "No transpose", "Non-unit", n, nrhs, &c_b15, &
        a[a_offset], lda, &b[b_offset], ldb);  // 调用 dtrsm，解 L*X = B

/*        Solve L'*X = B, overwriting B with X. */

    dtrsm_("Left", "Lower", "Transpose", "Non-unit", n, nrhs, &c_b15, &a[
        a_offset], lda, &b[b_offset], ldb);  // 继续调用 dtrsm，解 L'*X = B
    }

    return 0;

/*     End of DPOTRS */

} /* dpotrs_ */

/* Subroutine */ int dstedc_(char *compz, integer *n, doublereal *d__,
    doublereal *e, doublereal *z__, integer *ldz, doublereal *work,
    integer *lwork, integer *iwork, integer *liwork, integer *info)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, j, k, m;
    static doublereal p;
    static integer ii, lgn;
    static doublereal eps, tiny;
    extern /* Subroutine */ int dgemm_(char *, char *, integer *, integer *,
        integer *, doublereal *, doublereal *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *);
    static integer lwmin;
    extern /* Subroutine */ int dlaed0_(integer *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *, doublereal *,
         integer *, doublereal *, integer *, integer *);
    static integer start;

    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), dlacpy_(char *, integer *, integer
        *, doublereal *, integer *, doublereal *, integer *),
        dlaset_(char *, integer *, integer *, doublereal *, doublereal *,
        doublereal *, integer *);
    ! 外部函数声明，调用 ilaenv_ 函数，返回整数结果
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    ! 外部函数声明，调用 xerbla_ 子程序，处理错误信息
    extern /* Subroutine */ int xerbla_(char *, integer *);
    ! 静态变量声明，表示计算结束的标志
    static integer finish;
    ! 外部函数声明，调用 dlanst_ 函数，计算范数
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    ! 外部函数声明，调用 dsterf_ 子程序，计算实对称矩阵的特征值
    extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *,
         integer *);
    ! 外部函数声明，调用 dlasrt_ 子程序，对数组进行排序
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, integer *);
    ! 静态变量声明，表示计算中是否包含计算特征向量的标志
    static integer icompz;
    ! 外部函数声明，调用 dsteqr_ 子程序，计算对称三对角矩阵的特征值和（可选）特征向量
    extern /* Subroutine */ int dsteqr_(char *, integer *, doublereal *,
        doublereal *, doublereal *, integer *, doublereal *, integer *);
    ! 静态变量声明，原始范数
    static doublereal orgnrm;
    ! 逻辑变量声明，查询标志
    static logical lquery;
    ! 静态变量声明，小规模问题的阈值
    static integer smlsiz;
    ! 静态变量声明，存储特征向量的标志
    static integer storez;
    ! 静态变量声明，矩阵是否为上三角的标志
    static integer strtrw;
/*
    -- LAPACK driver routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the divide and conquer method.
    The eigenvectors of a full or band real symmetric matrix can also be
    found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
    matrix to tridiagonal form.

    This code makes very mild assumptions about floating point
    arithmetic. It will work on machines with a guard digit in
    add/subtract, or on those binary machines without guard digits
    which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
    It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.  See DLAED3 for details.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original dense symmetric
                    matrix also.  On entry, Z contains the orthogonal
                    matrix used to reduce the original matrix to
                    tridiagonal form.

    N       (input) INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.

    Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).

    WORK    (workspace/output) DOUBLE PRECISION array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*/
    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or N <= 1 then LWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LWORK must be at least
                           ( 1 + 3*N + 2*N*lg N + 3*N**2 ),
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1 then LWORK must be at least
                           ( 1 + 4*N + N**2 ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be max(1,2*(N-1)).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
    /* Parameter adjustments */
    --d__;                              /* Adjust the pointer for array d */
    --e;                                /* Adjust the pointer for array e */
    z_dim1 = *ldz;                      /* Set the first dimension of z */
    z_offset = 1 + z_dim1;              /* Calculate the offset for z */
    z__ -= z_offset;                    /* Adjust the pointer for array z */
    --work;                             /* Adjust the pointer for array work */
    --iwork;                            /* Adjust the pointer for array iwork */

    /* Function Body */
    *info = 0;                          /* Initialize info to zero */
    lquery = *lwork == -1 || *liwork == -1;  /* Determine if workspace query */

    if (lsame_(compz, "N")) {           /* Check if compz equals 'N' */
        icompz = 0;                     /* Set icompz accordingly */
    } else if (lsame_(compz, "V")) {    /* Check if compz equals 'V' */
        icompz = 1;                     /* Set icompz accordingly */
    } else if (lsame_(compz, "I")) {    /* Check if compz equals 'I' */
        icompz = 2;                     /* Set icompz accordingly */
    } else {
        icompz = -1;                    /* Invalid value for compz */
    }
    if (icompz < 0) {                   /* Check if compz is invalid */
        *info = -1;                     /* Set info to -1 */
    } else if (*n < 0) {                /* Check if n is less than zero */
        *info = -2;                     /* Set info to -2 */
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) { /* Check ldz */
        *info = -6;                     /* Set info to -6 */
    }

    if (*info == 0) {

/*        Compute the workspace requirements */

        smlsiz = ilaenv_(&c__9, "DSTEDC", " ", &c__0, &c__0, &c__0, &c__0, (
            ftnlen)6, (ftnlen)1);        /* Determine small size threshold */
        if (*n <= 1 || icompz == 0) {   /* Check conditions for minimal workspace */
            liwmin = 1;                 /* Minimum integer workspace size */
            lwmin = 1;                   /* Minimum real workspace size */
        } else if (*n <= smlsiz) {      /* Check if n is within small size */
            liwmin = 1;                 /* Minimum integer workspace size */
            lwmin = *n - 1 << 1;        /* Real workspace size */
        } else {
            lgn = (integer) (log((doublereal) (*n)) / log(2.));  /* Logarithm base 2 of n */
            if (pow_ii(&c__2, &lgn) < *n) {  /* Check power of 2 condition */
                ++lgn;                  /* Increment lgn if condition not met */
            }
            if (pow_ii(&c__2, &lgn) < *n) {  /* Check power of 2 condition again */
                ++lgn;                  /* Increment lgn if condition not met */
            }
            if (icompz == 1) {          /* Check if compz equals 'V' */
/* Computing 2nd power */
                i__1 = *n;
                lwmin = *n * 3 + 1 + (*n << 1) * lgn + i__1 * i__1 * 3;  /* Calculate real workspace size */
                liwmin = *n * 6 + 6 + *n * 5 * lgn;  /* Calculate integer workspace size */
            } else if (icompz == 2) {   /* Check if compz equals 'I' */
/* Computing 2nd power */
                i__1 = *n;
                lwmin = (*n << 2) + 1 + i__1 * i__1;  /* Calculate real workspace size */
                liwmin = *n * 5 + 3;    /* Calculate integer workspace size */
            }
        }
        work[1] = (doublereal) lwmin;   /* Store minimum real workspace size */
        iwork[1] = liwmin;              /* Store minimum integer workspace size */

        if (*lwork < lwmin && ! lquery) {   /* Check if provided lwork is insufficient */
            *info = -8;                 /* Set info to -8 */
        } else if (*liwork < liwmin && ! lquery) {  /* Check if provided liwork is insufficient */
            *info = -10;                /* Set info to -10 */
        }
    }

    if (*info != 0) {                   /* Check if any errors occurred */
        i__1 = -(*info);                /* Negate info for error reporting */
        xerbla_("DSTEDC", &i__1);        /* Call error handler */
        return 0;                       /* Return from function */
    } else if (lquery) {                /* Check if query was requested */
        return 0;                       /* Return from function */
    }

/*     Quick return if possible */

    if (*n == 0) {                      /* Check if n is zero */
        return 0;                       /* Return from function */
    }
    if (*n == 1) {                      /* Check if n is one */
        if (icompz != 0) {              /* Check if compz is not 'N' */
            z__[z_dim1 + 1] = 1.;       /* Set the first element of z to 1. */
        }
        return 0;                       /* Return from function */
    }

/*
       If the following conditional clause is removed, then the routine
       will use the Divide and Conquer routine to compute only the
       eigenvalues, which requires (3N + 3N**2) real workspace and
       (2 + 5N + 2N lg(N)) integer workspace.
       Since on many architectures DSTERF is much faster than any other
       algorithm for finding eigenvalues only, it is used here
       as the default. If the conditional clause is removed, then
       information on the size of workspace needs to be changed.

       If COMPZ = 'N', use DSTERF to compute the eigenvalues.
*/

    if (icompz == 0) {                  /* Check if compz equals 'N' */
        dsterf_(n, &d__[1], &e[1], info);  /* Call DSTERF to compute eigenvalues */
        goto L50;                       /* Jump to label L50 */
    }

/*
       If N is smaller than the minimum divide size (SMLSIZ+1), then
       solve the problem with another solver.
*/

    if (*n <= smlsiz) {                 /* Check if n is less than or equal to smlsiz */
        dsteqr_(compz, n, &d__[1], &e[1], &z__[z_offset], ldz, &work[1], info);  /* Call DSTEQR for eigenvalue computation */
    } else {

/*
          If COMPZ = 'V', the Z matrix must be stored elsewhere for later
          use.
*/
    # 如果 icompz 等于 1，计算存储位置的起始点为 n*n + 1
    if (icompz == 1) {
        storez = *n * *n + 1;
    # 否则，计算存储位置的起始点为 1
    } else {
        storez = 1;
    }

    # 如果 icompz 等于 2，使用 dlaset_ 函数在 z__ 数组中初始化一个 n × n 的矩阵
    if (icompz == 2) {
        dlaset_("Full", n, n, &c_b29, &c_b15, &z__[z_offset], ldz);
    }
/*        Scale. */

/* 计算矩阵的无穷范数，使用 dlanst_ 函数 */
    orgnrm = dlanst_("M", n, &d__[1], &e[1]);
/* 如果矩阵的无穷范数为 0，跳转到 L50 标签处 */
    if (orgnrm == 0.) {
        goto L50;
    }

/* 设置机器精度 */
    eps = EPSILON;

/* 设置起始位置 */
    start = 1;

/*        while ( START <= N ) */

L10:
/* 如果 start 小于等于 n */
    if (start <= *n) {

/*
             Let FINISH be the position of the next subdiagonal entry
             such that E( FINISH ) <= TINY or FINISH = N if no such
             subdiagonal exists.  The matrix identified by the elements
             between START and FINISH constitutes an independent
             sub-problem.
*/

/* 初始化 finish 为 start */
        finish = start;
L20:
/* 如果 finish 小于 n */
        if (finish < *n) {
/* 计算 TINY 的阈值 */
        tiny = eps * sqrt((d__1 = d__[finish], abs(d__1))) * sqrt((
            d__2 = d__[finish + 1], abs(d__2)));
/* 如果 e[finish] 的绝对值大于 tiny，增加 finish 的值 */
        if ((d__1 = e[finish], abs(d__1)) > tiny) {
            ++finish;
            goto L20;
        }
        }

/*           (Sub) Problem determined.  Compute its size and solve it. */

/* 计算子问题的规模 m */
        m = finish - start + 1;
/* 如果 m 等于 1，更新 start 并跳转到 L10 */
        if (m == 1) {
        start = finish + 1;
        goto L10;
        }
/* 如果 m 大于预定义的 smlsiz */

/*              Scale. */

/* 计算子问题的无穷范数 */
        orgnrm = dlanst_("M", &m, &d__[start], &e[start]);
/* 缩放子问题的对角元素和次对角元素 */
        dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &m, &c__1, &d__[
            start], &m, info);
        i__1 = m - 1;
        i__2 = m - 1;
        dlascl_("G", &c__0, &c__0, &orgnrm, &c_b15, &i__1, &c__1, &e[
            start], &i__2, info);

/* 如果需要更新 Z 矩阵 */
        if (icompz == 1) {
            strtrw = 1;
        } else {
            strtrw = start;
        }
/* 调用 dlaed0_ 解决子问题 */
        dlaed0_(&icompz, n, &m, &d__[start], &e[start], &z__[strtrw +
            start * z_dim1], ldz, &work[1], n, &work[storez], &
            iwork[1], info);
/* 如果计算出错，调整 info 并跳转到 L50 */
        if (*info != 0) {
            *info = (*info / (m + 1) + start - 1) * (*n + 1) + *info %
                 (m + 1) + start - 1;
            goto L50;
        }

/*              Scale back. */

/* 将子问题的对角元素和次对角元素缩放回原始大小 */
        dlascl_("G", &c__0, &c__0, &c_b15, &orgnrm, &m, &c__1, &d__[
            start], &m, info);

        } else {
/* 如果不需要更新 Z 矩阵 */

        if (icompz == 1) {

/*
                   Since QR won't update a Z matrix which is larger than
                   the length of D, we must solve the sub-problem in a
                   workspace and then multiply back into Z.
*/

/* 使用 dsteqr_ 解决子问题，将结果存储在工作空间中 */
            dsteqr_("I", &m, &d__[start], &e[start], &work[1], &m, &
                work[m * m + 1], info);
/* 复制结果回 Z 矩阵 */
            dlacpy_("A", n, &m, &z__[start * z_dim1 + 1], ldz, &work[
                storez], n);
/* 执行矩阵乘法将工作空间中的结果乘回 Z 矩阵 */
            dgemm_("N", "N", n, &m, &m, &c_b15, &work[storez], n, &
                work[1], &m, &c_b29, &z__[start * z_dim1 + 1],
                ldz);
        } else if (icompz == 2) {

/* 如果需要更新 Z 矩阵的特定列 */
            dsteqr_("I", &m, &d__[start], &e[start], &z__[start +
                start * z_dim1], ldz, &work[1], info);
        } else {

/* 如果不需要更新 Z 矩阵 */

/* 调用 dsterf_ 解决对称三对角矩阵 */
            dsterf_(&m, &d__[start], &e[start], info);
        }
/* 如果计算出错，调整 info 并跳转到 L50 */
        if (*info != 0) {
            *info = start * (*n + 1) + finish;
            goto L50;
        }
        }

/* 更新 start 的位置 */
        start = finish + 1;
        goto L10;
    }
/*
          endwhile

          If the problem split any number of times, then the eigenvalues
          will not be properly ordered.  Here we permute the eigenvalues
          (and the associated eigenvectors) into ascending order.
*/

    // 如果问题被分割多次，则特征值可能未被正确排序。在这里，我们对特征值（和相关的特征向量）进行升序排列。

    if (m != *n) {
        if (icompz == 0) {

/*              Use Quick Sort */

        // 使用快速排序算法对特征值进行排序

        dlasrt_("I", n, &d__[1], info);

        } else {

/*              Use Selection Sort to minimize swaps of eigenvectors */

        // 使用选择排序算法以最小化特征向量的交换次数

        i__1 = *n;
        for (ii = 2; ii <= i__1; ++ii) {
            i__ = ii - 1;
            k = i__;
            p = d__[i__];
            i__2 = *n;
            for (j = ii; j <= i__2; ++j) {
            if (d__[j] < p) {
                k = j;
                p = d__[j];
            }
/* L30: */
            }
            if (k != i__) {
            d__[k] = d__[i__];
            d__[i__] = p;
            dswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k *
                z_dim1 + 1], &c__1);
            }
/* L40: */
        }
        }
    }
    }

L50:
    work[1] = (doublereal) lwmin;
    iwork[1] = liwmin;

    return 0;

/*     End of DSTEDC */

} /* dstedc_ */

/* Subroutine */ int dsteqr_(char *compz, integer *n, doublereal *d__,
    doublereal *e, doublereal *z__, integer *ldz, doublereal *work,
    integer *info)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal b, c__, f, g;
    static integer i__, j, k, l, m;
    static doublereal p, r__, s;
    static integer l1, ii, mm, lm1, mm1, nm1;
    static doublereal rt1, rt2, eps;
    static integer lsv;
    static doublereal tst, eps2;
    static integer lend, jtot;
    extern /* Subroutine */ int dlae2_(doublereal *, doublereal *, doublereal
        *, doublereal *, doublereal *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dlasr_(char *, char *, char *, integer *,
        integer *, doublereal *, doublereal *, doublereal *, integer *);
    static doublereal anorm;
    extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *,
        doublereal *, integer *), dlaev2_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *, doublereal *,
        doublereal *);
    static integer lendm1, lendp1;

    static integer iscale;
    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *), dlaset_(char *, integer *, integer
        *, doublereal *, doublereal *, doublereal *, integer *);
    static doublereal safmin;
    extern /* Subroutine */ int dlartg_(doublereal *, doublereal *,
        doublereal *, doublereal *, doublereal *);
    static doublereal safmax;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);


注释：

上面的注释详细解释了每个代码块的作用和功能，按照要求给出了对应的解释。
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, integer *);
    # 声明外部的名为 dlasrt_ 的子程序，其参数类型为 char *, integer *, doublereal *, integer *
    
    static integer lendsv;
    # 声明静态整数变量 lendsv
    
    static doublereal ssfmin;
    # 声明静态双精度浮点数变量 ssfmin
    
    static integer nmaxit, icompz;
    # 声明静态整数变量 nmaxit 和 icompz
    
    static doublereal ssfmax;
    # 声明静态双精度浮点数变量 ssfmax
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
    symmetric tridiagonal matrix using the implicit QL or QR method.
    The eigenvectors of a full or band symmetric matrix can also be found
    if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
    tridiagonal form.

    Arguments
    =========

    COMPZ   (input) CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.

    LDZ     (input) INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).

    WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.

    =====================================================================


       Test the input parameters.
*/
    /* Parameter adjustments */
    --d__;                              // 减小指向数组 d__ 的指针
    --e;                                // 减小指向数组 e 的指针
    z_dim1 = *ldz;                      // 设置 z_dim1 为 LDZ，矩阵 z 的第一维大小
    z_offset = 1 + z_dim1;              // 计算 z 数组的偏移量
    z__ -= z_offset;                    // 调整指向 z__ 的指针，指向 z 数组的首地址
    --work;                             // 减小指向数组 work 的指针

    /* Function Body */
    *info = 0;                          // 初始化 info 为 0

    if (lsame_(compz, "N")) {           // 判断 compz 是否为 "N"
        icompz = 0;                     // 设置 icompz 为 0
    } else if (lsame_(compz, "V")) {    // 判断 compz 是否为 "V"
        icompz = 1;                     // 设置 icompz 为 1
    } else if (lsame_(compz, "I")) {    // 判断 compz 是否为 "I"
        icompz = 2;                     // 设置 icompz 为 2
    } else {
        icompz = -1;                    // 设置 icompz 为 -1（表示未知选项）
    }
    if (icompz < 0) {                   // 如果 icompz 小于 0
        *info = -1;                     // 设置 info 为 -1（表示错误的参数）
    } else if (*n < 0) {                // 如果 n 小于 0
        *info = -2;                     // 设置 info 为 -2（表示错误的参数）
    } else if (*ldz < 1 || icompz > 0 && *ldz < max(1,*n)) {  // 如果 ldz 小于 1 或者 icompz 大于 0 且 ldz 小于 max(1, n)
        *info = -6;                     // 设置 info 为 -6（表示错误的参数）
    }
    if (*info != 0) {                   // 如果 info 不为 0（即有错误发生）
        i__1 = -(*info);                // 取 info 的负值
        xerbla_("DSTEQR", &i__1);       // 调用错误处理函数 xerbla_
        return 0;                       // 返回 0
    }

/*     Quick return if possible */

    if (*n == 0) {                      // 如果 n 等于 0
        return 0;                       // 直接返回 0
    }

    if (*n == 1) {                      // 如果 n 等于 1
        if (icompz == 2) {              // 如果 icompz 等于 2
            z__[z_dim1 + 1] = 1.;       // 设置 z__ 的第一个元素为 1.0
        }
        return 0;                       // 返回 0
    }

/*     Determine the unit roundoff and over/underflow thresholds. */

    eps = EPSILON;                      // 获取机器精度
    /* Computing 2nd power */
    d__1 = eps;                         // 计算 eps 的平方
    eps2 = d__1 * d__1;                 // 将计算结果赋值给 eps2
    safmin = SAFEMINIMUM;               // 获取安全最小值
    safmax = 1. / safmin;               // 计算安全最大值
    ssfmax = sqrt(safmax) / 3.;         // 计算 sqrt(safmax) / 3
    ssfmin = sqrt(safmin) / eps2;       // 计算 sqrt(safmin) / eps2

    /*
       Compute the eigenvalues and eigenvectors of the tridiagonal
       matrix.
    */

    if (icompz == 2) {                  // 如果 icompz 等于 2
        dlaset_("Full", n, n, &c_b29, &c_b15, &z__[z_offset], ldz);  // 初始化 z__ 为单位阵
    }

    nmaxit = *n * 30;                   // 设置最大迭代次数
    jtot = 0;                           // 初始化迭代计数器

    /*
       Determine where the matrix splits and choose QL or QR iteration
       for each block, according to whether top or bottom diagonal
       element is smaller.
    */

    l1 = 1;                             // 设置初始分裂位置
    nm1 = *n - 1;                       // 设置 n-1
L10:
    if (l1 > *n) {                      // 如果 l1 大于 n，跳转到 L160
        goto L160;
    }
    if (l1 > 1) {                       // 如果 l1 大于 1，将 e[l1-1] 设为 0
        e[l1 - 1] = 0.;
    }
    if (l1 <= nm1) {                    // 如果 l1 小于等于 n-1
        i__1 = nm1;
        for (m = l1; m <= i__1; ++m) {  // 遍历 m 从 l1 到 n-1
            tst = (d__1 = e[m], abs(d__1));  // 计算 e[m] 的绝对值
            if (tst == 0.) {            // 如果 tst 等于 0，跳转到 L30
                goto L30;
            }
            if (tst <= sqrt((d__1 = d__[m], abs(d__1))) * sqrt((d__2 = d__[m + 1], abs(d__2))) * eps) {  // 如果 tst 小于等于 sqrt(d[m] * d[m+1]) * eps，将 e[m] 设为 0，跳转到 L30
                e[m] = 0.;
                goto L30;
            }
            /* L20: */
        }
    }
    m = *n;

L30:
    l = l1;                             // 设置 l 为 l1
    lsv = l;                            // 保存 l 到 lsv
    lend = m;                           // 设置 lend 为 m
    lendsv = lend;                      // 保存 lend 到 lendsv
    l1 = m + 1;                         // 设置 l1 为 m+1
    if (lend == l) {                    // 如果 lend 等于 l，跳转到 L10
        goto L10;
    }

/*     Scale submatrix in rows and columns L to LEND */

    i__1 = lend - l + 1;                // 计算 lend - l + 1
    anorm = dlanst_("I", &i__1, &d__[l], &e[l]);  // 计算子矩阵的范数
    iscale = 0;                         // 初始化缩放指示器为 0
    if (anorm == 0.) {                  // 如果范数 anorm 等于 0，跳转到 L10
        goto L10;
    }
    if (anorm > ssfmax) {               // 如果范数 anorm 大于 ssfmax
        iscale = 1;                     // 设置缩放指示器为 1
        i__1 = lend - l + 1;
        dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n, info);  // 缩放 d[l:lend]
        i__1 = lend - l;
        dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n, info);  // 缩放 e[l:lend-1]
    } else if (anorm < ssfmin) {        // 如果范数 anorm 小于 ssfmin
        iscale = 2;                     // 设置缩放指示器为 2
        i__1 = lend - l + 1;
        dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n, info);  // 缩放 d[l:lend]
        i__1 = lend - l;
        dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n, info);  // 缩放 e[l:lend-1]
    }

/*     Choose between QL and QR iteration */
/*
          QL Iteration

          Look for small subdiagonal element.
*/
L40:
    // 检查是否 l 不等于 lend
    if (l != lend) {
        // 计算 lend - 1
        lendm1 = lend - 1;
        // 循环遍历 m 从 l 到 lend-1
        i__1 = lendm1;
        for (m = l; m <= i__1; ++m) {
            // 计算 e[m] 的绝对值的平方
            /* Computing 2nd power */
            d__2 = (d__1 = e[m], abs(d__1));
            tst = d__2 * d__2;
            // 判断是否满足特定条件
            if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m
                + 1], abs(d__2)) + safmin) {
                // 转到 L60
                goto L60;
            }
            // L50: 继续循环
        }
    }

    // 设置 m = lend
    m = lend;

L60:
    // 如果 m < lend，则将 e[m] 设置为 0
    if (m < lend) {
        e[m] = 0.;
    }
    // 将 p 设置为 d__[l]
    p = d__[l];
    // 如果 m == l，则转到 L80
    if (m == l) {
        goto L80;
    }

/*
          If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
          to compute its eigensystem.
*/

    // 如果 m == l + 1
    if (m == l + 1) {
        // 如果 icompz > 0，则调用 dlaev2_ 计算特定的特征值和特征向量
        if (icompz > 0) {
            dlaev2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2, &c__, &s);
            // 保存旋转信息
            work[l] = c__;
            work[*n - 1 + l] = s;
            // 应用旋转到矩阵 Z 的列
            dlasr_("R", "V", "B", n, &c__2, &work[l], &work[*n - 1 + l], &
                z__[l * z_dim1 + 1], ldz);
        } else {
            // 否则调用 dlae2_ 计算特定的特征值
            dlae2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2);
        }
        // 更新特征值和超对角元素
        d__[l] = rt1;
        d__[l + 1] = rt2;
        e[l] = 0.;
        // 更新 l，使得 l 指向下一个 2x2 子矩阵的起始点
        l += 2;
        // 如果 l <= lend，则转到 L40 继续迭代
        if (l <= lend) {
            goto L40;
        }
        // 否则转到 L140 结束迭代
        goto L140;
    }

    // 如果 jtot == nmaxit，则转到 L140 结束迭代
    if (jtot == nmaxit) {
        goto L140;
    }
    // 增加 jtot 计数
    ++jtot;

/*        Form shift. */

    // 计算 g
    g = (d__[l + 1] - p) / (e[l] * 2.);
    // 计算 r__
    r__ = dlapy2_(&g, &c_b15);
    // 计算 g
    g = d__[m] - p + e[l] / (g + d_sign(&r__, &g));

    // 初始化 s、c__、p
    s = 1.;
    c__ = 1.;
    p = 0.;

/*        Inner loop */

    // 循环处理内部操作
    mm1 = m - 1;
    i__1 = l;
    for (i__ = mm1; i__ >= i__1; --i__) {
        // 计算 f 和 b
        f = s * e[i__];
        b = c__ * e[i__];
        // 计算旋转角度并更新 e[i__+1]
        dlartg_(&g, &f, &c__, &s, &r__);
        if (i__ != m - 1) {
            e[i__ + 1] = r__;
        }
        // 更新 g 和 r__
        g = d__[i__ + 1] - p;
        r__ = (d__[i__] - g) * s + c__ * 2. * b;
        p = s * r__;
        d__[i__ + 1] = g + p;
        g = c__ * r__ - b;

        // 如果需要计算特征向量，则保存旋转信息
        if (icompz > 0) {
            work[i__] = c__;
            work[*n - 1 + i__] = -s;
        }

        // L70: 继续循环
    }

/*        If eigenvectors are desired, then apply saved rotations. */

    // 如果需要计算特征向量，则应用保存的旋转信息到矩阵 Z
    if (icompz > 0) {
        mm = m - l + 1;
        dlasr_("R", "V", "B", n, &mm, &work[l], &work[*n - 1 + l], &z__[l
            * z_dim1 + 1], ldz);
    }

    // 更新 d__[l] 和 e[l]
    d__[l] -= p;
    e[l] = g;
    // 转到 L40 继续迭代
    goto L40;

/*        Eigenvalue found. */

L80:
    // 将 d__[l] 设置为 p
    d__[l] = p;

    // 增加 l
    ++l;
    // 如果 l <= lend，则转到 L40 继续迭代
    if (l <= lend) {
        goto L40;
    }
    // 否则转到 L140 结束迭代
    goto L140;

    } else {

/*
          QR Iteration

          Look for small superdiagonal element.
*/
L90:
    // 检查是否 l 不等于 lend
    if (l != lend) {
        // 计算 lend + 1
        lendp1 = lend + 1;
        // 循环遍历 m 从 l 到 lend+1
        i__1 = lendp1;
        for (m = l; m >= i__1; --m) {
            // 计算 e[m-1] 的绝对值的平方
            /* Computing 2nd power */
            d__2 = (d__1 = e[m - 1], abs(d__1));
            tst = d__2 * d__2;
            // 判断是否满足特定条件
            if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m
                - 1], abs(d__2)) + safmin) {
                // 转到 L110
                goto L110;
            }
            // L100: 继续循环
        }
    }

    // 设置 m = lend
    m = lend;

L110:
    // 如果 m > lend，则将 e[m-1] 设置为 0
    if (m > lend) {
        e[m - 1] = 0.;
    }
    }
    # 将字典 d__ 中索引为 l 的值赋给变量 p
    p = d__[l];
    # 如果 m 等于 l，则跳转到标签 L130
    if (m == l) {
        goto L130;
    }
/*
          如果剩余的矩阵是2×2的，则使用DLAE2或SLAEV2计算其特征系统。
*/

if (m == l - 1) {
    if (icompz > 0) {
        // 使用DLAEV2计算2×2矩阵的特征值和特征向量
        dlaev2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2, &c__, &s);
        // 保存旋转参数
        work[m] = c__;
        work[*n - 1 + m] = s;
        // 应用旋转到Z矩阵上
        dlasr_("R", "V", "F", n, &c__2, &work[m], &work[*n - 1 + m], &z__[(l - 1) * z_dim1 + 1], ldz);
    } else {
        // 使用DLAE2计算2×2矩阵的特征值
        dlae2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2);
    }
    // 更新对角元素和下对角元素
    d__[l - 1] = rt1;
    d__[l] = rt2;
    e[l - 1] = 0.;
    l += -2;
    if (l >= lend) {
        goto L90;
    }
    goto L140;
}

if (jtot == nmaxit) {
    goto L140;
}
++jtot;

/*        计算位移量。 */

g = (d__[l - 1] - p) / (e[l - 1] * 2.);
r__ = dlapy2_(&g, &c_b15);
g = d__[m] - p + e[l - 1] / (g + d_sign(&r__, &g));

s = 1.;
c__ = 1.;
p = 0.;

/*        内循环 */

lm1 = l - 1;
i__1 = lm1;
for (i__ = m; i__ <= i__1; ++i__) {
    f = s * e[i__];
    b = c__ * e[i__];
    // 计算Givens旋转参数
    dlartg_(&g, &f, &c__, &s, &r__);
    if (i__ != m) {
        e[i__ - 1] = r__;
    }
    g = d__[i__] - p;
    r__ = (d__[i__ + 1] - g) * s + c__ * 2. * b;
    p = s * r__;
    d__[i__] = g + p;
    g = c__ * r__ - b;

    // 如果需要计算特征向量，保存旋转参数
    if (icompz > 0) {
        work[i__] = c__;
        work[*n - 1 + i__] = s;
    }
}

/*        如果需要计算特征向量，应用保存的旋转参数。 */

if (icompz > 0) {
    mm = l - m + 1;
    dlasr_("R", "V", "F", n, &mm, &work[m], &work[*n - 1 + m], &z__[m * z_dim1 + 1], ldz);
}

d__[l] -= p;
e[lm1] = g;
goto L90;

/*        找到一个特征值。 */

L130:
d__[l] = p;

--l;
if (l >= lend) {
    goto L90;
}
goto L140;

}

/*     如有必要，撤销缩放 */

L140:
if (iscale == 1) {
    i__1 = lendsv - lsv + 1;
    // 反向应用缩放因子到特征值数组D
    dlascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv], n, info);
    i__1 = lendsv - lsv;
    // 反向应用缩放因子到下对角元素数组E
    dlascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &e[lsv], n, info);
} else if (iscale == 2) {
    i__1 = lendsv - lsv + 1;
    // 反向应用缩放因子到特征值数组D
    dlascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv], n, info);
    i__1 = lendsv - lsv;
    // 反向应用缩放因子到下对角元素数组E
    dlascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &e[lsv], n, info);
}

/*
       检查是否在总计N*MAXIT次迭代后没有收敛到一个特征值。
*/

if (jtot < nmaxit) {
    goto L10;
}
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
    if (e[i__] != 0.) {
        ++(*info);
    }
}

/* L150: */
goto L190;

/*     对特征值和特征向量进行排序。 */

L160:
if (icompz == 0) {

/*        使用快速排序 */

    dlasrt_("I", n, &d__[1], info);

} else {

/*        使用选择排序以最小化特征向量的交换 */
    i__1 = *n;
    # 将指针 n 指向的值赋给 i__1，表示循环的上限
    for (ii = 2; ii <= i__1; ++ii) {
        # 从 ii = 2 开始循环到 i__1，每次增加 ii 的值
        i__ = ii - 1;
        # 设置 i__ 为 ii 减去 1，用于后续比较
        k = i__;
        # 将 k 设为 i__，作为最小值索引的初始值
        p = d__[i__];
        # 将 p 设为 d__ 数组中索引为 i__ 的元素值，作为当前最小值的初始值
        i__2 = *n;
        # 将指针 n 指向的值赋给 i__2，表示内部循环的上限
        for (j = ii; j <= i__2; ++j) {
        # 从 j = ii 开始循环到 i__2，每次增加 j 的值
        if (d__[j] < p) {
            # 如果 d__ 数组中索引为 j 的元素值小于 p，则执行以下操作
            k = j;
            # 将 k 更新为 j，表示找到了新的最小值的索引
            p = d__[j];
            # 将 p 更新为 d__ 数组中索引为 j 的元素值，作为新的最小值
        }
/* L170: */
        }
        if (k != i__) {
        d__[k] = d__[i__];
        d__[i__] = p;
        dswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1 + 1],
             &c__1);
        }
/* L180: */
    }
    }

L190:
    return 0;

/*     End of DSTEQR */

} /* dsteqr_ */

/* Subroutine */ int dsterf_(integer *n, doublereal *d__, doublereal *e,
    integer *info)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    static doublereal c__;
    static integer i__, l, m;
    static doublereal p, r__, s;
    static integer l1;
    static doublereal bb, rt1, rt2, eps, rte;
    static integer lsv;
    static doublereal eps2, oldc;
    static integer lend, jtot;
    extern /* Subroutine */ int dlae2_(doublereal *, doublereal *, doublereal
        *, doublereal *, doublereal *);
    static doublereal gamma, alpha, sigma, anorm;

    static integer iscale;
    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *);
    static doublereal oldgam, safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal safmax;
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *,
        integer *);
    static integer lendsv;
    static doublereal ssfmin;
    static integer nmaxit;
    static doublereal ssfmax;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
    using the Pal-Walker-Kahan variant of the QL or QR algorithm.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm failed to find all of the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero.

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    --e;
    --d__;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */


注释部分：


/* L170: */
        }
        if (k != i__) {
        d__[k] = d__[i__];
        d__[i__] = p;
        dswap_(n, &z__[i__ * z_dim1 + 1], &c__1, &z__[k * z_dim1 + 1],
             &c__1);
        }
/* L180: */
    }
    }

L190:
    return 0;

/*     End of DSTEQR */

} /* dsteqr_ */

/* Subroutine */ int dsterf_(integer *n, doublereal *d__, doublereal *e,
    integer *info)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    static doublereal c__;
    static integer i__, l, m;
    static doublereal p, r__, s;
    static integer l1;
    static doublereal bb, rt1, rt2, eps, rte;
    static integer lsv;
    static doublereal eps2, oldc;
    static integer lend, jtot;
    extern /* Subroutine */ int dlae2_(doublereal *, doublereal *, doublereal
        *, doublereal *, doublereal *);
    static doublereal gamma, alpha, sigma, anorm;

    static integer iscale;
    extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, integer *, doublereal *,
        integer *, integer *);
    static doublereal oldgam, safmin;
    extern /* Subroutine */ int xerbla_(char *, integer *);
    static doublereal safmax;
    extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *,
        integer *);
    static integer lendsv;
    static doublereal ssfmin;
    static integer nmaxit;
    static doublereal ssfmax;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
    using the Pal-Walker-Kahan variant of the QL or QR algorithm.

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix.  N >= 0.

    D       (input/output) DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.

    E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm failed to find all of the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero.

    =====================================================================


       Test the input parameters.
*/

    /* Parameter adjustments */
    --e;
    --d__;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */


这段代码是 Fortran 语言的一部分，主要用于计算对称三对角矩阵的所有特征值。
    # 检查输入参数 n 是否小于 0
    if (*n < 0) {
        # 如果 n 小于 0，将 info 设置为 -1，表示错误状态
        *info = -1;
        # 调用 xerbla_ 函数报告错误并返回
        i__1 = -(*info);
        xerbla_("DSTERF", &i__1);
        return 0;
    }
    # 检查输入参数 n 是否小于等于 1
    if (*n <= 1) {
        # 如果 n 小于等于 1，直接返回，不做任何处理
        return 0;
    }
/* Determine the unit roundoff for this environment. */
eps = EPSILON;
/* Computing 2nd power */
d__1 = eps;
eps2 = d__1 * d__1;
safmin = SAFEMINIMUM;
safmax = 1. / safmin;
ssfmax = sqrt(safmax) / 3.;
ssfmin = sqrt(safmin) / eps2;

/* Compute the eigenvalues of the tridiagonal matrix. */

nmaxit = *n * 30;
sigma = 0.;
jtot = 0;

/*
   Determine where the matrix splits and choose QL or QR iteration
   for each block, according to whether top or bottom diagonal
   element is smaller.
*/

l1 = 1;

L10:
if (l1 > *n) {
goto L170;
}
if (l1 > 1) {
e[l1 - 1] = 0.;
}
i__1 = *n - 1;
for (m = l1; m <= i__1; ++m) {
if ((d__3 = e[m], abs(d__3)) <= sqrt((d__1 = d__[m], abs(d__1))) *
    sqrt((d__2 = d__[m + 1], abs(d__2))) * eps) {
    e[m] = 0.;
    goto L30;
}
/* L20: */
}
m = *n;

L30:
l = l1;
lsv = l;
lend = m;
lendsv = lend;
l1 = m + 1;
if (lend == l) {
goto L10;
}

/* Scale submatrix in rows and columns L to LEND */

i__1 = lend - l + 1;
anorm = dlanst_("I", &i__1, &d__[l], &e[l]);
iscale = 0;
if (anorm > ssfmax) {
iscale = 1;
i__1 = lend - l + 1;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &d__[l], n,
    info);
i__1 = lend - l;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmax, &i__1, &c__1, &e[l], n,
    info);
} else if (anorm < ssfmin) {
iscale = 2;
i__1 = lend - l + 1;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &d__[l], n,
    info);
i__1 = lend - l;
dlascl_("G", &c__0, &c__0, &anorm, &ssfmin, &i__1, &c__1, &e[l], n,
    info);
}

i__1 = lend - 1;
for (i__ = l; i__ <= i__1; ++i__) {
/* Computing 2nd power */
d__1 = e[i__];
e[i__] = d__1 * d__1;
/* L40: */
}

/* Choose between QL and QR iteration */

if ((d__1 = d__[lend], abs(d__1)) < (d__2 = d__[l], abs(d__2))) {
lend = lsv;
l = lendsv;
}

if (lend >= l) {

/*
  QL Iteration

  Look for small subdiagonal element.
*/

L50:
if (l != lend) {
i__1 = lend - 1;
for (m = l; m <= i__1; ++m) {
if ((d__2 = e[m], abs(d__2)) <= eps2 * (d__1 = d__[m] * d__[m
    + 1], abs(d__1))) {
    goto L70;
}
/* L60: */
}
}
m = lend;

L70:
if (m < lend) {
e[m] = 0.;
}
p = d__[l];
if (m == l) {
goto L90;
}

/*
  If remaining matrix is 2 by 2, use DLAE2 to compute its
  eigenvalues.
*/

if (m == l + 1) {
rte = sqrt(e[l]);
dlae2_(&d__[l], &rte, &d__[l + 1], &rt1, &rt2);
d__[l] = rt1;
d__[l + 1] = rt2;
e[l] = 0.;
l += 2;
if (l <= lend) {
goto L50;
}
goto L150;
}

if (jtot == nmaxit) {
goto L150;
}
++jtot;

/* Form shift. */

rte = sqrt(e[l]);
    # 计算 sigma 的值，sigma 是一个浮点数，表示在当前循环中的计算结果
    sigma = (d__[l + 1] - p) / (rte * 2.);
    # 使用 dlapy2_ 函数计算 r__ 的值，dlapy2_ 是一个特定的数学函数或者子程序
    r__ = dlapy2_(&sigma, &c_b15);
    # 更新 sigma 的值，使用 d_sign 函数调整符号
    sigma = p - rte / (sigma + d_sign(&r__, &sigma));

    # 初始化 c__ 为 1
    c__ = 1.;
    # 初始化 s 为 0
    s = 0.;
    # 计算 gamma 的值，gamma 是一个浮点数，表示在当前循环中的计算结果
    gamma = d__[m] - sigma;
    # 计算 p 的值，p 是一个浮点数，表示在当前循环中的计算结果
    p = gamma * gamma;
/*        Inner loop */

/* 循环从 m-1 到 l，处理矩阵的特征值计算 */
i__1 = l;
for (i__ = m - 1; i__ >= i__1; --i__) {
    bb = e[i__];  /* 取出数组 e 中的元素 */
    r__ = p + bb;  /* 计算 p 和 bb 的和赋值给 r__ */
    if (i__ != m - 1) {
        e[i__ + 1] = s * r__;  /* 如果 i__ 不是 m-1，则更新 e[i__+1] */
    }
    oldc = c__;  /* 保存旧的 c__ 值 */
    c__ = p / r__;  /* 计算 p/r__ 的结果赋值给 c__ */
    s = bb / r__;  /* 计算 bb/r__ 的结果赋值给 s */
    oldgam = gamma;  /* 保存旧的 gamma 值 */
    alpha = d__[i__];  /* 取出数组 d__ 中的元素 */
    gamma = c__ * (alpha - sigma) - s * oldgam;  /* 计算 gamma 的新值 */
    d__[i__ + 1] = oldgam + (alpha - gamma);  /* 更新数组 d__ 中的元素 */
    if (c__ != 0.) {
        p = gamma * gamma / c__;  /* 根据 gamma 和 c__ 计算 p 的新值 */
    } else {
        p = oldc * bb;  /* 如果 c__ 为 0，则使用 oldc * bb 计算 p 的新值 */
    }
/* L80: */
}

e[l] = s * p;  /* 更新数组 e 中的元素 */
d__[l] = sigma + gamma;  /* 更新数组 d__ 中的元素 */
goto L50;  /* 跳转到标签 L50 处 */

/*        Eigenvalue found. */

L90:
d__[l] = p;  /* 更新数组 d__ 中的元素 */

++l;  /* l 自增 */
if (l <= lend) {
    goto L50;  /* 如果 l <= lend，则跳转到标签 L50 处 */
}
goto L150;  /* 否则跳转到标签 L150 处 */

} else {

/*
      QR Iteration

      Look for small superdiagonal element.
*/

L100:
i__1 = lend + 1;
for (m = l; m >= i__1; --m) {
    if ((d__2 = e[m - 1], abs(d__2)) <= eps2 * (d__1 = d__[m] * d__[m
        - 1], abs(d__1))) {
    goto L120;  /* 如果满足条件则跳转到标签 L120 处 */
    }
/* L110: */
}
m = lend;  /* 更新 m 的值 */

L120:
if (m > lend) {
    e[m - 1] = 0.;  /* 如果 m > lend，则更新数组 e 中的元素 */
}
p = d__[l];  /* 取出数组 d__ 中的元素 */
if (m == l) {
    goto L140;  /* 如果 m == l，则跳转到标签 L140 处 */
}

/*
      If remaining matrix is 2 by 2, use DLAE2 to compute its
      eigenvalues.
*/

if (m == l - 1) {
    rte = sqrt(e[l - 1]);  /* 计算 e[l-1] 的平方根赋值给 rte */
    dlae2_(&d__[l], &rte, &d__[l - 1], &rt1, &rt2);  /* 调用函数 dlae2 计算特征值 */
    d__[l] = rt1;  /* 更新数组 d__ 中的元素 */
    d__[l - 1] = rt2;  /* 更新数组 d__ 中的元素 */
    e[l - 1] = 0.;  /* 更新数组 e 中的元素 */
    l += -2;  /* l 减去 2 */
    if (l >= lend) {
    goto L100;  /* 如果 l >= lend，则跳转到标签 L100 处 */
    }
    goto L150;  /* 否则跳转到标签 L150 处 */
}

if (jtot == nmaxit) {
    goto L150;  /* 如果 jtot 等于 nmaxit，则跳转到标签 L150 处 */
}
++jtot;  /* jtot 自增 */

/*        Form shift. */

rte = sqrt(e[l - 1]);  /* 计算 e[l-1] 的平方根赋值给 rte */
sigma = (d__[l - 1] - p) / (rte * 2.);  /* 计算 sigma 的新值 */
r__ = dlapy2_(&sigma, &c_b15);  /* 调用函数 dlapy2 计算 r__ 的新值 */
sigma = p - rte / (sigma + d_sign(&r__, &sigma));  /* 计算 sigma 的新值 */

c__ = 1.;  /* 初始化 c__ 为 1 */
s = 0.;  /* 初始化 s 为 0 */
gamma = d__[m] - sigma;  /* 计算 gamma 的新值 */
p = gamma * gamma;  /* 计算 p 的新值 */

/*        Inner loop */

i__1 = l - 1;
for (i__ = m; i__ <= i__1; ++i__) {
    bb = e[i__];  /* 取出数组 e 中的元素 */
    r__ = p + bb;  /* 计算 p 和 bb 的和赋值给 r__ */
    if (i__ != m) {
    e[i__ - 1] = s * r__;  /* 如果 i__ 不是 m，则更新 e[i__-1] */
    }
    oldc = c__;  /* 保存旧的 c__ 值 */
    c__ = p / r__;  /* 计算 p/r__ 的结果赋值给 c__ */
    s = bb / r__;  /* 计算 bb/r__ 的结果赋值给 s */
    oldgam = gamma;  /* 保存旧的 gamma 值 */
    alpha = d__[i__ + 1];  /* 取出数组 d__ 中的元素 */
    gamma = c__ * (alpha - sigma) - s * oldgam;  /* 计算 gamma 的新值 */
    d__[i__] = oldgam + (alpha - gamma);  /* 更新数组 d__ 中的元素 */
    if (c__ != 0.) {
    p = gamma * gamma / c__;  /* 根据 gamma 和 c__ 计算 p 的新值 */
    } else {
    p = oldc * bb;  /* 如果 c__ 为 0，则使用 oldc * bb 计算 p 的新值 */
    }
/* L130: */
}

e[l - 1] = s * p;  /* 更新数组 e 中的元素 */
d__[l] = sigma + gamma;  /* 更新数组 d__ 中的元素 */
goto L100;  /* 跳转到标签 L100 处 */

/*        Eigenvalue found. */

L140:
d__[l] = p;  /* 更新数组 d__ 中的元素 */

--l;  /* l 自减 */
if (l >= lend) {
    goto L100;  /* 如果 l >= lend，则跳转到标签 L100 处 */
}
goto L150;  /* 否则跳转到标签 L150 处 */

}

/*     Undo scaling if necessary */

L150:
if (iscale == 1) {
i__1 = lendsv - lsv + 1;
dlascl_("G", &c__0, &c__0, &ssfmax, &anorm, &i__1, &c__1, &d__[lsv],
    n, info);  /* 调用函数 dlascl 进行数组 d__ 的反缩放 */
}
if (iscale == 2) {
i__1 = lendsv - lsv + 1;
dlascl_("G", &c__0, &c__0, &ssfmin, &anorm, &i__1, &c__1, &d__[lsv],
    n, info);  /* 调用函数 dlascl 进行数组 d__ 的反缩放 */
}
/*
   Check for no convergence to an eigenvalue after a total
   of N*MAXIT iterations.
*/
if (jtot < nmaxit) {
goto L10;
}
i__1 = *n - 1;
for (i__ = 1; i__ <= i__1; ++i__) {
if (e[i__] != 0.) {
++(*info);
}
/* L160: */
}
goto L180;

/* Sort eigenvalues in increasing order. */
L170:
dlasrt_("I", n, &d__[1], info);

L180:
return 0;

/* End of DSTERF */
} /* dsterf_ */

/* Subroutine */ int dsyevd_(char *jobz, char *uplo, integer *n, doublereal *
a, integer *lda, doublereal *w, doublereal *work, integer *lwork,
integer *iwork, integer *liwork, integer *info)
{
/* System generated locals */
integer a_dim1, a_offset, i__1, i__2, i__3;
doublereal d__1;

/* Local variables */
static doublereal eps;
static integer inde;
static doublereal anrm, rmin, rmax;
static integer lopt;
extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
    integer *);
static doublereal sigma;
extern logical lsame_(char *, char *);
static integer iinfo, lwmin, liopt;
static logical lower, wantz;
static integer indwk2, llwrk2;

static integer iscale;
extern /* Subroutine */ int dlascl_(char *, integer *, integer *,
    doublereal *, doublereal *, integer *, integer *, doublereal *,
    integer *, integer *), dstedc_(char *, integer *,
    doublereal *, doublereal *, doublereal *, integer *, doublereal *,
     integer *, integer *, integer *, integer *), dlacpy_(
    char *, integer *, integer *, doublereal *, integer *, doublereal
    *, integer *);
static doublereal safmin;
extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
    integer *, integer *, ftnlen, ftnlen);
extern /* Subroutine */ int xerbla_(char *, integer *);
static doublereal bignum;
static integer indtau;
extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *,
     integer *);
extern doublereal dlansy_(char *, char *, integer *, doublereal *,
    integer *, doublereal *);
static integer indwrk, liwmin;
extern /* Subroutine */ int dormtr_(char *, char *, char *, integer *,
    integer *, doublereal *, integer *, doublereal *, doublereal *,
    integer *, doublereal *, integer *, integer *), dsytrd_(char *, integer *, doublereal *, integer *,
    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
     integer *);
static integer llwork;
static doublereal smlnum;
static logical lquery;

/*
-- LAPACK driver routine (version 3.2) --
-- LAPACK is a software package provided by Univ. of Tennessee,    --
-- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   November 2006


Purpose
=======

DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
real symmetric matrix A. If eigenvectors are desired, it uses a
*/
    divide and conquer algorithm.

    The divide and conquer algorithm makes very mild assumptions about
    floating point arithmetic. It will work on machines with a guard
    digit in add/subtract, or on those binary machines without guard
    digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
    Cray-2. It could conceivably fail on hexadecimal or decimal machines
    without guard digits, but we know of none.

    Because of large use of BLAS of level 3, DSYEVD needs N**2 more
    workspace than DSYEVX.

    Arguments
    =========

    JOBZ    (input) CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    W       (output) DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.

    WORK    (workspace/output) DOUBLE PRECISION array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            If N <= 1,               LWORK must be at least 1.
            If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
            If JOBZ = 'V' and N > 1, LWORK must be at least
                                                  1 + 6*N + 2*N**2.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK and IWORK
            arrays, returns these values as the first entries of the WORK
            and IWORK arrays, and no error message related to LWORK or
            LIWORK is issued by XERBLA.

    IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
    # LIWORK（输入）整数
    #     IWORK 数组的维度。
    #     如果 N <= 1，则 LIWORK 必须至少为 1。
    #     如果 JOBZ = 'N' 且 N > 1，则 LIWORK 必须至少为 1。
    #     如果 JOBZ = 'V' 且 N > 1，则 LIWORK 必须至少为 3 + 5*N。
    # 
    #     如果 LIWORK = -1，则假定为工作空间查询；例程仅计算 WORK 和 IWORK 数组的最优大小，
    #     将这些值作为 WORK 和 IWORK 数组的第一个条目返回，并且 XERBLA 不会发出与 LWORK 或 LIWORK 相关的错误消息。
    LIWORK  (input) INTEGER

    # INFO（输出）整数
    #     = 0：成功退出
    #     < 0：如果 INFO = -i，则第 i 个参数具有非法值
    #     > 0：如果 INFO = i 且 JOBZ = 'N'，则算法未能收敛；
    #          某些中间三对角形式的非对角线元素未收敛于零；
    #          如果 INFO = i 且 JOBZ = 'V'，则算法未能计算一个特征值，
    #          当处理位于行和列 INFO/(N+1) 到 mod(INFO,N+1) 的子矩阵时。
    # 
    #     进一步细节
    #     ===============
    # 
    #     基于以下贡献
    #        Jeff Rutter，加利福尼亚大学伯克利分校计算机科学系，美国
    #     由 Francoise Tisseur 修改，田纳西大学。
    # 
    #     修改 INFO 的描述。Sven，2005年2月16日。
    INFO    (output) INTEGER
```fort`
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --w;
    --work;
    --iwork;

    /* Function Body */
    /* 判断是否需要计算特征向量 */
    wantz = lsame_(jobz, "V");
    /* 判断是否是下三角矩阵 */
    lower = lsame_(uplo, "L");
    /* 判断是否仅查询所需的工作空间大小 */
    lquery = *lwork == -1 || *liwork == -1;

    /* 初始化错误信息 */
    *info = 0;
    /* 检查 jobz 参数的合法性 */
    if (! (wantz || lsame_(jobz, "N"))) {
        *info = -1;
    } else if (! (lower || lsame_(uplo, "U"))) {
        /* 检查 uplo 参数的合法性 */
        *info = -2;
    } else if (*n < 0) {
        /* 检查矩阵维度 n 的合法性 */
        *info = -3;
    } else if (*lda < max(1,*n)) {
        /* 检查 lda 参数的合法性 */
        *info = -5;
    }

    /* 计算所需的工作空间大小 */
    if (*info == 0) {
        if (*n <= 1) {
            liwmin = 1;
            lwmin = 1;
            lopt = lwmin;
            liopt = liwmin;
        } else {
            /* 计算需要的工作空间大小，对于求特征向量的情况 */
            if (wantz) {
                liwmin = *n * 5 + 3;
                /* 计算 lwmin，特征值和特征向量 */
                /* 计算二次幂 */
                i__1 = *n;
                lwmin = *n * 6 + 1 + (i__1 * i__1 << 1);
            } else {
                /* 对于不求特征向量的情况 */
                liwmin = 1;
                lwmin = (*n << 1) + 1;
            }
            /* 计算最优工作空间大小 */
            /* 计算 lwmin 和 ilaenv_ 函数返回的大小的最大值 */
            i__1 = lwmin, i__2 = (*n << 1) + ilaenv_(&c__1, "DSYTRD", uplo, n,
                 &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)1);
            lopt = max(i__1,i__2);
            liopt = liwmin;
        }
        /* 将最优工作空间大小存入 work 和 iwork 数组的第一个元素 */
        work[1] = (doublereal) lopt;
        iwork[1] = liopt;

        /* 检查实际可用的工作空间是否足够 */
        if (*lwork < lwmin && ! lquery) {
            *info = -8;
        } else if (*liwork < liwmin && ! lquery) {
            *info = -10;
        }
    }

    /* 如果有错误信息，调用错误处理函数并返回 */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DSYEVD", &i__1);
        return 0;
    } else if (lquery) {
        /* 如果仅查询工作空间大小，直接返回 */
        return 0;
    }

    /* 如果 n 为 0，直接返回 */
    /* 如果 n 为 1，直接计算特征值和特征向量 */
    if (*n == 0) {
        return 0;
    }

    if (*n == 1) {
        /* n 为 1 时的特殊情况处理 */
        w[1] = a[a_dim1 + 1];
        if (wantz) {
            a[a_dim1 + 1] = 1.;
        }
        return 0;
    }

    /* 获取机器常数 */
    safmin = SAFEMINIMUM;
    eps = PRECISION;
    smlnum = safmin / eps;
    bignum = 1. / smlnum;
    rmin = sqrt(smlnum);
    rmax = sqrt(bignum);

    /* 将矩阵缩放到允许的范围 */
    anrm = dlansy_("M", uplo, n, &a[a_offset], lda, &work[1]);
    iscale = 0;
    if (anrm > 0. && anrm < rmin) {
        iscale = 1;
        sigma = rmin / anrm;
    } else if (anrm > rmax) {
        iscale = 1;
        sigma = rmax / anrm;
    }
    /* 如果需要缩放矩阵，调用缩放函数 dlascl_ */
    if (iscale == 1) {
        dlascl_(uplo, &c__0, &c__0, &c_b15, &sigma, n, n, &a[a_offset], lda,
            info);
    }

    /* 调用 DSYTRD 函数将对称矩阵转化为三对角形式 */
    inde = 1;
    indtau = inde + *n;
    indwrk = indtau + *n;
    llwork = *lwork - indwrk + 1;
    indwk2 = indwrk + *n * *n;
    llwrk2 = *lwork - indwk2 + 1;

    dsytrd_(uplo, n, &a[a_offset], lda, &w[1], &work[inde], &work[indtau], &
        work[indwrk], &llwork, &iinfo);
    /* 计算实际所需工作空间大小 */
    lopt = (integer) ((*n << 1) + work[indwrk]);

    /*
       仅计算特征值时，调用 DSTERF 函数。
       若需计算特征向量，则首先调用 DSTEDC 生成三对角矩阵的特征向量矩阵 WORK(INDWRK)，
       然后调用 DORMTR 将其乘以存储在 A 中的 Householder 变换。
    */
    if (! wantz) {
        dsterf_(n, &w[1], &work[inde], info);
    } else {
    ! 调用 LAPACK 库中的 DSTEDC 函数，求解对称特征值问题
    dstedc_("I", n, &w[1], &work[inde], &work[indwrk], n, &work[indwk2], &
        llwrk2, &iwork[1], liwork, info);
    ! 调用 LAPACK 库中的 DORMTR 函数，对矩阵进行乘积运算
    dormtr_("L", uplo, "N", n, n, &a[a_offset], lda, &work[indtau], &work[
        indwrk], n, &work[indwk2], &llwrk2, &iinfo);
    ! 调用 LAPACK 库中的 DLACPY 函数，复制矩阵的内容
    dlacpy_("A", n, n, &work[indwrk], n, &a[a_offset], lda);
/*
   Computing MAX
   Computing 2nd power
*/
    i__3 = *n;
    // Calculate the length of array lopt based on the value of n
    i__1 = lopt, i__2 = *n * 6 + 1 + (i__3 * i__3 << 1);
    lopt = max(i__1,i__2);
    }

/*     If matrix was scaled, then rescale eigenvalues appropriately. */

    if (iscale == 1) {
    // Scale eigenvalues by dividing each element in w by sigma
    d__1 = 1. / sigma;
    dscal_(n, &d__1, &w[1], &c__1);
    }

    // Store the value of lopt in the first element of array work
    work[1] = (doublereal) lopt;
    // Store the value of liopt in the first element of array iwork
    iwork[1] = liopt;

    // Return 0 to indicate successful execution

    return 0;

/*     End of DSYEVD */

} /* dsyevd_ */

/* Subroutine */ int dsytd2_(char *uplo, integer *n, doublereal *a, integer *
    lda, doublereal *d__, doublereal *e, doublereal *tau, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__;
    // Local variable to store the value of taui
    static doublereal taui;
    // Local variable to store the value of alpha
    static doublereal alpha;
    // Logical variable to check if UPLO is upper
    static logical upper;
    extern doublereal ddot_(integer *, doublereal *, integer *, doublereal *,
        integer *);
    extern /* Subroutine */ int dsyr2_(char *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        integer *);
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int daxpy_(integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *);
    extern /* Subroutine */ int dsymv_(char *, integer *, doublereal *,
        doublereal *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, integer *), dlarfg_(integer *, doublereal *,
         doublereal *, integer *, doublereal *), xerbla_(char *, integer *
        );


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
    form T by an orthogonal similarity transformation: Q' * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
*/


The annotations follow the structure and format required, providing clear explanations for each line of code within the specified block.
    ! A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
    !         On entry, the symmetric matrix A.  If UPLO = 'U', the leading
    !         n-by-n upper triangular part of A contains the upper
    !         triangular part of the matrix A, and the strictly lower
    !         triangular part of A is not referenced.  If UPLO = 'L', the
    !         leading n-by-n lower triangular part of A contains the lower
    !         triangular part of the matrix A, and the strictly upper
    !         triangular part of A is not referenced.
    !         On exit, if UPLO = 'U', the diagonal and first superdiagonal
    !         of A are overwritten by the corresponding elements of the
    !         tridiagonal matrix T, and the elements above the first
    !         superdiagonal, with the array TAU, represent the orthogonal
    !         matrix Q as a product of elementary reflectors; if UPLO
    !         = 'L', the diagonal and first subdiagonal of A are over-
    !         written by the corresponding elements of the tridiagonal
    !         matrix T, and the elements below the first subdiagonal, with
    !         the array TAU, represent the orthogonal matrix Q as a product
    !         of elementary reflectors. See Further Details.

    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(1,N).

    ! D       (output) DOUBLE PRECISION array, dimension (N)
    !         The diagonal elements of the tridiagonal matrix T:
    !         D(i) = A(i,i).

    ! E       (output) DOUBLE PRECISION array, dimension (N-1)
    !         The off-diagonal elements of the tridiagonal matrix T:
    !         E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

    ! TAU     (output) DOUBLE PRECISION array, dimension (N-1)
    !         The scalar factors of the elementary reflectors (see Further
    !         Details).

    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument had an illegal value.

    ! Further Details
    ! ===============

    ! If UPLO = 'U', the matrix Q is represented as a product of elementary
    ! reflectors

    !    Q = H(n-1) . . . H(2) H(1).

    ! Each H(i) has the form

    !    H(i) = I - tau * v * v'

    ! where tau is a real scalar, and v is a real vector with
    ! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    ! A(1:i-1,i+1), and tau in TAU(i).

    ! If UPLO = 'L', the matrix Q is represented as a product of elementary
    ! reflectors

    !    Q = H(1) H(2) . . . H(n-1).

    ! Each H(i) has the form

    !    H(i) = I - tau * v * v'

    ! where tau is a real scalar, and v is a real vector with
    ! v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
    ! and tau in TAU(i).

    ! The contents of A on exit are illustrated by the following examples
    ! with n = 5:
    # 如果 UPLO 等于 'U'，即上三角矩阵的情况
    if UPLO = 'U':

      # 矩阵 T 的对角线和非对角线元素
      (  d   e   v2  v3  v4 )
      (      d   e   v3  v4 )
      (          d   e   v4 )
      (              d   e  )
      (                  d  )

    # 如果 UPLO 等于 'L'，即下三角矩阵的情况
    if UPLO = 'L':

      # 矩阵 T 的对角线和非对角线元素
      (  d                  )
      (  e   d              )
      (  v1  e   d          )
      (  v1  v2  e   d      )
      (  v1  v2  v3  e   d  )

    where d and e denote diagonal and off-diagonal elements of T, and vi
    denotes an element of the vector defining H(i).

    =====================================================================


    # 检查输入参数的有效性
       Test the input parameters
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0，用于记录函数执行状态
    upper = lsame_(uplo, "U");  // 判断 uplo 是否为 "U"（上三角）并将结果存入 upper
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 uplo 不是 "U" 也不是 "L"，则设置 info 为 -1
        *info = -1;
    } else if (*n < 0) {  // 如果 n 小于 0，设置 info 为 -2
        *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 max(1, n)，设置 info 为 -4
        *info = -4;
    }
    if (*info != 0) {  // 如果 info 不为 0，调用 xerbla 函数报错并返回
        i__1 = -(*info);
        xerbla_("DSYTD2", &i__1);
        return 0;
    }

/*     Quick return if possible */

    if (*n <= 0) {  // 如果 n 小于等于 0，直接返回
        return 0;
    }

    if (upper) {

/*        Reduce the upper triangle of A */

    for (i__ = *n - 1; i__ >= 1; --i__) {

/*
             Generate elementary reflector H(i) = I - tau * v * v'
             to annihilate A(1:i-1,i+1)
*/

        dlarfg_(&i__, &a[i__ + (i__ + 1) * a_dim1], &a[(i__ + 1) * a_dim1
            + 1], &c__1, &taui);  // 生成第 i 个元素的 Householder 变换，用于消除 A(1:i-1, i+1) 的元素
        e[i__] = a[i__ + (i__ + 1) * a_dim1];  // 将被修改的对角线元素存入 e 数组

        if (taui != 0.) {

/*              Apply H(i) from both sides to A(1:i,1:i) */

        a[i__ + (i__ + 1) * a_dim1] = 1.;  // 将 Householder 变换的第一个元素设置为 1

/*              Compute  x := tau * A * v  storing x in TAU(1:i) */

        dsymv_(uplo, &i__, &taui, &a[a_offset], lda, &a[(i__ + 1) *
            a_dim1 + 1], &c__1, &c_b29, &tau[1], &c__1)
            ;  // 计算 tau * A * v 并将结果存入 tau 数组

/*              Compute  w := x - 1/2 * tau * (x'*v) * v */

        alpha = taui * -.5 * ddot_(&i__, &tau[1], &c__1, &a[(i__ + 1)
            * a_dim1 + 1], &c__1);  // 计算 w = x - 1/2 * tau * (x'*v) * v
        daxpy_(&i__, &alpha, &a[(i__ + 1) * a_dim1 + 1], &c__1, &tau[
            1], &c__1);  // 更新 tau 数组

/*
                Apply the transformation as a rank-2 update:
                   A := A - v * w' - w * v'
*/

        dsyr2_(uplo, &i__, &c_b151, &a[(i__ + 1) * a_dim1 + 1], &c__1,
             &tau[1], &c__1, &a[a_offset], lda);  // 执行矩阵 A 的更新操作

        a[i__ + (i__ + 1) * a_dim1] = e[i__];  // 恢复被修改的对角线元素
        }
        d__[i__ + 1] = a[i__ + 1 + (i__ + 1) * a_dim1];  // 将主对角线元素存入 d 数组
        tau[i__] = taui;  // 将计算得到的 tau 存入 tau 数组
/* L10: */
    }
    d__[1] = a[a_dim1 + 1];  // 存入最后一个主对角线元素到 d 数组
    } else {

/*        Reduce the lower triangle of A */

    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*
             Generate elementary reflector H(i) = I - tau * v * v'
             to annihilate A(i+2:n,i)
*/

        i__2 = *n - i__;
/* Computing MIN */
        i__3 = i__ + 2;
        dlarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[min(i__3,*n) + i__ *
             a_dim1], &c__1, &taui);  // 生成第 i 个元素的 Householder 变换，用于消除 A(i+2:n, i) 的元素
        e[i__] = a[i__ + 1 + i__ * a_dim1];  // 将被修改的对角线元素存入 e 数组

        if (taui != 0.) {

/*              Apply H(i) from both sides to A(i+1:n,i+1:n) */

        a[i__ + 1 + i__ * a_dim1] = 1.;  // 将 Householder 变换的第一个元素设置为 1

/*              Compute  x := tau * A * v  storing y in TAU(i:n-1) */

        i__2 = *n - i__;
        dsymv_(uplo, &i__2, &taui, &a[i__ + 1 + (i__ + 1) * a_dim1],
            lda, &a[i__ + 1 + i__ * a_dim1], &c__1, &c_b29, &tau[
            i__], &c__1);  // 计算 tau * A * v 并将结果存入 tau 数组
/*              Compute  w := x - 1/2 * tau * (x'*v) * v */

/* 计算 w := x - 1/2 * tau * (x'*v) * v */

        i__2 = *n - i__;
/* 计算向量长度 */
        alpha = taui * -.5 * ddot_(&i__2, &tau[i__], &c__1, &a[i__ +
            1 + i__ * a_dim1], &c__1);
/* 计算 alpha = -1/2 * tau * (tau[i] 和 a[i+1+i*a_dim1] 的内积) */
        i__2 = *n - i__;
/* 计算向量长度 */
        daxpy_(&i__2, &alpha, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
            i__], &c__1);
/* 计算向量运算：tau[i] := tau[i] + alpha * a[i+1+i*a_dim1] */

/*
                Apply the transformation as a rank-2 update:
                   A := A - v * w' - w * v'
*/

/* 应用作为秩-2更新的变换：A := A - v * w' - w * v' */

        i__2 = *n - i__;
/* 计算向量长度 */
        dsyr2_(uplo, &i__2, &c_b151, &a[i__ + 1 + i__ * a_dim1], &
            c__1, &tau[i__], &c__1, &a[i__ + 1 + (i__ + 1) *
            a_dim1], lda);
/* 执行 dsyr2 函数，对矩阵 A 进行秩-2更新 */

        a[i__ + 1 + i__ * a_dim1] = e[i__];
/* 将 e[i] 存入矩阵 A 的对应位置 */

        }
        d__[i__] = a[i__ + i__ * a_dim1];
/* 将矩阵 A 的对角元素存入数组 d__ 中 */
        tau[i__] = taui;
/* 将 taui 存入数组 tau 中 */
/* L20: */
    }
    d__[*n] = a[*n + *n * a_dim1];
/* 将矩阵 A 的右下角元素存入数组 d__ 中 */

    return 0;

/*     End of DSYTD2 */

/* DSYTD2 的结束 */

} /* dsytd2_ */

/* Subroutine */ int dsytrd_(char *uplo, integer *n, doublereal *a, integer *
    lda, doublereal *d__, doublereal *e, doublereal *tau, doublereal *
    work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, nb, kk, nx, iws;
    extern logical lsame_(char *, char *);
    static integer nbmin, iinfo;
    static logical upper;
    extern /* Subroutine */ int dsytd2_(char *, integer *, doublereal *,
        integer *, doublereal *, doublereal *, doublereal *, integer *);
    extern /* Subroutine */ int dsyr2k_(char *, char *, integer *, integer *, doublereal
        *, doublereal *, integer *, doublereal *, integer *, doublereal *,
         doublereal *, integer *), dlatrd_(char *,
        integer *, integer *, doublereal *, integer *, doublereal *,
        doublereal *, doublereal *, integer *);
    extern /* Subroutine */ int xerbla_(char *,
        integer *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static integer ldwork, lwkopt;
    static logical lquery;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DSYTRD reduces a real symmetric matrix A to real symmetric
    tridiagonal form T by an orthogonal similarity transformation:
    Q**T * A * Q = T.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.
    ! A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
    !         On entry, the symmetric matrix A.  If UPLO = 'U', the leading
    !         N-by-N upper triangular part of A contains the upper
    !         triangular part of the matrix A, and the strictly lower
    !         triangular part of A is not referenced.  If UPLO = 'L', the
    !         leading N-by-N lower triangular part of A contains the lower
    !         triangular part of the matrix A, and the strictly upper
    !         triangular part of A is not referenced.
    !         On exit, if UPLO = 'U', the diagonal and first superdiagonal
    !         of A are overwritten by the corresponding elements of the
    !         tridiagonal matrix T, and the elements above the first
    !         superdiagonal, with the array TAU, represent the orthogonal
    !         matrix Q as a product of elementary reflectors; if UPLO
    !         = 'L', the diagonal and first subdiagonal of A are over-
    !         written by the corresponding elements of the tridiagonal
    !         matrix T, and the elements below the first subdiagonal, with
    !         the array TAU, represent the orthogonal matrix Q as a product
    !         of elementary reflectors. See Further Details.
    
    ! LDA     (input) INTEGER
    !         The leading dimension of the array A.  LDA >= max(1,N).
    
    ! D       (output) DOUBLE PRECISION array, dimension (N)
    !         The diagonal elements of the tridiagonal matrix T:
    !         D(i) = A(i,i).
    
    ! E       (output) DOUBLE PRECISION array, dimension (N-1)
    !         The off-diagonal elements of the tridiagonal matrix T:
    !         E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
    
    ! TAU     (output) DOUBLE PRECISION array, dimension (N-1)
    !         The scalar factors of the elementary reflectors (see Further
    !         Details).
    
    ! WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
    !         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
    
    ! LWORK   (input) INTEGER
    !         The dimension of the array WORK.  LWORK >= 1.
    !         For optimum performance LWORK >= N*NB, where NB is the
    !         optimal blocksize.
    !         
    !         If LWORK = -1, then a workspace query is assumed; the routine
    !         only calculates the optimal size of the WORK array, returns
    !         this value as the first entry of the WORK array, and no error
    !         message related to LWORK is issued by XERBLA.
    
    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument had an illegal value
    
    ! Further Details
    ! ===============
    ! 
    ! If UPLO = 'U', the matrix Q is represented as a product of elementary
    ! reflectors
    ! 
    !    Q = H(n-1) . . . H(2) H(1).
    ! 
    ! Each H(i) has the form
    ! 
    !    H(i) = I - tau * v * v'
    ! 
    ! where tau is a real scalar, and v is a real vector with
    ! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
    ! A(1:i-1,i+1), and tau in TAU(i).
    # 如果 UPLO = 'L'，矩阵 Q 被表示为一系列初等反射变换的乘积
    # 
    #    Q = H(1) H(2) . . . H(n-1).
    # 
    # 每个 H(i) 的形式为
    # 
    #    H(i) = I - tau * v * v'
    # 
    # 其中 tau 是一个实数标量，v 是一个实向量，满足：
    # - v(1:i) = 0
    # - v(i+1) = 1
    # - A(i+2:n, i) 上的 v(i+2:n) 在退出时存储在 A(i+2:n, i) 中
    # - tau 存储在 TAU(i) 中。
    # 
    # A 在退出时的内容通过以下示例进行说明，假设 n = 5：
    # 
    # 如果 UPLO = 'U':                       如果 UPLO = 'L':
    # 
    #   (  d   e   v2  v3  v4 )              (  d                  )
    #   (      d   e   v3  v4 )              (  e   d              )
    #   (          d   e   v4 )              (  v1  e   d          )
    #   (              d   e  )              (  v1  v2  e   d      )
    #   (                  d  )              (  v1  v2  v3  e   d  )
    # 
    # 其中 d 和 e 表示 T 的对角线和非对角线元素，vi 表示定义 H(i) 的向量的元素。
    # =====================================================================
    
    
       # 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --d__;
    --e;
    --tau;
    --work;

    /* Function Body */
    *info = 0;  // 初始化 info 为 0
    upper = lsame_(uplo, "U");  // 检查 uplo 是否为 "U"，确定是否处理上三角部分
    lquery = *lwork == -1;  // 检查是否是查询工作空间大小
    if (! upper && ! lsame_(uplo, "L")) {  // 如果 uplo 不是 "U" 也不是 "L"，则设置 info 为 -1
    *info = -1;
    } else if (*n < 0) {  // 如果 n < 0，则设置 info 为 -2
    *info = -2;
    } else if (*lda < max(1,*n)) {  // 如果 lda 小于 1 和 n 的最大值，则设置 info 为 -4
    *info = -4;
    } else if (*lwork < 1 && ! lquery) {  // 如果 lwork < 1 且不是查询工作空间大小，则设置 info 为 -9
    *info = -9;
    }

    if (*info == 0) {

/*        Determine the block size. */

    nb = ilaenv_(&c__1, "DSYTRD", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6,
         (ftnlen)1);  // 确定分块大小 nb
    lwkopt = *n * nb;  // 计算最优工作空间大小
    work[1] = (doublereal) lwkopt;  // 将最优工作空间大小存入 work[1]
    }

    if (*info != 0) {
    i__1 = -(*info);
    xerbla_("DSYTRD", &i__1);  // 如果 info 不为 0，则调用错误处理函数 xerbla
    return 0;
    } else if (lquery) {
    return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
    work[1] = 1.;  // 如果 n 为 0，则设置 work[1] 为 1.0
    return 0;
    }

    nx = *n;
    iws = 1;
    if (nb > 1 && nb < *n) {

/*
          Determine when to cross over from blocked to unblocked code
          (last block is always handled by unblocked code).

   Computing MAX
*/
    i__1 = nb, i__2 = ilaenv_(&c__3, "DSYTRD", uplo, n, &c_n1, &c_n1, &
        c_n1, (ftnlen)6, (ftnlen)1);  // 确定何时从分块代码切换到非分块代码
    nx = max(i__1,i__2);  // 取 nb 和 ilaenv 计算的值的最大值作为 nx
    if (nx < *n) {

/*           Determine if workspace is large enough for blocked code. */

        ldwork = *n;
        iws = ldwork * nb;  // 计算工作空间大小 iws
        if (*lwork < iws) {

/*
                Not enough workspace to use optimal NB:  determine the
                minimum value of NB, and reduce NB or force use of
                unblocked code by setting NX = N.

   Computing MAX
*/
        i__1 = *lwork / ldwork;  // 计算 lwork / ldwork 的整数部分
        nb = max(i__1,1);  // 取这个值和 1 的最大值作为新的 nb
        nbmin = ilaenv_(&c__2, "DSYTRD", uplo, n, &c_n1, &c_n1, &c_n1,
             (ftnlen)6, (ftnlen)1);  // 计算最小的分块大小
        if (nb < nbmin) {
            nx = *n;  // 如果新的 nb 小于最小分块大小，则设置 nx 为 n
        }
        }
    } else {
        nx = *n;
    }
    } else {
    nb = 1;
    }

    if (upper) {

/*
          Reduce the upper triangle of A.
          Columns 1:kk are handled by the unblocked method.
*/

    kk = *n - (*n - nx + nb - 1) / nb * nb;  // 计算 kk 的值
    i__1 = kk + 1;
    i__2 = -nb;
    for (i__ = *n - nb + 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ +=
        i__2) {

/*
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix
*/

        i__3 = i__ + nb - 1;
        dlatrd_(uplo, &i__3, &nb, &a[a_offset], lda, &e[1], &tau[1], &
            work[1], &ldwork);  // 调用 dlatrd 函数进行矩阵变换

/*
             Update the unreduced submatrix A(1:i-1,1:i-1), using an
             update of the form:  A := A - V*W' - W*V'
*/

        i__3 = i__ - 1;
        dsyr2k_(uplo, "No transpose", &i__3, &nb, &c_b151, &a[i__ *
            a_dim1 + 1], lda, &work[1], &ldwork, &c_b15, &a[a_offset],
             lda);  // 调用 dsyr2k 函数进行矩阵更新

/*
             Copy superdiagonal elements back into A, and diagonal
             elements into D
*/
        i__3 = i__ + nb - 1;
        for (j = i__; j <= i__3; ++j) {
            a[j - 1 + j * a_dim1] = e[j - 1];
            d__[j] = a[j + j * a_dim1];
/* L10: */
        }
/* L20: */
    }

```    
        dsytd2_(uplo, &kk, &a[a_offset], lda, &d__[1], &e[1], &tau[1], &iinfo);
    } else {

```    
        i__2 = *n - nx;
        i__1 = nb;
        for (i__ = 1; i__1 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__1) {

```    
             Reduce columns i:i+nb-1 to tridiagonal form and form the
             matrix W which is needed to update the unreduced part of
             the matrix

```    
            i__3 = *n - i__ + 1;
            dlatrd_(uplo, &i__3, &nb, &a[i__ + i__ * a_dim1], lda, &e[i__], &
                tau[i__], &work[1], &ldwork);

```    
             Update the unreduced submatrix A(i+ib:n,i+ib:n), using
             an update of the form:  A := A - V*W' - W*V'

```    
            i__3 = *n - i__ - nb + 1;
            dsyr2k_(uplo, "No transpose", &i__3, &nb, &c_b151, &a[i__ + nb +
                i__ * a_dim1], lda, &work[nb + 1], &ldwork, &c_b15, &a[
                i__ + nb + (i__ + nb) * a_dim1], lda);

```    
             Copy subdiagonal elements back into A, and diagonal
             elements into D

```    
            i__3 = i__ + nb - 1;
            for (j = i__; j <= i__3; ++j) {
                a[j + 1 + j * a_dim1] = e[j];
                d__[j] = a[j + j * a_dim1];
/* L30: */
            }
/* L40: */
        }

```    
        i__1 = *n - i__ + 1;
        dsytd2_(uplo, &i__1, &a[i__ + i__ * a_dim1], lda, &d__[i__], &e[i__],
            &tau[i__], &iinfo);
    }

```    
    work[1] = (doublereal) lwkopt;
    return 0;

```    
} /* dsytrd_ */

```    
int dtrevc_(char *side, char *howmny, logical *select,
    integer *n, doublereal *t, integer *ldt, doublereal *vl, integer *
    ldvl, doublereal *vr, integer *ldvr, integer *mm, integer *m,
    doublereal *work, integer *info)
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1,
        i__2, i__3;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    static integer i__, j, k;
    static doublereal x[4]    /* was [2][2] */;
    static integer j1, j2, n2, ii, ki, ip, is;
    static doublereal wi, wr, rec, ulp, beta, emax;
    static logical pair;
    extern doublereal ddot_(integer *, doublereal *, integer *, doublereal *,
        integer *);
    static logical allv;
    static integer ierr;
    static doublereal unfl, ovfl, smin;
    static logical over;
    static doublereal vmax;
    static integer jnxt;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    static doublereal scale;
    extern logical lsame_(char *, char *);
    # 声明一个外部的双精度矩阵-向量乘法子程序
    extern /* Subroutine */ int dgemv_(char *, integer *, integer *,
        doublereal *, doublereal *, integer *, doublereal *, integer *,
        doublereal *, doublereal *, integer *);

    # 声明一个静态的双精度变量 remax
    static doublereal remax;

    # 声明一个外部的双精度向量复制子程序
    extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *,
        doublereal *, integer *);

    # 声明一个静态的逻辑变量 leftv 和 bothv
    static logical leftv, bothv;

    # 声明一个外部的双精度向量-向量加法子程序
    extern /* Subroutine */ int daxpy_(integer *, doublereal *, doublereal *,
        integer *, doublereal *, integer *);

    # 声明一个静态的双精度变量 vcrit
    static doublereal vcrit;

    # 声明一个静态的逻辑变量 somev
    static logical somev;

    # 声明一个静态的双精度变量 xnorm
    static doublereal xnorm;

    # 声明一个外部的双精度线性代数子程序
    extern /* Subroutine */ int dlaln2_(logical *, integer *, integer *,
        doublereal *, doublereal *, doublereal *, integer *, doublereal *,
         doublereal *, doublereal *, integer *, doublereal *, doublereal *,
         doublereal *, integer *, doublereal *, doublereal *, integer *);

    # 声明一个外部的双精度数值转换子程序
    extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);

    # 声明一个外部的整型函数，返回最大绝对值元素的索引
    extern integer idamax_(integer *, doublereal *, integer *);

    # 声明一个外部的错误处理子程序
    extern /* Subroutine */ int xerbla_(char *, integer *);

    # 声明一个静态的双精度变量 bignum
    static doublereal bignum;

    # 声明一个静态的逻辑变量 rightv
    static logical rightv;

    # 声明一个静态的双精度变量 smlnum
    static doublereal smlnum;
"""
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DTREVC computes some or all of the right and/or left eigenvectors of
    a real upper quasi-triangular matrix T.
    Matrices of this type are produced by the Schur factorization of
    a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.

    The right eigenvector x and the left eigenvector y of T corresponding
    to an eigenvalue w are defined by:

       T*x = w*x,     (y**H)*T = w*(y**H)

    where y**H denotes the conjugate transpose of y.
    The eigenvalues are not input to this routine, but are read directly
    from the diagonal blocks of T.

    This routine returns the matrices X and/or Y of right and left
    eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
    input matrix.  If Q is the orthogonal factor that reduces a matrix
    A to Schur form T, then Q*X and Q*Y are the matrices of right and
    left eigenvectors of A.

    Arguments
    =========

    SIDE    (input) CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.

    HOWMNY  (input) CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed by the matrices in VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.

    SELECT  (input/output) LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            If w(j) is a real eigenvalue, the corresponding real
            eigenvector is computed if SELECT(j) is .TRUE..
            If w(j) and w(j+1) are the real and imaginary parts of a
            complex eigenvalue, the corresponding complex eigenvector is
            computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
            on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
            .FALSE..
            Not referenced if HOWMNY = 'A' or 'B'.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input) DOUBLE PRECISION array, dimension (LDT,N)
            The upper quasi-triangular matrix T in Schur canonical form.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
"""
    ! VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
    !         On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
    !         contain an N-by-N matrix Q (usually the orthogonal matrix Q
    !         of Schur vectors returned by DHSEQR).
    !         On exit, if SIDE = 'L' or 'B', VL contains:
    !         if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
    !         if HOWMNY = 'B', the matrix Q*Y;
    !         if HOWMNY = 'S', the left eigenvectors of T specified by
    !                          SELECT, stored consecutively in the columns
    !                          of VL, in the same order as their
    !                          eigenvalues.
    !         A complex eigenvector corresponding to a complex eigenvalue
    !         is stored in two consecutive columns, the first holding the
    !         real part, and the second the imaginary part.
    !         Not referenced if SIDE = 'R'.

    ! LDVL    (input) INTEGER
    !         The leading dimension of the array VL.  LDVL >= 1, and if
    !         SIDE = 'L' or 'B', LDVL >= N.

    ! VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
    !         On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
    !         contain an N-by-N matrix Q (usually the orthogonal matrix Q
    !         of Schur vectors returned by DHSEQR).
    !         On exit, if SIDE = 'R' or 'B', VR contains:
    !         if HOWMNY = 'A', the matrix X of right eigenvectors of T;
    !         if HOWMNY = 'B', the matrix Q*X;
    !         if HOWMNY = 'S', the right eigenvectors of T specified by
    !                          SELECT, stored consecutively in the columns
    !                          of VR, in the same order as their
    !                          eigenvalues.
    !         A complex eigenvector corresponding to a complex eigenvalue
    !         is stored in two consecutive columns, the first holding the
    !         real part and the second the imaginary part.
    !         Not referenced if SIDE = 'L'.

    ! LDVR    (input) INTEGER
    !         The leading dimension of the array VR.  LDVR >= 1, and if
    !         SIDE = 'R' or 'B', LDVR >= N.

    ! MM      (input) INTEGER
    !         The number of columns in the arrays VL and/or VR. MM >= M.

    ! M       (output) INTEGER
    !         The number of columns in the arrays VL and/or VR actually
    !         used to store the eigenvectors.
    !         If HOWMNY = 'A' or 'B', M is set to N.
    !         Each selected real eigenvector occupies one column and each
    !         selected complex eigenvector occupies two columns.

    ! WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

    ! INFO    (output) INTEGER
    !         = 0:  successful exit
    !         < 0:  if INFO = -i, the i-th argument had an illegal value

    ! Further Details
    ! ===============

    ! The algorithm used in this program is basically backward (forward)
    ! substitution, with scaling to make the code robust against
    ! possible overflow.
    # 每个特征向量被归一化，使得具有最大幅值的元素的幅值为1；
    # 这里复数的幅值被定义为 |x| + |y|，其中 (x, y) 是复数。

    # =====================================================================

    # 解码和测试输入参数
    /* Parameter adjustments */
    --select;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    bothv = lsame_(side, "B");  // 检查是否需要计算左右特征向量
    rightv = lsame_(side, "R") || bothv;  // 检查是否需要计算右特征向量
    leftv = lsame_(side, "L") || bothv;   // 检查是否需要计算左特征向量

    allv = lsame_(howmny, "A");   // 检查是否要计算所有的特征向量
    over = lsame_(howmny, "B");   // 检查是否要计算多个特征向量
    somev = lsame_(howmny, "S");  // 检查是否要计算选定的特征向量

    *info = 0;  // 初始化 info，用于存储错误码
    if (! rightv && ! leftv) {  // 如果既不计算右特征向量也不计算左特征向量
        *info = -1;  // 设置错误码为 -1
    } else if (! allv && ! over && ! somev) {  // 如果既不计算所有特征向量、也不计算多个特征向量、也不计算选定的特征向量
        *info = -2;  // 设置错误码为 -2
    } else if (*n < 0) {  // 如果输入的维度 n 小于 0
        *info = -4;  // 设置错误码为 -4
    } else if (*ldt < max(1,*n)) {  // 如果指定的 t 的列数 ldvt 小于 1 或 n
        *info = -6;  // 设置错误码为 -6
    } else if (*ldvl < 1 || leftv && *ldvl < *n) {  // 如果指定的左特征向量矩阵的列数 ldvl 小于 1 或 (leftv 为真且 ldvl 小于 n)
        *info = -8;  // 设置错误码为 -8
    } else if (*ldvr < 1 || rightv && *ldvr < *n) {  // 如果指定的右特征向量矩阵的列数 ldvr 小于 1 或 (rightv 为真且 ldvr 小于 n)
        *info = -10;  // 设置错误码为 -10
    } else {

        /*
              Set M to the number of columns required to store the selected
              eigenvectors, standardize the array SELECT if necessary, and
              test MM.
        */

        if (somev) {  // 如果需要计算选定的特征向量
            *m = 0;  // 初始化计数器 m 为 0
            pair = FALSE_;  // 初始化 pair 为 FALSE
            i__1 = *n;  // 循环次数为 n
            for (j = 1; j <= i__1; ++j) {  // 遍历每一个特征值
                if (pair) {  // 如果前一个特征值是复数对的一部分
                    pair = FALSE_;  // 重置 pair 为 FALSE
                    select[j] = FALSE_;  // 设置 select[j] 为 FALSE
                } else {
                    if (j < *n) {  // 如果不是最后一个特征值
                        if (t[j + 1 + j * t_dim1] == 0.) {  // 如果下一列的对角元素为 0
                            if (select[j]) {  // 如果 select[j] 为真
                                ++(*m);  // 增加 m 的计数
                            }
                        } else {  // 如果下一列的对角元素不为 0，表示有复数特征值对
                            pair = TRUE_;  // 设置 pair 为 TRUE，表示找到复数特征值对
                            if (select[j] || select[j + 1]) {  // 如果 select[j] 或 select[j + 1] 为真
                                select[j] = TRUE_;  // 设置 select[j] 为 TRUE
                                *m += 2;  // 增加 m 的计数，因为复数特征值对占两列
                            }
                        }
                    } else {  // 如果是最后一个特征值
                        if (select[*n]) {  // 如果 select[*n] 为真
                            ++(*m);  // 增加 m 的计数
                        }
                    }
                }
                /* L10: */
            }
        } else {  // 如果需要计算所有特征向量
            *m = *n;  // 设置 m 等于 n，表示计算所有特征向量
        }

        if (*mm < *m) {  // 如果给定的 mm 小于 m
            *info = -11;  // 设置错误码为 -11
        }
    }
    if (*info != 0) {  // 如果存在错误码
        i__1 = -(*info);  // 取错误码的负值
        xerbla_("DTREVC", &i__1);  // 调用错误处理程序 xerbla
        return 0;  // 返回
    }

    /*     Quick return if possible. */

    if (*n == 0) {  // 如果 n 等于 0
        return 0;  // 直接返回
    }

    /*     Set the constants to control overflow. */

    unfl = SAFEMINIMUM;  // 设置下界 unfl
    ovfl = 1. / unfl;  // 设置上界 ovfl
    dlabad_(&unfl, &ovfl);  // 调用 dlabad 函数计算 unfl 和 ovfl
    ulp = PRECISION;  // 设置单位舍入误差 ulp
    smlnum = unfl * (*n / ulp);  // 计算小数 smlnum
    bignum = (1. - ulp) / smlnum;  // 计算大数 bignum

    /*
       Compute 1-norm of each column of strictly upper triangular
       part of T to control overflow in triangular solver.
    */

    work[1] = 0.;  // 初始化工作数组的第一个元素为 0
    i__1 = *n;  // 循环次数为 n
    for (j = 2; j <= i__1; ++j) {  // 遍历每一列
        work[j] = 0.;  // 初始化工作数组的第 j 个元素为 0
        i__2 = j - 1;  // 内循环次数为 j-1
        for (i__ = 1; i__ <= i__2; ++i__) {  // 遍历每一行
            work[j] += (d__1 = t[i__ + j * t_dim1], abs(d__1));  // 计算每一列的 1-范数
            /* L20: */
        }
        /* L30: */
    }

    /*
       Index IP is used to specify the real or complex eigenvalue:
         IP = 0, real eigenvalue,
              1, first of conjugate complex pair: (wr,wi)
             -1, second of conjugate complex pair: (wr,wi)
    */

    n2 = *n << 1;  // n2 等于 n 的两倍

    if (rightv) {  // 如果需要计算右特征向量

        /*        Compute right eigenvectors. */

        ip = 0;  // 设置 ip 为 0
        is = *m;  // 设置 is 等于 m
    # 对 ki 进行递减循环，从 *n 到 1
    for (ki = *n; ki >= 1; --ki) {
        # 如果 ip 等于 1，则跳转到标签 L130
        if (ip == 1) {
            goto L130;
        }
        # 如果 ki 等于 1，则跳转到标签 L40
        if (ki == 1) {
            goto L40;
        }
        # 如果 t[ki + (ki - 1) * t_dim1] 等于 0，则跳转到标签 L40
        if (t[ki + (ki - 1) * t_dim1] == 0.) {
            goto L40;
        }
        # 将 ip 设置为 -1
        ip = -1;
L40:
        // 如果条件成立，则执行以下语句块
        if (somev) {
        // 如果 ip 等于 0
        if (ip == 0) {
            // 如果 select[ki] 为假，跳转到标签 L130
            if (! select[ki]) {
            goto L130;
            }
        } else {
            // 如果 select[ki - 1] 为假，跳转到标签 L130
            if (! select[ki - 1]) {
            goto L130;
            }
        }
        }

/*           Compute the KI-th eigenvalue (WR,WI). */

        // 计算第 ki 个特征值的实部 WR 和虚部 WI
        wr = t[ki + ki * t_dim1];
        wi = 0.;
        // 如果 ip 不等于 0
        if (ip != 0) {
        // 计算虚部 WI，使用平方根函数 sqrt，计算绝对值函数 abs
        wi = sqrt((d__1 = t[ki + (ki - 1) * t_dim1], abs(d__1))) *
            sqrt((d__2 = t[ki - 1 + ki * t_dim1], abs(d__2)));
        }
/* Computing MAX */
        // 计算 ulp * (|wr| + |wi|) 的最大值
        d__1 = ulp * (abs(wr) + abs(wi));
        smin = max(d__1,smlnum);

        // 如果 ip 等于 0
        if (ip == 0) {

/*              Real right eigenvector */

        // 设置 work 数组的第 (ki + *n) 个元素为 1
        work[ki + *n] = 1.;

/*              Form right-hand side */

        // 对于 k 从 1 到 ki-1
        i__1 = ki - 1;
        for (k = 1; k <= i__1; ++k) {
            // 计算 work 数组的第 (k + *n) 个元素
            work[k + *n] = -t[k + ki * t_dim1];
/* L50: */
        }

/*
                Solve the upper quasi-triangular system:
                   (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
*/

        // 初始化 jnxt 为 ki-1
        jnxt = ki - 1;
        // 从 j 为 ki-1 递减到 1
        for (j = ki - 1; j >= 1; --j) {
            // 如果 j 大于 jnxt，跳转到标签 L60
            if (j > jnxt) {
            goto L60;
            }
            // 设置 j1 和 j2 为 j
            j1 = j;
            j2 = j;
            // 更新 jnxt 为 j-1
            jnxt = j - 1;
            // 如果 j 大于 1
            if (j > 1) {
            // 如果 T(j, j-1) 不等于 0
            if (t[j + (j - 1) * t_dim1] != 0.) {
                // 更新 j1 为 j-1
                j1 = j - 1;
                // 更新 jnxt 为 j-2
                jnxt = j - 2;
            }
            }

            // 如果 j1 等于 j2
            if (j1 == j2) {

/*                    1-by-1 diagonal block */

            // 调用 dlaln2 函数，解一个 1x1 对角块的线性系统
            dlaln2_(&c_false, &c__1, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*
                      Scale X(1,1) to avoid overflow when updating
                      the right-hand side.
*/

            // 如果 xnorm 大于 1
            if (xnorm > 1.) {
                // 如果 work[j] 大于 bignum / xnorm
                if (work[j] > bignum / xnorm) {
                // 缩放 x[0] 和 scale
                x[0] /= xnorm;
                scale /= xnorm;
                }
            }

/*                    Scale if necessary */

            // 如果 scale 不等于 1
            if (scale != 1.) {
                // 调用 dscal_ 函数，对 work[*n+1] 执行缩放
                dscal_(&ki, &scale, &work[*n + 1], &c__1);
            }
            // 设置 work[j + *n] 为 x[0]
            work[j + *n] = x[0];

/*                    Update right-hand side */

            // 更新右侧向量的值
            i__1 = j - 1;
            d__1 = -x[0];
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);

            } else {

/*                    2-by-2 diagonal block */

            // 调用 dlaln2 函数，解一个 2x1 对角块的线性系统
            dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b15, &t[j -
                1 + (j - 1) * t_dim1], ldt, &c_b15, &c_b15, &
                work[j - 1 + *n], n, &wr, &c_b29, x, &c__2, &
                scale, &xnorm, &ierr);

/*
                      Scale X(1,1) and X(2,1) to avoid overflow when
                      updating the right-hand side.
*/

            // 如果 xnorm 大于 1
            if (xnorm > 1.) {
/* Computing MAX */
/* 计算两个数的最大值 */
                d__1 = work[j - 1], d__2 = work[j];
                beta = max(d__1,d__2);
                /* 计算两个数中较大的值，并赋给 beta */
                if (beta > bignum / xnorm) {
                /* 如果 beta 大于 bignum / xnorm，进行下面的操作 */
                x[0] /= xnorm;
                /* x[0] 除以 xnorm */
                x[1] /= xnorm;
                /* x[1] 除以 xnorm */
                scale /= xnorm;
                /* scale 除以 xnorm */
                }
            }

/*                    Scale if necessary */

/* 如果需要，进行缩放 */
            if (scale != 1.) {
            /* 如果 scale 不等于 1，执行以下操作 */
                dscal_(&ki, &scale, &work[*n + 1], &c__1);
                /* 使用 dscal 函数对 work[*n + 1] 进行缩放 */
            }
            work[j - 1 + *n] = x[0];
            /* 将 x[0] 赋值给 work[j - 1 + *n] */
            work[j + *n] = x[1];
            /* 将 x[1] 赋值给 work[j + *n] */

/*                    Update right-hand side */

/* 更新右侧向量 */
            i__1 = j - 2;
            /* 循环次数为 j - 2 */
            d__1 = -x[0];
            /* 将 -x[0] 赋给 d__1 */
            daxpy_(&i__1, &d__1, &t[(j - 1) * t_dim1 + 1], &c__1,
                &work[*n + 1], &c__1);
            /* 使用 daxpy 函数更新 work[*n + 1] */
            i__1 = j - 2;
            /* 循环次数为 j - 2 */
            d__1 = -x[1];
            /* 将 -x[1] 赋给 d__1 */
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);
            /* 使用 daxpy 函数更新 work[*n + 1] */
            }
L60:
            ;
        }

/*              Copy the vector x or Q*x to VR and normalize. */

/* 复制向量 x 或 Q*x 到 VR，并进行归一化 */
        if (! over) {
        /* 如果不是过度模式 */
            dcopy_(&ki, &work[*n + 1], &c__1, &vr[is * vr_dim1 + 1], &
                c__1);
            /* 使用 dcopy 函数复制 work[*n + 1] 到 vr[is * vr_dim1 + 1] */
            ii = idamax_(&ki, &vr[is * vr_dim1 + 1], &c__1);
            /* 使用 idamax 函数找到 vr[is * vr_dim1 + 1] 的最大绝对值的索引 */
            remax = 1. / (d__1 = vr[ii + is * vr_dim1], abs(d__1));
            /* 计算归一化常数 remax */
            dscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);
            /* 使用 dscal 函数归一化 vr[is * vr_dim1 + 1] */
            i__1 = *n;
            /* 循环次数为 *n */
            for (k = ki + 1; k <= i__1; ++k) {
            /* 循环从 ki+1 到 *n */
            vr[k + is * vr_dim1] = 0.;
/* L70: */
            }
        } else {
        /* 否则 */
            if (ki > 1) {
            /* 如果 ki 大于 1 */
            i__1 = ki - 1;
            /* 循环次数为 ki - 1 */
            dgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &
                work[*n + 1], &c__1, &work[ki + *n], &vr[ki *
                vr_dim1 + 1], &c__1);
            /* 使用 dgemv 函数进行矩阵-向量乘法 */
            }

            ii = idamax_(n, &vr[ki * vr_dim1 + 1], &c__1);
            /* 使用 idamax 函数找到 vr[ki * vr_dim1 + 1] 的最大绝对值的索引 */
            remax = 1. / (d__1 = vr[ii + ki * vr_dim1], abs(d__1));
            /* 计算归一化常数 remax */
            dscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
            /* 使用 dscal 函数归一化 vr[ki * vr_dim1 + 1] */
        }

        } else {

/*
                Complex right eigenvector.

                Initial solve
                  [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
                  [ (T(KI,KI-1)   T(KI,KI)   )               ]
*/

/* 复数右特征向量。初始求解 */
/* 初始化右侧向量，对复数特征值进行求解 */

        if ((d__1 = t[ki - 1 + ki * t_dim1], abs(d__1)) >= (d__2 = t[
            ki + (ki - 1) * t_dim1], abs(d__2))) {
            /* 如果 |t[ki-1+ki*t_dim1]| >= |t[ki+(ki-1)*t_dim1]| */
            work[ki - 1 + *n] = 1.;
            /* 将 1 赋给 work[ki - 1 + *n] */
            work[ki + n2] = wi / t[ki - 1 + ki * t_dim1];
            /* 将 wi / t[ki-1+ki*t_dim1] 赋给 work[ki + n2] */
        } else {
            /* 否则 */
            work[ki - 1 + *n] = -wi / t[ki + (ki - 1) * t_dim1];
            /* 将 -wi / t[ki+(ki-1)*t_dim1] 赋给 work[ki - 1 + *n] */
            work[ki + n2] = 1.;
            /* 将 1 赋给 work[ki + n2] */
        }
        work[ki + *n] = 0.;
        /* 将 0 赋给 work[ki + *n] */
        work[ki - 1 + n2] = 0.;
        /* 将 0 赋给 work[ki - 1 + n2] */

/*              Form right-hand side */

/* 形成右侧向量 */
        i__1 = ki - 2;
        /* 循环次数为 ki - 2 */
        for (k = 1; k <= i__1; ++k) {
        /* 循环从 1 到 ki - 2 */
            work[k + *n] = -work[ki - 1 + *n] * t[k + (ki - 1) *
                t_dim1];
            /* 计算 work[k + *n] */
            work[k + n2] = -work[ki + n2] * t[k + ki * t_dim1];
            /* 计算 work[k + n2] */
/* L80: */
        }
        jnxt = ki - 2;
        // 设置初始值 jnxt 为 ki - 2
        for (j = ki - 2; j >= 1; --j) {
            // 循环从 ki-2 到 1，递减
            if (j > jnxt) {
            // 如果 j 大于 jnxt，则跳转到标签 L90
            goto L90;
            }
            j1 = j;
            j2 = j;
            jnxt = j - 1;
            // 更新 j1 和 j2 的值为当前 j 的值，更新 jnxt 为 j-1
            if (j > 1) {
            // 如果 j 大于 1
            if (t[j + (j - 1) * t_dim1] != 0.) {
                // 如果 t[j, j-1] 不等于 0
                j1 = j - 1;
                // 更新 j1 为 j-1
                jnxt = j - 2;
                // 更新 jnxt 为 j-2
            }
            }

            if (j1 == j2) {

/*                    1-by-1 diagonal block */

            // 单个 1x1 对角块处理

            dlaln2_(&c_false, &c__1, &c__2, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &wi, x, &c__2, &scale, &xnorm, &
                ierr);

/*
                      Scale X(1,1) and X(1,2) to avoid overflow when
                      updating the right-hand side.
*/

            // 缩放 X(1,1) 和 X(1,2)，避免更新右侧时溢出

            if (xnorm > 1.) {
                if (work[j] > bignum / xnorm) {
                x[0] /= xnorm;
                x[2] /= xnorm;
                scale /= xnorm;
                }
            }

/*                    Scale if necessary */

            // 必要时进行缩放

            if (scale != 1.) {
                dscal_(&ki, &scale, &work[*n + 1], &c__1);
                dscal_(&ki, &scale, &work[n2 + 1], &c__1);
            }
            work[j + *n] = x[0];
            work[j + n2] = x[2];

/*                    Update the right-hand side */

            // 更新右侧

            i__1 = j - 1;
            d__1 = -x[0];
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);
            i__1 = j - 1;
            d__1 = -x[2];
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                n2 + 1], &c__1);

            } else {

/*                    2-by-2 diagonal block */

            // 双 2x2 对角块处理

            dlaln2_(&c_false, &c__2, &c__2, &smin, &c_b15, &t[j -
                1 + (j - 1) * t_dim1], ldt, &c_b15, &c_b15, &
                work[j - 1 + *n], n, &wr, &wi, x, &c__2, &
                scale, &xnorm, &ierr);

/*
                      Scale X to avoid overflow when updating
                      the right-hand side.
*/

            // 缩放 X，避免更新右侧时溢出

            if (xnorm > 1.) {
/* Computing MAX */
                d__1 = work[j - 1], d__2 = work[j];
                beta = max(d__1,d__2);
                if (beta > bignum / xnorm) {
                rec = 1. / xnorm;
                x[0] *= rec;
                x[2] *= rec;
                x[1] *= rec;
                x[3] *= rec;
                scale *= rec;
                }
            }

/*                    Scale if necessary */

            // 必要时进行缩放

            if (scale != 1.) {
                dscal_(&ki, &scale, &work[*n + 1], &c__1);
                dscal_(&ki, &scale, &work[n2 + 1], &c__1);
            }
            work[j - 1 + *n] = x[0];
            work[j + *n] = x[1];
            work[j - 1 + n2] = x[2];
            work[j + n2] = x[3];
/* 更新右侧 */

            i__1 = j - 2;  // 计算向量的长度
            d__1 = -x[0];  // 计算向量乘积的系数
            daxpy_(&i__1, &d__1, &t[(j - 1) * t_dim1 + 1], &c__1,
                &work[*n + 1], &c__1);  // 执行向量乘积运算并存储结果
            i__1 = j - 2;
            d__1 = -x[1];
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                *n + 1], &c__1);  // 执行向量乘积运算并存储结果
            i__1 = j - 2;
            d__1 = -x[2];
            daxpy_(&i__1, &d__1, &t[(j - 1) * t_dim1 + 1], &c__1,
                &work[n2 + 1], &c__1);  // 执行向量乘积运算并存储结果
            i__1 = j - 2;
            d__1 = -x[3];
            daxpy_(&i__1, &d__1, &t[j * t_dim1 + 1], &c__1, &work[
                n2 + 1], &c__1);  // 执行向量乘积运算并存储结果
            }
L90:
            ;
        }

/* 复制向量 x 或 Q*x 到 VR 并进行归一化 */

        if (! over) {
            dcopy_(&ki, &work[*n + 1], &c__1, &vr[(is - 1) * vr_dim1
                + 1], &c__1);  // 复制向量并存储到 VR 中
            dcopy_(&ki, &work[n2 + 1], &c__1, &vr[is * vr_dim1 + 1], &
                c__1);  // 复制向量并存储到 VR 中

            emax = 0.;  // 初始化最大值
            i__1 = ki;
            for (k = 1; k <= i__1; ++k) {
/* 计算最大值 */
            d__3 = emax, d__4 = (d__1 = vr[k + (is - 1) * vr_dim1]
                , abs(d__1)) + (d__2 = vr[k + is * vr_dim1],
                abs(d__2));
            emax = max(d__3,d__4);
/* L100: */
            }

            remax = 1. / emax;  // 计算倒数
            dscal_(&ki, &remax, &vr[(is - 1) * vr_dim1 + 1], &c__1);  // 缩放向量
            dscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);  // 缩放向量

            i__1 = *n;
            for (k = ki + 1; k <= i__1; ++k) {
            vr[k + (is - 1) * vr_dim1] = 0.;  // 清零向量的剩余部分
            vr[k + is * vr_dim1] = 0.;  // 清零向量的剩余部分
/* L110: */
            }

        } else {

            if (ki > 2) {
            i__1 = ki - 2;
            dgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &
                work[*n + 1], &c__1, &work[ki - 1 + *n], &vr[(
                ki - 1) * vr_dim1 + 1], &c__1);  // 矩阵-向量乘积运算
            i__1 = ki - 2;
            dgemv_("N", n, &i__1, &c_b15, &vr[vr_offset], ldvr, &
                work[n2 + 1], &c__1, &work[ki + n2], &vr[ki *
                vr_dim1 + 1], &c__1);  // 矩阵-向量乘积运算
            } else {
            dscal_(n, &work[ki - 1 + *n], &vr[(ki - 1) * vr_dim1
                + 1], &c__1);  // 缩放向量
            dscal_(n, &work[ki + n2], &vr[ki * vr_dim1 + 1], &
                c__1);  // 缩放向量
            }

            emax = 0.;  // 初始化最大值
            i__1 = *n;
            for (k = 1; k <= i__1; ++k) {
/* 计算最大值 */
            d__3 = emax, d__4 = (d__1 = vr[k + (ki - 1) * vr_dim1]
                , abs(d__1)) + (d__2 = vr[k + ki * vr_dim1],
                abs(d__2));
            emax = max(d__3,d__4);
/* L120: */
            }
            remax = 1. / emax;  // 计算倒数
            dscal_(n, &remax, &vr[(ki - 1) * vr_dim1 + 1], &c__1);  // 缩放向量
            dscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);  // 缩放向量
        }
        }

        --is;  // 减小 is 的值
        if (ip != 0) {
        --is;  // 减小 is 的值
        }
L130:
        if (ip == 1) {
        ip = 0;  // 重置 ip 的值
        }
        if (ip == -1) {
        ip = 1;  // 重置 ip 的值
        }
/* L140: */
    }
    }

    if (leftv) {

/*        Compute left eigenvectors. */

    ip = 0;
    is = 1;
    i__1 = *n;
    for (ki = 1; ki <= i__1; ++ki) {

        if (ip == -1) {
        goto L250;
        }
        if (ki == *n) {
        goto L150;
        }
        if (t[ki + 1 + ki * t_dim1] == 0.) {
        goto L150;
        }
        ip = 1;

L150:
        if (somev) {
        if (! select[ki]) {
            goto L250;
        }
        }

/*           Compute the KI-th eigenvalue (WR,WI). */

        wr = t[ki + ki * t_dim1];
        wi = 0.;
        if (ip != 0) {
        wi = sqrt((d__1 = t[ki + (ki + 1) * t_dim1], abs(d__1))) *
            sqrt((d__2 = t[ki + 1 + ki * t_dim1], abs(d__2)));
        }
/* Computing MAX */
        d__1 = ulp * (abs(wr) + abs(wi));
        smin = max(d__1,smlnum);

        if (ip == 0) {

/*              Real left eigenvector. */

        work[ki + *n] = 1.;

/*              Form right-hand side */

        i__2 = *n;
        for (k = ki + 1; k <= i__2; ++k) {
            work[k + *n] = -t[ki + k * t_dim1];
/* L160: */
        }

/*
                Solve the quasi-triangular system:
                   (T(KI+1:N,KI+1:N) - WR)'*X = SCALE*WORK
*/

        vmax = 1.;
        vcrit = bignum;

        jnxt = ki + 1;
        i__2 = *n;
        for (j = ki + 1; j <= i__2; ++j) {
            if (j < jnxt) {
            goto L170;
            }
            j1 = j;
            j2 = j;
            jnxt = j + 1;
            if (j < *n) {
            if (t[j + 1 + j * t_dim1] != 0.) {
                j2 = j + 1;
                jnxt = j + 2;
            }
            }

            if (j1 == j2) {

/*
                      1-by-1 diagonal block

                      Scale if necessary to avoid overflow when forming
                      the right-hand side.
*/

            if (work[j] > vcrit) {
                rec = 1. / vmax;
                i__3 = *n - ki + 1;
                dscal_(&i__3, &rec, &work[ki + *n], &c__1);
                vmax = 1.;
                vcrit = bignum;
            }

            i__3 = j - ki - 1;
            work[j + *n] -= ddot_(&i__3, &t[ki + 1 + j * t_dim1],
                &c__1, &work[ki + 1 + *n], &c__1);

/*                    Solve (T(J,J)-WR)'*X = WORK */

            dlaln2_(&c_false, &c__1, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*                    Scale if necessary */

            if (scale != 1.) {
                i__3 = *n - ki + 1;
                dscal_(&i__3, &scale, &work[ki + *n], &c__1);
            }
            work[j + *n] = x[0];
/* Computing MAX */
            d__2 = (d__1 = work[j + *n], abs(d__1));
            vmax = max(d__2,vmax);
            vcrit = bignum / vmax;

            } else {
/*
                      2-by-2 diagonal block

                      Scale if necessary to avoid overflow when forming
                      the right-hand side.

   Computing MAX
*/
            d__1 = work[j], d__2 = work[j + 1];
            // 获取 work[j] 和 work[j+1] 中的值，并计算它们的最大值
            beta = max(d__1,d__2);
            // 如果最大值 beta 超过阈值 vcrit，则进行下列操作
            if (beta > vcrit) {
                // 计算一个尺度系数，以避免在形成右侧向量时溢出
                rec = 1. / vmax;
                // 调整 work 中的部分元素，以确保不会溢出
                i__3 = *n - ki + 1;
                dscal_(&i__3, &rec, &work[ki + *n], &c__1);
                // 重置最大值和阈值
                vmax = 1.;
                vcrit = bignum;
            }

            // 更新 work[j+n]，减去与特定向量之间的点积
            i__3 = j - ki - 1;
            work[j + *n] -= ddot_(&i__3, &t[ki + 1 + j * t_dim1],
                &c__1, &work[ki + 1 + *n], &c__1);

            // 更新 work[j+1+n]，减去与特定向量之间的点积
            i__3 = j - ki - 1;
            work[j + 1 + *n] -= ddot_(&i__3, &t[ki + 1 + (j + 1) *
                 t_dim1], &c__1, &work[ki + 1 + *n], &c__1);

/*
                      Solve
                        [T(J,J)-WR   T(J,J+1)     ]'* X = SCALE*( WORK1 )
                        [T(J+1,J)    T(J+1,J+1)-WR]             ( WORK2 )
*/
            // 调用 dlaln2 函数解线性方程组
            dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b15, &t[j +
                j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
                n], n, &wr, &c_b29, x, &c__2, &scale, &xnorm,
                &ierr);

/*                    Scale if necessary */
            // 如果需要，对 work 中的元素进行缩放
            if (scale != 1.) {
                i__3 = *n - ki + 1;
                dscal_(&i__3, &scale, &work[ki + *n], &c__1);
            }
            // 将计算结果存入 work 数组
            work[j + *n] = x[0];
            work[j + 1 + *n] = x[1];

/* Computing MAX */
            // 计算 work[j+n] 和 work[j+1+n] 的绝对值的最大值，并更新最大值 vmax
            d__3 = (d__1 = work[j + *n], abs(d__1)), d__4 = (d__2
                = work[j + 1 + *n], abs(d__2)), d__3 = max(
                d__3,d__4);
            vmax = max(d__3,vmax);
            // 更新阈值 vcrit
            vcrit = bignum / vmax;

            }
L170:
            ;
        }

/*              Copy the vector x or Q*x to VL and normalize. */
        // 如果不是反转运算，则复制向量并进行归一化处理
        if (! over) {
            i__2 = *n - ki + 1;
            dcopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is *
                vl_dim1], &c__1);

            i__2 = *n - ki + 1;
            // 计算向量中的最大值，并进行归一化处理
            ii = idamax_(&i__2, &vl[ki + is * vl_dim1], &c__1) + ki -
                1;
            remax = 1. / (d__1 = vl[ii + is * vl_dim1], abs(d__1));
            i__2 = *n - ki + 1;
            dscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);

            i__2 = ki - 1;
            // 将前 ki-1 个元素置零
            for (k = 1; k <= i__2; ++k) {
                vl[k + is * vl_dim1] = 0.;
/* L180: */
            }

        } else {

            // 如果是反转运算，则进行矩阵向量乘法和归一化处理
            if (ki < *n) {
                i__2 = *n - ki;
                dgemv_("N", n, &i__2, &c_b15, &vl[(ki + 1) * vl_dim1
                    + 1], ldvl, &work[ki + 1 + *n], &c__1, &work[
                    ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
            }

            // 计算向量中的最大值，并进行归一化处理
            ii = idamax_(n, &vl[ki * vl_dim1 + 1], &c__1);
            remax = 1. / (d__1 = vl[ii + ki * vl_dim1], abs(d__1));
            dscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);

        }

        } else {
/*
   Complex left eigenvector.

   Initial solve:
     ((T(KI,KI)    T(KI,KI+1) )' - (WR - I* WI))*X = 0.
     ((T(KI+1,KI) T(KI+1,KI+1))                )
*/

if ((d__1 = t[ki + (ki + 1) * t_dim1], abs(d__1)) >= (d__2 =
    t[ki + 1 + ki * t_dim1], abs(d__2))) {
    // 如果 |T(KI,KI)| >= |T(KI+1,KI)|，计算工作数组中的值
    work[ki + *n] = wi / t[ki + (ki + 1) * t_dim1];
    work[ki + 1 + n2] = 1.;
} else {
    // 如果 |T(KI,KI)| < |T(KI+1,KI)|，计算工作数组中的值
    work[ki + *n] = 1.;
    work[ki + 1 + n2] = -wi / t[ki + 1 + ki * t_dim1];
}
// 初始化工作数组的其余部分
work[ki + 1 + *n] = 0.;
work[ki + n2] = 0.;

/* Form right-hand side */

i__2 = *n;
for (k = ki + 2; k <= i__2; ++k) {
    // 计算右侧向量的值
    work[k + *n] = -work[ki + *n] * t[ki + k * t_dim1];
    work[k + n2] = -work[ki + 1 + n2] * t[ki + 1 + k * t_dim1];
    // L190: 无特定操作，标签
}

/*
   Solve complex quasi-triangular system:
   ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
*/

vmax = 1.;
vcrit = bignum;

jnxt = ki + 2;
i__2 = *n;
for (j = ki + 2; j <= i__2; ++j) {
    if (j < jnxt) {
        goto L200;
    }
    j1 = j;
    j2 = j;
    jnxt = j + 1;
    if (j < *n) {
        if (t[j + 1 + j * t_dim1] != 0.) {
            j2 = j + 1;
            jnxt = j + 2;
        }
    }

    if (j1 == j2) {
        /*
           1-by-1 diagonal block

           Scale if necessary to avoid overflow when
           forming the right-hand side elements.
        */

        if (work[j] > vcrit) {
            // 若需要，对工作数组进行缩放，以避免溢出
            rec = 1. / vmax;
            i__3 = *n - ki + 1;
            dscal_(&i__3, &rec, &work[ki + *n], &c__1);
            i__3 = *n - ki + 1;
            dscal_(&i__3, &rec, &work[ki + n2], &c__1);
            vmax = 1.;
            vcrit = bignum;
        }

        // 计算右侧元素
        i__3 = j - ki - 2;
        work[j + *n] -= ddot_(&i__3, &t[ki + 2 + j * t_dim1],
            &c__1, &work[ki + 2 + *n], &c__1);
        i__3 = j - ki - 2;
        work[j + n2] -= ddot_(&i__3, &t[ki + 2 + j * t_dim1],
            &c__1, &work[ki + 2 + n2], &c__1);

        /* Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2 */

        d__1 = -wi;
        dlaln2_(&c_false, &c__1, &c__2, &smin, &c_b15, &t[j +
            j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
            n], n, &wr, &d__1, x, &c__2, &scale, &xnorm, &
            ierr);

        // 若需要，对解进行缩放
        if (scale != 1.) {
            i__3 = *n - ki + 1;
            dscal_(&i__3, &scale, &work[ki + *n], &c__1);
            i__3 = *n - ki + 1;
            dscal_(&i__3, &scale, &work[ki + n2], &c__1);
        }
        work[j + *n] = x[0];
        work[j + n2] = x[2];
    }
    // L200: 无特定操作，标签
}
/* Computing MAX */
/* 计算绝对值的最大值 */

d__3 = (d__1 = work[j + *n], abs(d__1)), d__4 = (d__2
    = work[j + n2], abs(d__2)), d__3 = max(d__3,
    d__4);
/* 计算两个绝对值的最大值 */

vmax = max(d__3,vmax);
/* 更新vmax为当前计算出的最大值 */

vcrit = bignum / vmax;
/* 计算临界值vcrit，用于后续的判断 */

} else {

/*
          2-by-2 diagonal block

          Scale if necessary to avoid overflow when forming
          the right-hand side elements.

Computing MAX
*/
/* 处理2x2对角块，如有必要进行缩放以避免右侧元素溢出 */

d__1 = work[j], d__2 = work[j + 1];
beta = max(d__1,d__2);
/* 计算两个值的最大值作为beta */

if (beta > vcrit) {
    rec = 1. / vmax;
    i__3 = *n - ki + 1;
    dscal_(&i__3, &rec, &work[ki + *n], &c__1);
    i__3 = *n - ki + 1;
    dscal_(&i__3, &rec, &work[ki + n2], &c__1);
    vmax = 1.;
    vcrit = bignum;
}
/* 如果beta大于vcrit，则进行缩放处理，以防止溢出 */

i__3 = j - ki - 2;
work[j + *n] -= ddot_(&i__3, &t[ki + 2 + j * t_dim1],
    &c__1, &work[ki + 2 + *n], &c__1);

i__3 = j - ki - 2;
work[j + n2] -= ddot_(&i__3, &t[ki + 2 + j * t_dim1],
    &c__1, &work[ki + 2 + n2], &c__1);

i__3 = j - ki - 2;
work[j + 1 + *n] -= ddot_(&i__3, &t[ki + 2 + (j + 1) *
     t_dim1], &c__1, &work[ki + 2 + *n], &c__1);

i__3 = j - ki - 2;
work[j + 1 + n2] -= ddot_(&i__3, &t[ki + 2 + (j + 1) *
     t_dim1], &c__1, &work[ki + 2 + n2], &c__1);

/*
          Solve 2-by-2 complex linear equation
            ([T(j,j)   T(j,j+1)  ]'-(wr-i*wi)*I)*X = SCALE*B
            ([T(j+1,j) T(j+1,j+1)]             )

Computing MAX
*/
/* 解2x2复线性方程组 */

d__1 = -wi;
dlaln2_(&c_true, &c__2, &c__2, &smin, &c_b15, &t[j +
    j * t_dim1], ldt, &c_b15, &c_b15, &work[j + *
    n], n, &wr, &d__1, x, &c__2, &scale, &xnorm, &
    ierr);

/* Scale if necessary */
/* 如有必要进行缩放 */

if (scale != 1.) {
    i__3 = *n - ki + 1;
    dscal_(&i__3, &scale, &work[ki + *n], &c__1);
    i__3 = *n - ki + 1;
    dscal_(&i__3, &scale, &work[ki + n2], &c__1);
}

work[j + *n] = x[0];
work[j + n2] = x[2];
work[j + 1 + *n] = x[1];
work[j + 1 + n2] = x[3];
/* 更新work数组的值 */

/* Computing MAX */
/* 计算绝对值的最大值 */

d__1 = abs(x[0]), d__2 = abs(x[2]), d__1 = max(d__1,
    d__2), d__2 = abs(x[1]), d__1 = max(d__1,d__2)
    , d__2 = abs(x[3]), d__1 = max(d__1,d__2);
vmax = max(d__1,vmax);
/* 更新vmax为当前计算出的最大值 */

vcrit = bignum / vmax;
/* 更新vcrit为当前计算出的临界值 */

}
L200:
;
/* 标号L200 */
/*              Copy the vector x or Q*x to VL and normalize. */

/* 如果不是过渡状态（over为假） */
if (! over) {
    /* 复制向量 x 或 Q*x 到 VL，并进行归一化处理 */
    i__2 = *n - ki + 1;
    dcopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is * vl_dim1], &c__1);
    i__2 = *n - ki + 1;
    dcopy_(&i__2, &work[ki + n2], &c__1, &vl[ki + (is + 1) * vl_dim1], &c__1);

    /* 计算向量的最大模 */
    emax = 0.;
    i__2 = *n;
    for (k = ki; k <= i__2; ++k) {
        /* 计算模的最大值 */
        d__3 = emax, d__4 = (d__1 = vl[k + is * vl_dim1], abs(d__1)) + (d__2 = vl[k + (is + 1) * vl_dim1], abs(d__2));
        emax = max(d__3,d__4);
        /* L220: */
    }
    /* 计算归一化系数 */
    remax = 1. / emax;
    i__2 = *n - ki + 1;
    /* 对 VL 中的向量进行归一化 */
    dscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);
    i__2 = *n - ki + 1;
    dscal_(&i__2, &remax, &vl[ki + (is + 1) * vl_dim1], &c__1);

    /* 将前 ki-1 行置零 */
    i__2 = ki - 1;
    for (k = 1; k <= i__2; ++k) {
        vl[k + is * vl_dim1] = 0.;
        vl[k + (is + 1) * vl_dim1] = 0.;
        /* L230: */
    }
} else {
    /* 如果是过渡状态并且 ki 小于 n-1 */
    if (ki < *n - 1) {
        /* 对 VL 进行乘法运算 */
        i__2 = *n - ki - 1;
        dgemv_("N", n, &i__2, &c_b15, &vl[(ki + 2) * vl_dim1 + 1], ldvl, &work[ki + 2 + *n], &c__1, &work[ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
        i__2 = *n - ki - 1;
        dgemv_("N", n, &i__2, &c_b15, &vl[(ki + 2) * vl_dim1 + 1], ldvl, &work[ki + 2 + n2], &c__1, &work[ki + 1 + n2], &vl[(ki + 1) * vl_dim1 + 1], &c__1);
    } else {
        /* 对 VL 中的向量进行缩放 */
        dscal_(n, &work[ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
        dscal_(n, &work[ki + 1 + n2], &vl[(ki + 1) * vl_dim1 + 1], &c__1);
    }

    /* 计算向量的最大模 */
    emax = 0.;
    i__2 = *n;
    for (k = 1; k <= i__2; ++k) {
        /* 计算模的最大值 */
        d__3 = emax, d__4 = (d__1 = vl[k + ki * vl_dim1], abs(d__1)) + (d__2 = vl[k + (ki + 1) * vl_dim1], abs(d__2));
        emax = max(d__3,d__4);
        /* L240: */
    }
    /* 计算归一化系数 */
    remax = 1. / emax;
    /* 对 VL 中的向量进行归一化 */
    dscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
    dscal_(n, &remax, &vl[(ki + 1) * vl_dim1 + 1], &c__1);
}

/* 增加 is 的值 */
++is;
/* 如果 ip 不为 0，则再增加 is 的值 */
if (ip != 0) {
    ++is;
}
L250:
/* 如果 ip 等于 -1，则将其设置为 0 */
if (ip == -1) {
    ip = 0;
}
/* 如果 ip 等于 1，则将其设置为 -1 */
if (ip == 1) {
    ip = -1;
}

/* L260: */
}

}

/* 返回 0 表示成功 */

/*     End of DTREVC */

} /* dtrevc_ */

/* 子程序 */ int dtrexc_(char *compq, integer *n, doublereal *t, integer *
    ldt, doublereal *q, integer *ldq, integer *ifst, integer *ilst,
    doublereal *work, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    static integer nbf, nbl, here;
    extern logical lsame_(char *, char *);
    static logical wantq;
    # 外部声明一个子程序 dlaexc_ 和 xerbla_
    extern /* Subroutine */ int dlaexc_(logical *, integer *, doublereal *,
        integer *, doublereal *, integer *, integer *, integer *, integer
        *, doublereal *, integer *);

    # 静态声明一个整数变量 nbnext
    static integer nbnext;
/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DTREXC reorders the real Schur factorization of a real matrix
    A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
    moved to row ILST.

    The real Schur form T is reordered by an orthogonal similarity
    transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
    is updated by postmultiplying it with Z.

    T must be in Schur canonical form (as returned by DHSEQR), that is,
    block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
    2-by-2 diagonal block has its diagonal elements equal and its
    off-diagonal elements of opposite sign.

    Arguments
    =========

    COMPQ   (input) CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.

    N       (input) INTEGER
            The order of the matrix T. N >= 0.

    T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            Schur canonical form.
            On exit, the reordered upper quasi-triangular matrix, again
            in Schur canonical form.

    LDT     (input) INTEGER
            The leading dimension of the array T. LDT >= max(1,N).

    Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            orthogonal transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.

    LDQ     (input) INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).

    IFST    (input/output) INTEGER
            Specify the reordering of the diagonal blocks of T.
            The block with row index IFST is moved to row ILST, by a
            sequence of transpositions between adjacent blocks.
            On exit, if IFST pointed on entry to the second row of a
            2-by-2 block, it is changed to point to the first row; ILST
            always points to the first row of the block in its final
            position (which may differ from its input value by +1 or -1).
            1 <= IFST <= N; 1 <= ILST <= N.

    WORK    (workspace) DOUBLE PRECISION array, dimension (N)

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            = 1:  two adjacent blocks were too close to swap (the problem
                  is very ill-conditioned); T may have been partially
                  reordered, and ILST points to the first row of the
                  current position of the block being moved.
*/
    =====================================================================
    # 执行解码和测试输入参数的操作
    Decode and test the input arguments.
    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --work;

    /* Function Body */
    *info = 0;
    wantq = lsame_(compq, "V");
    if (! wantq && ! lsame_(compq, "N")) {
        *info = -1;  // 设置错误码，说明参数 compq 不合法
    } else if (*n < 0) {
        *info = -2;  // 设置错误码，说明参数 n 小于零
    } else if (*ldt < max(1,*n)) {
        *info = -4;  // 设置错误码，说明参数 ldt 小于所需的最小值
    } else if (*ldq < 1 || wantq && *ldq < max(1,*n)) {
        *info = -6;  // 设置错误码，说明参数 ldq 小于所需的最小值
    } else if (*ifst < 1 || *ifst > *n) {
        *info = -7;  // 设置错误码，说明参数 ifst 超出有效范围
    } else if (*ilst < 1 || *ilst > *n) {
        *info = -8;  // 设置错误码，说明参数 ilst 超出有效范围
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DTREXC", &i__1);  // 调用错误处理例程
        return 0;
    }

/*     Quick return if possible */

    if (*n <= 1) {
        return 0;  // 如果 n 小于等于 1，直接返回
    }

/*
       Determine the first row of specified block
       and find out it is 1 by 1 or 2 by 2.
*/

    if (*ifst > 1) {
        if (t[*ifst + (*ifst - 1) * t_dim1] != 0.) {
            --(*ifst);  // 如果指定块的左下角元素非零，将 ifst 向上移动
        }
    }
    nbf = 1;  // 初始化指定块的大小
    if (*ifst < *n) {
        if (t[*ifst + 1 + *ifst * t_dim1] != 0.) {
            nbf = 2;  // 如果指定块右上角元素非零，指定块大小为 2
        }
    }

/*
       Determine the first row of the final block
       and find out it is 1 by 1 or 2 by 2.
*/

    if (*ilst > 1) {
        if (t[*ilst + (*ilst - 1) * t_dim1] != 0.) {
            --(*ilst);  // 如果最终块的左下角元素非零，将 ilst 向上移动
        }
    }
    nbl = 1;  // 初始化最终块的大小
    if (*ilst < *n) {
        if (t[*ilst + 1 + *ilst * t_dim1] != 0.) {
            nbl = 2;  // 如果最终块右上角元素非零，最终块大小为 2
        }
    }

    if (*ifst == *ilst) {
        return 0;  // 如果指定块和最终块相同，直接返回
    }

    if (*ifst < *ilst) {

/*        Update ILST */

        if (nbf == 2 && nbl == 1) {
            --(*ilst);  // 如果指定块大小为 2，最终块大小为 1，则将 ilst 向上移动
        }
        if (nbf == 1 && nbl == 2) {
            ++(*ilst);  // 如果指定块大小为 1，最终块大小为 2，则将 ilst 向下移动
        }

        here = *ifst;

L10:

/*        Swap block with next one below */

        if (nbf == 1 || nbf == 2) {

/*           Current block either 1 by 1 or 2 by 2 */

            nbnext = 1;  // 初始化下一个块的大小
            if (here + nbf + 1 <= *n) {
                if (t[here + nbf + 1 + (here + nbf) * t_dim1] != 0.) {
                    nbnext = 2;  // 如果下一个块右上角元素非零，下一个块大小为 2
                }
            }
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &here, &
                nbf, &nbnext, &work[1], info);  // 调用交换函数 dlaexc
            if (*info != 0) {
                *ilst = here;
                return 0;
            }
            here += nbnext;  // 更新当前块的位置

/*           Test if 2 by 2 block breaks into two 1 by 1 blocks */

            if (nbf == 2) {
                if (t[here + 1 + here * t_dim1] == 0.) {
                    nbf = 3;  // 如果当前块大小为 2，但右下角元素为零，则将当前块大小设置为 3
                }
            }

        } else {

/*
             Current block consists of two 1 by 1 blocks each of which
             must be swapped individually
*/

            nbnext = 1;  // 初始化下一个块的大小
            if (here + 3 <= *n) {
                if (t[here + 3 + (here + 2) * t_dim1] != 0.) {
                    nbnext = 2;  // 如果下一个块右上角元素非零，下一个块大小为 2
                }
            }
            i__1 = here + 1;
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
                c__1, &nbnext, &work[1], info);  // 调用交换函数 dlaexc
            if (*info != 0) {
                *ilst = here;
                return 0;
            }
            if (nbnext == 1) {
/*              Swap two 1 by 1 blocks, no problems possible */

/* 交换两个1x1的块，不存在问题 */

        dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
            here, &c__1, &nbnext, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释：
   - wantq: 是否计算 Q 矩阵
   - n: 矩阵的阶数
   - t[t_offset]: 矩阵 T 的首元素地址
   - ldt: 矩阵 T 的列数
   - q[q_offset]: 矩阵 Q 的首元素地址
   - ldq: 矩阵 Q 的列数
   - here: 当前操作的起始行（列）
   - c__1: 固定值1，表示只处理单个块
   - nbnext: 下一个操作的块大小
   - work[1]: 工作数组
   - info: 返回操作的状态信息 */

        ++here;
/* 当前块处理完毕，移动到下一个块 */

        } else {

/*              Recompute NBNEXT in case 2 by 2 split */

/* 在2x2块分裂的情况下重新计算 nbnext */

        if (t[here + 2 + (here + 1) * t_dim1] == 0.) {
/* 检查下一个2x2块的右上角元素是否为零 */
            nbnext = 1;
        }
        if (nbnext == 2) {

/*                 2 by 2 Block did not split */

/* 2x2 块未分裂 */

            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                here, &c__1, &nbnext, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释同上 */

            if (*info != 0) {
/* 如果操作返回错误信息 */
            *ilst = here;
/* 设置 ilst 为当前块的起始位置 */
            return 0;
/* 返回 0 表示错误 */
            }
            here += 2;
/* 移动到下一个2x2块的起始位置 */
        } else {

/*                 2 by 2 Block did split */

/* 2x2 块分裂 */

            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                here, &c__1, &c__1, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释同上 */

            i__1 = here + 1;
/* 计算下一个1x1块的起始位置 */
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                i__1, &c__1, &c__1, &work[1], info);
/* 再次调用 dlaexc 处理另一个1x1块
   参数解释同上 */

            here += 2;
/* 移动到下一个2x2块的起始位置 */
        }
        }
    }
    if (here < *ilst) {
/* 如果当前处理的块起始位置小于 ilst */
        goto L10;
/* 跳转到标签 L10 继续处理 */
    }

    } else {

    here = *ifst;
/* 将 here 设置为 ifst */

L20:

/*        Swap block with next one above */

/* 与上方的块进行交换 */

    if (nbf == 1 || nbf == 2) {

/*           Current block either 1 by 1 or 2 by 2 */

/* 当前块是1x1或者2x2 */

        nbnext = 1;
/* 设置 nbnext 为1 */
        if (here >= 3) {
/* 如果当前块的起始位置大于等于3 */
        if (t[here - 1 + (here - 2) * t_dim1] != 0.) {
/* 检查上方块的右下角元素是否为零 */
            nbnext = 2;
/* 如果不为零，设置 nbnext 为2 */
        }
        }
        i__1 = here - nbnext;
/* 计算需要交换的上方块的起始位置 */
        dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
            nbnext, &nbf, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释同上 */

        if (*info != 0) {
/* 如果操作返回错误信息 */
        *ilst = here;
/* 设置 ilst 为当前块的起始位置 */
        return 0;
/* 返回 0 表示错误 */
        }
        here -= nbnext;
/* 移动到上方块的起始位置 */

/*           Test if 2 by 2 block breaks into two 1 by 1 blocks */

/* 检测是否2x2块分裂成两个1x1块 */

        if (nbf == 2) {
/* 如果当前块是2x2块 */
        if (t[here + 1 + here * t_dim1] == 0.) {
/* 检查当前块的右上角元素是否为零 */
            nbf = 3;
/* 设置 nbf 为3，表示分裂成两个1x1块 */
        }
        }

    } else {

/*
             Current block consists of two 1 by 1 blocks each of which
             must be swapped individually
*/

/* 当前块包含两个1x1块，每个都必须单独交换 */

        nbnext = 1;
/* 设置 nbnext 为1 */
        if (here >= 3) {
/* 如果当前块的起始位置大于等于3 */
        if (t[here - 1 + (here - 2) * t_dim1] != 0.) {
/* 检查上方块的右下角元素是否为零 */
            nbnext = 2;
/* 如果不为零，设置 nbnext 为2 */
        }
        }
        i__1 = here - nbnext;
/* 计算需要交换的上方块的起始位置 */
        dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
            nbnext, &c__1, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释同上 */

        if (*info != 0) {
/* 如果操作返回错误信息 */
        *ilst = here;
/* 设置 ilst 为当前块的起始位置 */
        return 0;
/* 返回 0 表示错误 */
        }

        if (nbnext == 1) {

/*              Swap two 1 by 1 blocks, no problems possible */

/* 交换两个1x1的块，不存在问题 */

        dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
            here, &nbnext, &c__1, &work[1], info);
/* 调用 LAPACK 子程序 dlaexc ，执行矩阵 T 的特定变换，可能会修改 Q 矩阵
   参数解释同上 */
        --here;
/* 移动到上方块的起始位置 */

        } else {

/*              Recompute NBNEXT in case 2 by 2 split */

/* 在2x2块分裂的情况下重新计算 nbnext */

        if (t[here + (here - 1) * t_dim1] == 0.) {
/* 检查当前块的左下角元素是否为零 */
            nbnext = 1;
        }
        if (nbnext == 2) {
/* 如果当前块是2x2块 */
/*                 2 by 2 Block did not split */

            i__1 = here - 1;  // 计算索引偏移量，这里是上一个块结束位置的索引
            // 调用 LAPACK 的 dlaexc 函数，处理不分割的 2x2 块
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                i__1, &c__2, &c__1, &work[1], info);
            if (*info != 0) {
            *ilst = here;  // 更新 ilst 到当前块的结束位置
            return 0;  // 返回成功标志
            }
            here += -2;  // 更新 here 指向下一个块的开始位置
        } else {

/*                 2 by 2 Block did split */

            // 调用 LAPACK 的 dlaexc 函数，处理分割后的 2x2 块
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                here, &c__1, &c__1, &work[1], info);
            i__1 = here - 1;
            // 再次调用 dlaexc 处理分割后的第二个块
            dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
                i__1, &c__1, &c__1, &work[1], info);
            here += -2;  // 更新 here 指向下一个块的开始位置
        }
        }
    }
    if (here > *ilst) {
        goto L20;  // 如果当前块的结束位置大于 ilst，则跳转到标签 L20 处
    }
    }
    *ilst = here;  // 更新 ilst 到当前块的结束位置

    return 0;  // 返回成功标志

/*     End of DTREXC */

} /* dtrexc_ */

/* Subroutine */ int dtrti2_(char *uplo, char *diag, integer *n, doublereal *
    a, integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer j;
    static doublereal ajj;
    extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *,
        integer *);
    extern logical lsame_(char *, char *);
    static logical upper;
    extern /* Subroutine */ int dtrmv_(char *, char *, char *, integer *,
        doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
    static logical nounit;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======

    DTRTI2 computes the inverse of a real upper or lower triangular
    matrix.

    This is the Level 2 BLAS version of the algorithm.

    Arguments
    =========

    UPLO    (input) CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular

    DIAG    (input) CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.


注释：
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.

            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.

说明：
- `A` 是一个双精度数组，作为输入和输出参数。在输入时，根据 `UPLO` 的设定，如果是 `'U'`，则数组 `A` 的前 n 行 n 列是上三角矩阵，且不会引用严格的下三角部分；如果是 `'L'`，则 `A` 的前 n 行 n 列是下三角矩阵，且不会引用严格的上三角部分。如果 `DIAG` 是 `'U'`，则对角线元素也不会被引用，默认为 1。
- 在函数执行完毕后，数组 `A` 中存储着原始矩阵的逆矩阵，仍然保持相同的存储格式。


    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

说明：
- `LDA` 是整数输入参数，表示数组 `A` 的主维度。它必须满足 `LDA >= max(1,N)`，其中 `N` 是数组 `A` 的列数或行数中较大的那个。


    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -k, the k-th argument had an illegal value

说明：
- `INFO` 是整数输出参数，用于指示函数执行的状态：
  - `INFO = 0`：表示函数成功执行。
  - `INFO < 0`：表示发生错误，具体而言，如果 `INFO = -k`，则第 k 个输入参数有非法值。


    =====================================================================


       Test the input parameters.

说明：
- 这部分注释指示接下来的代码段是用来测试输入参数的有效性。
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    nounit = lsame_(diag, "N");

    /* Check for errors in input parameters */
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    }

    /* If error detected, call XERBLA and return */
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DTRTI2", &i__1);
        return 0;
    }

    /* Compute the inverse of the triangular matrix */
    if (upper) {
        /* Compute inverse of upper triangular matrix */

        /* Loop over columns from 1 to *n */
        i__1 = *n;
        for (j = 1; j <= i__1; ++j) {
            if (nounit) {
                /* Compute the diagonal element */
                a[j + j * a_dim1] = 1. / a[j + j * a_dim1];
                ajj = -a[j + j * a_dim1];
            } else {
                ajj = -1.;
            }

            /* Compute elements 1:j-1 of j-th column */
            i__2 = j - 1;
            dtrmv_("Upper", "No transpose", diag, &i__2, &a[a_offset], lda, &
                a[j * a_dim1 + 1], &c__1);
            i__2 = j - 1;
            dscal_(&i__2, &ajj, &a[j * a_dim1 + 1], &c__1);
        }
    } else {
        /* Compute inverse of lower triangular matrix */

        /* Loop over columns from *n down to 1 */
        for (j = *n; j >= 1; --j) {
            if (nounit) {
                /* Compute the diagonal element */
                a[j + j * a_dim1] = 1. / a[j + j * a_dim1];
                ajj = -a[j + j * a_dim1];
            } else {
                ajj = -1.;
            }

            if (j < *n) {
                /* Compute elements j+1:n of j-th column */
                i__1 = *n - j;
                dtrmv_("Lower", "No transpose", diag, &i__1, &a[j + 1 + (j +
                    1) * a_dim1], lda, &a[j + 1 + j * a_dim1], &c__1);
                i__1 = *n - j;
                dscal_(&i__1, &ajj, &a[j + 1 + j * a_dim1], &c__1);
            }
        }
    }

    return 0;

/*     End of DTRTI2 */

} /* dtrti2_ */

/* Subroutine */ int dtrtri_(char *uplo, char *diag, integer *n, doublereal *
    a, integer *lda, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, i__1, i__2[2], i__3, i__4, i__5;
    char ch__1[2];

    /* Local variables */
    static integer j, jb, nb, nn;
    extern logical lsame_(char *, char *);
    extern /* Subroutine */ int dtrmm_(char *, char *, char *, char *,
        integer *, integer *, doublereal *, doublereal *, integer *,
        doublereal *, integer *), dtrsm_(
        char *, char *, char *, char *, integer *, integer *, doublereal *
        , doublereal *, integer *, doublereal *, integer *);
    static logical upper;
    extern /* Subroutine */ int dtrti2_(char *, char *, integer *, doublereal
        *, integer *, integer *), xerbla_(char *, integer
        *);
    extern integer ilaenv_(integer *, char *, char *, integer *, integer *,
        integer *, integer *, ftnlen, ftnlen);
    static logical nounit;


/*
    -- LAPACK routine (version 3.2) --
    -- LAPACK is a software package provided by Univ. of Tennessee,    --
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
       November 2006


    Purpose
    =======
    # 测试输入参数
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U");
    nounit = lsame_(diag, "N");
    if (! upper && ! lsame_(uplo, "L")) {
        *info = -1;
    } else if (! nounit && ! lsame_(diag, "U")) {
        *info = -2;
    } else if (*n < 0) {
        *info = -3;
    } else if (*lda < max(1,*n)) {
        *info = -5;
    }
    if (*info != 0) {
        i__1 = -(*info);
        xerbla_("DTRTRI", &i__1);
        return 0;
    }

    /* Quick return if possible */
    if (*n == 0) {
        return 0;
    }

    /* Check for singularity if non-unit. */
    if (nounit) {
        i__1 = *n;
        for (*info = 1; *info <= i__1; ++(*info)) {
            if (a[*info + *info * a_dim1] == 0.) {
                return 0;
            }
            /* L10: */
        }
        *info = 0;
    }

    /* Determine the block size for this environment. */
    i__2[0] = 1, a__1[0] = uplo;
    i__2[1] = 1, a__1[1] = diag;
    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);
    nb = ilaenv_(&c__1, "DTRTRI", ch__1, n, &c_n1, &c_n1, &c_n1, (ftnlen)6, (ftnlen)2);
    if (nb <= 1 || nb >= *n) {
        /* Use unblocked code */
        dtrti2_(uplo, diag, n, &a[a_offset], lda, info);
    } else {
        /* Use blocked code */
        if (upper) {
            /* Compute inverse of upper triangular matrix */
            i__1 = *n;
            i__3 = nb;
            for (j = 1; i__3 < 0 ? j >= i__1 : j <= i__1; j += i__3) {
                /* Computing MIN */
                i__4 = nb, i__5 = *n - j + 1;
                jb = min(i__4,i__5);

                /* Compute rows 1:j-1 of current block column */
                i__4 = j - 1;
                dtrmm_("Left", "Upper", "No transpose", diag, &i__4, &jb, &c_b15, &a[a_offset], lda, &a[j * a_dim1 + 1], lda);
                i__4 = j - 1;
                dtrsm_("Right", "Upper", "No transpose", diag, &i__4, &jb, &c_b151, &a[j + j * a_dim1], lda, &a[j * a_dim1 + 1], lda);

                /* Compute inverse of current diagonal block */
                dtrti2_("Upper", diag, &jb, &a[j + j * a_dim1], lda, info);
                /* L20: */
            }
        } else {
            /* Compute inverse of lower triangular matrix */
            nn = (*n - 1) / nb * nb + 1;
            i__3 = -nb;
            for (j = nn; i__3 < 0 ? j >= 1 : j <= 1; j += i__3) {
                /* Computing MIN */
                i__1 = nb, i__4 = *n - j + 1;
                jb = min(i__1,i__4);
                if (j + jb <= *n) {
                    /* Compute rows j+jb:n of current block column */
                    i__1 = *n - j - jb + 1;
                    dtrmm_("Left", "Lower", "No transpose", diag, &i__1, &jb, &c_b15, &a[j + jb + (j + jb) * a_dim1], lda, &a[j + jb + j * a_dim1], lda);
                    i__1 = *n - j - jb + 1;
                    dtrsm_("Right", "Lower", "No transpose", diag, &i__1, &jb, &c_b151, &a[j + j * a_dim1], lda, &a[j + jb + j * a_dim1], lda);
                }
            }
        }
    }
/*              Compute inverse of current diagonal block */
/* 计算当前对角块的逆矩阵 */

dtrti2_("Lower", diag, &jb, &a[j + j * a_dim1], lda, info);
/* 调用 LAPACK 中的 dtrti2 函数，计算下三角矩阵的逆 */
/* "Lower" 表示输入的矩阵是下三角矩阵 */
/* diag 是一个字符参数，指示如何处理对角元素 */
/* jb 是一个整数参数，表示矩阵的维数 */
/* &a[j + j * a_dim1] 是指向当前对角块起始位置的指针 */
/* lda 是矩阵 a 的第一维的尺寸 */
/* info 是输出参数，返回函数调用的状态信息 */

/* L30: */
/* 标签 L30:，用作程序中的跳转目标 */

}
/* 结束函数 dtrtri_ */

/*     End of DTRTRI */
/* 程序块 DTRTRI 的结束 */

} /* dtrtri_ */
/* 结束函数 dtrtri_ */
```