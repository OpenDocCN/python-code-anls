# `.\numpy\numpy\f2py\rules.py`

```
# 指定脚本的解释器为 Python 3
#!/usr/bin/env python3

"""
Rules for building C/API module with f2py2e.

Here is a skeleton of a new wrapper function (13Dec2001):

wrapper_function(args)
  declarations
  get_python_arguments, say, `a' and `b'

  get_a_from_python
  if (successful) {

    get_b_from_python
    if (successful) {

      callfortran
      if (successful) {

        put_a_to_python
        if (successful) {

          put_b_to_python
          if (successful) {

            buildvalue = ...

          }

        }

      }

    }
    cleanup_b

  }
  cleanup_a

  return buildvalue

Copyright 1999 -- 2011 Pearu Peterson all rights reserved.
Copyright 2011 -- present NumPy Developers.
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
"""

# 导入标准库模块
import os, sys
# 导入时间模块
import time
# 导入拷贝模块
import copy
# 从 pathlib 模块中导入 Path 类
from pathlib import Path

# 导入当前包的版本信息
from . import __version__

# 导入辅助函数
from .auxfuncs import (
    applyrules, debugcapi, dictappend, errmess, gentitle, getargs2,
    hascallstatement, hasexternals, hasinitvalue, hasnote,
    hasresultnote, isarray, isarrayofstrings, ischaracter,
    ischaracterarray, ischaracter_or_characterarray, iscomplex,
    iscomplexarray, iscomplexfunction, iscomplexfunction_warn,
    isdummyroutine, isexternal, isfunction, isfunction_wrap, isint1,
    isint1array, isintent_aux, isintent_c, isintent_callback,
    isintent_copy, isintent_hide, isintent_inout, isintent_nothide,
    isintent_out, isintent_overwrite, islogical, islong_complex,
    islong_double, islong_doublefunction, islong_long,
    islong_longfunction, ismoduleroutine, isoptional, isrequired,
    isscalar, issigned_long_longarray, isstring, isstringarray,
    isstringfunction, issubroutine, isattr_value,
    issubroutine_wrap, isthreadsafe, isunsigned, isunsigned_char,
    isunsigned_chararray, isunsigned_long_long,
    isunsigned_long_longarray, isunsigned_short, isunsigned_shortarray,
    l_and, l_not, l_or, outmess, replace, stripcomma, requiresf90wrapper
)

# 导入包内部模块
from . import capi_maps
from . import cfuncs
from . import common_rules
from . import use_rules
from . import f90mod_rules
from . import func2subr

# 设置 f2py_version 和 numpy_version 变量为当前包的版本信息
f2py_version = __version__.version
numpy_version = __version__.version

# 初始化选项和分隔字典
options = {}
sepdict = {}

# 配置分隔字典的各个键对应的分隔符
for k in ['decl',
          'frompyobj',
          'cleanupfrompyobj',
          'topyarr', 'method',
          'pyobjfrom', 'closepyobjfrom',
          'freemem',
          'userincludes',
          'includes0', 'includes', 'typedefs', 'typedefs_generated',
          'cppmacros', 'cfuncs', 'callbacks',
          'latexdoc',
          'restdoc',
          'routine_defs', 'externroutines',
          'initf2pywraphooks',
          'commonhooks', 'initcommonhooks',
          'f90modhooks', 'initf90modhooks']:
    sepdict[k] = '\n'

# 注释结束，下面是关于 C/API 模块的规则
#################### Rules for C/API module #################
# 获取环境变量中名为 'SOURCE_DATE_EPOCH' 的值，转换为整数，如果不存在则使用当前时间戳
generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))

# 定义模块规则字典，包含自动生成的模块文件头部信息
module_rules = {
    # 模块主体部分的注释，包含生成的日期和警告信息
    'modulebody': """\
/* File: #modulename#module.c
 * This file is auto-generated with f2py (version:#f2py_version#).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: """ + time.asctime(time.gmtime(generationtime)) + """
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern \"C\" {
#endif

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */

/* Unconditionally included */
#include <Python.h>
#include <numpy/npy_os.h>

""" + gentitle("See f2py2e/cfuncs.py: includes") + """
#includes#
#includes0#

""" + gentitle("See f2py2e/rules.py: mod_rules['modulebody']") + """
static PyObject *#modulename#_error;
static PyObject *#modulename#_module;

""" + gentitle("See f2py2e/cfuncs.py: typedefs") + """
#typedefs#

""" + gentitle("See f2py2e/cfuncs.py: typedefs_generated") + """
#typedefs_generated#

""" + gentitle("See f2py2e/cfuncs.py: cppmacros") + """
#cppmacros#

""" + gentitle("See f2py2e/cfuncs.py: cfuncs") + """
#cfuncs#

""" + gentitle("See f2py2e/cfuncs.py: userincludes") + """
#userincludes#

""" + gentitle("See f2py2e/capi_rules.py: usercode") + """
#usercode#

/* See f2py2e/rules.py */
#externroutines#

""" + gentitle("See f2py2e/capi_rules.py: usercode1") + """
#usercode1#

""" + gentitle("See f2py2e/cb_rules.py: buildcallback") + """
#callbacks#

""" + gentitle("See f2py2e/rules.py: buildapi") + """
#body#

""" + gentitle("See f2py2e/f90mod_rules.py: buildhooks") + """
#f90modhooks#

""" + gentitle("See f2py2e/rules.py: module_rules['modulebody']") + """

""" + gentitle("See f2py2e/common_rules.py: buildhooks") + """
#commonhooks#

""" + gentitle("See f2py2e/rules.py") + """

static FortranDataDef f2py_routine_defs[] = {
#routine_defs#
    {NULL}
};

static PyMethodDef f2py_module_methods[] = {
#pymethoddef#
    {NULL,NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "#modulename#",
    NULL,
    -1,
    f2py_module_methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_#modulename#(void) {
    int i;
    PyObject *m,*d, *s, *tmp;
    m = #modulename#_module = PyModule_Create(&moduledef);
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    import_array();
    if (PyErr_Occurred())
        {PyErr_SetString(PyExc_ImportError, \"can't initialize module #modulename# (failed to import numpy)\"); return m;}
    d = PyModule_GetDict(m);
    s = PyUnicode_FromString(\"#f2py_version#\");
    PyDict_SetItemString(d, \"__version__\", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(
        \"This module '#modulename#' is auto-generated with f2py (version:#f2py_version#).\\nFunctions:\\n\"\n#docs#\".\");
    PyDict_SetItemString(d, \"__doc__\", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(\"""" + numpy_version + """\");
    # 将字符串键为 "__f2py_numpy_version__" 的项设置为变量 s 所指向的对象
    PyDict_SetItemString(d, "__f2py_numpy_version__", s);
    # 递减引用计数，释放对象 s
    Py_DECREF(s);
    #modulename#_error = PyErr_NewException ("#modulename#.error", NULL, NULL);
    /*
     * 将错误对象 #modulename#_error 存储在字典 d 中，以便它可以被释放。
     * 在实践中，这是一个模块，所以它可能不会也不应该被释放。
     */
    PyDict_SetItemString(d, "_#modulename#_error", #modulename#_error);
    # 递减引用计数，释放对象 #modulename#_error
    Py_DECREF(#modulename#_error);
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
        // 为 f2py_routine_defs 数组中每个函数定义创建一个 PyFortranObject 对象，并作为属性存储在 tmp 中
        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
        // 将 tmp 对象添加到字典 d 中，键为 f2py_routine_defs[i].name
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
        // 递减引用计数，释放 tmp 对象
        Py_DECREF(tmp);
    }
# 初始化F2PY包装钩子
defmod_rules = [
    {
        'body': '/*eof body*/',  # 模块主体结束标志
        'method': '/*eof method*/',  # 方法结束标志
        'externroutines': '/*eof externroutines*/',  # 外部函数声明结束标志
        'routine_defs': '/*eof routine_defs*/',  # 函数定义结束标志
        'initf90modhooks': '/*eof initf90modhooks*/',  # 初始化F90模块钩子结束标志
        'initf2pywraphooks': '/*eof initf2pywraphooks*/',  # 初始化F2PY包装钩子结束标志
        'initcommonhooks': '/*eof initcommonhooks*/',  # 初始化公共钩子结束标志
        'latexdoc': '',  # LaTeX文档内容为空
        'restdoc': '',  # reStructuredText文档内容为空
        'modnote': {hasnote: '#note#', l_not(hasnote): ''},  # 模块注释存在与不存在的情况分别为“#note#”和空字符串
    }
]

routine_rules = {
    'separatorsfor': sepdict,  # 用于分隔符的字典
    'body': """
#begintitle#
static char doc_#apiname#[] = \"\\\n#docreturn##name#(#docsignatureshort#)\\n\\nWrapper for ``#name#``.\\\n\\n#docstrsigns#\";
/* #declfortranroutine# */
static PyObject *#apiname#(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           #functype# (*f2py_func)(#callprotoargument#)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
#decl#
    static char *capi_kwlist[] = {#kwlist##kwlistopt##kwlistxa#NULL};
#usercode#
#routdebugenter#
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\\
        \"#argformat#|#keyformat##xaformat#:#pyname#\",\\
        capi_kwlist#args_capi##keys_capi##keys_xa#))\n        return NULL;
#frompyobj#
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
#callfortranroutine#
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
#pyobjfrom#
/*end of pyobjfrom*/
        CFUNCSMESS(\"Building return value.\\n\");
        capi_buildvalue = Py_BuildValue(\"#returnformat#\"#return#);
/*closepyobjfrom*/
#closepyobjfrom#
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
#cleanupfrompyobj#
    if (capi_buildvalue == NULL) {
#routdebugfailure#
    } else {
#routdebugleave#
    }
    CFUNCSMESS(\"Freeing memory.\\n\");
#freemem#
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
#endtitle#
""",
    'routine_defs': '#routine_def#',  # 函数定义
    'initf2pywraphooks': '#initf2pywraphook#',  # 初始化F2PY包装钩子
    'externroutines': '#declfortranroutine#',  # 外部函数声明
    'doc': '#docreturn##name#(#docsignature#)',  # 文档
    'docshort': '#docreturn##name#(#docsignatureshort#)',  # 简短文档
    'docs': '"    #docreturn##name#(#docsignature#)\\n"\n',  # 文档字符串
}
    # 定义一个字典，包含需要的文件名列表
    'need': ['arrayobject.h', 'CFUNCSMESS', 'MINMAX'],
    # 定义一个字典，包含 C++ 宏的名称及其对应的宏定义
    'cppmacros': {debugcapi: '#define DEBUGCFUNCS'},
    # 定义一个列表，包含 LaTeX 文档中的特定文本内容
    'latexdoc': ['\\subsection{Wrapper function \\texttt{#texname#}}\n',
                 """
                 # 此处可能包含更多的 LaTeX 文档内容，未在示例中显示完整
                 """
                 """
# 定义文档字符串和注释相关的字符串常量和模板
# 注意：这些字符串是用于生成函数文档和注释的模板

# 定义函数的规则和参数配置
rout_rules = [
    {  # Init
        # 指定不同类型的分隔符，用于各种函数和调试信息的分隔
        'separatorsfor': {
            'callfortranroutine': '\n',
            'routdebugenter': '\n',
            'decl': '\n',
            'routdebugleave': '\n',
            'routdebugfailure': '\n',
            'setjmpbuf': ' || ',
            'docstrreq': '\n',
            'docstropt': '\n',
            'docstrout': '\n',
            'docstrcbs': '\n',
            'docstrsigns': '\\n"\n"',
            'latexdocstrsigns': '\n',
            'latexdocstrreq': '\n',
            'latexdocstropt': '\n',
            'latexdocstrout': '\n',
            'latexdocstrcbs': '\n',
        },
        'kwlist': '',
        'kwlistopt': '',
        'callfortran': '',
        'callfortranappend': '',
        'docsign': '',
        'docsignopt': '',
        'decl': '/*decl*/',  # 在声明时添加注释
        'freemem': '/*freemem*/',  # 释放内存时添加注释
        'docsignshort': '',
        'docsignoptshort': '',
        'docstrsigns': '',  # 文档字符串中的标志
        'latexdocstrsigns': '',
        'docstrreq': '\\nParameters\\n----------',  # 必需参数的文档字符串格式
        'docstropt': '\\nOther Parameters\\n----------------',  # 可选参数的文档字符串格式
        'docstrout': '\\nReturns\\n-------',  # 返回值的文档字符串格式
        'docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n',  # 回调函数的文档字符串格式
        'latexdocstrreq': '\\noindent Required arguments:',  # LaTeX 格式下的必需参数说明
        'latexdocstropt': '\\noindent Optional arguments:',  # LaTeX 格式下的可选参数说明
        'latexdocstrout': '\\noindent Return objects:',  # LaTeX 格式下的返回对象说明
        'latexdocstrcbs': '\\noindent Call-back functions:',  # LaTeX 格式下的回调函数说明
        'args_capi': '',
        'keys_capi': '',
        'functype': '',
        'frompyobj': '/*frompyobj*/',  # 从 Python 对象转换时的注释
        'cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'],  # 清理从 Python 对象转换的结尾注释
        'pyobjfrom': '/*pyobjfrom*/',  # 转换为 Python 对象时的注释
        'closepyobjfrom': ['/*end of closepyobjfrom*/'],  # 关闭 Python 对象转换时的结尾注释
        'topyarr': '/*topyarr*/',  # 转换为数组时的注释
        'routdebugleave': '/*routdebugleave*/',  # 函数调试离开时的注释
        'routdebugenter': '/*routdebugenter*/',  # 函数调试进入时的注释
        'routdebugfailure': '/*routdebugfailure*/',  # 函数调试失败时的注释
        'callfortranroutine': '/*callfortranroutine*/',  # 调用 Fortran 程序时的注释
        'argformat': '',
        'keyformat': '',
        'need_cfuncs': '',
        'docreturn': '',  # 文档返回值
        'return': '',  # 返回值
        'returnformat': '',
        'rformat': '',
        'kwlistxa': '',
        'keys_xa': '',
        'xaformat': '',
        'docsignxa': '',
        'docsignxashort': '',
        'initf2pywraphook': '',
        'routnote': {hasnote: '--- #note#', l_not(hasnote): ''},  # 函数的注释和说明
    },
    {
        'apiname': 'f2py_rout_#modulename#_#name#',  # 函数 API 名称
        'pyname': '#modulename#.#name#',  # Python 函数名称
        'decl': '',
        '_check': l_not(ismoduleroutine),  # 是否为模块化的函数
    },
    {
        'apiname': 'f2py_rout_#modulename#_#f90modulename#_#name#',  # 函数 API 名称
        'pyname': '#modulename#.#f90modulename#.#name#',  # Python 函数名称
        'decl': '',
        '_check': ismoduleroutine,  # 是否为模块化的函数
    }
]
    }, {  # Subroutine
        'functype': 'void',
        'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);',
                               l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern void #fortranname#(#callprotoargument#);',
                               ismoduleroutine: '',  # 如果是模块中的例行程序，不需要任何声明
                               isdummyroutine: ''  # 如果是虚拟例行程序，也不需要任何声明
                               },
        'routine_def': {
            l_not(l_or(ismoduleroutine, isintent_c, isdummyroutine)):
            '    {\"#name#\",-1,{{-1}},0,0,(char *)'
            '  #F_FUNC#(#fortranname#,#FORTRANNAME#),'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',  # 定义非模块例行程序的例行程序的初始化结构体
            l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)):
            '    {\"#name#\",-1,{{-1}},0,0,(char *)#fortranname#,'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',  # 定义 C 意图的例行程序的初始化结构体
            l_and(l_not(ismoduleroutine), isdummyroutine):
            '    {\"#name#\",-1,{{-1}},0,0,NULL,'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',  # 定义虚拟例行程序的初始化结构体
        },
        'need': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC'},  # 非模块例行程序需要 F_FUNC
        'callfortranroutine': [
            {debugcapi: [
                """    fprintf(stderr,\"debug-capi:Fortran subroutine `#fortranname#(#callfortran#)\'\\n\");"""]},  # 如果是 debugcapi，则输出调试信息
            {hasexternals: """\
        if (#setjmpbuf#) {
            f2py_success = 0;
        } else {"""},  # 如果有 externals，则进行异常处理
            {isthreadsafe: '            Py_BEGIN_ALLOW_THREADS'},  # 如果是线程安全的，则开始 Python GIL 保护
            {hascallstatement: '''                #callstatement#;
                /*(*f2py_func)(#callfortran#);*/'''},  # 如果有调用语句，则执行调用
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '                (*f2py_func)(#callfortran#);'},  # 如果没有调用语句，但不是虚拟例行程序，则执行函数调用
            {isthreadsafe: '            Py_END_ALLOW_THREADS'},  # 结束 Python GIL 保护
            {hasexternals: """        }"""}  # 结束 externals 的异常处理
        ],
        '_check': l_and(issubroutine, l_not(issubroutine_wrap)),  # 检查是否为例行程序，且不是包装过的例行程序
    }, {  # Wrapped function
        'functype': 'void',
        'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);',
                               isdummyroutine: ''  # 如果是虚拟例行程序，则不需要声明
                               },

        'routine_def': {
            l_not(l_or(ismoduleroutine, isdummyroutine)):
            '    {\"#name#\",-1,{{-1}},0,0,(char *)'
            '  #F_WRAPPEDFUNC#(#name_lower#,#NAME#),'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',  # 定义非模块虚拟例行程序的初始化结构体
            isdummyroutine:
            '    {\"#name#\",-1,{{-1}},0,0,NULL,'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',  # 定义虚拟例行程序的初始化结构体
        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      // 声明一个外部 C 函数原型，其返回类型为 ctype，函数名为 F_FUNC，参数为 name_lower 和 NAME
      extern #ctype# #F_FUNC#(#name_lower#,#NAME#)(void);
      // 从 Python 字典 d 中获取键名为 "#name#" 的项，并赋给 PyObject 指针 o
      PyObject* o = PyDict_GetItemString(d,"#name#");
      // 使用 F2PyCapsule_FromVoidPtr 函数将 #F_FUNC#(#name_lower#,#NAME#) 的返回值转换为 Python capsule 对象 tmp
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);
      // 将 tmp 设置为 o 对象的 "_cpointer" 属性
      PyObject_SetAttrString(o,"_cpointer", tmp);
      // 释放 tmp 对象的引用计数
      Py_DECREF(tmp);
      // 创建字符串对象 s，内容为 "#name#"，并赋给 s
      s = PyUnicode_FromString("#name#");
      // 将 s 设置为 o 对象的 "__name__" 属性
      PyObject_SetAttrString(o,"__name__", s);
      // 释放 s 对象的引用计数
      Py_DECREF(s);
    }
    '''},
        // 当 l_not(l_or(ismoduleroutine, isdummyroutine)) 不成立时，需包含 'F_WRAPPEDFUNC' 和 'F_FUNC' 两个字段
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        // 若 debugcapi 为真，则输出格式化的调试信息到标准错误流 stderr
        'callfortranroutine': [
            {debugcapi: [
                """    fprintf(stderr,\"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n\");"""]},
            // 若 hasexternals 为真，则根据条件设置 f2py_success 的值
            {hasexternals: """\
    if (#setjmpbuf#) {
        f2py_success = 0;
    } else {"""},
            // 若 isthreadsafe 为真，则开始允许 Python 线程
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            // 若 l_not(l_or(hascallstatement, isdummyroutine)) 不成立时，调用指针 f2py_func 指向的函数 #callfortran#
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(#callfortran#);'},
            // 若 hascallstatement 为真时，执行 #callstatement# 语句
            {hascallstatement:
                '    #callstatement#;\n    /*(*f2py_func)(#callfortran#);*/'},
            // 若 isthreadsafe 为真，则结束允许 Python 线程
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            // 若 hasexternals 为真时，结束条件分支
            {hasexternals: '    }'}
        ],
        // 检查对象是否为函数包装
        '_check': isfunction_wrap,
    }, {  // Wrapped subroutine
        // 函数类型为 void
        'functype': 'void',
        // 定义 Fortran 子例程声明，根据条件设置不同的值
        'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);',
                               isdummyroutine: '',
                               },
        // Fortran 子例程定义，根据条件设置不同的值
        'routine_def': {
            l_not(l_or(ismoduleroutine, isdummyroutine)):
            '    {\"#name#\",-1,{{-1}},0,0,(char *)'
            '  #F_WRAPPEDFUNC#(#name_lower#,#NAME#),'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',
            isdummyroutine:
            '    {\"#name#\",-1,{{-1}},0,0,NULL,'
            '  (f2py_init_func)#apiname#,doc_#apiname#},',
        },
        // 初始化 F2Py 包装钩子，根据条件设置不同的值
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      // 声明一个外部函数原型 #F_FUNC#，其返回类型为 void，参数为 #name_lower# 和 #NAME#
      extern void #F_FUNC#(#name_lower#,#NAME#)(void);
      // 从 Python 字典 d 中获取键名为 "#name#" 的项，并赋给 PyObject 指针 o
      PyObject* o = PyDict_GetItemString(d,"#name#");
      // 使用 F2PyCapsule_FromVoidPtr 函数将 #F_FUNC#(#name_lower#,#NAME#) 的返回值转换为 Python capsule 对象 tmp
      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);
      // 将 tmp 设置为 o 对象的 "_cpointer" 属性
      PyObject_SetAttrString(o,"_cpointer", tmp);
      // 释放 tmp 对象的引用计数
      Py_DECREF(tmp);
      // 创建字符串对象 s，内容为 "#name#"，并赋给 s
      s = PyUnicode_FromString("#name#");
      // 将 s 设置为 o 对象的 "__name__" 属性
      PyObject_SetAttrString(o,"__name__", s);
      // 释放 s 对象的引用计数
      Py_DECREF(s);
    }
    '''},
        // 当 l_not(l_or(ismoduleroutine, isdummyroutine)) 不成立时，需包含 'F_WRAPPEDFUNC' 和 'F_FUNC' 两个字段
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        // 调用 Fortran 子例程，根据条件设置不同的值
        'callfortranroutine': [
            // 若 debugcapi 为真，则输出格式化的调试信息到标准错误流 stderr
            {debugcapi: [
                """    fprintf(stderr,\"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n\");"""]},
            // 若 hasexternals 为真，则根据条件设置 f2py_success 的值
            {hasexternals: """\
    if (#setjmpbuf#) {
        f2py_success = 0;
    } else {"""},
            // 若 isthreadsafe 为真，则开始允许 Python 线程
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            // 若 l_not(l_or(hascallstatement, isdummyroutine)) 不成立时，调用指针 f2py_func 指向的函数 #callfortran#
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(#callfortran#);'},
            // 若 hascallstatement 为真时，执行 #callstatement# 语句
            {hascallstatement:
                '    #callstatement#;\n    /*(*f2py_func)(#callfortran#);*/'},
            // 若 isthreadsafe 为真，则结束允许 Python 线程
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            // 若 hasexternals 为真时，结束条件分支
            {hasexternals: '    }'}
        ],
        // 检查对象是否为函数包装
        '_check': isfunction_wrap,
    }
    } else {"""
            # 如果不是线程安全的情况下，进行特定处理
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            # 如果不是调用语句或者是虚拟例程，调用Fortran函数
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(#callfortran#);'},
            # 如果有调用语句，执行调用语句并注释掉调用Fortran函数
            {hascallstatement:
                '    #callstatement#;\n    /*(*f2py_func)(#callfortran#);*/'},
            # 如果是线程安全的情况下，结束线程保护区域
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            # 如果有外部引用，进行特定处理
            {hasexternals: '    }'}
        ],
        '_check': issubroutine_wrap,
    }, {  # Function
        'functype': '#ctype#',
        'docreturn': {l_not(isintent_hide): '#rname#,'},
        'docstrout': '#pydocsignout#',
        'latexdocstrout': ['\\item[]{{}\\verb@#pydocsignout#@{}}',
                           {hasresultnote: '--- #resultnote#'}],
        'callfortranroutine': [{l_and(debugcapi, isstringfunction): """\
#ifdef USESCOMPAQFORTRAN
    // 如果定义了 USESCOMPAQFORTRAN 宏，则打印使用 Compaq Fortran 的调试信息
    fprintf(stderr,"debug-capi:Fortran function #ctype# #fortranname#(#callcompaqfortran#)\n");
#else
    // 否则，打印使用普通 Fortran 的调试信息
    fprintf(stderr,"debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)\n");
#endif
        '''},
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    #name#_return_value = (*f2py_func)(#callfortran#);'},
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            {hasexternals: '    }'},
            {l_and(debugcapi, iscomplexfunction)
                   : '    fprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value.r,#name#_return_value.i);'},
            {l_and(debugcapi, l_not(iscomplexfunction)): '    fprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value);'}],
        'pyobjfrom': {iscomplexfunction: '    #name#_return_value_capi = pyobj_from_#ctype#1(#name#_return_value);'},
        'need': [{l_not(isdummyroutine): 'F_FUNC'},
                 {iscomplexfunction: 'pyobj_from_#ctype#1'},
                 {islong_longfunction: 'long_long'},
                 {islong_doublefunction: 'long_double'}],
        'returnformat': {l_not(isintent_hide): '#rformat#'},
        'return': {iscomplexfunction: ',#name#_return_value_capi',
                   l_not(l_or(iscomplexfunction, isintent_hide)): ',#name#_return_value'},
        '_check': l_and(isfunction, l_not(isstringfunction), l_not(isfunction_wrap))
    }, {  # String function # in use for --no-wrap
        'declfortranroutine': 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);',
        'routine_def': {l_not(l_or(ismoduleroutine, isintent_c)):
                        '    {\"#name#\",-1,{{-1}},0,0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},',
                        l_and(l_not(ismoduleroutine), isintent_c):
                        '    {\"#name#\",-1,{{-1}},0,0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},'
                        },
        'decl': ['    #ctype# #name#_return_value = NULL;',  # 声明返回值变量
                 '    int #name#_return_value_len = 0;'],  # 声明返回值长度变量
        'callfortran':'#name#_return_value,#name#_return_value_len,',  # 调用Fortran函数时传递返回值和长度
        'callfortranroutine':['    #name#_return_value_len = #rlength#;',  # 设置返回值的长度
                              '    if ((#name#_return_value = (string)malloc('  # 分配返回值内存
                              + '#name#_return_value_len+1) == NULL) {',  # 检查内存分配是否成功
                              '        PyErr_SetString(PyExc_MemoryError, \"out of memory\");',  # 内存分配失败时设置异常
                              '        f2py_success = 0;',  # 设置f2py_success为0表示失败
                              '    } else {',  # 如果内存分配成功
                              "        (#name#_return_value)[#name#_return_value_len] = '\\0';",  # 将返回值字符串结束符设为'\0'
                              '    }',
                              '    if (f2py_success) {',  # 如果f2py执行成功
                              {hasexternals: """\
        if (#setjmpbuf#) {  # 如果存在externals并且setjmpbuf为真
            f2py_success = 0;  # 设置f2py_success为0表示失败
        } else {"""},  # 否则开始执行以下操作
                              {isthreadsafe: '        Py_BEGIN_ALLOW_THREADS'},  # 如果是线程安全的，则开始线程
                              """\
#ifdef USESCOMPAQFORTRAN
        (*f2py_func)(#callcompaqfortran#);  # 调用Compaq Fortran代码段
#else
        (*f2py_func)(#callfortran#);  # 调用Fortran代码段
#endif
[
    {  # Code block definition for C/API function argument rules
        'separatorsfor': sepdict
    },
    {  # Common rules for processing auxiliary variables from Python objects
        'frompyobj': [
            '    /* Processing auxiliary variable #varname# */',
            {debugcapi: '    fprintf(stderr,"#vardebuginfo#\\n");'},
        ],
        'cleanupfrompyobj': '    /* End of cleaning variable #varname# */',
        'need': typedef_need_dict,
    },
    {  # Declaration and initialization of non-complex scalar variables
        'decl': '    #ctype# #varname# = 0;',
        'need': {hasinitvalue: 'math.h'},
        'frompyobj': {hasinitvalue: '    #varname# = #init#;'},
        '_check': l_and(isscalar, l_not(iscomplex)),
    },
    {  # Return statement configuration for non-complex scalar variables
        'return': ',#varname#',
        'docstrout': '#pydocsignout#',
        'docreturn': '#outvarname#,',
        'returnformat': '#varrformat#',
        '_check': l_and(isscalar, l_not(iscomplex), isintent_out),
    },
    {  # Declaration of complex scalar variables
        'decl': '    #ctype# #varname#;',
        'frompyobj': {hasinitvalue: '    #varname#.r = #init.r#, #varname#.i = #init.i#;'},
        '_check': iscomplex
    }
]
    # String
    {  # Common
        'decl': ['    #ctype# #varname# = NULL;',  # 声明一个空指针，类型为 #ctype#
                 '    int slen(#varname#);',  # 声明一个函数原型，函数名为 slen，参数为 #varname#，返回类型为 int
                 ],
        'need':['len..'],  # 需要长度信息
        '_check': isstring  # 执行 isstring 函数进行检查
    },
    # Array
    {  # Common
        'decl': ['    #ctype# *#varname# = NULL;',  # 声明一个空指针，类型为 #ctype#
                 '    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};',  # 声明一个数组，其维度为 #rank#，每个维度大小为 -1
                 '    const int #varname#_Rank = #rank#;',  # 声明一个常量整数，值为 #rank#
                 ],
        'need':['len..', {hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],  # 需要长度信息，以及某些初始化值
        '_check': isarray  # 执行 isarray 函数进行检查
    },
    # Scalararray
    {  # Common
        '_check': l_and(isarray, l_not(iscomplexarray))  # 检查是否是标量数组且不是复数数组
    }, {  # Not hidden
        '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)  # 检查是否是标量数组、非复数数组且意图不隐藏
    },
    # Integer*1 array
    {'need': '#ctype#',  # 需要类型为 #ctype# 的数据
     '_check': isint1array,  # 执行 isint1array 函数进行检查
     '_depend': ''  # 依赖为空
     },
    # Integer*-1 array
    {'need': '#ctype#',  # 需要类型为 #ctype# 的数据
     '_check': l_or(isunsigned_chararray, isunsigned_char),  # 检查是否是无符号 char 数组或者无符号 char
     '_depend': ''  # 依赖为空
     },
    # Integer*-2 array
    {'need': '#ctype#',  # 需要类型为 #ctype# 的数据
     '_check': isunsigned_shortarray,  # 检查是否是无符号 short 数组
     '_depend': ''  # 依赖为空
     },
    # Integer*-8 array
    {'need': '#ctype#',  # 需要类型为 #ctype# 的数据
     '_check': isunsigned_long_longarray,  # 检查是否是无符号 long long 数组
     '_depend': ''  # 依赖为空
     },
    # Complexarray
    {'need': '#ctype#',  # 需要类型为 #ctype# 的数据
     '_check': iscomplexarray,  # 检查是否是复数数组
     '_depend': ''  # 依赖为空
     },
    # Stringarray
    {
        'callfortranappend': {isarrayofstrings: 'flen(#varname#),'},  # 如果是字符串数组，调用 Fortran 函数追加字符串长度信息
        'need': 'string',  # 需要字符串类型
        '_check': isstringarray  # 检查是否是字符串数组
    }
]

arg_rules = [
    {  # 定义一个字典，用于指定不同规则的参数处理方式
        'separatorsfor': sepdict  # 指定分隔符的字典，用于某些处理
    },
    {  # 常见规则
        'frompyobj': [  # 从 Python 对象转换过来的处理
            '    /* Processing variable #varname# */',  # 处理变量 #varname# 的过程注释
            {debugcapi: '    fprintf(stderr,"#vardebuginfo#\\n");'},  # 如果启用了 debugcapi，输出变量的调试信息到 stderr
        ],
        'cleanupfrompyobj': '    /* End of cleaning variable #varname# */',  # 清理变量 #varname# 结束的注释
        '_depend': '',  # 依赖项为空字符串
        'need': typedef_need_dict,  # 指定需要的类型定义的字典
    },
    # 文档签名
    {
        'docstropt': {l_and(isoptional, isintent_nothide): '#pydocsign#'},  # 可选参数且意图不隐藏时的文档字符串签名
        'docstrreq': {l_and(isrequired, isintent_nothide): '#pydocsign#'},  # 必需参数且意图不隐藏时的文档字符串签名
        'docstrout': {isintent_out: '#pydocsignout#'},  # 输出参数的文档字符串签名
        'latexdocstropt': {  # 可选参数且意图不隐藏时的 LaTeX 文档字符串签名
            l_and(isoptional, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}',  # LaTeX 格式化输出
                                                  {hasnote: '--- #note#'}  # 如果有注释，添加注释信息
                                                  ]
        },
        'latexdocstrreq': {  # 必需参数且意图不隐藏时的 LaTeX 文档字符串签名
            l_and(isrequired, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}',  # LaTeX 格式化输出
                                                  {hasnote: '--- #note#'}  # 如果有注释，添加注释信息
                                                  ]
        },
        'latexdocstrout': {  # 输出参数的 LaTeX 文档字符串签名
            isintent_out: ['\\item[]{{}\\verb@#pydocsignout#@{}}',  # LaTeX 格式化输出
                          {l_and(hasnote, isintent_hide): '--- #note#',  # 如果有注释且意图隐藏，添加注释信息
                           l_and(hasnote, isintent_nothide): '--- See above.'  # 如果有注释且意图不隐藏，指向上述信息
                           }]
        },
        'depend': ''  # 依赖项为空字符串
    },
    # 必需/可选参数
    {
        'kwlist': '"#varname#",',  # 关键字参数列表的格式化输出
        'docsign': '#varname#,',  # 文档签名中的变量名格式化输出
        '_check': l_and(isintent_nothide, l_not(isoptional))  # 检查意图不隐藏且不是可选参数的条件
    },
    {
        'kwlistopt': '"#varname#",',  # 可选关键字参数列表的格式化输出
        'docsignopt': '#varname#=#showinit#,',  # 可选参数的文档签名格式化输出（包括初始值）
        'docsignoptshort': '#varname#,',  # 简短格式的可选参数的文档签名格式化输出
        '_check': l_and(isintent_nothide, isoptional)  # 检查意图不隐藏且是可选参数的条件
    },
    # 文档字符串/BuildValue
    {
        'docreturn': '#outvarname#,',  # 返回值的文档字符串格式化输出
        'returnformat': '#varrformat#',  # 返回格式的变量格式化输出
        '_check': isintent_out  # 检查是否是输出参数的条件
    },
    # 外部调用（回调函数）
    {  # Common
        'docsignxa': {isintent_nothide: '#varname#_extra_args=(),'},
        # 定义 'docsignxa' 键的值为包含 isintent_nothide 的字典，表示额外参数默认为空元组。
        
        'docsignxashort': {isintent_nothide: '#varname#_extra_args,'},
        # 定义 'docsignxashort' 键的值为包含 isintent_nothide 的字典，表示额外参数的简短形式。
        
        'docstropt': {isintent_nothide: '#varname#_extra_args : input tuple, optional\\n    Default: ()'},
        # 定义 'docstropt' 键的值为包含 isintent_nothide 的字典，表示可选输入元组形式的额外参数，默认为空。
        
        'docstrcbs': '#cbdocstr#',
        # 定义 'docstrcbs' 键的值为 '#cbdocstr#'，可能用于文档字符串中的回调描述。
        
        'latexdocstrcbs': '\\item[] #cblatexdocstr#',
        # 定义 'latexdocstrcbs' 键的值为 LaTeX 风格的表项，使用 #cblatexdocstr# 描述。
        
        'latexdocstropt': {isintent_nothide: '\\item[]{{}\\verb@#varname#_extra_args := () input tuple@{}} --- Extra arguments for call-back function {{}\\verb@#varname#@{}}.'},
        # 定义 'latexdocstropt' 键的值为包含 isintent_nothide 的字典，为回调函数描述提供 LaTeX 格式的额外参数说明。
        
        'decl': ['    #cbname#_t #varname#_cb = { Py_None, NULL, 0 };',
                 '    #cbname#_t *#varname#_cb_ptr = &#varname#_cb;',
                 '    PyTupleObject *#varname#_xa_capi = NULL;',
                 {l_not(isintent_callback):
                  '    #cbname#_typedef #varname#_cptr;'}
                 ],
        # 定义 'decl' 键的值为包含多个声明字符串的列表，其中包括回调函数的默认初始化、指针和可能的类型定义。
        
        'kwlistxa': {isintent_nothide: '"#varname#_extra_args",'},
        # 定义 'kwlistxa' 键的值为包含 isintent_nothide 的字典，表示关键字参数列表中包含额外参数的名称。
        
        'argformat': {isrequired: 'O'},
        # 定义 'argformat' 键的值为包含 isrequired 的字典，指示参数的格式要求为一个对象。
        
        'keyformat': {isoptional: 'O'},
        # 定义 'keyformat' 键的值为包含 isoptional 的字典，指示关键字的格式要求为一个对象。
        
        'xaformat': {isintent_nothide: 'O!'},
        # 定义 'xaformat' 键的值为包含 isintent_nothide 的字典，指示额外参数的格式要求为对象且必须存在。
        
        'args_capi': {isrequired: ',&#varname#_cb.capi'},
        # 定义 'args_capi' 键的值为包含 isrequired 的字典，表示参数列表中包含 C API 的参数。
        
        'keys_capi': {isoptional: ',&#varname#_cb.capi'},
        # 定义 'keys_capi' 键的值为包含 isoptional 的字典，表示关键字参数中包含 C API 的参数。
        
        'keys_xa': ',&PyTuple_Type,&#varname#_xa_capi',
        # 定义 'keys_xa' 键的值为字符串，包含元组类型的 Pyhton 类型和对应的 C API 参数。
        
        'setjmpbuf': '(setjmp(#varname#_cb.jmpbuf))',
        # 定义 'setjmpbuf' 键的值为 setjmp 函数对给定的跳转缓冲区（jmpbuf）进行调用。
        
        'callfortran': {l_not(isintent_callback): '#varname#_cptr,'},
        # 定义 'callfortran' 键的值为包含 l_not(isintent_callback) 的字典，表示用于调用 Fortran 的函数指针。
        
        'need': ['#cbname#', 'setjmp.h'],
        # 定义 'need' 键的值为列表，包含所需的回调函数和头文件 'setjmp.h'。
        
        '_check': isexternal
        # 定义 '_check' 键的值为 isexternal，可能用于指示外部检查的标志。
    },
    {  # Specific block
        'frompyobj': [{l_not(isintent_callback): """\
# 检查是否符合 F2PyCapsule 的检查条件
if(F2PyCapsule_Check(#varname#_cb.capi)) {
  #varname#_cptr = F2PyCapsule_AsVoidPtr(#varname#_cb.capi);
} else {
  #varname#_cptr = #cbname#;
}



# 如果回调函数的 C API 是 Py_None，则尝试从指定模块中获取回调函数 #varname#
if (#varname#_cb.capi==Py_None) {
  #varname#_cb.capi = PyObject_GetAttrString(#modulename#_module,\"#varname#\");
  if (#varname#_cb.capi) {
    # 检查是否需要额外的参数
    if (#varname#_xa_capi==NULL) {
      # 如果模块中存在 #varname#_extra_args 属性，则将其转换为元组
      if (PyObject_HasAttrString(#modulename#_module,\"#varname#_extra_args\")) {
        PyObject* capi_tmp = PyObject_GetAttrString(#modulename#_module,\"#varname#_extra_args\");
        if (capi_tmp) {
          #varname#_xa_capi = (PyTupleObject *)PySequence_Tuple(capi_tmp);
          Py_DECREF(capi_tmp);
        }
        else {
          # 如果未能成功获取 #varname#_extra_args 属性，则创建一个空元组
          #varname#_xa_capi = (PyTupleObject *)Py_BuildValue(\"()\");
        }
        # 检查是否成功转换为元组
        if (#varname#_xa_capi==NULL) {
          PyErr_SetString(#modulename#_error,\"Failed to convert #modulename#.#varname#_extra_args to tuple.\\n\");
          return NULL;
        }
      }
    }
  }
  # 如果未能成功获取回调函数 #varname#，则报错
  if (#varname#_cb.capi==NULL) {
    PyErr_SetString(#modulename#_error,\"Callback #varname# not defined (as an argument or module #modulename# attribute).\\n\");
    return NULL;
  }
}



# 创建回调函数的参数列表，如果失败则报错
if (create_cb_arglist(#varname#_cb.capi,#varname#_xa_capi,#maxnofargs#,#nofoptargs#,&#varname#_cb.nofargs,&#varname#_cb.args_capi,\"failed in processing argument list for call-back #varname#.\")) {



# 输出调试信息，显示回调函数的预期参数数量
fprintf(stderr,\"debug-capi:Assuming %d arguments; at most #maxnofargs#(-#nofoptargs#) is expected.\\n\",#varname#_cb.nofargs);
# 打印调试信息，显示回调函数的当前值
CFUNCSMESSPY(\"for #varname#=\",#varname#_cb.capi);



# 打印消息，表示正在保存回调函数的变量
CFUNCSMESS(\"Saving callback variables for `#varname#`.\\n\");
# 交换活跃的回调函数指针
#varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr);



# 打印消息，表示正在恢复回调函数的变量
CFUNCSMESS(\"Restoring callback variables for `#varname#`.\\n\");
# 交换活跃的回调函数指针
#varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr);
# 释放回调函数参数列表的 Python 对象引用
Py_DECREF(#varname#_cb.args_capi);
    }, {  # Not hidden
        'decl': '    PyObject *#varname#_capi = Py_None;',
        # 声明一个名为 #varname#_capi 的 PyObject 指针变量，初始化为 Py_None
        'argformat': {isrequired: 'O'},
        # 指定参数格式，isrequired 对应 'O' 表示必须的参数类型为 PyObject
        'keyformat': {isoptional: 'O'},
        # 指定关键字参数格式，isoptional 对应 'O' 表示可选的参数类型为 PyObject
        'args_capi': {isrequired: ',&#varname#_capi'},
        # 定义参数列表中的 #varname#_capi，作为必需参数
        'keys_capi': {isoptional: ',&#varname#_capi'},
        # 定义关键字参数中的 #varname#_capi，作为可选参数
        'pyobjfrom': {isintent_inout: """\
    f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);
    if (f2py_success) {"""},
        # 根据 isintent_inout 条件，执行从 PyObject 到 #ctype# 的转换，检查转换成功后的处理逻辑
        'closepyobjfrom': {isintent_inout: "    } /*if (f2py_success) of #varname# pyobjfrom*/"},
        # 根据 isintent_inout 条件，关闭 PyObject 到 #ctype# 的转换逻辑
        'need': {isintent_inout: 'try_pyarr_from_#ctype#'},
        # 指定需要进行 PyObject 到 #ctype# 转换的条件
        '_check': l_and(isscalar, l_not(iscomplex), l_not(isstring),
                        isintent_nothide)
        # 检查条件，确保是标量、非复数、非字符串，并且不隐藏意图
    }, {
        'frompyobj': [
            # 根据条件不同，执行不同的赋值逻辑，从 PyObject 到变量 #varname# 的转换
            {hasinitvalue: '    if (#varname#_capi == Py_None) #varname# = #init#; else',
             '_depend': ''},
            {l_and(isoptional, l_not(hasinitvalue)): '    if (#varname#_capi != Py_None)',
             '_depend': ''},
            {l_not(islogical): '''\
        f2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");
    if (f2py_success) {'''},
            {islogical: '''\
        #varname# = (#ctype#)PyObject_IsTrue(#varname#_capi);
        f2py_success = 1;
    if (f2py_success) {'''},
        ],
        # 根据不同的条件，执行从 PyObject 到 #ctype# 的转换逻辑，检查转换成功后的处理逻辑
        'cleanupfrompyobj': '    } /*if (f2py_success) of #varname#*/',
        # 执行从 PyObject 到 #ctype# 的转换后，进行清理逻辑
        'need': {l_not(islogical): '#ctype#_from_pyobj'},
        # 指定需要进行 PyObject 到 #ctype# 转换的条件
        '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide),
        # 检查条件，确保是标量、非复数，并且不隐藏意图
        '_depend': ''
    }, {  # Hidden
        'frompyobj': {hasinitvalue: '    #varname# = #init#;'},
        # 根据 hasinitvalue 条件，执行隐藏意图的赋值逻辑，从 PyObject 到变量 #varname# 的转换
        'need': typedef_need_dict,
        # 指定需要的 typedef 字典
        '_check': l_and(isscalar, l_not(iscomplex), isintent_hide),
        # 检查条件，确保是标量、非复数，并且隐藏意图
        '_depend': ''
    }, {  # Common
        'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#);'},
        # 根据 debugcapi 条件，执行常见的从 PyObject 到 #varname# 的转换逻辑
        '_check': l_and(isscalar, l_not(iscomplex)),
        # 检查条件，确保是标量、非复数
        '_depend': ''
    },
    # Complex scalars
    {  # Common
        'decl': '    #ctype# #varname#;',
        # 声明复杂标量类型的 #varname# 变量
        'callfortran': {isintent_c: '#varname#,', l_not(isintent_c): '&#varname#,'},
        # 根据 isintent_c 条件，生成调用 Fortran 代码的字符串
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);'},
        # 根据 debugcapi 条件，执行复杂标量类型的从 PyObject 到 #varname# 的转换逻辑
        'return': {isintent_out: ',#varname#_capi'},
        # 根据 isintent_out 条件，指定返回 #varname#_capi 的值
        '_check': iscomplex
        # 检查条件，确保是复杂标量
    }, {  # Not hidden
        'decl': '    PyObject *#varname#_capi = Py_None;',  # 声明一个名为 #varname#_capi 的 PyObject 指针变量，初始化为 Py_None
        'argformat': {isrequired: 'O'},  # 参数格式化信息，要求为必需参数，格式为 'O'
        'keyformat': {isoptional: 'O'},  # 关键字格式化信息，要求为可选参数，格式为 'O'
        'args_capi': {isrequired: ',&#varname#_capi'},  # 参数的 C API 格式化信息，要求为必需参数
        'keys_capi': {isoptional: ',&#varname#_capi'},  # 关键字的 C API 格式化信息，要求为可选参数
        'need': {isintent_inout: 'try_pyarr_from_#ctype#'},  # 需要的信息，表明是输入输出参数，需要调用 try_pyarr_from_#ctype#
        'pyobjfrom': {isintent_inout: """\  # 从 Python 对象转换而来的信息，表明是输入输出参数
        f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);
        if (f2py_success) {"""},
        'closepyobjfrom': {isintent_inout: "        } /*if (f2py_success) of #varname# pyobjfrom*/"},  # 关闭从 Python 对象转换的操作
        '_check': l_and(iscomplex, isintent_nothide)  # 检查条件，复杂类型且非隐藏意图
    }, {
        'frompyobj': [{hasinitvalue: '    if (#varname#_capi==Py_None) {#varname#.r = #init.r#, #varname#.i = #init.i#;} else'},  # 从 Python 对象转换而来的操作，具有初始值的情况下处理
                      {l_and(isoptional, l_not(hasinitvalue)): '    if (#varname#_capi != Py_None)'},  # 可选参数且无初始值的情况下处理
                      '        f2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");'
                      '\n    if (f2py_success) {'],  # 调用函数尝试从 Python 对象转换为给定类型，如果成功则继续执行
        'cleanupfrompyobj': '    }  /*if (f2py_success) of #varname# frompyobj*/',  # 清理从 Python 对象转换操作的代码块
        'need': ['#ctype#_from_pyobj'],  # 需要的信息，调用了 #ctype#_from_pyobj 函数
        '_check': l_and(iscomplex, isintent_nothide),  # 检查条件，复杂类型且非隐藏意图
        '_depend': ''  # 依赖信息为空
    }, {  # Hidden
        'decl': {isintent_out: '    PyObject *#varname#_capi = Py_None;'},  # 隐藏的声明，输出意图的 PyObject 指针变量，初始化为 Py_None
        '_check': l_and(iscomplex, isintent_hide)  # 检查条件，复杂类型且隐藏意图
    }, {
        'frompyobj': {hasinitvalue: '    #varname#.r = #init.r#, #varname#.i = #init.i#;'},  # 从 Python 对象转换而来的操作，具有初始值的情况下处理
        '_check': l_and(iscomplex, isintent_hide),  # 检查条件，复杂类型且隐藏意图
        '_depend': ''  # 依赖信息为空
    }, {  # Common
        'pyobjfrom': {isintent_out: '    #varname#_capi = pyobj_from_#ctype#1(#varname#);'},  # 通用的从 Python 对象转换操作，输出意图
        'need': ['pyobj_from_#ctype#1'],  # 需要的信息，调用了 pyobj_from_#ctype#1 函数
        '_check': iscomplex  # 检查条件，复杂类型
    }, {
        'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);'},  # 从 Python 对象转换而来的操作，输出调试信息
        '_check': iscomplex,  # 检查条件，复杂类型
        '_depend': ''  # 依赖信息为空
    },
    # String
    {  # Common
        'decl': ['    #ctype# #varname# = NULL;',  # 声明一个指向 #ctype# 类型的变量 #varname#，初始化为 NULL
                 '    int slen(#varname#);',  # 声明一个名为 slen 的整数变量，初始化为调用函数 slen(#varname#)
                 '    PyObject *#varname#_capi = Py_None;'],  # 声明一个名为 #varname#_capi 的 PyObject 指针变量，初始化为 Py_None
        'callfortran':'#varname#,',  # 调用 Fortran 函数时的参数信息
        'callfortranappend':'slen(#varname#),',  # 调用 Fortran 函数时追加的参数信息，调用函数 slen(#varname#)
        'pyobjfrom':[
            {debugcapi:
             '    fprintf(stderr,'
             '"#vardebugshowvalue#\\n",slen(#varname#),#varname#);'},  # 从 Python 对象转换而来的操作，输出调试信息
            {l_and(isintent_out, l_not(isintent_c)):
             "        STRINGPADN(#varname#, slen(#varname#), ' ', '\\0');"},  # 从 Python 对象转换而来的操作，处理输出意图且非 C 类型的情况
        ],
        'return': {isintent_out: ',#varname#'},  # 返回值的信息，输出意图
        'need': ['len..',  # 需要的信息，包含字符串长度操作
                 {l_and(isintent_out, l_not(isintent_c)): 'STRINGPADN'}],  # 需要的信息，处理输出意图且非 C 类型的情况
        '_check': isstring  # 检查条件，字符串类型
    }, {  # Common
        'frompyobj': [
            """\
    slen(#varname#) = #elsize#;
    f2py_success = #ctype#_from_pyobj(&#varname#,&slen(#varname#),#init#,"""  # 从 Python 对象转换而来的操作，设置字符串长度并调用函数尝试转换为给定类型
"""#varname#_capi,\"#ctype#_from_pyobj failed in converting #nth#"""
"""`#varname#\' of #pyname# to C #ctype#\");
    if (f2py_success) {""",
            # The trailing null value for Fortran is blank.
            {l_not(isintent_c):
             "        STRINGPADN(#varname#, slen(#varname#), '\\0', ' ');"},
        ],
        'cleanupfrompyobj': """\
        STRINGFREE(#varname#);
    }  /*if (f2py_success) of #varname#*/""",
        'need': ['#ctype#_from_pyobj', 'len..', 'STRINGFREE',
                 {l_not(isintent_c): 'STRINGPADN'}],
        '_check':isstring,
        '_depend':''
    }, {  # Not hidden
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&#varname#_capi'},
        'keys_capi': {isoptional: ',&#varname#_capi'},
        'pyobjfrom': [
            {l_and(isintent_inout, l_not(isintent_c)):
             "        STRINGPADN(#varname#, slen(#varname#), ' ', '\\0');"},
            {isintent_inout: '''\
    f2py_success = try_pyarr_from_#ctype#(#varname#_capi, #varname#,
                                          slen(#varname#));
    if (f2py_success) {'''}],
        'closepyobjfrom': {isintent_inout: '    } /*if (f2py_success) of #varname# pyobjfrom*/'},
        'need': {isintent_inout: 'try_pyarr_from_#ctype#',
                 l_and(isintent_inout, l_not(isintent_c)): 'STRINGPADN'},
        '_check': l_and(isstring, isintent_nothide)
    }, {  # Hidden
        '_check': l_and(isstring, isintent_hide)
    }, {
        'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",slen(#varname#),#varname#);'},
        '_check': isstring,
        '_depend': ''
    },
    # Array
    {  # Common
        'decl': ['    #ctype# *#varname# = NULL;',
                 '    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};',
                 '    const int #varname#_Rank = #rank#;',
                 '    PyArrayObject *capi_#varname#_as_array = NULL;',
                 '    int capi_#varname#_intent = 0;',
                 {isstringarray: '    int slen(#varname#) = 0;'},
                 ],
        'callfortran':'#varname#,',
        'callfortranappend': {isstringarray: 'slen(#varname#),'},
        'return': {isintent_out: ',capi_#varname#_as_array'},
        'need': 'len..',
        '_check': isarray
    }, {  # intent(overwrite) array
        'decl': '    int capi_overwrite_#varname# = 1;',
        'kwlistxa': '"overwrite_#varname#",',
        'xaformat': 'i',
        'keys_xa': ',&capi_overwrite_#varname#',
        'docsignxa': 'overwrite_#varname#=1,',
        'docsignxashort': 'overwrite_#varname#,',
        'docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 1',
        '_check': l_and(isarray, isintent_overwrite),
    }, {
        'frompyobj': '    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);',
        '_check': l_and(isarray, isintent_overwrite),
        '_depend': '',
    },
    {  # intent(copy) array
        'decl': '    int capi_overwrite_#varname# = 0;',
        'kwlistxa': '"overwrite_#varname#",',
        'xaformat': 'i',
        'keys_xa': ',&capi_overwrite_#varname#',
        'docsignxa': 'overwrite_#varname#=0,',
        'docsignxashort': 'overwrite_#varname#,',
        'docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 0',
        '_check': l_and(isarray, isintent_copy),
    }, {
        'frompyobj': '    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);',
        '_check': l_and(isarray, isintent_copy),
        '_depend': '',
    }, {
        'need': [{hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],
        '_check': isarray,
        '_depend': ''
    }, {  # Not hidden
        'decl': '    PyObject *#varname#_capi = Py_None;',
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&#varname#_capi'},
        'keys_capi': {isoptional: ',&#varname#_capi'},
        '_check': l_and(isarray, isintent_nothide)
    }, {
        'frompyobj': [
            '    #setdims#;',
            '    capi_#varname#_intent |= #intent#;',
            ('    const char * capi_errmess = "#modulename#.#pyname#:'
             ' failed to create array from the #nth# `#varname#`";'),
            {isintent_hide:
             '    capi_#varname#_as_array = ndarray_from_pyobj('
             '  #atype#,#elsize#,#varname#_Dims,#varname#_Rank,'
             '  capi_#varname#_intent,Py_None,capi_errmess);'},
            {isintent_nothide:
             '    capi_#varname#_as_array = ndarray_from_pyobj('
             '  #atype#,#elsize#,#varname#_Dims,#varname#_Rank,'
             '  capi_#varname#_intent,#varname#_capi,capi_errmess);'},
            """\
    if (capi_#varname#_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = #modulename#_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        #varname# = (#ctype# *)(PyArray_DATA(capi_#varname#_as_array));
        # code block intent set
# 定义了一个名为`cleanupfrompyobj`的字典列表，用于存储特定清理操作的规则
'cleanupfrompyobj': [
    '    }  '  # 关闭块注释
    '/* if (capi_#varname#_as_array == NULL) ... else of #varname# */',  # 处理特定条件下的注释
    {l_not(l_or(isintent_out, isintent_hide)): """\
    if((PyObject *)capi_#varname#_as_array!=#varname#_capi) {
        Py_XDECREF(capi_#varname#_as_array); }"""},  # 根据条件释放特定对象
    {l_and(isintent_hide, l_not(isintent_out)): """\
        Py_XDECREF(capi_#varname#_as_array);"""},  # 处理隐藏变量的清理操作
    {hasinitvalue: '    }  /*if (f2py_success) of #varname# init*/'},  # 处理初始化成功的情况
],

# 规则用于检查数组的相关定义
'check_rules': [
    {
        'frompyobj': {debugcapi: '    fprintf(stderr,\"debug-capi:Checking `#check#\'\\n\");'},  # 输出用于调试的语句
        'need': 'len..'  # 指定检查的需求条件
    }
]
    }, {
        # 开始定义一个新的字典条目，包含从 Python 对象到 C 代码的转换
        'frompyobj': '    CHECKSCALAR(#check#,\"#check#\",\"#nth# #varname#\",\"#varshowvalue#\",#varname#) {',
        # 在 C 代码中生成用于检查标量的宏定义
        'cleanupfrompyobj': '    } /*CHECKSCALAR(#check#)*/',
        # 需要定义一个标量检查
        'need': 'CHECKSCALAR',
        # 执行标量检查的条件：既不是复数，也不是复杂对象
        '_check': l_and(isscalar, l_not(iscomplex)),
        # 在此处没有需要中断的附加操作
        '_break': ''
    }, {
        # 开始定义一个新的字典条目，包含从 Python 对象到 C 代码的转换
        'frompyobj': '    CHECKSTRING(#check#,\"#check#\",\"#nth# #varname#\",\"#varshowvalue#\",#varname#) {',
        # 在 C 代码中生成用于检查字符串的宏定义
        'cleanupfrompyobj': '    } /*CHECKSTRING(#check#)*/',
        # 需要定义一个字符串检查
        'need': 'CHECKSTRING',
        # 执行字符串检查的条件：对象是字符串
        '_check': isstring,
        # 在此处没有需要中断的附加操作
        '_break': ''
    }, {
        # 需要定义一个数组检查
        'need': 'CHECKARRAY',
        # 在 C 代码中生成用于检查数组的宏定义
        'frompyobj': '    CHECKARRAY(#check#,\"#check#\",\"#nth# #varname#\") {',
        # 在 C 代码中生成用于清理数组检查的宏定义
        'cleanupfrompyobj': '    } /*CHECKARRAY(#check#)*/',
        # 执行数组检查的条件：对象是数组
        '_check': isarray,
        # 在此处没有需要中断的附加操作
        '_break': ''
    }, {
        # 需要定义一个通用检查
        'need': 'CHECKGENERIC',
        # 在 C 代码中生成用于通用检查的宏定义
        'frompyobj': '    CHECKGENERIC(#check#,\"#check#\",\"#nth# #varname#\") {',
        # 在 C 代码中生成用于清理通用检查的宏定义
        'cleanupfrompyobj': '    } /*CHECKGENERIC(#check#)*/',
        # 在此处没有需要中断的附加操作
    }
# 构建模块的函数，接收两个参数：m 表示模块信息，um 表示未使用的参数
def buildmodule(m, um):
    """
    构建模块函数，处理模块相关的构建工作并返回结果字典。

    参数:
    m -- 包含模块信息的字典
    um -- 未使用的参数，此处未被使用

    返回:
    ret -- 返回一个空字典作为占位符

    """

    # 输出构建模块的信息
    outmess('    Building module "%s"...\n' % (m['name']))

    # 初始化返回的字典
    ret = {}

    # 复制模块规则列表到 mod_rules
    mod_rules = defmod_rules[:]

    # 将模块签名映射为字典 vrd
    vrd = capi_maps.modsign2map(m)

    # 构建包含 f2py 版本信息的字典 rd
    rd = dictappend({'f2py_version': f2py_version}, vrd)

    # 初始化函数包装器列表
    funcwrappers = []

    # 初始化 F90 代码的函数包装器列表
    funcwrappers2 = []  # F90 codes

    # 遍历模块的 interfaced 列表
    for n in m['interfaced']:
        nb = None

        # 在模块的 body 中查找对应的接口块
        for bi in m['body']:
            if bi['block'] not in ['interface', 'abstract interface']:
                errmess('buildmodule: Expected interface block. Skipping.\n')
                continue
            for b in bi['body']:
                if b['name'] == n:
                    nb = b
                    break

        # 如果未找到接口块，输出错误信息并跳过
        if not nb:
            print(
                'buildmodule: Could not find the body of interfaced routine "%s". Skipping.\n' % (n), file=sys.stderr)
            continue

        # 创建接口块列表，包含当前接口块及其 entry 属性的深拷贝
        nb_list = [nb]
        if 'entry' in nb:
            for k, a in nb['entry'].items():
                nb1 = copy.deepcopy(nb)
                del nb1['entry']
                nb1['name'] = k
                nb1['args'] = a
                nb_list.append(nb1)

        # 遍历接口块列表
        for nb in nb_list:
            # 检查是否需要 F90 包装器
            isf90 = requiresf90wrapper(nb)

            # 如果选项中包含 emptygen，生成可能为空的包装器文件
            if options['emptygen']:
                b_path = options['buildpath']
                m_name = vrd['modulename']
                outmess('    Generating possibly empty wrappers"\n')
                Path(f"{b_path}/{vrd['coutput']}").touch()
                if isf90:
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers2.f90"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers2.f90').touch()
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()
                else:
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()

            # 构建 API 和包装器
            api, wrap = buildapi(nb)

            # 如果存在包装器，根据是否为 F90 添加到对应列表
            if wrap:
                if isf90:
                    funcwrappers2.append(wrap)
                else:
                    funcwrappers.append(wrap)

            # 应用规则并更新 rd 字典
            ar = applyrules(api, vrd)
            rd = dictappend(rd, ar)

    # 构建 COMMON 块支持
    cr, wrap = common_rules.buildhooks(m)
    if wrap:
        funcwrappers.append(wrap)
    ar = applyrules(cr, vrd)
    rd = dictappend(rd, ar)

    # 构建 F90 模块支持
    mr, wrap = f90mod_rules.buildhooks(m)
    if wrap:
        funcwrappers2.append(wrap)
    ar = applyrules(mr, vrd)
    rd = dictappend(rd, ar)
    # 遍历 um 列表中的元素 u
    for u in um:
        # 使用 use_rules.buildusevars 函数处理 u 和 m['use'][u['name']]，返回结果存储在 ar 中
        ar = use_rules.buildusevars(u, m['use'][u['name']])
        # 将 ar 合并到 rd 中
        rd = dictappend(rd, ar)

    # 获取需要的信息集合
    needs = cfuncs.get_needs()
    
    # 向 needs['typedefs'] 中添加从 capi_maps.f2cmap_mapped 中选择的 cvar 元素，条件是 cvar 存在于 typedef_need_dict 的值中
    needs['typedefs'] += [cvar for cvar in capi_maps.f2cmap_mapped
                          if cvar in typedef_need_dict.values()]
    
    # 初始化 code 字典
    code = {}
    
    # 遍历 needs 字典的键
    for n in needs.keys():
        # 将每个键对应的值初始化为空列表
        code[n] = []
        # 遍历 needs[n] 中的每个元素 k
        for k in needs[n]:
            c = ''
            # 根据 k 的值从不同的函数字典中获取对应的字符串 c
            if k in cfuncs.includes0:
                c = cfuncs.includes0[k]
            elif k in cfuncs.includes:
                c = cfuncs.includes[k]
            elif k in cfuncs.userincludes:
                c = cfuncs.userincludes[k]
            elif k in cfuncs.typedefs:
                c = cfuncs.typedefs[k]
            elif k in cfuncs.typedefs_generated:
                c = cfuncs.typedefs_generated[k]
            elif k in cfuncs.cppmacros:
                c = cfuncs.cppmacros[k]
            elif k in cfuncs.cfuncs:
                c = cfuncs.cfuncs[k]
            elif k in cfuncs.callbacks:
                c = cfuncs.callbacks[k]
            elif k in cfuncs.f90modhooks:
                c = cfuncs.f90modhooks[k]
            elif k in cfuncs.commonhooks:
                c = cfuncs.commonhooks[k]
            else:
                # 如果 k 不存在于任何函数字典中，输出错误信息
                errmess('buildmodule: unknown need %s.\n' % (repr(k)))
                continue
            # 将获取的字符串 c 添加到 code[n] 中
            code[n].append(c)
    
    # 将 code 添加到 mod_rules 列表中
    mod_rules.append(code)
    
    # 遍历 mod_rules 列表中的元素 r
    for r in mod_rules:
        # 检查 r 是否包含键 '_check'，并且调用 r['_check'](m) 如果条件为真，或者 r 中不包含 '_check'
        if ('_check' in r and r['_check'](m)) or ('_check' not in r):
            # 应用规则 r 到 vrd 和 m 上，结果存储在 ar 中
            ar = applyrules(r, vrd, m)
            # 将 ar 合并到 rd 中
            rd = dictappend(rd, ar)
    
    # 应用 module_rules 到 rd 上，结果存储在 ar 中
    ar = applyrules(module_rules, rd)

    # 构造输出文件的路径 fn
    fn = os.path.join(options['buildpath'], vrd['coutput'])
    # 将 ar['modulebody'] 中的内容写入文件 fn 中，替换其中的制表符为两个空格
    ret['csrc'] = fn
    with open(fn, 'w') as f:
        f.write(ar['modulebody'].replace('\t', 2 * ' '))
    # 输出信息，指示成功写入 C/API 模块到文件中
    outmess('    Wrote C/API module "%s" to file "%s"\n' % (m['name'], fn))

    # 如果 options['dorestdoc'] 为真
    if options['dorestdoc']:
        # 构造 ReST 文档文件的路径 fn
        fn = os.path.join(options['buildpath'], vrd['modulename'] + 'module.rest')
        # 将 ar['restdoc'] 中的内容写入文件 fn 中
        with open(fn, 'w') as f:
            f.write('.. -*- rest -*-\n')
            f.write('\n'.join(ar['restdoc']))
        # 输出信息，指示成功保存 ReST 文档文件
        outmess('    ReST Documentation is saved to file "%s/%smodule.rest"\n' %
                (options['buildpath'], vrd['modulename']))

    # 如果 options['dolatexdoc'] 为真
    if options['dolatexdoc']:
        # 构造 LaTeX 文档文件的路径 fn
        fn = os.path.join(options['buildpath'], vrd['modulename'] + 'module.tex')
        # 将 ar['latexdoc'] 中的内容写入文件 fn 中
        ret['ltx'] = fn
        with open(fn, 'w') as f:
            f.write(
                '%% This file is auto-generated with f2py (version:%s)\n' % (f2py_version))
            if 'shortlatex' not in options:
                f.write(
                    '\\documentclass{article}\n\\usepackage{a4wide}\n\\begin{document}\n\\tableofcontents\n\n')
                f.write('\n'.join(ar['latexdoc']))
            if 'shortlatex' not in options:
                f.write('\\end{document}')
        # 输出信息，指示成功保存 LaTeX 文档文件
        outmess('    Documentation is saved to file "%s/%smodule.tex"\n' %
                (options['buildpath'], vrd['modulename']))
    # 如果存在函数包装器
    if funcwrappers:
        # 拼接生成包装器文件的路径名
        wn = os.path.join(options['buildpath'], vrd['f2py_wrapper_output'])
        # 将文件路径添加到返回结果中的 'fsrc' 键
        ret['fsrc'] = wn
        # 打开文件以写入模式
        with open(wn, 'w') as f:
            # 写入文件头部信息
            f.write('C     -*- fortran -*-\n')
            f.write(
                'C     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                'C     It contains Fortran 77 wrappers to fortran functions.\n')
            # 初始化空列表 lines
            lines = []
            # 遍历函数包装器并生成文件内容
            for l in ('\n\n'.join(funcwrappers) + '\n').split('\n'):
                # 如果行中存在注释符号且位于前 66 个字符内，则不分割注释行
                if 0 <= l.find('!') < 66:
                    # 将该行添加到 lines 列表中，并加上换行符
                    lines.append(l + '\n')
                # 如果行不为空且以空格开头
                elif l and l[0] == ' ':
                    # 当行长度大于等于 66 时，分割为多行，并添加到 lines 中
                    while len(l) >= 66:
                        lines.append(l[:66] + '\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            # 将 lines 列表中的内容连接成字符串，并将多余的换行和连接符去除
            lines = ''.join(lines).replace('\n     &\n', '\n')
            # 将处理好的文件内容写入文件中
            f.write(lines)
        # 输出消息，显示 Fortran 77 包装器文件已保存
        outmess('    Fortran 77 wrappers are saved to "%s"\n' % (wn))
    
    # 如果存在第二组函数包装器
    if funcwrappers2:
        # 拼接生成包装器文件的路径名
        wn = os.path.join(
            options['buildpath'], '%s-f2pywrappers2.f90' % (vrd['modulename']))
        # 将文件路径添加到返回结果中的 'fsrc' 键
        ret['fsrc'] = wn
        # 打开文件以写入模式
        with open(wn, 'w') as f:
            # 写入文件头部信息
            f.write('!     -*- f90 -*-\n')
            f.write(
                '!     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                '!     It contains Fortran 90 wrappers to fortran functions.\n')
            # 初始化空列表 lines
            lines = []
            # 遍历第二组函数包装器并生成文件内容
            for l in ('\n\n'.join(funcwrappers2) + '\n').split('\n'):
                # 如果行中存在注释符号且位于前 72 个字符内，则不分割注释行
                if 0 <= l.find('!') < 72:
                    # 将该行添加到 lines 列表中，并加上换行符
                    lines.append(l + '\n')
                # 如果行长度超过 72 并且以空格开头
                elif len(l) > 72 and l[0] == ' ':
                    # 分割为多行，并添加到 lines 中
                    lines.append(l[:72] + '&\n     &')
                    l = l[72:]
                    while len(l) > 66:
                        lines.append(l[:66] + '&\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            # 将 lines 列表中的内容连接成字符串，并将多余的换行和连接符去除
            lines = ''.join(lines).replace('\n     &\n', '\n')
            # 将处理好的文件内容写入文件中
            f.write(lines)
        # 输出消息，显示 Fortran 90 包装器文件已保存
        outmess('    Fortran 90 wrappers are saved to "%s"\n' % (wn))
    
    # 返回包含生成文件路径的字典 ret
    return ret
# 构建 C/API 函数的过程

# 定义一个字典，将数字转换为对应的英文序数词尾
stnd = {1: 'st', 2: 'nd', 3: 'rd', 4: 'th', 5: 'th',
        6: 'th', 7: 'th', 8: 'th', 9: 'th', 0: 'th'}

# 定义构建 API 函数的主函数
def buildapi(rout):
    # 将函数转换为子程序，同时获取包装信息
    rout, wrap = func2subr.assubr(rout)
    # 获取函数的参数列表和依赖参数
    args, depargs = getargs2(rout)
    # 设置全局变量 capi_maps 的依赖参数
    capi_maps.depargs = depargs
    # 获取函数的变量列表
    var = rout['vars']

    # 如果是模块函数，输出构建包装函数的消息
    if ismoduleroutine(rout):
        outmess('            Constructing wrapper function "%s.%s"...\n' %
                (rout['modulename'], rout['name']))
    else:
        outmess('        Constructing wrapper function "%s"...\n' % (rout['name']))

    # 根据函数签名构建路由映射
    vrd = capi_maps.routsign2map(rout)
    rd = dictappend({}, vrd)

    # 根据规则集对函数进行处理
    for r in rout_rules:
        # 如果规则包含 '_check' 并且检查通过，或者规则没有 '_check'，则应用规则
        if ('_check' in r and r['_check'](rout)) or ('_check' not in r):
            ar = applyrules(r, vrd, rout)
            rd = dictappend(rd, ar)

    # 处理函数的参数
    nth, nthk = 0, 0
    savevrd = {}
    for a in args:
        vrd = capi_maps.sign2map(a, var[a])
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
            if not isintent_hide(var[a]):
                if not isoptional(var[a]):
                    nth = nth + 1
                    vrd['nth'] = repr(nth) + stnd[nth % 10] + ' argument'
                else:
                    nthk = nthk + 1
                    vrd['nth'] = repr(nthk) + stnd[nthk % 10] + ' keyword'
            else:
                vrd['nth'] = 'hidden'
        savevrd[a] = vrd
        for r in _rules:
            if '_depend' in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break

    # 处理依赖参数
    for a in depargs:
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
        vrd = savevrd[a]
        for r in _rules:
            if '_depend' not in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
        if 'check' in var[a]:
            for c in var[a]['check']:
                vrd['check'] = c
                ar = applyrules(check_rules, vrd, var[a])
                rd = dictappend(rd, ar)

    # 反转清理和关闭 Python 对象的列表（如果存在）
    if isinstance(rd['cleanupfrompyobj'], list):
        rd['cleanupfrompyobj'].reverse()
    if isinstance(rd['closepyobjfrom'], list):
        rd['closepyobjfrom'].reverse()

    # 构建函数的文档签名，并移除末尾逗号
    rd['docsignature'] = stripcomma(replace('#docsign##docsignopt##docsignxa#',
                                            {'docsign': rd['docsign'],
                                             'docsignopt': rd['docsignopt'],
                                             'docsignxa': rd['docsignxa']}))
    # 从 rd 字典中获取 'docsignxashort' 和 'docsignoptshort' 的值，替换字符串 "#docsignopt##docsignxa#" 中的占位符，
    # 使用 stripcomma 函数去除结果字符串中可能的逗号后返回。
    optargs = stripcomma(replace('#docsignopt##docsignxa#',
                                 {'docsignxa': rd['docsignxashort'],
                                  'docsignopt': rd['docsignoptshort']}
                                 ))
    
    # 如果 optargs 是空字符串，则从 rd 字典中获取 'docsign' 的值，替换字符串 "#docsign#" 的占位符，
    # 使用 stripcomma 函数去除结果字符串中可能的逗号后赋给 rd['docsignatureshort']。
    if optargs == '':
        rd['docsignatureshort'] = stripcomma(
            replace('#docsign#', {'docsign': rd['docsign']}))
    else:
        # 否则，替换字符串 "#docsign#[#docsignopt#]" 的占位符，使用 replace 函数，
        # 将结果赋给 rd['docsignatureshort']。
        rd['docsignatureshort'] = replace('#docsign#[#docsignopt#]',
                                          {'docsign': rd['docsign'],
                                           'docsignopt': optargs,
                                           })
    
    # 将 rd['docsignatureshort'] 中的下划线替换为 LaTeX 格式的转义序列 "\_"，
    # 然后将其中的逗号替换为 ", "，并将结果赋给 rd['latexdocsignatureshort']。
    rd['latexdocsignatureshort'] = rd['docsignatureshort'].replace('_', '\\_')
    rd['latexdocsignatureshort'] = rd[
        'latexdocsignatureshort'].replace(',', ', ')
    
    # 从 rd 字典中获取 'callfortran' 和 'callfortranappend' 的值，替换字符串 "#callfortran##callfortranappend#" 的占位符，
    # 使用 stripcomma 函数去除结果字符串中可能的逗号后返回。
    cfs = stripcomma(replace('#callfortran##callfortranappend#', {
                     'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    
    # 如果 rd['callfortranappend'] 的长度大于1，则从 rd 字典中获取 'callfortran' 和 'callfortranappend' 的值，
    # 替换字符串 "#callfortran# 0,#callfortranappend#" 的占位符，使用 stripcomma 函数去除结果字符串中可能的逗号后，
    # 将结果赋给 rd['callcompaqfortran']；否则，将前面计算得到的 cfs 赋给 rd['callcompaqfortran']。
    if len(rd['callfortranappend']) > 1:
        rd['callcompaqfortran'] = stripcomma(replace('#callfortran# 0,#callfortranappend#', {
                                             'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    else:
        rd['callcompaqfortran'] = cfs
    
    # 将前面计算得到的 cfs 赋给 rd['callfortran']。
    rd['callfortran'] = cfs
    
    # 如果 rd['docreturn'] 是列表类型，则从 rd 字典中获取 'docreturn' 的值，替换字符串 "#docreturn#" 的占位符，
    # 使用 stripcomma 函数去除结果字符串中可能的逗号后，再在末尾加上等号"="，将结果赋给 rd['docreturn']。
    if isinstance(rd['docreturn'], list):
        rd['docreturn'] = stripcomma(
            replace('#docreturn#', {'docreturn': rd['docreturn']})) + ' = '
    
    # 初始化 rd['docstrsigns'] 和 rd['latexdocstrsigns'] 为空列表。
    rd['docstrsigns'] = []
    rd['latexdocstrsigns'] = []
    
    # 遍历包含字符串 'docstrreq', 'docstropt', 'docstrout', 'docstrcbs' 的列表，
    # 对于每个字符串 k：
    #   如果 rd 字典中存在 k，并且其值是列表类型，则将 rd[k] 中的元素追加到 rd['docstrsigns'] 中。
    #   将字符串 'latex' + k 赋给 k，并检查 rd 字典中是否存在这个键，如果存在且值是列表类型，
    #   则将 rd[k] 中的第一个元素追加到 rd['latexdocstrsigns'] 中，然后插入 LaTeX 描述环境的起始标记和结束标记之间的所有元素。
    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:
        if k in rd and isinstance(rd[k], list):
            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]
        k = 'latex' + k
        if k in rd and isinstance(rd[k], list):
            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] +\
                ['\\begin{description}'] + rd[k][1:] +\
                ['\\end{description}']
    
    # 使用 routine_rules 中定义的规则对 rd 进行处理，将处理结果赋给 ar。
    ar = applyrules(routine_rules, rd)
    
    # 如果 rout 是模块化的例行程序，调用 outmess 函数输出格式化后的 ar['docshort']；
    # 否则，输出格式化后的 ar['docshort']。
    if ismoduleroutine(rout):
        outmess('              %s\n' % (ar['docshort']))
    else:
        outmess('          %s\n' % (ar['docshort']))
    
    # 返回 ar 和 wrap。
    return ar, wrap
# 导入内建的 os 模块
import os

# 导入内建的 re 模块（正则表达式）
import re

# 导入内建的 sys 模块
import sys

# 导入内建的 argparse 模块（命令行解析）
import argparse

# 导入内建的 itertools 模块（迭代工具）
import itertools

# 导入内建的 pathlib 模块（路径操作）
import pathlib

# 导入内建的 collections 模块
import collections

# 导入内建的 typing 模块
import typing

# 导入自定义模块或库 module
import module
```