# `D:\src\scipysrc\scipy\scipy\_build_utils\_generate_blas_wrapper.py`

```
"""
Generate wrappers to dispatch BLAS/LAPACK calls to the properly prefixed/
suffixed symbols.

For example, MacOS 13.3+ has a new, LAPACK 3.9-compatible, high performance
BLAS/LAPACK implementation. These functions are provided side-by-side with
the old implementation, and the symbols are distinguished by appending the
literal suffix "$NEWLAPACK".

To point our BLAS/LAPACK calls to these symbols, we need to create wrappers
which call them appropriately. We do this as simple C function declarations
that make use of the preprocessor macros defined in npy_cblas.h.

We already have all the required signature information in
    scipy/linalg/cython_{blas,lapack}_signatures.txt
which is generated by
    scipy/linalg/_cython_signature_generator.py

We automatically create the declarations based on these signatures, with a
few special cases. First, all complex-valued functions are skipped (empty
source files) because they require more complicated wrapper logic. The
wrappers for these functions are hard-coded in wrap_g77_abi.c and
wrap_dummy_g77_abi.c. Second, certain functions are missing from the
new Accelerate implementation and/or have unusual symbols that require
special handling in this script.
"""
import argparse
import os

from _wrappers_common import (C_PREAMBLE, C_TYPES, CPP_GUARD_BEGIN,
                              CPP_GUARD_END, LAPACK_DECLS, USE_OLD_ACCELERATE,
                              WRAPPED_FUNCS, all_newer,
                              get_blas_macro_and_name, read_signatures,
                              write_files)

# 获取当前脚本文件的目录路径
CURR_DIR = os.path.dirname(os.path.abspath(__file__))
# 获取 linalg 目录的绝对路径
LINALG_DIR = os.path.abspath(os.path.join(CURR_DIR, "..", "linalg"))
# C 文件的注释
C_COMMENT = f"""/*
This file was generated by {os.path.basename(__file__)}.
Do not edit this file directly.
*/\n\n"""


def generate_decl_wrapper(name, return_type, argnames, argtypes, accelerate):
    """
    Create wrapper function declaration.

    Wrapper has symbol `F_FUNC(name,NAME)` and wraps the BLAS/LAPACK function
    `blas_macro(blas_name)` (by default: `BLAS_FUNC(name)`).
    """
    # 复杂值函数在 G77 ABI 包装器中有硬编码的包装逻辑，因此跳过
    if name in WRAPPED_FUNCS:
        return ""
    # 如果使用标准的旧 Accelerate 符号，则无需包装器
    if accelerate and name in USE_OLD_ACCELERATE:
        return ""
    # 将返回类型和参数类型转换为对应的 C 类型
    c_return_type = C_TYPES[return_type]
    c_argtypes = [C_TYPES[t] for t in argtypes]
    # 生成参数列表和参数名称字符串
    param_list = ', '.join(f'{t} *{n}' for t, n in zip(c_argtypes, argnames))
    argnames = ', '.join(argnames)
    # 获取 BLAS 宏和名称
    blas_macro, blas_name = get_blas_macro_and_name(name, accelerate)
    # 返回生成的包装器函数声明
    return f"""
{c_return_type} {blas_macro}({blas_name})({param_list});
{c_return_type} F_FUNC({name},{name.upper()})({param_list}){{
    return {blas_macro}({blas_name})({argnames});
}}
"""


def generate_file_wrapper(sigs, accelerate):
    """
    Returns text of file containing wrappers for all BLAS/LAPACK functions.
    """
    # 定义一个列表，包含几个预定义的字符串常量 C_COMMENT, C_PREAMBLE, LAPACK_DECLS, CPP_GUARD_BEGIN
    file_text = [C_COMMENT, C_PREAMBLE, LAPACK_DECLS, CPP_GUARD_BEGIN]
    # 遍历 sigs 列表中的每个元素，每个元素都是一个字典
    for sig in sigs:
        # 调用 generate_decl_wrapper 函数，传入 sig 字典的关键字参数，并设置 accelerate 参数为当前函数的 accelerate 变量
        file_text.append(generate_decl_wrapper(**sig, accelerate=accelerate))
    # 将字符串常量 CPP_GUARD_END 添加到 file_text 列表末尾
    file_text.append(CPP_GUARD_END)
    # 将 file_text 列表中的所有字符串连接成一个单独的字符串，并返回
    return ''.join(file_text)
# 定义一个函数，用于生成所有的 BLAS 和 LAPACK 函数包装器文件
def make_all(outdir,
             # BLAS 函数签名文件路径，默认为指定目录下的 cython_blas_signatures.txt
             blas_signature_file=os.path.join(
                 LINALG_DIR, "cython_blas_signatures.txt"),
             # LAPACK 函数签名文件路径，默认为指定目录下的 cython_lapack_signatures.txt
             lapack_signature_file=os.path.join(
                 LINALG_DIR, "cython_lapack_signatures.txt"),
             accelerate=False):
    
    # 打开并读取 BLAS 函数签名文件内容
    with open(blas_signature_file) as f:
        blas_sigs = f.readlines()
    # 打开并读取 LAPACK 函数签名文件内容
    with open(lapack_signature_file) as f:
        lapack_sigs = f.readlines()
    
    # 解析 BLAS 函数签名
    blas_sigs = read_signatures(blas_sigs)
    # 解析 LAPACK 函数签名
    lapack_sigs = read_signatures(lapack_sigs)
    
    # 检查是否需要创建新文件
    src_files = (os.path.abspath(__file__),  # 当前文件的绝对路径
                 blas_signature_file,  # BLAS 函数签名文件路径
                 lapack_signature_file)  # LAPACK 函数签名文件路径
    dst_files = [os.path.join(outdir, 'blas_lapack_wrappers.c')]  # 目标文件路径列表
    
    # 如果所有目标文件都比源文件更新，则打印消息并返回
    if all_newer(dst_files, src_files):
        print("scipy/_build_utils/_generate_blas_wrapper.py: all files up-to-date")
        return
    
    # 生成 BLAS 和 LAPACK 函数包装器文件
    wrapper_file = generate_file_wrapper(blas_sigs + lapack_sigs, accelerate)
    # 写入生成的文件到目标文件
    write_files({dst_files[0]: wrapper_file})


if __name__ == '__main__':
    # 解析命令行参数
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--outdir", type=str,
                        help="Path to the output directory")
    parser.add_argument("-a", "--accelerate", action="store_true",
                        help="Whether to use new Accelerate (macOS 13.3+)")
    args = parser.parse_args()

    # 确定输出目录的绝对路径
    if not args.outdir:
        outdir_abs = os.path.abspath(os.path.dirname(__file__))  # 当前文件所在目录的绝对路径
    else:
        outdir_abs = os.path.join(os.getcwd(), args.outdir)  # 当前工作目录与输出目录的组合路径

    # 调用 make_all 函数，生成 BLAS 和 LAPACK 函数包装器文件
    make_all(outdir_abs, accelerate=args.accelerate)
```