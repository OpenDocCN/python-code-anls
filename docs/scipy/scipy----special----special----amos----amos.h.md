# `D:\src\scipysrc\scipy\scipy\special\special\amos\amos.h`

```
/*
 * This file is a C++ translation of the Fortran code written by
 * D.E. Amos with the following original description:
 *
 *
 * A Portable Package for Bessel Functions of a Complex Argument
 * and Nonnegative Order
 *
 * This algorithm is a package of subroutines for computing Bessel
 * functions and Airy functions.  The routines are updated
 * versions of those routines found in TOMS algorithm 644.
 *
 * Disclaimer:
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                 ISSUED BY SANDIA LABORATORIES,
 *                   A PRIME CONTRACTOR TO THE
 *               UNITED STATES DEPARTMENT OF ENERGY
 * * * * * * * * * * * * * *  NOTICE   * * * * * * * * * * * * * * *
 * THIS REPORT WAS PREPARED AS AN ACCOUNT OF WORK SPONSORED BY THE
 * UNITED STATES GOVERNMENT.  NEITHER THE UNITED STATES NOR THE
 * UNITED STATES DEPARTMENT OF ENERGY, NOR ANY OF THEIR
 * EMPLOYEES, NOR ANY OF THEIR CONTRACTORS, SUBCONTRACTORS, OR THEIR
 * EMPLOYEES, MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY
 * LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS
 * OR USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT OR PROCESS
 * DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
 * PRIVATELY OWNED RIGHTS.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * *```cpp
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * THIS CODE HAS BEEN APPROVED FOR UNLIMITED RELEASE.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *
 *
 * The original Fortran code can be found at https://www.netlib.org/amos/
 *
 * References:
 *
 * [1]: Abramowitz, M. and Stegun, I. A., Handbook of Mathematical
 *      Functions, NBS Applied Math Series 55, U.S. Dept. of Commerce,
 *      Washington, D.C., 1955
 *
 * [2]: Amos, D. E., Algorithm 644, A Portable Package For Bessel
 *      Functions of a Complex Argument and Nonnegative Order, ACM
 *      Transactions on Mathematical Software, Vol. 12, No. 3,
 *      September 1986, Pages 265-273, DOI:10.1145/7921.214331
 *
 * [3]: Amos, D. E., Remark on Algorithm 644, ACM Transactions on
 *      Mathematical Software, Vol. 16, No. 4, December 1990, Page
 *      404, DOI:10.1145/98267.98299
 *
 * [4]: Amos, D. E., A remark on Algorithm 644: "A portable package
 *      for Bessel functions of a complex argument and nonnegative order",
 *      ACM Transactions on Mathematical Software, Vol. 21, No. 4,
 *      December 1995, Pages 388-393, DOI:10.1145/212066.212078
 *
 * [5]: Cody, W. J., Algorithm 665, MACHAR: A Subroutine to
 *      Dynamically Determine Machine Parameters, ACM Transactions on
 *      Mathematical Software, Vol. 14, No. 4, December 1988, Pages
 *      303-311, DOI:10.1145/50063.51907
 *
 */
/*
 * 版权所有 (C) 2024 SciPy 开发者
 *
 * 源代码和二进制形式的再发布和使用，无论是否进行修改，都是允许的，但需要满足以下条件：
 *
 * a. 源代码的再发布必须保留上述版权声明、本条件列表以及以下免责声明。
 * b. 以二进制形式再发布时，必须在配套的文档或其他材料中复制上述版权声明、本条件列表以及以下免责声明。
 * c. 未经特定书面许可，不得使用 SciPy 开发者的名称来认可或推广从本软件衍生的产品。
 *
 * 本软件由版权持有人和贡献者“按原样”提供，任何明示或暗示的保证，包括但不限于适销性和特定用途适用性的保证，均不作声明。在任何情况下，版权持有人或贡献者均不对任何直接、间接、附带、特殊、示范性或后果性损害（包括但不限于采购替代商品或服务；使用数据、利润或业务中断）承担责任，无论是因何种方式的侵权行为（包括疏忽或其他方式）还是合同责任，即使事先已被告知可能发生此类损害的可能性。
 */
#pragma once

#include <stdlib.h>

#include <math.h>
#include <complex.h>

namespace special {
namespace amos {

// 计算指定参数下的复数函数 acai 的值
int acai(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double, double);

// 计算指定参数下的复数函数 acon 的值
int acon(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double, double, double);

// 计算指定参数下的复数函数 asyi 的值
int asyi(std::complex<double>, double, int, int, std::complex<double> *, double, double, double, double);

// 计算指定参数下的复数函数 binu 的值
int binu(std::complex<double>, double fnu, int, int, std::complex<double> *, double, double, double, double, double);

// 计算指定参数下的复数函数 bknu 的值
int bknu(std::complex<double>, double, int, int, std::complex<double> *, double, double, double);

// 计算指定参数下的复数函数 buni 的值
int buni(std::complex<double>, double, int, int, std::complex<double> *, int, int *, double, double, double, double);

// 计算指定参数下的复数函数 bunk 的值
int bunk(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double);

// 计算 gamma 函数的自然对数值
double gamln(double);

// 对指定参数进行缩放，并返回结果
int kscl(std::complex<double>, double, int, std::complex<double> *, std::complex<double>, double *, double, double);

// 计算指定参数下的复数函数 mlri 的值
int mlri(std::complex<double>, double, int, int, std::complex<double> *, double);

// 计算比率 rati 的值
void rati(std::complex<double>, double, int, std::complex<double> *, double);

// 计算指定参数下的复数函数 seri 的值
int seri(std::complex<double>, double, int, int, std::complex<double> *, double, double, double);

// 计算 s1s2 函数的值
int s1s2(std::complex<double>, std::complex<double> *, std::complex<double> *, double, double, int *);

// 检查给定参数的有效性
int uchk(std::complex<double>, double, double);
// 声明一个没有返回值的函数unhj，接受七个参数：复数、双精度浮点数、整数、双精度浮点数、以及五个复数指针参数
void unhj(std::complex<double>, double, int, double, std::complex<double> *, std::complex<double> *, std::complex<double> *, std::complex<double> *, std::complex<double> *, std::complex<double> *);

// 声明一个没有返回值的函数uni1，接受十个参数：复数、双精度浮点数、整数、整数、一个复数指针、一个整数指针、两个整数参数、四个双精度浮点数参数
void uni1(std::complex<double>, double, int, int, std::complex<double> *, int *, int *, double, double, double, double);

// 声明一个没有返回值的函数uni2，接受十个参数：复数、双精度浮点数、整数、整数、一个复数指针、一个整数指针、两个整数参数、四个双精度浮点数参数
void uni2(std::complex<double>, double, int, int, std::complex<double> *, int *, int *, double, double, double, double);

// 声明一个没有返回值的函数unik，接受十个参数：复数、双精度浮点数、整数、整数、双精度浮点数、一个整数指针、五个复数指针参数
void unik(std::complex<double>, double, int, int, double, int *, std::complex<double> *, std::complex<double> *, std::complex<double> *, std::complex<double> *, std::complex<double> *);

// 声明一个返回整数的函数unk1，接受九个参数：复数、双精度浮点数、整数、整数、整数、一个复数指针、三个双精度浮点数参数
int unk1(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double);

// 声明一个返回整数的函数unk2，接受九个参数：复数、双精度浮点数、整数、整数、整数、一个复数指针、三个双精度浮点数参数
int unk2(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double);

// 声明一个返回整数的函数uoik，接受九个参数：复数、双精度浮点数、整数、整数、整数、一个复数指针、三个双精度浮点数参数
int uoik(std::complex<double>, double, int, int, int, std::complex<double> *, double, double, double);

// 声明一个返回整数的函数wrsk，接受九个参数：复数、双精度浮点数、整数、整数、两个复数指针、三个双精度浮点数参数
int wrsk(std::complex<double>, double, int, int, std::complex<double> *, std::complex<double> *, double, double, double);

// 声明一个包含五个双精度浮点数常量的数组d1mach
constexpr double d1mach[5] = {
    2.2250738585072014e-308,  // np.finfo(np.float64).tiny
    1.7976931348623157e+308,  // np.finfo(np.float64).max
    1.1102230246251565e-16,   // 0.5 * np.finfo(np.float64).eps
    2.220446049250313e-16,    // np.finfo(np.float64).eps
    0.3010299956639812        // np.log10(2)
};

// 声明一个包含十六个整数常量的数组i1mach
constexpr double i1mach[16] = {
    5,           // standard input
    6,           // standard output
    7,           // standard punch
    0,           // standard error
    32,          // bits per integer
    4,           // sizeof(int);
    2,           // base for integers
    31,          // digits of integer base
    2147483647,  // LONG MAX 2**31 - 1
    2,           // FLT_RADIX;
    24,          // FLT_MANT_DIG;
    -126,        // FLT_MIN_EXP;
    128,         // FLT_MAX_EXP;
    53,          // DBL_MANT_DIG;
    -1021,       // DBL_MIN_EXP;
    1024         // DBL_MAX_EXP;
};

// 声明一个包含十四个双精度浮点数常量的数组zunhj_ar
constexpr double zunhj_ar[14] = {
    1.00000000000000000e+00, 1.04166666666666667e-01, 8.35503472222222222e-02, 1.28226574556327160e-01,      //  0
    2.91849026464140464e-01, 8.81627267443757652e-01, 3.32140828186276754e+00, 1.49957629868625547e+01,      //  4
    7.89230130115865181e+01, 4.74451538868264323e+02, 3.20749009089066193e+03, 2.40865496408740049e+04,      //  8
    1.98923119169509794e+05, 1.79190200777534383e+06                                                         // 12
};

// 声明一个包含十四个双精度浮点数常量的数组zunhj_br
constexpr double zunhj_br[14] = {
    1.00000000000000000e+00, -1.45833333333333333e-01, -9.87413194444444444e-02, -1.43312053915895062e-01,  //  0
    -3.17227202678413548e-01, -9.42429147957120249e-01, -3.51120304082635426e+00, -1.57272636203680451e+01,  //  4
    # 以下是一行以逗号分隔的数值列表，表示一些数学常数或数据值
    -8.22814390971859444e+01, -4.92355370523670524e+02, -3.31621856854797251e+03, -2.48276742452085896e+04,  //  8
    -2.04526587315129788e+05, -1.83844491706820990e+06                                                       // 12
constexpr double  zunhj_c[105] = {
     1.00000000000000000e+00, -2.08333333333333333e-01,  1.25000000000000000e-01,  3.34201388888888889e-01,  //   0
    -4.01041666666666667e-01,  7.03125000000000000e-02, -1.02581259645061728e+00,  1.84646267361111111e+00,  //   4
    -8.91210937500000000e-01,  7.32421875000000000e-02,  4.66958442342624743e+00, -1.12070026162229938e+01,  //   8
     8.78912353515625000e+00, -2.36408691406250000e+00,  1.12152099609375000e-01, -2.82120725582002449e+01,  //  12
     8.46362176746007346e+01, -9.18182415432400174e+01,  4.25349987453884549e+01, -7.36879435947963170e+00,  //  16
     2.27108001708984375e-01,  2.12570130039217123e+02, -7.65252468141181642e+02,  1.05999045252799988e+03,  //  20
    -6.99579627376132541e+02,  2.18190511744211590e+02, -2.64914304869515555e+01,  5.72501420974731445e-01,  //  24
    -1.91945766231840700e+03,  8.06172218173730938e+03, -1.35865500064341374e+04,  1.16553933368645332e+04,  //  28
    -5.30564697861340311e+03,  1.20090291321635246e+03, -1.08090919788394656e+02,  1.72772750258445740e+00,  //  32
     2.02042913309661486e+04, -9.69805983886375135e+04,  1.92547001232531532e+05, -2.03400177280415534e+05,  //  36
     1.22200464983017460e+05, -4.11926549688975513e+04,  7.10951430248936372e+03, -4.93915304773088012e+02,  //  40
     6.07404200127348304e+00, -2.42919187900551333e+05,  1.31176361466297720e+06, -2.99801591853810675e+06,  //  44
     3.76327129765640400e+06, -2.81356322658653411e+06,  1.26836527332162478e+06, -3.31645172484563578e+05,  //  48
     4.52187689813627263e+04, -2.49983048181120962e+03,  2.43805296995560639e+01,  3.28446985307203782e+06,  //  52
    -1.97068191184322269e+07,  5.09526024926646422e+07, -7.41051482115326577e+07,  6.63445122747290267e+07,  //  56
    -3.75671766607633513e+07,  1.32887671664218183e+07, -2.78561812808645469e+06,  3.08186404612662398e+05,  //  60
    -1.38860897537170405e+04,  1.10017140269246738e+02, -4.93292536645099620e+07,  3.25573074185765749e+08,  //  64
    -9.39462359681578403e+08,  1.55359689957058006e+09, -1.62108055210833708e+09,  1.10684281682301447e+09,  //  68
    -4.95889784275030309e+08,  1.42062907797533095e+08, -2.44740627257387285e+07,  2.24376817792244943e+06,  //  72
};


注释：
这段代码定义了一个 `constexpr`（编译期常量）的双精度浮点数组 `zunhj_c`，包含105个元素。每个元素依次表示不同的浮点数值，用科学计数法表示。注释中的数字如 `// 0`、`// 4` 表示每组四个元素的起始索引。
    -8.40054336030240853e+04,  5.51335896122020586e+02,  8.14789096118312115e+08, -5.86648149205184723e+09,  //  76
     1.86882075092958249e+10, -3.46320433881587779e+10,  4.12801855797539740e+10, -3.30265997498007231e+10,  //  80
     1.79542137311556001e+10, -6.56329379261928433e+09,  1.55927986487925751e+09, -2.25105661889415278e+08,  //  84
     1.73951075539781645e+07, -5.49842327572288687e+05,  3.03809051092238427e+03, -1.46792612476956167e+10,  //  88
     1.14498237732025810e+11, -3.99096175224466498e+11,  8.19218669548577329e+11, -1.09837515608122331e+12,  //  92
     1.00815810686538209e+12, -6.45364869245376503e+11,  2.87900649906150589e+11, -8.78670721780232657e+10,  //  96
     1.76347306068349694e+10, -2.16716498322379509e+09,  1.43157876718888981e+08, -3.87183344257261262e+06,  // 100
     1.82577554742931747e+04                                                                                 // 104



// 76-104行：一系列浮点数，可能是用于某种数学计算或者模型的系数或参数。
// 这些数字在代码中可能用于计算复杂的数学公式或者模型，具体用途需要查看其在代码中的应用上下文。
// 定义一个名为 zunhj_alfa 的常量表，包含 180 个元素，表示一系列双精度浮点数
constexpr double zunhj_alfa[180] = {
    // 下面是数组 zunhj_alfa 的初始化列表，每行包含四个元素
    // 每个元素表示数组中的一个值，这些值依次为 -4.44444444444444444e-03, -9.22077922077922078e-04, -8.84892884892884893e-05, 1.65927687832449737e-04
    -4.44444444444444444e-03, -9.22077922077922078e-04, -8.84892884892884893e-05,  1.65927687832449737e-04,  //   0
    // 继续初始化列表，每行四个元素，依次为 2.46691372741792910e-04, 2.65995589346254780e-04, 2.61824297061500945e-04, 2.48730437344655609e-04
    2.46691372741792910e-04,  2.65995589346254780e-04,  2.61824297061500945e-04,  2.48730437344655609e-04,  //   4
    // ...
    // 这里继续初始化剩余的元素，依次类推
    // 最后一行以注释形式说明每行的起始位置和包含的四个元素
};
    -8.22982872820208365e-05, -4.62860730588116458e-05, -1.72334302366962267e-05,  5.60690482304602267e-06,  // 100
     2.31395443148286800e-05,  3.62642745856793957e-05,  4.58006124490188752e-05,  5.24595294959114050e-05,  // 104
     5.68396208545815266e-05,  5.94349820393104052e-05,  6.06478527578421742e-05,  6.08023907788436497e-05,  // 108
     6.01577894539460388e-05,  5.89199657344698500e-05,  5.72515823777593053e-05,  5.52804375585852577e-05,  // 112
     5.31063773802880170e-05,  5.08069302012325706e-05,  4.84418647620094842e-05,  4.60568581607475370e-05,  // 116
    -6.91141397288294174e-04, -4.29976633058871912e-04,  1.83067735980039018e-04,  6.60088147542014144e-04,  // 120
     8.75964969951185931e-04,  8.77335235958235514e-04,  7.49369585378990637e-04,  5.63832329756980918e-04,  // 124
     3.68059319971443156e-04,  1.88464535514455599e-04,  3.70663057664904149e-05, -8.28520220232137023e-05,  // 128
    -1.72751952869172998e-04, -2.36314873605872983e-04, -2.77966150694906658e-04, -3.02079514155456919e-04,  // 132
    -3.12594712643820127e-04, -3.12872558758067163e-04, -3.05678038466324377e-04, -2.93226470614557331e-04,  // 136
    -2.77255655582934777e-04, -2.59103928467031709e-04, -2.39784014396480342e-04, -2.20048260045422848e-04,  // 140
    -2.00443911094971498e-04, -1.81358692210970687e-04, -1.63057674478657464e-04, -1.45712672175205844e-04,  // 144
    -1.29425421983924587e-04, -1.14245691942445952e-04,  1.92821964248775885e-03,  1.35592576302022234e-03,  // 148
    -7.17858090421302995e-04, -2.58084802575270346e-03, -3.49271130826168475e-03, -3.46986299340960628e-03,  // 152
    -2.82285233351310182e-03, -1.88103076404891354e-03, -8.89531718383947600e-04,  3.87912102631035228e-06,  // 156
     7.28688540119691412e-04,  1.26566373053457758e-03,  1.62518158372674427e-03,  1.83203153216373172e-03,  // 160
     1.91588388990527909e-03,  1.90588846755546138e-03,  1.82798982421825727e-03,  1.70389506421121530e-03,  // 164
     1.55097127171097686e-03,  1.38261421852276159e-03,  1.20881424230064774e-03,  1.03676532638344962e-03,  // 168
     8.71437918068619115e-04,  7.16080155297701002e-04,  5.72637002558129372e-04,  4.42089819465802277e-04,  // 172
     3.24724948503090564e-04,  2.20342042730246599e-04,  1.28412898401353882e-04,  4.82005924552095464e-05   // 176
// 定义一个 constexpr (编译时计算) 的双精度浮点数组 zunhj_beta，包含 210 个元素
constexpr double zunhj_beta[210] = {
    // 下面是数组 zunhj_beta 的前四个元素，分别是 0 到 3 索引位置
    1.79988721413553309e-02,  5.59964911064388073e-03,  2.88501402231132779e-03,  1.80096606761053941e-03,  //   0
    // 接下来是 4 到 7 索引位置的四个元素
    1.24753110589199202e-03,  9.22878876572938311e-04,  7.14430421727287357e-04,  5.71787281789704872e-04,  //   4
    // 8 到 11 索引位置的四个元素
    4.69431007606481533e-04,  3.93232835462916638e-04,  3.34818889318297664e-04,  2.88952148495751517e-04,  //   8
    // 12 到 15 索引位置的四个元素
    2.52211615549573284e-04,  2.22280580798883327e-04,  1.97541838033062524e-04,  1.76836855019718004e-04,  //  12
    // 16 到 19 索引位置的四个元素
    1.59316899661821081e-04,  1.44347930197333986e-04,  1.31448068119965379e-04,  1.20245444949302884e-04,  //  16
    // 20 到 23 索引位置的四个元素
    1.10449144504599392e-04,  1.01828770740567258e-04,  9.41998224204237509e-05,  8.74130545753834437e-05,  //  20
    // 24 到 27 索引位置的四个元素
    8.13466262162801467e-05,  7.59002269646219339e-05,  7.09906300634153481e-05,  6.65482874842468183e-05,  //  24
    // 28 到 31 索引位置的四个元素
    6.25146958969275078e-05,  5.88403394426251749e-05, -1.49282953213429172e-03, -8.78204709546389328e-04,  //  28
    // 32 到 35 索引位置的四个元素
    -5.02916549572034614e-04, -2.94822138512746025e-04, -1.75463996970782828e-04, -1.04008550460816434e-04,  //  32
    // 36 到 39 索引位置的四个元素
    -5.96141953046457895e-05, -3.12038929076098340e-05, -1.26089735980230047e-05, -2.42892608575730389e-07,  //  36
    // 40 到 43 索引位置的四个元素
    8.05996165414273571e-06,  1.36507009262147391e-05,  1.73964125472926261e-05,  1.98672978842133780e-05,  //  40
    // 44 到 47 索引位置的四个元素
    2.14463263790822639e-05,  2.23954659232456514e-05,  2.28967783814712629e-05,  2.30785389811177817e-05,  //  44
    // 48 到 51 索引位置的四个元素
    2.30321976080909144e-05,  2.28236073720348722e-05,  2.25005881105292418e-05,  2.20981015361991429e-05,  //  48
    // 52 到 55 索引位置的四个元素
    2.16418427448103905e-05,  2.11507649256220843e-05,  2.06388749782170737e-05,  2.01165241997081666e-05,  //  52
    // 56 到 59 索引位置的四个元素
    1.95913450141179244e-05,  1.90689367910436740e-05,  1.85533719641636667e-05,  1.80475722259674218e-05,  //  56
    // 60 到 63 索引位置的四个元素
    5.52213076721292790e-04,  4.47932581552384646e-04,  2.79520653992020589e-04,  1.52468156198446602e-04,  //  60
    // 64 到 67 索引位置的四个元素
    6.93271105657043598e-05,  1.76258683069991397e-05, -1.35744996343269136e-05, -3.17972413350427135e-05,  //  64
    // 68 到 71 索引位置的四个元素
    -4.18861861696693365e-05, -4.69004889379141029e-05, -4.87665447413787352e-05, -4.87010031186735069e-05,  //  68
    // 72 到 75 索引位置的四个元素
    -4.74755620890086638e-05, -4.55813058138628452e-05, -4.33309644511266036e-05, -4.09230193157750364e-05,  //  72
    // 76 到 79 索引位置的四个元素
    -3.84822638603221274e-05, -3.60857167535410501e-05, -3.37793306123367417e-05, -3.15888560772109621e-05,  //  76
    // 80 到 83 索引位置的四个元素
    -2.95269561750807315e-05, -2.75978914828335759e-05, -2.58006174666883713e-05, -2.41308356761280200e-05,  //  80
    // 84 到 87 索引位置的四个元素
    -2.25823509518346033e-05, -2.11479656768912971e-05, -1.98200638885294927e-05, -1.85909870801065077e-05,  //  84
    // 88 到 91 索引位置的四个元素
    -1.74532699844210224e-05, -1.63997823854497997e-05, -4.74617796559959808e-04, -4.77864567147321487e-04,  //  88
};
    -3.20390228067037603e-04, -1.61105016119962282e-04, -4.25778101285435204e-05,  3.44571294294967503e-05,  //  92
    7.97092684075674924e-05,  1.03138236708272200e-04,  1.12466775262204158e-04,  1.13103642108481389e-04,  //  96
    1.08651634848774268e-04,  1.01437951597661973e-04,  9.29298396593363896e-05,  8.40293133016089978e-05,  // 100
    7.52727991349134062e-05,  6.69632521975730872e-05,  5.92564547323194704e-05,  5.22169308826975567e-05,  // 104
    4.58539485165360646e-05,  4.01445513891486808e-05,  3.50481730031328081e-05,  3.05157995034346659e-05,  // 108
    2.64956119950516039e-05,  2.29363633690998152e-05,  1.97893056664021636e-05,  1.70091984636412623e-05,  // 112
    1.45547428261524004e-05,  1.23886640995878413e-05,  1.04775876076583236e-05,  8.79179954978479373e-06,  // 116
    7.36465810572578444e-04,  8.72790805146193976e-04,  6.22614862573135066e-04,  2.85998154194304147e-04,  // 120
    3.84737672879366102e-06, -1.87906003636971558e-04, -2.97603646594554535e-04, -3.45998126832656348e-04,  // 124
   -3.53382470916037712e-04, -3.35715635775048757e-04, -3.04321124789039809e-04, -2.66722723047612821e-04,  // 128
   -2.27654214122819527e-04, -1.89922611854562356e-04, -1.55058918599093870e-04, -1.23778240761873630e-04,  // 132
   -9.62926147717644187e-05, -7.25178327714425337e-05, -5.22070028895633801e-05, -3.50347750511900522e-05,  // 136
   -2.06489761035551757e-05, -8.70106096849767054e-06,  1.13698686675100290e-06,  9.16426474122778849e-06,  // 140
    1.56477785428872620e-05,  2.08223629482466847e-05,  2.48923381004595156e-05,  2.80340509574146325e-05,  // 144
    3.03987774629861915e-05,  3.21156731406700616e-05, -1.80182191963885708e-03, -2.43402962938042533e-03,  // 148
   -1.83422663549856802e-03, -7.62204596354009765e-04,  2.39079475256927218e-04,  9.49266117176881141e-04,  // 152
    1.34467449701540359e-03,  1.48457495259449178e-03,  1.44732339830617591e-03,  1.30268261285657186e-03,  // 156
    1.10351597375642682e-03,  8.86047440419791759e-04,  6.73073208165665473e-04,  4.77603872856582378e-04,  // 160
    3.05991926358789362e-04,  1.60315694594721630e-04,  4.00749555270613286e-05, -5.66607461635251611e-05,  // 164
   -1.32506186772982638e-04, -1.90296187989614057e-04, -2.32811450376937408e-04, -2.62628811464668841e-04,  // 168
   -2.82050469867598672e-04, -2.93081563192861167e-04, -2.97435962176316616e-04, -2.96557334239348078e-04,  // 172
   -2.91647363312090861e-04, -2.83696203837734166e-04, -2.73512317095673346e-04, -2.61750155806768580e-04,  // 176
    6.38585891212050914e-03,  9.62374215806377941e-03,  7.61878061207001043e-03,  2.83219055545628054e-03,  // 180
   -2.09841352012720090e-03, -5.73826764216626498e-03, -7.70804244495414620e-03, -8.21011692264844401e-03,  // 184
   -7.65824520346905413e-03, -6.47209729391045177e-03, -4.99132412004966473e-03, -3.45612289713133280e-03,  // 188
    -2.01785580014170775e-03, -7.59430686781961401e-04,  2.84173631523859138e-04,  1.10891667586337403e-03,  // 192
     1.72901493872728771e-03,  2.16812590802684701e-03,  2.45357710494539735e-03,  2.61281821058334862e-03,  // 196
     2.67141039656276912e-03,  2.65203073395980430e-03,  2.57411652877287315e-03,  2.45389126236094427e-03,  // 200
     2.30460058071795494e-03,  2.13684837686712662e-03,  1.95896528478870911e-03,  1.77737008679454412e-03,  // 204
     1.59690280765839059e-03,  1.42111975664438546e-03                                                       // 208


注释：


# 下面是一系列浮点数值，按行排列
-2.01785580014170775e-03, -7.59430686781961401e-04,  2.84173631523859138e-04,  1.10891667586337403e-03,  // 192
1.72901493872728771e-03,  2.16812590802684701e-03,  2.45357710494539735e-03,  2.61281821058334862e-03,  // 196
2.67141039656276912e-03,  2.65203073395980430e-03,  2.57411652877287315e-03,  2.45389126236094427e-03,  // 200
2.30460058071795494e-03,  2.13684837686712662e-03,  1.95896528478870911e-03,  1.77737008679454412e-03,  // 204
1.59690280765839059e-03,  1.42111975664438546e-03                                                       // 208


这段代码是一系列浮点数值的列表，每行包含四个浮点数，行末有注释标注行号。
// 定义长度为30的constexpr双精度数组 zunhj_gama，存储Gamma函数的系数
constexpr double zunhj_gama[30] = {
    6.29960524947436582e-01, 2.51984209978974633e-01, 1.54790300415655846e-01, 1.10713062416159013e-01,      //  0
    8.57309395527394825e-02, 6.97161316958684292e-02, 5.86085671893713576e-02, 5.04698873536310685e-02,      //  4
    4.42600580689154809e-02, 3.93720661543509966e-02, 3.54283195924455368e-02, 3.21818857502098231e-02,      //  8
    2.94646240791157679e-02, 2.71581677112934479e-02, 2.51768272973861779e-02, 2.34570755306078891e-02,      // 12
    2.19508390134907203e-02, 2.06210828235646240e-02, 1.94388240897880846e-02, 1.83810633800683158e-02,      // 16
    1.74293213231963172e-02, 1.65685837786612353e-02, 1.57865285987918445e-02, 1.50729501494095594e-02,      // 20
    1.44193250839954639e-02, 1.38184805735341786e-02, 1.32643378994276568e-02, 1.27517121970498651e-02,      // 24
    1.22761545318762767e-02, 1.18338262398482403e-02                                                         // 28
};

// 定义长度为120的constexpr双精度数组 zunik_c，存储一个数学公式的系数
constexpr double zunik_c[120] = {
     1.00000000000000000e+00, -2.08333333333333333e-01,  1.25000000000000000e-01,  3.34201388888888889e-01,  //   0
    -4.01041666666666667e-01,  7.03125000000000000e-02, -1.02581259645061728e+00,  1.84646267361111111e+00,  //   4
    -8.91210937500000000e-01,  7.32421875000000000e-02,  4.66958442342624743e+00, -1.12070026162229938e+01,  //   8
     8.78912353515625000e+00, -2.36408691406250000e+00,  1.12152099609375000e-01, -2.82120725582002449e+01,  //  12
     8.46362176746007346e+01, -9.18182415432400174e+01,  4.25349987453884549e+01, -7.36879435947963170e+00,  //  16
     2.27108001708984375e-01,  2.12570130039217123e+02, -7.65252468141181642e+02,  1.05999045252799988e+03,  //  20
    -6.99579627376132541e+02,  2.18190511744211590e+02, -2.64914304869515555e+01,  5.72501420974731445e-01,  //  24
    -1.91945766231840700e+03,  8.06172218173730938e+03, -1.35865500064341374e+04,  1.16553933368645332e+04,  //  28
    -5.30564697861340311e+03,  1.20090291321635246e+03, -1.08090919788394656e+02,  1.72772750258445740e+00,  //  32
     2.02042913309661486e+04, -9.69805983886375135e+04,  1.92547001232531532e+05, -2.03400177280415534e+05,  //  36
     1.22200464983017460e+05, -4.11926549688975513e+04,  7.10951430248936372e+03, -4.93915304773088012e+02,  //  40
     6.07404200127348304e+00, -2.42919187900551333e+05,  1.31176361466297720e+06, -2.99801591853810675e+06,  //  44
     3.76327129765640400e+06, -2.81356322658653411e+06,  1.26836527332162478e+06, -3.31645172484563578e+05,  //  48
     4.52187689813627263e+04, -2.49983048181120962e+03,  2.43805296995560639e+01,  3.28446985307203782e+06,  //  52
    -1.97068191184322269e+07,  5.09526024926646422e+07, -7.41051482115326577e+07,  6.63445122747290267e+07,  //  56
    -3.75671766607633513e+07,  1.32887671664218183e+07, -2.78561812808645469e+06,  3.08186404612662398e+05,  //  60
    -1.38860897537170405e+04,  1.10017140269246738e+02, -4.93292536645099620e+07,  3.25573074185765749e+08   //  64
};
    -9.39462359681578403e+08,  1.55359689957058006e+09, -1.62108055210833708e+09,  1.10684281682301447e+09,  //  68
    // 第68行的一组浮点数
    -4.95889784275030309e+08,  1.42062907797533095e+08, -2.44740627257387285e+07,  2.24376817792244943e+06,  //  72
    // 第72行的一组浮点数
    -8.40054336030240853e+04,  5.51335896122020586e+02,  8.14789096118312115e+08, -5.86648149205184723e+09,  //  76
    // 第76行的一组浮点数
     1.86882075092958249e+10, -3.46320433881587779e+10,  4.12801855797539740e+10, -3.30265997498007231e+10,  //  80
    // 第80行的一组浮点数
     1.79542137311556001e+10, -6.56329379261928433e+09,  1.55927986487925751e+09, -2.25105661889415278e+08,  //  84
    // 第84行的一组浮点数
     1.73951075539781645e+07, -5.49842327572288687e+05,  3.03809051092238427e+03, -1.46792612476956167e+10,  //  88
    // 第88行的一组浮点数
     1.14498237732025810e+11, -3.99096175224466498e+11,  8.19218669548577329e+11, -1.09837515608122331e+12,  //  92
    // 第92行的一组浮点数
     1.00815810686538209e+12, -6.45364869245376503e+11,  2.87900649906150589e+11, -8.78670721780232657e+10,  //  96
    // 第96行的一组浮点数
     1.76347306068349694e+10, -2.16716498322379509e+09,  1.43157876718888981e+08, -3.87183344257261262e+06,  // 100
    // 第100行的一组浮点数
     1.82577554742931747e+04,  2.86464035717679043e+11, -2.40629790002850396e+12,  9.10934118523989896e+12,  // 104
    // 第104行的一组浮点数
    -2.05168994109344374e+13,  3.05651255199353206e+13, -3.16670885847851584e+13,  2.33483640445818409e+13,  // 108
    // 第108行的一组浮点数
    -1.23204913055982872e+13,  4.61272578084913197e+12, -1.19655288019618160e+12,  2.05914503232410016e+11,  // 112
    // 第112行的一组浮点数
    -2.18229277575292237e+10,  1.24700929351271032e+09, -2.91883881222208134e+07,  1.18838426256783253e+05   // 116
    // 第116行的一组浮点数
};

// 伽玛函数的对数值数组，索引0到99
constexpr double dgamln_gln[100] = {
    0.00000000000000000e+00, 0.00000000000000000e+00, 6.93147180559945309e-01, 1.79175946922805500e+00,      //   0
    3.17805383034794562e+00, 4.78749174278204599e+00, 6.57925121201010100e+00, 8.52516136106541430e+00,      //   4
    1.06046029027452502e+01, 1.28018274800814696e+01, 1.51044125730755153e+01, 1.75023078458738858e+01,      //   8
    1.99872144956618861e+01, 2.25521638531234229e+01, 2.51912211827386815e+01, 2.78992713838408916e+01,      //  12
    3.06718601060806728e+01, 3.35050734501368889e+01, 3.63954452080330536e+01, 3.93398841871994940e+01,      //  16
    4.23356164607534850e+01, 4.53801388984769080e+01, 4.84711813518352239e+01, 5.16066755677643736e+01,      //  20
    5.47847293981123192e+01, 5.80036052229805199e+01, 6.12617017610020020e+01, 6.45575386270063311e+01,      //  24
    6.78897431371815350e+01, 7.12570389671680090e+01, 7.46582363488301644e+01, 7.80922235533153106e+01,      //  28
    8.15579594561150372e+01, 8.50544670175815174e+01, 8.85808275421976788e+01, 9.21361756036870925e+01,      //  32
    9.57196945421432025e+01, 9.93306124547874269e+01, 1.02968198614513813e+02, 1.06631760260643459e+02,      //  36
    1.10320639714757395e+02, 1.14034211781461703e+02, 1.17771881399745072e+02, 1.21533081515438634e+02,      //  40
    1.25317271149356895e+02, 1.29123933639127215e+02, 1.32952575035616310e+02, 1.36802722637326368e+02,      //  44
    1.40673923648234259e+02, 1.44565743946344886e+02, 1.48477766951773032e+02, 1.52409592584497358e+02,      //  48
    1.56360836303078785e+02, 1.60331128216630907e+02, 1.64320112263195181e+02, 1.68327445448427652e+02,      //  52
    1.72352797139162802e+02, 1.76395848406997352e+02, 1.80456291417543771e+02, 1.84533828861449491e+02,      //  56
    1.88628173423671591e+02, 1.92739047287844902e+02, 1.96866181672889994e+02, 2.01009316399281527e+02,      //  60
    2.05168199482641199e+02, 2.09342586752536836e+02, 2.13532241494563261e+02, 2.17736934113954227e+02,      //  64
    2.21956441819130334e+02, 2.26190548323727593e+02, 2.30439043565776952e+02, 2.34701723442818268e+02,      //  68
    2.38978389561834323e+02, 2.43268849002982714e+02, 2.47572914096186884e+02, 2.51890402209723194e+02,      //  72
    2.56221135550009525e+02, 2.60564940971863209e+02, 2.64921649798552801e+02, 2.69291097651019823e+02,      //  76
    2.73673124285693704e+02, 2.78067573440366143e+02, 2.82474292687630396e+02, 2.86893133295426994e+02,      //  80
    2.91323950094270308e+02, 2.95766601350760624e+02, 3.00220948647014132e+02, 3.04686856765668715e+02,      //  84
    3.09164193580146922e+02, 3.13652829949879062e+02, 3.18152639620209327e+02, 3.22663499126726177e+02,      //  88
    3.27185287703775217e+02, 3.31717887196928473e+02, 3.36261181979198477e+02, 3.40815058870799018e+02,      //  92
    3.45379407062266854e+02, 3.49954118040770237e+02, 3.54539085519440809e+02, 3.59134205369575399e+02       //  96
};

// 伽玛函数的收敛因子数组，长度为22
constexpr double dgamln_cf[22] = {
    8.33333333333333333e-02, -2.77777777777777778e-03, 7.93650793650793651e-04, -5.95238095238095238e-04,    //  0
    8.41750841750841751e-04, -1.91752691752691753e-03, 6.41025641025641026e-03, -2.95506535947712418e-02,    //  4
    1.79644372368830573e-01, -1.39243221690590112e+00, 1.34028640441683920e+01, -1.56848284626002017e+02,    //  8
    2.19310333333333333e+03, -3.61087712537249894e+04, 6.91472268851313067e+05, -1.52382215394074162e+07,    // 12
    3.82900751391414141e+08, -1.08822660357843911e+10, 3.47320283765002252e+11, -1.23696021422692745e+13,    // 16
    4.88788064793079335e+14, -2.13203339609193739e+16                                                        // 20


注释：

    // 系数序列，这些数值代表一个多项式的各项系数，按照指数递增排列
    // 每四个数表示一个多项式的一项，例如第一项为 8.3333e-02，第二项为 -2.7777e-03，依此类推
    // 每一行都以双斜杠注释其内容及其所代表的含义
//***BEGIN PROLOGUE  ZACAI
//***REFER TO  ZAIRY
//
//     ZACAI APPLIES THE ANALYTIC CONTINUATION FORMULA
//
//         K(FNU,ZN*EXP(MP))=K(FNU,ZN)*EXP(-MP*FNU) - MP*I(FNU,ZN)
//                 MP=PI*MR*std::complex<double>(0.0,1.0)
//
//     TO CONTINUE THE K FUNCTION FROM THE RIGHT HALF TO THE LEFT
//     HALF Z PLANE FOR USE WITH ZAIRY WHERE FNU=1/3 OR 2/3 AND N=1.
//     ZACAI IS THE SAME AS ZACON WITH THE PARTS FOR LARGER ORDERS AND
//     RECURRENCE REMOVED. A RECURSIVE CALL TO ZACON CAN RESULT IF ZACON
//     IS CALLED FROM ZAIRY.
//
//***ROUTINES CALLED  ZASYI,ZBKNU,ZMLRI,ZSERI,ZS1S2,D1MACH,AZABS
//***END PROLOGUE  ZACAI

inline int acai(
    std::complex<double> z,
    double fnu,
    int kode,
    int mr,
    int n,
    std::complex<double> *y,
    double rl,
    double tol,
    double elim,
    double alim
) {

    std::complex<double> csgn, cspn, c1, c2, zn, cy[2];
    double arg, ascle, az, cpn, dfnu, fmr, sgn, spn, yy;
    int inu, iuf, nn, nw;
    double pi = 3.14159265358979324;
    int nz = 0;

    // Apply the transformation to the input z to compute zn
    zn = -z;
    // Compute the absolute value of z
    az = std::abs(z);
    // Set nn to the input value of n
    nn = n;
    // Calculate dfnu which is fnu + (n-1)
    dfnu = fnu + (n-1);

    // Check if asymptotic expansion or power series is required
    if ((az > 2.0) && (az*az*0.25 > dfnu+1.0)) {
        /* 20 */
        // Check if z is sufficiently large for asymptotic expansion
        if (az >= rl) {
            //
            // ASYMPTOTIC EXPANSION FOR LARGE Z FOR THE I FUNCTION
            //
            // Call the asymptotic expansion routine
            nw = asyi(zn, fnu, kode, nn, y, rl, tol, elim, alim);
        } else {
            //
            // MILLER ALGORITHM NORMALIZED BY THE SERIES FOR THE I FUNCTION
            //
            // Call the Miller algorithm routine
            nw = mlri(zn, fnu, kode, nn, y, tol);
        }
        // Handle errors returned by asymptotic or Miller algorithm
        if (nw < 0) {
            nz = -1;
            if (nw == -2) { nz = -2; }
            return nz;
        }
    } else {
        //
        // POWER SERIES FOR THE I FUNCTION
        //
        // Call the power series routine
        seri(zn, fnu, kode, nn, y, tol, elim, alim);
    }
    /* 40 */
    //
    // ANALYTIC CONTINUATION TO THE LEFT HALF PLANE FOR THE K FUNCTION
    //
    // Call the bessel function continuation routine
    nw = bknu(zn, fnu, kode, 1, &cy[0], tol, elim, alim);
    // Handle errors returned by bessel function continuation
    if (nw != 0) {
        nz = -1;
        if (nw == -2) { nz = -2; }
        return nz;
    }

    // Prepare constants for further calculations
    fmr = mr;
    sgn = (fmr < 0.0 ? pi : -pi);
    csgn = std::complex<double>(0.0, sgn);

    // Adjust csgn if not in the first mode (kode == 1)
    if (kode != 1) {
        yy = -std::imag(zn);
        cpn = cos(yy);
        spn = sin(yy);
        csgn *= std::complex<double>(cpn, spn);
    }

    // Calculate cspn=EXP(FNU*PI*I) for minimizing losses of significance
    inu = (int)fnu;
    arg = (fnu - inu)*sgn;
    cpn = cos(arg);
    spn = sin(arg);
    cspn = std::complex<double>(cpn, spn);
    if (inu % 2 == 1) { cspn = -cspn; }

    // Store initial values of c1 and c2
    c1 = cy[0];
    c2 = y[0];

    // Adjust c1 and c2 if not in the first mode (kode == 1)
    if (kode != 1) {
        iuf = 0;
        ascle = 1e3 * d1mach[0] / tol;
        nw = s1s2(zn, &c1, &c2, ascle, alim, &iuf);
        nz += nw;
    }

    // Compute the final result using cspn and csgn
    y[0] = cspn*c1 + csgn*c2;

    // Return the final nz value
    return nz;
}
    double rl,     // 声明一个双精度浮点数变量 rl
    double fnul,   // 声明一个双精度浮点数变量 fnul
    double tol,    // 声明一个双精度浮点数变量 tol
    double elim,   // 声明一个双精度浮点数变量 elim
    double alim    // 声明一个双精度浮点数变量 alim
) {

    //***BEGIN PROLOGUE  ZACON
    //***REFER TO  ZBESK,ZBESH
    //
    //     ZACON APPLIES THE ANALYTIC CONTINUATION FORMULA
    //
    //         K(FNU,ZN*EXP(MP))=K(FNU,ZN)*EXP(-MP*FNU) - MP*I(FNU,ZN)
    //                 MP=PI*MR*std::complex<double>(0.0,1.0)
    //
    //     TO CONTINUE THE K FUNCTION FROM THE RIGHT HALF TO THE LEFT
    //     HALF Z PLANE
    //
    //***ROUTINES CALLED  ZBINU,ZBKNU,ZS1S2,D1MACH,AZABS,ZMLT
    //***END PROLOGUE  ZACON

    std::complex<double> ck, cs, cscl, cscr, csgn, cspn, c1, c2, rz, sc1, sc2 = 0.0,\
                   st, s1, s2, zn;
    double arg, ascle, as2, bscle, c1i, c1m, c1r, fmr, sgn, yy;
    int i, inu, iuf, kflag, nn, nw, nz;
    double pi = 3.14159265358979324;
    std::complex<double> cy[2] = { 0.0 };
    std::complex<double> css[3] = { 0.0 };
    std::complex<double> csr[3] = { 0.0 };
    double bry[3] = { 0.0 };

    nz = 0;  // Initialize nz to 0
    zn = -z;  // Compute -z and assign to zn
    nn = n;   // Assign n to nn
    // Call function binu to compute some values and store result in nw
    nw = binu(zn, fnu, kode, nn, y, rl, fnul, tol, elim, alim);
    }
    nz = -1;  // Set nz to -1
    if (nw == -2) { nz = -2; }  // Check if nw equals -2 and update nz accordingly
    return nz;  // Return nz
}


inline std::complex<double> airy(
    std::complex<double> z,
    int id,
    int kode,
    int *nz,
    int *ierr
) {

    //***BEGIN PROLOGUE  ZAIRY
    //***DATE WRITTEN   830501   (YYMMDD)
    //***REVISION DATE  890801   (YYMMDD)
    //***CATEGORY NO.  B5K
    //***KEYWORDS  AIRY FUNCTION,BESSEL FUNCTIONS OF ORDER ONE THIRD
    //***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
    //***PURPOSE  TO COMPUTE AIRY FUNCTIONS AI(Z) AND DAI(Z) FOR COMPLEX Z
    //***DESCRIPTION
    //
    //                      ***A DOUBLE PRECISION ROUTINE***
    //         ON KODE=1, ZAIRY COMPUTES THE COMPLEX AIRY FUNCTION AI(Z) OR
    //         ITS DERIVATIVE DAI(Z)/DZ ON ID=0 OR ID=1 RESPECTIVELY. ON
    //         KODE=2, A SCALING OPTION CEXP(ZTA)*AI(Z) OR CEXP(ZTA)*
    //         DAI(Z)/DZ IS PROVIDED TO REMOVE THE EXPONENTIAL DECAY IN
    //         -PI/3.LT.ARG(Z).LT.PI/3 AND THE EXPONENTIAL GROWTH IN
    //         PI/3.LT.ABS(ARG(Z)).LT.PI WHERE ZTA=(2/3)*Z*CSQRT(Z).
    //
    //         WHILE THE AIRY FUNCTIONS AI(Z) AND DAI(Z)/DZ ARE ANALYTIC IN
    //         THE WHOLE Z PLANE, THE CORRESPONDING SCALED FUNCTIONS DEFINED
    //         FOR KODE=2 HAVE A CUT ALONG THE NEGATIVE REAL AXIS.
    //         DEFINITIONS AND NOTATION ARE FOUND IN THE NBS HANDBOOK OF
    //         MATHEMATICAL FUNCTIONS (REF. 1).
    //
    //         INPUT      ZR,ZI ARE DOUBLE PRECISION
    //           ZR,ZI  - Z=std::complex<double>(ZR,ZI)
    //           ID     - ORDER OF DERIVATIVE, ID=0 OR ID=1
    //           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
    //                    KODE= 1  RETURNS
    //                             AI=AI(Z)                ON ID=0 OR
    //                             AI=DAI(Z)/DZ            ON ID=1
    //                        = 2  RETURNS
    //                             AI=CEXP(ZTA)*AI(Z)       ON ID=0 OR


注：这是注释的部分代码。
    //                             AI=CEXP(ZTA)*DAI(Z)/DZ   ON ID=1 WHERE
    //                             ZTA=(2/3)*Z*CSQRT(Z)
    //
    //         OUTPUT     AIR,AII ARE DOUBLE PRECISION
    //           AIR,AII- COMPLEX ANSWER DEPENDING ON THE CHOICES FOR ID AND
    //                    KODE
    //           NZ     - UNDERFLOW INDICATOR
    //                    NZ= 0   , NORMAL RETURN
    //                    NZ= 1   , AI=std::complex<double>(0.0D0,0.0D0) DUE TO UNDERFLOW IN
    //                              -PI/3.LT.ARG(Z).LT.PI/3 ON KODE=1
    //           IERR   - ERROR FLAG
    //                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
    //                    IERR=1, INPUT ERROR   - NO COMPUTATION
    //                    IERR=2, OVERFLOW      - NO COMPUTATION, REAL(ZTA)
    //                            TOO LARGE ON KODE=1
    //                    IERR=3, CABS(Z) LARGE      - COMPUTATION COMPLETED
    //                            LOSSES OF SIGNIFCANCE BY ARGUMENT REDUCTION
    //                            PRODUCE LESS THAN HALF OF MACHINE ACCURACY
    //                    IERR=4, CABS(Z) TOO LARGE  - NO COMPUTATION
    //                            COMPLETE LOSS OF ACCURACY BY ARGUMENT
    //                            REDUCTION
    //                    IERR=5, ERROR              - NO COMPUTATION,
    //                            ALGORITHM TERMINATION CONDITION NOT MET
    //
    //***LONG DESCRIPTION
    //
    //         AI AND DAI ARE COMPUTED FOR CABS(Z).GT.1.0 FROM THE K BESSEL
    //         FUNCTIONS BY
    //
    //            AI(Z)=C*SQRT(Z)*K(1/3,ZTA) , DAI(Z)=-C*Z*K(2/3,ZTA)
    //                           C=1.0/(PI*SQRT(3.0))
    //                            ZTA=(2/3)*Z**(3/2)
    //
    //         WITH THE POWER SERIES FOR CABS(Z).LE.1.0.
    //
    //         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
    //         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z IS LARGE, LOSSES
    //         OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR. CONSEQUENTLY, IF
    //         THE MAGNITUDE OF ZETA=(2/3)*Z**1.5 EXCEEDS U1=SQRT(0.5/UR),
    //         THEN LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR
    //         FLAG IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS
    //         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
    //         ALSO, IF THE MAGNITUDE OF ZETA IS LARGER THAN U2=0.5/UR, THEN
    //         ALL SIGNIFICANCE IS LOST AND IERR=4. IN ORDER TO USE THE INT
    //         FUNCTION, ZETA MUST BE FURTHER RESTRICTED NOT TO EXCEED THE
    //         LARGEST INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF ZETA
    //         MUST BE RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2,
    //         AND U3 ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE
    //         PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE
    //         PRECISION ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMIT-
    // 声明复数变量和双精度浮点变量，用于计算复数贝塞尔函数的近似值
    std::complex<double> ai, csq, cy[1], s1, s2, trm1, trm2, zta, z3;
    double aa, ad, ak, alim, atrm, az, az3, bk, ck, dig, dk, d1, d2,\
           elim, fid, fnu, rl, r1m5, sfac, tol, zi, zr, bb, alaz;
    int iflag, k, k1, k2, mr, nn;
    // 定义常数 tth 为 2/3
    double tth = 2. / 3.;
    // 定义常数 c1, c2, coef，分别为系数值，用于后续计算
    double c1 = 0.35502805388781723926;    /* 1/(Gamma(2/3) * 3**(2/3)) */
    double c2 = 0.25881940379280679841;    /* 1/(Gamma(1/3) * 3**(1/3)) */
    double coef = 0.18377629847393068317;  /* 1 / (sqrt(3) * PI)        */

    // 初始化错误码 ierr 和非零数 nz，并设置初始值 ai 为 0
    *ierr = 0;
    *nz = 0;
    ai = 0.;

    // 检查 id 和 kode 的值是否符合预期，若不符则设置 ierr 为 1
    if ((id < 0) || (id > 1)) { *ierr = 1; }
    if ((kode < 1) || (kode > 2)) { *ierr = 1; }

    // 若存在错误，则直接返回 0
    if (*ierr != 0) return 0.;

    // 计算 z 的绝对值并赋给 az
    az = std::abs(z);

    // 设置 tol 为机器精度的一个估计值
    tol = d1mach[3];

    // 将 id 的值赋给 fid
    fid = id;

    // 根据 az 的大小选择不同的分支进行计算
    if (az <= 1.0) {
        //
        // POWER SERIES FOR ABS(Z) <= 1.
        //
        // 初始化部分级数求和的变量 s1 和 s2
        s1 = 1.0;
        s2 = 1.0;

        // 若 az 过小，则调整 s1 的计算方式
        if (az < tol) {
            // 设置一个较大的值 aa
            aa = 1e3*d1mach[0];
            s1 = 0.;

            // 根据 id 的值进行不同的计算分支
            if (id != 1) {
                // 若 az 较大，则使用 c2 * z 进行计算
                if (az > aa) { s1 = c2 * z; }
                ai = c1 - s1;
                return ai;
            }

            // 若 id 等于 1，则计算 ai 的另一种情况
            ai = -c2;
            aa = sqrt(aa);
            if (az > aa) { s1 = z * z * 0.5; }
            ai += s1 * c1;
            return ai;
        }

        // 计算 aa 的平方
        aa = az*az;

        // 若 aa 较大，则采用级数展开计算
        if (aa >= tol/az) {
            // 初始化级数求和的变量及其它中间变量
            trm1 = 1.0;
            trm2 = 1.0;
            atrm = 1.0;
            z3 = z*z*z;
            az3 = az * aa;
            ak = 2.0 + fid;
            bk = 3.0 - fid - fid;
            ck = 4.0 - fid;
            dk = 3.0 + fid + fid;
            d1 = ak * dk;
            d2 = bk * ck;
            ad = (d1 > d2 ? d2 : d1);
            ak = 24.0 + 9.0*fid;
            bk = 30.0 - 9.0*fid;

            // 开始进行级数求和的循环
            for (int k = 1; k < 26; k++)
            {
                trm1 *= z3/d1;
                s1 += trm1;
                trm2 *= z3/d2;
                s2 += trm2;
                atrm *= az3 / ad;
                d1 += ak;
                d2 += bk;
                ad = (d1 > d2 ? d2 : d1);
                
                // 若 atrm 较小，则退出循环
                if (atrm < tol*ad) { break; }

                ak += 18.0;
                bk += 18.0;
            }
        }

        // 根据 id 和 kode 的不同情况，计算最终的 ai 值
        if (id != 1) {
            ai = s1*c1 - z*s2*c2;
            if (kode == 1) { return ai; }
            zta = z*std::sqrt(z)*tth;
            ai *= std::exp(zta);
            return ai;
        }

        ai = -s2*c2;
        if (az > tol) { ai += z*z*s1*c1/(1. + fid); }
        if (kode == 1) { return ai; }
        zta = z*std::sqrt(z)*tth;
        return ai*std::exp(zta);
    }

    // 若 az > 1.0，则执行以下代码块
    //
    // CASE FOR ABS(Z) > 1.0
    //
    fnu = (1.0 + fid) / 3.0;

    // 设置机器常数相关的参数
    k1 = i1mach[14];
    k2 = i1mach[15];
    r1m5 = d1mach[4];
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );
    elim = 2.303 * (k*r1m5 - 3.0);
    k1 = i1mach[13] - 1;
    // 计算 aa，这是 r1m5 乘以 k1 的结果
    aa = r1m5 * k1;
    // 将 aa 限制在 18.0 以内
    dig = (aa > 18.0 ? 18.0 : aa);
    // aa 增大 2.303 倍
    aa *= 2.303;
    // 计算 alim，这是 elim 和 (-aa 和 -41.45 之间较大的一个的和
    alim = elim + (-aa > -41.45 ? -aa : -41.45);
    // 计算 rl，这是 1.2 乘以 dig 加上 3.0
    rl = 1.2 * dig + 3.0;
    // 计算 alaz，这是 az 的自然对数
    alaz = log(az);

    //
    // 测试范围
    //

    // 计算 aa，这是 0.5 除以 tol 的结果
    aa = 0.5 / tol;
    // 计算 bb，这是 i1mach[8] 的一半
    bb = i1mach[8] * 0.5;
    // 将 aa 限制在 bb 以内
    aa = (aa > bb ? bb : aa);
    // aa 的 tth 次方
    aa = pow(aa, tth);
    // 如果 az 大于 aa，则设置 ierr 为 4，nz 为 0，并返回 0.0
    if (az > aa) {
        *ierr = 4;
        *nz = 0;
        return 0.0;
    }
    // aa 的平方根
    aa = sqrt(aa);
    // 如果 az 大于 aa，则设置 ierr 为 3
    if (az > aa) { *ierr = 3; }

    // csq 是 z 的平方根
    csq = std::sqrt(z);
    // zta 是 z 乘以 csq 和 tth 的乘积
    zta = z * csq * tth;

    //
    // 当 RE(Z) < 0 时，特别是当 IM(Z) 很小时，确保 RE(ZTA) <= 0
    //

    // 初始化 iflag 和 sfac
    iflag = 0;
    sfac = 1.0;
    // 获取 z 的虚部和实部
    zi = std::imag(z);
    zr = std::real(z);
    // 获取 zta 的虚部和实部
    ak = std::imag(zta);
    // 如果 z 的实部小于 0.0
    if (zr < 0.0) {
        bk = std::real(zta);
        ck = -fabs(bk);
        // 将 zta 更新为一个新的复数，实部为 -fabs(bk)，虚部为 ak
        zta = std::complex<double>(ck, ak);
    }
    // 如果 zi 等于 0.0，并且 zr 小于等于 0.0
    if ((zi == 0.0) && (zr <= 0.0)) {
        // 将 zta 更新为一个新的复数，实部为 0.0，虚部为 ak
        zta = std::complex<double>(0.0, ak);
    }
    // 获取 zta 的实部
    aa = std::real(zta);
    // 如果 zta 的实部小于 0.0，或者 z 的实部小于等于 0.0
    if ((aa < 0.0) || (zr <= 0.0)) {
        // 如果 kode 不等于 2
        if (kode != 2) {
            //
            // 溢出测试
            //
            // 如果 aa 小于等于 -alim，则调整 aa 的值，设置 iflag 为 1，sfac 为 tol
            if (aa <= -alim) {
                aa = -aa + 0.25 * alaz;
                iflag = 1;
                sfac = tol;
                // 如果 aa 大于 elim，则返回 ai，nz 为 0，ierr 为 2
                if (aa > elim) {
                    /* 270 */
                    *nz = 0;
                    *ierr = 2;
                    return ai;
                }
            }
        }
        //
        // 当 kode=2 时，CBKNU 和 CACAI 在 K(FNU,ZTA) 上返回 EXP(ZTA)*K(FNU,ZTA)
        //
        // 初始化 mr 为 1
        mr = 1;
        // 如果 zi 小于 0.0，则 mr 为 -1
        if (zi < 0.0) { mr = -1; }
        // 调用 acai 函数，计算返回值 nn
        nn = acai(zta, fnu, kode, mr, 1, &cy[0], rl, tol, elim, alim);
        // 如果 nn 小于 0
        if (nn < 0) {
            // 如果 nn 等于 -1，则 nz 为 1，返回 0.0
            if (nn == -1) {
                *nz = 1;
                return 0.0;
            } else {
                // 否则，nz 为 0，ierr 为 5，返回 0.0
                *nz = 0;
                *ierr = 5;
                return 0.0;
            }
        }
        // nz 增加 nn
        *nz += nn;
    } else {
        // 如果 kode 不等于 2
        if (kode != 2) {
            //
            // 下溢测试
            //
            // 如果 aa 大于等于 alim，则调整 aa 的值，设置 iflag 为 2，sfac 为 1.0/tol
            if (aa >= alim) {
                aa = -aa - 0.25 * alaz;
                iflag = 2;
                sfac = 1.0 / tol;
                // 如果 aa 小于 -elim，则 nz 为 1，返回 0.0
                if (aa < -elim) {
                    *nz = 1;
                    return 0.0;
                }
            }
        }
        // 调用 bknu 函数，返回结果存储在 cy[0] 中
        *nz = bknu(zta, fnu, kode, 1, &cy[0], tol, elim, alim);
    }
    // 计算 s1，这是 cy[0] 乘以 coef 的结果
    s1 = cy[0] * coef;

    // 如果 iflag 等于 0
    if (iflag == 0) {
        // 如果 id 不等于 1，则返回 csq 乘以 s1
        if (id != 1) {
            return csq * s1;
        }
        // 否则，返回 -z 乘以 s1
        return (-z * s1);
    }
    // 如果 iflag 不等于 0
    s1 *= sfac;
    // 如果 id 不等于 1
    if (id != 1) {
        // s1 乘以 csq，然后除以 sfac，返回结果
        s1 *= csq;
        return (s1 / sfac);
    }
    // 否则，s1 乘以 -z，然后除以 sfac，返回结果
    s1 *= -z;
    return (s1 / sfac);
// 为asymptotic bessel function计算I类Bessel函数
inline int asyi(
    std::complex<double> z,             // 输入：复数参数z
    double fnu,                         // 输入：实数参数fnu
    int kode,                           // 输入：整数参数kode
    int n,                              // 输入：整数参数n
    std::complex<double> *y,            // 输出：复数数组y
    double rl,                           // 输入：实数参数rl
    double tol,                          // 输入：实数参数tol
    double elim,                         // 输入：实数参数elim
    double alim                          // 输入：实数参数alim
) {

    //***BEGIN PROLOGUE  ZASYI
    //***REFER TO  ZBESI,ZBESK
    //
    //     ZASYI COMPUTES THE I BESSEL FUNCTION FOR REAL(Z).GE.0.0 BY
    //     MEANS OF THE ASYMPTOTIC EXPANSION FOR LARGE CABS(Z) IN THE
    //     REGION CABS(Z).GT.MAX(RL,FNU*FNU/2). NZ=0 IS A NORMAL RETURN.
    //     NZ.LT.0 INDICATES AN OVERFLOW ON KODE=1.
    //
    //***ROUTINES CALLED  D1MACH,AZABS,ZDIV,AZEXP,ZMLT,AZSQRT
    //***END PROLOGUE  ZASYI

    std::complex<double> ak1, ck, cs1, cs2, cz, dk, ez, p1, rz, s2;
    double aa, acz, aez, ak, arg, arm, atol, az, bb, bk, dfnu;
    double dnu2, fdn, rtr1, s, sgn, sqk, x, yy;
    int ib, il, inu, j, jl, k, koded, m, nn;
    double pi = 3.14159265358979324;
    double rpi = 0.159154943091895336; /* (1 / pi) */
    int nz = 0;

    // 计算输入参数z的绝对值
    az = std::abs(z);
    // 获取z的实部
    x = std::real(z);
    // 设置阈值
    arm = 1e3 * d1mach[0];
    // 计算平方根
    rtr1 = sqrt(arm);
    // 选择il作为n和2之间的最小值
    il = (n > 2 ? 2 : n);
    // 计算dfnu
    dfnu = fnu + (n - il);

    // 过载测试
    ak1 = std::sqrt(rpi / z);
    cz = z;
    // 如果kode等于2，则重新定义cz
    if (kode == 2) { cz = std::complex<double>(0.0, std::imag(z)); }
    // 获取cz的实部
    acz = std::real(cz);
    // 检查绝对值的大小是否小于等于elim
    if (fabs(acz) <= elim) {
        // 计算dnu的两倍
        dnu2 = dfnu + dfnu;
        // 设置koded为1，表示开启了特定的条件
        koded = 1;
        // 如果acz的绝对值不大于alim，并且n大于2，则设置koded为0，并更新ak1的值
        if (!((fabs(acz) > alim) && (n > 2))) {
            koded = 0;
            ak1 *= std::exp(cz);
        }
        // 初始化fdn为0
        fdn = 0.;
        // 如果dnu2大于rtr1，则计算fdn的值
        if (dnu2 > rtr1) { fdn = dnu2 * dnu2; }
        // 计算ez的值
        ez = z * 8.;
        
        // 当z是虚数时，必须相对于第一个倒数幂进行误差测试，因为这是扩展的主导项的虚部
        // aez是8乘以az
        aez = 8. * az;
        
        // 设置s为tol除以aez的结果
        s = tol / aez;
        
        // 计算jl为(rl + rl)加2的整数部分
        jl = (int)(rl + rl) + 2;
        
        // 计算yy为z的虚部
        yy = std::imag(z);
        
        // 初始化p1为0
        p1 = 0.;
        // 如果yy不等于0，则进行以下操作
        if (yy != 0.) {
            // 计算inu为fnu的整数部分
            inu = (int)fnu;
            // 计算arg为(fnu - inu)乘以pi
            arg = (fnu - inu) * pi;
            // 更新inu为inu加上n减去il
            inu += n - il;
            // 计算ak为-sin(arg)，bk为cos(arg)
            ak = -sin(arg);
            bk = cos(arg);
            // 如果yy小于0，则更新bk为-bk
            if (yy < 0.) { bk = -bk; }
            // 初始化p1为一个复数
            p1 = std::complex<double>(ak, bk);
            // 如果inu除以2的余数为1，则取反p1
            if (inu % 2 == 1) { p1 = -p1; }
        }
        
        // 对于每个k从1到(il+1)的循环
        for (int k = 1; k < (il+1); k++)
        {
            // 计算sqk为fdn减1
            sqk = fdn - 1.;
            // 计算atol为s乘以sqk的绝对值
            atol = s * fabs(sqk);
            // 初始化sgn为1，cs1为1，cs2为1，ck为1，ak为0，aa为1，bb为aez，dk为ez，j为1
            sgn = 1.;
            cs1 = 1.;
            cs2 = 1.;
            ck = 1.;
            ak = 0.;
            aa = 1.;
            bb = aez;
            dk = ez;
            
            // 对于每个j从1到(jl+1)的循环
            for (j = 1; j < (jl + 1); j++)
            {
                // 更新ck为ck乘以sqk除以dk
                ck *= sqk / dk;
                // 更新cs2为cs2加上ck
                cs2 += ck;
                // 更新sgn为-sgn
                sgn = -sgn;
                // 更新cs1为cs1加上ck乘以sgn
                cs1 += ck * sgn;
                // 更新dk为dk加上ez
                dk += ez;
                // 更新aa为aa乘以sqk的绝对值除以bb
                aa *= fabs(sqk) / bb;
                // 更新bb为bb加上aez
                bb += aez;
                // 更新ak为ak加上8
                ak += 8.;
                // 更新sqk为sqk减去ak
                sqk -= ak;
                // 如果aa小于等于atol，则跳出循环
                if (aa <= atol) { break; }
            }
            // 如果j等于(jl+1)且aa大于atol，则返回-2
            if ((j == (jl + 1)) && (aa > atol)) { return -2; }

            // 设置s2为cs1
            s2 = cs1;
            // 如果x加上x小于elim，则更新s2为s2加上p1乘以cs2乘以std::exp(-z-z)
            if (x + x < elim) { s2 += p1 * cs2 * std::exp(-z - z); }
            // 更新fdn为fdn加上8乘以dfnu加上4
            fdn += 8. * dfnu + 4.;
            // 更新p1为-p1
            p1 = -p1;
            // 更新m为n减去il加上k
            m = n - il + k;
            // 更新y[m-1]为s2乘以ak1
            y[m - 1] = s2 * ak1;
        }
        // 如果n小于等于2，则返回nz
        if (n <= 2) { return nz; }
        
        // 更新nn为n，更新k为nn减去2
        nn = n;
        k = nn - 2;
        // 更新ak为k，更新rz为2除以z
        ak = k;
        rz = 2. / z;
        ib = 3;
        
        // 对于每个i从ib到(nn+1)的循环
        for (int i = ib; i < (nn + 1); i++)
        {
            // 更新y[k-1]为(ak加上fnu)乘以rz乘以y[k]加上y[k+1]
            y[k - 1] = (ak + fnu) * rz * y[k] + y[k + 1];
            // 更新ak为ak减去1
            ak -= 1.;
            // 更新k为k减去1
            k -= 1;
        }
        
        // 如果koded等于0，则返回nz
        if (koded == 0) { return nz; }
        
        // 更新ck为std::exp(cz)
        ck = std::exp(cz);
        // 对于每个i从0到(nn+1)的循环，更新y[i]为y[i]乘以ck
        for (int i = 0; i < (nn + 1); i++) { y[i] *= ck; }
        
        // 返回nz
        return nz;
    }
    // 如果acz的绝对值大于elim，则返回-1
    /* 100 */
    return -1;
inline int besh(
    std::complex<double> z,   // 输入参数，复数 z
    double fnu,               // 输入参数，双精度浮点数 fnu
    int kode,                 // 输入参数，整数 kode
    int m,                    // 输入参数，整数 m
    int n,                    // 输入参数，整数 n
    std::complex<double> *cy, // 输出参数，复数数组 cy
    int *ierr                 // 输出参数，整数指针 ierr
) {

    //***BEGIN PROLOGUE  ZBESH
    //***DATE WRITTEN   830501   (YYMMDD)
    //***REVISION DATE  890801   (YYMMDD)
    //***CATEGORY NO.  B5K
    //***KEYWORDS  H-BESSEL FUNCTIONS,BESSEL FUNCTIONS OF COMPLEX ARGUMENT,
    //             BESSEL FUNCTIONS OF THIRD KIND,HANKEL FUNCTIONS
    //***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
    //***PURPOSE  TO COMPUTE THE H-BESSEL FUNCTIONS OF A COMPLEX ARGUMENT
    //***DESCRIPTION
    //
    //                      ***A DOUBLE PRECISION ROUTINE***
    //         ON KODE=1, ZBESH COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
    //         HANKEL (BESSEL) FUNCTIONS CY(J)=H(M,FNU+J-1,Z) FOR KINDS M=1
    //         OR 2, REAL, NONNEGATIVE ORDERS FNU+J-1, J=1,...,N, AND COMPLEX
    //         Z.NE.std::complex<double>(0.0,0.0) IN THE CUT PLANE -PI.LT.ARG(Z).LE.PI.
    //         ON KODE=2, ZBESH RETURNS THE SCALED HANKEL FUNCTIONS
    //
    //         CY(I)=EXP(-MM*Z*I)*H(M,FNU+J-1,Z)       MM=3-2*M,   I**2=-1.
    //
    //         WHICH REMOVES THE EXPONENTIAL BEHAVIOR IN BOTH THE UPPER AND
    //         LOWER HALF PLANES. DEFINITIONS AND NOTATION ARE FOUND IN THE
    //         NBS HANDBOOK OF MATHEMATICAL FUNCTIONS (REF. 1).
    //
    //         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
    //           ZR,ZI  - Z=std::complex<double>(ZR,ZI), Z.NE.std::complex<double>(0.0D0,0.0D0),
    //                    -PT.LT.ARG(Z).LE.PI
    //           FNU    - ORDER OF INITIAL H FUNCTION, FNU.GE.0.0D0
    //           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
    //                    KODE= 1  RETURNS
    //                             CY(J)=H(M,FNU+J-1,Z),   J=1,...,N
    //                        = 2  RETURNS
    //                             CY(J)=H(M,FNU+J-1,Z)*EXP(-I*Z*(3-2M))
    //                                  J=1,...,N  ,  I**2=-1
    //           M      - KIND OF HANKEL FUNCTION, M=1 OR 2
    //           N      - NUMBER OF MEMBERS IN THE SEQUENCE, N.GE.1
    //
    //         OUTPUT     CYR,CYI ARE DOUBLE PRECISION
    //           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
    //                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
    //                    CY(J)=H(M,FNU+J-1,Z)  OR
    //                    CY(J)=H(M,FNU+J-1,Z)*EXP(-I*Z*(3-2M))  J=1,...,N
    //                    DEPENDING ON KODE, I**2=-1.
    //           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,
    //                    NZ= 0   , NORMAL RETURN
    //                    NZ.GT.0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE
    //                              TO UNDERFLOW, CY(J)=std::complex<double>(0.0D0,0.0D0)
    //                              J=1,...,NZ WHEN Y.GT.0.0 AND M=1 OR
    //                              Y.LT.0.0 AND M=2. FOR THE COMPLMENTARY
    //                              HALF PLANES, NZ STATES ONLY THE NUMBER
    //                              OF UNDERFLOWS.
    //           IERR   - ERROR FLAG
    //                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
    //                    IERR=1, INPUT ERROR   - NO COMPUTATION
    //                    IERR=2, OVERFLOW      - NO COMPUTATION, FNU TOO
    //                            LARGE OR CABS(Z) TOO SMALL OR BOTH
    //                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
    //                            BUT LOSSES OF SIGNIFICANCE BY ARGUMENT
    //                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE
    //                            ACCURACY
    //                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
    //                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
    //                            CANCE BY ARGUMENT REDUCTION
    //                    IERR=5, ERROR              - NO COMPUTATION,
    //                            ALGORITHM TERMINATION CONDITION NOT MET
    //
    //***LONG DESCRIPTION
    //
    //         THE COMPUTATION IS CARRIED OUT BY THE RELATION
    //
    //         H(M,FNU,Z)=(1/MP)*EXP(-MP*FNU)*K(FNU,Z*EXP(-MP))
    //             MP=MM*HPI*I,  MM=3-2*M,  HPI=PI/2,  I**2=-1
    //
    //         FOR M=1 OR 2 WHERE THE K BESSEL FUNCTION IS COMPUTED FOR THE
    //         RIGHT HALF PLANE RE(Z).GE.0.0. THE K FUNCTION IS CONTINUED
    //         TO THE LEFT HALF PLANE BY THE RELATION
    //
    //         K(FNU,Z*EXP(MP)) = EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)
    //         MP=MR*PI*I, MR=+1 OR -1, RE(Z).GT.0, I**2=-1
    //
    //         WHERE I(FNU,Z) IS THE I BESSEL FUNCTION.
    //
    //         EXPONENTIAL DECAY OF H(M,FNU,Z) OCCURS IN THE UPPER HALF Z
    //         PLANE FOR M=1 AND THE LOWER HALF Z PLANE FOR M=2.  EXPONENTIAL
    //         GROWTH OCCURS IN THE COMPLEMENTARY HALF PLANES.  SCALING
    //         BY EXP(-MM*Z*I) REMOVES THE EXPONENTIAL BEHAVIOR IN THE
    //         WHOLE Z PLANE FOR Z TO INFINITY.
    //
    //         FOR NEGATIVE ORDERS,THE FORMULAE
    //
    //               H(1,-FNU,Z) = H(1,FNU,Z)*CEXP( PI*FNU*I)
    //               H(2,-FNU,Z) = H(2,FNU,Z)*CEXP(-PI*FNU*I)
    //                         I**2=-1
    //
    //         CAN BE USED.
    //
    //         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
    //         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
    //         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
    //         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
    //         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
    //         IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS
    //         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
    //         IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
    //         ...
    //         (The remainder of the comments are omitted as per instructions)
    //         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
    //         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
    //         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
    //         RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
    //         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
    //         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
    //         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
    //         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
    //         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
    //         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
    //         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
    //
    //         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
    //         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
    //         ROUNDOFF,1.0D-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
    //         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
    //         ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
    //         ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
    //         CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
    //         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
    //         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
    //         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
    //         THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
    //         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
    //         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
    //         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
    //         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
    //         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
    //         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
    //         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
    //         OR -PI/2+P.
    //
    //***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
    //                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
    //                 COMMERCE, 1955.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 BY D. E. AMOS, SAND83-0083, MAY, 1983.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
    //
    //               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
    //                 1018, MAY, 1985
    //
    //               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
    //                 MATH. SOFTWARE, 1986
    //
    //***ROUTINES CALLED  ZACON,ZBKNU,ZBUNK,ZUOIK,AZABS,I1MACH,D1MACH
    //***END PROLOGUE  ZBESH

    std::complex<double> zn, zt, csgn;
    double aa, alim, aln, arg, az, cpn, dig, elim, fmm, fn, fnul,
        rhpi, rl, r1m5, sgn, spn, tol, ufl, xn, xx, yn, yy,
        bb, ascle, rtol, atol;
    int i, inu, inuh, ir, k, k1, k2, mm, mr, nn, nuf, nw, nz;

    double hpi = 1.57079632679489662; /* 0.5 PI */

    nz = 0;
    xx = std::real(z);
    yy = std::imag(z);
    *ierr = 0;

    if ((xx == 0.0) && (yy == 0.0)) { *ierr = 1; }
    if (fnu < 0.0) { *ierr = 1; }
    if ((m < 1) || (m > 2)) { *ierr = 1; }
    if ((kode < 1) || (kode > 2)) { *ierr = 1; }
    if (n < 1) { *ierr = 1; }
    if (*ierr != 0) { return nz; }
    nn = n;
    //
    //  SET PARAMETERS RELATED TO MACHINE CONSTANTS.
    //  TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
    //  ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
    //  EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL    AND
    //  EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
    //  UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
    //  RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
    //  DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
    //  FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
    //
    tol = fmax(d1mach[3], 1e-18);  // Determine tolerance as the maximum of machine epsilon and 1.0E-18
    k1 = i1mach[14];  // Get the value of machine-dependent constant
    k2 = i1mach[15];  // Get another value of machine-dependent constant
    r1m5 = d1mach[4];  // Get another machine-dependent constant
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );  // Determine the minimum of the absolute values of k1 and k2
    elim = 2.303 * (k*r1m5 - 3.0);  // Compute the limit for exponential over- and underflow
    k1 = i1mach[13] - 1;  // Compute a modified machine-dependent constant
    aa = r1m5 * k1;  // Compute a value based on r1m5 and k1
    dig = fmin(aa, 18.0);  // Determine the number of significant digits in the tolerance
    aa *= 2.303;
    alim = elim + fmax(-aa, -41.45);  // Determine the limit for underflow and overflow
    fnul = 10.0 + 6.0 * (dig - 3.0);  // Compute the lower boundary for the asymptotic series for large FNU
    rl = 1.2 * dig + 3.0;  // Compute the lower boundary of the asymptotic expansion for large Z
    fn = fnu + (nn - 1);  // Compute fn as fnu plus (nn - 1)
    mm = 3 - m - m;  // Compute mm based on m
    fmm = mm;
    zn = z * std::complex<double>(0.0, -fmm);  // Compute zn as z times a complex number
    xn = std::real(zn);  // Extract real part of zn
    yn = std::imag(zn);  // Extract imaginary part of zn
    //
    // TEST FOR PROPER RANGE
    //
    az = std::abs(z);  // Compute absolute value of z
    bb = d1mach[1] * 0.5;  // Compute half of the smallest positive number
    aa = fmin(0.5 / tol, bb);  // Determine a threshold value based on tolerance and machine precision
    if ((az > aa) || (fn > aa)){ *ierr = 4; return 0; }  // Check if az or fn exceed the threshold; set ierr to 4 if true
    aa = sqrt(aa);  // Compute the square root of aa
    if (az > aa) { *ierr = 3; }  // Set ierr to 3 if az exceeds aa
    if (fn > aa) { *ierr = 3; }  // Set ierr to 3 if fn exceeds aa
    //
    // OVERFLOW TEST ON THE LAST MEMBER OF THE SEQUENCE
    //
    ufl = d1mach[0] * 1.0e3;  // Compute a value related to underflow
    if (az < ufl) { *ierr = 2; return 0; }  // Set ierr to 2 if az is less than ufl
    if (fnu <= fnul) {
        //
        // Untangling GOTOs with explicit conditions
        //

        if ((fn > 1.0) && (fn <= 2.0) && (az <= tol)) {
            /* Failed through all checks */
            arg = 0.5 * az;
            aln = -fn * log(arg);
            if (aln > elim) { *ierr = 2; return 0; }  /* GO TO 230 */
            /* GO TO 70 */
        } else if ((fn > 1.0) && (fn <= 2.0) && (az > tol)) {
            /* Failed all but the az > tol hence do nothing and GO TO 70 */
        } else if ((fn > 1.0) && (fn > 2.0)) {
            /* GO TO 60 */
            // Call to compute K functions with non-trivial conditions
            nuf = uoik(zn, fnu, kode, 2, nn, cy, tol, elim, alim);
            if (nuf < 0) { *ierr = 2; return 0; }  /* GO TO 230 */
            nz += nuf;
            nn -= nuf;
            //
            // HERE NN=N OR NN=0 SINCE NUF=0,NN, OR -1 ON RETURN FROM CUOIK
            // IF NUF=NN, THEN CY(I)=CZERO FOR ALL I
            //
            if (nn == 0) {
                /* GO TO 140 */
                if (xn < 0.0) { *ierr = 2; return 0; }  /* GO TO 230 */
                return nz;
            }
            /* GO TO 70 */
        } else {
            /* Passed the first hence GO TO 70 */
        }

        /* GO TO 70 */
        //
        // More GOTOs untangling
        //

        if ((xn < 0.0) || ((xn == 0.0) && (yn < 0.0) && (m == 2))) {
            /* GO TO 80 */
            mr = -mm;
            // Call to compute A functions with various conditions
            nw = acon(zn, fnu, kode, mr, nn, cy, rl, fnul, tol, elim, alim);
            if (nw < 0) {
                /* GO TO 240 */
                if (nw == -1) { *ierr = 2; return 0; }  /* GO TO 230 */
                *ierr = 5;
                return 0;
            }
            nz = nw;
            /* GO TO 110 */
        } else {
            //
            // RIGHT HALF PLANE COMPUTATION, XN >= 0.  .AND.  (XN.NE.0.  .OR.
            // YN >= 0.  .OR.  M=1)
            //
            // Call to compute Bessel function K with non-trivial conditions
            nz = bknu(zn, fnu, kode, nn, cy, tol, elim, alim);
            /* GO TO 110 */
        }
    } else {
        /* GO TO 90 */
        //
        // UNIFORM ASYMPTOTIC EXPANSIONS FOR FNU > FNUL
        //

        mr = 0;
        if (!((xn >= 0.0) && ((xn != 0.0) || (yn >= 0.0) || (m != 2)))) {
            mr = -mm;
            if ((xn == 0.0) && (yn < 0.0)) { zn = -zn; }
        }
        /* GO TO 100 */
        // Call to compute asymptotic series with non-trivial conditions
        nw = bunk(zn, fnu, kode, mr, nn, cy, tol, elim, alim);
        if (nw < 0) {
            /* GO TO 240 */
            if (nw == -1) { *ierr = 2; return 0; }  /* GO TO 230 */
            *ierr = 5;
            return 0;
        }
        nz += nw;
    }
    /* 110 */
    //
    // H(M,FNU,Z) = -FMM*(I/HPI)*(ZT**FNU)*K(FNU,-Z*ZT)
    // ZT=EXP(-FMM*HPI*I) = std::complex<double>(0.0,-FMM), FMM=3-2*M, M=1,2
    //
    sgn = (-fmm < 0 ? -hpi : hpi);
    //
    // CALCULATE EXP(FNU*HPI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
    // WHEN FNU IS LARGE
    //
    inu = (int)fnu;
    inuh = inu / 2;
    ir = inu - 2 * inuh;
    arg = (fnu - (inu - ir)) * sgn;
    rhpi = 1.0 / sgn;
    cpn = rhpi * cos(arg);
    // 计算 spn，使用 -rhpi 乘以 sin(arg)，得到一个浮点数
    spn = -rhpi * sin(arg);

    // 创建一个复数对象 csgn，实部为 spn，虚部为 cpn
    csgn = std::complex<double>(spn, cpn);

    // 如果 inuh 是奇数，将 csgn 取负值
    if (inuh % 2 == 1) { csgn = -csgn; }

    // 创建一个虚部为 -fmm 的复数对象 zt
    zt = std::complex<double>(0.0, -fmm);

    // 计算 rtol，作为 1/tol 的倒数
    rtol = 1.0 / tol;

    // 计算 ascle，为 ufl 乘以 rtol
    ascle = ufl * rtol;

    // 循环遍历 cy 数组，索引从 1 到 nn
    for (i = 1; i < (nn+1); i++) {
        // 取出当前 cy[i-1] 的值作为 zn
        zn = cy[i-1];

        // 初始化 atol 为 1.0
        atol = 1.0;

        // 如果 zn 的实部或虚部的绝对值都小于或等于 ascle
        if (fmax(fabs(std::real(zn)), fabs(std::imag(zn))) <= ascle) {
            // 将 zn 缩放为 rtol 倍
            zn *= rtol;
            // 设置 atol 为 tol
            atol = tol;
        }

        // 将 zn 乘以 csgn
        zn *= csgn;

        // 将结果乘以 atol，并写回 cy[i-1]
        cy[i-1] = zn * atol;

        // csgn 乘以 zt，更新 csgn 的值
        csgn *= zt;
    }

    // 返回 nz 变量的值
    return nz;
// End of function besi()
}
    //                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
    //                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE
    //                            ACCURACY
    //                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
    //                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
    //                            CANCE BY ARGUMENT REDUCTION
    //                    IERR=5, ERROR              - NO COMPUTATION,
    //                            ALGORITHM TERMINATION CONDITION NOT MET
    //
    //***LONG DESCRIPTION
    //
    //         THE COMPUTATION IS CARRIED OUT BY THE POWER SERIES FOR
    //         SMALL CABS(Z), THE ASYMPTOTIC EXPANSION FOR LARGE CABS(Z),
    //         THE MILLER ALGORITHM NORMALIZED BY THE WRONSKIAN AND A
    //         NEUMANN SERIES FOR IMTERMEDIATE MAGNITUDES, AND THE
    //         UNIFORM ASYMPTOTIC EXPANSIONS FOR I(FNU,Z) AND J(FNU,Z)
    //         FOR LARGE ORDERS. BACKWARD RECURRENCE IS USED TO GENERATE
    //         SEQUENCES OR REDUCE ORDERS WHEN NECESSARY.
    //
    //         THE CALCULATIONS ABOVE ARE DONE IN THE RIGHT HALF PLANE AND
    //         CONTINUED INTO THE LEFT HALF PLANE BY THE FORMULA
    //
    //         I(FNU,Z*EXP(M*PI)) = EXP(M*PI*FNU)*I(FNU,Z)  REAL(Z).GT.0.0
    //                       M = +I OR -I,  I**2=-1
    //
    //         FOR NEGATIVE ORDERS,THE FORMULA
    //
    //              I(-FNU,Z) = I(FNU,Z) + (2/PI)*SIN(PI*FNU)*K(FNU,Z)
    //
    //         CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE
    //         THE FUNCTION CHANGES RADICALLY. WHEN FNU IS A LARGE POSITIVE
    //         INTEGER,THE MAGNITUDE OF I(-FNU,Z)=I(FNU,Z) IS A LARGE
    //         NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,
    //         K(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF
    //         TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY
    //         UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN
    //         OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,
    //         LARGE MEANS FNU.GT.CABS(Z).
    //
    //         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
    //         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
    //         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
    //         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
    //         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
    //         IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS
    //         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
    //         IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
    //         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
    //         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
    //         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
    //         RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
    //         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
    //         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
    //         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
    //         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
    //         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
    //         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
    //         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
    //
    //         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
    //         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
    //         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
    //         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
    //         ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
    //         ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
    //         CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
    //         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
    //         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
    //         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
    //         THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
    //         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
    //         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
    //         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
    //         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
    //         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
    //         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
    //         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
    //         OR -PI/2+P.
    //
    //***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
    //                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
    //                 COMMERCE, 1955.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 BY D. E. AMOS, SAND83-0083, MAY, 1983.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
    //
    //               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
    //                 1018, MAY, 1985
    //
    //               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
    //                 MATH. SOFTWARE, 1986
    //
    //***ROUTINES CALLED  ZBINU,I1MACH,D1MACH
    //***END PROLOGUE  ZBESI
    
    std::complex<double> csgn, zn;
    // 定义双精度变量和整型变量
    double aa, alim, arg, atol, ascle, az, bb, dig, elim, fn, fnul, rl, rtol,\
           r1m5, tol, xx, yy;
    int i, inu, k, k1, k2, nn, nz;
    // 定义圆周率 pi
    double pi = 3.14159265358979324;

    // 初始化 ierr 为 0，nz 为 0
    *ierr = 0;
    nz = 0;
    // 检查 fnu 是否小于 0，如果是则设置 ierr 为 1
    if (fnu < 0.0) { *ierr = 1; }
    // 检查 kode 是否不在 1 到 2 的范围内，如果是则设置 ierr 为 1
    if ((kode < 1) || (kode > 2)) { *ierr = 1; }
    // 检查 n 是否小于 1，如果是则设置 ierr 为 1
    if (n < 1) { *ierr = 1; }
    // 如果 ierr 不为 0，返回 nz（初始值为 0）
    if (*ierr != 0) { return nz; }
    // 获取 z 的实部和虚部
    xx = std::real(z);
    yy = std::imag(z);
    //
    //  SET PARAMETERS RELATED TO MACHINE CONSTANTS.
    //  TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
    //  ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
    //  EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL    AND
    //  EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
    //  UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
    //  RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
    //  DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
    //  FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
    //
    // 计算机器常数相关的参数
    tol = fmax(d1mach[3], 1e-18);
    k1 = i1mach[14];
    k2 = i1mach[15];
    r1m5 = d1mach[4];
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );
    elim = 2.303 * (k*r1m5 - 3.0);
    k1 = i1mach[13] - 1;
    aa = r1m5*k1;
    dig = fmin(aa, 18.0);
    aa *= 2.303;
    alim = elim + fmax(-aa, -41.45);
    rl = 1.2 * dig + 3.0;
    fnul = 10.0 + 6.0 * (dig - 3.0);
    //
    // TEST FOR PROPER RANGE
    //
    // 计算 az，即 z 的绝对值
    az = std::abs(z);
    // 计算 fn，即 fnu 加上 (n - 1)
    fn = fnu + (n - 1);
    // 计算 aa 和 bb 用于测试 proper range
    aa = 0.5 / tol;
    bb = i1mach[8]*0.5;
    aa = fmin(aa, bb);
    // 如果 az 大于 aa 或者 fn 大于 aa，则设置 ierr 为 4，返回 0
    if ((az > aa) || (fn > aa)) {
        *ierr = 4;
        return 0;
    }
    // 计算 aa 的平方根
    aa = sqrt(aa);
    // 如果 az 大于 aa，则设置 ierr 为 3
    if (az > aa) { *ierr = 3; }
    // 如果 fn 大于 aa，则设置 ierr 为 3
    if (fn > aa) { *ierr = 3; }
    // 如果 xx 大于 0，则返回 nz
    if (xx > 0.0) { return nz; }
    //
    // ANALYTIC CONTINUATION TO THE LEFT HALF PLANE
    //
    // 计算 nn，即 n 减去 nz
    nn = n - nz;
    // 如果 nn 等于 0，则返回 nz
    if (nn == 0) { return nz; }
    // 计算 rtol，即 1.0 / tol
    rtol = 1.0 / tol;
    ascle = d1mach[0]*rtol*1e3;
    // 循环处理 nn 次
    for (i = 1; i < (nn+1); i++)
    {
        // 获取 cy[i-1] 的值
        zn = cy[i-1];
        atol = 1.0;
        // 如果 zn 的实部和虚部的绝对值小于等于 ascle，则对 zn 进行缩放
        if (fmax(fabs(std::real(zn)), fabs(std::imag(zn))) <= ascle) {
            zn *= rtol;
            atol = tol;
        }
        // 更新 cy[i-1] 的值
        cy[i-1] = atol*(zn*csgn);
        // 更新 csgn 的值
        csgn = -csgn;
    }
    // 将 ierr 设置为 0
    *ierr = 0;
    // 返回 nz
    return nz;
//***BEGIN PROLOGUE  ZBESJ
//***DATE WRITTEN   830501   (YYMMDD)
//***REVISION DATE  890801   (YYMMDD)
//***CATEGORY NO.  B5K
//***KEYWORDS  J-BESSEL FUNCTION,BESSEL FUNCTION OF COMPLEX ARGUMENT,
//             BESSEL FUNCTION OF FIRST KIND
//***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
//***PURPOSE  TO COMPUTE THE J-BESSEL FUNCTION OF A COMPLEX ARGUMENT
//***DESCRIPTION
//
//                      ***A DOUBLE PRECISION ROUTINE***
//         ON KODE=1, CBESJ COMPUTES AN N MEMBER  SEQUENCE OF COMPLEX
//         BESSEL FUNCTIONS CY(I)=J(FNU+I-1,Z) FOR REAL, NONNEGATIVE
//         ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE
//         -PI.LT.ARG(Z).LE.PI. ON KODE=2, CBESJ RETURNS THE SCALED
//         FUNCTIONS
//
//         CY(I)=EXP(-ABS(Y))*J(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)
//
//         WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND
//         LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
//         ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS
//         (REF. 1).
//
//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//           ZR,ZI  - Z=std::complex<double>(ZR,ZI),  -PI.LT.ARG(Z).LE.PI
//           FNU    - ORDER OF INITIAL J FUNCTION, FNU.GE.0.0D0
//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//                    KODE= 1  RETURNS
//                             CY(I)=J(FNU+I-1,Z), I=1,...,N
//                        = 2  RETURNS
//                             CY(I)=J(FNU+I-1,Z)EXP(-ABS(Y)), I=1,...,N
//           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N.GE.1
//
//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//                    CY(I)=J(FNU+I-1,Z)  OR
//                    CY(I)=J(FNU+I-1,Z)EXP(-ABS(Y))  I=1,...,N
//                    DEPENDING ON KODE, Y=AIMAG(Z).
//           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,
//                    NZ= 0   , NORMAL RETURN
//                    NZ.GT.0 , LAST NZ COMPONENTS OF CY SET  ZERO DUE
//                              TO UNDERFLOW, CY(I)=std::complex<double>(0.0D0,0.0D0),
//                              I = N-NZ+1,...,N
//           IERR   - ERROR FLAG
//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//                    IERR=1, INPUT ERROR   - NO COMPUTATION
//                    IERR=2, OVERFLOW      - NO COMPUTATION, AIMAG(Z)
//                            TOO LARGE ON KODE=1
//                    IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
    //                            BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
    //                            REDUCTION PRODUCE LESS THAN HALF OF MACHINE
    //                            ACCURACY
    //                    IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
    //                            TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
    //                            CANCE BY ARGUMENT REDUCTION
    //                    IERR=5, ERROR              - NO COMPUTATION,
    //                            ALGORITHM TERMINATION CONDITION NOT MET
    //
    //***LONG DESCRIPTION
    //
    //         THE COMPUTATION IS CARRIED OUT BY THE FORMULA
    //
    //         J(FNU,Z)=EXP( FNU*PI*I/2)*I(FNU,-I*Z)    AIMAG(Z).GE.0.0
    //
    //         J(FNU,Z)=EXP(-FNU*PI*I/2)*I(FNU, I*Z)    AIMAG(Z).LT.0.0
    //
    //         WHERE I**2 = -1 AND I(FNU,Z) IS THE I BESSEL FUNCTION.
    //
    //         FOR NEGATIVE ORDERS,THE FORMULA
    //
    //              J(-FNU,Z) = J(FNU,Z)*COS(PI*FNU) - Y(FNU,Z)*SIN(PI*FNU)
    //
    //         CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE
    //         THE FUNCTION CHANGES RADICALLY. WHEN FNU IS A LARGE POSITIVE
    //         INTEGER,THE MAGNITUDE OF J(-FNU,Z)=J(FNU,Z)*COS(PI*FNU) IS A
    //         LARGE NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,
    //         Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF
    //         TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY
    //         UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN
    //         OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,
    //         LARGE MEANS FNU.GT.CABS(Z).
    //
    //         IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
    //         MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
    //         LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
    //         CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
    //         LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
    //         IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS
    //         DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
    //         IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
    //         LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
    //         MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
    //         INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
    //         RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
    //         ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
    //         ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
    //         ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
    //         THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
    //         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
    // Declare complex variables and double precision variables for computation
    std::complex<double> ci, csgn, zn;
    double aa, alim, arg, dig, elim, fnul, rl, r1, r1m5, r2,
        tol, yy, az, fn, bb, ascle, rtol, atol;
    int i, inu, inuh, ir, k1, k2, nl, nz, k;
    // Define the constant for half of pi
    double hpi = 1.570796326794896619;

    // Initialize error flag and count of non-zero results
    *ierr = 0;
    nz = 0;

    // Check for invalid input conditions and set error flag accordingly
    // fnu (order of Bessel function) should be non-negative
    if (fnu < 0.0) *ierr = 1;
    // kode (type of Bessel function) should be either 1 or 2
    if (kode < 1 || kode > 2) *ierr = 1;
    // n (number of points) should be positive
    if (n < 1) *ierr = 1;

    // If any error was detected, return nz (which is 0)
    if (*ierr != 0) return nz;

    // SET PARAMETERS RELATED TO MACHINE CONSTANTS.
    // TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
    // ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
    // EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL    AND
    // EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
    // UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
    // RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
    // DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
    // FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU.
    //
    tol = fmax(d1mach[3], 1e-18);
    k1 = i1mach[14];
    k2 = i1mach[15];
    r1m5 = d1mach[4];
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );
    elim = 2.303 * (k*r1m5 - 3.0);  // Compute ELIM based on machine constants and k.
    k1 = i1mach[13] - 1;
    aa = r1m5*k1;
    dig = fmin(aa, 18.0);  // Determine DIG, the number of decimal digits in TOL.
    aa *= 2.303;
    alim = elim + fmax(-aa, -41.45);  // Compute ALIM, the limit for avoiding overflow.
    fnul = 10.0 + 6.0 * (dig - 3.0);  // Calculate FNUL, the starting point for the asymptotic series.
    rl = 1.2*dig + 3.0;  // RL is the lower boundary for the asymptotic expansion.
    
    //
    // TEST FOR PROPER RANGE
    //
    yy = std::imag(z);
    az = std::abs(z);
    fn = fnu + (n - 1);
    
    aa = 0.5 / tol;
    bb = d1mach[1] * 0.5;
    aa = fmin(aa, bb);  // Determine AA, a threshold value for proper range testing.
    if ((az > aa) || (fn > aa)) {
        *ierr = 4;  // Set error code 4 and return if input values are out of proper range.
        return 0;
    }
    aa = sqrt(aa);
    
    if (az > aa) { *ierr = 3; }  // Set error code 3 if AZ exceeds AA.
    if (fn > aa) { *ierr = 3; }  // Set error code 3 if FN exceeds AA.
    
    //
    // CALCULATE CSGN = EXP(FNU*HPI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
    // WHEN FNU IS LARGE
    //
    ci.imag(1);
    inu = (int)fnu;
    inuh = inu / 2;
    ir = inu - 2*inuh;
    arg = (fnu - (inu - ir)) * hpi;
    r1 = cos(arg);
    r2 = sin(arg);
    csgn = std::complex<double>(r1, r2);  // Calculate CSGN as exp(FNU*HPI*I).
    if (inuh % 2 == 1) { csgn = -csgn; }  // Adjust CSGN based on the parity of INU.
    
    //
    // ZN IS IN THE RIGHT HALF PLANE
    //
    zn = -z * ci;
    if (yy < 0.0) {
        zn = -zn;
        csgn = conj(csgn);
        ci = conj(ci);  // Adjust ZN, CSGN, and CI if YY is negative.
    }
    
    nz = binu(zn, fnu, kode, n, cy, rl, fnul, tol, elim, alim);  // Compute BINU function.
    
    if (nz < 0) {
        if (nz == -2) { *ierr = 5; return 0; }  // Handle specific error cases.
        *ierr = 2;
        return 0;  // Set error code 2 and return if BINU function fails.
    }
    
    nl = n - nz;
    if (nl == 0) { return nz; }  // Return NZ if no further computations are needed.
    
    rtol = 1.0 / tol;
    ascle = d1mach[0]*rtol*1e3;
    
    for (i = 1; i < (nl+1); i++)
    {
        zn = cy[i-1];
        aa = std::real(zn);
        bb = std::imag(zn);
        atol = 1.0;
        if (fmax(fabs(aa), fabs(bb)) <= ascle) {
            zn *= rtol;
            atol = tol;  // Adjust ZN and ATOL for scaled arithmetic.
        }
        cy[i-1] = atol*(zn * csgn);  // Apply scaling factor to CY elements.
        csgn = csgn * ci;  // Update CSGN for the next iteration.
    }
    
    return nz;  // Return the number of elements computed.
inline int besk(
    std::complex<double> z,            // 输入：复数参数 z
    double fnu,                        // 输入：双精度浮点数，初始 K 函数的阶数 FNU
    int kode,                          // 输入：整数，标志量 KODE
    int n,                             // 输入：整数，序列的成员数量 N
    std::complex<double> *cy,          // 输出：复数数组指针，存储计算结果 CY
    int *ierr                          // 输出：整数指针，用于错误标志 IERR
) {

    //***BEGIN PROLOGUE  ZBESK
    //***DATE WRITTEN   830501   (YYMMDD)
    //***REVISION DATE  890801   (YYMMDD)
    //***CATEGORY NO.  B5K
    //***KEYWORDS  K-BESSEL FUNCTION,COMPLEX BESSEL FUNCTION,
    //             MODIFIED BESSEL FUNCTION OF THE SECOND KIND,
    //             BESSEL FUNCTION OF THE THIRD KIND
    //***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
    //***PURPOSE  TO COMPUTE K-BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //***DESCRIPTION
    //
    //                      ***A DOUBLE PRECISION ROUTINE***
    //
    //         ON KODE=1, CBESK COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
    //         BESSEL FUNCTIONS CY(J)=K(FNU+J-1,Z) FOR REAL, NONNEGATIVE
    //         ORDERS FNU+J-1, J=1,...,N AND COMPLEX Z.NE.std::complex<double>(0.0,0.0)
    //         IN THE CUT PLANE -PI.LT.ARG(Z).LE.PI. ON KODE=2, CBESK
    //         RETURNS THE SCALED K FUNCTIONS,
    //
    //         CY(J)=EXP(Z)*K(FNU+J-1,Z) , J=1,...,N,
    //
    //         WHICH REMOVE THE EXPONENTIAL BEHAVIOR IN BOTH THE LEFT AND
    //         RIGHT HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND
    //         NOTATION ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL
    //         FUNCTIONS (REF. 1).
    //
    //         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
    //           ZR,ZI  - Z=std::complex<double>(ZR,ZI), Z.NE.std::complex<double>(0.0D0,0.0D0),
    //                    -PI.LT.ARG(Z).LE.PI
    //           FNU    - ORDER OF INITIAL K FUNCTION, FNU.GE.0.0D0
    //           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N.GE.1
    //           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
    //                    KODE= 1  RETURNS
    //                             CY(I)=K(FNU+I-1,Z), I=1,...,N
    //                        = 2  RETURNS
    //                             CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N
    //
    //         OUTPUT     CYR,CYI ARE DOUBLE PRECISION
    //           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
    //                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
    //                    CY(I)=K(FNU+I-1,Z), I=1,...,N OR
    //                    CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N
    //                    DEPENDING ON KODE
    //           NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW.
    //                    NZ= 0   , NORMAL RETURN
    //                    NZ.GT.0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE
    //                              TO UNDERFLOW, CY(I)=std::complex<double>(0.0D0,0.0D0),
    //                              I=1,...,N WHEN X.GE.0.0. WHEN X.LT.0.0
    //                              NZ STATES ONLY THE NUMBER OF UNDERFLOWS
    //                              IN THE SEQUENCE.
    //
    //           IERR   - ERROR FLAG
    //                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
    //                    IERR=1, 输入错误   - 没有计算
    //                    IERR=2, 溢出      - 没有计算，FNU太大或CABS(Z)太小或两者兼有
    //                    IERR=3, CABS(Z)或FNU+N-1太大 - 计算完成，但由于参数减少导致损失超过机器精度的一半
    //                    IERR=4, CABS(Z)或FNU+N-1太大 - 完全由于参数减少导致损失所有有效数字
    //                    IERR=5, 错误      - 没有计算，未满足算法终止条件
    //
    //***详细描述
    //
    //         参考文献中的方程对于小的阶数DNU和DNU+1.0在右半平面X.GE.0.0中实现。
    //         前向递归生成更高阶。通过关系式K(FNU,Z*EXP(MP)) = EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)
    //         其中MP=MR*PI*I, MR=+1或-1，RE(Z).GT.0，I**2=-1，将K继续到左半平面。
    //
    //         对于大阶数，FNU.GT.FNUL，通过其统一渐近展开计算K函数。
    //
    //         对于负阶数，可以使用公式
    //
    //                       K(-FNU,Z) = K(FNU,Z)
    //
    //         CBESK假设有一个显著数字的双曲正弦函数SINH(X)可用。
    //
    //         在大多数复变量计算中，必须评估基本函数。当Z或FNU+N-1的幅度很大时，参数减少会导致
    //         损失的显著性。因此，如果任一者超过U1=SQRT(0.5/UR)，则可能会损失超过半精度，触发错误标志IERR=3，
    //         其中UR=DMAX1(D1MACH(4),1.0D-18)是双精度单位舍入，限制到18位有效数字。
    //         如果任一者大于U2=0.5/UR，则所有显著性都丢失，IERR=4。为了使用INT函数，参数必须进一步限制，
    //         不能超过最大机器整数，U3=I1MACH(9)。因此，Z和FNU+N-1的幅度由MIN(U2,U3)限制。
    //         在32位机器上，单精度算术中U1,U2和U3约为2.0E+3, 4.2E+6, 2.1E+9，在双精度算术中分别为
    //         1.3E+8, 1.8E+16, 2.1E+9。这使得U2和U3在各自的算术中是限制性的。这意味着可以预期
    //         一
    //         TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
    //         IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
    //         SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
    //
    //         THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
    //         BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
    //         ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
    //         SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
    //         ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
    //         ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
    //         CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
    //         HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
    //         ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
    //         SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
    //         THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
    //         0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
    //         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
    //         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
    //         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
    //         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
    //         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
    //         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
    //         OR -PI/2+P.
    //
    //***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
    //                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
    //                 COMMERCE, 1955.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 BY D. E. AMOS, SAND83-0083, MAY, 1983.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983.
    //
    //               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
    //                 1018, MAY, 1985
    //
    //               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
    //                 MATH. SOFTWARE, 1986
    //
    //***ROUTINES CALLED  ZACON,ZBKNU,ZBUNK,ZUOIK,AZABS,I1MACH,D1MACH
    //***END PROLOGUE  ZBESK
    
    // Initialize variables for the computation of Bessel functions
    double xx = std::real(z);   // Extract real part of complex number z
    double yy = std::imag(z);   // Extract imaginary part of complex number z
    double aa, alim, aln, arg, az, dig, elim, fn, fnul, rl, r1m5, tol, ufl, bb;
    int k, k1, k2, mr, nn, nuf, nw, nz;
    
    *ierr = 0;   // Initialize error flag to zero
    nz = 0;       // Initialize number of zeros found to zero
    
    // Check for special cases where errors need to be set
    if ((yy == 0.0) && (xx == 0.0)) { *ierr = 1; }   // z is zero
    if (fnu < 0.0) { *ierr = 1; }                   // fnu is negative
    if (kode < 1 || kode > 2) { *ierr = 1; }         // invalid value of kode
    if (n < 1) { *ierr = 1; }                       // n is less than 1
    // 检查错误码是否为0，如果不是则返回nz
    if (*ierr != 0) { return nz; }

    // 将n赋给nn
    nn = n;

    //
    // 设置与机器常数相关的参数。
    // TOL是单位舍入误差，限制为1.0E-18。
    // ELIM是指数上下溢限制。
    // EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL 和
    // EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL 是接近
    // 下溢和上溢限制的区间，在这些区间内执行缩放算术运算。
    // RL是大Z的渐近展开的下限。
    // DIG = TOL的十进制位数 = 10**(-DIG)。
    // FNUL是大FNU的渐近级数的下限。
    //

    // 计算TOL，使用d1mach[3]和1e-18中的较大值
    tol = fmax(d1mach[3], 1e-18);

    // 获取机器常数数组中的值
    k1 = i1mach[14];
    k2 = i1mach[15];
    r1m5 = d1mach[4];

    // 比较k1和k2的绝对值，选择较小的作为k的值
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );

    // 计算elim的值
    elim = 2.303 * (k*r1m5 - 3.0);

    // 更新k1的值
    k1 = i1mach[13] - 1;

    // 计算aa的值
    aa = r1m5 * k1;

    // 计算DIG的值，使用aa和18.0中的较小值
    dig = fmin(aa, 18.0);

    // 计算aa的值，用于计算alim
    aa *= 2.303;

    // 计算alim的值
    alim = elim + fmax(-aa, -41.45);

    // 计算fnul的值
    fnul = 10.0 + 6.0 * (dig - 3.0);

    // 计算rl的值
    rl = 1.2 * dig + 3.0;

    //
    // 检测是否在合适的范围内
    //

    // 计算az的绝对值
    az = std::abs(z);

    // 计算fn的值
    fn = fnu + (nn - 1);

    // 计算aa的值，用于后续比较
    aa = 0.5 / tol;

    // 计算bb的值，用于后续比较
    bb = i1mach[8] * 0.5;

    // 取aa和bb的较小值
    aa = fmin(aa, bb);

    // 检查az和fn是否超出aa的范围
    if ((az > aa) ||  (fn > aa)) {
        // 如果超出范围，则将错误码置为4，返回0
        *ierr = 4;
        return 0;
    }

    // 计算aa的平方根
    aa = sqrt(aa);

    // 如果az超出aa，则将错误码置为3
    if (az > aa) { *ierr = 3; }

    // 如果fn超出aa，则将错误码置为3
    if (fn > aa) { *ierr = 3; }

    //
    // 检查序列的最后一个成员是否溢出
    //

    // 计算ufl的值
    ufl = d1mach[0] * 1.0E+3;

    // 如果az小于ufl，则将错误码置为2，返回0
    if (az < ufl) {
        *ierr = 2;
        return 0;
    }
    // 检查 fnu 是否小于等于 fnul
    if (fnu <= fnul) {
        // 如果 fn 大于 1.0
        if (fn > 1.0) {
            // 如果 fn 小于等于 2.0
            if (fn <= 2.0) {
                // 如果 az 小于等于 tol，计算 arg 和 aln
                if (az <= tol) {
                    arg = 0.5 * az;
                    aln = -fn * log(arg);
                    // 如果 aln 大于 elim，则设置 ierr 为 2 并返回 0
                    if (aln > elim) { *ierr = 2; return 0; }
                }
                /* GO TO 60 */
            } else {
                // 调用 uoik 函数处理特定情况，更新 nn 和 nz
                nuf = uoik(z, fnu, kode, 2, nn, cy, tol, elim, alim);
                // 如果 nuf 小于 0，设置 ierr 为 2 并返回 0
                if (nuf < 0) { *ierr = 2; return 0; }
                nz += nuf;
                nn -= nuf;
                //
                // HERE NN=N OR NN=0 SINCE NUF=0,NN, OR -1 ON RETURN FROM CUOIK
                // IF NUF=NN, THEN CY(I)=CZERO FOR ALL I
                //
                if (nn == 0) {
                    // 如果 xx 小于 0.0，设置 ierr 为 2 并返回 0
                    if (xx < 0.0) { *ierr = 2; return 0; }
                    // 否则返回当前 nz
                    return nz;
                }
            }
        }

        /* 60 */
        // 如果 xx 大于等于 0.0
        if (xx >= 0.0) {
            //
            // RIGHT HALF PLANE COMPUTATION, REAL(Z) >= 0.
            //
            // 调用 bknu 函数进行计算，更新 ierr 或返回 nw
            nw = bknu(z, fnu, kode, nn, cy, tol, elim, alim);
            // 如果 nw 小于 0，根据 nw 的值设置 ierr 并返回相应的值
            if (nw < 0) {
                if (nw == -1) {
                    *ierr = 2;
                } else {
                    *ierr = 5;
                }
                return 0;
            }
            // 返回计算结果 nw
            return nw;
        }
        /* 70 */
        //
        // LEFT HALF PLANE COMPUTATION
        // PI/2 < ARG(Z) <= PI AND -PI < ARG(Z) < -PI/2.
        //
        // 如果 nz 不等于 0，设置 ierr 为 2 并返回 0
        if (nz != 0) { *ierr = 2; return 0; }
        // 根据 yy 的值设置 mr，调用 acon 函数计算结果 nw
        mr = 1;
        if (yy < 0.0) { mr = -1; }
        nw = acon(z, fnu, kode, mr, nn, cy, rl, fnul, tol, elim, alim);
        // 如果 nw 小于 0，根据 nw 的值设置 ierr 并返回相应的值
        if (nw < 0) {
            if (nw == -1) {
                *ierr = 2;
            } else {
                *ierr = 5;
            }
            return 0;
        }
        // 返回计算结果 nw
        return nw;
    }

    /* 80 */
    //
    // UNIFORM ASYMPTOTIC EXPANSIONS FOR FNU > FNUL
    //
    // 根据 xx 和 yy 的值设置 mr，调用 bunk 函数计算结果 nw
    mr = 0;
    if (xx < 0.0) {
        mr = 1;
        if (yy < 0.0) { mr = -1; }
    }
    nw = bunk(z, fnu, kode, mr, nn, cy, tol, elim, alim);
    // 如果 nw 小于 0，根据 nw 的值设置 ierr 并返回相应的值
    if (nw < 0) {
        if (nw == -1) {
            *ierr = 2;
        } else {
            *ierr = 5;
        }
        return 0;
    }
    // 更新 nz 并返回结果 nz
    nz += nw;
    return nz;
//***BEGIN PROLOGUE  ZBESY
//***DATE WRITTEN   830501   (YYMMDD)
//***REVISION DATE  890801   (YYMMDD)
//***CATEGORY NO.  B5K
//***KEYWORDS  Y-BESSEL FUNCTION,BESSEL FUNCTION OF COMPLEX ARGUMENT,
//             BESSEL FUNCTION OF SECOND KIND
//***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
//***PURPOSE  TO COMPUTE THE Y-BESSEL FUNCTION OF A COMPLEX ARGUMENT
//***DESCRIPTION
//
//                      ***A DOUBLE PRECISION ROUTINE***
//
//         ON KODE=1, CBESY COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
//         BESSEL FUNCTIONS CY(I)=Y(FNU+I-1,Z) FOR REAL, NONNEGATIVE
//         ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE
//         -PI.LT.ARG(Z).LE.PI. ON KODE=2, CBESY RETURNS THE SCALED
//         FUNCTIONS
//
//         CY(I)=EXP(-ABS(Y))*Y(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)
//
//         WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND
//         LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
//         ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS
//         (REF. 1).
//
//         INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//           ZR,ZI  - Z=std::complex<double>(ZR,ZI), Z.NE.std::complex<double>(0.0D0,0.0D0),
//                    -PI.LT.ARG(Z).LE.PI
//           FNU    - ORDER OF INITIAL Y FUNCTION, FNU.GE.0.0D0
//           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//                    KODE= 1  RETURNS
//                             CY(I)=Y(FNU+I-1,Z), I=1,...,N
//                        = 2  RETURNS
//                             CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y)), I=1,...,N
//                             WHERE Y=AIMAG(Z)
//           N      - NUMBER OF MEMBERS OF THE SEQUENCE, N.GE.1
//           CWRKR, - DOUBLE PRECISION WORK VECTORS OF DIMENSION AT
//           CWRKI    AT LEAST N
//
//         OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//           CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//                    CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//                    CY(I)=Y(FNU+I-1,Z)  OR
//                    CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y))  I=1,...,N
//                    DEPENDING ON KODE.
//           NZ     - NZ=0 , A NORMAL RETURN
//                    NZ.GT.0 , NZ COMPONENTS OF CY SET TO ZERO DUE TO
//                    UNDERFLOW (GENERALLY ON KODE=2)
//           IERR   - ERROR FLAG
//                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//                    IERR=1, INPUT ERROR   - NO COMPUTATION
//                    IERR=2, OVERFLOW      - NO COMPUTATION, FNU IS
//                            TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH
    // 根据不同的错误码（IERR）对计算过程中可能出现的问题进行说明和处理
    // IERR=3, 当复数的模CABS(Z)或者FNU+N-1的值很大时，计算虽然完成但由于参数减少导致的精度损失小于机器精度的一半
    // IERR=4, 当复数的模CABS(Z)或者FNU+N-1的值太大时，计算无法进行，因为参数减少导致全部的精度损失
    // IERR=5, 出现错误，算法终止条件未满足，无法进行计算
    //
    //***LONG DESCRIPTION
    //
    // 计算通过以下公式进行：
    //
    // Y(FNU,Z)=0.5*(H(1,FNU,Z)-H(2,FNU,Z))/I
    //
    // 其中I**2 = -1，Hankel贝塞尔函数H(1,FNU,Z)和H(2,FNU,Z)在CBESH中计算。
    //
    // 对于负阶数，可以使用以下公式：
    //
    // Y(-FNU,Z) = Y(FNU,Z)*COS(PI*FNU) + J(FNU,Z)*SIN(PI*FNU)
    //
    // 然而，对于接近一半奇整数的大阶数，函数会发生根本性变化。当FNU是大的正一半奇整数时，Y(-FNU,Z)=J(FNU,Z)*SIN(PI*FNU)的数量级是一个大的负十的幂次。但是当FNU不是一半奇整数时，Y(FNU,Z)在数量级上占主导地位，具有一个大的正十的幂次，第二项的最大减少程度是从系数的单位舍入误差开始的。因此，在一个大的一半奇整数的单位舍入误差内可以发生广泛的变化。这里，大意味着FNU.GT.CABS(Z)。
    //
    // 在大多数复数变量计算中，必须评估基本函数。当Z或者FNU+N-1的模很大时，通过参数减少导致的精度损失会发生。因此，如果其中一个超过了U1=SQRT(0.5/UR)，那么超过半精度的损失很可能发生，触发错误标志IERR=3，其中UR=DMAX1(D1MACH(4),1.0D-18)是双精度单位舍入误差，限制为18位精度。如果任一超过U2=0.5/UR，则所有的有效位数都会丢失，并且IERR=4。为了使用整数函数，参数必须进一步限制不超过最大的机器整数U3=I1MACH(9)。因此，Z和FNU+N-1的模由MIN(U2,U3)限制。在32位机器上，单精度算术中的U1、U2和U3大约是2.0E+3、4.2E+6和2.1E+9，在双精度算术中分别是1.3E+8、1.8E+16和2.1E+9。这使得U2和U3在各自的算术中是限制性的。这意味着可以预期
    // 初始化变量和数组
    std::complex<double> c1, c2, hci, st;  // 定义复数对象和临时变量
    double elim, exr, exi, ey, tay, xx, yy, ascle, rtol, atol, tol, aa, bb, r1m5;  // 定义各种数值型变量
    int i, k, k1, k2, nz, nz1, nz2;  // 定义整数型变量
    
    // 分配复数工作数组的内存
    std::complex<double>* cwrk = new std::complex<double>[n];
    
    // 从复数 z 中获取实部和虚部
    xx = std::real(z);
    yy = std::imag(z);
    
    // 初始化错误码和非零计数器
    *ierr = 0;
    nz = 0;
    
    // 检查特殊情况：z 是否为零
    if ((xx == 0.0) && (yy == 0.0)) { *ierr = 1; }
    
    // 检查特殊情况：fnu 是否小于零
    if (fnu < 0.0) { *ierr = 1; }
    // 如果输入参数 kode 不在 1 和 2 之间，则将 ierr 设置为 1
    if ((kode < 1) || (kode > 2)) { *ierr = 1; }
    // 如果输入参数 n 小于 1，则将 ierr 设置为 1
    if (n < 1) { *ierr = 1; }
    // 如果 ierr 不为 0，则返回当前 nz 的值
    if (*ierr != 0) { return nz; }

    // 初始化 hci 为复数 0.0 + 0.5i
    hci = std::complex<double>(0.0, 0.5);
    // 调用 besh 函数计算第一类贝塞尔函数值，并返回非零 nz1 和可能的 ierr
    nz1 = besh(z, fnu, kode, 1, n, cy, ierr);
    // 如果 ierr 不为 0 且不为 3，则返回 0
    if ((*ierr != 0) && (*ierr != 3)) { return 0; }

    // 调用 besh 函数计算第二类贝塞尔函数值，并返回非零 nz2 和可能的 ierr
    nz2 = besh(z, fnu, kode, 2, n, cwrk, ierr);
    // 如果 ierr 不为 0 且不为 3，则返回 0
    if ((*ierr != 0) && (*ierr != 3)) { return 0; }

    // 选择 nz1 和 nz2 中较小的值作为 nz
    nz = (nz1 > nz2 ? nz2 : nz1);
    // 如果 kode 不等于 2，则进行以下操作
    if (kode != 2) {
        // 对于每个 i 从 1 到 n，计算 cy[i-1] 的更新值
        for (i = 1; i < (n+1); i++)
        {
            cy[i-1] = hci * (cwrk[i-1] - cy[i-1]);
        }
        // 返回当前 nz 的值
        return nz;
    }

    // 计算 tol 的值，它是 d1mach[3] 和 1e-18 中较大的一个
    tol = fmax(d1mach[3], 1e-18);
    // 获取机器整数参数 k1 和 k2 的值
    k1 = i1mach[14];
    k2 = i1mach[15];
    // 获取机器浮点参数 r1m5 的值
    r1m5 = d1mach[4];
    // 计算 k 的值，它是 k1 和 k2 中绝对值较小的一个
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );
    //
    // ELIM IS THE APPROXIMATE EXPONENTIAL UNDER- AND OVERFLOW LIMIT
    //
    // 计算 elim 的值，它是一个大致的指数上下溢出限制
    elim = 2.303 * (k*r1m5 - 3.0);
    // 计算 exr 和 exi 的值，它们分别是 cos(xx) 和 sin(xx)
    exr = cos(xx);
    exi = sin(xx);
    // 初始化 ey 的值为 0.0
    ey = 0.0;
    // 计算 tay 的值为 fabs(yy + yy)
    tay = fabs(yy + yy);
    // 如果 tay 小于 elim，则计算 ey 的值为 exp(-tay)
    if (tay < elim) { ey = exp(-tay); }
    // 如果 yy 小于 0.0，则执行以下操作
    if (yy < 0.0) {
        /* 90 */
        // 设置 c1 和 c2 的值为复数
        c1 = std::complex<double>(exr, exi);
        c2 = ey*std::complex<double>(exr, -exi);
    } else {
        // 设置 c1 和 c2 的值为复数
        c1 = ey*std::complex<double>(exr, exi);
        c2 = std::complex<double>(exr, -exi);
    }

    // 初始化 nz 的值为 0
    nz = 0;
    // 计算 rtol 的值为 1.0 / tol
    rtol = 1.0 / tol;
    // 计算 ascle 的值为 1e3*d1mach[0]*rtol
    ascle = 1e3*d1mach[0]*rtol;
    // 对于每个 i 从 1 到 n，执行以下操作
    for (i = 1; i< (n+1); i++)
    {
        // 获取 cwrk[i-1] 的实部和虚部的值
        aa = std::real(cwrk[i-1]);
        bb = std::imag(cwrk[i-1]);
        // 初始化 atol 的值为 1.0
        atol = 1.0;
        // 如果 fabs(aa) 和 fabs(bb) 中较大的一个小于等于 ascle，则更新 aa 和 bb 的值，并将 atol 设置为 tol
        if (fmax(fabs(aa), fabs(bb)) <= ascle) {
            aa *= rtol;
            bb *= rtol;
            atol = tol;
        }

        // 计算 st 的值
        st = std::complex<double>(aa, bb) * c2 * atol;
        // 获取 cy[i-1] 的实部和虚部的值
        aa = std::real(cy[i-1]);
        bb = std::imag(cy[i-1]);
        // 初始化 atol 的值为 1.0
        atol = 1.0;
        // 如果 fabs(aa) 和 fabs(bb) 中较大的一个小于等于 ascle，则更新 aa 和 bb 的值，并将 atol 设置为 tol
        if (fmax(fabs(aa), fabs(bb)) <= ascle) {
            aa *= rtol;
            bb *= rtol;
            atol = tol;
        }

        // 更新 st 的值
        st -= std::complex<double>(aa, bb) * c1 * atol;
        // 更新 cy[i-1] 的值
        cy[i-1] = st*hci;
        // 如果 st 等于 0.0 且 ey 等于 0.0，则增加 nz 的值
        if ((st == 0.0) && (ey == 0.0)) { nz += 1; }
    }

    // 释放 cwrk 数组的内存
    delete [] cwrk;
    // 返回当前 nz 的值
    return nz;
    //***BEGIN PROLOGUE  ZBINU
    //***REFER TO  ZBESH,ZBESI,ZBESJ,ZBESK,ZAIRY,ZBIRY
    //
    //     ZBINU COMPUTES THE I FUNCTION IN THE RIGHT HALF Z PLANE
    //
    //***ROUTINES CALLED  AZABS,ZASYI,ZBUNI,ZMLRI,ZSERI,ZUOIK,ZWRSK
    //***END PROLOGUE  ZBINU

    // 定义复数数组cw，长度为2，初始化为{0.}
    std::complex<double> cw[2] = { 0. };
    // 定义变量az，表示复数z的绝对值
    double az;
    // 定义变量dfnu，表示修正参数fnu加上n-1
    double dfnu;
    // 定义整型变量inw、nlast、nn、nui、nw、nz，并初始化nz为0
    int inw, nlast, nn, nui, nw, nz;

    // 计算复数z的绝对值
    az = std::abs(z);
    // 将n的值赋给nn
    nn = n;
    // 计算dfnu
    dfnu = fnu + n - 1;
    
    // 检查是否满足进入级数展开的条件
    if ((az <= 2.) || (az*az*0.25 <= (dfnu + 1.0))) {
        /* GOTO 10 */
        // 调用seri函数进行级数展开计算
        nw = seri(z,fnu, kode, n, cy, tol, elim, alim);
        // 计算nw的绝对值并赋给inw
        inw = abs(nw);
        // nz增加inw的值
        nz += inw;
        // nn减去inw
        nn -= inw;
        // 如果nn为0，则返回nz
        if (nn == 0) { return nz; }
        // 如果nw大于等于0，则返回nz
        if (nw >= 0) { return nz; }
        // 更新dfnu的值
        dfnu = fnu + nn - 1;
    }
    /* GOTO 30 conditions*/

    // 如果复数z的绝对值小于rl，进行以下操作
    //
    // ASYMPTOTIC EXPANSION FOR LARGE Z
    //
    if (az < rl) {
        /* 40 */
        // 如果dfnu小于等于1.0，采用Miller算法和级数归一化处理
        if (dfnu <= 1.0) {
            /* 70 */
            //
            // MILLER ALGORITHM NORMALIZED BY THE SERIES
            //
            // 调用mlri函数进行Miller算法的计算
            nw = mlri(z, fnu, kode, n, cy, tol);
            // 如果nw小于0，则设置nz为-1；如果nw为-2，则设置nz为-2
            if (nw < 0) {
                nz = -1;
                if (nw == -2) {
                    nz = -2;
                }
                return nz;
            }
            return nz;
        }
        /* GO TO 50 */
    } else {
        // 如果dfnu小于等于1.0或者复数z的绝对值的两倍大于dfnu的平方，采用大z的渐近展开式处理
        if ((dfnu <= 1.0) || (az+az >= dfnu*dfnu)) {
            /* 30 */
            //
            // ASYMPTOTIC EXPANSION FOR LARGE Z
            //
            // 调用asyi函数进行大z的渐近展开式计算
            nw = asyi(z, fnu, kode, n, cy, rl, tol, elim, alim);
            // 如果nw小于0，则设置nz为-1；如果nw为-2，则设置nz为-2
            if (nw < 0) {
                nz = -1;
                if (nw == -2) {
                    nz = -2;
                }
                return nz;
            }
            return nz;
        }
        /* GO TO 50 */
    }
    /* 50 */
    //
    // OVERFLOW AND UNDERFLOW TEST ON I SEQUENCE FOR MILLER ALGORITHM
    //
    // 调用uoik函数进行Miller算法的I序列的溢出和下溢测试
    nw = uoik(z, fnu, kode, 1, nn, cy, tol, elim, alim);
    // 如果nw小于0，则设置nz为-1；如果nw为-2，则设置nz为-2
    if (nw < 0) {
        nz = -1;
        if (nw == -2) { nz = -2; }
        return nz;
    }
    // nz增加nw的值
    nz += nw;
    // nn减去nw
    nn -= nw;
    // 如果nn为0，则返回nz
    if (nn == 0) { return nz; }
    // 更新dfnu的值
    dfnu = fnu + (nn -1);
    /* GOTO 110s handled here */
    // 如果dfnu大于fnul或者复数z的绝对值大于fnul，进行以下操作
    //
    // INCREMENT FNU+NN-1 UP TO FNUL, COMPUTE AND RECUR BACKWARD
    //
    // 计算并递归向后计算增加到fnul的fnu+nn-1
    nui = (int)(fnul-dfnu) + 1;
    nui = (nui > 0 ? nui : 0);
    // 调用buni函数进行增加到fnul的计算
    nw = buni(z, fnu, kode, nn, cy, nui, &nlast, fnul, tol, elim, alim);
    // 如果nw小于0，则设置nz为-1；如果nw为-2，则设置nz为-2
    if (nw < 0) {
        nz = -1;
        if (nw == -2) { nz = -2; }
        return nz;
    }
    // nz增加nw的值
    nz += nw;
    // 如果nlast为0，则返回nz
    if (nlast == 0) { return nz; }
    // 更新nn的值
    nn = nlast;
    /* 60 */
    // 如果 az <= rl，则执行以下操作
    if (az <= rl) {
        /* 70 */
        // 调用 mlri 函数计算，返回值存入 nw
        nw = mlri(z, fnu, kode, n, cy, tol);
        // 如果 nw < 0，设置 nz 为 -1；如果 nw 等于 -2，设置 nz 为 -2，并返回 nz
        if (nw < 0) {
            nz = -1;
            if (nw == -2) { nz = -2; }
            return nz;
        }
        // 返回当前值 nz
        return nz;
    }
    /* 80 */
    //
    // MILLER ALGORITHM NORMALIZED BY THE WRONSKIAN
    //
    //
    // OVERFLOW TEST ON K FUNCTIONS USED IN WRONSKIAN
    //
    // 调用 uoik 函数进行 K 函数的溢出测试，返回值存入 nw
    nw = uoik(z, fnu, kode, 2, 2, cw, tol, elim, alim);
    // 如果 nw < 0，将数组 cy 的每个元素设置为 0，并返回 nz
    if (nw < 0) {
        nz = nn;
        /* 90 */
        for (int i=0; i < nn; i++) { cy[i] = 0.0; }
        return nz;
    }
    /* 100 */
    // 如果 nw > 0，返回 -1
    if (nw > 0) {
        return -1;
    }
    // 调用 wrsk 函数计算 Wronskian，并返回 nw
    nw = wrsk(z, fnu, kode, nn, cy, cw, tol, elim, alim);
    // 如果 nw < 0，设置 nz 为 -1；如果 nw 等于 -2，设置 nz 为 -2，并返回 nz
    if (nw < 0) {
        nz = -1;
        if (nw == -2) {
            nz = -2;
        }
        return nz;
    }
    // 返回当前值 nz
    return nz;
}

// 定义 biry 函数，计算复数 z 的 Airy 函数 BI(z) 或其导数 DBI(z)/DZ
inline std::complex<double> biry(
    std::complex<double> z,   // 输入参数，复数 z
    int id,                   // 输入参数，导数的阶数，id=0 或 id=1
    int kode,                 // 输入参数，缩放选项的指示符，kode=1 或 kode=2
    int *ierr                 // 输出参数，错误标志
) {

    //***BEGIN PROLOGUE  ZBIRY
    //***DATE WRITTEN   830501   (YYMMDD)
    //***REVISION DATE  890801   (YYMMDD)
    //***CATEGORY NO.  B5K
    //***KEYWORDS  AIRY FUNCTION,BESSEL FUNCTIONS OF ORDER ONE THIRD
    //***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
    //***PURPOSE  TO COMPUTE AIRY FUNCTIONS BI(Z) AND DBI(Z) FOR COMPLEX Z
    //***DESCRIPTION
    //
    //                      ***A DOUBLE PRECISION ROUTINE***
    //         ON KODE=1, CBIRY COMPUTES THE COMPLEX AIRY FUNCTION BI(Z) OR
    //         ITS DERIVATIVE DBI(Z)/DZ ON ID=0 OR ID=1 RESPECTIVELY. ON
    //         KODE=2, A SCALING OPTION CEXP(-AXZTA)*BI(Z) OR CEXP(-AXZTA)*
    //         DBI(Z)/DZ IS PROVIDED TO REMOVE THE EXPONENTIAL BEHAVIOR IN
    //         BOTH THE LEFT AND RIGHT HALF PLANES WHERE
    //         ZTA=(2/3)*Z*CSQRT(Z)=std::complex<double>(XZTA,YZTA) AND AXZTA=ABS(XZTA).
    //         DEFINITIONS AND NOTATION ARE FOUND IN THE NBS HANDBOOK OF
    //         MATHEMATICAL FUNCTIONS (REF. 1).
    //
    //         INPUT      ZR,ZI ARE DOUBLE PRECISION
    //           ZR,ZI  - Z=std::complex<double>(ZR,ZI)
    //           ID     - ORDER OF DERIVATIVE, ID=0 OR ID=1
    //           KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
    //                    KODE= 1  RETURNS
    //                             BI=BI(Z)                 ON ID=0 OR
    //                             BI=DBI(Z)/DZ             ON ID=1
    //                        = 2  RETURNS
    //                             BI=CEXP(-AXZTA)*BI(Z)     ON ID=0 OR
    //                             BI=CEXP(-AXZTA)*DBI(Z)/DZ ON ID=1 WHERE
    //                             ZTA=(2/3)*Z*CSQRT(Z)=std::complex<double>(XZTA,YZTA)
    //                             AND AXZTA=ABS(XZTA)
    //
    //         OUTPUT     BIR,BII ARE DOUBLE PRECISION
    //           BIR,BII- COMPLEX ANSWER DEPENDING ON THE CHOICES FOR ID AND
    //                    KODE
    //           IERR   - ERROR FLAG
    //                    IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
    //                    IERR=1, INPUT ERROR   - NO COMPUTATION
    //                    IERR=2, OVERFLOW      - NO COMPUTATION, REAL(Z)
    //                            TOO LARGE ON KODE=1
    //                    IERR=3, CABS(Z) LARGE      - COMPUTATION COMPLETED
    //                            LOSSES OF SIGNIFCANCE BY ARGUMENT REDUCTION
    //                            PRODUCE LESS THAN HALF OF MACHINE ACCURACY
    //                    IERR=4, CABS(Z) TOO LARGE  - NO COMPUTATION
    //                            COMPLETE LOSS OF ACCURACY BY ARGUMENT
    //                            REDUCTION
    //                    IERR=5, ERROR              - NO COMPUTATION,
    //                            ALGORITHM TERMINATION CONDITION NOT MET
    //
    //***LONG DESCRIPTION
    //
    // BI AND DBI ARE COMPUTED FOR CABS(Z).GT.1.0 FROM THE I BESSEL
    // FUNCTIONS BY
    //
    //       BI(Z)=C*SQRT(Z)*( I(-1/3,ZTA) + I(1/3,ZTA) )
    //       DBI(Z)=C *  Z  * ( I(-2/3,ZTA) + I(2/3,ZTA) )
    //                     C=1.0/SQRT(3.0)
    //                   ZTA=(2/3)*Z**(3/2)
    //
    // WITH THE POWER SERIES FOR CABS(Z).LE.1.0.
    //
    // IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
    // MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z IS LARGE, LOSSES
    // OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR. CONSEQUENTLY, IF
    // THE MAGNITUDE OF ZETA=(2/3)*Z**1.5 EXCEEDS U1=SQRT(0.5/UR),
    // THEN LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR
    // FLAG IERR=3 IS TRIGGERED WHERE UR=DMAX1(D1MACH(4),1.0D-18) IS
    // DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
    // ALSO, IF THE MAGNITUDE OF ZETA IS LARGER THAN U2=0.5/UR, THEN
    // ALL SIGNIFICANCE IS LOST AND IERR=4. IN ORDER TO USE THE INT
    // FUNCTION, ZETA MUST BE FURTHER RESTRICTED NOT TO EXCEED THE
    // LARGEST INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF ZETA
    // MUST BE RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2,
    // AND U3 ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE
    // PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE
    // PRECISION ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMIT-
    // ING IN THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT THE MAG-
    // NITUDE OF Z CANNOT EXCEED 3.1E+4 IN SINGLE AND 2.1E+6 IN
    // DOUBLE PRECISION ARITHMETIC. THIS ALSO MEANS THAT ONE CAN
    // EXPECT TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES,
    // NO DIGITS IN SINGLE PRECISION AND ONLY 7 DIGITS IN DOUBLE
    // PRECISION ARITHMETIC. SIMILAR CONSIDERATIONS HOLD FOR OTHER
    // MACHINES.
    //
    // THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
    // BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
    // ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
    // SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
    // ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
    // ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
    // CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
    // HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
    // ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
    // SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
    // THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
    // 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
    //         THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
    //         COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
    //         BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
    //         COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
    //         MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
    //         THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
    //         OR -PI/2+P.
    //
    //***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
    //                 AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
    //                 COMMERCE, 1955.
    //
    //               COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
    //
    //               A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
    //                 1018, MAY, 1985
    //
    //               A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
    //                 ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
    //                 MATH. SOFTWARE, 1986
    //
    //***ROUTINES CALLED  ZBINU,AZABS,ZDIV,AZSQRT,D1MACH,I1MACH
    //***END PROLOGUE  ZBIRY
    
    // 声明复数和双精度浮点数变量
    std::complex<double> bi, csq, s1, s2, trm1, trm2, zta, z3;
    double aa, ad, ak, alim, atrm, az, az3, bb, bk, ck, dig, dk, d1, d2,\
           elim, fid, fmr, fnu, fnul, rl, r1m5, sfac, tol, zi, zr;
    int k, k1, k2, nz;
    
    // 初始化复数数组
    std::complex<double> cy[2] = { 0.0 };
    
    // 初始化常数和变量
    double tth = 2. / 3.;
    double c1 = 0.614926627446000735150922369;    /* 1/( 3**(1/6) Gamma(2/3)) */
    double c2 = 0.448288357353826357914823710;    /* 3**(1/6) / Gamma(1/3)    */
    double coef = 0.577350269189625764509148780;  /* sqrt( 1 / 3)             */
    double pi = 3.141592653589793238462643383;
    
    // 设置初始错误码和非零计数
    *ierr = 0;
    nz = 0;
    
    // 检查输入参数的合法性
    if ((id < 0) || (id > 1)) { *ierr= 1; }
    if ((kode < 1) || (kode > 2)) { *ierr= 1; }
    
    // 若有错误则返回
    if ( *ierr != 0) { return 0.0;}
    
    // 计算输入复数的绝对值并设置容错值
    az = std::abs(z);
    tol = fmax(d1mach[3], 1e-18);
    fid = id;
    if (az <= 1.0) {
        //
        // ABS(Z) <= 1 的幂级数展开
        //
        s1 = 1.0;
        s2 = 1.0;
        if (az < tol) {
            // 当 abs(z) 小于 tol 时，使用简化公式计算并返回结果
            aa = c1*(1.0 - fid) + fid*c2;
            return aa;
        }
        aa = az*az;
        if (aa >= tol/az) {
            // 使用幂级数展开计算函数值
            trm1 = 1.0;
            trm2 = 1.0;
            atrm = 1.0;
            z3 = z*z*z;
            az3 = az * aa;
            ak = 2.0 + fid;
            bk = 3.0 - fid - fid;
            ck = 4.0 - fid;
            dk = 3.0 + fid + fid;
            d1 = ak * dk;
            d2 = bk * ck;
            ad = fmin(d1,d2);
            ak = 24.0 + 9.0*fid;
            bk = 30.0 - 9.0*fid;
            for (k = 1; k < 26; k++)
            {
                // 循环计算幂级数展开的各项并累加
                trm1 *= z3/d1;
                s1 += trm1;
                trm2 *= z3/d2;
                s2 += trm2;
                atrm *= az3 / ad;
                d1 += ak;
                d2 += bk;
                ad = fmin(d1, d2);
                // 检查是否达到精度要求，若是则退出循环
                if (atrm < tol*ad) { break; }
                ak += 18.0;
                bk += 18.0;
            }
        /* 30 */
        }
        /* 40 */
        if (id != 1) {
            // id 不等于 1 的情况下计算另一种情况的函数值
            bi = s1*c1 + z*s2*c2;
            if (kode == 1) { return bi; }
            zta = z*std::sqrt(z)*tth;
            aa = -fabs(std::real(zta));
            bi *= exp(aa);
            return bi;
        }
        /* 50 */
        // id 等于 1 的情况下计算函数值的另一种情况
        bi = s2*c2;
        if (az > tol) { bi += z*z*s1*c1/(1.0 + fid ); }
        if (kode == 1) { return bi; }
        zta = z*std::sqrt(z)*tth;
        aa = -fabs(std::real(zta));
        bi *= exp(aa);
        return bi;
    }
    /* 70 */
    //
    // ABS(Z) > 1.0 的情况
    //
    fnu = (1.0 + fid) / 3.0;
    //
    // 设置与机器常数相关的参数
    // tol 是近似的舍入误差限制在 1.0E-18
    // elim 是指数上下溢限制的近似值
    // rl 是大 Z 情况下渐近展开的下限
    // dig 是 tol 的十进制位数 = 10**(-dig)
    // fnul 是大 FNU 情况下渐近级数的下限
    //
    k1 = i1mach[14];
    k2 = i1mach[15];
    r1m5 = d1mach[4];
    k = ( abs(k1) > abs(k2) ? abs(k2) : abs(k1) );
    elim = 2.303 * (k*r1m5 - 3.0);
    k1 = i1mach[13] - 1;
    aa = r1m5*k1;
    dig = fmin(aa, 18.0);
    aa *= 2.303;
    alim = elim + fmax(-aa, -41.45);
    rl = 1.2*dig + 3.0;
    fnul = 10.0 + 6.0*(dig - 3.0);
    //
    // 检查范围
    //
    aa = 0.5 / tol;
    bb = i1mach[8] * 0.5;
    aa = fmin(aa, bb);
    aa = pow(aa, tth);
    if (az > aa) { *ierr = 4; return 0.0; }
    aa = sqrt(aa);
    if (az > aa) { *ierr = 3; }
    csq = std::sqrt(z);
    zta = z*csq*tth;
    //
    // 当实部小于零时，尤其是当虚部较小时，RE(ZTA) <= 0
    //
    sfac = 1.0;
    zi = std::imag(z);
    // 计算复数 z 的实部
    zr = std::real(z);
    // 计算复数 zta 的虚部
    ak = std::imag(zta);
    // 如果 z 的实部小于 0
    if (zr < 0.0) {
        // 获取 zta 的实部
        bk = std::real(zta);
        // 计算 ck 为负的 bk 的绝对值
        ck = -fabs(bk);
        // 更新 zta 为一个新的复数对象，实部为 ck，虚部为 ak
        zta = std::complex<double>(ck, ak);
    }
    /* 80 */
    // 如果 zi 为 0 且 z 的实部小于等于 0
    if ((zi == 0.0) && (zr <= 0.0)) { zta = std::complex<double>(0.0, ak); }
    /* 90 */
    // 获取 zta 的实部
    aa = std::real(zta);
    // 如果 kode 不等于 2
    if (kode != 2) {
        //
        // 溢出测试
        //
        // 计算 aa 的绝对值
        bb = fabs(aa);
        // 如果 bb 大于等于 alim
        if (bb >= alim) {
            // bb 加上 0.25*log(az)
            bb += 0.25*log(az);
            // 设置 sfac 为 tol
            sfac = tol;
            // 如果 bb 大于 elim，则设置 ierr 为 2 并返回 0.0
            if (bb > elim) { *ierr = 2; return 0.0; }
        }
    }
    /* 100 */
    // 初始化 fmr 为 0.0
    fmr = 0.0;
    // 如果 aa 小于 0.0 或 z 的实部小于等于 0.0
    if ((aa < 0.0) || (zr <= 0.0)) {
        // 设置 fmr 为 pi
        fmr = pi;
        // 如果 zi 小于 0.0，则设置 fmr 为 -pi
        if (zi < 0.0) { fmr = -pi; }
        // 更新 zta 为 -zta
        zta = -zta;
    }
    /* 110 */
    //
    // AA=FACTOR FOR ANALYTIC CONTINUATION OF I(FNU,ZTA)
    // KODE=2 RETURNS EXP(-ABS(XZTA))*I(FNU,ZTA) FROM CBINU
    //
    // 调用 binu 函数计算，返回值存储在 nz 中
    nz = binu(zta, fnu, kode, 1, cy, rl, fnul, tol, elim, alim);
    // 如果 nz 小于 0
    if (nz < 0) {
        // 如果 nz 等于 -1，则设置 ierr 为 2；否则设置 ierr 为 5
        if (nz == -1) {
            *ierr = 2;
        } else {
            *ierr = 5;
        }
        // 返回 0.0
        return 0.0;
    }
    // 计算 aa 为 fmr 乘以 fnu
    aa = fmr * fnu;
    // 设置 z3 为 sfac
    z3 = sfac;
    // 计算 s1 为 cy[0] 乘以复数(cos(aa), sin(aa)) 乘以 z3
    s1 = cy[0] * std::complex<double>(cos(aa), sin(aa)) * z3;
    // 更新 fnu 为 (2.0 - fid) / 3.0
    fnu = (2.0 - fid) / 3.0;
    // 再次调用 binu 函数计算，返回值存储在 nz 中
    nz = binu(zta, fnu, kode, 2, cy, rl, fnul, tol, elim, alim);
    // 将 cy[0] 和 cy[1] 各自乘以 z3
    cy[0] *= z3;
    cy[1] *= z3;
    //
    // BACKWARD RECUR ONE STEP FOR ORDERS -1/3 OR -2/3
    //
    // 计算 s2 为 cy[0] 乘以 (fnu+fnu) 除以 zta 再加上 cy[1]
    s2 = cy[0] * (fnu+fnu) / zta + cy[1];
    // 计算 aa 为 fmr 乘以 (fnu - 1.0)
    aa = fmr * (fnu - 1.0);
    // 计算 s1 为 (s1 加上 s2 乘以复数(cos(aa), sin(aa))) 乘以 coef
    s1 = (s1 + s2 * std::complex<double>(cos(aa), sin(aa))) * coef;
    // 如果 id 不等于 1
    if (id != 1) {
        // s1 乘以 csq
        s1 *= csq;
        // 设置 bi 为 s1 除以 sfac
        bi = s1 / sfac;
        // 返回 bi
        return bi;
    }
    /* 120 */
    // s1 乘以 z
    s1 *= z;
    // 设置 bi 为 s1 除以 sfac
    bi = s1 / sfac;
    // 返回 bi
    return bi;
    }

    //***BEGIN PROLOGUE  ZBKNU
    //***REFER TO  ZBESI,ZBESK,ZAIRY,ZBESH
    //
    //     ZBKNU COMPUTES THE K BESSEL FUNCTION IN THE RIGHT HALF Z PLANE.
    //
    //***ROUTINES CALLED  DGAMLN,I1MACH,D1MACH,ZKSCL,ZSHCH,ZUCHK,AZABS,ZDIV,
    //                    AZEXP,AZLOG,ZMLT,AZSQRT
    //***END PROLOGUE  ZBKNU

    // 声明复数和双精度变量
    std::complex<double> cch, ck, coef, crsc, cs, cscl, csh, cz,\
                   f, fmu, p, pt, p1, p2, q, rz, smu, st, s1, s2, zd;
    double aa, ak, ascle, a1, a2, bb, bk, caz, dnu, dnu2, etest, fc, fhs,\
           fk, fks, g1, g2, p2i, p2m, p2r, rk, s, tm, t1, t2, xx, yy,\
           elm, xd, yd, alas, as;
    int iflag, inu, k, kflag, kk, koded, j, ic, inub, i = 1;
    std::complex<double> cy[2];

    // 定义常量和数组
    int kmax = 30;
    double r1 = 2.;
    double pi = 3.14159265358979324;
    double rthpi = 1.25331413731550025;
    double spi = 1.90985931710274403;
    double hpi = 1.57079632679489662;
    double fpi = 1.89769999331517738;
    double tth = 2. / 3.;
    double cc[8] = {
        5.77215664901532861e-01, -4.20026350340952355e-02,
       -4.21977345555443367e-02,  7.21894324666309954e-03,
       -2.15241674114950973e-04, -2.01348547807882387e-05,
        1.13302723198169588e-06,  6.11609510448141582e-09
    };

    // 从复数 z 中提取实部和虚部
    xx = std::real(z);
    yy = std::imag(z);
    // 计算 z 的模
    caz = std::abs(z);
    // 设置比例因子
    cscl = 1. / tol;
    crsc = tol;
    // 设置复数数组和常数数组
    std::complex<double> css[3] = {cscl, 1., crsc};
    std::complex<double> csr[3] = {crsc, 1., cscl};
    double bry[3] = {1e3*d1mach[0]/tol, tol/(1e3*d1mach[0]), d1mach[1]};
    // 初始化变量
    int nz = 0;
    iflag = 0;
    koded = kode;
    // 计算 rz
    rz = 2. / z;
    // 计算整数部分
    inu = (int)(fnu + 0.5);
    dnu = fnu - inu;
    // 用于消除初始化警告的定义
    s1 = 0.0;
    s2 = 0.0;
    ck = 0.0;
    dnu2 = 0.0;
}
//
// IFLAG=0 MEANS NO UNDERFLOW OCCURRED
// IFLAG=1 MEANS AN UNDERFLOW OCCURRED- COMPUTATION PROCEEDS WITH
// KODED=2 AND A TEST FOR ON SCALE VALUES IS MADE DURING FORWARD
// RECURSION
//
// 程序标志解释和条件设置
coef = rthpi / std::sqrt(z);
kflag = 2;
if (koded != 2) {
    if (xx > alim) {
        koded = 2;
        iflag = 1;
        kflag = 2;
    } else {
        a1 = exp(-xx)*std::real(css[kflag-1]);
        pt = a1*std::complex<double>(cos(yy), -sin(yy));
        coef *= pt;
    }
}

if (fabs(dnu) == 0.5) {
    s1 = coef;
    s2 = coef;
    goto L100;
}
//
//    MILLER ALGORITHM FOR ABS(Z) > R1
//
ak = fabs(cos(pi*dnu));
if (ak == 0.) {
    s1 = coef;
    s2 = coef;
    goto L100;
}
fhs = fabs(0.25 - dnu2);
if (fhs == 0.) {
    s1 = coef;
    s2 = coef;
    goto L100;
}
//
// COMPUTE R2=F(E). IF ABS(Z) >= R2, USE FORWARD RECURRENCE TO
// DETERMINE THE BACKWARD INDEX K. R2=F(E) IS A STRAIGHT LINE ON


注释部分解释了每行代码的作用，包括变量的定义、常量的设定以及程序标志的解释和条件设置。
    // 根据公式计算 t1 值，确保 12 <= t1 <= 60
    t1 = (i1mach[13] - 1)*d1mach[4]*(log(10)/log(2));
    t1 = fmin(fmax(t1, 12.0), 60.0);

    // 计算 t2
    t2 = tth * t1 - 6.0;

    // 如果 xx 等于 0，则将 t1 设置为半π，否则计算 arctan(yy/xx) 的绝对值赋给 t1
    if (xx == 0.) {
        t1 = hpi;
    } else {
        t1 = fabs(atan(yy/xx));
    }

    // 如果 t2 <= caz，则进入 ABS(Z) >= R2 的前向递归循环
    if (t2 <= caz) {
        // 计算 etest
        etest = ak / (pi*caz*tol);
        fk = 1.0;

        // 如果 etest < 1.0，则跳转到标号 L80
        if (etest < 1.0) { goto L80; }

        fks = 2.0;
        rk = caz + caz + 2.0;
        a1 = 0.0;
        a2 = 1.0;

        // 开始进行前向递归循环
        for (i = 1; i < (kmax+1); i++)
        {
            ak = fhs / fks;
            bk = rk / (fk + 1.0);
            tm = a2;
            a2 = bk * a2 - ak * a1;
            a1 = tm;
            rk += 2.;
            fks += fk + fk + 2.0;
            fhs += fk + fk;
            fk += 1.0;
            tm = fabs(a2)*fk;

            // 如果 etest < tm，则跳出循环，否则继续下一轮
            if (etest < tm) {
                /* goto 160 */
                break;
            }

            // 如果已经达到 kmax 仍未跳出循环，则返回 -2
            if (i == kmax) {
                /* Didn't break so goes to 310 */
                return -2;
            }
        }

        /* 160 */
        // 计算 fk 的值
        fk += spi * t1 * sqrt(t2/caz);
        fhs = fabs(0.25 - dnu2);
    } else {
        //
        // 当 t2 > caz 时，计算 ABS(Z) < R2 的情况下的后向指数 k
        //
        a2 = sqrt(caz);
        ak *= fpi / (tol*sqrt(a2));
        aa = 3.0 * t1 / (1.0 + caz);
        bb = 14.7 * t1 / (28.0 + caz);

        // 根据给定公式计算 ak 的值
        ak = (log(ak) + caz*cos(aa)/(1.0  + 0.008*caz)) / cos(bb);
        fk = 0.12125 * ak * ak / caz + 1.5;
    }

L80:
    //
    // MILLER 算法的后向递归循环
    //
    k = (int)fk;
    fk = (double)k;
    fks = fk * fk;
    p1 = 0.0;
    p2 = tol;
    cs = p2;

    // 开始进行后向递归循环
    for (i=1; i < (k+1); i++)
    {
        a1 = fks - fk;
        a2 = (fks+fk) / (a1+fhs);
        rk = 2.0 / (fk + 1.);
        t1 = (fk + xx) * rk;
        t2 = yy * rk;
        pt = p2;
        p2 = (p2 * std::complex<double>(t1, t2) - p1) * a2;
        p1 = pt;
        cs += p2;
        fks = a1 - fk + 1.0;
        fk -= 1.0;
    }

    //
    // 计算 (P2/CS)=(P2/ABS(CS))*(CONJG(CS)/ABS(CS)) 以获取更好的缩放
    //
    tm = std::abs(cs);
    pt = 1.0 / tm;
    s1 = pt * p2;
    cs = conj(cs) * pt;
    s1 *= coef * cs;

    // 如果 inu <= 0 并且 n <= 1，则进行特定条件下的处理
    if ((inu <= 0) && (n <= 1)) {
        zd = z;

        // 如果 iflag 等于 1，则跳转到标号 L190，否则跳转到 L130
        if (iflag == 1) { goto L190; }
        goto L130;
    }

    //
    // 计算 P1/P2=(P1/ABS(P2)*CONJG(P2)/ABS(P2) 以进行进一步的缩放
    //
    tm = std::abs(p2);
    pt = 1.0 / tm;
    p1 = pt * p1;
    p2 = conj(p2) * pt;
    pt = p1 * p2;
    s2 = s1 * (1. + (dnu+0.5 - pt)/z);

    //
    // 在 KFLAG=1 或 KFLAG=3 时，在三项递推关系上进行前向递归，以在指数极端情况下进行缩放
    //
L100:
    ck = (dnu + 1.)*rz;

    // 如果 n 等于 1，则减小 inu
    if (n == 1) { inu -= 1; }

    // 如果 inu 小于等于 0，则根据 n 的值进行不同的处理
    if (inu <= 0) {
        if (n <= 1) { s1 = s2; }
        zd = z;

        // 如果 iflag 等于 1，则跳转到标号 L190，否则跳转到 L130
        if (iflag == 1) { goto L190; }
        goto L130;
    }

    // 设置 inub 的值为 1，如果 iflag 等于 1，则跳转到标号 L160
    inub = 1;
    if (iflag == 1) { goto L160; }
L110:
    // 初始化变量，根据数组索引 kflag-1 取值
    p1 = csr[kflag-1];
    // 初始化变量，根据数组索引 kflag-1 取值
    ascle = bry[kflag-1];
    // 循环，从 inub 到 inu+1
    for (i = inub; i < inu+1; i++)
    {
        // 保存 s2 的值到临时变量 st
        st = s2;
        // 计算新的 s2 值
        s2 = ck*s2 + s1;
        // 更新 s1 为之前的 s2 值
        s1 = st;
        // 更新 ck 的值
        ck += rz;
        // 如果 kflag 小于 3，则执行以下代码块
        if (kflag < 3) {
            // 计算 p2 的值
            p2 = s2*p1;
            // 计算 p2 的模，并取其实部和虚部的绝对值中的较大值
            p2m = fmax(fabs(std::real(p2)), fabs(std::imag(p2)));
            // 如果 p2 的模大于 ascle
            if (p2m > ascle) {
                // 更新 kflag
                kflag += 1;
                // 更新 ascle
                ascle = bry[kflag-1];
                // 更新 s1
                s1 *= p1;
                // 更新 s2
                s2 = p2;
                // 更新 s1 和 s2
                s1 *= css[kflag-1];
                s2 *= css[kflag-1];
                // 更新 p1
                p1 = csr[kflag-1];
            }
        }
    }
    // 如果 n 等于 1，则将 s2 赋值给 s1
    if (n == 1) { s1 = s2; }

L130:
    // 计算 y[0] 的值
    y[0] = s1 * csr[kflag-1];
    // 如果 n 等于 1，则返回 nz
    if (n == 1) { return nz; }
    // 计算 y[1] 的值
    y[1] = s2 * csr[kflag-1];
    // 如果 n 等于 2，则返回 nz
    if (n == 2) { return nz; }
    // 初始化 kk 的值为 2
    kk = 2;
L140:
    // kk 自增
    kk += 1;
    // 如果 kk 大于 n，则返回 nz
    if (kk > n) { return nz; }
    // 根据数组索引 kflag-1 取值
    p1 = csr[kflag-1];
    // 根据数组索引 kflag-1 取值
    ascle = bry[kflag-1];
    // 循环，从 kk 到 n+1
    for (i = kk; i < (n+1); i++)
    {
        // 保存 s2 的值到 p2
        p2 = s2;
        // 计算新的 s2 值
        s2 = ck*s2 + s1;
        // 更新 s1 为之前的 p2 值
        s1 = p2;
        // 更新 ck 的值
        ck += rz;
        // 计算 p2 的值
        p2 = s2*p1;
        // 将 p2 的值赋给 y[i-1]
        y[i-1] = p2;
        // 如果 kflag 小于 3，则执行以下代码块
        if (kflag < 3) {
            // 计算 p2 的模，并取其实部和虚部的绝对值中的较大值
            p2m = fmax(fabs(std::real(p2)), fabs(std::imag(p2)));
            // 如果 p2 的模大于 ascle
            if (p2m > ascle) {
                // 更新 kflag
                kflag += 1;
                // 更新 ascle
                ascle = bry[kflag-1];
                // 更新 s1
                s1 *= p1;
                // 更新 s2
                s2 = p2;
                // 更新 s1 和 s2
                s1 *= css[kflag-1];
                s2 *= css[kflag-1];
                // 更新 p1
                p1 = csr[kflag-1];
            }
        }
    }
    // 返回 nz
    return nz;

//
// IFLAG=1 CASES, FORWARD RECURRENCE ON SCALED VALUES ON UNDERFLOW
//

L160:
    // 计算 elm 的值
    elm = exp(-elim);
    // 初始化 ascle 的值为 bry[0]
    ascle = bry[0];
    // 初始化 zd, xd, yd 的值
    zd = z;
    xd = xx;
    yd = yy;
    // 初始化 ic 的值为 -1，j 的值为 2
    ic = -1;
    j = 2;
    // 循环，从 1 到 inu+1
    for (i = 1; i < (inu+1); i++)
    {
        // 保存 s2 的值到临时变量 st
        st = s2;
        // 计算新的 s2 值
        s2 = ck*s2 + s1;
        // 更新 s1 为之前的 st 值
        s1 = st;
        // 更新 ck 的值
        ck += rz;
        // 计算 s2 的绝对值
        as = std::abs(s2);
        // 计算 s2 的自然对数绝对值
        alas = log(as);
        // 计算 p2r 的值
        p2r = alas - xd;
        // 如果 p2r 大于等于 -elim，则执行以下代码块
        if (p2r >= -elim) {
            // 计算 p2 的值
            p2 = -zd + std::log(s2);
            // 计算 p2 的实部和虚部
            p2r = std::real(p2);
            p2i = std::imag(p2);
            // 计算 p2m 的值
            p2m = exp(p2r) / tol;
            // 构建复数 p1，并调用 uchk 函数检查其是否满足条件
            p1 = p2m * std::complex<double>(cos(p2i), sin(p2i));
            if (!(uchk(p1, ascle, tol))) {
                // 更新 j
                j = 3 - j;
                // 将 p1 赋给 cy[j-1]
                cy[j-1] = p1;
                // 如果 ic 等于 i-1，则跳转到 L180 标签
                if (ic == i-1) { goto L180; }
                // 更新 ic
                ic = i;
                // 继续循环
                continue;
            }
        }
        // 如果 alas 大于等于 0.5 * elim，则执行以下代码块
        if (alas >= 0.5 * elim) {
            // 更新 xd 的值
            xd -= elim;
            // 更新 s1 和 s2
            s1 *= elm;
            s2 *= elm;
            // 更新 zd 的值
            zd = std::complex<double>(xd, yd);
        }
    }
    // 如果 n 等于 1，则将 s2 赋值给 s1
    if (n == 1) { s1 = s2; }
    // 跳转到 L190 标签
    goto L190;
L180:
    // 更新 kflag 的值为 1
    kflag = 1;
    // 更新 inub 的值为 i + 1
    inub = i + 1;
    // 将 cy[j-1] 赋给 s2
    s2 = cy[j-1];
    // 更新 j
    j = 3 - j;
    // 将 cy[j-1] 赋给 s1
    s1 = cy[j-1];
    // 如果 inub 小于等于 inu，则跳转到 L110 标签
    if (inub <= inu) { goto L110; }
    // 如果 n 等于 1，则将 s2 赋值给 s1
    if (n == 1) { s1 = s2; }
    // 跳转到 L130 标签
    goto L130;
L190:
    // 计算 y[0] 的值
    y[0] = s1;
    // 如果 n 不等于 1，则计算 y[1] 的值
    if (n != 1) { y[1] = s2; }
    // 初始化 ascle 的值为 bry[0]
    ascle = b
    # 计算变量 ck 的值，等于变量 t2 乘以变量 rz
    ck = t2 * rz;
    # 将变量 kflag 设为 1，表示某种标志位的设置
    kflag = 1;
    # 跳转到标签 L140 处继续执行程序
    goto L140;
}

inline int buni(
    std::complex<double> z,            // 输入：复数 z
    double fnu,                        // 输入：函数的阶数 fnu
    int kode,                          // 输入：控制标志
    int n,                             // 输入：整数 n
    std::complex<double> *y,           // 输出：复数数组 y
    int nui,                           // 输入：整数 nui
    int *nlast,                        // 输入/输出：整数指针 nlast
    double fnul,                       // 输入：double 值 fnul
    double tol,                        // 输入：double 值 tol
    double elim,                       // 输入：double 值 elim
    double alim                        // 输入：double 值 alim
) {

    //***BEGIN PROLOGUE  ZBUNI
    //***REFER TO  ZBESI,ZBESK
    //
    //     ZBUNI COMPUTES THE I BESSEL FUNCTION FOR LARGE CABS(Z).GT.
    //     FNUL AND FNU+N-1.LT.FNUL. THE ORDER IS INCREASED FROM
    //     FNU+N-1 GREATER THAN FNUL BY ADDING NUI AND COMPUTING
    //     ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR I(FNU,Z)
    //     ON IFORM=1 AND THE EXPANSION FOR J(FNU,Z) ON IFORM=2
    //
    //***ROUTINES CALLED  ZUNI1,ZUNI2,AZABS,D1MACH
    //***END PROLOGUE  ZBUNI

    std::complex<double> cscl, cscr, rz, st, s1, s2;
    double ax, ay, dfnu, fnui, gnu, xx, yy, ascle, str, sti, stm;
    int i, iflag, iform, k, nl, nw, nz;
    std::complex<double> cy[2] = { 0.0 };
    double bry[3] = { 0.0 };

    nz = 0;                             // 初始化 nz 为 0
    xx = std::real(z);                  // 获取 z 的实部
    yy = std::imag(z);                  // 获取 z 的虚部
    ax = fabs(xx) + sqrt(3.);           // 计算 |xx| + sqrt(3)
    ay = fabs(yy);                      // 计算 |yy|
    iform = 1;                          // 初始化 iform 为 1
    if (ay > ax) {                      // 根据条件判断 iform 的值
        iform = 2;
    }
    if (nui == 0) {                     // 如果 nui 为 0
        if (iform != 2) {               // 根据 iform 的值调用相应的函数 uni1 或 uni2
            uni1(z, fnu, kode, n, y, &nw, nlast, fnul, tol, elim, alim);
        } else {
            uni2(z, fnu, kode, n, y, &nw, nlast, fnul, tol, elim, alim);
        }
        if (nw < 0) {                   // 如果 nw 小于 0，设置 nz 为 -1 或 -2，并返回 nz
            nz = -1;
            if (nw == -2) { nz = -2; }
            return nz;
        }
        return nw;                      // 返回 nw
    }

    fnui = nui;                         // 将 nui 赋值给 fnui
    dfnu = fnu + (n - 1);               // 计算 dfnu
    gnu = dfnu + fnui;                  // 计算 gnu
    if (iform != 2) {                   // 根据 iform 的值调用 uni1 或 uni2
        // ASYMPTOTIC EXPANSION FOR I(FNU,Z) FOR LARGE FNU APPLIED IN
        // -PI/3 <= ARG(Z) <= PI/3
        uni1(z, gnu, kode, 2, cy, &nw, nlast, fnul, tol, elim, alim);
    } else {
        uni2(z, gnu, kode, 2, cy, &nw, nlast, fnul, tol, elim, alim);
    }
    // 检查 nw 是否大于等于 0
    if (nw >= 0) {
        // 如果 nw 不等于 0，则更新 nlast，返回 nz
        if (nw != 0) { *nlast = n; return nz; }
        
        // 计算 cy[0] 的绝对值
        ay = std::abs(cy[0]);
        
        //
        // 向后递推缩放，定义了但未使用的常数数组 bry[3]
        //
        
        // 根据机器精度 d1mach[0] 和容差 tol 计算常数 bry[0], bry[1], bry[2]
        bry[0] = 1e3 * d1mach[0] / tol;
        bry[1] = tol / 1e3 * d1mach[0];
        bry[2] = bry[1];
        
        // 设置标志 iflag 和缩放常数 ascle
        iflag = 2;
        ascle = bry[1];
        
        // 设置 ax 和 cscl 的初值
        ax = 1.0;
        cscl = ax;
        
        // 根据 ay 的大小更新 iflag、ascle、ax 和 cscl
        if (ay <= bry[0]) {
            iflag = 1;
            ascle = bry[0];
            ax = 1.0 / tol;
            cscl = ax;
        } else {
            if (ay >= bry[1]) {
                iflag = 3;
                ascle = bry[2];
                ax = tol;
                cscl = ax;
            }
        }
        
        // 计算 cscr 和 s1, s2
        ay = 1.0 / ax;
        cscr = ay;
        s1 = cy[1] * cscl;
        s2 = cy[0] * cscl;
        
        // 计算 rz
        rz = 2.0 / z;
        
        // 循环计算 y[n-1] 的值
        for (i = 1; i < (nui + 1); i++)
        {
            st = s2;
            s2 = (dfnu + fnui) * rz * st + s1;
            s1 = st;
            fnui -= 1.0;
            
            // 如果 iflag < 3，则根据 ascle 进行缩放和调整
            if (iflag < 3) {
                st = s2 * cscr;
                str = fabs(std::real(st));
                sti = fabs(std::imag(st));
                stm = fmax(str, sti);
                if (stm > ascle) {
                    iflag += 1;
                    ascle = bry[iflag - 1];
                    s1 *= cscr;
                    s2 = st;
                    ax *= tol;
                    ay = 1.0 / ax;
                    cscl = ax;
                    cscr = ay;
                    s1 *= cscl;
                    s2 *= cscl;
                }
            }
        }
        
        // 将计算结果赋给 y[n-1]
        y[n - 1] = s2 * cscr;
        
        // 如果 n 等于 1，则直接返回 nz
        if (n == 1) { return nz; }
        
        // 循环计算 y[k-1] 的值，k 从 nl 递减到 0
        nl = n - 1;
        fnui = nl;
        k = nl;
        for (i = 0; i < (nl + 1); i++)
        {
            st = s2;
            s2 = (fnu + fnui) * rz * s2 + s1;
            s1 = st;
            st = s2 * cscr;
            y[k - 1] = st;
            fnui -= 1.0;
            k -= 1;
            
            // 如果 iflag < 3，则根据 ascle 进行缩放和调整
            if (iflag < 3) {
                st = s2 * cscr;
                str = fabs(std::real(st));
                sti = fabs(std::imag(st));
                stm = fmax(str, sti);
                if (stm > ascle) {
                    iflag += 1;
                    ascle = bry[iflag - 1];
                    s1 *= cscr;
                    s2 = st;
                    ax *= tol;
                    ay = 1.0 / ax;
                    cscl = ax;
                    cscr = ay;
                    s1 *= cscl;
                    s2 *= cscl;
                }
            }
        }
        
        // 返回 nz
        return nz;
    }
    
    // 如果 nw 不大于等于 0，则设置 nz 为 -1
    nz = -1;
    
    // 如果 nw 等于 -2，则将 nz 设置为 -2
    if (nw == -2) { nz = -2; }
    
    // 返回 nz
    return nz;
}

inline int bunk(
    std::complex<double> z,
    double fnu,
    int kode,
    int mr,
    int n,
    std::complex<double> *y,
    double tol,
    double elim,
    double alim
) {

    //***BEGIN PROLOGUE  ZBUNK
    //***REFER TO  ZBESK,ZBESH
    //
    //     ZBUNK COMPUTES THE K BESSEL FUNCTION FOR FNU.GT.FNUL.
    //     ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR K(FNU,Z)
    //     IN ZUNK1 AND THE EXPANSION FOR H(2,FNU,Z) IN ZUNK2
    //
    //***ROUTINES CALLED  ZUNK1,ZUNK2
    //***END PROLOGUE  ZBUNK

    double ax, ay;

    int nz = 0;
    // 计算复数 z 的实部和虚部的绝对值乘积的1.7321倍，存储在 ax 中
    ax = fabs(std::real(z)) * 1.7321;
    // 计算复数 z 的虚部的绝对值，存储在 ay 中
    ay = fabs(std::imag(z));

    if (ay <= ax) {
        //
        // Asymptotic expansion for K(FNU,Z) for large FNU applied in
        // -PI/3 <= ARG(Z) <= PI/3
        //
        // 调用 ZUNK1 函数，计算大 FNU 下 K Bessel 函数的渐近展开
        nz = unk1(z, fnu, kode, mr, n, y, tol, elim, alim);
    } else {
        //
        // Asymptotic expansion for H(2, FNU, Z*EXP(M*HPI)) for large FNU
        // applied in PI/3 < ABS(ARG(Z)) <= PI/2 where M = +I or -I and HPI = PI/2
        //
        // 调用 ZUNK2 函数，计算大 FNU 下 H(2) Hankel 函数的渐近展开
        nz = unk2(z, fnu, kode, mr, n, y, tol, elim, alim);
    }
    // 返回计算得到的结果数量 nz
    return nz;
}


inline double gamln(double z) {

    //***BEGIN PROLOGUE  DGAMLN
    //***DATE WRITTEN   830501   (YYMMDD)
    //***REVISION DATE  830501   (YYMMDD)
    //***CATEGORY NO.  B5F
    //***KEYWORDS  GAMMA FUNCTION,LOGARITHM OF GAMMA FUNCTION
    //***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
    //***PURPOSE  TO COMPUTE THE LOGARITHM OF THE GAMMA FUNCTION
    //***DESCRIPTION
    //
    //               **** A DOUBLE PRECISION ROUTINE ****
    //         DGAMLN COMPUTES THE NATURAL LOG OF THE GAMMA FUNCTION FOR
    //         Z.GT.0.  THE ASYMPTOTIC EXPANSION IS USED TO GENERATE VALUES
    //         GREATER THAN ZMIN WHICH ARE ADJUSTED BY THE RECURSION
    //         G(Z+1)=Z*G(Z) FOR Z.LE.ZMIN.  THE FUNCTION WAS MADE AS
    //         PORTABLE AS POSSIBLE BY COMPUTIMG ZMIN FROM THE NUMBER OF BASE
    //         10 DIGITS IN A WORD, RLN=AMAX1(-ALOG10(R1MACH(4)),0.5E-18)
    //         LIMITED TO 18 DIGITS OF (RELATIVE) ACCURACY.
    //
    //         SINCE INTEGER ARGUMENTS ARE COMMON, A TABLE LOOK UP ON 100
    //         VALUES IS USED FOR SPEED OF EXECUTION.
    //
    //     DESCRIPTION OF ARGUMENTS
    //
    //         INPUT      Z IS D0UBLE PRECISION
    //           Z      - ARGUMENT, Z.GT.0.0D0
    //
    //         OUTPUT      DGAMLN IS DOUBLE PRECISION
    //           DGAMLN  - NATURAL LOG OF THE GAMMA FUNCTION AT Z.NE.0.0D0
    //           IERR    - ERROR FLAG
    //                     IERR=0, NORMAL RETURN, COMPUTATION COMPLETED
    //                     IERR=1, Z.LE.0.0D0,    NO COMPUTATION
    //
    //
    //***REFERENCES  COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
    //                 BY D. E. AMOS, SAND83-0083, MAY, 1983.
    //***ROUTINES CALLED  I1MACH,D1MACH
    //***END PROLOGUE  DGAMLN

    int i1m, mz;
    double fln, fz, rln, s, tlg, trm, tst, t1, wdtol, zdmy, zinc, zm, zmin, zp, zsq;
    // 常数定义，对数值为 LN(2*PI)
    const double con = 1.83787706640934548;  /* LN(2*PI) */
    // 初始化整型变量 nz 为 0
    int nz = 0;
    // 如果 z 大于 0.0，则进入条件语句块
    if (z > 0.0) {
        // 如果 z 小于等于 101.0，则进入条件语句块
        if (z <= 101.0) {
            // 将 z 转换为整型并赋值给 nz
            nz = (int)z;
            // 计算 fz，即 z 减去 nz 的小数部分
            fz = z - nz;
            // 如果 fz 小于等于 0.0，则进入条件语句块
            if (fz <= 0.0) {
                // 如果 nz 小于等于 100，则返回预先计算好的 dgamln_gln[nz-1]
                if (nz <= 100) {
                    return dgamln_gln[nz-1];
                }
            }
        }
        // 计算 wdtol，为 d1mach[3] 和 1e-18 中的较大值
        wdtol = fmax(d1mach[3], 1e-18);
        // 获取机器数值 i1mach[13]
        i1m = i1mach[13];
        // 计算 rln，为 d1mach[4] 乘以 i1m
        rln = d1mach[4]*i1m;
        // 计算 fln，为 rln 与 20.0 中的较大值，再与 3.0 中的较小值，再减去 3.0
        fln = fmax(fmin(rln, 20.), 3.0) - 3.0;
        // 计算 zm，为 1.8 加上 0.3875 乘以 fln
        zm = 1.8 + 0.3875*fln;
        // 计算 mz，为 zm 的整数部分加 1
        mz = ((int)zm) + 1;
        // 设置 zmin 为 mz
        zmin = mz;
        // 将 zdmy 初始化为 z
        zdmy = z;
        // 初始化 zinc 为 0.0
        zinc = 0.0;
        // 如果 z 小于 zmin，则执行以下操作
        if (z < zmin){
            // 计算 zinc，为 zmin 减去 nz
            zinc = zmin - nz;
            // 将 zdmy 更新为 z 加上 zinc
            zdmy = z + zinc;
        }
        // 计算 zp，为 1.0 除以 zdmy
        zp = 1. / zdmy;
        // 初始化 s 为 dgamln_cf[0] 乘以 zp
        s = dgamln_cf[0]*zp;
        // 如果 zp 大于等于 wdtol，则执行以下循环
        if (zp >= wdtol) {
            // 计算 zsq，为 zp 的平方
            zsq = zp*zp;
            // 计算 tst，为 t1 乘以 wdtol
            tst = t1*wdtol;
            // 循环计算和项，直到满足条件退出循环
            for (int i = 2; i < 23; i++)
            {
                zp *= zsq;
                trm = dgamln_cf[i-1] * zp;
                // 如果 trm 的绝对值小于 tst，则退出循环
                if (fabs(trm) < tst) { break; }
                // 将 trm 加到 s 上
                s += trm;
            }
        }

        // 如果 zinc 等于 0.0，则执行以下操作
        if (zinc == 0.) {
            // 计算 tlg，为 z 的自然对数
            tlg = log(z);
            // 返回计算结果，包括 z*(tlg-1.0)、0.5*(con - tlg) 和 s
            return z*(tlg-1.0) + 0.5*(con - tlg) + s;
        }
        // 初始化 zp 为 1.0
        zp = 1.0;
        // 将 nz 更新为 zinc 的整数部分
        nz = (int)zinc;
        // 循环计算 zp 的乘积
        for (int i = 0; i < nz; i++)
        {
            zp *= (z + i);
        }
        // 计算 tlg，为 zdmy 的自然对数
        tlg = log(zdmy);
        // 返回计算结果，包括 zdmy*(tlg-1.0)、-log(zp)、0.5*(con-tlg) 和 s
        return zdmy*(tlg-1.0) - log(zp) + 0.5*(con-tlg) + s;
    }
    // 如果 z 小于等于 0.0，则返回 NaN
    // 零或负数参数
    return NAN;
    //***BEGIN PROLOGUE  ZMLRI
    //***REFER TO  ZBESI,ZBESK
    //
    //     ZMLRI COMPUTES THE I BESSEL FUNCTION FOR RE(Z).GE.0.0 BY THE
    //     MILLER ALGORITHM NORMALIZED BY A NEUMANN SERIES.
    //
    //***ROUTINES CALLED  DGAMLN,D1MACH,AZABS,AZEXP,AZLOG,ZMLT
    //***END PROLOGUE  ZMLRI

    // 声明和初始化变量
    std::complex<double> ck, cnorm, pt, p1, p2, rz, sum;
    double ack, ak, ap, at, az, bk, fkap, fkk, flam, fnf, rho,\
           rho2, scle, tfnf, tst, x;
    int i, iaz, ifnu, inu, itime, k, kk, km, m, nz;

    // 计算尺度参数 scle
    scle = d1mach[0] / tol;
    nz = 0;

    // 计算输入复数 z 的绝对值和实部
    az = std::abs(z);
    x = std::real(z);

    // 计算整数部分的绝对值
    iaz = (int)az;

    // 将 fnu 和 n 转换为整数
    ifnu = (int)fnu;
    inu = ifnu + n - 1;

    // 计算 at 并初始化 ck 和 rz
    at = iaz + 1;
    ck = at / z;
    rz = 2. / z;
    p1 = 0.;
    p2 = 1.;

    // 计算系数 ack 和初始化 rho 和 tst
    ack = (at + 1.0) / az;
    rho = ack + sqrt(ack*ack - 1.);
    rho2 = rho * rho;
    tst = (rho2 + rho2) / ((rho2 - 1.0)*(rho - 1.0));
    tst /= tol;

    //
    // COMPUTE RELATIVE TRUNCATION ERROR INDEX FOR SERIES
    //

    // 计算截断误差的相对指标
    ak = at;
    i = 1;
    for (i = 1; i < 81; i++ )
    {
        pt = p2;
        p2 = p1 - ck * p2;
        p1 = pt;
        ck += rz;
        ap = std::abs(p2);
        if (ap > tst*ak*ak) { break; }
        ak += 1.0;
        if (i == 80) {
            /* Exhausted loop without break */
            return -2;
        }
    }
    i += 1;
    k = 0;

    // 如果 inu >= iaz，计算 ratios 的截断误差
    if (inu >= iaz) {

        //
        // COMPUTE RELATIVE TRUNCATION ERROR FOR RATIOS
        //

        // 重新初始化 p1 和 p2
        p1 = 0.0;
        p2 = 1.0;
        at = inu + 1;
        ck = at / z;
        ack = at / az;
        tst = sqrt(ack / tol);
        itime = 1;
        k = 1;
        for (k = 1; k < 81; k++ )
        {
            pt = p2;
            p2 = p1 - ck * p2;
            p1 = pt;
            ck += rz;
            ap = std::abs(p2);
            if (ap >= tst) {
                if (itime == 2) { break; }
                ack = std::abs(ck);
                flam = ack + sqrt(ack*ack - 1.0);
                fkap = ap / std::abs(p1);
                rho = fmin(flam, fkap);
                tst *= sqrt(rho / (rho*rho - 1.0));
                itime = 2;
            }
            if (k == 80) {
                /* Exhausted loop without break */
                return -2;
            }
        }
    }

    //
    // BACKWARD RECURRENCE AND SUM NORMALIZING RELATION
    //

    // 后向递推和求和归一化关系
    k += 1;
    kk = fmax(i+iaz, k+inu);
    fkk = kk;
    p1 = 0.0;

    //
    // SCALE P2 AND SUM BY SCLE
    //

    // 尺度化 p2 并乘以 scle 求和
    p2 = scle;
    fnf = fnu - ifnu;
    tfnf = fnf + fnf;
    bk = gamln(fkk + tfnf + 1.0) - gamln(fkk + 1.0) - gamln(tfnf + 1.0);
    bk = exp(bk);
    sum = 0.;
    km = kk - inu;
    for (i = 1; i < (km+1); i++)
    {
        pt = p2;
        p2 = p1 + (fkk + fnf)*rz*p2;
        p1 = pt;
        ak = 1. - tfnf / (fkk+tfnf);
        ack = bk*ak;
        sum += (ack + bk)*p1;
        bk = ack;
        fkk -= 1.;
    }

    // 将结果存入数组 y 的第 n-1 个元素
    y[n-1] = p2;
    // 如果 n 不等于 1，则执行以下循环
    if (n != 1) {
        // 从 i=2 开始到 i=n 的循环
        for (i = 2; i < (n+1); i++)
        {
            pt = p2;  // 保存 p2 的值到 pt
            p2 = p1 + (fkk + fnf)*rz*p2;  // 更新 p2 的值
            p1 = pt;  // p1 更新为之前的 pt 值
            ak = 1. - tfnf / (fkk+tfnf);  // 计算 ak 的值
            ack = bk*ak;  // 计算 ack 的值
            sum += (ack + bk)*p1;  // 更新 sum 的值
            bk = ack;  // 更新 bk 的值
            fkk -= 1.;  // fkk 减1
            m = n - i + 1;  // 计算 m 的值
            y[m-1] = p2;  // 更新 y[m-1] 的值为 p2
        }
    }
    
    // 如果 ifnu 大于 0，则执行以下循环
    if (ifnu > 0) {
        // 从 i=1 开始到 i=ifnu 的循环
        for (i = 1; i < (ifnu+1); i++)
        {
            pt = p2;  // 保存 p2 的值到 pt
            p2 = p1 + (fkk + fnf)*rz*p2;  // 更新 p2 的值
            p1 = pt;  // p1 更新为之前的 pt 值
            ak = 1. - tfnf / (fkk+tfnf);  // 计算 ak 的值
            ack = bk*ak;  // 计算 ack 的值
            sum += (ack + bk)*p1;  // 更新 sum 的值
            bk = ack;  // 更新 bk 的值
            fkk -= 1.;  // fkk 减1
        }
    }
    
    pt = z;  // 设置 pt 的值为 z
    if (kode == 2) { pt -= x; }  // 如果 kode 等于 2，则更新 pt 的值
    p1 = -fnf * std::log(rz) + pt;  // 计算 p1 的值
    ap = gamln(1. + fnf);  // 计算 ap 的值
    pt = p1 - ap;  // 更新 pt 的值
    
    //
    // THE DIVISION EXP(PT)/(SUM+P2) IS ALTERED TO AVOID OVERFLOW
    // IN THE DENOMINATOR BY SQUARING LARGE QUANTITIES
    //
    
    p2 += sum;  // 更新 p2 的值
    ap = std::abs(p2);  // 计算 ap 的值
    p1 = 1. / ap;  // 计算 p1 的值
    ck = std::exp(pt) * p1;  // 计算 ck 的值
    pt = conj(p2)*p1;  // 计算 pt 的值
    cnorm = ck * pt;  // 计算 cnorm 的值
    
    // 将 y 中的每个元素乘以 cnorm
    for (int i = 0; i < n; i++) { y[i] *= cnorm; }
    
    return nz;  // 返回 nz 的值
}

inline int kscl(
    std::complex<double> zr,                    // zr 是复数类型的输入参数，表示某个复数
    double fnu,                                 // fnu 是 double 类型的输入参数，表示某个数值
    int n,                                      // n 是整型输入参数，表示某个整数
    std::complex<double> *y,                    // y 是指向复数类型数组的指针，表示某个复数数组
    std::complex<double> rz,                    // rz 是复数类型的输入参数，表示某个复数
    double *ascle,                              // ascle 是 double 类型的指针，表示某个数值
    double tol,                                 // tol 是 double 类型的输入参数，表示某个数值
    double elim                                 // elim 是 double 类型的输入参数，表示某个数值
) {

    //***BEGIN PROLOGUE  ZKSCL
    //***REFER TO  ZBESK
    //
    //     SET K FUNCTIONS TO ZERO ON UNDERFLOW, CONTINUE RECURRENCE
    //     ON SCALED FUNCTIONS UNTIL TWO MEMBERS COME ON SCALE, THEN
    //     RETURN WITH MIN(NZ+2,N) VALUES SCALED BY 1/TOL.
    //
    //***ROUTINES CALLED  ZUCHK,AZABS,AZLOG
    //***END PROLOGUE  ZKSCL

    std::complex<double> cy[2] = { 0. };         // 定义复数数组 cy，初始化为零
    double as, acs, alas, fn, zri, xx;           // 定义一些 double 和复数类型的变量
    std::complex<double> s1, s2, cs, ck, zd;     // 定义一些复数类型的变量
    int nz = 0;                                  // 初始化整型变量 nz 为零
    int ic = 0;                                  // 初始化整型变量 ic 为零
    int nn = ( n > 2 ? 2 : n );                   // 计算 nn 的值，取 n 和 2 中较小的那个
    int kk = 0;                                  // 初始化整型变量 kk 为零
    int i;                                       // 声明整型变量 i
    double elm = exp(-elim);                     // 计算 exp(-elim) 并赋值给 elm
    xx = std::real(zr);                          // 获取 zr 的实部并赋值给 xx

    for (i = 1; i < (nn + 1); i++)
    {
        s1 = y[i-1];                             // 获取 y[i-1] 的值并赋给 s1
        cy[i-1] = s1;                            // 将 s1 赋值给 cy[i-1]
        as = std::abs(s1);                       // 计算 s1 的绝对值并赋给 as
        acs = -std::real(zr) + log(as);          // 计算 -Re(zr) + log(as) 并赋给 acs
        nz += 1;                                 // nz 自增 1
        y[i-1] = 0.;                             // 将 y[i-1] 置零
        if (acs < -elim) {                       // 如果 acs 小于 -elim，则继续下一次循环
            continue;
        }
        cs = -zr + std::log(s1);                 // 计算 -zr + log(s1) 并赋给 cs
        cs = (exp(std::real(cs))/tol)*(cos(std::imag(cs)) + sin(std::imag(cs)*std::complex<double>(0, 1)));
        // 计算 exp(Re(cs))/tol * (cos(Im(cs)) + sin(Im(cs)*i)) 并赋给 cs
        if (!uchk(cs, *ascle, tol)) {            // 调用 uchk 函数检查 cs
            y[i-1] = cs;                         // 如果通过检查，将 cs 赋给 y[i-1]
            nz -= 1;                             // nz 减 1
            ic = i;                              // 将 i 赋给 ic
        }
    }
    if (n == 1) {
        return nz;                               // 如果 n 等于 1，则返回 nz
    }
    if (ic <= 1) {
        y[0] = 0.;                               // 如果 ic 小于等于 1，则将 y[0] 置零
        nz = 2;                                  // 将 nz 设置为 2
    }
    if (n == 2) {
        return nz;                               // 如果 n 等于 2，则返回 nz
    }
    if (nz == 0) {
        return nz;                               // 如果 nz 等于 0，则返回 nz
    }

    fn = fnu + 1.;                                // 计算 fn 并赋值给 fn
    ck = fn*rz;                                   // 计算 fn*rz 并赋值给 ck
    s1 = cy[0];                                   // 获取 cy[0] 的值并赋给 s1
    s2 = cy[1];                                   // 获取 cy[1] 的值并赋给 s2
    zri = std::imag(zr);                          // 获取 zr 的虚部并赋给 zri
    zd = zr;                                       // 将 zr 赋值给 zd
    for (i = 3; i < (n+1); i++)
    {
        kk = i;                                    // 将 i 赋值给 kk
        cs = s2;                                   // 将 s2 赋值给 cs
        s2 *= ck;                                  // 计算 s2 *= ck
        s2 += s1;                                  // 计算 s2 += s1
        s1 = cs;                                   // 将 cs 赋值给 s1
        ck += rz;                                  // 计算 ck += rz
        as = std::abs(s2);                         // 计算 s2 的绝对值并赋给 as
        alas = log(as);                            // 计算 log(as) 并赋给 alas
        acs = alas - xx;                           // 计算 alas - xx 并赋给 acs
        nz += 1;                                   // nz 自增 1
        y[i-1] = 0.;                               // 将 y[i-1] 置零
        if (acs >= -elim) {                        // 如果 acs 大于等于 -elim，则继续下一次循环
            cs = std::log(s2);                     // 计算 log(s2) 并赋给 cs
            cs -= zd;                              // 计算 cs -= zd
            cs = (exp(std::real(cs))/tol)*std::complex<double>(cos(std::imag(cs)), sin(std::imag(cs)));
            // 计算 exp(Re(cs))/tol * (cos(Im(cs)) + sin(Im(cs)*i)) 并赋给 cs
            if (!uchk(cs, *ascle, tol)) {          // 调用 uchk 函数检查 cs
                y[i-1] = cs;                       // 如果通过检查，将 cs 赋给 y[i-1]
                nz -= 1;                           // nz 减 1
                if (ic == kk-1) {                  // 如果 ic 等于 kk-1
                    nz = kk - 2;                   // 设置 nz 为 kk-2
                    for (int i = 0; i < nz; i++) { y[i] = 0.; }  // 将 y 数组前 nz 个元素置零
                    return nz;                     // 返回 nz
                }
                ic = kk;                           // 将 kk 赋给 ic
                continue;
            }
        }
        if (alas >= 0.5*elim){                     // 如果 alas 大于等于 0.5*elim
            xx -= elim;                           // xx 减去 elim
            zd = std::complex<double>(xx, zri);    // 构造一个新的复数并赋给 zd
            s1 *= elm;                            // 计算 s1 *= elm
            s2 *= elm;                            // 计算 s2 *= elm
        }
    }
    nz = n;                                        // 将 n 赋给 nz
    if (ic == n) {
        nz = n-1;                                  // 如果 ic 等于 n，则将 nz 设置为 n-1
    }

    for (int i = 0; i < nz; i++) { y[i] = 0.; }     // 将 y 数组前 nz 个元素置零
    return nz;                                      // 返回 nz
}


inline void rati(
    std::complex<double> z,
    // 计算输入复数 z 的绝对值
    // 计算 int(fnu)，即 fnu 的整数部分
    // 计算 idnu = int(fnu) + n - 1
    // 将 idnu 赋值给 fdnu
    // 计算复数 z 的模的整数部分
    // 计算 amagz = magz + 1
    // 计算 fnup = max(amagz, fdnu)
    // 计算 id = idnu - magz - 1
    // 设置 itime = 1
    // 初始化 k = 1
    // 计算 rz = 2.0 / z
    // 计算 t1 = fnup * rz
    // 初始化 p2 = -t1
    // 初始化 p1 = 1.0
    // 更新 t1 = t1 + rz
    // 如果 id > 0，则将 id 置为 0
    // 计算 ap2 = abs(p2)
    // 计算 ap1 = abs(p1)

    //
    // 在调用 CBKNX 之前，通过对 K(FNU+I-1,Z) 的溢出测试保证 P2 处于合适的范围内。
    // 将 test1 缩放为 sqrt((ap2 + ap2) / (ap1 * tol))，并通过乘以 rap1 来缩放所有后续的 p2 值，以确保不会过早溢出。
    //
    // 计算 arg = (ap2 + ap2) / (ap1 * tol)
    // 计算 test1 = sqrt(arg)
    // 将 test 初始化为 test1
    // 计算 rap1 = 1.0 / ap1
    // 缩放 p1、p2 和 ap2
    // 进入循环，直到条件满足退出循环
    while (1) {
        // 更新 k = k + 1
        // 将 ap1 赋值给 ap2
        // 将 p2 赋值给 pt
        // 更新 p2 = p1 - t1 * p2
        // 将 pt 赋值给 p1
        // 更新 t1 = t1 + rz
        // 计算 ap2 = abs(p2)
        // 如果 ap1 > test，则跳出循环
        // 如果 itime 不等于 2，则计算 ak 和 flam，并更新 test
        k += 1;
        ap1 = ap2;
        pt = p2;
        p2 = p1 - t1 * p2;
        p1 = pt;
        t1 += rz;
        ap2 = std::abs(p2);
        if (ap1 > test) { break; }
        if (itime != 2) {
            ak = std::abs(t1) * 0.5;
            flam = ak + sqrt(ak * ak - 1.0);
            rho = fmin(ap2 / ap1, flam);
            test = test1 * sqrt(rho / (rho * rho - 1.0));
            itime = 2;
        }
    }

    // 计算 kk = k + 1 - id
    // 设置 ak = kk
    // 计算 dfnu = fnu + n - 1
    // 将 dfnu 赋值给 cdfnu
    // 设置 t1 = ak
    // 初始化 p1 = 1.0 / ap2
    // 初始化 p2 = 0.0
    // 进入循环，计算 p1 和 p2 的值
    for (i = 1; i < (kk + 1); i++) {
        // 将 p1 赋值给 pt
        // 更新 p1 = rz * (cdfnu + t1) * p1 + p2
        // 将 pt 赋值给 p2
        // 更新 t1 = t1 - 1.0
        pt = p1;
        p1 = rz * (cdfnu + t1) * p1 + p2;
        p2 = pt;
        t1 -= 1.0;
    }

    // 如果 p1 等于 0，则将 p1 初始化为复数 0
    cy[n - 1] = p2 / p1;
    // 如果 n 等于 1，则直接返回
    if (n == 1) { return; }
    // 设置 k = n - 1
    // 设置 ak = k
    // 设置 t1 = ak
    // 计算 cdfnu = fnu * rz
    // 进入循环，计算 cy 数组的值
    for (i = 2; i < (n + 1); i++) {
        // 计算 pt = cdfnu + t1 * rz * cy[k]
        // 如果 pt 等于 0，则将 pt 初始化为复数 (tol, tol)
        // 更新 cy[k-1] = 1.0 / pt
        // 更新 t1 = t1 - 1.0
        // 更新 k = k - 1
        pt = cdfnu + t1 * rz * cy[k];
        if (pt == 0.0) {
            pt = std::complex<double>(tol, tol);
        }
        cy[k - 1] = 1.0 / pt;
        t1 -= 1.0;
        k -= 1;
    }
    return;
    // 结束当前函数的定义，此处为函数体的结尾
    }

    // inline 关键字表示该函数可以内联展开
    // seri 函数用于计算贝塞尔函数 I，接受复数 z、fnu、kode、n 等参数
    int seri(
        std::complex<double> z,   // 输入参数：复数 z
        double fnu,               // 输入参数：double 类型的 fnu
        int kode,                 // 输入参数：整数类型的 kode
        int n,                    // 输入参数：整数 n
        std::complex<double> *y,  // 输出参数：复数数组 y
        double tol,               // 输入参数：double 类型的 tol
        double elim,              // 输入参数：double 类型的 elim
        double alim               // 输入参数：double 类型的 alim
    ) {

        //***BEGIN PROLOGUE  ZSERI
        //***REFER TO  ZBESI,ZBESK
        //
        //     ZSERI COMPUTES THE I BESSEL FUNCTION FOR REAL(Z).GE.0.0 BY
        //     MEANS OF THE POWER SERIES FOR LARGE CABS(Z) IN THE
        //     REGION CABS(Z).LE.2*SQRT(FNU+1). NZ=0 IS A NORMAL RETURN.
        //     NZ.GT.0 MEANS THAT THE LAST NZ COMPONENTS WERE SET TO ZERO
        //     DUE TO UNDERFLOW. NZ.LT.0 MEANS UNDERFLOW OCCURRED, BUT THE
        //     CONDITION CABS(Z).LE.2*SQRT(FNU+1) WAS VIOLATED AND THE
        //     COMPUTATION MUST BE COMPLETED IN ANOTHER ROUTINE WITH N=N-ABS(NZ).
        //
        //***ROUTINES CALLED  DGAMLN,D1MACH,ZUCHK,AZABS,ZDIV,AZLOG,ZMLT
        //***END PROLOGUE  ZSERI

        std::complex<double> ak1, ck, coef, crsc, cz, half_z, rz, s1, s2, w[2];
        double aa, acz, ak, arm, ascle, atol, az, dfnu, fnup, rak1,\
               rs, rtr1, s, ss, x;
        int ib, iflag, il, k, l, m, nn;

        int nz = 0;
        az = std::abs(z);  // 计算 z 的绝对值
        if (az == 0.0) {
            y[0] = 0.0;
            if (fnu == 0.) { y[0] = 1.0; }  // 如果 fnu 为 0，则 y[0] 设置为 1.0
            if (n == 1) { return nz; }  // 如果 n 为 1，则返回 nz
            for (int i = 1; i < n; i++) { y[i] = 0.0; }  // 否则将 y 数组中的元素设置为 0.0
            return nz;
        }
        x = std::real(z);  // 获取 z 的实部
        arm = 1e3*d1mach[0];  // 计算 arm
        rtr1 = sqrt(arm);  // 计算 arm 的平方根
        crsc = 1.0;  // 设置 crsc 为 1.0
        iflag = 0;  // 初始化 iflag 为 0
        if (az >= arm) {
            half_z = 0.5*z;  // 计算 z 的一半
            cz = 0.0;  // 初始化 cz 为 0.0
            if (az > rtr1) { cz = half_z*half_z; }  // 如果 az 大于 rtr1，则计算 cz
            acz = std::abs(cz);  // 计算 cz 的绝对值
            nn = n;  // 将 nn 初始化为 n
            ck = std::log(half_z);  // 计算 half_z 的自然对数
L10:
            dfnu = fnu + (nn-1);  // 计算 dfnu
            fnup = dfnu + 1.0;  // 计算 fnup
            //
            // UNDERFLOW TEST
            //
            ak1 = ck * dfnu;  // 计算 ak1
            ak = gamln(fnup);  // 调用 gamln 函数计算 ak
            ak1 -= ak;  // ak1 减去 ak
            if (kode == 2) { ak1 -= x; }  // 如果 kode 等于 2，则 ak1 再减去 x
            rak1 = std::real(ak1);  // 获取 ak1 的实部
            if (rak1 > -elim) { goto L30; }  // 如果 rak1 大于 -elim，则跳转到 L30
L20:
            nz += 1;  // nz 加 1
            y[nn - 1] = 0.0;  // 设置 y 数组中索引为 nn-1 的元素为 0.0
            //
            // RETURN WITH NZ < 0 IF ABS(Z*Z/4) > FNU+N-NZ-1 COMPLETE
            // THE CALCULATION IN CBINU WITH N=N-ABS(NZ)
            //
            if (acz > dfnu) { return -nz; }  // 如果 acz 大于 dfnu，则返回 -nz
            nn -= 1;  // nn 减 1
            if (nn == 0) { return nz; }  // 如果 nn 等于 0，则返回 nz
            goto L10;  // 跳转到 L10
        }
        //***MISSING CODE: ADD MISSING CODE HERE***
        // THE MISSING CODE WILL BE ADDED HERE IN THE NEXT ITERATION
L30:
        // 检查 rak1 是否小于等于 -alim
        if (rak1 <= -alim) {
            // 如果满足条件，则设置 iflag 为 1
            iflag = 1;
            // 计算 ss 为 1/tol
            ss = 1.0 / tol;
            // 设置 crsc 为 tol
            crsc = tol;
            // 计算 ascle 为 arm * ss
            ascle = arm * ss;
        }
        // 计算 ak 为 ak1 的虚部
        ak = std::imag(ak1);
        // 计算 aa 为 exp(rak1)
        aa = exp(rak1);
        // 如果 iflag 为 1，则将 aa 乘以 ss
        if (iflag == 1) { aa *= ss; }
        // 计算 coef 为 aa 乘以以 (cos(ak), sin(ak)) 组成的复数
        coef = aa * std::complex<double>(cos(ak), sin(ak));
        // 计算 atol 为 tol * acz / fnup
        atol = tol * acz / fnup;
        // 计算 il 为 nn 和 2 中较小的值
        il = (nn > 2 ? 2 : nn);
        // 循环遍历 il 次
        for (int i = 1; i < (il + 1); i++)
        {
            // 计算 dfnu 为 fnu + (nn-i)
            dfnu = fnu + (nn-i);
            // 计算 fnup 为 dfnu + 1.0
            fnup = dfnu + 1.0;
            // 初始化 s1 为 1.0
            s1 = 1.0;
            // 如果 acz 大于等于 tol*fnup，则进入内部循环
            if (acz >= tol*fnup) {
                // 初始化 ak1 为 1.0
                ak1 = 1.0;
                // 初始化 ak 为 fnup + 2.0
                ak = fnup + 2.0;
                // 初始化 s 为 fnup
                s = fnup;
                // 初始化 aa 为 2.0
                aa = 2.0;
                // 进入 aa 的计算循环
                while (1) {
                    // 计算 rs 为 1.0 / s
                    rs = 1.0 / s;
                    // ak1 乘以 cz
                    ak1 *= cz;
                    // ak1 乘以 rs
                    ak1 *= rs;
                    // s1 累加 ak1
                    s1 += ak1;
                    // s 累加 ak
                    s += ak;
                    // ak 累加 2.0
                    ak += 2.0;
                    // aa 乘以 acz
                    aa *= acz;
                    // aa 乘以 rs
                    aa *= rs;
                    // 如果 aa 小于等于 atol，则跳出循环
                    if (aa <= atol) { break; }
                }
            }
            // 计算 s2 为 s1 乘以 coef
            s2 = s1 * coef;
            // 将 s2 赋值给 w[i-1]
            w[i-1] = s2;
            // 如果 iflag 不为 0，则进行进一步检查
            if (iflag != 0) {
                // 如果 uchk(s2, ascle, tol) 返回 true，则跳转到 L20
                if (uchk(s2, ascle, tol)) { goto L20; }
            }
            // 计算 m 为 nn - i + 1
            m = nn - i + 1;
            // 计算 y[m-1] 为 s2 乘以 crsc
            y[m-1] = s2 * crsc;
            // 如果 i 不等于 il，则更新 coef
            if (i != il) { coef *= dfnu / half_z; }
        }
        // 如果 nn 小于等于 2，则返回 nz
        if (nn <= 2) { return nz; }
        // 计算 k 为 nn - 2
        k = nn - 2;
        // 初始化 ak 为 k
        ak = k;
        // 计算 rz 为 2.0 / z
        rz = 2.0 / z;
        // 如果 iflag 为 1，则跳转到 L80
        if (iflag == 1) { goto L80; }
        // 初始化 ib 为 3
        ib = 3;
L60:
        // 循环遍历 ib 到 nn 的值
        for (int i = ib; i < (nn+1); i++)
        {
            // 计算 y[k-1] 为 (ak+fnu)*rz*y[k] + y[k+1]
            y[k-1] = (ak+fnu)*rz*y[k] + y[k+1];
            // ak 减去 1.0
            ak -= 1.0;
            // k 减去 1
            k -= 1;
        }
        // 返回 nz
        return nz;
L80:
        //
        // RECUR BACKWARD WITH SCALED VALUES
        //
        //
        // EXP(-ALIM)=EXP(-ELIM)/TOL=APPROX. ONE PRECISION ABOVE THE
        // UNDERFLOW LIMIT = ASCLE = D1MACH(1)*SS*1000
        //
        // 将 w[0] 赋值给 s1
        s1 = w[0];
        // 将 w[1] 赋值给 s2
        s2 = w[1];
        // 初始化 l 为 3
        l = 3;
        // 循环遍历 l 到 nn 的值
        for (int l = 3; l < (nn+1); l++)
        {
            // 将 s2 赋值给 ck
            ck = s2;
            // 计算 s2 为 s1 + (ak+fnu)*rz*s2
            s2 = s1 + (ak+fnu)*rz*s2;
            // 将 s1 赋值给 ck
            s1= ck;
            // 计算 ck 为 s2*crsc
            ck = s2*crsc;
            // 将 ck 赋值给 y[k-1]
            y[k-1] = ck;
            // ak 减去 1.0
            ak -= 1.0;
            // k 减去 1
            k -= 1;
            // 如果 ck 的绝对值大于 ascle，则跳转到 L100
            if (std::abs(ck) > ascle) { goto L100; }
        }
        // 返回 nz
        return nz;
L100:
        // 将 l+1 赋值给 ib
        ib = l+1;
        // 如果 ib 大于 nn，则返回 nz
        if (ib > nn) { return nz; }
        // 跳转到 L60
        goto L60;
    }
    // 将 n 赋值给 nz
    nz = n;
    // 如果 fnu 等于 0.0，则 nz 减去 1
    if (fnu == 0.0) { nz -= 1; }
    // 将 0.0 赋值给 y[0]
    y[0] = 0.0;
    // 如果 fnu 等于 0.0，则将 1.0 赋值给 y[0]
    if (fnu == 0.) { y[0] = 1.0; }
    // 如果 n 等于 1，则返回 nz
    if (n == 1) { return nz; }
    // 循环遍历 1 到 n-1 的值
    for (int i = 1; i < n; i++) { y[i] = 0.0; }
    // 返回 nz
    return nz;
}


inline int s1s2(
    std::complex<double> zr,
    std::complex<double> *s1,
    std::complex<double> *s2,
    double ascle,
    double alim,
    int *iuf
) {

    //***BEGIN PROLOGUE  ZS1S2
    //***REFER TO  ZBESK,ZAIRY
    //
    //     ZS1S2 TESTS FOR A POSSIBLE UNDERFLOW RESULTING FROM THE
    //     ADDITION OF THE I AND K FUNCTIONS IN THE ANALYTIC CON-
    //     TINUATION FORMULA WHERE S1=K FUNCTION AND S2=I FUNCTION.
    //     ON KODE=1 THE I AND K FUNCTIONS ARE DIFFERENT ORDERS OF
    // 定义复数变量c1和s1d，以及浮点数变量aa、aln、as1、as2、xx
    std::complex<double> c1, s1d;
    double aa, aln, as1, as2, xx;
    // 初始化非零计数器nz
    int nz = 0;
    
    // 计算s1的绝对值as1和s2的绝对值as2
    as1 = std::abs(*s1);
    as2 = std::abs(*s2);
    // 提取s1的实部aa和虚部aln
    aa = std::real(*s1);
    aln = std::imag(*s1);
    
    // 如果s1不全为零
    if ((aa != 0.) || (aln != 0.)) {
        // 如果as1不为零
        if (as1 != 0.) {
            // 计算xx为zr的实部的两倍的负对数加上log(as1)
            xx = std::real(zr);
            aln = -xx - xx + log(as1);
            // 保存原始值到s1d，将s1设为零，并将as1设为零
            s1d = *s1;
            *s1 = 0.;
            as1 = 0.;
            // 如果aln大于等于-alim
            if (aln >= -alim) {
                // 计算c1为s1d的对数减去zr的两倍，然后取指数赋给s1
                c1 = std::log(s1d) - zr - zr;
                *s1 = std::exp(c1);
                // 更新as1为s1的绝对值，并增加iuf计数器
                as1 = std::abs(*s1);
                *iuf += 1;
            }
        }
    }
    
    // 计算aa为as1和as2中的最大值
    aa = fmax(as1, as2);
    // 如果aa大于给定的阈值ascle，则返回nz
    if (aa > ascle) {
        return nz;
    }
    
    // 将s1、s2和iuf均设为零，并返回1
    *s1 = 0.;
    *s2 = 0.;
    *iuf = 0;
    return 1;
}

//***BEGIN PROLOGUE  ZUCHK
//***REFER TO ZSERI,ZUOIK,ZUNK1,ZUNK2,ZUNI1,ZUNI2,ZKSCL
//
//      Y ENTERS AS A SCALED QUANTITY WHOSE MAGNITUDE IS GREATER THAN
//      EXP(-ALIM)=ASCLE=1.0E+3*D1MACH(1)/TOL. THE TEST IS MADE TO SEE
//      IF THE MAGNITUDE OF THE REAL OR IMAGINARY PART WOULD UNDERFLOW
//      WHEN Y IS SCALED (BY TOL) TO ITS PROPER VALUE. Y IS ACCEPTED
//      IF THE UNDERFLOW IS AT LEAST ONE PRECISION BELOW THE MAGNITUDE
//      OF THE LARGEST COMPONENT; OTHERWISE THE PHASE ANGLE DOES NOT HAVE
//      ABSOLUTE ACCURACY AND AN UNDERFLOW IS ASSUMED.
//
//***ROUTINES CALLED  (NONE)
//***END PROLOGUE  ZUCHK

inline int uchk(
    std::complex<double> y,
    double ascle,
    double tol
) {
    // 计算实部和虚部的绝对值
    double yr = fabs(std::real(y));
    double yi = fabs(std::imag(y));
    // 取较大和较小值
    double ss = fmax(yr, yi);
    double st = fmin(yr, yi);
    // 如果较小值大于给定的上界，返回0
    if (st > ascle) {
        return 0;
    } else {
        // 否则将较小值除以tol
        st /= tol;
        // 如果较大值小于除以tol后的较小值，返回1；否则返回0
        if (ss < st) {
            return 1;
        } else {
            return 0;
        }
    }
}

//***BEGIN PROLOGUE  ZUNHJ
//***REFER TO  ZBESI,ZBESK
//
//     REFERENCES
//         HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ AND I.A.
//         STEGUN, AMS55, NATIONAL BUREAU OF STANDARDS, 1965, CHAPTER 9.
//
//         ASYMPTOTICS AND SPECIAL FUNCTIONS BY F.W.J. OLVER, ACADEMIC
//         PRESS, N.Y., 1974, PAGE 420
//
//     ABSTRACT
//         ZUNHJ COMPUTES PARAMETERS FOR BESSEL FUNCTIONS C(FNU,Z) =
//         J(FNU,Z), Y(FNU,Z) OR H(I,FNU,Z) I=1,2 FOR LARGE ORDERS FNU
//         BY MEANS OF THE UNIFORM ASYMPTOTIC EXPANSION
//
//         C(FNU,Z)=C1*PHI*( ASUM*AIRY(ARG) + C2*BSUM*DAIRY(ARG) )
//
//         FOR PROPER CHOICES OF C1, C2, AIRY AND DAIRY WHERE AIRY IS
//         AN AIRY FUNCTION AND DAIRY IS ITS DERIVATIVE.
//
//               (2/3)*FNU*ZETA**1.5 = ZETA1-ZETA2,
//
//         ZETA1=0.5*FNU*CLOG((1+W)/(1-W)), ZETA2=FNU*W FOR SCALING
//         PURPOSES IN AIRY FUNCTIONS FROM CAIRY OR CBIRY.
//
//         MCONJ=SIGN OF AIMAG(Z), BUT IS AMBIGUOUS WHEN Z IS REAL AND
//         MUST BE SPECIFIED. IPMTR=0 RETURNS ALL PARAMETERS. IPMTR=
//         1 COMPUTES ALL EXCEPT ASUM AND BSUM.
//
//***ROUTINES CALLED  AZABS,ZDIV,AZLOG,AZSQRT,D1MACH
//***END PROLOGUE  ZUNHJ

inline void unhj(
    std::complex<double> z,
    double fnu,
    int ipmtr,
    double tol,
    std::complex<double> *phi,
    std::complex<double> *arg,
    std::complex<double> *zeta1,
    std::complex<double> *zeta2,
    std::complex<double> *asum,
    std::complex<double> *bsum
) {
    // 声明各种复数和实数变量
    std::complex<double> cfnu, przth, ptfn, rtzta, rzth, suma, sumb;
    std::complex<double> tfn, t2, w, w2, za, zb, zc, zeta, zth;
    double ang, atol, aw2, azth, btol, fn13, fn23, pp, rfn13;
    double rfnu, rfnu2, wi, wr, zci, zcr, zetai, zetar, zthi;
    // 定义双精度变量
    double zthr, asumr, asumi, bsumr, bsumi, test, ac;
    // 初始化常数
    double ex1 = 1. / 3.;
    double ex2 = 2. / 3.;
    double hpi = 1.57079632679489662;
    double pi = 3.14159265358979324;
    double thpi = 4.71238898038468986;
    // 初始化整数变量
    int ias, ibs, j, ju, k, kmax, kp1, ks, l, lrp1, l1, l2, m;
    /* array vars */
    // 初始化复数数组
    std::complex<double> cr[14] = { 0. };
    std::complex<double> dr[14] = { 0. };
    std::complex<double> up[14] = { 0. };
    std::complex<double> p[30] = { 0. };
    // 初始化双精度数组
    double ap[30] = { 0. };

    // 计算 1/fnu
    rfnu = 1. / fnu;

    //
    // OVERFLOW TEST (Z/FNU TOO SMALL)
    //
    // 根据机器精度检测是否会发生溢出
    test = d1mach[0] * 1e3;
    ac = fnu * test;
    // 如果 z/fnu 的实部和虚部都小于等于 ac，则认为溢出，直接返回预设值
    if ((fabs(std::real(z)) <= ac) && (fabs(std::imag(z)) <= ac)) {
        *zeta1 = 2.0 * fabs(log(test)) + fnu;
        *zeta2 = fnu;
        *phi = 1.;
        *arg = 1.;
        return;
    }

    // 计算 zb = z * 1/fnu 和 rfnu^2
    zb = z * rfnu;
    rfnu2 = rfnu * rfnu;

    //
    // COMPUTE IN THE FOURTH QUADRANT
    //
    // 计算 fnu 的 1/3 和 2/3 次方
    fn13 = pow(fnu, ex1);
    fn23 = fn13 * fn13;
    rfn13 = 1.0 / fn13;
    w2 = 1.0 - zb * zb;
    /* AMOS AZSQRT and C CSQRT differs when imaginary 0.0 swaps sign */
    // 处理特殊情况：当 w2 的虚部为负零时，将其转换为实部
    w2 = 1.0 - zb * zb;
    if (std::imag(w2) == -0.0) { w2 = std::real(w2); }
    aw2 = std::abs(w2);
    if (aw2 <= 0.25) {
        //
        // POWER SERIES FOR ABS(W2) <= 0.25
        //
        // 初始化系数和和值
        k = 1;
        p[0] = 1.;
        suma = zunhj_gama[0];
        ap[0] = 1.;
        // 如果 aw2 大于等于 tol，则计算幂级数
        if (aw2 >= tol) {
            for (k = 2; k < 31; k++)
            {
                // 计算幂级数系数和递归公式
                p[k-1] = p[k-2]*w2;
                suma += p[k-1]*zunhj_gama[k-1];
                ap[k-1] = ap[k-2]*aw2;
                // 如果 ap[k-1] 小于 tol，退出循环
                if (ap[k-1] < tol) { break; }
            }
        }
        /* Check for exhausted loop */
        // 检查循环是否因为达到上限而结束
        if (k == 31) { k = 30; }

        // 计算 zeta 和 arg
        kmax = k;
        zeta = w2*suma;
        *arg = zeta*fn23;
        za = std::sqrt(suma);
        *zeta2 = std::sqrt(w2)*fnu;
        *zeta1 = (*zeta2) * (1. + zeta*za*ex2);
        za = za + za;
        *phi = std::sqrt(za)*rfn13;
        // 如果 ipmtr 等于 1，直接返回
        if (ipmtr == 1) { return; }
        //
        // SUM SERIES FOR ASUM AND BSUM
        //
        // 计算 asum 和 bsum 的级数和
        sumb = 0.0;
        for (k = 1; k < (kmax+1); k++) {
            sumb += p[k-1]*zunhj_beta[k-1];
        }
        *asum = 0.0;
        *bsum = sumb;
        l1 = 0;
        l2 = 30;
        btol = tol * (fabs(std::real(*bsum)) + fabs(std::imag(*bsum)));
        atol = tol;
        pp = 1.0;
        ias = 0;
        ibs = 0;
        // 如果 rfnu2 小于 tol，直接进行特殊处理
        if (rfnu2 < tol) {
            /* 110 */
            *asum += 1.;
            *bsum *= rfnu*rfn13;
            /* 120 */
            return;
        }
        // 循环求解级数和
        for (int is = 2; is < 8; is++)
        {
            atol /= rfnu2;
            pp *= rfnu2;
            // 计算 asum
            if (ias != 1) {
                suma = 0.0;
                for (k = 1; k < (kmax+1); k++)
                {
                    m = l1 + k;
                    suma += p[k-1]*zunhj_alfa[m-1];
                    if (ap[k-1] < atol) { break; }
                }
                *asum += suma*pp;
                if (pp < tol) { ias = 1; }
            }
            // 计算 bsum
            if (ibs != 1) {
                sumb = 0.0;
                for (k = 1; k < (kmax+1); k++)
                {
                    m = l2 + k;
                    sumb += p[k-1]*zunhj_beta[m-1];
                    if (ap[k-1] < atol) { break; }
                }
                *bsum += sumb*pp;
                if (pp < btol) { ibs = 1; }
            }
            // 如果 asum 和 bsum 已经满足精度要求，跳出循环
            if ((ias == 1) && (ibs == 1)) { break; }
            l1 += 30;
            l2 += 30;
        }
        // 最后的特殊处理
        *asum += 1.;
        *bsum *= rfnu*rfn13;
        return;
    }


这段代码主要是一个条件判断和一系列数学运算的实现，注释解释了每个步骤和循环的作用，以及条件判断的含义。
    // }
    
    // 内联函数 uni1 开始
    // 参数说明：
    //   z: 复数类型的参数
    //   fnu: double 类型参数，代表函数的某种度量
    //   kode: int 类型参数，控制计算方式的标志
    //   n: int 类型参数，代表某种数量
    //   *y: 复数类型的指针，指向存储结果的数组
    //   *nz: int 类型的指针，用于存储计算结果的数量
    //   *nlast: int 类型的指针，表示最后处理的数量
    //   fnul: double 类型参数，代表函数的最小值
    //   tol, elim, alim: double 类型参数，控制数值计算精度的参数

    // ***BEGIN PROLOGUE  ZUNI1
    // ***REFER TO  ZBESI,ZBESK
    //
    // ZUNI1 计算 I(FNU,Z) 的均匀渐近展开，其中 -PI/3 <= ARG Z <= PI/3.
    //
    // FNUL 是渐近展开允许的最小阶数。NLAST=0 表示所有的 Y 值已设置。
    // NLAST.NE.0 表示剩余需要由其他公式计算的 Y 值，适用于阶数 FNU 到 FNU+NLAST-1，因为 FNU+NLAST-1.LT.FNUL.
    // 对于 I(FNU,Z)，Y(I)=CZERO 对于 I=NLAST+1,N。
    //
    // ***ROUTINES CALLED  ZUCHK,ZUNIK,ZUOIK,D1MACH,AZABS
    // ***END PROLOGUE  ZUNI1

    std::complex<double> c2, phi, rz, sum, s1, s2, zeta1 = 0, zeta2 = 0;
    double aphi, ascle, c1r, crsc, cscl, fn, rs1;
    int i, iflag, init, k, m, nd, nn, nuf;
    std::complex<double> cwrk[16] = { 0. };
    std::complex<double> cy[2] = { 0. };
    *nz = 0;
    nd = n;
    *nlast = 0;
    //
    // COMPUTED VALUES WITH EXPONENTS BETWEEN ALIM AND ELIM IN
    // MAGNITUDE ARE SCALED TO KEEP INTERMEDIATE ARITHMETIC ON SCALE,
    // EXP(ALIM)=EXP(ELIM)*TOL
    //
    cscl = 1.0 / tol;
    crsc = tol;
    double css[3] = {cscl, 1., crsc};
    double csr[3] = {crsc, 1., cscl};
    double bry[3] = {1e3*d1mach[0]/tol, 0., 0.};
    bry[1] = 1.0 / bry[0];
    bry[2] = d1mach[1];
    //
    // CHECK FOR UNDERFLOW AND OVERFLOW ON FIRST MEMBER
    //
    fn = fmax(fnu, 1.0);
    init = 0;
    unik(z, fn, 1, 1, tol, &init, &phi, &zeta1, &zeta2, &sum, &cwrk[0]);
    if (kode != 1) {
        s1 = -zeta1 + fn*(fn / (z + zeta2));
    } else {
        s1 = -zeta1 + zeta2 ;
    }

    rs1 = std::real(s1);
    if (fabs(rs1) > elim) {
        if (rs1 > 0) {
            *nz = -1;
            return;
        }
        *nz = n;
        for (i = 0; i < n; i++) { y[i] = 0.0; }
    }
L30:
    nn = ( nd > 2 ? 2 : nd);
    for (i = 1; i < (nn+1); i++)
    {
        fn = fnu + nd - i;
        init = 0;
        unik(z, fn, 1, 0, tol, &init, &phi, &zeta1, &zeta2, &sum, &cwrk[0]);
        if (kode != 1) {
            s1 = -zeta1 + fn*(fn / (z + zeta2)) + std::complex<double>(0.0, std::imag(z));
        } else {
            s1 = -zeta1 + zeta2;
        }
        //
        // TEST FOR UNDERFLOW AND OVERFLOW
        //
        rs1 = std::real(s1);
        if (fabs(rs1) > elim) { goto L110; }
        if (i == 1) { iflag = 2; }
        if (fabs(rs1) >= alim) {
            //
            // REFINE TEST AND SCALE
            //
            aphi = std::abs(phi);
            rs1 += log(aphi);
            if (fabs(rs1) > elim) { goto L110; }
            if (i == 1) { iflag = 1; }
            if (rs1 >= 0.0) { if (i == 1) { iflag = 3; } }
        }
    /* 60 */
        // 如果绝对值小于指定阈值 ASCLE，则对 S1 进行缩放
        s2 = phi*sum; // 计算 phi 乘以 sum 的结果赋给 s2
        s1 = exp(std::real(s1))*css[iflag-1]*std::complex<double>(cos(std::imag(s1)), sin(std::imag(s1))); // 计算 s1 的指数部分，乘以 css 数组中的元素，再乘以一个复数
        s2 *= s1; // 将 s2 乘以 s1
        if (iflag == 1) { if (uchk(s2, bry[0], tol)) { goto L110; } } // 如果 iflag 等于 1，并且 s2 不满足指定条件，则跳转到标签 L110
    /* 70 */
        cy[i-1] = s2; // 将 s2 赋给数组 cy 的第 i-1 个元素
        m = nd - i + 1; // 计算 m 的值
        y[m-1] = s2*csr[iflag-1]; // 将 s2 乘以 csr 数组中的元素赋给数组 y 的第 m-1 个元素
    }
    /* 80 */
    if (nd > 2) { // 如果 nd 大于 2
        rz = 1.0 / z; // 计算 rz 的值
        s1 = cy[0]; // 将数组 cy 的第一个元素赋给 s1
        s2 = cy[1]; // 将数组 cy 的第二个元素赋给 s2
        c1r = csr[iflag-1]; // 将 csr 数组中的元素赋给 c1r
        ascle = bry[iflag-1]; // 将 bry 数组中的元素赋给 ascle
        k = nd - 2; // 计算 k 的值
        fn = k; // 将 k 的值赋给 fn
        for (i = 3; i < (nd+1); i++) // 循环从 i=3 到 nd
        {
            c2 = s2; // 将 s2 赋给 c2
            s2 = s1 + (fnu + fn)*rz*c2; // 计算新的 s2 的值
            s1 = c2; // 将 c2 赋给 s1
            c2 = s2*c1r; // 将 s2 乘以 c1r 赋给 c2
            y[k-1] = c2; // 将 c2 赋给数组 y 的第 k-1 个元素
            k -= 1; // k 减 1
            fn -= 1.0; // fn 减 1
            if (iflag >= 3) { continue; } // 如果 iflag 大于等于 3，则继续下一次循环
            if (fmax(fabs(std::real(c2)), fabs(std::imag(c2))) <= ascle) { continue; } // 如果 c2 的实部和虚部的绝对值的最大值小于等于 ascle，则继续下一次循环
            iflag += 1; // iflag 加 1
            ascle = bry[iflag-1]; // 更新 ascle 的值
            s1 *= c1r; // 将 s1 乘以 c1r
            s2 = c2; // 将 c2 赋给 s2
            s1 *= css[iflag-1]; // 将 s1 乘以 css 数组中的元素
            s2 *= css[iflag-1]; // 将 s2 乘以 css 数组中的元素
            c1r = csr[iflag-1]; // 将 csr 数组中的元素赋给 c1r
        }
    /* 90 */
    }
    /* 100 */
    return;
    // 如果 rs1 大于 0.0，则设置 nz 为 -1 并返回
    if (rs1 > 0.0) { *nz = -1; return; }
    // 在数组 y 的第 nd-1 位置设置值为 0.0
    y[nd - 1] = 0.0;
    // nz 自增
    *nz += 1;
    // nd 减一
    nd -= 1;
    // 如果 nd 等于 0，则返回
    if (nd == 0) { return; }
    // 调用 uoik 函数计算 nuf
    nuf = uoik(z, fnu, kode, 1, nd, y, tol, elim, alim);
    // 如果 nuf 小于 0，则设置 nz 为 -1 并返回
    if (nuf < 0) { *nz = -1; return; }
    // nd 减去 nuf
    nd -= nuf;
    // nz 自增 nuf
    *nz += nuf;
    // 如果 nd 等于 0，则返回
    if (nd == 0) { return; }
    // 计算 fn 为 fnu 加上 nd 减一
    fn = fnu + nd - 1;
    // 如果 fn 大于等于 fnul，则跳转到 L30
    if (fn >= fnul) { goto L30; }
    // 将 nlast 设置为 nd，并返回
    *nlast = nd;
    return;
}
    } else {
        // 计算 s1 的值，s1 = -zeta1 + zeta2
        s1 = -zeta1 + zeta2;
    }
    // 计算 s1 的实部
    rs1 = std::real(s1);
    // 检查实部的绝对值是否大于 elim
    if (fabs(rs1) > elim) {
        // 如果实部大于 elim
        if (rs1 > 0.) {
            // 如果实部大于 0，设置 nz 为 -1 并返回
            *nz = -1;
            return;
        }
        // 将数组 y 的所有元素设为 0
        for (i = 0; i < n; i++) {
            y[i] = 0.0;
        }
        // 返回结束函数执行
        return;
    }
L10:
    // 选择较小的值作为 nn，限制在 2 以下
    nn = (nd > 2 ? 2 : nd);
    // 初始化循环变量 i
    i = 1;
    // 循环，处理每个 i 从 1 到 nn
    for (i = 1; i < (nn+1); i++)
    {
        // 计算当前 fn 值
        fn = fnu + (nd-i);
        // 调用 unhj 函数计算 phi, arg, zeta1, zeta2, asum, bsum 的值
        unhj(zn, fn, 0, tol, &phi, &arg, &zeta1, &zeta2, &asum, &bsum);
        // 根据 kode 值进行条件判断
        if (kode != 1) {
            // 设置 cfn 为 fn 的值
            cfn = fn;
            // 计算 ay，取 yy 的绝对值
            ay = fabs(yy);
            // 计算 s1
            s1 = -zeta1 + cfn*(cfn/(zb + zeta2)) + ay*std::complex<double>(0, 1);
        } else {
            // 如果 kode 等于 1，简化计算 s1 的值
            s1 = -zeta1 + zeta2;
        }
        //
        // TEST FOR UNDERFLOW AND OVERFLOW
        //
        // 获取 s1 的实部 rs1
        rs1 = std::real(s1);
        // 如果 rs1 的绝对值超过 elim，跳转到 L50 标签处
        if (fabs(rs1) > elim) { goto L50; }
        // 如果 i 等于 1，设置 iflag 为 2
        if (i == 1) { iflag = 2; }
        // 如果 rs1 的绝对值大于等于 alim
        if (fabs(rs1) >= alim) {
            //
            // REFINE TEST AND SCALE
            //
            // 计算 aphi 和 aarg 的绝对值
            aphi = std::abs(phi);
            aarg = std::abs(arg);
            // 调整 rs1 值，用于进一步测试
            rs1 += log(aphi) - 0.25*log(aarg) - aic;
            // 如果 rs1 的绝对值超过 elim，跳转到 L50 标签处
            if (fabs(rs1) > elim) { goto L50; }
            // 如果 i 等于 1，设置 iflag 为 1
            if (i == 1) { iflag = 1; }
            // 如果 rs1 大于等于 0.0，且 i 等于 1，设置 iflag 为 3
            if (rs1 >= 0.0){ if (i== 1) { iflag = 3; }}
        }
        //
        // SCALE S1 TO KEEP INTERMEDIATE ARITHMETIC ON SCALE NEAR
        // EXPONENT EXTREMES
        //
        // 调用 airy 函数计算 ai 和 dai 的值
        ai = airy(arg, 0, 2, &nai, &idum);
        dai = airy(arg, 1, 2, &ndai, &idum);
        // 计算 s2 的值
        s2 = phi * (ai*asum + dai*bsum);
        // 计算 c2r 和 c2i
        c2r = std::exp(std::real(s1))*std::real(css[iflag-1]);
        c2i = std::imag(s1);
        // 计算 s1
        s1 = c2r*std::complex<double>(cos(c2i), sin(c2i));
        // 更新 s2 的值
        s2 *= s1;
        // 如果 iflag 等于 1，调用 uchk 函数检查 s2 是否小于 bry[0] 的绝对值，如果是则跳转到 L50 标签处
        if (iflag == 1) { if (uchk(s2, bry[0], tol)) { goto L50; } }
        // 如果 yy 小于等于 0.0，将 s2 取共轭
        if (yy <= 0.0) { s2 = conj(s2); }
        // 计算 j 的值
        j = nd - i + 1;
        // 更新 s2 的值
        s2 *= c2;
        // 将 s2 存储在 cy 数组中
        cy[i-1] = s2;
        // 更新 y 数组中的值
        y[j-1] = s2*csr[iflag-1];
        // 更新 c2 的值
        c2 *= cid;
    }
    // 如果 nd 大于 2，执行以下操作
    if (nd > 2) {
        // 计算 rz 的值
        rz = 2.0 / z;
        // 更新 bry 数组的值
        bry[1] = 1.0 / bry[0];
        bry[2] = d1mach[1];
        // 获取 cy 数组的前两个元素值
        s1 = cy[0];
        s2 = cy[1];
        // 获取 csr 数组的当前值
        c1 = csr[iflag-1];
        // 更新 ascle 的值
        ascle = bry[iflag-1];
        // 计算 k 的值
        k = nd - 2;
        fn = k;
        // 循环，处理每个 i 从 3 到 nd
        for (i = 3; i < (nd+1); i++) {
            // 将 s2 的值保存在 c2 中
            c2 = s2;
            // 更新 s2 的值
            s2 = s1 + (fnu+fn)*rz*s2;
            // 更新 s1 的值
            s1 = c2;
            // 计算 c2 的值
            c2 = s2*c1;
            // 更新 y 数组的值
            y[k-1] = c2;
            // 更新 k 的值
            k -= 1;
            // 减小 fn 的值
            fn -= 1.0;
            // 如果 iflag 小于 3，执行以下操作
            if (iflag < 3) {
                // 计算 c2r 和 c2i 的值
                c2r = fabs(std::real(c2));
                c2i = fabs(std::imag(c2));
                c2m = fmax(c2r, c2i);
                // 如果 c2m 大于 ascle，更新 iflag 的值
                if (c2m > ascle) {
                    iflag += 1;
                    ascle = bry[iflag-1];
                    s1 *= c1;
                    s2 = c2;
                    s1 *= css[iflag-1];
                    s2 *= css[iflag-1];
                    c1 = csr[iflag-1];
                }
            }
        }
    }
    // 返回
    return;
L50:
    // 如果 rs1 小于等于 0.0，则执行以下操作
    if (rs1 <= 0.0) {
        //
        // 设置下溢并更新参数
        //
        // 将 y 数组中的最后一个元素设为 0.0
        y[nd-1] = 0.0;
        // 增加下溢计数器 nz
        nz += 1;
        // 减少 nd 的值
        nd -= 1;
        // 如果 nd 变为 0，则直接返回
        if (nd == 0) { return; }
        // 调用 uoik 函数进行参数更新和处理
        nuf = uoik(z, fnu, kode, 1, nd, y, tol, elim, alim);
        // 如果 nuf 大于等于 0，则继续处理
        if (nuf >= 0) {
            // 更新 nd 和 nz
            nd -= nuf;
            nz += nuf;
            // 如果 nd 变为 0，则直接返回
            if (nd == 0) { return; }
            // 计算 fn 的值
            fn = fnu + nd - 1;
            // 如果 fn 大于等于 fnul，则执行以下操作
            if (fn >= fnul) {
                // 以下内容在原始的 F77 代码中被注释掉了
                // C      FN = CIDI
                // C      J = NUF + 1
                // C      K = MOD(J,4) + 1
                // C      S1R = CIPR(K)
                // C      S1I = CIPI(K)
                // C      IF (FN.LT.0.0D0) S1I = -S1I
                // C      STR = C2R*S1R - C2I*S1I
                // C      C2I = C2R*S1I + C2I*S1R
                // C      C2R = STR
                // 计算 in 的值
                in = (inu + nd - 1) % 4;
                // 计算 c2 的值
                c2 = zar * cip[in];
                // 如果 yy 小于等于 0.0，则取 c2 的共轭
                if (yy <= 0.0) { c2 = conj(c2); }
                // 跳转到标签 L10 处
                goto L10;
            }
            // 更新 nlast 的值为 nd，并返回
            *nlast = nd;
            return;
        }
    }
    // 如果 rs1 大于 0.0，则将 nz 设为 -1，并返回
    *nz = -1;
    return;
// 闭合之前的函数定义
}

// 定义名为 unik 的内联函数，计算复杂参数以用于 I 和 K 函数的统一渐近展开
inline void unik(
    std::complex<double> zr,  // 输入参数：复数 zr
    double fnu,               // 输入参数：双精度浮点数 fnu
    int ikflg,                // 输入参数：整数 ikflg
    int ipmtr,                // 输入参数：整数 ipmtr
    double tol,               // 输入参数：双精度浮点数 tol
    int *init,                // 输入/输出参数：整型指针 init
    std::complex<double> *phi, // 输出参数：复数指针 phi
    std::complex<double> *zeta1, // 输出参数：复数指针 zeta1
    std::complex<double> *zeta2, // 输出参数：复数指针 zeta2
    std::complex<double> *total, // 输出参数：复数指针 total
    std::complex<double> *cwrk   // 输入/输出参数：复数指针 cwrk
) {

    //***BEGIN PROLOGUE  ZUNIK
    //***REFER TO  ZBESI,ZBESK
    //
    //        ZUNIK COMPUTES PARAMETERS FOR THE UNIFORM ASYMPTOTIC
    //        EXPANSIONS OF THE I AND K FUNCTIONS ON IKFLG= 1 OR 2
    //        RESPECTIVELY BY
    //
    //        W(FNU,ZR) = PHI*EXP(ZETA)*SUM
    //
    //        WHERE       ZETA=-ZETA1 + ZETA2       OR
    //                          ZETA1 - ZETA2
    //
    //        THE FIRST CALL MUST HAVE INIT=0. SUBSEQUENT CALLS WITH THE
    //        SAME ZR AND FNU WILL RETURN THE I OR K FUNCTION ON IKFLG=
    //        1 OR 2 WITH NO CHANGE IN INIT. CWRK IS A COMPLEX WORK
    //        ARRAY. IPMTR=0 COMPUTES ALL PARAMETERS. IPMTR=1 COMPUTES PHI,
    //        ZETA1,ZETA2.
    //
    //***ROUTINES CALLED  ZDIV,AZLOG,AZSQRT,D1MACH
    //***END PROLOGUE  ZUNIK

    std::complex<double> cfn, crfn, s, sr, t, t2, zn;
    double ac, rfn, test, tstr, tsti;
    int i, j, k, l;
    /* ( 1/sqrt(2 PI), sqrt(PI/2) ) */
    double con[2] = { 3.98942280401432678e-01, 1.25331413731550025 };

    if (*init == 0) {
        rfn = 1. / fnu;  // 计算 fnu 的倒数并赋值给 rfn
        crfn = rfn;       // 将 rfn 赋值给 crfn

        tstr = std::real(zr);  // 获取 zr 的实部
        tsti = std::imag(zr);  // 获取 zr 的虚部
        test = d1mach[0] * 1e3;  // 使用 d1mach 函数计算 test 值
        ac = fnu * test;   // 计算 ac
        if ((fabs(tstr) <= ac) && (fabs(tsti) <= ac)) {
            ac = 2.0 * fabs(log(test)) + fnu;
            *zeta1 = ac;   // 设置 zeta1
            *zeta2 = fnu;  // 设置 zeta2
            *phi = 1.0;    // 设置 phi
        }
        t = zr * crfn;  // 计算 t
        s = 1.0 + t*t;  // 计算 s
        sr = std::sqrt(s);  // 计算 sr
        cfn = fnu;       // 将 fnu 赋值给 cfn
        zn = (1. + sr) / t;  // 计算 zn
        *zeta1 = cfn * std::log(zn);  // 计算 zeta1
        *zeta2 = cfn * sr;  // 计算 zeta2
        t = 1.0 / sr;    // 计算 t
        sr = t*crfn;     // 重新计算 sr
        cwrk[15] = std::sqrt(sr);  // 计算 cwrk[15]
        *phi = cwrk[15]*con[ikflg-1];  // 计算 phi
        if (ipmtr != 0) { return; }  // 根据 ipmtr 的值决定返回
        t2 = 1. / s;     // 计算 t2
        cwrk[0] = 1.;    // 设置 cwrk[0]
        crfn = 1.;       // 设置 crfn
        ac = 1.;         // 设置 ac
        l = 1;           // 初始化 l
        k = 2;           // 初始化 k
        for (k = 2; k < 16; k++)
        {
            s = 0.0;
            for (j = 1; j < (k+1); j++)
            {
                l += 1;
                s = s*t2 + zunik_c[l-1];
            }
            crfn *= sr;
            cwrk[k-1] = crfn*s;
            ac *= rfn;
            tstr = std::real(cwrk[k-1]);
            tsti = std::imag(cwrk[k-1]);
            test = fabs(tstr) + fabs(tsti);
            if ((ac < tol) && (test < tol)) {
                break;
            }
        }
        /* Guard against exhausted loop */
        if (k == 16) { k-=1; }
        *init = k;   // 更新 init
    }

    *total = 0.0;   // 初始化 total
    t = 1.0;        // 初始化 t
    if (ikflg != 2) {

        for (i = 0; i < (*init); i++) {
            *total += cwrk[i];  // 累加 cwrk 中的值到 total
        }
        *phi = cwrk[15] * con[0];  // 计算 phi
    } else {
        # 进入 else 分支，说明条件不满足
        for (i = 1; i < (*init + 1); i++) {
            # 循环从1到(*init + 1)，对 total 进行累加计算
            *total += t * cwrk[i-1];
            # 切换 t 的符号
            t = -t;
        }
        # 计算 phi 的值，基于 cwrk 数组的第16个元素和 con 数组的第2个元素
        *phi = cwrk[15] * con[1];
    }
    # 函数返回，结束执行
    return;
}

// 定义一个名为 unk1 的内联函数，计算修正的贝塞尔函数 K(FNU,Z)
// 并通过均匀渐近展开从右半平面延伸到左半平面的解析延拓。
// MR 指示解析延拓的旋转方向。
// NZ=-1 意味着可能会发生溢出。

inline int unk1(
    std::complex<double> z,     // 复数变量 z，表示复变量
    double fnu,                 // 双精度浮点数，表示 FNU 参数
    int kode,                   // 整数，编码参数
    int mr,                     // 整数，表示方向
    int n,                      // 整数，表示计数器
    std::complex<double> *y,    // 指向复数数组的指针，用于存储结果
    double tol,                 // 双精度浮点数，容忍度参数
    double elim,                // 双精度浮点数，消除参数
    double alim                 // 双精度浮点数，限制参数
) {

    //***BEGIN PROLOGUE  ZUNK1
    //***REFER TO  ZBESK
    //
    //     ZUNK1 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE
    //     RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE
    //     UNIFORM ASYMPTOTIC EXPANSION.
    //     MR INDICATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.
    //     NZ=-1 MEANS AN OVERFLOW WILL OCCUR
    //
    //***ROUTINES CALLED  ZKSCL,ZS1S2,ZUCHK,ZUNIK,D1MACH,AZABS
    //***END PROLOGUE  ZUNK1

    std::complex<double> cfn, ck, crsc, cs, cscl, csgn, cspn, c1, c2, rz, s1, s2, zr,\
                   phid, zeta1d = 0.0, zeta2d = 0.0, sumd;
    double ang, aphi, asc, ascle, c2i, c2m, c2r, fmr, fn, fnf, rs1, sgn, x;
    int i, ib, iflag = 0, ifn, il, inu, iuf, k, kdflg, kflag, kk, m, nw, nz, j,\
        jc, ipard, initd, ic;

    // 初始化参数
    cscl = 1.0 / tol;   // 计算倒数作为缩放因子
    crsc = tol;         // 定义容忍度参数
    std::complex<double> css[3] = {cscl, 1.0, crsc };   // 复数数组，存储缩放因子和容忍度
    std::complex<double> csr[3] = {crsc, 1.0, cscl };   // 另一个复数数组，存储容忍度和缩放因子
    std::complex<double> cwrk[3][16] = {{ 0.0 }};       // 复数矩阵，用于工作空间
    std::complex<double> phi[2] = { 0.0 };              // 复数数组，存储相位信息
    std::complex<double> sum[2] = { 0.0 };              // 复数数组，用于求和
    std::complex<double> zeta1[2] = { 0.0 };            // 复数数组，存储 ζ1
    std::complex<double> zeta2[2] = { 0.0 };            // 复数数组，存储 ζ2
    std::complex<double> cy[2] = { 0.0 };                // 复数数组，用于存储计算结果
    double bry[3] = { 1e3*d1mach[0] / tol, tol / 1e3*d1mach[0], d1mach[1]};  // 双精度浮点数数组，定义 Bessel 函数的阈值
    int init[2] = { 0 };                                // 整数数组，初始化标志
    double pi = 3.14159265358979324;                    // 双精度浮点数，π 的值

    kdflg = 1;  // 初始化 KDFLG 为 1
    kflag = 1;  // 初始化 KFLAG 为 1
    fn = fnu;   // 将 FNU 赋给 FN
    nz = 0;     // 初始化 NZ 为 0
    x = std::real(z);   // 计算 z 的实部并赋给 x
    zr = z;             // 将 z 赋给 zr
    if (x < 0.0) { zr = -z; }   // 如果 x 小于 0，则 zr 赋为 -z
    j = 2;  // 初始化 j 为 2
    for (i = 1; i < (n+1); i++)
        j = 3 - j; /* j flip flops between 1, 2 */
        // 计算 j 的翻转，其值在 1 和 2 之间变换

        jc = j - 1; /* dummy index for 0-indexing */
        // 将 j 转换为从 0 开始的索引

        fn = fnu + (i - 1);
        // 计算 fn，它是 fnu 加上 i 减 1 的结果

        init[jc] = 0;
        // 初始化数组 init 的第 jc 个元素为 0

        unik(zr, fn, 2, 0, tol, &init[jc], &phi[jc], &zeta1[jc], &zeta2[jc], &sum[jc], &cwrk[jc][0]);
        // 调用 unik 函数进行计算，更新 init[jc]、phi[jc]、zeta1[jc]、zeta2[jc]、sum[jc] 和 cwrk[jc][0]

        if (kode != 1) {
            cfn = fn;
            s1 = zeta1[jc] - cfn*(cfn / (zr + zeta2[jc]));
        } else {
            s1 = zeta1[jc] - zeta2[jc];
        }
        // 根据条件计算 s1 的值

        //
        // TEST FOR UNDERFLOW AND OVERFLOW
        //
        // 检查是否出现下溢或上溢情况

        rs1 = std::real(s1);
        // 获取 s1 的实部

        if (fabs(rs1) <= elim) {
            // 如果 s1 的绝对值小于等于 elim
            if (kdflg == 1) { kflag = 2; }
            // 如果 kdflg 等于 1，则 kflag 置为 2

            if (fabs(rs1) >= alim) {
                //
                // REFINE TEST AND SCALE
                //
                // 进一步细化测试并进行缩放

                aphi = std::abs(phi[jc]);
                // 计算 phi[jc] 的绝对值

                rs1 += log(aphi);
                // 将 rs1 加上 log(aphi)

                if (fabs(rs1) > elim) { goto L10; }
                // 如果 rs1 的绝对值大于 elim，则跳转到标签 L10

                if (kdflg == 1) { kflag = 1; }
                // 如果 kdflg 等于 1，则 kflag 置为 1

                if (rs1 >= 0.0) { if (kdflg == 1) { kflag = 3; } }
                // 如果 rs1 大于等于 0.0 且 kdflg 等于 1，则 kflag 置为 3
            }

            //
            // SCALE S1 TO KEEP INTERMEDIATE ARITHMETIC ON SCALE NEAR
            // EXPONENT EXTREMES
            //
            // 缩放 s1 以保持中间算术在指数极限附近的尺度

            s2 = phi[jc]*sum[jc];
            // 计算 s2

            c2r = std::real(s1);
            c2i = std::imag(s1);
            // 获取 s1 的实部和虚部

            c2m = exp(c2r)*std::real(css[kflag-1]);
            // 计算 c2m

            s1 = c2m * std::complex<double>(cos(c2i), sin(c2i));
            // 更新 s1

            s2 *= s1;
            // 更新 s2

            if (!((kflag == 1) && (uchk(s2, bry[0], tol)))) {
                // 如果不满足条件 (kflag == 1) && (uchk(s2, bry[0], tol))
                cy[kdflg-1] = s2;
                // 更新 cy 数组的值
                y[i-1] = s2*csr[kflag-1];
                // 更新 y 数组的值

                if (kdflg == 2) { break; }
                // 如果 kdflg 等于 2，则跳出循环

                kdflg = 2;
                // 更新 kdflg 的值为 2
                continue;
                // 继续循环
            }
        }
        if (rs1 > 0.0 ) { return -1; }
        // 如果 rs1 大于 0，则返回 -1，这里 rs1 是一个实数变量
        if (x < 0.0) { return -1; }
        // 如果 x 小于 0，则返回 -1，这里 x 也是一个实数变量
        kdflg = 1;
        // 设置 kdflg 为 1，kdflg 是一个标志位
        y[i-1] = 0.0;
        // 将 y 数组中索引为 i-1 的位置设为 0.0，i 是循环变量
        nz += 1;
        // nz 自增 1，nz 是一个计数器
        if (i > 1) {
            // 如果 i 大于 1，则执行下面的条件语句块
            if (y[i-2] != 0.0) {
                // 如果 y 数组中索引为 i-2 的位置不为 0.0，则执行下面的语句块
                y[i-2] = 0.0;
                // 将 y 数组中索引为 i-2 的位置设为 0.0
                nz += 1;
                // nz 自增 1
            }
        }
    }
    /* Check for exhausted loop */
    // 检查循环是否耗尽
    if (i == (n+1)) { i = n; }
    // 如果 i 等于 n+1，则将 i 设为 n，结束循环

    rz = 2.0 / zr;
    // 计算 rz 为 2.0 除以 zr 的值，zr 是一个实数变量
    ck = fn * rz;
    // 计算 ck 为 fn 乘以 rz 的值，fn 是一个实数变量
    ib = i + 1;
    // 将 ib 设为 i 加 1
    if (n >= ib) {
        // 如果 n 大于等于 ib，则执行下面的条件语句块
        //
        // TEST LAST MEMBER FOR UNDERFLOW AND OVERFLOW, SET SEQUENCE TO ZERO
        // ON UNDERFLOW
        //
        // 检测最后一个成员的下溢和上溢，将序列设为零，对于下溢
        //
        fn = fnu + (n-1);
        // 计算 fn 为 fnu 加上 n-1 的值，fnu 和 n 都是实数变量
        ipard = 1;
        // 设置 ipard 为 1，ipard 是一个整数变量
        if (mr != 0) { ipard = 0; }
        // 如果 mr 不等于 0，则将 ipard 设为 0
        initd = 0;
        // 将 initd 设为 0，initd 是一个整数变量
        unik(zr, fn, 2, ipard, tol, &initd, &phid, &zeta1d, &zeta2d, &sumd, &cwrk[2][0]);
        // 调用 unik 函数，传递多个参数
        if (kode != 1) {
            // 如果 kode 不等于 1，则执行下面的条件语句块
            cfn = fn;
            // 将 cfn 设为 fn，cfn 是一个实数变量
            s1 = zeta1d - cfn*(cfn / (zr + zeta2d));
            // 计算 s1 的值
        } else {
            s1 = zeta1d - zeta2d;
            // 否则，将 s1 设为 zeta1d 减去 zeta2d
        }
        rs1 = std::real(s1);
        // 将 rs1 设为 s1 的实部，std::real 是获取复数实部的函数
        if (fabs(rs1) <= elim) {
            // 如果 rs1 的绝对值小于等于 elim，则执行下面的条件语句块
            if (fabs(rs1) < alim) { goto L50; }
            // 如果 rs1 的绝对值小于 alim，则跳转到 L50 标签处
            //
            // REFINE ESTIMATE AND TEST
            //
            // 修正估计并进行测试
            //
            aphi = std::abs(phid);
            // 将 aphi 设为 phid 的绝对值，std::abs 是获取数值绝对值的函数
            rs1 += log(aphi);
            // 将 rs1 加上 log(aphi)
            if (fabs(rs1) < elim) { goto L50; }
            // 如果 rs1 的绝对值小于 elim，则跳转到 L50 标签处
        }
        if (rs1 > 0.0) { return -1; }
        // 如果 rs1 大于 0，则返回 -1
        //
        // FOR X < 0.0, THE I FUNCTION TO BE ADDED WILL OVERFLOW
        //
        // 对于 x 小于 0.0，要添加的 I 函数会溢出
        //
        if (x < 0.0) { return -1; }
        // 如果 x 小于 0，则返回 -1
        nz = n;
        // 将 nz 设为 n
        for (i = 0; i < (n+1); i++) { y[i] = 0.0; }
        // 将 y 数组中的所有元素设为 0.0
        return nz;
        // 返回 nz
L50:
        //
        // RECUR FORWARD FOR REMAINDER OF THE SEQUENCE
        //
        // 递归前进处理序列的其余部分
        //
        s1 = cy[0];
        // 将 s1 设为 cy 数组的第一个元素
        s2 = cy[1];
        // 将 s2 设为 cy 数组的第二个元素
        c1 = csr[kflag-1];
        // 将 c1 设为 csr 数组中索引为 kflag-1 的元素
        ascle = bry[kflag-1];
        // 将 ascle 设为 bry 数组中索引为 kflag-1 的元素
        for (i = ib; i < (n+1); i++)
        {
            // 循环 i 从 ib 到 n+1
            c2 = s2;
            // 将 c2 设为 s2
            s2 = ck*s2 + s1;
            // 计算新的 s2
            s1 = c2;
            // 将 s1 设为原来的 c2
            ck += rz;
            // ck 自增 rz
            c2 = s2*c1;
            // 计算 c2
            y[i-1] = c2;
            // 将 y 数组中索引为 i-1 的位置设为 c2
            if (kflag < 3) {
                // 如果 kflag 小于 3，则执行下面的条件语句块
                c2m = fmax(fabs(std::real(c2)), fabs(std::imag(c2)));
                // 计算 c2m 为 c2 的实部和虚部的绝对值中的较大值
                if (c2m > ascle) {
                    // 如果 c2m 大于 ascle，则执行下面的条件语句块
                    kflag += 1;
                    // kflag 自增 1
                    ascle = bry[kflag-1];
                    // 将 ascle 设为 bry 数组中索引为 kflag-1 的元素
                    s1 *= c1;
                    // s1 乘以 c1
                    s2 = c2;
                    // 将 s2 设为 c2
                    s1 *= css[kflag-1];
                    // s1 乘以 css 数组中索引为 kflag-1 的元素
                    s2 *= css[kflag-1];
                    // s2 乘以 css 数组中索引为 kflag-1 的元素
                    c1 = csr[kflag-1];
                    // 将 c1 设为 csr 数组中索引为 kflag-1 的元素
                }
            }
        }
    }
    if (mr == 0) { return nz; }
    // 如果 mr 等于 0，则返回 nz
    //
    // ANALYTIC CONTINUATION FOR RE(Z) < 0.0
    //
    // 对于 Re(Z) < 0.0 的解析延拓
    //
    nz = 0;
    // 将 nz 设为 0
    fmr = mr;
    // 将 fmr 设为 mr，
    {
        fn = fnu + (kk-1);
        //
        // 计算 fn 变量的值，fnu 为起始值，kk 为当前循环变量减一
        //
    
        // LOGIC TO SORT OUT CASES WHOSE PARAMETERS WERE SET FOR THE K
        // FUNCTION ABOVE
        //
        // 处理那些参数已经为上述 K 函数设置的情况的逻辑
        //
        
        m = 3;
        // 将 m 设为 3
    
        if (n > 2) { goto L80; }
        // 如果 n 大于 2，则跳转到标签 L80 处继续执行
    }
L70:
        // 从数组中取出对应位置的值赋给变量
        initd = init[j-1];
        // 从数组中取出对应位置的值赋给变量
        phid = phi[j -1];
        // 从数组中取出对应位置的值赋给变量
        zeta1d = zeta1[j-1];
        // 从数组中取出对应位置的值赋给变量
        zeta2d = zeta2[j-1];
        // 从数组中取出对应位置的值赋给变量
        sumd = sum[j-1];
        // 变量 m 被赋值为 j
        m = j;
        // 变量 j 被赋值为 3 减 j 的结果
        j = 3 - j;
        // 跳转到标签 L90
        goto L90;
L80:
        // 检查条件，如果不满足则跳转到标签 L70
        if (!((kk == n) && (ib < n))) {
            if ((kk == ib) || (kk == ic)){ goto L70; }
            // 初始化变量 initd 为 0
            initd = 0;
        }
L90:
        // 调用函数 unik，传递参数并更新参数的值
        unik(zr, fn, 1, 0, tol, &initd, &phid, &zeta1d, &zeta2d, &sumd, &cwrk[m-1][0]);
        // 检查条件 kode 不等于 1
        if (kode != 1) {
            // 初始化变量 cfn 为 fn
            cfn = fn;
            // 计算变量 s1 的值
            s1 = -zeta1d + cfn * (cfn/(zr + zeta2d));
        } else {
            // 计算变量 s1 的值
            s1 = -zeta1d + zeta2d;
        }
        //
        // TEST FOR UNDERFLOW AND OVERFLOW
        //
        // 获取实部 rs1
        rs1 = std::real(s1);
        // 检查 fabs(rs1) 是否大于 elim，如果是则跳转到标签 L110
        if (fabs(rs1) > elim) { goto L110; }
        // 检查 kdflg 是否等于 1，如果是则将 iflag 置为 2
        if (kdflg == 1) { iflag = 2; }
        // 检查 fabs(rs1) 是否大于等于 alim
        if (fabs(rs1) >= alim) {
            //
            // REFINE TEST AND SCALE
            //
            // 计算 aphi 的绝对值
            aphi = std::abs(phid);
            // 更新 rs1 的值
            rs1 += log(aphi);
            // 检查 fabs(rs1) 是否大于 elim，如果是则跳转到标签 L110
            if (fabs(rs1) > elim) { goto L110; }
            // 检查 kdflg 是否等于 1，如果是则将 iflag 置为 1
            if (kdflg == 1) { iflag = 1; }
            // 检查 rs1 是否大于等于 0.0
            if (rs1 >= 0.0) { if (kdflg == 1) { iflag = 3; } }
        }

        // 计算 s2 的值
        s2 = csgn * phid * sumd;
        // 获取 s1 的实部和虚部，计算 c2m 的值
        c2r = std::real(s1);
        c2i = std::imag(s1);
        c2m = exp(c2r) * std::real(css[iflag-1]);
        // 更新 s1 的值
        s1 = c2m * std::complex<double>(cos(c2i), sin(c2i));
        // 计算 s2 的值
        s2 *= s1;
        // 检查 iflag 是否等于 1，如果是则调用 uchk 函数并根据返回值处理 s2
L100:
        cy[kdflg -1] = s2;
        c2 = s2;
        s2 *= csr[iflag-1];
        //
        // ADD I AND K FUNCTIONS, K SEQUENCE IN Y(I), I=1,N
        //
        // 获取 y[kk-1] 的值赋给 s1
        s1 = y[kk-1];
        // 检查 kode 是否不等于 1，如果是则调用 s1s2 函数
        if (kode != 1) {
            nw = s1s2(zr, &s1, &s2, asc, alim, &iuf);
            nz += nw;
        }
        // 更新 y[kk-1] 的值
        y[kk-1] = s1*cspn + s2;
        // kk 减 1
        kk -= 1;
        // 反转符号 cspn
        cspn = -cspn;
        // 如果 c2 等于 0.0，则设置 kdflg 为 1 并继续循环
        if (c2 == 0.0) {
            kdflg = 1;
            continue;
        }
        // 检查 kdflg 是否等于 2，如果是则跳转到标签 L130
        if (kdflg == 2) { goto L130; }
        // 设置 kdflg 为 2 并继续循环
        kdflg = 2;
        continue;
L110:
        // 检查 rs1 是否大于 0.0，如果是则返回 -1
        if (rs1 > 0.0) { return -1; }
        // 设置 s2 为 0.0 并跳转到标签 L100
        s2 = 0.0;
        goto L100;
    }
    /* If loop is exhausted */
    // 如果 k 等于 n+1，则 k 减 1
    if (k == n+1) { k -= 1; }
L130:
    // 计算 il 的值
    il = n-k;
    // 如果 il 等于 0，则返回 nz
    if (il == 0) { return nz; };
    // 获取 cy[0] 和 cy[1] 的值
    s1 = cy[0];
    s2 = cy[1];
    // 获取 csr[iflag-1] 和 bry[iflag-1] 的值
    cs = csr[iflag-1];
    ascle = bry[iflag-1];
    // 计算 fn 的值
    fn = inu + il;
    // 循环，更新 y 数组的值
    for (i = 1; i < (il+1); i++)
    {
        // 获取 s2 的值赋给 c2
        c2 = s2;
        // 计算 s2 的值
        s2 = s1 + (fn + fnf) * rz * s2;
        // 更新 s1 的值
        s1 = c2;
        // fn 减 1.0
        fn -= 1.0;
        // 计算 c2 的值
        c2 = s2 * cs;
        // 获取 y[kk-1] 的值赋给 c1
        c1 = y[kk-1];
        // 检查 kode 是否不等于 1，如果是则调用 s1s2 函数
        if (kode != 1) {
            nw = s1s2(zr, &c1, &c2, asc, alim, &iuf);
            nz = nz + nw;
        }
        // 更新 y[kk-1] 的值
        y[kk-1] = c1 * cspn + c2;
        // kk 减 1
        kk -= 1;
        // 反转符号 cspn
        cspn = -cspn;
        // 检查 iflag 是否小于 3
        if (iflag < 3) {
            // 计算 c2 的模值
            c2m = fmax(fabs(std::real(c2)), fabs(std::imag(c2)));
            // 如果 c2m 大于 ascle，则更新 iflag 和 ascle，并调整其他变量
            if (c2m > ascle) {
                iflag += 1;
                ascle = bry[iflag-1];
                s1 *= cs;
                s2 = ck;
                s1 *= css[iflag-1];
                s2 *= css[iflag-1];
                cs = csr
    std::complex<double> z,     // 定义一个复数变量 z，类型为 std::complex<double>
    double fnu,                 // 定义一个双精度浮点数变量 fnu
    int kode,                   // 定义一个整数变量 kode
    int mr,                     // 定义一个整数变量 mr
    int n,                      // 定义一个整数变量 n
    std::complex<double> *y,    // 定义一个指向 std::complex<double> 类型的指针 y
    double tol,                 // 定义一个双精度浮点数变量 tol
    double elim,                // 定义一个双精度浮点数变量 elim
    double alim                 // 定义一个双精度浮点数变量 alim
//***BEGIN PROLOGUE  ZUNK2
//***REFER TO  ZBESK
//
//     ZUNK2 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE
//     RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE
//     UNIFORM ASYMPTOTIC EXPANSIONS FOR H(KIND,FNU,ZN) AND J(FNU,ZN)
//     WHERE ZN IS IN THE RIGHT HALF PLANE, KIND=(3-MR)/2, MR=+1 OR
//     -1. HERE ZN=ZR*I OR -ZR*I WHERE ZR=Z IF Z IS IN THE RIGHT
//     HALF PLANE OR ZR=-Z IF Z IS IN THE LEFT HALF PLANE. MR INDIC-
//     ATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.
//     NZ=-1 MEANS AN OVERFLOW WILL OCCUR
//
//***ROUTINES CALLED  ZAIRY,ZKSCL,ZS1S2,ZUCHK,ZUNHJ,D1MACH,AZABS
//***END PROLOGUE  ZUNK2

std::complex<double> ai, cfn, ck, cs, csgn, cspn, c1, c2, dai, rz, s1, s2,\
             zb, zn, zr, phid, argd, zeta1d, zeta2d, asumd, bsumd;
double aarg, ang, aphi, asc, ascle, car, cpn, c2i, c2m, c2r, crsc, cscl,\
       fmr, fn, fnf, rs1, sar, sgn, spn, x, yy;
int i, ib, iflag = 0, ifn, il, in, inu, iuf, k, kdflg, kflag, kk, nai, ndai,\
    nw, nz, idum, j, ipard, ic;

std::complex<double> cr1 = std::complex<double>(1.0, 1.73205080756887729);      /*   1 + sqrt(3)i  */
std::complex<double> cr2 = std::complex<double>(-0.5, -8.66025403784438647e-1); /*      0.5 cr1    */
double hpi = 1.57079632679489662;                          /*      0.5 pi     */
double pi = 3.14159265358979324;
double aic = 1.26551212348464539;                          /* log(2 sqrt(pi)) */
std::complex<double> cip[4] = {1.0, -std::complex<double>(0, 1), -1.0, std::complex<double>(0, 1)};
cscl = 1.0 / tol;   // Inverse of tolerance
crsc = tol;         // Tolerance
std::complex<double> css[3] = {cscl, 1.0, crsc };    // Array of complex constants
std::complex<double> csr[3] = {crsc, 1.0, cscl };    // Array of complex constants
std::complex<double> phi[2] = { 0.0 };               // Array of complex variables
std::complex<double> arg[2] = { 0.0 };               // Array of complex variables
std::complex<double> zeta1[2] = { 0.0 };             // Array of complex variables
std::complex<double> zeta2[2] = { 0.0 };             // Array of complex variables
std::complex<double> asum[2] = { 0.0 };              // Array of complex variables
std::complex<double> bsum[2] = { 0.0 };              // Array of complex variables
std::complex<double> cy[2] = { 0.0 };                // Array of complex variables
double bry[3] = { (1.0 + 1e3*d1mach[0] / tol), 1.0/(1.0 + 1e3*d1mach[0] / tol), d1mach[1]};   // Array of doubles

kdflg = 1;      // Flag for scaling parameter
kflag = 1;      // Flag for analytic continuation
fn = fnu;       // Assigning the value of fnu to fn
nz = 0;         // Initialize nz (overflow indicator)

//
// EXP(-ALIM)=EXP(-ELIM)/TOL=APPROX. ONE PRECISION GREATER THAN
// THE UNDERFLOW LIMIT
//
x = std::real(z);   // Real part of z
zr = z;
if (x < 0.0) { zr = -z; }   // Adjust zr based on the sign of x
yy = std::imag(zr);        // Imaginary part of zr
zn = -zr*std::complex<double>(0, 1);    // Complex number zn
zb = zr;                 // Assign zr to zb
inu = (int)fnu;          // Convert fnu to integer and assign to inu
fnf = fnu - inu;         // Fractional part of fnu
ang = -hpi * fnf;        // Angle calculation
car = cos(ang);          // Cosine of angle
sar = sin(ang);          // Sine of angle
cpn = hpi * car;         // Adjusted cosine
spn = hpi * sar;         // Adjusted sine
c2 = std::complex<double>(spn, -cpn);    // Complex constant c2
kk = (inu % 4) + 1;      // Determine kk based on inu
cs = cr1 * c2 * cip[kk - 1];   // Complex constant cs
if (yy <= 0.0) {
    zn = conj(-zn);      // Conjugate of -zn if yy <= 0
    zb = conj(zb);       // Conjugate of zb
}
//
// K(FNU,Z) IS COMPUTED FROM H(2,FNU,-I*Z) WHERE Z IS IN THE FIRST
// QUADRANT.  FOURTH QUADRANT VALUES (YY <= 0.0_DP) ARE COMPUTED BY
    // 设置初始值为2，因为K函数在正实数轴上是实数
    //
    j = 2;
    // 循环，从1到n+1，i作为循环变量
    for (i = 1; i < (n+1); i++)
    }
    /* 检查循环是否已完成 */
    if (i == n+1) { i = n; }

    // 计算rz为2.0除以zr的结果
    rz = 2.0 / zr;
    // 计算ck为fn乘以rz的结果
    ck = fn * rz;
    // ib为i加1
    ib = i + 1;
    // 如果n大于等于ib
    if (n >= ib) {
        // 计算fn为fnu加上n-1
        fn = fnu + (n - 1);
        // 设置ipard为1
        ipard = 1;
        // 如果mr不等于0，则设置ipard为0
        if (mr != 0) { ipard = 0; }
        // 调用unhj函数，计算phid、argd、zeta1d、zeta2d、asumd、bsumd
        unhj(zn, fn, ipard, tol, &phid, &argd, &zeta1d, &zeta2d, &asumd, &bsumd);
        // 如果kode不等于1
        if (kode != 1) {
            // 将cfn设置为fn
            cfn = fn;
            // 计算s1为zeta1d减去cfn乘以(cfn除以(zb加上zeta2d))的结果
            s1 = zeta1d - cfn * (cfn / (zb + zeta2d));
        } else {
            // 否则，计算s1为zeta1d减去zeta2d的结果
            s1 = zeta1d - zeta2d;
        }
        // 计算rs1为s1的实部
        rs1 = std::real(s1);
        // 如果rs1的绝对值小于等于elim
        if (fabs(rs1) <= elim) {
            // 如果rs1的绝对值小于alim，跳转到标签L120
            if (fabs(rs1) < alim) { goto L120; }
            //
            // 修正估计值并进行测试
            //
            // 计算aphi为phid的绝对值
            aphi = std::abs(phid);
            // 计算aarg为argd的绝对值
            aarg = std::abs(argd);
            // 对rs1进行修正，加上log(aphi)减去0.25乘以log(aarg)减去aic
            rs1 += log(aphi) - 0.25 * log(aarg) - aic;
            // 如果修正后的rs1的绝对值小于elim，跳转到标签L120
            if (fabs(rs1) < elim) { goto L120; }
        }
        // 如果rs1大于0.0，返回-1
        if (rs1 > 0.0) { return -1; }
        //
        // 当x < 0.0时，要添加的I函数会溢出
        //
        // 如果x小于0.0，返回-1
        if (x < 0.0) { return -1; }
        // 将nz设置为n，循环将y数组中的所有元素设为0.0
        nz = n;
        for (i = 0; i < n; i++) { y[i] = 0.0; }
        // 返回nz
        return nz;
        //
        // SCALED FORWARD RECURRENCE FOR REMAINDER OF THE SEQUENCE
        //
        s1 = cy[0];
        s2 = cy[1];
        c1 = csr[kflag-1];  // 获取 csr 数组中的值，索引为 kflag-1
        ascle = bry[kflag-1];  // 获取 bry 数组中的值，索引为 kflag-1
        for (i = ib; i < (n+1); i++)
        {
            c2 = s2;
            s2 = ck * s2 + s1;  // 根据给定公式更新 s2
            s1 = c2;  // 更新 s1
            ck += rz;  // 更新 ck
            c2 = s2 * c1;  // 计算 c2
            y[i-1] = c2;  // 将 c2 存入 y 数组的相应位置
            if (kflag < 3) {
                c2m = fmax(fabs(std::real(c2)), fabs(std::imag(c2)));  // 计算 c2 的实部和虚部的绝对值的最大值
                if (c2m > ascle) {
                    kflag += 1;  // 更新 kflag
                    ascle = bry[kflag-1];  // 获取更新后的 ascle 值
                    s1 *= c1;  // 更新 s1
                    s2 = c2;  // 更新 s2
                    s1 *= css[kflag-1];  // 更新 s1
                    s2 *= css[kflag-1];  // 更新 s2
                    c1 = csr[kflag-1];  // 获取更新后的 c1
                }
            }
        }
    }
    if (mr == 0) { return nz; }
    //
    // ANALYTIC CONTINUATION FOR RE(Z) < 0.0
    //
    nz = 0;
    fmr = mr;
    sgn = ( fmr < 0.0 ? pi : -pi);  // 根据 fmr 的值确定 sgn 的正负
    //
    // CSPN AND CSGN ARE COEFF OF K AND I FUNCTIONS RESP.
    //
    csgn = std::complex<double>(0.0, sgn);  // 初始化 csgn
    if (yy <= 0.0) { csgn = -csgn; }  // 根据 yy 的值更新 csgn
    ifn = inu + n - 1;  // 计算 ifn 的值
    ang = fnf*sgn;  // 计算 ang 的值
    cspn = std::complex<double>(cos(ang), sin(ang));  // 根据 ang 计算 cspn
    if (ifn % 2 == 1) { cspn = -cspn; }  // 根据 ifn 的奇偶性更新 cspn
    //
    // CS=COEFF OF THE J FUNCTION TO GET THE I FUNCTION.  I(FNU,Z) IS
    // COMPUTED FROM EXP(I*FNU*HPI)*J(FNU,-I*Z) WHERE Z IS IN THE FIRST
    // QUADRANT.  FOURTH QUADRANT VALUES (YY <= 0.0_dp) ARE COMPUTED BY
    // CONJUGATION SINCE THE I FUNCTION IS REAL ON THE POSITIVE REAL AXIS
    //
    cs = std::complex<double>(car, -sar) * csgn;  // 计算 cs
    in = (ifn % 4) + 1;  // 计算 in 的值
    c2 = cip[in-1];  // 获取 cip 数组中的值，索引为 in-1
    cs *= conj(c2);  // 更新 cs
    asc = bry[0];  // 获取 bry 数组中的第一个元素的值
    iuf = 0;  // 初始化 iuf
    kk = n;  // 初始化 kk
    kdflg = 1;  // 初始化 kdflg
    ib -= 1;  // ib 减去 1
    ic = ib - 1;  // 计算 ic 的值
    for (k = 1; k < (n+1); k++) {
        fn = fnu + (kk-1);  // 计算 fn 的值
        if (n > 2) { goto L175; }  // 根据 n 的值判断是否跳转到标签 L175
L172:
        phid = phi[j-1];  // 获取 phi 数组中的值，索引为 j-1
        argd = arg[j-1];  // 获取 arg 数组中的值，索引为 j-1
        zeta1d = zeta1[j-1];  // 获取 zeta1 数组中的值，索引为 j-1
        zeta2d = zeta2[j-1];  // 获取 zeta2 数组中的值，索引为 j-1
        asumd = asum[j-1];  // 获取 asum 数组中的值，索引为 j-1
        bsumd = bsum[j-1];  // 获取 bsum 数组中的值，索引为 j-1
        j = 3 - j;  // 更新 j
        goto L210;  // 跳转到标签 L210
L175:
        if (!((kk == n) && (ib < n))) {
            if ((kk == ib) || (kk == ic)) { goto L172; }  // 根据 kk、ib、ic 的关系决定是否跳转到标签 L172
            unhj(zn, fn, 0, tol, &phid, &argd, &zeta1d, &zeta2d, &asumd, &bsumd);  // 调用 unhj 函数
        }
        if (kode != 1) {
            // 如果 kode 不等于 1，则执行以下代码块
            cfn = fn;
            // 将 fn 赋值给 cfn
            s1 = -zeta1d + cfn * (cfn/(zb + zeta2d));
            // 计算 s1 的值
        } else {
            // 如果 kode 等于 1，则执行以下代码块
            s1 = -zeta1d + zeta2d;
            // 直接将 s1 赋值为 -zeta1d + zeta2d
        }
        //
        // 检查是否会发生下溢和上溢
        //
        rs1 = std::real(s1);
        // 提取 s1 的实部
        if (fabs(rs1) > elim) {
            // 如果 s1 的绝对值超过 elim
            if (rs1 > 0.0) { return -1; }
            // 如果 s1 大于 0，则返回 -1
            s2 = 0.0;
            // 否则将 s2 置为 0
            goto L250;
            // 跳转到标签 L250 处
        }
        if (kdflg == 1) { iflag = 2; }
        // 如果 kdflg 等于 1，则将 iflag 设置为 2
        if (fabs(rs1) >= alim) {
            //
            // 进一步测试并进行缩放
            //
            aphi = std::abs(phid);
            // 计算 phid 的绝对值
            aarg = std::abs(argd);
            // 计算 argd 的绝对值
            rs1 += log(aphi) - 0.25f * log(aarg) - aic;
            // 对 rs1 进行修正
            if (fabs(rs1) > elim) {
                // 如果修正后的 rs1 的绝对值超过 elim
                if (rs1 > 0.0) { return -1; }
                // 如果 rs1 大于 0，则返回 -1
                s2 = 0.0;
                // 否则将 s2 置为 0
                goto L250;
                // 跳转到标签 L250 处
            }
            if (kdflg == 1) { iflag = 1; }
            // 如果 kdflg 等于 1，则将 iflag 设置为 1
            if (rs1 >= 0.0) { if (kdflg == 1) {iflag = 3;} }
            // 如果 rs1 大于等于 0，并且 kdflg 等于 1，则将 iflag 设置为 3
        }

        ai = airy(argd, 0, 2, &nai, &idum);
        // 调用 airy 函数计算 ai
        dai = airy(argd, 1, 2, &ndai, &idum);
        // 调用 airy 函数计算 dai
        s2 = cs * phid * (ai*asumd + dai*bsumd);
        // 计算 s2 的值
        c2r = std::real(s1);
        // 提取 s1 的实部
        c2i = std::imag(s1);
        // 提取 s1 的虚部
        c2m = exp(c2r) * std::real(css[iflag-1]);
        // 计算 c2m 的值
        s1 = c2m * std::complex<double>(cos(c2i), sin(c2i));
        // 重新计算 s1 的值
        s2 *= s1;
        // 计算 s2 的乘积
        if (iflag == 1) { if (uchk(s2, bry[0], tol)) { s2 = 0.0; } }
        // 如果 iflag 等于 1，则调用 uchk 函数检查 s2

L250:
        if (yy <= 0.0) { s2 = conj(s2); }
        // 如果 yy 小于等于 0，则取 s2 的共轭
        cy[kdflg-1] = s2;
        // 将 s2 存入 cy 数组
        c2 = s2;
        // 将 s2 赋值给 c2
        s2 *= csr[iflag-1];
        // 将 s2 乘以 csr 数组中对应的元素

        //
        // 添加 I 和 K 函数，K 序列存储在 Y(I)，I=1,N 中
        //
        s1 = y[kk-1];
        // 取出 y 数组中的第 kk-1 个元素赋给 s1
        if (kode != 1) {
            // 如果 kode 不等于 1，则执行以下代码块
            nw = s1s2(zr, &s1, &s2, asc, alim, &iuf);
            // 调用 s1s2 函数计算 nw
            nz += nw;
            // 将 nw 累加到 nz 上
        }
        y[kk-1] = s1 * cspn + s2;
        // 更新 y 数组中的第 kk-1 个元素
        kk -= 1;
        // kk 自减 1
        cspn = -cspn;
        // cspn 取反
        cs *= -std::complex<double>(0, 1);
        // cs 乘以 -i

        if (c2 == 0.0) {
            // 如果 c2 等于 0
            kdflg = 1;
            // 将 kdflg 设置为 1
            continue;
            // 继续循环
        }
        if (kdflg == 2) { break; }
        // 如果 kdflg 等于 2，则跳出循环
        kdflg = 2;
        // 将 kdflg 设置为 2
        continue;
        // 继续循环
    }
    /* 检查是否循环耗尽 */
    if (k == n+1) { k = n; }
    // 如果 k 等于 n+1，则将 k 设置为 n

    il = n - k;
    // 计算 il 的值
    if (il == 0) { return nz; }
    // 如果 il 等于 0，则返回 nz

    //
    // 对 I 序列的剩余部分进行递归，并添加 K 函数，在递归期间进行缩放以保持中间算术在指数极值附近的尺度。
    //
    s1 = cy[0];
    // 取出 cy 数组中的第一个元素赋给 s1
    s2 = cy[1];
    // 取出 cy 数组中的第二个元素赋给 s2
    cs = csr[iflag-1];
    // 将 csr 数组中对应的元素赋给 cs
    ascle = bry[iflag-1];
    // 将 bry 数组中对应的元素赋给 ascle
    fn = inu + il;
    // 计算 fn 的值
    for (i = 1; i < (il+1); i++) {
        // 保存当前 s2 的值到 c2
        c2 = s2;
        // 计算下一个 s2 的值
        s2 = s1 + (fn + fnf) * rz * c2;
        // 更新 s1 的值为前一个 s2 的值
        s1 = c2;
        // 减小 fn 的值
        fn -= 1.0;
        // 计算 c2 的复数乘积
        c2 = s2 * cs;
        // 将 c2 赋给 ck
        ck = c2;
        // 从 y 数组中取出元素赋给 c1
        c1 = y[kk-1];
        // 如果 kode 不等于 1，则调用 s1s2 函数，更新 nw 和 nz
        if (kode != 1) {
            nw = s1s2(zr, &c1, &c2, asc, alim, &iuf);
            nz = nz + nw;
        }
        // 将计算结果更新到 y 数组中
        y[kk-1] = c1 * cspn + c2;
        // 减小 kk 的值
        kk -= 1;
        // 更改 cspn 的符号
        cspn = -cspn;
        // 如果 iflag 小于 3，则执行以下操作
        if (iflag < 3) {
            // 计算 ck 的最大模值
            c2m = fmax(fabs(std::real(ck)), fabs(std::imag(ck)));
            // 如果 ck 的模值大于 ascle，则执行以下操作
            if (c2m > ascle) {
                // 增加 iflag 的值
                iflag += 1;
                // 更新 ascle 的值
                ascle = bry[iflag-1];
                // 更新 s1 和 s2 的值
                s1 *= cs;
                s2 = ck;
                // 更新 s1 和 s2 的值
                s1 *= css[iflag-1];
                s2 *= css[iflag-1];
                // 更新 cs 的值
                cs = csr[iflag-1];
            }
        }
    }
    // 返回 nz 的值
    return nz;
    //***BEGIN PROLOGUE  ZUOIK
    //***REFER TO  ZBESI,ZBESK,ZBESH
    //
    //     ZUOIK COMPUTES THE LEADING TERMS OF THE UNIFORM ASYMPTOTIC
    //     EXPANSIONS FOR THE I AND K FUNCTIONS AND COMPARES THEM
    //     (IN LOGARITHMIC FORM) TO ALIM AND ELIM FOR OVER AND UNDERFLOW
    //     WHERE ALIM.LT.ELIM. IF THE MAGNITUDE, BASED ON THE LEADING
    //     EXPONENTIAL, IS LESS THAN ALIM OR GREATER THAN -ALIM, THEN
    //     THE RESULT IS ON SCALE. IF NOT, THEN A REFINED TEST USING OTHER
    //     MULTIPLIERS (IN LOGARITHMIC FORM) IS MADE BASED ON ELIM. HERE
    //     EXP(-ELIM)=SMALLEST MACHINE NUMBER*1.0E+3 AND EXP(-ALIM)=
    //     EXP(-ELIM)/TOL
    //
    //     IKFLG=1 MEANS THE I SEQUENCE IS TESTED
    //          =2 MEANS THE K SEQUENCE IS TESTED
    //     NUF = 0 MEANS THE LAST MEMBER OF THE SEQUENCE IS ON SCALE
    //         =-1 MEANS AN OVERFLOW WOULD OCCUR
    //     IKFLG=1 AND NUF.GT.0 MEANS THE LAST NUF Y VALUES WERE SET TO ZERO
    //             THE FIRST N-NUF VALUES MUST BE SET BY ANOTHER ROUTINE
    //     IKFLG=2 AND NUF.EQ.N MEANS ALL Y VALUES WERE SET TO ZERO
    //     IKFLG=2 AND 0.LT.NUF.LT.N NOT CONSIDERED. Y MUST BE SET BY
    //             ANOTHER ROUTINE
    //
    //***ROUTINES CALLED  ZUCHK,ZUNHJ,ZUNIK,D1MACH,AZABS,AZLOG
    //***END PROLOGUE  ZUOIK

    // 初始化一些变量
    std::complex<double> arg, asum, bsum, cz, phi, sum, zb, zeta1;
    std::complex<double> zeta2, zn, zr;
    double aarg, aphi, ascle, ax, ay, fnn, gnn, gnu, rcz, x, yy;
    int iform, init, nn;
    // 定义一个常数
    double aic = 1.265512123484645396;
    // 定义一个复数数组并初始化为零
    std::complex<double> cwrk[16] = { 0. };

    // 初始化 nuf 为 0
    int nuf = 0;
    // 复制 n 的值到 nn
    nn = n;
    // 获取 z 的实部赋值给 x
    x = std::real(z);
    // 如果 x 小于 0，则取 z 的负值赋值给 zr
    zr = z;
    if (x < 0.) { zr = -z; }
    // 将 zr 赋值给 zb
    zb = zr;
    // 获取 zr 的虚部赋值给 yy
    yy = std::imag(zr);
    // 计算 ax 和 ay
    ax = fabs(x) * sqrt(3.);
    ay = fabs(yy);
    // 初始化 iform 为 1 或 2
    iform = 1;
    if (ay > ax) { iform = 2; }
    // 计算 gnu
    gnu = fmax(fnu, 1.);
    // 如果 ikflg 不等于 1，则计算 fnn 和 gnn
    if (ikflg != 1) {
        fnn = nn;
        gnn = fnu + fnn -1;
        gnu = fmax(gnn, fnn);
    }

    // 根据 iform 的值选择不同的计算路径
    if (iform != 2) {
        // 初始化 init 为 0
        init = 0;
        // 调用 unik 函数计算
        unik(zr, gnu, ikflg, 1, tol, &init, &phi, &zeta1, &zeta2, &sum, &cwrk[0]);
        // 计算 cz
        cz = -zeta1 + zeta2;
    } else {
        // 计算 zn
        zn = -zr * std::complex<double>(0, 1);
        if (yy <= 0.) {
            zn = conj(zn);
        }
        // 调用 unhj 函数计算
        unhj(zn, gnu, 1, tol, &phi, &arg, &zeta1, &zeta2, &asum, &bsum);
        // 计算 cz
        cz = zeta2 - zeta1;
        aarg = std::abs(arg);
    }
    // 根据 kode 和 ikflg 对 cz 进行调整
    if (kode == 2) { cz -= zb; }
    if (ikflg == 2) { cz = -cz; }
    // 计算 aphi 和 rcz
    aphi = std::abs(phi);
    rcz = std::real(cz);

    /*  OVERFLOW TEST  */
    // 进行溢出测试
    if (rcz > elim) { return -1; }
    // 如果 rcz 大于等于 alim，则进一步检查
    if (rcz >= alim) {
        rcz += log(aphi);
        if (iform == 2) { rcz -= 0.25*log(aarg) + aic; }
        if (rcz > elim) { return -1; }
    } else {
        /*  UNDERFLOW TEST  */
        // 检查是否需要进行下溢测试

        if (rcz >= -elim) {
            // 如果 rcz 大于等于 -elim，则继续判断

            if (rcz > -alim) {
                // 如果 rcz 大于 -alim，则返回 nuf
                return nuf;
            } else {
                // 否则执行以下操作

                rcz += log(aphi);
                // 将 rcz 增加 log(aphi)

                if (iform == 2) { rcz -= 0.25*log(aarg) + aic; }
                // 如果 iform 等于 2，则从 rcz 减去 0.25*log(aarg) + aic

                if (rcz > -elim) {
                    // 如果 rcz 大于 -elim，则继续执行

                    /* goto 30 */
                    // 转到标签 30 的位置

                    ascle = 1e3*d1mach[0] / tol;
                    // 计算 ascle 的值

                    cz += std::log(phi);
                    // cz 增加 std::log(phi)

                    if (iform != 1) { cz -= 0.25*log(arg) + aic;}
                    // 如果 iform 不等于 1，则从 cz 减去 0.25*log(arg) + aic

                    ax = exp(rcz) / tol;
                    // 计算 ax 的值

                    ay = std::imag(cz);
                    // 获取 cz 的虚部

                    cz = ax*std::exp(ay);
                    // 计算 cz 的新值

                    if (uchk(cz, ascle, tol)) {
                        // 如果 uchk 函数返回 true，则执行以下操作

                        for (int i = 0; i < nn; i++){ y[i] = 0.; }
                        // 将数组 y 的所有元素设置为 0

                        return nn;
                        // 返回 nn
                    }
                } else {
                    // 如果 rcz 不大于 -elim，则执行以下操作

                    for (int i = 0; i < nn; i++){ y[i] = 0.; }
                    // 将数组 y 的所有元素设置为 0

                    return nn;
                    // 返回 nn
                }
            }
        } else {
            // 如果 rcz 小于 -elim，则执行以下操作

            for (int i = 0; i < nn; i++){ y[i] = 0.; }
            // 将数组 y 的所有元素设置为 0

            return nn;
            // 返回 nn
        }
    }
    if ((ikflg == 2) || (n == 1)) { return nuf; }
    // 如果 ikflg 等于 2 或者 n 等于 1，则返回 nuf

    /* 140 */
    // 标签 140 处的代码

    while (1) {
        // 进入无限循环

        gnu = fnu + (nn -1);
        // 计算 gnu 的值

        if (iform != 2) {
            // 如果 iform 不等于 2，则执行以下操作

            init = 0;
            // 将 init 设置为 0

            unik(zr, gnu, ikflg, 1, tol, &init, &phi, &zeta1, &zeta2, &sum, &cwrk[0]);
            // 调用 unik 函数计算 phi, zeta1, zeta2, sum 等值

            cz = zeta2 - zeta1;
            // 计算 cz 的值为 zeta2 - zeta1
        } else {
            // 如果 iform 等于 2，则执行以下操作

            unhj(zn, gnu, 1, tol, &phi, &arg, &zeta1, &zeta2, &asum, &bsum);
            // 调用 unhj 函数计算 phi, arg, zeta1, zeta2, asum, bsum 等值

            cz = zeta2 - zeta1;
            // 计算 cz 的值为 zeta2 - zeta1

            aarg = std::abs(phi);
            // 计算 aarg 的值为 phi 的绝对值
        }

        if (kode == 2) { cz -= zb; }
        // 如果 kode 等于 2，则从 cz 减去 zb 的值

        /* 170 */
        // 标签 170 处的代码

        aphi = std::abs(phi);
        // 计算 aphi 的值为 phi 的绝对值

        rcz = std::real(cz);
        // 获取 cz 的实部

        if (rcz >= -elim) {
            // 如果 rcz 大于等于 -elim，则执行以下操作

            if (rcz > -alim) { return nuf; }
            // 如果 rcz 大于 -alim，则返回 nuf

            rcz += log(aphi);
            // 将 rcz 增加 log(aphi)

            if (iform == 2) { rcz -= 0.25*log(aarg) + aic; }
            // 如果 iform 等于 2，则从 rcz 减去 0.25*log(aarg) + aic

            if (rcz > -elim) {
                // 如果 rcz 大于 -elim，则执行以下操作

                ascle = 1e3 * d1mach[0] / tol;
                // 计算 ascle 的值

                cz = std::log(phi);
                // 计算 cz 的值为 std::log(phi)

                if (iform != 1) { cz -= 0.25*std::log(arg) + aic; }
                // 如果 iform 不等于 1，则从 cz 减去 0.25*std::log(arg) + aic

                ax = exp(rcz)/tol;
                // 计算 ax 的值

                ay = std::imag(cz);
                // 获取 cz 的虚部

                cz = ax*(cos(ay)+sin(ay*std::complex<double>(0, 1)));
                // 计算 cz 的新值

                if (!(uchk(cz, ascle, tol))) { return nuf; }
                // 如果 uchk 函数返回 false，则返回 nuf
            }
        }

        y[nn-1] = 0.;
        // 将数组 y 的第 nn-1 个元素设置为 0

        nn -= 1;
        // nn 减去 1

        nuf += 1;
        // nuf 增加 1

        if (nn == 0) { return nuf; }
        // 如果 nn 等于 0，则返回 nuf
    }
    // 结束无限循环

    return -1;
    // 返回 -1
}

inline int wrsk(
    std::complex<double> zr,                     // 输入参数：复数 zr
    double fnu,                                  // 输入参数：双精度数 fnu
    int kode,                                     // 输入参数：整数 kode
    int n,                                         // 输入参数：整数 n
    std::complex<double> *y,                    // 输入输出参数：复数数组 y
    std::complex<double> *cw,                   // 输入参数：复数数组 cw
    double tol,                                    // 输入参数：双精度数 tol
    double elim,                                  // 输入参数：双精度数 elim
    double alim                                   // 输入参数：双精度数 alim
) {

    //***BEGIN PROLOGUE  ZWRSK
    //***REFER TO  ZBESI,ZBESK
    //
    //     ZWRSK COMPUTES THE I BESSEL FUNCTION FOR RE(Z).GE.0.0 BY
    //     NORMALIZING THE I FUNCTION RATIOS FROM ZRATI BY THE WRONSKIAN
    //
    //***ROUTINES CALLED  D1MACH,ZBKNU,ZRATI,AZABS
    //***END PROLOGUE  ZWRSK

   std::complex<double> cinu, cscl, ct, c1, c2, rct, st;
   double act, acw, ascle, yy;
   int i, nw, nz;

    //
    // I(FNU+I-1,Z) BY BACKWARD RECURRENCE FOR RATIOS
    // Y(I)=I(FNU+I,Z)/I(FNU+I-1,Z) FROM CRATI NORMALIZED BY THE
    // WRONSKIAN WITH K(FNU,Z) AND K(FNU+1,Z) FROM CBKNU.
    //
    nz = 0;
    nw = bknu(zr, fnu, kode, 2, cw, tol, elim, alim);  // 调用 bknu 函数计算 K 函数，返回值存储在 nw 中
    if (nw != 0) {
        /* 50 */
        nz = -1;
        if (nw == -2) {
            nz = -2;
        }
        return nz;  // 若 nw 不为 0，则返回 nz，表示错误码
    }
    rati(zr, fnu, n, y, tol);  // 调用 rati 函数计算 I 函数的比率，结果存储在 y 数组中
    //
    // RECUR FORWARD ON I(FNU+1,Z) = R(FNU,Z)*I(FNU,Z),
    // R(FNU+J-1,Z)=Y(J),  J=1,...,N
    //
    cinu = 1.0;
    if (kode != 1) {
        yy = std::imag(zr);
        cinu = std::complex<double>(cos(yy), sin(yy));  // 如果 kode 不为 1，则计算复数 cinu
    }
    //
    // ON LOW EXPONENT MACHINES THE K FUNCTIONS CAN BE CLOSE TO BOTH THE
    // UNDER AND OVERFLOW LIMITS AND THE NORMALIZATION MUST BE SCALED TO
    // PREVENT OVER OR UNDERFLOW.  CUOIK HAS DETERMINED THAT THE RESULT
    // IS ON SCALE.
    //
    acw = std::abs(cw[1]);  // 计算复数数组 cw 的第二个元素的绝对值
    ascle = 1e3*d1mach[0]/tol;  // 根据机器精度和 tol 计算 ascle
    cscl = 1.0;

    if (acw <= ascle) {  // 根据 acw 和 ascle 的大小关系确定 cscl
        cscl = 1.0 / tol;
    } else {
        ascle = 1.0 / ascle;
        if (acw >= ascle) {
            cscl = tol;
        }
    }

    c1 = cw[0]*cscl;  // 计算 c1
    c2 = cw[1]*cscl;  // 计算 c2
    st = y[0];  // 初始化 st 为 y[0]
    //
    // CINU=CINU*(CONJG(CT)/ABS(CT))*(1.0_dp/ABS(CT) PREVENTS
    // UNDER- OR OVERFLOW PREMATURELY BY SQUARING ABS(CT)
    //
    ct = zr * (c2 + st*c1);  // 计算 ct
    act = std::abs(ct);  // 计算 ct 的绝对值
    rct = 1.0 / act;  // 计算 ct 的倒数的实部
    ct = conj(ct)*rct;  // 计算 ct 的共轭乘以它的倒数
    cinu *= ct*rct;  // 更新 cinu
    y[0] = cinu*cscl;  // 更新 y[0]
    if (n == 1) { return nz; }  // 如果 n 为 1，直接返回 nz
    for (i = 2; i < (n+1); i++) {
        cinu *= st;  // 循环更新 cinu
        st = y[i-1];  // 更新 st
        y[i-1] = cinu*cscl;  // 更新 y[i-1]
    }
    return nz;  // 返回 nz
}
}
}
```