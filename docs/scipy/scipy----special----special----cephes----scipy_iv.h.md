# `D:\src\scipysrc\scipy\scipy\special\special\cephes\scipy_iv.h`

```
/*
 * Translated into C++ by SciPy developers in 2024.
 * Original header with Copyright information appears below.
 */

/*
 * iv.c
 *
 * Modified Bessel function of noninteger order
 *
 * SYNOPSIS:
 *
 * double v, x, y, iv();
 *
 * y = iv( v, x );
 *
 * DESCRIPTION:
 *
 * Returns modified Bessel function of order v of the
 * argument.  If x is negative, v must be integer valued.
 */

/*
 * Parts of the code are copyright:
 *
 * Cephes Math Library Release 2.8:  June, 2000
 * Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
 *
 * And other parts:
 *
 * Copyright (c) 2006 Xiaogang Zhang
 * Use, modification and distribution are subject to the
 * Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole or
 * in part, and all derivative works of the Software, unless such copies or
 * derivative works are solely in the form of machine-executable object code
 * generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 * WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * And the rest are:
 *
 * Copyright (C) 2009 Pauli Virtanen
 * Distributed under the same license as Scipy.
 */

#pragma once

#include "../config.h"
#include "../error.h"

#include "const.h"
#include "gamma.h"
#include "trig.h"

namespace special {
namespace cephes {

} // namespace detail
    SPECFUN_HOST_DEVICE inline double iv(double v, double x) {
        // 用于存储符号的变量
        int sign;
        // 临时变量t、ax和结果变量res
        double t, ax, res;

        // 检查输入是否包含NaN，若包含则返回NaN
        if (std::isnan(v) || std::isnan(x)) {
            return std::numeric_limits<double>::quiet_NaN();
        }

        /* 如果 v 是负整数，调用对称性 */
        t = std::floor(v);
        if (v < 0.0) {
            // 如果 v 是负整数，则进行对称操作
            if (t == v) {
                v = -v; /* 对称性 */
                t = -t;
            }
        }
        /* 如果 x 是负数，要求 v 必须是整数 */
        sign = 1;
        if (x < 0.0) {
            // 如果 x 是负数，则要求 v 是整数
            if (t != v) {
                // 如果 v 不是整数，设置错误并返回NaN
                set_error("iv", SF_ERROR_DOMAIN, NULL);
                return (std::numeric_limits<double>::quiet_NaN());
            }
            if (v != 2.0 * std::floor(v / 2.0)) {
                // 如果 v 不是偶数，修改符号标志为-1
                sign = -1;
            }
        }

        /* 避免对数奇点 */
        if (x == 0.0) {
            if (v == 0.0) {
                // 当 v 和 x 都为0时，返回1
                return 1.0;
            }
            if (v < 0.0) {
                // 当 v 为负数时，设置错误并返回正无穷
                set_error("iv", SF_ERROR_OVERFLOW, NULL);
                return std::numeric_limits<double>::infinity();
            } else
                // 当 x 为0但 v 不为0时，返回0
                return 0.0;
        }

        ax = std::abs(x);
        if (std::abs(v) > 50) {
            /*
             * 对于大的阶数，使用统一的渐近展开。
             *
             * 这似乎比Boost实现的Temme方法稍晚溢出。
             */
            // 使用统一的渐近展开计算修正Bessel函数值
            detail::ikv_asymptotic_uniform(v, ax, &res, NULL);
        } else {
            /* 否则使用Temme的方法 */
            // 使用Temme方法计算修正Bessel函数值
            detail::ikv_temme(v, ax, &res, NULL);
        }
        // 根据符号标志修正结果并返回
        res *= sign;
        return res;
    }
} // namespace cephes
} // namespace special
```