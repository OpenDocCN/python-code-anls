# `D:\src\scipysrc\scipy\scipy\linalg\_cython_signature_generator.py`

```
"""
A script that uses f2py to generate the signature files used to make
the Cython BLAS and LAPACK wrappers from the fortran source code for
LAPACK and the reference BLAS.

To generate the BLAS wrapper signatures call:
python _cython_signature_generator.py blas <blas_directory> <out_file>

To generate the LAPACK wrapper signatures call:
python _cython_signature_generator.py lapack <lapack_src_directory> <out_file>

This script expects to be run on the source directory for
the oldest supported version of LAPACK (currently 3.4.0).
"""

# 导入必要的模块
import glob
import os
from numpy.f2py import crackfortran

# 定义Fortran类型到Cython类型的映射关系
sig_types = {'integer': 'int',
             'complex': 'c',
             'double precision': 'd',
             'real': 's',
             'complex*16': 'z',
             'double complex': 'z',
             'character': 'char',
             'logical': 'bint'}

# 根据变量信息和参数索引获取参数类型
def get_type(info, arg):
    argtype = sig_types[info['vars'][arg]['typespec']]
    if argtype == 'c' and info['vars'][arg].get('kindselector') is not None:
        argtype = 'z'
    return argtype

# 根据给定的Fortran文件生成函数签名
def make_signature(filename):
    info = crackfortran.crackfortran(filename)[0]
    name = info['name']
    if info['block'] == 'subroutine':
        return_type = 'void'
    else:
        return_type = get_type(info, name)
    arglist = [' *'.join([get_type(info, arg), arg]) for arg in info['args']]
    args = ', '.join(arglist)
    # 修正参数中的奇怪命名，替换掉 rank_bn 为 rank
    args = args.replace('rank_bn', 'rank')
    return f'{return_type} {name}({args})\n'

# 从一行获取函数签名的名称
def get_sig_name(line):
    return line.split('(')[0].split(' ')[-1]

# 从指定目录中的Fortran文件生成函数签名，并写入输出文件
def sigs_from_dir(directory, outfile, manual_wrappers=None, exclusions=None):
    if directory[-1] in ['/', '\\']:
        directory = directory[:-1]
    files = sorted(glob.glob(directory + '/*.f*'))
    if exclusions is None:
        exclusions = []
    if manual_wrappers is not None:
        exclusions += [get_sig_name(l) for l in manual_wrappers.split('\n')]
    signatures = []
    for filename in files:
        name = os.path.splitext(os.path.basename(filename))[0]
        if name in exclusions:
            continue
        signatures.append(make_signature(filename))
    if manual_wrappers is not None:
        signatures += [l + '\n' for l in manual_wrappers.split('\n')]
    signatures.sort(key=get_sig_name)
    comment = ["# This file was generated by _cython_signature_generator.py.\n",
               "# Do not edit this file directly.\n\n"]
    with open(outfile, 'w') as f:
        f.writelines(comment)
        f.writelines(signatures)

# 手动添加的函数签名，因为生成签名的函数无法处理函数指针参数的情况
# slamch 和 dlamch 不在 lapack 源目录中，但因已有 Python 包装器，我们也将包装它们。
# 其他手动签名用于生成签名时的特定排除功能。
# LAPACK 手动包装器字符串，包含多个 LAPACK 函数的声明
lapack_manual_wrappers = '''
void cgees(char *jobvs, char *sort, cselect1 *select, int *n, c *a, int *lda, int *sdim, c *w, c *vs, int *ldvs, c *work, int *lwork, s *rwork, bint *bwork, int *info)
void cgeesx(char *jobvs, char *sort, cselect1 *select, char *sense, int *n, c *a, int *lda, int *sdim, c *w, c *vs, int *ldvs, s *rconde, s *rcondv, c *work, int *lwork, s *rwork, bint *bwork, int *info)
void cgges(char *jobvsl, char *jobvsr, char *sort, cselect2 *selctg, int *n, c *a, int *lda, c *b, int *ldb, int *sdim, c *alpha, c *beta, c *vsl, int *ldvsl, c *vsr, int *ldvsr, c *work, int *lwork, s *rwork, bint *bwork, int *info)
void cggesx(char *jobvsl, char *jobvsr, char *sort, cselect2 *selctg, char *sense, int *n, c *a, int *lda, c *b, int *ldb, int *sdim, c *alpha, c *beta, c *vsl, int *ldvsl, c *vsr, int *ldvsr, s *rconde, s *rcondv, c *work, int *lwork, s *rwork, int *iwork, int *liwork, bint *bwork, int *info)
void dgees(char *jobvs, char *sort, dselect2 *select, int *n, d *a, int *lda, int *sdim, d *wr, d *wi, d *vs, int *ldvs, d *work, int *lwork, bint *bwork, int *info)
void dgeesx(char *jobvs, char *sort, dselect2 *select, char *sense, int *n, d *a, int *lda, int *sdim, d *wr, d *wi, d *vs, int *ldvs, d *rconde, d *rcondv, d *work, int *lwork, int *iwork, int *liwork, bint *bwork, int *info)
void dgges(char *jobvsl, char *jobvsr, char *sort, dselect3 *selctg, int *n, d *a, int *lda, d *b, int *ldb, int *sdim, d *alphar, d *alphai, d *beta, d *vsl, int *ldvsl, d *vsr, int *ldvsr, d *work, int *lwork, bint *bwork, int *info)
void dggesx(char *jobvsl, char *jobvsr, char *sort, dselect3 *selctg, char *sense, int *n, d *a, int *lda, d *b, int *ldb, int *sdim, d *alphar, d *alphai, d *beta, d *vsl, int *ldvsl, d *vsr, int *ldvsr, d *rconde, d *rcondv, d *work, int *lwork, int *iwork, int *liwork, bint *bwork, int *info)
d dlamch(char *cmach)
void ilaver(int *vers_major, int *vers_minor, int *vers_patch)
void sgees(char *jobvs, char *sort, sselect2 *select, int *n, s *a, int *lda, int *sdim, s *wr, s *wi, s *vs, int *ldvs, s *work, int *lwork, bint *bwork, int *info)
void sgeesx(char *jobvs, char *sort, sselect2 *select, char *sense, int *n, s *a, int *lda, int *sdim, s *wr, s *wi, s *vs, int *ldvs, s *rconde, s *rcondv, s *work, int *lwork, int *iwork, int *liwork, bint *bwork, int *info)
void sgges(char *jobvsl, char *jobvsr, char *sort, sselect3 *selctg, int *n, s *a, int *lda, s *b, int *ldb, int *sdim, s *alphar, s *alphai, s *beta, s *vsl, int *ldvsl, s *vsr, int *ldvsr, s *work, int *lwork, bint *bwork, int *info)
void sggesx(char *jobvsl, char *jobvsr, char *sort, sselect3 *selctg, char *sense, int *n, s *a, int *lda, s *b, int *ldb, int *sdim, s *alphar, s *alphai, s *beta, s *vsl, int *ldvsl, s *vsr, int *ldvsr, s *rconde, s *rcondv, s *work, int *lwork, int *iwork, int *liwork, bint *bwork, int *info)
s slamch(char *cmach)
'''
# 定义了一个接口函数 zgees，用于计算特征值问题，返回特征向量（若指定）
void zgees(char *jobvs, char *sort, zselect1 *select, int *n, z *a, int *lda, int *sdim, z *w, z *vs, int *ldvs, z *work, int *lwork, d *rwork, bint *bwork, int *info)

# 定义了一个扩展接口函数 zgeesx，支持更多的选项和控制参数
void zgeesx(char *jobvs, char *sort, zselect1 *select, char *sense, int *n, z *a, int *lda, int *sdim, z *w, z *vs, int *ldvs, d *rconde, d *rcondv, z *work, int *lwork, d *rwork, bint *bwork, int *info)

# 定义了一个接口函数 zgges，用于广义特征值问题，返回左右特征向量
void zgges(char *jobvsl, char *jobvsr, char *sort, zselect2 *selctg, int *n, z *a, int *lda, z *b, int *ldb, int *sdim, z *alpha, z *beta, z *vsl, int *ldvsl, z *vsr, int *ldvsr, z *work, int *lwork, d *rwork, bint *bwork, int *info)

# 定义了一个扩展接口函数 zggesx，支持更多的选项和控制参数
void zggesx(char *jobvsl, char *jobvsr, char *sort, zselect2 *selctg, char *sense, int *n, z *a, int *lda, z *b, int *ldb, int *sdim, z *alpha, z *beta, z *vsl, int *ldvsl, z *vsr, int *ldvsr, d *rconde, d *rcondv, z *work, int *lwork, d *rwork, int *iwork, int *liwork, bint *bwork, int *info)

# 排除特定的 BLAS 函数，因为它们未包含在 scipy 的 ABI 包装器中
blas_exclusions = ['scabs1', 'xerbla']

# 在 LAPACK 模块中排除具有字符串参数的例程，以避免与不同标准的字符串参数兼容性问题
if __name__ == '__main__':
    from sys import argv
    libname, src_dir, outfile = argv[1:]
    if libname.lower() == 'blas':
        # 从指定目录中提取 BLAS 函数签名，并写入输出文件，排除指定的函数
        sigs_from_dir(src_dir, outfile, exclusions=blas_exclusions)
    elif libname.lower() == 'lapack':
        # 从指定目录中提取 LAPACK 函数签名，并写入输出文件，使用手动包装器和排除列表
        sigs_from_dir(src_dir, outfile, manual_wrappers=lapack_manual_wrappers,
                      exclusions=lapack_exclusions)
```