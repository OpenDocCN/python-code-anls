# `D:\src\scipysrc\scipy\scipy\special\tests\test_lambertw.py`

```
# 导入 pytest 模块，用于运行测试
import pytest
# 导入 numpy 模块，并重命名为 np，用于数值计算
import numpy as np
# 从 numpy.testing 中导入断言函数，用于测试结果的验证
from numpy.testing import assert_, assert_equal, assert_array_almost_equal
# 从 scipy.special 模块中导入 lambertw 函数，用于进行 Lambert W 函数的计算
from scipy.special import lambertw
# 从 numpy 模块中导入一些常用的数学常数和函数
from numpy import nan, inf, pi, e, isnan, log, r_, array, complex128
# 从 scipy.special._testutils 模块中导入 FuncData 类，用于测试函数的数据管理

# 定义测试函数，测试 Lambert W 函数的各种输入情况
def test_values():
    # 断言当输入为 nan 时，lambertw 函数返回 nan
    assert_(isnan(lambertw(nan)))
    # 断言当输入为 inf 时，lambertw 函数返回实部为 inf 的复数
    assert_equal(lambertw(inf,1).real, inf)
    # 断言当输入为 inf 时，lambertw 函数返回虚部为 2*pi 的复数
    assert_equal(lambertw(inf,1).imag, 2*pi)
    # 断言当输入为 -inf 时，lambertw 函数返回实部为 inf 的复数
    assert_equal(lambertw(-inf,1).real, inf)
    # 断言当输入为 -inf 时，lambertw 函数返回虚部为 3*pi 的复数
    assert_equal(lambertw(-inf,1).imag, 3*pi)
    # 断言当输入为 1.0 时，lambertw 函数的结果等于 lambertw(1.0, 0)
    assert_equal(lambertw(1.), lambertw(1., 0))
    data = [
        (0,0, 0),  # 定义一个复数数据列表，包含实部和虚部为零的元组
        (0+0j,0, 0),  # 复数数据，实部虚部都为零
        (inf,0, inf),  # 复数数据，实部和虚部为无穷大
        (0,-1, -inf),  # 复数数据，实部为零，虚部为负一，结果为负无穷大
        (0,1, -inf),  # 复数数据，实部为零，虚部为一，结果为负无穷大
        (0,3, -inf),  # 复数数据，实部为零，虚部为三，结果为负无穷大
        (e,0, 1),  # 复数数据，实部为自然对数的底 e，虚部为零，结果为正一
        (1,0, 0.567143290409783873),  # 复数数据，实部为一，虚部为零，结果约为 0.567143290409783873
        (-pi/2,0, 1j*pi/2),  # 复数数据，实部为负 pi/2，虚部为零，结果为虚数单位乘以 pi/2
        (-log(2)/2,0, -log(2)),  # 复数数据，实部为负 log(2)/2，虚部为零，结果为负 log(2)
        (0.25,0, 0.203888354702240164),  # 复数数据，实部为 0.25，虚部为零，结果约为 0.203888354702240164
        (-0.25,0, -0.357402956181388903),  # 复数数据，实部为负 0.25，虚部为零，结果约为 -0.357402956181388903
        (-1./10000,0, -0.000100010001500266719),  # 复数数据，实部为负 1/10000，虚部为零，结果约为 -0.000100010001500266719
        (-0.25,-1, -2.15329236411034965),  # 复数数据，实部为负 0.25，虚部为负一，结果约为 -2.15329236411034965
        (0.25,-1, -3.00899800997004620-4.07652978899159763j),  # 复数数据，实部为 0.25，虚部为负一，结果为复数
        (-0.25,-1, -2.15329236411034965),  # 复数数据，实部为负 0.25，虚部为负一，结果约为 -2.15329236411034965
        (0.25,1, -3.00899800997004620+4.07652978899159763j),  # 复数数据，实部为 0.25，虚部为一，结果为复数
        (-0.25,1, -3.48973228422959210+7.41405453009603664j),  # 复数数据，实部为负 0.25，虚部为一，结果为复数
        (-4,0, 0.67881197132094523+1.91195078174339937j),  # 复数数据，实部为负四，虚部为零，结果为复数
        (-4,1, -0.66743107129800988+7.76827456802783084j),  # 复数数据，实部为负四，虚部为一，结果为复数
        (-4,-1, 0.67881197132094523-1.91195078174339937j),  # 复数数据，实部为负四，虚部为负一，结果为复数
        (1000,0, 5.24960285240159623),  # 复数数据，实部为一千，虚部为零，结果约为 5.24960285240159623
        (1000,1, 4.91492239981054535+5.44652615979447070j),  # 复数数据，实部为一千，虚部为一，结果为复数
        (1000,-1, 4.91492239981054535-5.44652615979447070j),  # 复数数据，实部为一千，虚部为负一，结果为复数
        (1000,5, 3.5010625305312892+29.9614548941181328j),  # 复数数据，实部为一千，虚部为五，结果为复数
        (3+4j,0, 1.281561806123775878+0.533095222020971071j),  # 复数数据，实部为三加四乘虚数单位，虚部为零，结果为复数
        (-0.4+0.4j,0, -0.10396515323290657+0.61899273315171632j),  # 复数数据，实部为负零点四加零点四乘虚数单位，虚部为零，结果为复数
        (3+4j,1, -0.11691092896595324+5.61888039871282334j),  # 复数数据，实部为三加四乘虚数单位，虚部为一，结果为复数
        (3+4j,-1, 0.25856740686699742-3.85211668616143559j),  # 复数数据，实部为三加四乘虚数单位，虚部为负一，结果为复数
        (-0.5,-1, -0.794023632344689368-0.770111750510379110j),  # 复数数据，实部为负零点五，虚部为负一，结果为复数
        (-1./10000,1, -11.82350837248724344+6.80546081842002101j),  # 复数数据，实部为负一分之一万，虚部为一，结果为复数
        (-1./10000,-1, -11.6671145325663544),  # 复数数据，实部为负一分之一万，虚部为负一，结果约为 -11.6671145325663544
        (-1./10000,-2, -11.82350837248724344-6.80546081842002101j),  # 复数数据，实部为负一分之一万，虚部为负二，结果为复数
        (-1./100000,4, -14.9186890769540539+26.1856750178782046j),  # 复数数据，实部为负一分之十万，虚部为四，结果为复数
        (-1./100000,5, -15.0931437726379218666+32.5525721210262290086j),  # 复数数据，实部为负一分之十万，虚部为五，结果为复数
        ((2+1j)/10,0, 0.173704503762911669+0.071781336752835511j),  # 复数数据，实部为（二加虚数单位）除以十，虚部为零，结果为复数
        ((2+1j)/10,1, -3.21746028349820063+4.56175438896292539j),  # 复数数据，实部为（二加虚数单位）除以十，虚部为一，结果为复数
        ((2+1j)/10,-1, -3.03781405002993088-3.53946629633505737j),  # 复数数据，实部为（二加虚数单位）除以十，虚部为负一，结果为复数
        ((2+1j)/10,4, -4.6878509692773249+23.8313630697683291j),  # 复数数据
# 定义一个测试函数 test_ufunc，用于测试 lambertw 函数的近似数组是否准确
def test_ufunc():
    # 使用 assert_array_almost_equal 检查 lambertw 函数计算结果与预期结果的近似程度
    assert_array_almost_equal(
        lambertw(r_[0., e, 1.]), r_[0., 1., 0.567143290409783873])


# 定义一个测试函数 test_lambertw_ufunc_loop_selection，用于测试 lambertw 函数在循环选择上的行为
def test_lambertw_ufunc_loop_selection():
    # 查看 https://github.com/scipy/scipy/issues/4895 获取更多信息
    # 定义复数类型 dt 为 np.complex128
    dt = np.dtype(np.complex128)
    # 使用 assert_equal 检查 lambertw 函数对不同参数组合的输出数据类型是否与预期的复数类型 dt 相同
    assert_equal(lambertw(0, 0, 0).dtype, dt)
    assert_equal(lambertw([0], 0, 0).dtype, dt)
    assert_equal(lambertw(0, [0], 0).dtype, dt)
    assert_equal(lambertw(0, 0, [0]).dtype, dt)
    assert_equal(lambertw([0], [0], [0]).dtype, dt)


# 使用 pytest.mark.parametrize 标记测试用例，参数化输入 z 的多个子正常值进行测试
@pytest.mark.parametrize('z', [1e-316, -2e-320j, -5e-318+1e-320j])
def test_lambertw_subnormal_k0(z):
    # 验证在分支 k=0 下，对子正常输入的处理是否正确（gh-16291 的回归测试）
    # 计算 lambertw(z)
    w = lambertw(z)
    # 对于这么小的数值，可以确信数值上 lambertw(z) 等于 z
    assert w == z
```