# `D:\src\scipysrc\scipy\scipy\sparse\linalg\_dsolve\SuperLU\SRC\zgsisx.c`

```
/*! \file
Copyright (c) 2003, The Regents of the University of California, through
Lawrence Berkeley National Laboratory (subject to receipt of any required 
approvals from U.S. Dept. of Energy) 

All rights reserved. 

The source code is distributed under BSD license, see the file License.txt
at the top-level directory.
*/

/*! @file zgsisx.c
 * \brief Computes an approximate solutions of linear equations A*X=B or A'*X=B
 *
 * <pre>
 * -- SuperLU routine (version 4.2) --
 * Lawrence Berkeley National Laboratory.
 * November, 2010
 * August, 2011
 * </pre>
 */
#include "slu_zdefs.h"

/**
 * \brief Solves systems of linear equations A*X=B or A'*X=B using SuperLU routines.
 *
 * This function computes an approximate solution of the linear equations A*X=B or A'*X=B.
 * It includes various computational steps and options for matrix equilibration and
 * factorization using SuperLU's capabilities.
 *
 * \param options       Options controlling the solution process.
 * \param A             Pointer to the coefficient matrix A.
 * \param perm_c        Column permutation vector.
 * \param perm_r        Row permutation vector.
 * \param etree         Elimination tree of A'*A or A*A, generated by symbolic factorization.
 * \param equed         Specifies the form of equilibration applied to A. ('N', 'R', 'C', or 'B')
 * \param R             Row scale factors for equilibration.
 * \param C             Column scale factors for equilibration.
 * \param L             Pointer to the factor L from the factorization A = P*L*U.
 * \param U             Pointer to the factor U from the factorization A = P*L*U.
 * \param work          Workspace array.
 * \param lwork         Length of the work array.
 * \param B             Right-hand side matrix B.
 * \param X             On entry, the right-hand side matrix B; on exit, the solution matrix X.
 * \param recip_pivot_growth Reciprocal pivot growth factor.
 * \param rcond         Reciprocal condition number estimate.
 * \param Glu           Pointer to the data structure for SuperLU internal data.
 * \param mem_usage     Memory usage statistics.
 * \param stat          SuperLU statistics.
 * \param info          Output status: 0 on successful exit, <0 if an error occurred.
 */
void
zgsisx(superlu_options_t *options, SuperMatrix *A, int *perm_c, int *perm_r,
       int *etree, char *equed, double *R, double *C,
       SuperMatrix *L, SuperMatrix *U, void *work, int_t lwork,
       SuperMatrix *B, SuperMatrix *X,
       double *recip_pivot_growth, double *rcond,
       GlobalLU_t *Glu, mem_usage_t *mem_usage, SuperLUStat_t *stat, int_t *info)
{
    DNformat  *Bstore, *Xstore;
    doublecomplex    *Bmat, *Xmat;
    int       ldb, ldx, nrhs, n;
    SuperMatrix *AA; /* A in SLU_NC format used by the factorization routine. */
    SuperMatrix AC; /* Matrix postmultiplied by Pc */
    int       colequ, equil, nofact, notran, rowequ, permc_spec, mc64;
    trans_t   trant;
    char      norm[1];
    int_t     i, j;
    double    amax, anorm, bignum, smlnum, colcnd, rowcnd, rcmax, rcmin;
    int       relax, panel_size, info1;
    double    t0;      /* temporary time */
    double    *utime;

    int *perm = NULL; /* permutation returned from MC64 */

    /* External functions */
    extern double zlangs(char *, SuperMatrix *);

    Bstore = B->Store;
    Xstore = X->Store;
    Bmat   = Bstore->nzval;
    Xmat   = Xstore->nzval;
    ldb    = Bstore->lda;
    ldx    = Xstore->lda;
    nrhs   = B->ncol;
    n      = B->nrow;

    *info = 0;
    nofact = (options->Fact != FACTORED);
    equil = (options->Equil == YES);
    notran = (options->Trans == NOTRANS);
    mc64 = (options->RowPerm == LargeDiag_MC64);
    if ( nofact ) {
        *(unsigned char *)equed = 'N';
        rowequ = FALSE;
        colequ = FALSE;
    } else {
        rowequ = strncmp(equed, "R", 1)==0 || strncmp(equed, "B", 1)==0;
        colequ = strncmp(equed, "C", 1)==0 || strncmp(equed, "B", 1)==0;
        smlnum = dmach("Safe minimum");  /* lamch_("Safe minimum"); */
        bignum = 1. / smlnum;
    }

    /* Test the input parameters */
    if (options->Fact != DOFACT && options->Fact != SamePattern &&
        options->Fact != SamePattern_SameRowPerm &&
        options->Fact != FACTORED &&
        options->Trans != NOTRANS && options->Trans != TRANS && 
        options->Trans != CONJ &&
        options->Equil != NO && options->Equil != YES)
    {
        *info = -1;
    }
    else if ( A->nrow != A->ncol || A->nrow < 0 ||
              (A->Stype != SLU_NC && A->Stype != SLU_NR) ||
              A->Dtype != SLU_Z || A->Mtype != SLU_GE )
    {
        *info = -2;
    }
    // 如果选项指定 FACTORED 并且未进行行或列置换或未指定 equed 为 "N"
    else if ( options->Fact == FACTORED &&
         !(rowequ || colequ || strncmp(equed, "N", 1)==0) )
    *info = -6; // 设置错误代码为 -6

    else {
    if (rowequ) {
        rcmin = bignum; // 设置 rcmin 初始值为极大值
        rcmax = 0.; // 设置 rcmax 初始值为 0
        for (j = 0; j < A->nrow; ++j) {
        rcmin = SUPERLU_MIN(rcmin, R[j]); // 计算 R[j] 的最小值
        rcmax = SUPERLU_MAX(rcmax, R[j]); // 计算 R[j] 的最大值
        }
        if (rcmin <= 0.) *info = -7; // 如果 rcmin 小于等于 0，则设置错误代码为 -7
        else if ( A->nrow > 0)
        rowcnd = SUPERLU_MAX(rcmin,smlnum) / SUPERLU_MIN(rcmax,bignum); // 计算行条件数
        else rowcnd = 1.;
    }
    if (colequ && *info == 0) {
        rcmin = bignum; // 设置 rcmin 初始值为极大值
        rcmax = 0.; // 设置 rcmax 初始值为 0
        for (j = 0; j < A->nrow; ++j) {
        rcmin = SUPERLU_MIN(rcmin, C[j]); // 计算 C[j] 的最小值
        rcmax = SUPERLU_MAX(rcmax, C[j]); // 计算 C[j] 的最大值
        }
        if (rcmin <= 0.) *info = -8; // 如果 rcmin 小于等于 0，则设置错误代码为 -8
        else if (A->nrow > 0)
        colcnd = SUPERLU_MAX(rcmin,smlnum) / SUPERLU_MIN(rcmax,bignum); // 计算列条件数
        else colcnd = 1.;
    }
    if (*info == 0) {
        if ( lwork < -1 ) *info = -12; // 如果 lwork 小于 -1，则设置错误代码为 -12
        else if ( B->ncol < 0 || Bstore->lda < SUPERLU_MAX(0, A->nrow) ||
              B->Stype != SLU_DN || B->Dtype != SLU_Z || 
              B->Mtype != SLU_GE )
        *info = -13; // 设置错误代码为 -13
        else if ( X->ncol < 0 || Xstore->lda < SUPERLU_MAX(0, A->nrow) ||
              (B->ncol != 0 && B->ncol != X->ncol) ||
              X->Stype != SLU_DN ||
              X->Dtype != SLU_Z || X->Mtype != SLU_GE )
        *info = -14; // 设置错误代码为 -14
    }
    }
    if (*info != 0) {
    int ii = -(*info);
    input_error("zgsisx", &ii); // 报告输入错误，使用错误代码 ii
    return; // 返回
    }

    /* Initialization for factor parameters */
    panel_size = sp_ienv(1); // 设置 panel_size 为 sp_ienv(1) 返回的值
    relax      = sp_ienv(2); // 设置 relax 为 sp_ienv(2) 返回的值

    utime = stat->utime; // 设置 utime 为 stat 结构体中的 utime 值

    /* Convert A to SLU_NC format when necessary. */
    if ( A->Stype == SLU_NR ) {
    NRformat *Astore = A->Store; // 获取 A 的 NRformat 存储格式
    AA = (SuperMatrix *) SUPERLU_MALLOC( sizeof(SuperMatrix) ); // 分配内存给 AA
    zCreate_CompCol_Matrix(AA, A->ncol, A->nrow, Astore->nnz,
                   Astore->nzval, Astore->colind, Astore->rowptr,
                   SLU_NC, A->Dtype, A->Mtype); // 创建 SLU_NC 格式的复合列压缩矩阵 AA
    if ( notran ) { /* Reverse the transpose argument. */
        trant = TRANS; // 设置 trant 为 TRANS
        notran = 0; // 设置 notran 为 0
    } else {
        trant = NOTRANS; // 设置 trant 为 NOTRANS
        notran = 1; // 设置 notran 为 1
    }
    } else { /* A->Stype == SLU_NC */
    trant = options->Trans; // 设置 trant 为选项中的 Trans
    AA = A; // AA 指向 A
    }

    if ( nofact ) {
    register int i, j; // 注册变量 i, j
    NCformat *Astore = AA->Store; // 获取 AA 的 NCformat 存储格式
    int_t nnz = Astore->nnz; // 获取非零元素个数
    int_t *colptr = Astore->colptr; // 列指针数组
    int_t *rowind = Astore->rowind; // 行索引数组
    doublecomplex *nzval = (doublecomplex *)Astore->nzval; // 非零值数组
    if ( mc64 ) {
        // 如果 mc64 不为零，则进行以下操作
        t0 = SuperLU_timer_();
        // 记录当前时间，用于计时

        // 分配空间给排列数组 perm
        if ((perm = int32Malloc(n)) == NULL)
        ABORT("SUPERLU_MALLOC fails for perm[]");
        // 如果分配失败，则终止程序并输出错误信息

        // 使用 zldperm 函数进行列排列和对角元缩放
        info1 = zldperm(5, n, nnz, colptr, rowind, nzval, perm, R, C);

        // 如果 zldperm 执行失败，设置 mc64 为零，并释放 perm 数组
        if (info1 != 0) { /* MC64 fails, call zgsequ() later */
        mc64 = 0;
        SUPERLU_FREE(perm);
        perm = NULL;
        } else {
            // 如果 zldperm 成功，则根据 equil 的值进行对角元缩放
            if ( equil ) {
                rowequ = colequ = 1;
                // 对 R 和 C 中的每个元素取指数
                for (i = 0; i < n; i++) {
                    R[i] = exp(R[i]);
                    C[i] = exp(C[i]);
                }
                // 缩放矩阵
                for (j = 0; j < n; j++) {
                    for (i = colptr[j]; i < colptr[j + 1]; i++) {
                        // 对矩阵中的每个非零元素进行缩放
                        zd_mult(&nzval[i], &nzval[i], R[rowind[i]] * C[j]);
                    }
                }
                // 设置 equed 为 'B'，表示使用了 both 缩放
                *equed = 'B';
            }

            // 使用 perm 数组对矩阵进行列排列
            for (j = 0; j < n; j++) {
                for (i = colptr[j]; i < colptr[j + 1]; i++) {
                    // 重排列行索引数组 rowind
                    rowind[i] = perm[rowind[i]];
                }
            }
        }
        // 计算操作的时间并记录到 utime[EQUIL] 中
        utime[EQUIL] = SuperLU_timer_() - t0;
    }

    // 如果 mc64 为零并且 equil 为真，则只进行对角元缩放，不进行行排列
    if ( mc64==0 && equil ) { /* Only perform equilibration, no row perm */
        t0 = SuperLU_timer_();
        // 记录当前时间，用于计时

        // 计算行和列的缩放因子，使矩阵 A 变为等比例矩阵
        zgsequ(AA, R, C, &rowcnd, &colcnd, &amax, &info1);

        // 如果计算成功，则根据 equed 的值进行矩阵的等比例化
        if ( info1 == 0 ) {
            // 等比例化矩阵 AA
            zlaqgs(AA, R, C, rowcnd, colcnd, amax, equed);
            // 检查 equed 的值，确定是否进行行和列的等比例化
            rowequ = strncmp(equed, "R", 1)==0 || strncmp(equed, "B", 1)==0;
            colequ = strncmp(equed, "C", 1)==0 || strncmp(equed, "B", 1)==0;
        }
        // 计算操作的时间并记录到 utime[EQUIL] 中
        utime[EQUIL] = SuperLU_timer_() - t0;
    }
    }


    // 如果 nofact 为真，则进行矩阵的预处理和 LU 分解
    if ( nofact ) {
    
    t0 = SuperLU_timer_();
    // 记录当前时间，用于计时

    /*
     * 根据 permc_spec 进行列的排列，得到列排列向量 perm_c[]：
     *   permc_spec = NATURAL:  自然顺序
     *   permc_spec = MMD_AT_PLUS_A: 结构 A'+A 的最小度排序
     *   permc_spec = MMD_ATA:  结构 A'*A 的最小度排序
     *   permc_spec = COLAMD:   近似最小度列排序
     *   permc_spec = MY_PERMC: 已提供的自定义排序在 perm_c[] 中
     */
    permc_spec = options->ColPerm;
    // 如果 permc_spec 不是 MY_PERMC 并且 options->Fact 是 DOFACT，根据 permc_spec 获取 perm_c
    if ( permc_spec != MY_PERMC && options->Fact == DOFACT )
        get_perm_c(permc_spec, AA, perm_c);
    // 计算操作的时间并记录到 utime[COLPERM] 中
    utime[COLPERM] = SuperLU_timer_() - t0;

    t0 = SuperLU_timer_();
    // 记录当前时间，用于计时

    // 预处理步骤，计算列向量 perm_c 的 etree，得到因子化矩阵 AC
    sp_preorder(options, AA, perm_c, etree, &AC);
    // 计算操作的时间并记录到 utime[ETREE] 中
    utime[ETREE] = SuperLU_timer_() - t0;

    /* 计算矩阵 A*Pc 的 LU 分解 */
    t0 = SuperLU_timer_();
    // 记录当前时间，用于计时
    zgsitrf(options, &AC, relax, panel_size, etree, work, lwork,
                perm_c, perm_r, L, U, Glu, stat, info);
    // 计算操作的时间并记录到 utime[FACT] 中
    utime[FACT] = SuperLU_timer_() - t0;

    // 如果 lwork 为 -1，则记录内存使用情况并返回
    if ( lwork == -1 ) {
        mem_usage->total_needed = *info - A->ncol;
        return;
    }
    if ( mc64 ) { /* Fold MC64's perm[] into perm_r[]. */
        // 如果使用了MC64的重排序结果，将MC64的perm[]数组折叠到perm_r[]数组中

        NCformat *Astore = AA->Store;
        int_t nnz = Astore->nnz, *rowind = Astore->rowind;
        int *perm_tmp, *iperm;

        // 分配内存给perm_tmp[]数组
        if ((perm_tmp = int32Malloc(2*n)) == NULL)
            ABORT("SUPERLU_MALLOC fails for perm_tmp[]");

        iperm = perm_tmp + n;

        // 将原始perm[]数组根据perm_r[]重新排序存入perm_tmp[]数组
        for (i = 0; i < n; ++i)
            perm_tmp[i] = perm_r[perm[i]];

        // 更新perm_r[]和iperm[]数组
        for (i = 0; i < n; ++i) {
            perm_r[i] = perm_tmp[i];
            iperm[perm[i]] = i;
        }

        // 还原A矩阵的行索引到原始排序
        for (i = 0; i < nnz; ++i)
            rowind[i] = iperm[rowind[i]];

        SUPERLU_FREE(perm); /* MC64 permutation */
        SUPERLU_FREE(perm_tmp);
    }
    }

    if ( options->PivotGrowth ) {
        if ( *info > 0 ) return;

        // 计算倒数的主元增长因子*recip_pivot_growth
        *recip_pivot_growth = zPivotGrowth(A->ncol, AA, perm_c, L, U);
    }

    if ( options->ConditionNumber ) {
        // 估算矩阵A的条件数的倒数
        t0 = SuperLU_timer_();
        if ( notran ) {
            *(unsigned char *)norm = '1';
        } else {
            *(unsigned char *)norm = 'I';
        }
        anorm = zlangs(norm, AA);
        zgscon(norm, L, U, anorm, rcond, stat, &info1);
        utime[RCOND] = SuperLU_timer_() - t0;
    }

    if ( nrhs > 0 ) { /* Solve the system */

        // 如果有右手边向量需要求解

        /* Scale and permute the right-hand side if equilibration
           and permutation from MC64 were performed. */
        if ( notran ) {
            if ( rowequ ) {
                // 如果进行了行等价化，对右手边向量进行缩放和置换
                for (j = 0; j < nrhs; ++j)
                    for (i = 0; i < n; ++i)
                        zd_mult(&Bmat[i+j*ldb], &Bmat[i+j*ldb], R[i]);
            }
        } else if ( colequ ) {
            // 如果进行了列等价化，对右手边向量进行缩放和置换
            for (j = 0; j < nrhs; ++j)
                for (i = 0; i < n; ++i) {
                    zd_mult(&Bmat[i+j*ldb], &Bmat[i+j*ldb], C[i]);
                }
        }

        // 复制右手边向量Bmat到解向量Xmat
        for (j = 0; j < nrhs; j++)  /* Save a copy of the right hand sides */
            for (i = 0; i < B->nrow; i++)
                Xmat[i + j*ldx] = Bmat[i + j*ldb];

        t0 = SuperLU_timer_();
        // 调用求解函数zgstrs求解线性系统
        zgstrs (trant, L, U, perm_c, perm_r, X, stat, &info1);
        utime[SOLVE] = SuperLU_timer_() - t0;

        // 将解向量Xmat转换为原始系统的解
        if ( notran ) {
            if ( colequ ) {
                // 如果进行了列等价化，对解向量进行逆操作
                for (j = 0; j < nrhs; ++j)
                    for (i = 0; i < n; ++i) {
                        zd_mult(&Xmat[i+j*ldx], &Xmat[i+j*ldx], C[i]);
                    }
            }
        } else { /* transposed system */
            if ( rowequ ) {
                // 如果进行了行等价化，对解向量进行逆操作
                for (j = 0; j < nrhs; ++j)
                    for (i = 0; i < A->nrow; ++i) {
                        zd_mult(&Xmat[i+j*ldx], &Xmat[i+j*ldx], R[i]);
                    }
            }
        }

    } /* end if nrhs > 0 */

    if ( options->ConditionNumber ) {
        // 如果需要计算条件数
        /* The matrix is singular to working precision. */
        // 如果矩阵在工作精度下是奇异的
        if ( *rcond < dmach("E") && *info == 0) *info = A->ncol + 1;
    }

    if ( nofact ) {
    # 调用 ilu_zQuerySpace 函数，计算 ILU 预处理后使用的空间
    ilu_zQuerySpace(L, U, mem_usage);
    
    # 销毁类型为 CompCol_Permuted 的稀疏矩阵 AC
    Destroy_CompCol_Permuted(&AC);
    }
    
    # 如果矩阵 A 的存储类型为 SLU_NR（非规则稠密存储）
    if ( A->Stype == SLU_NR ) {
        # 销毁 SuperMatrix 类型的对象 AA 的存储空间
        Destroy_SuperMatrix_Store(AA);
        # 释放 SuperMatrix 对象 AA 占用的内存空间
        SUPERLU_FREE(AA);
    }
}



# 这是代码块的结尾，表示一个代码块的结束。在这种情况下，它表示一个函数或者其他控制流结构（如循环、条件语句）的结束。
```