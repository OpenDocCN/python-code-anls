# `D:\src\scipysrc\scipy\scipy\linalg\_generate_pyx.py`

```
# 定义脚本的目的是生成 Cython BLAS 和 LAPACK 包装器
# 使用 argparse 库来处理命令行参数
# 使用 importlib.util 导入模块并加载外部 Python 文件
# 使用 os 模块来进行路径操作和环境变量处理

import argparse
import importlib.util
import os


def import_wrappers_common():
    # 定义 _wrappers_common_path 变量，指向 _wrappers_common.py 文件的路径
    _wrappers_common_path = os.path.join(
        os.path.dirname(__file__),
        '..', '_build_utils', '_wrappers_common.py'
    )
    # 根据 _wrappers_common.py 文件路径创建导入模块的规范对象
    spec = importlib.util.spec_from_file_location(
        '_wrappers_common', _wrappers_common_path
    )
    # 根据规范对象加载模块并执行，得到 mod 对象
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod


# 导入 _wrappers_common.py 中定义的模块级变量和函数
_wrappers_common = import_wrappers_common()

# 从 _wrappers_common 中导入常量和函数
C_PREAMBLE = _wrappers_common.C_PREAMBLE
C_TYPES = _wrappers_common.C_TYPES
CPP_GUARD_BEGIN = _wrappers_common.CPP_GUARD_BEGIN
CPP_GUARD_END = _wrappers_common.CPP_GUARD_END
LAPACK_DECLS = _wrappers_common.LAPACK_DECLS
NPY_TYPES = _wrappers_common.NPY_TYPES
WRAPPED_FUNCS = _wrappers_common.WRAPPED_FUNCS
all_newer = _wrappers_common.all_newer
get_blas_macro_and_name = _wrappers_common.get_blas_macro_and_name
read_signatures = _wrappers_common.read_signatures
write_files = _wrappers_common.write_files

# 获取当前脚本文件的绝对路径
BASE_DIR = os.path.abspath(os.path.dirname(__file__))

# 定义注释文本，描述当前文件由哪个脚本生成，禁止直接编辑
COMMENT_TEXT = [f"This file was generated by {os.path.basename(__file__)}.\n",
                "Do not edit this file directly.\n"]

# 定义 BLAS 包装器文件的起始部分
blas_pyx_preamble = '''# cython: boundscheck = False
# cython: wraparound = False
# cython: cdivision = True

"""
BLAS Functions for Cython
=========================

Usable from Cython via::

    cimport scipy.linalg.cython_blas

These wrappers do not check for alignment of arrays.
Alignment should be checked before these wrappers are used.

If using ``cdotu``, ``cdotc``, ``zdotu``, ``zdotc``, ``sladiv``, or ``dladiv``,
the ``CYTHON_CCOMPLEX`` define must be set to 0 during compilation. For
example, in a ``meson.build`` file when using Meson::

    py.extension_module('ext_module'
        'ext_module.pyx',
        c_args: ['-DCYTHON_CCOMPLEX=0'],
        ...
    )

Raw function pointers (Fortran-style pointer arguments):

- {}


"""

# 在 SciPy 中，可以通过相对或绝对 cimport 使用这些包装器
# 例如：
# from ..linalg cimport cython_blas
# from scipy.linalg cimport cython_blas
# cimport scipy.linalg.cython_blas as cython_blas
# cimport ..linalg.cython_blas as cython_blas

# 在 SciPy 中，如果需要在 C/C++/Fortran 中使用 BLAS 函数，
# 不应使用这些包装器，而应直接链接原始库。

cdef extern from "fortran_defs.h":
    pass

from numpy cimport npy_complex64, npy_complex128

'''

# 定义 LAPACK 包装器文件的起始部分
lapack_pyx_preamble = '''"""
LAPACK functions for Cython
===========================

Usable from Cython via::

    cimport scipy.linalg.cython_lapack




注释：
'''
This module provides Cython-level wrappers for all primary routines included
in LAPACK 3.4.0 except for ``zcgesv`` since its interface is not consistent
from LAPACK 3.4.0 to 3.6.0. It also provides some of the
fixed-api auxiliary routines.

These wrappers do not check for alignment of arrays.
Alignment should be checked before these wrappers are used.

Raw function pointers (Fortran-style pointer arguments):

- {}

"""

# Within SciPy, these wrappers can be used via relative or absolute cimport.
# Examples:
# from ..linalg cimport cython_lapack
# from scipy.linalg cimport cython_lapack
# cimport scipy.linalg.cython_lapack as cython_lapack
# cimport ..linalg.cython_lapack as cython_lapack

# Within SciPy, if LAPACK functions are needed in C/C++/Fortran,
# these wrappers should not be used.
# The original libraries should be linked directly.

cdef extern from "fortran_defs.h":
    pass

from numpy cimport npy_complex64, npy_complex128

cdef extern from "_lapack_subroutines.h":
    # Function pointer type declarations for
    # gees and gges families of functions.
    ctypedef bint _cselect1(npy_complex64*)
    ctypedef bint _cselect2(npy_complex64*, npy_complex64*)
    ctypedef bint _dselect2(d*, d*)
    ctypedef bint _dselect3(d*, d*, d*)
    ctypedef bint _sselect2(s*, s*)
    ctypedef bint _sselect3(s*, s*, s*)
    ctypedef bint _zselect1(npy_complex128*)
    ctypedef bint _zselect2(npy_complex128*, npy_complex128*)

'''

blas_py_wrappers = """

# Python-accessible wrappers for testing:

cdef inline bint _is_contiguous(double[:,:] a, int axis) noexcept nogil:
    # Check if the array 'a' is contiguous along the specified axis
    return (a.strides[axis] == sizeof(a[0,0]) or a.shape[axis] == 1)

cpdef float complex _test_cdotc(float complex[:] cx, float complex[:] cy) noexcept nogil:
    # Compute the conjugate dot product of two complex arrays cx and cy
    cdef:
        int n = cx.shape[0]
        int incx = cx.strides[0] // sizeof(cx[0])
        int incy = cy.strides[0] // sizeof(cy[0])
    return cdotc(&n, &cx[0], &incx, &cy[0], &incy)

cpdef float complex _test_cdotu(float complex[:] cx, float complex[:] cy) noexcept nogil:
    # Compute the unconjugated dot product of two complex arrays cx and cy
    cdef:
        int n = cx.shape[0]
        int incx = cx.strides[0] // sizeof(cx[0])
        int incy = cy.strides[0] // sizeof(cy[0])
    return cdotu(&n, &cx[0], &incx, &cy[0], &incy)

cpdef double _test_dasum(double[:] dx) noexcept nogil:
    # Compute the sum of the absolute values of elements in a double array dx
    cdef:
        int n = dx.shape[0]
        int incx = dx.strides[0] // sizeof(dx[0])
    return dasum(&n, &dx[0], &incx)

cpdef double _test_ddot(double[:] dx, double[:] dy) noexcept nogil:
    # Compute the dot product of two double arrays dx and dy
    cdef:
        int n = dx.shape[0]
        int incx = dx.strides[0] // sizeof(dx[0])
        int incy = dy.strides[0] // sizeof(dy[0])
    return ddot(&n, &dx[0], &incx, &dy[0], &incy)

cpdef int _test_dgemm(double alpha, double[:,:] a, double[:,:] b, double beta,
                double[:,:] c) except -1 nogil:
    # Perform a matrix-matrix multiplication c = alpha * a * b + beta * c
    cdef:
        char *transa
        char *transb
        int m, n, k, lda, ldb, ldc
        double *a0=&a[0,0]
        double *b0=&b[0,0]
        double *c0=&c[0,0]
    # 如果 c 是 C 连续的情况下，交换 a 和 b，并且交换它们是否转置。
    # 这是因为 a.dot(b) = b.T.dot(a.T).T。
    if _is_contiguous(c, 1):
        # 如果 a 是 C 连续的
        if _is_contiguous(a, 1):
            transb = 'n'  # 不转置 b
            ldb = (&a[1,0]) - a0 if a.shape[0] > 1 else 1  # 计算 ldb
        # 如果 a 是 Fortran 连续的
        elif _is_contiguous(a, 0):
            transb = 't'  # 转置 b
            ldb = (&a[0,1]) - a0 if a.shape[1] > 1 else 1  # 计算 ldb
        else:
            with gil:
                raise ValueError("Input 'a' is neither C nor Fortran contiguous.")
        # 如果 b 是 C 连续的
        if _is_contiguous(b, 1):
            transa = 'n'  # 不转置 a
            lda = (&b[1,0]) - b0 if b.shape[0] > 1 else 1  # 计算 lda
        # 如果 b 是 Fortran 连续的
        elif _is_contiguous(b, 0):
            transa = 't'  # 转置 a
            lda = (&b[0,1]) - b0 if b.shape[1] > 1 else 1  # 计算 lda
        else:
            with gil:
                raise ValueError("Input 'b' is neither C nor Fortran contiguous.")
        # 获取 b 的行数作为 k
        k = b.shape[0]
        # 检查 k 是否等于 a 的列数
        if k != a.shape[1]:
            with gil:
                raise ValueError("Shape mismatch in input arrays.")
        # 获取 b 的列数作为 m
        m = b.shape[1]
        # 获取 a 的行数作为 n
        n = a.shape[0]
        # 检查 n 和 m 是否和 c 的形状匹配
        if n != c.shape[0] or m != c.shape[1]:
            with gil:
                raise ValueError("Output array does not have the correct shape.")
        # 计算 ldc
        ldc = (&c[1,0]) - c0 if c.shape[0] > 1 else 1
        # 调用底层 BLAS 函数 dgemm 进行矩阵乘法
        dgemm(transa, transb, &m, &n, &k, &alpha, b0, &lda, a0,
                   &ldb, &beta, c0, &ldc)
    # 如果 c 是 Fortran 连续的情况下
    elif _is_contiguous(c, 0):
        # 如果 a 是 C 连续的
        if _is_contiguous(a, 1):
            transa = 't'  # 转置 a
            lda = (&a[1,0]) - a0 if a.shape[0] > 1 else 1  # 计算 lda
        # 如果 a 是 Fortran 连续的
        elif _is_contiguous(a, 0):
            transa = 'n'  # 不转置 a
            lda = (&a[0,1]) - a0 if a.shape[1] > 1 else 1  # 计算 lda
        else:
            with gil:
                raise ValueError("Input 'a' is neither C nor Fortran contiguous.")
        # 如果 b 是 C 连续的
        if _is_contiguous(b, 1):
            transb = 't'  # 转置 b
            ldb = (&b[1,0]) - b0 if b.shape[0] > 1 else 1  # 计算 ldb
        # 如果 b 是 Fortran 连续的
        elif _is_contiguous(b, 0):
            transb = 'n'  # 不转置 b
            ldb = (&b[0,1]) - b0 if b.shape[1] > 1 else 1  # 计算 ldb
        else:
            with gil:
                raise ValueError("Input 'b' is neither C nor Fortran contiguous.")
        # 获取 a 的行数作为 m
        m = a.shape[0]
        # 获取 a 的列数作为 k
        k = a.shape[1]
        # 检查 k 是否等于 b 的行数
        if k != b.shape[0]:
            with gil:
                raise ValueError("Shape mismatch in input arrays.")
        # 获取 b 的列数作为 n
        n = b.shape[1]
        # 检查 m 和 n 是否和 c 的形状匹配
        if m != c.shape[0] or n != c.shape[1]:
            with gil:
                raise ValueError("Output array does not have the correct shape.")
        # 计算 ldc
        ldc = (&c[0,1]) - c0 if c.shape[1] > 1 else 1
        # 调用底层 BLAS 函数 dgemm 进行矩阵乘法
        dgemm(transa, transb, &m, &n, &k, &alpha, a0, &lda, b0,
                   &ldb, &beta, c0, &ldc)
    else:
        with gil:
            raise ValueError("Input 'c' is neither C nor Fortran contiguous.")
    # 返回 0
    return 0
cpdef double _test_dnrm2(double[:] x) noexcept nogil:
    cdef:
        int n = x.shape[0]                     # 获取数组 x 的长度
        int incx = x.strides[0] // sizeof(x[0]) # 计算 x 的步长
    return dnrm2(&n, &x[0], &incx)              # 调用 C 函数 dnrm2 计算 x 的二范数

cpdef double _test_dzasum(double complex[:] zx) noexcept nogil:
    cdef:
        int n = zx.shape[0]                     # 获取数组 zx 的长度
        int incx = zx.strides[0] // sizeof(zx[0]) # 计算 zx 的步长
    return dzasum(&n, &zx[0], &incx)            # 调用 C 函数 dzasum 计算 zx 的绝对值之和

cpdef double _test_dznrm2(double complex[:] x) noexcept nogil:
    cdef:
        int n = x.shape[0]                     # 获取数组 x 的长度
        int incx = x.strides[0] // sizeof(x[0]) # 计算 x 的步长
    return dznrm2(&n, &x[0], &incx)             # 调用 C 函数 dznrm2 计算 x 的复数二范数

cpdef int _test_icamax(float complex[:] cx) noexcept nogil:
    cdef:
        int n = cx.shape[0]                     # 获取数组 cx 的长度
        int incx = cx.strides[0] // sizeof(cx[0]) # 计算 cx 的步长
    return icamax(&n, &cx[0], &incx)            # 调用 C 函数 icamax 返回最大绝对值的索引

cpdef int _test_idamax(double[:] dx) noexcept nogil:
    cdef:
        int n = dx.shape[0]                     # 获取数组 dx 的长度
        int incx = dx.strides[0] // sizeof(dx[0]) # 计算 dx 的步长
    return idamax(&n, &dx[0], &incx)            # 调用 C 函数 idamax 返回最大绝对值的索引

cpdef int _test_isamax(float[:] sx) noexcept nogil:
    cdef:
        int n = sx.shape[0]                     # 获取数组 sx 的长度
        int incx = sx.strides[0] // sizeof(sx[0]) # 计算 sx 的步长
    return isamax(&n, &sx[0], &incx)            # 调用 C 函数 isamax 返回最大绝对值的索引

cpdef int _test_izamax(double complex[:] zx) noexcept nogil:
    cdef:
        int n = zx.shape[0]                     # 获取数组 zx 的长度
        int incx = zx.strides[0] // sizeof(zx[0]) # 计算 zx 的步长
    return izamax(&n, &zx[0], &incx)            # 调用 C 函数 izamax 返回最大绝对值的索引

cpdef float _test_sasum(float[:] sx) noexcept nogil:
    cdef:
        int n = sx.shape[0]                     # 获取数组 sx 的长度
        int incx = sx.strides[0] // sizeof(sx[0]) # 计算 sx 的步长
    return sasum(&n, &sx[0], &incx)             # 调用 C 函数 sasum 计算 sx 的绝对值之和

cpdef float _test_scasum(float complex[:] cx) noexcept nogil:
    cdef:
        int n = cx.shape[0]                     # 获取数组 cx 的长度
        int incx = cx.strides[0] // sizeof(cx[0]) # 计算 cx 的步长
    return scasum(&n, &cx[0], &incx)            # 调用 C 函数 scasum 计算 cx 的绝对值之和

cpdef float _test_scnrm2(float complex[:] x) noexcept nogil:
    cdef:
        int n = x.shape[0]                     # 获取数组 x 的长度
        int incx = x.strides[0] // sizeof(x[0]) # 计算 x 的步长
    return scnrm2(&n, &x[0], &incx)             # 调用 C 函数 scnrm2 计算 x 的复数二范数

cpdef float _test_sdot(float[:] sx, float[:] sy) noexcept nogil:
    cdef:
        int n = sx.shape[0]                     # 获取数组 sx 的长度
        int incx = sx.strides[0] // sizeof(sx[0]) # 计算 sx 的步长
        int incy = sy.strides[0] // sizeof(sy[0]) # 计算 sy 的步长
    return sdot(&n, &sx[0], &incx, &sy[0], &incy) # 调用 C 函数 sdot 计算向量点积

cpdef float _test_snrm2(float[:] x) noexcept nogil:
    cdef:
        int n = x.shape[0]                     # 获取数组 x 的长度
        int incx = x.strides[0] // sizeof(x[0]) # 计算 x 的步长
    return snrm2(&n, &x[0], &incx)              # 调用 C 函数 snrm2 计算 x 的二范数

cpdef double complex _test_zdotc(double complex[:] zx, double complex[:] zy) noexcept nogil:
    cdef:
        int n = zx.shape[0]                     # 获取数组 zx 的长度
        int incx = zx.strides[0] // sizeof(zx[0]) # 计算 zx 的步长
        int incy = zy.strides[0] // sizeof(zy[0]) # 计算 zy 的步长
    return zdotc(&n, &zx[0], &incx, &zy[0], &incy) # 调用 C 函数 zdotc 计算共轭点积

cpdef double complex _test_zdotu(double complex[:] zx, double complex[:] zy) noexcept nogil:
    cdef:
        int n = zx.shape[0]                     # 获取数组 zx 的长度
        int incx = zx.strides[0] // sizeof(zx[0]) # 计算 zx 的步长
        int incy = zy.strides[0] // sizeof(zy[0]) # 计算 zy 的步长
    return zdotu(&n, &zx[0], &incx, &zy[0], &incy) # 调用 C 函数 zdotu 计算向量点积
    # 将变量 cmach 转换为字节表示形式
    cmach_bytes = bytes(cmach)
    # 现在 cmach_bytes 是一个字节表示，作为函数调用的参数之一，
    # 必须作为非临时变量传递。
    cdef char* cmach_char = cmach_bytes
    # 调用 dlamch 函数，传入 cmach_char 参数，然后返回其结果
    return dlamch(cmach_char)
# Casts the argument type from a Cython type to Numpy complex pointer types.
def arg_casts(argtype):
    # Checks if the argument type is one of the NPY_TYPES values (presumably a dictionary of types).
    if argtype in NPY_TYPES.values():
        # Returns the argument type wrapped in '<>' for casting purposes.
        return f'<{argtype}*>'
    # Returns an empty string if the argument type is not found in NPY_TYPES.
    return ''


# Generates Cython declarations for BLAS/LAPACK functions based on provided parameters.
def generate_decl_pyx(name, return_type, argnames, argtypes, accelerate, header_name):
    # Constructs the input argument list for Cython function declaration.
    pyx_input_args = ', '.join([' *'.join(arg) for arg in zip(argtypes, argnames)])
    
    # Initializes variables related to return type and handling for complex functions.
    init_return_var = ''
    return_kw = ''
    return_var = ''
    blas_return_type = 'void'
    
    # Checks if the function name is in WRAPPED_FUNCS list (presumably for functions with complex return types).
    if name in WRAPPED_FUNCS:
        # Declares an output variable for complex return types.
        init_return_var = f'cdef {return_type} out'
        # Modifies argument lists to accommodate the output variable.
        argnames = ['out'] + argnames
        argtypes = [return_type] + argtypes
        return_var = 'return out'  # Specifies returning the output variable.
    elif return_type != 'void':
        return_kw = 'return '  # Specifies returning a non-void type.
        blas_return_type = return_type  # Updates the BLAS return type to the specified return type.
    
    # Converts Cython argument types to their corresponding C argument types using NPY_TYPES.
    c_argtypes = [NPY_TYPES.get(t, t) for t in argtypes]
    # Constructs the C function prototype for the Cython function declaration.
    c_proto = ', '.join([' *'.join(arg) for arg in zip(c_argtypes, argnames)])
    
    # Constructs Cython function call arguments, including casting for complex types.
    pyx_call_args = [arg_casts(t) + n for n, t in zip(argnames, c_argtypes)]
    
    # For functions with complex return types, modifies the first argument to pass as a pointer.
    if name in WRAPPED_FUNCS:
        pyx_call_args[0] = ''.join([arg_casts(c_argtypes[0]), '&', argnames[0]])
    
    pyx_call_args = ', '.join(pyx_call_args)  # Joins all Cython function call arguments into a string.
    
    # Retrieves BLAS macro and name based on function name and acceleration status.
    blas_macro, blas_name = get_blas_macro_and_name(name, accelerate)
    
    # Constructs the Cython function declaration block with extern from header file and function call.
    return f"""
cdef extern from "{header_name}":
    {blas_return_type} _fortran_{name} "{blas_macro}({blas_name})"({c_proto}) nogil
cdef {return_type} {name}({pyx_input_args}) noexcept nogil:
    {init_return_var}
    {return_kw}_fortran_{name}({pyx_call_args})
    {return_var}
"""


# Generates content for a Cython (.pyx) file containing BLAS/LAPACK declarations and tests.
def generate_file_pyx(sigs, lib_name, header_name, accelerate):
    # Selects appropriate templates based on the library name (either BLAS or LAPACK).
    if lib_name == 'BLAS':
        preamble_template = blas_pyx_preamble
        epilog = blas_py_wrappers
    elif lib_name == 'LAPACK':
        preamble_template = lapack_pyx_preamble
        epilog = lapack_py_wrappers
    else:
        raise RuntimeError(f'Unrecognized lib_name: {lib_name}.')
    
    # Constructs a string of function names from the provided function signatures.
    names = "\n- ".join([sig['name'] for sig in sigs])
    
    # Generates comment lines based on the COMMENT_TEXT list.
    comment = ['# ' + c for c in COMMENT_TEXT]
    
    # Constructs the preamble content for the Cython file, including function names.
    preamble = comment + [preamble_template.format(names)]
    # 根据给定的签名列表生成声明字符串的列表
    decls = [
        generate_decl_pyx(**sig, accelerate=accelerate, header_name=header_name)
        for sig in sigs]
    # 将生成的声明字符串列表与文档的开头内容和结尾内容合并成一个完整的字符串列表
    content = preamble + decls + [epilog]
    # 将字符串列表连接成一个单一的字符串并返回
    return ''.join(content)
# BLAS 函数的 Cython 头文件预言文本，包含 BLAS 函数的相关信息和使用示例
blas_pxd_preamble = """
# Within scipy, these wrappers can be used via relative or absolute cimport.
# Examples:
# from ..linalg cimport cython_blas
# from scipy.linalg cimport cython_blas
# cimport scipy.linalg.cython_blas as cython_blas
# cimport ..linalg.cython_blas as cython_blas

# Within SciPy, if BLAS functions are needed in C/C++/Fortran,
# these wrappers should not be used.
# The original libraries should be linked directly.

ctypedef float s
ctypedef double d
ctypedef float complex c
ctypedef double complex z

"""

# LAPACK 函数的 Cython 头文件预言文本，包含 LAPACK 函数的相关信息和使用示例
lapack_pxd_preamble = """
# Within SciPy, these wrappers can be used via relative or absolute cimport.
# Examples:
# from ..linalg cimport cython_lapack
# from scipy.linalg cimport cython_lapack
# cimport scipy.linalg.cython_lapack as cython_lapack
# cimport ..linalg.cython_lapack as cython_lapack

# Within SciPy, if LAPACK functions are needed in C/C++/Fortran,
# these wrappers should not be used.
# The original libraries should be linked directly.

ctypedef float s
ctypedef double d
ctypedef float complex c
ctypedef double complex z

# Function pointer type declarations for
# gees and gges families of functions.
ctypedef bint cselect1(c*)
ctypedef bint cselect2(c*, c*)
ctypedef bint dselect2(d*, d*)
ctypedef bint dselect3(d*, d*, d*)
ctypedef bint sselect2(s*, s*)
ctypedef bint sselect3(s*, s*, s*)
ctypedef bint zselect1(z*)
ctypedef bint zselect2(z*, z*)

"""


def generate_decl_pxd(name, return_type, argnames, argtypes):
    """Create Cython header declaration for BLAS/LAPACK function."""
    # 拼接函数参数类型和参数名称，生成 Cython 头文件的声明
    args = ', '.join([' *'.join(arg) for arg in zip(argtypes, argnames)])
    return f"cdef {return_type} {name}({args}) noexcept nogil\n"


def generate_file_pxd(sigs, lib_name):
    """Create content for Cython header file for generated pyx."""
    if lib_name == 'BLAS':
        # 使用 BLAS 的头文件预言文本
        preamble = blas_pxd_preamble
    elif lib_name == 'LAPACK':
        # 使用 LAPACK 的头文件预言文本
        preamble = lapack_pxd_preamble
    else:
        # 如果 lib_name 不是 BLAS 或 LAPACK，则引发运行时错误
        raise RuntimeError(f'Unrecognized lib_name: {lib_name}.')
    
    # 将注释文本和预言文本拼接成列表，并添加到头部
    preamble = ['"""\n', *COMMENT_TEXT, '"""\n', preamble]
    
    # 生成所有函数声明的列表
    decls = [generate_decl_pxd(**sig) for sig in sigs]
    
    # 合并注释文本、预言文本和函数声明，返回生成的 Cython 头文件内容
    content = preamble + decls
    return ''.join(content)


def generate_decl_c(name, return_type, argnames, argtypes, accelerate):
    """Create C header declarations for Cython to import."""
    # 转换函数返回类型和参数类型为 C 语言风格
    c_return_type = C_TYPES[return_type]
    c_argtypes = [C_TYPES[t] for t in argtypes]
    
    # 对于复杂返回类型的函数，使用带有“wrp”后缀的包装器
    if name in WRAPPED_FUNCS:
        argnames = ['out'] + argnames
        c_argtypes = [c_return_type] + c_argtypes
        c_return_type = 'void'
    
    # 获取 BLAS 宏和名称，并生成 C 语言风格的参数声明
    blas_macro, blas_name = get_blas_macro_and_name(name, accelerate)
    c_args = ', '.join(f'{t} *{n}' for t, n in zip(c_argtypes, argnames))
    return f"{c_return_type} {blas_macro}({blas_name})({c_args});\n"


def generate_file_c(sigs, lib_name, accelerate):
    # 该函数未完成，需要进一步开发来生成 C 文件内容
    pass
    """Generate content for C header file for Cython to import."""
    # 根据指定的库名生成 C 头文件内容，用于 Cython 导入

    if lib_name == 'BLAS':
        # 如果库名为 'BLAS'，则使用 C_PREAMBLE 作为前导内容
        preamble = [C_PREAMBLE]
    elif lib_name == 'LAPACK':
        # 如果库名为 'LAPACK'，则使用 C_PREAMBLE 和 LAPACK_DECLS 作为前导内容
        preamble = [C_PREAMBLE, LAPACK_DECLS]
    else:
        # 如果库名不是 'BLAS' 或 'LAPACK'，抛出运行时错误
        raise RuntimeError(f'Unrecognized lib_name: {lib_name}.')

    # 前导内容包括注释文本和预定义的内容保护宏
    preamble = ['/*\n', *COMMENT_TEXT, '*/\n'] + preamble + [CPP_GUARD_BEGIN]

    # 生成声明内容列表，通过调用 generate_decl_c 函数生成每个声明
    decls = [generate_decl_c(**sig, accelerate=accelerate) for sig in sigs]

    # 整合前导内容、声明内容和内容保护宏，形成最终的 C 头文件内容
    content = preamble + decls + [CPP_GUARD_END]

    # 将列表中的所有字符串连接成一个单独的字符串并返回
    return ''.join(content)
# 定义一个函数，用于生成所有的 Cython 文件和相关头文件
def make_all(outdir,
             blas_signature_file="cython_blas_signatures.txt",
             lapack_signature_file="cython_lapack_signatures.txt",
             blas_name="cython_blas",
             lapack_name="cython_lapack",
             blas_header_name="_blas_subroutines.h",
             lapack_header_name="_lapack_subroutines.h",
             accelerate=False):
    # 确定源文件和目标文件的绝对路径
    src_files = (os.path.abspath(__file__),
                 blas_signature_file,
                 lapack_signature_file)
    dst_files = (blas_name + '.pyx',
                 blas_name + '.pxd',
                 blas_header_name,
                 lapack_name + '.pyx',
                 lapack_name + '.pxd',
                 lapack_header_name)
    dst_files = [os.path.join(outdir, f) for f in dst_files]
    
    # 切换当前工作目录到基础目录
    os.chdir(BASE_DIR)
    
    # 检查目标文件是否比源文件更新，如果是则输出信息并返回
    if all_newer(dst_files, src_files):
        print("scipy/linalg/_generate_pyx.py: all files up-to-date")
        return
    
    # 打开 BLAS 签名文件，读取所有行并解析签名
    with open(blas_signature_file) as f:
        blas_sigs = f.readlines()
    blas_sigs = read_signatures(blas_sigs)
    
    # 打开 LAPACK 签名文件，读取所有行并解析签名
    with open(lapack_signature_file) as f:
        lapack_sigs = f.readlines()
    lapack_sigs = read_signatures(lapack_sigs)
    
    # 准备要写入文件的内容，包括生成 BLAS 和 LAPACK 的 .pyx、.pxd 和 .h 文件
    to_write = {
        dst_files[0]: generate_file_pyx(
            blas_sigs, 'BLAS', blas_header_name, accelerate),
        dst_files[1]: generate_file_pxd(blas_sigs, 'BLAS'),
        dst_files[2]: generate_file_c(blas_sigs, 'BLAS', accelerate),
        dst_files[3]: generate_file_pyx(
            lapack_sigs, 'LAPACK', lapack_header_name, accelerate),
        dst_files[4]: generate_file_pxd(lapack_sigs, 'LAPACK'),
        dst_files[5]: generate_file_c(lapack_sigs, 'LAPACK', accelerate)
    }
    
    # 调用函数将生成的文件写入到目标文件中
    write_files(to_write)


if __name__ == '__main__':
    # 创建参数解析器
    parser = argparse.ArgumentParser()
    # 添加输出目录参数
    parser.add_argument("-o", "--outdir", type=str,
                        help="Path to the output directory")
    # 添加是否使用加速选项（针对 macOS 13.3+）
    parser.add_argument("-a", "--accelerate", action="store_true",
                        help="Whether to use new Accelerate (macOS 13.3+)")
    # 解析命令行参数
    args = parser.parse_args()

    # 如果缺少 `--outdir` 参数，则引发值错误异常
    if not args.outdir:
        raise ValueError("Missing `--outdir` argument to _generate_pyx.py")
    else:
        # 计算输出目录的绝对路径
        outdir_abs = os.path.join(os.getcwd(), args.outdir)

    # 调用 make_all 函数，生成所有的 Cython 文件和相关头文件
    make_all(outdir_abs, accelerate=args.accelerate)
```