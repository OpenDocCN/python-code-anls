# `D:\src\scipysrc\scipy\scipy\special\_generate_pyx.py`

```
# 指定脚本解释器为 Python 3
#!/usr/bin/env python3

# 导入必要的模块
import json  # 导入处理 JSON 格式的模块
import os    # 导入操作系统相关功能的模块
from stat import ST_MTIME  # 导入获取文件修改时间的常量
import argparse  # 导入处理命令行参数的模块
import re   # 导入支持正则表达式的模块
import textwrap  # 导入文本包装和填充模块

# 定义特殊的 Ufunc 函数列表
special_ufuncs = [
    '_cospi', '_lambertw', '_scaled_exp1', '_sinpi', '_spherical_jn', '_spherical_jn_d',
    '_spherical_yn', '_spherical_yn_d', '_spherical_in', '_spherical_in_d',
    '_spherical_kn', '_spherical_kn_d', 'airy', 'airye', 'bei', 'beip', 'ber', 'berp',
    'binom', 'exp1', 'expi', 'expit', 'exprel', 'gamma', 'gammaln', 'hankel1',
    'hankel1e', 'hankel2', 'hankel2e', 'hyp2f1', 'it2i0k0', 'it2j0y0', 'it2struve0',
    'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0',
    # 定义一个长列表，包含各种数学函数和常数，用于导入的过程中
    'iv', '_iv_ratio', 'ive', 'jv',
    'jve', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kv', 'kve', 'log_expit',
    'log_wright_bessel', 'loggamma', 'logit', 'mathieu_a', 'mathieu_b', 'mathieu_cem',
    'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2',
    'mathieu_sem', 'modfresnelm', 'modfresnelp', 'obl_ang1', 'obl_ang1_cv', 'obl_cv',
    'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'pbdv', 'pbvv', 'pbwa',
    'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2',
    'pro_rad2_cv', 'psi', 'rgamma', 'sph_harm', 'wright_bessel', 'yv', 'yve', '_zeta'
# -----------------------------------------------------------------------------
# Extra code
# -----------------------------------------------------------------------------

UFUNCS_EXTRA_CODE_COMMON = """\
# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from libc.math cimport NAN

include "_ufuncs_extra_code_common.pxi"
"""
# 定义一个包含通用额外代码的字符串常量，用于在生成的文件中导入必要的库和代码，并包含一个特定的头文件。

UFUNCS_EXTRA_CODE = """\
include "_ufuncs_extra_code.pxi"
"""
# 定义一个包含特定额外代码的字符串常量，用于在生成的文件中包含一个特定的头文件。

UFUNCS_EXTRA_CODE_BOTTOM = f"""\
from ._special_ufuncs import ({', '.join(special_ufuncs)})

#
# Aliases
#
jn = jv
"""
# 定义一个包含特定额外代码的字符串常量，从特殊的ufuncs模块导入特定函数，并提供了别名jn作为jv的别名。

STUBS = """\
# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from typing import Any, Dict

import numpy as np

__all__ = [
    'geterr',
    'seterr',
    'errstate',
    {ALL}
]

def geterr() -> Dict[str, str]: ...
def seterr(**kwargs: str) -> Dict[str, str]: ...

class errstate:
    def __init__(self, **kargs: str) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self,
        exc_type: Any,  # Unused
        exc_value: Any,  # Unused
        traceback: Any,  # Unused
    ) -> None: ...

{STUBS}

"""
# 定义一个包含存根代码的字符串常量，用于在生成的文件中提供特定函数和类的定义，以及相应的文档字符串。

# -----------------------------------------------------------------------------
# Code generation
# -----------------------------------------------------------------------------

BASE_DIR = os.path.abspath(os.path.dirname(__file__))

add_newdocs = __import__('_add_newdocs')

CY_TYPES = {
    'f': 'float',
    'd': 'double',
    'g': 'long double',
    'F': 'float complex',
    'D': 'double complex',
    'G': 'long double complex',
    'i': 'int',
    'l': 'long',
    'v': 'void',
}
# 定义一个字典，将字符类型映射到Cython支持的C语言类型。

C_TYPES = {
    'f': 'npy_float',
    'd': 'npy_double',
    'g': 'npy_longdouble',
    'F': 'npy_cfloat',
    'D': 'npy_cdouble',
    'G': 'npy_clongdouble',
    'i': 'npy_int',
    'l': 'npy_long',
    'v': 'void',
}
# 定义一个字典，将字符类型映射到NumPy支持的C语言类型。

TYPE_NAMES = {
    'f': 'NPY_FLOAT',
    'd': 'NPY_DOUBLE',
    'g': 'NPY_LONGDOUBLE',
    'F': 'NPY_CFLOAT',
    'D': 'NPY_CDOUBLE',
    'G': 'NPY_CLONGDOUBLE',
    'i': 'NPY_INT',
    'l': 'NPY_LONG',
}
# 定义一个字典，将字符类型映射到NumPy中对应的类型名称常量。

def underscore(arg):
    return arg.replace(" ", "_")
# 定义一个函数，用于将字符串中的空格替换为下划线。

def cast_order(c):
    return ['ilfdgFDG'.index(x) for x in c]
# 定义一个函数，返回一个列表，表示给定类型字符在'ilfdgFDG'字符串中的索引顺序。

# These downcasts will cause the function to return NaNs, unless the
# values happen to coincide exactly.
DANGEROUS_DOWNCAST = {
    ('F', 'i'), ('F', 'l'), ('F', 'f'), ('F', 'd'), ('F', 'g'),
    ('D', 'i'), ('D', 'l'), ('D', 'f'), ('D', 'd'), ('D', 'g'),
    ('G', 'i'), ('G', 'l'), ('G', 'f'), ('G', 'd'), ('G', 'g'),
    ('f', 'i'), ('f', 'l'),
    ('d', 'i'), ('d', 'l'),
    ('g', 'i'), ('g', 'l'),
    ('l', 'i'),
}
# 定义一个集合，包含了会导致向下转型时返回NaN值的（输入类型，输出类型）组合。

NAN_VALUE = {
    'f': 'NAN',
    'd': 'NAN',
    'g': 'NAN',
    'F': 'NAN',
    'D': 'NAN',
    'G': 'NAN',
    'i': '0xbad0bad0',
    'l': '0xbad0bad0',
}
# 定义一个字典，将数据类型映射到对应的NaN值或者其他特殊的数值表示。

def generate_loop(func_inputs, func_outputs, func_retval,
                  ufunc_inputs, ufunc_outputs):
    """
    Generate a UFunc loop function that calls a function given as its
    data parameter with the specified input and output arguments and
    ```
    """
# 定义一个函数，用于生成一个UFunc循环函数，调用指定的函数作为其数据参数，传入指定的输入和输出参数。
    return value.

    This function can be passed to PyUFunc_FromFuncAndData.

    Parameters
    ----------
    func_inputs, func_outputs, func_retval : str
        Signature of the function to call, given as type codes of the
        input, output and return value arguments. These 1-character
        codes are given according to the CY_TYPES and TYPE_NAMES
        lists above.

        The corresponding C function signature to be called is:

            retval func(intype1 iv1, intype2 iv2, ..., outtype1 *ov1, ...);

        If len(ufunc_outputs) == len(func_outputs)+1, the return value
        is treated as the first output argument. Otherwise, the return
        value is ignored.

    ufunc_inputs, ufunc_outputs : str
        Ufunc input and output signature.

        This does not have to exactly match the function signature,
        as long as the type casts work out on the C level.

    Returns
    -------
    loop_name
        Name of the generated loop function.
    loop_body
        Generated C code for the loop.

    """
    # 检查函数输入参数和ufunc输入参数的数量是否匹配
    if len(func_inputs) != len(ufunc_inputs):
        raise ValueError("Function and ufunc have different number of inputs")

    # 检查函数输出参数和ufunc输出参数的数量是否匹配，或者检查返回值处理是否正确
    if len(func_outputs) != len(ufunc_outputs) and not (
            func_retval != "v" and len(func_outputs)+1 == len(ufunc_outputs)):
        raise ValueError("Function retval and ufunc outputs don't match")

    # 根据输入参数和输出参数的类型生成循环函数的名称
    name = (f"loop_{func_retval}_{func_inputs}_{func_outputs}"
            f"_As_{ufunc_inputs}_{ufunc_outputs}")
    
    # 生成循环函数的C代码主体
    body = (f"cdef void {name}(char **args, np.npy_intp *dims, np.npy_intp *steps, "
            f"void *data) noexcept nogil:\n")
    body += "    cdef np.npy_intp i, n = dims[0]\n"
    body += "    cdef void *func = (<void**>data)[0]\n"
    body += "    cdef char *func_name = <char*>(<void**>data)[1]\n"

    # 生成输入参数和输出参数在C代码中的声明和初始化
    for j in range(len(ufunc_inputs)):
        body += "    cdef char *ip%d = args[%d]\n" % (j, j)
    for j in range(len(ufunc_outputs)):
        body += "    cdef char *op%d = args[%d]\n" % (j, j + len(ufunc_inputs))

    # 根据函数输入参数类型和ufunc输入参数类型生成C代码中的变量声明和赋值
    ftypes = []
    fvars = []
    outtypecodes = []
    for j in range(len(func_inputs)):
        ftypes.append(CY_TYPES[func_inputs[j]])
        fvars.append("<%s>(<%s*>ip%d)[0]" % (
            CY_TYPES[func_inputs[j]],
            CY_TYPES[ufunc_inputs[j]], j))

    # 如果返回值作为输出参数的第一个参数处理，生成对应的C代码
    if len(func_outputs)+1 == len(ufunc_outputs):
        func_joff = 1
        outtypecodes.append(func_retval)
        body += f"    cdef {CY_TYPES[func_retval]} ov0\n"
    else:
        func_joff = 0

    # 根据函数输出参数类型生成C代码中的变量声明和赋值
    for j, outtype in enumerate(func_outputs):
        body += "    cdef %s ov%d\n" % (CY_TYPES[outtype], j+func_joff)
        ftypes.append("%s *" % CY_TYPES[outtype])
        fvars.append("&ov%d" % (j+func_joff))
        outtypecodes.append(outtype)

    # 生成循环体的C代码
    body += "    for i in range(n):\n"
    if len(func_outputs)+1 == len(ufunc_outputs):
        rv = "ov0 = "
    else:
        rv = ""
    # 根据给定的返回值、函数返回类型、参数类型和参数变量，生成函数调用语句
    funcall = "        {}(<{}(*)({}) noexcept nogil>func)({})\n".format(
        rv, CY_TYPES[func_retval], ", ".join(ftypes), ", ".join(fvars))

    # 检查输入并调用函数
    input_checks = []
    for j in range(len(func_inputs)):
        # 检查是否存在危险的类型转换，并生成相应的检查语句
        if (ufunc_inputs[j], func_inputs[j]) in DANGEROUS_DOWNCAST:
            chk = "<%s>(<%s*>ip%d)[0] == (<%s*>ip%d)[0]" % (
                CY_TYPES[func_inputs[j]], CY_TYPES[ufunc_inputs[j]], j,
                CY_TYPES[ufunc_inputs[j]], j)
            input_checks.append(chk)

    if input_checks:
        # 如果存在输入检查语句，添加条件判断语句
        body += "        if %s:\n" % (" and ".join(input_checks))
        body += "    " + funcall  # 添加函数调用语句
        body += "        else:\n"
        body += ("            sf_error.error(func_name, sf_error.DOMAIN, "
                 "\"invalid input argument\")\n")  # 处理输入错误的情况
        for j, outtype in enumerate(outtypecodes):
            body += "            ov%d = <%s>%s\n" % (
                j, CY_TYPES[outtype], NAN_VALUE[outtype])  # 初始化输出值为 NaN
    else:
        body += funcall  # 如果没有输入检查，直接添加函数调用语句

    # 分配和检查输出值的类型转换
    for j, (outtype, fouttype) in enumerate(zip(ufunc_outputs, outtypecodes)):
        if (fouttype, outtype) in DANGEROUS_DOWNCAST:
            # 如果存在危险的类型转换，添加条件判断和类型转换语句
            body += "        if ov%d == <%s>ov%d:\n" % (j, CY_TYPES[outtype], j)
            body += "            (<%s *>op%d)[0] = <%s>ov%d\n" % (
                CY_TYPES[outtype], j, CY_TYPES[outtype], j)
            body += "        else:\n"
            body += ("            sf_error.error(func_name, sf_error.DOMAIN, "
                     "\"invalid output\")\n")  # 处理输出错误的情况
            body += "            (<%s *>op%d)[0] = <%s>%s\n" % (
                CY_TYPES[outtype], j, CY_TYPES[outtype], NAN_VALUE[outtype])  # 将输出值设为 NaN
        else:
            body += "        (<%s *>op%d)[0] = <%s>ov%d\n" % (
                CY_TYPES[outtype], j, CY_TYPES[outtype], j)  # 直接进行类型转换

    # 更新输入指针的位置
    for j in range(len(ufunc_inputs)):
        body += "        ip%d += steps[%d]\n" % (j, j)

    # 更新输出指针的位置
    for j in range(len(ufunc_outputs)):
        body += "        op%d += steps[%d]\n" % (j, j + len(ufunc_inputs))

    body += "    sf_error.check_fpe(func_name)\n"  # 检查浮点异常

    return name, body  # 返回函数名和生成的函数体
def iter_variants(inputs, outputs):
    """
    Generate variants of UFunc signatures, by changing variable types,
    within the limitation that the corresponding C types casts still
    work out.

    This does not generate all possibilities, just the ones required
    for the ufunc to work properly with the most common data types.

    Parameters
    ----------
    inputs, outputs : str
        UFunc input and output signature strings

    Yields
    ------
    new_input, new_output : str
        Modified input and output strings.
        Also the original input/output pair is yielded.

    """
    # 定义类型映射列表，用于替换输入和输出签名中的数据类型
    maps = [
        # 总是使用长整型代替整型（在64位系统上更常见的类型）
        ('i', 'l'),
    ]

    # 如果输入签名和输出签名中不包含整型或长整型
    if not ('i' in inputs or 'l' in inputs):
        # 不为整数参数的ufunc添加float32版本，因为这可能导致错误的dtype选择
        # 如果整数参数是数组，但浮点参数是标量。
        # 例如 sph_harm(0,[0],0,0).dtype == complex64
        # 这可能是NumPy的一个bug，但我们需要解决这个问题。
        # 参见 gh-4895, https://github.com/numpy/numpy/issues/5895
        # 向映射列表中添加浮点数类型的版本
        maps = maps + [(a + 'dD', b + 'fF') for a, b in maps]

    # 对每对源和目标类型进行替换
    for src, dst in maps:
        new_inputs = inputs
        new_outputs = outputs
        # 逐字符替换输入和输出签名中的数据类型
        for a, b in zip(src, dst):
            new_inputs = new_inputs.replace(a, b)
            new_outputs = new_outputs.replace(a, b)
        # 生成新的输入和输出签名
        yield new_inputs, new_outputs


class Func:
    """
    Base class for Ufunc.

    """
    def __init__(self, name, signatures):
        # 初始化函数对象的名称和签名列表
        self.name = name
        self.signatures = []
        self.function_name_overrides = {}

        # 遍历提供的签名字典
        for header in signatures.keys():
            for name, sig in signatures[header].items():
                # 解析每个签名，并将其添加到签名列表中
                inarg, outarg, ret = self._parse_signature(sig)
                self.signatures.append((name, inarg, outarg, ret, header))

    def _parse_signature(self, sig):
        # 解析给定的签名字符串
        m = re.match(r"\s*([fdgFDGil]*)\s*\*\s*([fdgFDGil]*)\s*->\s*([*fdgFDGil]*)\s*$",
                     sig)
        if m:
            # 提取输入参数、输出参数和返回类型
            inarg, outarg, ret = (x.strip() for x in m.groups())
            if ret.count('*') > 1:
                raise ValueError(f"{self.name}: Invalid signature: {sig}")
            return inarg, outarg, ret
        m = re.match(r"\s*([fdgFDGil]*)\s*->\s*([fdgFDGil]?)\s*$", sig)
        if m:
            # 提取输入参数和返回类型（没有输出参数）
            inarg, ret = (x.strip() for x in m.groups())
            return inarg, "", ret
        # 如果无法匹配有效的签名格式，则引发异常
        raise ValueError(f"{self.name}: Invalid signature: {sig}")
    def get_prototypes(self, nptypes_for_h=False):
        # 初始化原型列表
        prototypes = []
        # 遍历每个函数签名中的元组数据
        for func_name, inarg, outarg, ret, header in self.signatures:
            # 移除返回类型中的星号
            ret = ret.replace('*', '')
            # 生成 C 语言参数列表
            c_args = ([C_TYPES[x] for x in inarg]
                      + [C_TYPES[x] + ' *' for x in outarg])
            # 生成 Cython 参数列表
            cy_args = ([CY_TYPES[x] for x in inarg]
                       + [CY_TYPES[x] + ' *' for x in outarg])
            # 构建 C 语言函数原型字符串
            c_proto = "{} (*)({})".format(C_TYPES[ret], ", ".join(c_args))
            # 如果文件头以 'h' 结尾并且 nptypes_for_h 为真，生成对应的 Cython 原型
            if header.endswith("h") and nptypes_for_h:
                cy_proto = c_proto + "nogil"
            else:
                # 否则生成带 noexcept 和 nogil 的 Cython 原型
                cy_proto = ("{} (*)({}) noexcept nogil"
                            .format(CY_TYPES[ret], ", ".join(cy_args)))
            # 将生成的原型信息添加到列表中
            prototypes.append((func_name, c_proto, cy_proto, header))
        # 返回所有生成的原型列表
        return prototypes

    def cython_func_name(self, c_name, specialized=False, prefix="_func_",
                         override=True):
        # 如果需要进行函数名覆盖
        if override and c_name in self.function_name_overrides:
            # 根据覆盖表替换函数名和前缀
            c_name = self.function_name_overrides[c_name]
            prefix = ""

        # 支持融合类型
        m = re.match(r'^(.*?)(\[.*\])$', c_name)
        if m:
            # 分离出基本名称和融合部分
            c_base_name, fused_part = m.groups()
        else:
            c_base_name, fused_part = c_name, ""
        
        # 如果需要特殊化处理
        if specialized:
            # 返回带有前缀和融合部分的特殊化函数名
            return "{}{}{}".format(prefix, c_base_name, fused_part.replace(' ', '_'))
        else:
            # 返回普通的函数名，带有前缀
            return f"{prefix}{c_base_name}"
class Ufunc(Func):
    """
    Ufunc signature, restricted format suitable for special functions.

    Parameters
    ----------
    name
        Name of the ufunc to create
    signature
        String of form 'func: fff*ff->f, func2: ddd->*i' describing
        the C-level functions and types of their input arguments
        and return values.

        The syntax is
        'function_name: inputparams*outputparams->output_retval*ignored_retval'

    Attributes
    ----------
    name : str
        Python name for the Ufunc
    signatures : list of (func_name, inarg_spec, outarg_spec, ret_spec, header_name)
        List of parsed signatures
    doc : str
        Docstring, obtained from add_newdocs
    function_name_overrides : dict of str->str
        Overrides for the function names in signatures

    """
    # 定义 Ufunc 类，继承自 Func 类
    def __init__(self, name, signatures):
        # 调用父类 Func 的构造方法
        super().__init__(name, signatures)
        # 从 add_newdocs 获取文档字符串，赋值给 self.doc
        self.doc = add_newdocs.get(name)
        # 如果 self.doc 为 None，则抛出 ValueError 异常
        if self.doc is None:
            raise ValueError("No docstring for ufunc %r" % name)
        # 使用 textwrap.dedent 去除文档字符串的缩进，并去除首尾空白字符
        self.doc = textwrap.dedent(self.doc).strip()
    # 定义一个方法，用于获取函数签名和循环信息，返回所有循环的字典
    def _get_signatures_and_loops(self, all_loops):
        # 输入参数数量，默认为 None
        inarg_num = None
        # 输出参数数量，默认为 None
        outarg_num = None

        # 用于存储已经处理过的函数签名的集合
        seen = set()
        # 用于存储生成的循环变体列表
        variants = []

        # 定义一个内部函数，用于添加函数变体
        def add_variant(func_name, inarg, outarg, ret, inp, outp):
            # 如果输入参数已经存在于 seen 集合中，则直接返回，避免重复处理
            if inp in seen:
                return
            seen.add(inp)

            # 生成函数签名元组
            sig = (func_name, inp, outp)
            # 如果输出参数包含 "v"，则抛出 ValueError 异常
            if "v" in outp:
                raise ValueError(f"{self.name}: void signature {sig!r}")
            # 检查输入和输出参数的数量是否符合预期
            if len(inp) != inarg_num or len(outp) != outarg_num:
                raise ValueError(
                    "%s: signature %r does not have %d/%d input/output args" % (
                        self.name, sig, inarg_num, outarg_num
                    )
                )

            # 生成循环的名称和循环对象，并将其加入 all_loops 字典中
            loop_name, loop = generate_loop(inarg, outarg, ret, inp, outp)
            all_loops[loop_name] = loop
            # 将函数名、循环名称、输入参数和输出参数添加到 variants 列表中
            variants.append((func_name, loop_name, inp, outp))

        # 首先处理基础变体
        for func_name, inarg, outarg, ret, header in self.signatures:
            # 生成输出参数，并去除可能的 "*" 符号
            outp = re.sub(r'\*.*', '', ret) + outarg
            ret = ret.replace('*', '')
            # 如果输入参数数量还未确定，则初始化 inarg_num 和 outarg_num
            if inarg_num is None:
                inarg_num = len(inarg)
                outarg_num = len(outp)

            # 获取第一个变体的输入和输出参数
            inp, outp = list(iter_variants(inarg, outp))[0]
            # 添加该变体到 variants 列表中
            add_variant(func_name, inarg, outarg, ret, inp, outp)

        # 然后处理补充变体
        for func_name, inarg, outarg, ret, header in self.signatures:
            outp = re.sub(r'\*.*', '', ret) + outarg
            ret = ret.replace('*', '')
            # 遍历所有可能的输入和输出参数变体，并将它们添加到 variants 列表中
            for inp, outp in iter_variants(inarg, outp):
                add_variant(func_name, inarg, outarg, ret, inp, outp)

        # 最后按照输入参数的强制顺序对 variants 列表进行排序
        # 排序是稳定的，所以在签名列表中较早出现的函数仍然优先
        variants.sort(key=lambda v: cast_order(v[2]))

        # 返回排序后的 variants 列表、输入参数数量和输出参数数量
        return variants, inarg_num, outarg_num
    # 定义一个生成函数，用于生成 Cython 扩展模块的顶层代码字符串
    def generate(self, all_loops):
        # 初始化顶层代码字符串
        toplevel = ""

        # 调用内部方法获取函数签名和循环信息
        variants, inarg_num, outarg_num = self._get_signatures_and_loops(all_loops)

        # 初始化存储循环名称、函数名称和类型的列表
        loops = []
        funcs = []
        types = []

        # 遍历每个变体，提取输入和输出类型，循环名称和函数名称
        for func_name, loop_name, inputs, outputs in variants:
            # 将输入类型和输出类型对应的类型名称添加到 types 列表中
            for x in inputs:
                types.append(TYPE_NAMES[x])
            for x in outputs:
                types.append(TYPE_NAMES[x])
            # 将循环名称和函数名称添加到 loops 和 funcs 列表中
            loops.append(loop_name)
            funcs.append(func_name)

        # 构建顶层代码字符串，定义 ufunc 相关的 C 变量
        toplevel += ("cdef np.PyUFuncGenericFunction ufunc_%s_loops[%d]\n" %
                     (self.name, len(loops)))
        toplevel += "cdef void *ufunc_%s_ptr[%d]\n" % (self.name, 2*len(funcs))
        toplevel += "cdef void *ufunc_%s_data[%d]\n" % (self.name, len(funcs))
        toplevel += "cdef char ufunc_%s_types[%d]\n" % (self.name, len(types))
        
        # 构建 ufunc 的文档字符串，注意处理转义和换行符
        toplevel += 'cdef char *ufunc_{}_doc = (\n    "{}")\n'.format(
            self.name,
            self.doc.replace("\\", "\\\\").replace('"', '\\"')
            .replace('\n', '\\n\"\n    "')
        )

        # 遍历循环函数列表，将函数指针赋值给 ufunc_%s_loops 数组
        for j, function in enumerate(loops):
            toplevel += ("ufunc_%s_loops[%d] = <np.PyUFuncGenericFunction>%s\n" %
                         (self.name, j, function))
        
        # 遍历类型列表，将类型值赋值给 ufunc_%s_types 数组
        for j, type in enumerate(types):
            toplevel += "ufunc_%s_types[%d] = <char>%s\n" % (self.name, j, type)
        
        # 遍历函数名称列表，为 ufunc_%s_ptr 数组设置函数指针和名称字符串
        for j, func in enumerate(funcs):
            toplevel += "ufunc_%s_ptr[2*%d] = <void*>%s\n" % (
                self.name, j, self.cython_func_name(func, specialized=True)
            )
            toplevel += "ufunc_%s_ptr[2*%d+1] = <void*>(<char*>\"%s\")\n" % (
                self.name, j, self.name
            )
        
        # 遍历函数名称列表，为 ufunc_%s_data 数组设置指向函数指针数组的指针
        for j, func in enumerate(funcs):
            toplevel += "ufunc_%s_data[%d] = &ufunc_%s_ptr[2*%d]\n" % (
                self.name, j, self.name, j)

        # 构建 np.PyUFunc_FromFuncAndData 函数调用的字符串，生成 ufunc 对象
        toplevel += ('@ = np.PyUFunc_FromFuncAndData(ufunc_@_loops, '
                     'ufunc_@_data, ufunc_@_types, %d, %d, %d, 0, '
                     '"@", ufunc_@_doc, 0)\n' % (len(types)/(inarg_num+outarg_num),
                                                 inarg_num, outarg_num)
                     ).replace('@', self.name)

        # 返回生成的顶层代码字符串
        return toplevel
# 根据给定参数生成 Cython 函数声明的工具函数
def get_declaration(ufunc, c_name, c_proto, cy_proto, header,
                    proto_h_filename):
    """
    Construct a Cython declaration of a function coming either from a
    pxd or a header file. Do sufficient tricks to enable compile-time
    type checking against the signature expected by the ufunc.

    构建一个 Cython 函数声明，可以从 .pxd 文件或者头文件中获取函数定义。
    使用足够的技巧来在编译时对 ufunc 预期的函数签名进行类型检查。
    """

    defs = []  # 存储 Cython 中的声明
    defs_h = []  # 存储用于头文件的声明

    # 生成变量名，替换掉非法字符，用于后续的声明中
    var_name = c_name.replace('[', '_').replace(']', '_').replace(' ', '_')

    if header.endswith('.pxd'):
        # 如果是 .pxd 文件，则从相应模块中导入函数声明
        defs.append("from .{} cimport {} as {}".format(
            header[:-4], ufunc.cython_func_name(c_name, prefix=""),
            ufunc.cython_func_name(c_name)))

        # 在编译时检查函数签名
        proto_name = '_proto_%s_t' % var_name
        defs.append("ctypedef %s" % (cy_proto.replace('(*)', proto_name)))
        defs.append(f"cdef {proto_name} *{proto_name}_var = "
                    f"&{ufunc.cython_func_name(c_name, specialized=True)}")
    else:
        # 如果是头文件，则重新声明函数以进行编译时的函数签名检查
        new_name = f"{ufunc.cython_func_name(c_name)} \"{c_name}\""
        proto_h_filename = os.path.basename(proto_h_filename)
        defs.append(f'cdef extern from r"{proto_h_filename}":')
        defs.append("    cdef %s" % (cy_proto.replace('(*)', new_name)))
        defs_h.append(f'#include "{header}"')
        defs_h.append("%s;" % (c_proto.replace('(*)', c_name)))

    return defs, defs_h, var_name
    for ufunc in ufuncs:
        # 遍历每个ufunc对象列表
        cfuncs = ufunc.get_prototypes()
        # 获取当前ufunc对象的C函数声明和类型检查片段列表
        for c_name, c_proto, cy_proto, header in cfuncs:
            # 遍历每个C函数名称、C函数原型、Cython函数原型、头文件
            if header.endswith('++'):
                # 如果头文件名以'++'结尾，则去掉末尾的'++'
                header = header[:-2]

                # 用于CXX模块的情况
                item_defs, item_defs_h, var_name = get_declaration(
                    ufunc, c_name, c_proto, cy_proto, header, cxx_proto_h_filename
                )
                # 将函数声明添加到CXX模块的定义列表和头文件定义列表中
                cxx_defs.extend(item_defs)
                cxx_defs_h.extend(item_defs_h)

                # 生成Cython函数名，并将其导出到CXX模块
                func_name = ufunc.cython_func_name(
                    c_name, specialized=True, override=False
                )
                cxx_defs.append(f"cdef void *_export_{var_name} = <void*>{func_name}")
                cxx_pxd_defs.append(f"cdef void *_export_{var_name}")

                # 让Cython从C++共享库中获取函数指针
                ufunc.function_name_overrides[c_name] = (
                    "scipy.special._ufuncs_cxx._export_" + var_name
                )
            else:
                # 普通情况
                item_defs, item_defs_h, _ = get_declaration(
                    ufunc, c_name, c_proto, cy_proto, header, proto_h_filename
                )
                # 将函数声明添加到定义列表和头文件定义列表中
                defs.extend(item_defs)
                defs_h.extend(item_defs_h)

        # 生成ufunc对象的创建代码片段
        t = ufunc.generate(all_loops)
        toplevel += t + "\n"

    # 生成最终的输出代码
    toplevel = "\n".join(sorted(all_loops.values()) + defs + [toplevel])

    # 为模块生成`__all__`列表
    all_ufuncs = (
        [
            f"'{ufunc.name}'"
            for ufunc in ufuncs if not ufunc.name.startswith('_')
        ]
        + ["'geterr'", "'seterr'", "'errstate'", "'jn'"] +
        [
            f"'{name}'"
            for name in special_ufuncs if not name.startswith('_')
        ]
    )
    module_all = '__all__ = [{}]'.format(', '.join(all_ufuncs))

    # 将生成的代码写入文件
    with open(filename, 'w') as f:
        f.write(UFUNCS_EXTRA_CODE_COMMON)
        f.write(UFUNCS_EXTRA_CODE)
        f.write(module_all)
        f.write("\n")
        f.write(toplevel)
        f.write(UFUNCS_EXTRA_CODE_BOTTOM)

    # 去除头文件定义列表中的重复项
    defs_h = unique(defs_h)
    with open(proto_h_filename, 'w') as f:
        f.write("#ifndef UFUNCS_PROTO_H\n#define UFUNCS_PROTO_H 1\n")
        f.write("\n".join(defs_h))
        f.write("\n#endif\n")

    # 去除CXX头文件定义列表中的重复项
    cxx_defs_h = unique(cxx_defs_h)
    with open(cxx_proto_h_filename, 'w') as f:
        f.write("#ifndef UFUNCS_PROTO_H\n#define UFUNCS_PROTO_H 1\n")
        f.write("\n".join(cxx_defs_h))
        f.write("\n#endif\n")

    # 将CXX定义写入pyx文件
    with open(cxx_pyx_filename, 'w') as f:
        f.write(UFUNCS_EXTRA_CODE_COMMON)
        f.write("\n")
        f.write("\n".join(cxx_defs))

    # 将CXX定义写入pxd文件
    with open(cxx_pxd_filename, 'w') as f:
        f.write("\n".join(cxx_pxd_defs))
# 定义函数 `unique`，用于返回一个去重后的列表，保持原有顺序
def unique(lst):
    # 创建一个空集合，用于存放已经出现过的元素
    seen = set()
    # 创建一个空列表，用于存放去重后的结果
    new_lst = []
    # 遍历输入的列表
    for item in lst:
        # 如果当前元素已经在集合中出现过，则跳过当前循环
        if item in seen:
            continue
        # 否则将当前元素添加到集合中，表示已经处理过
        seen.add(item)
        # 将当前元素添加到结果列表中
        new_lst.append(item)
    # 返回去重后的列表
    return new_lst


# 定义函数 `newer`，用于判断源文件是否比目标文件更新
def newer(source, target):
    # 如果源文件不存在，则抛出异常
    if not os.path.exists(source):
        raise ValueError("file '%s' does not exist" % os.path.abspath(source))
    # 如果目标文件不存在，则返回 True，表示源文件比目标文件新
    if not os.path.exists(target):
        return True

    # 获取源文件和目标文件的最后修改时间
    mtime1 = os.stat(source)[ST_MTIME]
    mtime2 = os.stat(target)[ST_MTIME]

    # 返回比较结果，True 表示源文件比目标文件新
    return mtime1 > mtime2


# 定义函数 `all_newer`，用于检查多个源文件是否比对应的目标文件更新
def all_newer(src_files, dst_files):
    # 使用生成器表达式，逐一检查每对源文件和目标文件的更新情况
    return all(os.path.exists(dst) and newer(dst, src)
               for dst in dst_files for src in src_files)


# 定义主函数 `main`，用于生成特定的代码文件
def main(outdir):
    # 获取当前文件的所在路径
    pwd = os.path.dirname(__file__)
    # 定义源文件列表和目标文件列表
    src_files = (os.path.abspath(__file__),
                 os.path.abspath(os.path.join(pwd, 'functions.json')),
                 os.path.abspath(os.path.join(pwd, '_add_newdocs.py')))
    dst_files = ('_ufuncs.pyx',
                 '_ufuncs_defs.h',
                 '_ufuncs_cxx.pyx',
                 '_ufuncs_cxx.pxd',
                 '_ufuncs_cxx_defs.h')
    # 将目标文件列表中的文件名与输出目录拼接，形成完整的目标文件路径列表
    dst_files = (os.path.join(outdir, f) for f in dst_files)

    # 切换当前工作目录到 BASE_DIR
    os.chdir(BASE_DIR)

    # 如果所有源文件都比对应的目标文件新，则打印提示信息并返回
    if all_newer(src_files, dst_files):
        print("scipy/special/_generate_pyx.py: all files up-to-date")
        return

    # 创建空列表，用于存放 Ufunc 对象
    ufuncs = []
    # 打开并读取 functions.json 文件中的内容
    with open('functions.json') as data:
        functions = json.load(data)
    # 遍历 functions 字典中的每个函数和其签名
    for f, sig in functions.items():
        # 如果函数不在 special_ufuncs 中，则创建 Ufunc 对象并添加到 ufuncs 列表中
        if (f not in special_ufuncs):
            ufuncs.append(Ufunc(f, sig))
    # 生成特定的代码文件到指定的输出目录下
    generate_ufuncs(os.path.join(outdir, "_ufuncs"),
                    os.path.join(outdir, "_ufuncs_cxx"),
                    ufuncs)


# 如果当前脚本被直接执行，则执行以下代码
if __name__ == "__main__":
    # 创建参数解析器对象
    parser = argparse.ArgumentParser()
    # 添加 `-o` 或 `--outdir` 参数，用于指定输出目录路径
    parser.add_argument("-o", "--outdir", type=str,
                        help="Path to the output directory")
    # 解析命令行参数
    args = parser.parse_args()

    # 如果未提供 `--outdir` 参数，则抛出异常
    if not args.outdir:
        raise ValueError("Missing `--outdir` argument to _generate_pyx.py")
    else:
        # 否则，将输出目录路径与当前工作目录拼接得到绝对路径
        outdir_abs = os.path.join(os.getcwd(), args.outdir)

    # 调用主函数，开始执行代码生成过程
    main(outdir_abs)
```