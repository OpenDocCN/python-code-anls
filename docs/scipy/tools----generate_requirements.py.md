# `D:\src\scipysrc\scipy\tools\generate_requirements.py`

```
#!/usr/bin/env python
"""Generate requirements/*.txt files from pyproject.toml."""

import sys  # 导入 sys 模块，用于处理系统相关功能
from pathlib import Path  # 导入 Path 类，用于处理文件路径操作

try:  # 尝试导入 tomllib 模块（Python 3.11+标准模块）
    import tomllib as toml
except ImportError:
    try:  # 尝试导入 tomli 模块（老版本 Python 通过 pip 安装）
        import tomli as toml
    except ImportError:
        sys.exit("Please install `tomli` first: `{mamba, pip} install tomli`")  # 如果都失败，则输出错误信息并退出程序

script_pth = Path(__file__)  # 获取当前脚本文件的路径
repo_dir = script_pth.parent.parent  # 获取当前脚本文件的父目录的父目录，即项目根目录
script_relpth = script_pth.relative_to(repo_dir)  # 获取当前脚本文件相对于项目根目录的相对路径
header = [  # 定义生成文件的头部信息列表
    f"# Generated via {script_relpth.as_posix()}.",  # 生成文件的来源信息
    "# Do not edit this file; modify `pyproject.toml` instead "
    "and run `python tools/generate_requirements.py`.",  # 提示不要直接编辑该文件，应修改 pyproject.toml 文件并运行生成脚本
]


def generate_requirement_file(name, req_list, *, extra_list=None):
    req_fname = repo_dir / "requirements" / f"{name}.txt"  # 构造生成的需求文件路径

    # 移除对 scikit-umfpack 的依赖，以解决循环依赖问题
    comment = "# scikit-umfpack  # circular dependency issues"
    req_list = [comment if x == "scikit-umfpack" else x for x in req_list]

    # 移除对 gmpy2 的依赖，因其尚不支持 Python 3.12
    comment = "# gymp2  # does not yet support Python 3.12"
    req_list = [comment if x == "gmpy2" else x for x in req_list]

    if name == "build":
        req_list = [x for x in req_list if "numpy" not in x]  # 如果是构建依赖文件，移除对 numpy 的依赖
        req_list.append("ninja")  # 添加 ninja 到构建依赖文件

    if extra_list:
        req_list += extra_list  # 如果有额外的依赖列表，则将其添加到需求列表末尾

    req_fname.write_text("\n".join(header + req_list) + "\n")  # 将头部信息与需求列表合并为文本并写入文件
    return req_list  # 返回生成的需求列表


def main():
    pyproject = toml.loads((repo_dir / "pyproject.toml").read_text())  # 加载 pyproject.toml 文件内容到 pyproject 变量中

    default = generate_requirement_file("default", pyproject["project"]["dependencies"])  # 生成默认需求文件
    generate_requirement_file("build", pyproject["build-system"]["requires"],
                              extra_list=default)  # 生成构建需求文件，包括默认依赖列表

    for key, opt_list in pyproject["project"]["optional-dependencies"].items():
        generate_requirement_file(key, opt_list)  # 遍历可选依赖并生成对应的需求文件

    # 生成 requirements/all.txt 文件
    all_path = repo_dir / "requirements" / "all.txt"
    files = ["build", "dev", "doc", "test"]  # 定义需求文件的列表
    reqs = [f"-r {x}.txt" for x in files]  # 生成包含文件列表的依赖项列表
    all_path.write_text("\n".join(header + reqs) + "\n")  # 将头部信息与依赖项列表合并为文本并写入文件


if __name__ == "__main__":
    main()  # 如果作为主程序运行，则调用 main 函数执行
```