
# `.\MetaGPT\metagpt\exp_pool\context_builders\simple.py` 详细设计文档

该代码实现了一个简单的上下文构建器，其核心功能是根据用户需求（req）和从经验池中获取的经验（exps），按照预定义的模板格式，构建一个结构化的提示词（Prompt）上下文，以引导模型在生成回答时参考历史经验。

## 整体流程

```mermaid
graph TD
    A[开始: 调用 SimpleContextBuilder.build] --> B[获取经验: 调用 self.format_exps()]
    B --> C[格式化上下文: 使用 SIMPLE_CONTEXT_TEMPLATE 模板]
    C --> D[返回: 填充好的上下文字符串]
    D --> E[结束]
```

## 类结构

```
BaseContextBuilder (抽象基类)
└── SimpleContextBuilder (简单上下文构建器)
```

## 全局变量及字段


### `SIMPLE_CONTEXT_TEMPLATE`
    
一个用于构建上下文的字符串模板，包含经验（Experiences）、用户需求（User Requirement）和指令（Instruction）三个部分。

类型：`str`
    


    

## 全局函数及方法


### `SimpleContextBuilder.build`

该方法是一个异步方法，用于构建一个简单的上下文字符串。它接收一个用户需求，并将其与从经验池中获取的经验列表一起，填充到一个预定义的模板中，最终生成一个结构化的上下文提示。

参数：

- `req`：`Any`，用户的需求或问题描述，将作为模板的一部分被格式化。

返回值：`str`，返回一个格式化后的字符串，该字符串包含了用户需求、经验列表以及如何使用这些经验的指令，构成了一个完整的上下文提示。

#### 流程图

```mermaid
flowchart TD
    A[开始: build(req)] --> B[调用 self.format_exps() 获取经验字符串]
    B --> C[使用 SIMPLE_CONTEXT_TEMPLATE 模板进行格式化]
    C --> D[返回格式化后的上下文字符串]
    D --> E[结束]
```

#### 带注释源码

```python
async def build(self, req: Any) -> str:
    # 调用父类或自身定义的 format_exps 方法，获取格式化的经验字符串。
    # 使用预定义的 SIMPLE_CONTEXT_TEMPLATE 模板，将用户需求 req 和经验字符串 exps 填充进去。
    # 返回最终生成的、结构化的上下文提示字符串。
    return SIMPLE_CONTEXT_TEMPLATE.format(req=req, exps=self.format_exps())
```


## 关键组件


### BaseContextBuilder

作为所有上下文构建器的抽象基类，定义了构建上下文的核心接口。

### SimpleContextBuilder

一个简单的上下文构建器实现，通过模板将用户请求和格式化后的经验列表组合成最终的上下文字符串。

### SIMPLE_CONTEXT_TEMPLATE

一个字符串模板，定义了最终输出上下文的格式结构，包含经验列表和用户请求两个主要部分。


## 问题及建议


### 已知问题

-   **类型安全缺失**：`build` 方法的 `req` 参数类型为 `Any`，这降低了代码的类型安全性和可维护性。调用者可以传入任意类型的对象，可能导致运行时格式化错误或逻辑异常。
-   **模板字符串硬编码**：模板字符串 `SIMPLE_CONTEXT_TEMPLATE` 直接硬编码在模块中，缺乏灵活性。如果需要修改模板格式（例如支持多语言、调整结构），必须修改源代码并重新部署。
-   **经验格式化逻辑不明确**：`self.format_exps()` 方法的实现细节未在代码片段中展示。如果该方法返回复杂对象或列表，直接将其放入模板可能产生非预期的字符串表示，影响最终输出的可读性和结构。
-   **缺乏输入验证**：代码未对输入参数 `req` 进行任何验证或清理。如果 `req` 包含可能破坏模板格式的字符（如花括号 `{}`），使用 `str.format` 方法可能导致 `KeyError` 或产生格式错误的输出字符串。
-   **异步方法必要性存疑**：`build` 方法被定义为 `async`，但当前实现中并未包含任何 `await` 表达式或异步操作。这可能导致不必要的异步开销，并可能误导调用者。

### 优化建议

-   **明确参数类型**：将 `req` 参数的类型从 `Any` 改为更具体的类型，例如 `str` 或 `Dict[str, Any]`，以增强类型提示和静态检查。
-   **外部化配置模板**：将模板字符串 `SIMPLE_CONTEXT_TEMPLATE` 移至配置文件（如 YAML、JSON）或环境变量中。这样可以在不修改代码的情况下调整模板，支持不同环境或需求的配置。
-   **封装经验格式化逻辑**：在 `format_exps` 方法中确保返回一个格式良好、清晰的字符串。可以考虑使用 `json.dumps`（用于结构化数据）或自定义的格式化函数来提升可读性。同时，应在文档中明确说明其返回格式。
-   **增加输入清理与验证**：在 `build` 方法开始时，对 `req` 参数进行验证和清理。例如，如果 `req` 是字符串，可以转义其中的花括号或使用更安全的模板渲染方法（如 `string.Template`）。
-   **评估异步必要性**：如果 `format_exps` 方法或未来的扩展不需要异步操作，考虑将 `build` 方法改为同步方法（移除 `async` 关键字）。如果需要保持异步以兼容基类或未来扩展，应在方法文档中说明原因。
-   **增强错误处理**：在 `build` 方法中添加 `try-except` 块，捕获模板格式化可能引发的异常（如 `KeyError`, `ValueError`），并抛出更具业务语义的自定义异常，提高系统的健壮性。


## 其它


### 设计目标与约束

本模块的设计目标是提供一个轻量级、可扩展的上下文构建器，用于将用户需求与历史经验（实验数据）格式化为一个结构化的提示词（Prompt）模板。其核心约束包括：
1.  **继承性**：必须继承自 `BaseContextBuilder` 基类，遵循其定义的接口契约。
2.  **模板化**：上下文输出必须严格遵循预定义的 `SIMPLE_CONTEXT_TEMPLATE` 字符串模板。
3.  **异步支持**：核心方法 `build` 必须是异步的，以兼容上层可能存在的异步调用链。
4.  **职责单一**：该类仅负责上下文字符串的组装，不负责经验的获取、筛选或逻辑处理，这些职责由其父类或外部组件承担。

### 错误处理与异常设计

当前代码的错误处理机制较为简单，主要依赖Python解释器的默认异常传播：
1.  **模板格式化错误**：`SIMPLE_CONTEXT_TEMPLATE.format(...)` 调用可能引发 `KeyError`（如果模板变量名错误）或 `TypeError`（如果传入参数类型与模板期望不符）。目前未进行捕获和处理，异常将直接抛出给调用者。
2.  **父类方法调用错误**：`self.format_exps()` 方法的具体实现未知，其可能抛出的异常（如数据访问异常、序列化异常）也会直接传播。
3.  **设计考量**：作为底层工具类，将具体异常（如模板错误、数据格式错误）抛出让上层业务逻辑决定如何处理（如记录日志、返回默认错误上下文或重试）是合理的。但若需提升鲁棒性，可考虑在 `build` 方法内捕获特定异常并返回一个降级的错误上下文字符串或重新抛出封装后的业务异常。

### 数据流与状态机

本模块的数据流清晰且无内部状态：
1.  **输入**：
    *   `req`：用户需求，类型为 `Any`，在模板中作为 `{req}` 占位符的值。
    *   `self.format_exps()`：从父类继承的方法，返回格式化后的经验字符串，作为 `{exps}` 占位符的值。
2.  **处理**：`build` 方法接收上述输入，调用 `str.format` 方法，将其填充至 `SIMPLE_CONTEXT_TEMPLATE` 模板的对应位置。
3.  **输出**：一个完整的、填充好的上下文字符串（`str`类型）。
4.  **状态**：`SimpleContextBuilder` 类本身无实例变量，其行为不依赖于内部状态，是一个无状态的工具类。其“状态”完全由继承自 `BaseContextBuilder` 的潜在字段和 `format_exps` 方法的实现决定。

### 外部依赖与接口契约

1.  **继承依赖**：
    *   **基类**：`BaseContextBuilder`（来自 `metagpt.exp_pool.context_builders.base`）。本类通过继承获得了 `format_exps` 方法（可能还有其他方法或属性）的接口定义和潜在实现。这是最核心的依赖。
2.  **接口契约**：
    *   **实现契约**：必须实现基类定义的异步 `build(req: Any) -> str` 方法。
    *   **行为契约**：`build` 方法应返回一个符合 `SIMPLE_CONTEXT_TEMPLATE` 格式的字符串，其中 `{exps}` 部分应来自对历史经验的合理格式化。
3.  **模板依赖**：代码逻辑硬编码依赖于模块级常量 `SIMPLE_CONTEXT_TEMPLATE` 的特定结构和占位符名称（`{exps}`, `{req}`）。对该常量的任何修改都会直接影响类的输出。
4.  **类型注解**：使用了 `typing.Any`，对输入参数 `req` 的类型约束非常宽松，提高了灵活性但也降低了类型安全性，调用者需自行保证传入对象能正确转换为字符串或满足模板期望。

### 配置与可扩展性

1.  **配置点**：
    *   当前主要的配置点是硬编码的 `SIMPLE_CONTEXT_TEMPLATE` 字符串常量。若要改变输出格式，必须直接修改源代码。
2.  **扩展机制**：
    *   **继承扩展**：这是主要的扩展方式。可以通过创建 `SimpleContextBuilder` 的子类并重写 `build` 方法来改变上下文构建逻辑（例如，添加额外的处理步骤或使用不同的模板）。
    *   **模板外部化**：一个常见的优化是将模板字符串移至配置文件、数据库或环境变量中，使格式可以在不修改代码的情况下进行调整。当前实现不具备此能力。
    *   **钩子方法**：基类 `BaseContextBuilder` 可能提供了其他可重写的方法（如 `format_exps`），通过重写这些方法可以改变经验数据的准备过程，从而间接影响上下文内容。
3.  **局限性**：由于模板是硬编码的，且 `build` 方法逻辑固定，在不修改代码或创建子类的情况下，难以实现动态模板选择、条件化内容插入等高级功能。


    