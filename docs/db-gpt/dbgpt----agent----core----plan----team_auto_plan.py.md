# `.\DB-GPT-src\dbgpt\agent\core\plan\team_auto_plan.py`

```py
"""Auto plan chat manager agent."""

# 导入日志模块
import logging
# 导入类型提示模块中的相关类型
from typing import Dict, List, Optional, Tuple

# 导入消息模块中的特定类型
from dbgpt.core.interface.message import ModelMessageRoleType

# 导入自定义模块中的相关类和函数
from ..action.base import ActionOutput
from ..agent import Agent, AgentMessage
from ..agent_manage import mentioned_agents, participant_roles
from ..base_agent import ConversableAgent
from ..base_team import ManagerAgent
from ..memory.gpts.base import GptsPlan
from ..plan.planner_agent import PlannerAgent
from ..profile import DynConfig, ProfileConfig
from ..schema import Status

# 设置日志记录器
logger = logging.getLogger(__name__)


class AutoPlanChatManager(ManagerAgent):
    """A chat manager agent that can manage a team chat of multiple agents."""

    # 定义配置文件对象
    profile: ProfileConfig = ProfileConfig(
        # 定义代理名称的动态配置
        name=DynConfig(
            "AutoPlanChatManager",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_name",
        ),
        # 定义代理角色的动态配置
        role=DynConfig(
            "PlanManager",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_role",
        ),
        # 定义代理目标的动态配置
        goal=DynConfig(
            "Advance the task plan generated by the planning agent. If the plan "
            "does not pre-allocate an agent, it needs to be coordinated with the "
            "appropriate agent to complete.",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_goal",
        ),
        # 定义代理描述的动态配置
        desc=DynConfig(
            "Advance the task plan generated by the planning agent.",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_desc",
        ),
    )

    def __init__(self, **kwargs):
        """Create a new AutoPlanChatManager instance."""
        # 调用父类的初始化方法
        super().__init__(**kwargs)

    async def process_rely_message(
        self, conv_id: str, now_plan: GptsPlan, speaker: Agent
    ):
        """Process the dependent message."""
        # 初始化依赖相关变量
        rely_prompt = None
        rely_messages: List[Dict] = []

        # 检查当前计划是否有依赖任务
        if now_plan.rely and len(now_plan.rely) > 0:
            # 将依赖任务列表分割为整数列表
            rely_tasks_list = now_plan.rely.split(",")
            rely_tasks_list_int = [int(i) for i in rely_tasks_list]
            
            # 查询内存中符合对话 ID 和任务编号的依赖任务
            rely_tasks = self.memory.plans_memory.get_by_conv_id_and_num(
                conv_id, rely_tasks_list_int
            )
            
            # 如果存在依赖任务，准备依赖提示和相关消息
            if rely_tasks:
                rely_prompt = (
                    "Read the result data of the dependent steps in the above"
                    " historical message to complete the current goal:"
                )
                # 遍历依赖任务列表，构建消息字典并添加到消息列表中
                for rely_task in rely_tasks:
                    rely_messages.append(
                        {
                            "content": rely_task.sub_task_content,
                            "role": ModelMessageRoleType.HUMAN,
                            "name": rely_task.sub_task_agent,
                        }
                    )
                    rely_messages.append(
                        {
                            "content": rely_task.result,
                            "role": ModelMessageRoleType.AI,
                            "name": rely_task.sub_task_agent,
                        }
                    )
        
        # 返回依赖提示和相关消息列表
        return rely_prompt, rely_messages

    def select_speaker_msg(self, agents: List[Agent]) -> str:
        """Return the message for selecting the next speaker."""
        # 提取代理人名称列表
        agent_names = [agent.name for agent in agents]
        
        # 返回选择下一个发言者的提示消息
        return (
            "You are in a role play game. The following roles are available:\n"
            f"   {participant_roles(agents)}.\n"
            "   Read the following conversation.\n"
            f"   Then select the next role from {agent_names} to play.\n"
            "   The role can be selected repeatedly.Only return the role."
        )

    async def select_speaker(
        self,
        last_speaker: Agent,
        selector: Agent,
        now_goal_context: Optional[str] = None,
        pre_allocated: Optional[str] = None,
    ) -> Tuple[Agent, Optional[str]]:
        """Select the next speaker."""
        # 获取当前对话中的所有代理人列表
        agents = self.agents

        if pre_allocated:
            # 如果预先分配了发言者，则直接使用预分配的发言者
            logger.info(f"Preselect speakers:{pre_allocated}")
            name = pre_allocated
            model = None
        else:
            # 否则自动选择发言者
            # TODO selector a_thinking It has been overwritten and cannot be used.
            # 获取所有代理人的名称列表
            agent_names = [agent.name for agent in agents]
            # 调用选择器的思考方法，选择下一个发言者的名称和相关模型
            fina_name, model = await selector.thinking(
                messages=[
                    AgentMessage(
                        role=ModelMessageRoleType.HUMAN,
                        content="Read and understand the following task content and"
                        " assign the appropriate role to complete the task.\n"
                        f"Task content: {now_goal_context},\n"
                        f"Select the role from: {agent_names},\n"
                        f"Please only return the role, such as: {agents[0].name}",
                    )
                ],
                prompt=self.select_speaker_msg(agents),
            )
            # 如果没有成功选择到发言者，则抛出数值错误
            if not fina_name:
                raise ValueError("Unable to select next speaker!")
            else:
                name = fina_name

        # 如果只提到了一个代理人，则使用该代理人，否则保持 OAI 响应不变
        mentions = mentioned_agents(name, agents)
        if len(mentions) == 1:
            name = next(iter(mentions))
        else:
            # 记录警告日志，指出无法解析下一个发言者的名称
            logger.warning(
                "GroupChat select_speaker failed to resolve the next speaker's name. "
                f"This is because the speaker selection OAI call returned:\n{name}"
            )

        # 返回结果
        try:
            # 尝试根据名称获取代理人对象，并返回其及模型
            return self.agent_by_name(name), model
        except Exception as e:
            # 如果选择发言者失败，记录异常日志并抛出数值错误
            logger.exception(f"auto select speaker failed!{str(e)}")
            raise ValueError("Unable to select next speaker!")

    async def act(
        self,
        message: Optional[str],
        sender: Optional[Agent] = None,
        reviewer: Optional[Agent] = None,
        **kwargs,
```