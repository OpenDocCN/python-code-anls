# `.\DB-GPT-src\dbgpt\agent\core\memory\base.py`

```py
"""Memory for agent.

Human memory follows a general progression from sensory memory that registers
perceptual inputs, to short-term memory that maintains information transiently, to
long-term memory that consolidates information over extended periods.
"""

import asyncio
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
)

from dbgpt.core import LLMClient
from dbgpt.util.annotations import PublicAPI, immutable, mutable

T = TypeVar("T", bound="MemoryFragment")
M = TypeVar("M", bound="Memory")


class WriteOperation(str, Enum):
    """Write operation."""

    ADD = "add"
    RETRIEVAL = "retrieval"


@PublicAPI(stability="beta")
class MemoryFragment(ABC):
    """Memory fragment interface.

    It is the interface of memory fragment, which is the basic unit of memory, which
    contains the basic information of memory, such as observation, importance, whether
    it is insight, last access time, etc
    """

    @classmethod
    @abstractmethod
    def build_from(
        cls: Type[T],
        observation: str,
        embeddings: Optional[List[float]] = None,
        memory_id: Optional[int] = None,
        importance: Optional[float] = None,
        is_insight: bool = False,
        last_accessed_time: Optional[datetime] = None,
        **kwargs,
    ) -> T:
        """Build a memory fragment from memory id and observation.

        Args:
            observation(str): Observation
            embeddings(List[float], optional): Embeddings of the memory fragment.
            memory_id(int): Memory id
            importance(float): Importance
            is_insight(bool): Whether the memory fragment is an insight
            last_accessed_time(datetime): Last accessed time

        Returns:
            MemoryFragment: Memory fragment
        """
        raise NotImplementedError

    @property
    @abstractmethod
    def id(self) -> int:
        """Return the id of the memory fragment.

        Commonly, the id is generated by Snowflake algorithm. So we can parse the
        timestamp of when the memory fragment is created.

        Returns:
            int: id
        """

    @property
    def metadata(self) -> Dict[str, Any]:
        """Return the metadata of the memory fragment.

        Returns:
            Dict[str, Any]: Metadata
        """
        return {}

    @property
    def importance(self) -> Optional[float]:
        """Return the importance of the memory fragment.

        It should be noted that importance only reflects the characters of the memory
        itself.

        Returns:
            Optional[float]: importance, None means the importance is not available.
        """
        return None

    @abstractmethod
    def update_importance(self, importance: float) -> Optional[float]:
        """Update the importance of the memory fragment.

        Args:
            importance(float): importance to be updated

        Returns:
            Optional[float]: updated importance
        """

    @property
    @abstractmethod
    def raw_observation(self) -> str:
        """Return the raw observation.

        Raw observation is the original observation data, it can be an observation from
         environment or an observation after executing an action.

        Returns:
            str: raw observation
        """

    @property
    def embeddings(self) -> Optional[List[float]]:
        """Return the embeddings of the memory fragment.

        Returns:
            Optional[List[float]]: embeddings of the memory fragment or None if not available
        """
        return None

    @abstractmethod
    def update_embeddings(self, embeddings: List[float]) -> None:
        """Update the embeddings of the memory fragment.

        Args:
            embeddings(List[float]): new embeddings to be updated
        """

    def calculate_current_embeddings(
        self, embedding_func: Callable[[List[str]], List[List[float]]]
    ) -> List[float]:
        """Calculate the embeddings of the memory fragment.

        Args:
            embedding_func(Callable[[List[str]], List[List[float]]]): Function to
                compute embeddings

        Returns:
            List[float]: Embeddings of the memory fragment

        Raises:
            NotImplementedError: This method needs to be implemented in subclasses
        """
        raise NotImplementedError

    @property
    @abstractmethod
    def is_insight(self) -> bool:
        """Return whether the memory fragment is an insight.

        Returns:
            bool: whether the memory fragment is considered an insight.
        """

    @property
    @abstractmethod
    def last_accessed_time(self) -> Optional[datetime]:
        """Return the last accessed time of the memory fragment.

        Returns:
            Optional[datetime]: last accessed time of the memory fragment
        """

    @abstractmethod
    def update_accessed_time(self, now: datetime) -> Optional[datetime]:
        """Update the last accessed time of the memory fragment.

        Args:
            now(datetime): The current time

        Returns:
            Optional[datetime]: The updated last accessed time of the memory fragment
        """

    @abstractmethod
    def copy(self: T) -> T:
        """Copy the memory fragment.

        Returns:
            T: A copy of the memory fragment
        """

    def reduce(self, memory_fragments: List[T], **kwargs) -> T:
        """Reduce memory fragments to a single memory fragment.

        Args:
            memory_fragments(List[T]): List of memory fragments to be reduced

        Returns:
            T: The reduced memory fragment
        """
        obs = []
        for memory_fragment in memory_fragments:
            obs.append(memory_fragment.raw_observation)
        new_observation = ";".join(obs)
        return self.current_class.build_from(new_observation, **kwargs)  # type: ignore

    @property
    def current_class(self: T) -> Type[T]:
        """Return the current class.

        Returns:
            Type[T]: The class type of the current memory fragment instance
        """
        return self.__class__
class InsightMemoryFragment(Generic[T]):
    """Insight memory fragment.

    Insight memory fragment is a memory fragment that contains insights.
    """

    def __init__(
        self,
        original_memory_fragment: Union[T, List[T]],
        insights: Union[List[T], List[str]],
    ):
        """Create an insight memory fragment.

        Insight is also a memory fragment.
        """
        # 检查是否传入了 insights，并且第一个元素是字符串类型
        if insights and isinstance(insights[0], str):
            # 如果 original_memory_fragment 是列表，则取第一个元素作为 mf
            mf = (
                original_memory_fragment[0]
                if isinstance(original_memory_fragment, list)
                else original_memory_fragment
            )
            # 使用 mf.current_class.build_from 创建 insights 列表，标记为 insight
            insights = [
                mf.current_class.build_from(i, is_insight=True) for i in insights  # type: ignore # noqa
            ]
        # 设置实例变量 _original_memory_fragment 为传入的 original_memory_fragment
        self._original_memory_fragment = original_memory_fragment
        # 设置实例变量 _insights 为经过处理后的 insights 列表
        self._insights: List[T] = cast(List[T], insights)

    @property
    def original_memory_fragment(self) -> Union[T, List[T]]:
        """Return the original memory fragment."""
        # 返回实例变量 _original_memory_fragment
        return self._original_memory_fragment

    @property
    def insights(self) -> List[T]:
        """Return the insights."""
        # 返回实例变量 _insights
        return self._insights


class DiscardedMemoryFragments(Generic[T]):
    """Discarded memory fragments.

    Sometimes, we need to discard some memory fragments, there are following cases:
    1. Memory duplicated, the same/similar action is executed multiple times and the
        same/similar observation from environment is received.
    2. Memory overflow. The memory is full and the new memory fragment needs to be
    written.
    3. The memory fragment is not important enough.
    4. Simulation of forgetting mechanism.

    The discarded memory fragments may be transferred to another memory.
    """

    def __init__(
        self,
        discarded_memory_fragments: List[T],
        discarded_insights: Optional[List[InsightMemoryFragment[T]]] = None,
    ):
        """Create a discarded memory fragments."""
        # 如果没有传入 discarded_insights，则设置为空列表
        if discarded_insights is None:
            discarded_insights = []
        # 设置实例变量 _discarded_memory_fragments 为传入的 discarded_memory_fragments
        self._discarded_memory_fragments = discarded_memory_fragments
        # 设置实例变量 _discarded_insights 为传入的 discarded_insights
        self._discarded_insights = discarded_insights

    @property
    def discarded_memory_fragments(self) -> List[T]:
        """Return the discarded memory fragments."""
        # 返回实例变量 _discarded_memory_fragments
        return self._discarded_memory_fragments

    @property
    def discarded_insights(self) -> List[InsightMemoryFragment[T]]:
        """Return the discarded insights."""
        # 返回实例变量 _discarded_insights
        return self._discarded_insights


class InsightExtractor(ABC, Generic[T]):
    """Insight extractor interface.

    Obtain high-level insights from memories.
    """

    @abstractmethod
    async def extract_insights(
        self,
        memory_fragment: T,
        llm_client: Optional[LLMClient] = None,
    ):
        """Extract insights from a memory fragment.

        This method should extract high-level insights from the given memory fragment.
        """
        # 抽象方法，派生类需要实现具体的逻辑
        pass
    ) -> InsightMemoryFragment[T]:
        """Extract insights from memory fragments.

        Args:
            memory_fragment(T): Memory fragment
                参数 memory_fragment(T): 表示内存片段，类型为 T
            llm_client(Optional[LLMClient]): LLM client
                参数 llm_client(Optional[LLMClient]): 可选参数，表示LLM客户端，类型为 LLMClient 或者 None

        Returns:
            InsightMemoryFragment: The insights of the memory fragment.
                返回值 InsightMemoryFragment: 返回内存片段的洞察结果，类型为 InsightMemoryFragment
        """
# 定义一个抽象基类 ImportanceScorer，用于评分记忆重要性的接口
class ImportanceScorer(ABC, Generic[T]):
    """Importance scorer interface.

    Score the importance of memories.
    """

    @abstractmethod
    async def score_importance(
        self,
        memory_fragment: T,
        llm_client: Optional[LLMClient] = None,
    ) -> float:
        """Score the importance of memory fragment.

        Args:
            memory_fragment(T): Memory fragment.
            llm_client(Optional[LLMClient]): LLM client

        Returns:
            float: The importance of the memory fragment.
        """


# 声明一个内存接口 Memory，用于操作记忆相关的功能
@PublicAPI(stability="beta")
class Memory(ABC, Generic[T]):
    """Memory interface."""

    # 内存的名称
    name: Optional[str] = None
    # 连接到长期记忆存储的客户端
    llm_client: Optional[LLMClient] = None
    # 用于评估记忆重要性的评分器
    importance_scorer: Optional[ImportanceScorer] = None
    # 用于提取记忆洞察的对象
    insight_extractor: Optional[InsightExtractor] = None
    # 实际存储的记忆片段类
    _real_memory_fragment_class: Optional[Type[T]] = None
    # 记忆的重要性权重，默认为 0.15
    importance_weight: float = 0.15

    # 初始化内存对象的可变方法
    @mutable
    def initialize(
        self,
        name: Optional[str] = None,
        llm_client: Optional[LLMClient] = None,
        importance_scorer: Optional[ImportanceScorer] = None,
        insight_extractor: Optional[InsightExtractor] = None,
        real_memory_fragment_class: Optional[Type[T]] = None,
    ) -> None:
        """Initialize memory.

        Some agent may need to initialize memory before using it.
        """
        self.name = name
        self.llm_client = llm_client
        self.importance_scorer = importance_scorer
        self.insight_extractor = insight_extractor
        self._real_memory_fragment_class = real_memory_fragment_class

    # 返回内存结构克隆的抽象方法
    @abstractmethod
    @immutable
    def structure_clone(self: M, now: Optional[datetime] = None) -> M:
        """Return a structure clone of the memory.

        Sometimes, we need to clone the structure of the memory, but not the content.

        There some cases:

        1. When we need to reset the memory, we can use this method to create a new
        one, and the new memory has the same structure as the old one.
        2. Create a new agent, the new agent has the same memory structure as the
        planner.

        Args:
            now(Optional[datetime]): The current time

        Returns:
            M: The structure clone of the memory

        """
        raise NotImplementedError

    # 从另一个内存对象复制内存的可变方法
    @mutable
    def _copy_from(self, memory: "Memory") -> None:
        """Copy memory from another memory.

        Args:
            memory(Memory): Another memory
        """
        self.name = memory.name
        self.llm_client = memory.llm_client
        self.importance_scorer = memory.importance_scorer
        self.insight_extractor = memory.insight_extractor
        self._real_memory_fragment_class = memory._real_memory_fragment_class

    # 写入内存的抽象异步方法
    @abstractmethod
    @mutable
    async def write(
        self,
        memory_fragment: T,
        now: Optional[datetime] = None,
        op: WriteOperation = WriteOperation.ADD,
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Write a memory fragment to memory.

        Two situations need to be noted here:
        1. Memory duplicated, the same/similar action is executed multiple times and
            the same/similar observation from environment is received.

        2.Memory overflow. The memory is full and the new memory fragment needs to be
            written to memory, the common strategy is to discard some memory fragments.

        Args:
            memory_fragment(T): Memory fragment
            now(Optional[datetime]): The current time
            op(WriteOperation): Write operation

        Returns:
            Optional[DiscardedMemoryFragments]: The discarded memory fragments, None
                means no memory fragments are discarded.
        """
        # Implementation of this method is missing or not provided
        pass

    @mutable
    async def write_batch(
        self, memory_fragments: List[T], now: Optional[datetime] = None
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Write a batch of memory fragments to memory.

        Args:
            memory_fragments(List[T]): Memory fragments
            now(Optional[datetime]): The current time

        Returns:
            Optional[DiscardedMemoryFragments]: The discarded memory fragments, None
                means no memory fragments are discarded.
        """
        raise NotImplementedError

    @abstractmethod
    @immutable
    async def read(
        self,
        observation: str,
        alpha: Optional[float] = None,
        beta: Optional[float] = None,
        gamma: Optional[float] = None,
    ) -> List[T]:
        r"""Read memory fragments by observation.

        Usually, there three commonly used criteria for information extraction, that is,
        the recency, relevance, and importance

        Memories that are more recent, relevant, and important are more likely to be
        extracted. Formally, we conclude the following equation from existing
        literature for memory information extraction:

        .. math::

            m^* = \arg\min_{m \in M} \alpha s^{\text{rec}}(q, m) + \\
            \beta s^{\text{rel}}(q, m) + \gamma s^{\text{imp}}(m), \tag{1}

        Args:
            observation(str): observation(Query)
            alpha(float, optional): Recency coefficient. Default is None.
            beta(float, optional): Relevance coefficient. Default is None.
            gamma(float, optional): Importance coefficient. Default is None.

        Returns:
            List[T]: memory fragments
        """
        # Method signature and docstring define an abstract method for reading memory fragments
        # based on specific observation criteria. Actual implementation is missing.
        raise NotImplementedError

    @immutable
    async def reflect(self, memory_fragments: List[T]) -> List[T]:
        """Reflect memory fragments by observation.

        Args:
            memory_fragments(List[T]): memory fragments to be reflected.

        Returns:
            List[T]: memory fragments after reflection.
        """
        return memory_fragments

    @immutable
    async def handle_duplicated(
        self, memory_fragments: List[T], new_memory_fragments: List[T]
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Handle duplicated memory fragments.

        This method is responsible for managing situations where duplicated memory
        fragments are detected.

        Args:
            memory_fragments(List[T]): Existing memory fragments
            new_memory_fragments(List[T]): New memory fragments

        Returns:
            Optional[DiscardedMemoryFragments]: The discarded memory fragments, None
                means no memory fragments are discarded.
        """
        # Implementation of this method is missing or not provided
        pass
    ) -> List[T]:
        """
        Handle duplicated memory fragments.

        Args:
            memory_fragments(List[T]): Existing memory fragments
            new_memory_fragments(List[T]): New memory fragments

        Returns:
            List[T]: The new memory fragments after handling duplicated memory
                fragments.
        """
        return memory_fragments + new_memory_fragments

    @mutable
    async def handle_overflow(
        self, memory_fragments: List[T]
    ) -> Tuple[List[T], List[T]]:
        """
        Handle memory overflow.

        Args:
            memory_fragments(List[T]): Existing memory fragments

        Returns:
            Tuple[List[T], List[T]]: The memory fragments after handling overflow and
                the discarded memory fragments.
        """
        return memory_fragments, []

    @abstractmethod
    @mutable
    async def clear(self) -> List[T]:
        """
        Clear all memory fragments.

        Returns:
            List[T]: The all cleared memory fragments.
        """

    @immutable
    async def get_insights(
        self, memory_fragments: List[T]
    ) -> List[InsightMemoryFragment[T]]:
        """
        Get insights from memory fragments.

        Args:
            memory_fragments(List[T]): Memory fragments

        Returns:
            List[InsightMemoryFragment]: The insights of the memory fragments.
        """
        if not self.insight_extractor:
            return []
        
        # Obtain insights in parallel from memory fragments
        tasks = []
        for memory_fragment in memory_fragments:
            tasks.append(
                self.insight_extractor.extract_insights(
                    memory_fragment, self.llm_client
                )
            )
        insights = await asyncio.gather(*tasks)
        
        result = []
        for insight in insights:
            if not insight:
                continue
            result.append(insight)
        
        if len(result) != len(insights):
            raise ValueError(
                "The number of insights is not equal to the number of memory fragments."
            )
        
        return result

    @immutable
    async def score_memory_importance(self, memory_fragments: List[T]) -> List[float]:
        """
        Score the importance of memory fragments.

        Args:
            memory_fragments(List[T]): Memory fragments

        Returns:
            List[float]: The importance of memory fragments.
        """
        if not self.importance_scorer:
            return [5 * self.importance_weight for _ in memory_fragments]
        
        tasks = []
        for memory_fragment in memory_fragments:
            tasks.append(
                self.importance_scorer.score_importance(
                    memory_fragment, self.llm_client
                )
            )
        
        result = []
        for importance in await asyncio.gather(*tasks):
            real_score = importance * self.importance_weight
            result.append(real_score)
        
        return result
    # 使用@property装饰器将方法转换为属性访问
    @property
    # 使用@immutable装饰器标记该属性为不可变的
    @immutable
    # 方法定义，返回类型为泛型类型T的实际内存片段类
    def real_memory_fragment_class(self) -> Type[T]:
        """Return the real memory fragment class."""
        # 如果_real_memory_fragment_class属性未设置，抛出数值错误异常
        if not self._real_memory_fragment_class:
            raise ValueError("The real memory fragment class is not set.")
        # 返回_real_memory_fragment_class属性对应的值
        return self._real_memory_fragment_class
class SensoryMemory(Memory, Generic[T]):
    """Sensory memory."""

    # 设置重要性权重，默认为0.9
    importance_weight: float = 0.9
    # 设置转移到短期记忆的阈值，默认为0.1
    threshold_to_short_term: float = 0.1

    def __init__(self, buffer_size: int = 0):
        """Create a sensory memory."""
        # 初始化缓冲区大小
        self._buffer_size = buffer_size
        # 初始化碎片列表为空列表
        self._fragments: List[T] = []
        # 初始化异步锁对象
        self._lock = asyncio.Lock()

    def structure_clone(
        self: "SensoryMemory[T]", now: Optional[datetime] = None
    ) -> "SensoryMemory[T]":
        """Return a structure clone of the memory."""
        # 创建并返回当前记忆的结构克隆
        m: SensoryMemory[T] = SensoryMemory(buffer_size=self._buffer_size)
        # 从当前对象复制状态到新对象
        m._copy_from(self)
        return m

    @mutable
    async def write(
        self,
        memory_fragment: T,
        now: Optional[datetime] = None,
        op: WriteOperation = WriteOperation.ADD,
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Write a memory fragment to sensory memory."""
        # 处理重复的记忆碎片
        fragments = await self.handle_duplicated(self._fragments, [memory_fragment])
        # 初始化被丢弃的碎片列表为空列表
        discarded_fragments: List[T] = []
        # 如果碎片数量超过缓冲区大小
        if len(fragments) > self._buffer_size:
            # 处理溢出的碎片
            fragments, discarded_fragments = await self.handle_overflow(fragments)

        # 异步上下文中锁定
        async with self._lock:
            # 清空当前碎片
            await self.clear()
            # 更新当前碎片列表
            self._fragments = fragments
        # 如果没有丢弃的碎片则返回None，否则返回被丢弃的碎片对象
        if not discarded_fragments:
            return None
        return DiscardedMemoryFragments(discarded_fragments, [])

    @immutable
    async def read(
        self,
        observation: str,
        alpha: Optional[float] = None,
        beta: Optional[float] = None,
        gamma: Optional[float] = None,
    ) -> List[T]:
        """Read memory fragments by observation."""
        # 返回当前碎片列表
        return self._fragments

    @mutable
    async def handle_overflow(
        self, memory_fragments: List[T]
    ) -> Tuple[List[T], List[T]]:
        """Handle memory overflow.

        For sensory memory, the overflow strategy is to transfer all memory fragments
        to short-term memory.

        Args:
            memory_fragments(List[T]): Existing memory fragments

        Returns:
            Tuple[List[T], List[T]]: The memory fragments after handling overflow and
                the discarded memory fragments, the discarded memory fragments should
                be transferred to short-term memory.
        """
        # 计算碎片的重要性得分
        scores = await self.score_memory_importance(memory_fragments)
        # 初始化结果列表
        result = []
        # 遍历碎片列表
        for i, memory in enumerate(memory_fragments):
            # 如果重要性得分大于等于转移到短期记忆的阈值
            if scores[i] >= self.threshold_to_short_term:
                # 更新碎片的重要性
                memory.update_importance(scores[i])
                # 将碎片添加到结果列表中
                result.append(memory)
        # 返回空列表和结果列表
        return [], result

    @mutable
    async def clear(self) -> List[T]:
        """Clear all memory fragments."""
        # 复制当前碎片列表
        fragments = self._fragments
        # 清空当前碎片列表
        self._fragments = []
        # 返回之前的碎片列表
        return fragments


class ShortTermMemory(Memory, Generic[T]):
    """Short term memory.

    All memories are stored in computer memory.
    """
    def __init__(self, buffer_size: int = 5):
        """Initialize ShortTermMemory with a specified buffer size.

        Args:
            buffer_size (int): Size limit for the short-term memory buffer.
        """
        self._buffer_size = buffer_size
        self._fragments: List[T] = []  # Initialize an empty list to store memory fragments
        self._lock = asyncio.Lock()  # Initialize a lock for asynchronous access control

    def structure_clone(
        self: "ShortTermMemory[T]", now: Optional[datetime] = None
    ) -> "ShortTermMemory[T]":
        """Create a structure clone of the current ShortTermMemory instance.

        Args:
            now (Optional[datetime]): Optional current time reference.

        Returns:
            ShortTermMemory[T]: A new instance that is a structure clone of the current instance.
        """
        m: ShortTermMemory[T] = ShortTermMemory(buffer_size=self._buffer_size)
        m._copy_from(self)
        return m

    @mutable
    async def write(
        self,
        memory_fragment: T,
        now: Optional[datetime] = None,
        op: WriteOperation = WriteOperation.ADD,
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Write a memory fragment to the short-term memory.

        Args:
            memory_fragment (T): New memory fragment to write.
            now (Optional[datetime]): Optional current time reference.
            op (WriteOperation): Write operation mode.

        Returns:
            Optional[DiscardedMemoryFragments]: Discarded memory fragments, or None if none were discarded.
        """
        fragments = await self.handle_duplicated(self._fragments, [memory_fragment])

        async with self._lock:
            await self.clear()  # Clear the short-term memory (not specified in provided code)
            self._fragments = fragments  # Update memory fragments with possibly deduplicated ones
            discarded_memories = await self.transfer_to_long_term(memory_fragment)
            fragments, discarded_fragments = await self.handle_overflow(self._fragments)
            self._fragments = fragments  # Update memory fragments after handling overflow
            return discarded_memories

    @immutable
    async def read(
        self,
        observation: str,
        alpha: Optional[float] = None,
        beta: Optional[float] = None,
        gamma: Optional[float] = None,
    ) -> List[T]:
        """Read memory fragments based on an observation.

        Args:
            observation (str): Observation criteria for selecting memory fragments.
            alpha (Optional[float]): Optional parameter alpha.
            beta (Optional[float]): Optional parameter beta.
            gamma (Optional[float]): Optional parameter gamma.

        Returns:
            List[T]: List of memory fragments that match the observation criteria.
        """
        return self._fragments

    @mutable
    async def transfer_to_long_term(
        self, memory_fragment: T
    ) -> Optional[DiscardedMemoryFragments[T]]:
        """Transfer the oldest memories to long-term memory if the buffer size is exceeded.

        Args:
            memory_fragment (T): Memory fragment to potentially transfer.

        Returns:
            Optional[DiscardedMemoryFragments]: Discarded memory fragments and insights, if any are transferred.
        """
        if len(self._fragments) > self._buffer_size:
            overflow_cnt = len(self._fragments) - self._buffer_size
            self._fragments = self._fragments[overflow_cnt:]  # Keep the most recent memories
            overflow_fragments = self._fragments[:overflow_cnt]  # Get the overflowed fragments
            insights = await self.get_insights(overflow_fragments)
            return DiscardedMemoryFragments(overflow_fragments, insights)
        else:
            return None

    @mutable
    # 异步方法：清除所有内存片段，并返回清除前的片段列表
    async def clear(self) -> List[T]:
        """Clear all memory fragments."""
        # 使用 async with 来确保在并发情况下正确处理锁
        # async with self._lock:
        # 将当前内存片段列表赋值给变量 fragments
        fragments = self._fragments
        # 清空 self._fragments 列表
        self._fragments = []
        # 返回之前的内存片段列表
        return fragments

    # 属性装饰器：不可变的属性，用于返回短期记忆列表
    @property
    @immutable
    def short_term_memories(self) -> List[T]:
        """Return short-term memories."""
        # 返回当前的短期记忆列表 self._fragments
        return self._fragments
```