# `.\pytorch\torchgen\utils.py`

```
# 引入未来版本的类型注解，允许在类型注解中使用TypeVar等特定语法
from __future__ import annotations

# 上下文管理工具，用于简化资源管理和异常处理的代码
import contextlib
# 函数工具，提供了一些用于函数操作的装饰器，如lru_cache
import functools
# 提供了常见的哈希算法，如MD5, SHA1等
import hashlib
# 提供了与操作系统相关的功能，如文件操作等
import os
# 提供了正则表达式的支持
import re
# 提供了与Python解释器相关的功能和变量
import sys
# 提供了文本包装和填充功能，如文本缩进
import textwrap

# 用于数据类操作的一些工具，如获取数据类的字段
from dataclasses import fields, is_dataclass
# 枚举类型，提供了枚举的定义和操作
from enum import auto, Enum
# 提供了类型提示中的Literal类型
from typing import (
    Any,
    Callable,
    Generic,
    Iterable,
    Iterator,
    Literal,
    NoReturn,
    Sequence,
    TYPE_CHECKING,
    TypeVar,
)
# 提供了类型提示的扩展，如Self类型
from typing_extensions import Self

# 引入来自外部库的代码模板，这里特指torchgen库中的CodeTemplate类
from torchgen.code_template import CodeTemplate

# 如果是类型检查阶段，引入argparse中的Namespace类型
if TYPE_CHECKING:
    from argparse import Namespace

# 多个函数共享逻辑用于定义和声明的部分，例如函数签名相同，
# 因此我们将它们组织到一个函数中，该函数接受一个Target参数来指定我们需要的代码类型。

# 这是一个开放式枚举（我们可能会在未来添加更多案例），因此确保显式地指定
# 使用哪些目标类型（例如Literal[Target.XXX]或Literal[Target.XXX, Target.YYY]）在您的使用中是有效的。
class Target(Enum):
    # 顶层命名空间（不包括at）
    DEFINITION = auto()
    # 声明部分
    DECLARATION = auto()
    # TORCH_LIBRARY(...) { ... }
    REGISTRATION = auto()
    # 匿名定义部分
    ANONYMOUS_DEFINITION = auto()
    # 命名空间 { ... }
    NAMESPACED_DEFINITION = auto()
    # 命名空间声明部分
    NAMESPACED_DECLARATION = auto()

# 用于在导数公式中搜索参数出现的正则表达式模式
IDENT_REGEX = r"(^|\W){}($|\W)"

# TODO: 这里应该使用真正的解析器；这段代码容易出错

# 将字符串schema拆分为函数名称和参数列表的元组
def split_name_params(schema: str) -> tuple[str, list[str]]:
    m = re.match(r"(\w+)(\.\w+)?\((.*)\)", schema)
    if m is None:
        raise RuntimeError(f"Unsupported function schema: {schema}")
    name, _, params = m.groups()
    return name, params.split(", ")

# 定义一个泛型类型变量T和S
T = TypeVar("T")
S = TypeVar("S")

# 这两个函数有意返回生成器，类似于map()，以便在需要时不要混淆它们
# 返回可能为None的函数的映射结果，从输出序列中省略None值
def mapMaybe(func: Callable[[T], S | None], xs: Iterable[T]) -> Iterator[S]:
    for x in xs:
        r = func(x)
        if r is not None:
            yield r

# 返回函数返回序列并将它们连接在一起的映射结果
def concatMap(func: Callable[[T], Sequence[S]], xs: Iterable[T]) -> Iterator[S]:
    for x in xs:
        yield from func(x)

# 在异常中添加错误上下文的小技巧，方便指出在处理特定上下文时发生的错误
@contextlib.contextmanager
def context(msg_fn: Callable[[], str]) -> Iterator[None]:
    try:
        yield
    except Exception as e:
        # TODO: 这段代码在处理KeyError时会出现问题
        msg = msg_fn()
        msg = textwrap.indent(msg, "  ")
        msg = f"{e.args[0]}\n{msg}" if e.args else msg
        e.args = (msg,) + e.args[1:]
        raise

# 来自https://github.com/python/mypy/issues/6366的小技巧，
# 用于让mypy执行完整性检查
# TODO: put this somewhere else, maybe
def assert_never(x: NoReturn) -> NoReturn:
    raise AssertionError(f"Unhandled type: {type(x).__name__}")

# 使用functools模块的lru_cache装饰器，将_read_template函数包装为LRU缓存版本，maxsize=None表示缓存大小无限制
@functools.lru_cache(maxsize=None)
# 从文件中读取代码模板，返回CodeTemplate对象
def _read_template(template_fn: str) -> CodeTemplate:
    return CodeTemplate.from_file(template_fn)

# 计算字符串的稳定哈希值，使用SHA-1算法计算字符串的哈希值，并返回整数类型的哈希值
def string_stable_hash(s: str) -> int:
    sha1 = hashlib.sha1(s.encode("latin1")).digest()
    return int.from_bytes(sha1, byteorder="little")

# 文件管理器类，用于生成文件并跟踪已生成的文件列表
class FileManager:
    install_dir: str  # 安装目录路径
    template_dir: str  # 模板文件目录路径
    dry_run: bool  # 是否为模拟运行模式
    filenames: set[str]  # 已生成文件名集合

    def __init__(self, install_dir: str, template_dir: str, dry_run: bool) -> None:
        # 初始化文件管理器，设置安装目录、模板文件目录、模拟运行模式，并初始化已生成文件名集合为空集合
        self.install_dir = install_dir
        self.template_dir = template_dir
        self.filenames = set()
        self.dry_run = dry_run

    def _write_if_changed(self, filename: str, contents: str) -> None:
        old_contents: str | None
        try:
            # 尝试读取文件原内容
            with open(filename) as f:
                old_contents = f.read()
        except OSError:
            old_contents = None
        if contents != old_contents:
            # 如果新内容与旧内容不同，则写入新内容到文件中
            # 如果目录不存在，则创建目录
            os.makedirs(os.path.dirname(filename), exist_ok=True)
            with open(filename, "w") as f:
                f.write(contents)

    # 使用指定模板替换文件内容并写入文件
    def substitute_with_template(
        self, template_fn: str, env_callable: Callable[[], str | dict[str, Any]]
    ) -> str:
        # 构建模板文件路径
        template_path = os.path.join(self.template_dir, template_fn)
        # 获取环境变量
        env = env_callable()
        if isinstance(env, dict):
            # 如果环境变量是字典类型，则添加生成的注释到环境变量中，并使用模板文件生成最终内容
            if "generated_comment" not in env:
                comment = "@" + "generated by torchgen/gen.py"
                comment += f" from {os.path.basename(template_path)}"
                env["generated_comment"] = comment
            # 从文件中读取模板并替换内容
            template = _read_template(template_path)
            return template.substitute(env)
        elif isinstance(env, str):
            # 如果环境变量是字符串类型，则直接返回该字符串
            return env
        else:
            # 否则，如果出现未处理的类型，则触发断言异常
            assert_never(env)

    # 使用模板生成内容并写入指定文件
    def write_with_template(
        self,
        filename: str,
        template_fn: str,
        env_callable: Callable[[], str | dict[str, Any]],
    ) -> None:
        # 构建完整的文件路径
        filename = f"{self.install_dir}/{filename}"
        # 检查文件名是否已经存在于已生成文件集合中，如果存在则抛出重复写入异常
        assert filename not in self.filenames, "duplicate file write {filename}"
        # 将文件名添加到已生成文件集合中
        self.filenames.add(filename)
        if not self.dry_run:
            # 如果不是模拟运行模式，则使用模板生成内容，并写入文件
            substitute_out = self.substitute_with_template(
                template_fn=template_fn,
                env_callable=env_callable,
            )
            self._write_if_changed(filename=filename, contents=substitute_out)
    def write(
        self,
        filename: str,
        env_callable: Callable[[], str | dict[str, Any]],
    ) -> None:
        # 使用 write_with_template 方法来写入文件，使用 filename 作为模板文件名，env_callable 用于提供环境变量数据
        self.write_with_template(filename, filename, env_callable)

    def write_sharded(
        self,
        filename: str,
        items: Iterable[T],
        *,
        key_fn: Callable[[T], str],
        env_callable: Callable[[T], dict[str, list[str]]],
        num_shards: int,
        base_env: dict[str, Any] | None = None,
        sharded_keys: set[str],
    ) -> None:
        # 创建一个包含所有分片的环境变量字典列表，包括一个 "Everything" 分片和 num_shards 个带索引的分片
        everything: dict[str, Any] = {"shard_id": "Everything"}
        shards: list[dict[str, Any]] = [
            {"shard_id": f"_{i}"} for i in range(num_shards)
        ]
        all_shards = [everything] + shards

        # 如果提供了 base_env，将其更新到所有分片的环境变量中
        if base_env is not None:
            for shard in all_shards:
                shard.update(base_env)

        # 针对每个 sharded_key，确保在所有分片中存在，并且如果在 base_env 中是列表，则进行深拷贝处理
        for key in sharded_keys:
            for shard in all_shards:
                if key in shard:
                    assert isinstance(
                        shard[key], list
                    ), "sharded keys in base_env must be a list"
                    shard[key] = shard[key].copy()
                else:
                    shard[key] = []

        # 定义一个函数 merge_env，用于将 from_ 的环境变量合并到 into 中的对应分片中
        def merge_env(into: dict[str, list[str]], from_: dict[str, list[str]]) -> None:
            for k, v in from_.items():
                assert k in sharded_keys, f"undeclared sharded key {k}"
                into[k] += v

        # 如果是 dry_run 模式，则不处理任何模板写入，直接将 items 设置为空
        if self.dry_run:
            items = ()

        # 遍历每个 item，并根据 key_fn 计算其分片索引 sid，然后调用 env_callable 获取环境变量并合并到对应的分片中
        for item in items:
            key = key_fn(item)
            sid = string_stable_hash(key) % num_shards
            env = env_callable(item)

            merge_env(shards[sid], env)
            merge_env(everything, env)

        # 获取文件名中最后一个点的位置，以确定文件名和扩展名的边界
        dot_pos = filename.rfind(".")
        if dot_pos == -1:
            dot_pos = len(filename)
        base_filename = filename[:dot_pos]
        extension = filename[dot_pos:]

        # 对所有分片，调用 write_with_template 方法写入模板文件，文件名格式为 base_filename + shard_id + extension
        for shard in all_shards:
            shard_id = shard["shard_id"]
            self.write_with_template(
                f"{base_filename}{shard_id}{extension}", filename, lambda: shard
            )

        # 从 self.filenames 中移除编译文件的记录，排除 FooEverything.cpp 这类文件
        self.filenames.discard(
            f"{self.install_dir}/{base_filename}Everything{extension}"
        )

    def write_outputs(self, variable_name: str, filename: str) -> None:
        """Write a file containing the list of all outputs which are
        generated by this script."""
        # 生成一个包含所有生成文件名的 set，将其按变量名和文件名的格式写入指定的 filename
        content = "set({}\n    {})".format(
            variable_name,
            "\n    ".join('"' + name + '"' for name in sorted(self.filenames)),
        )
        self._write_if_changed(filename, content)
    def template_dir_for_comments(self) -> str:
        """
        返回模板目录的相对路径，使其具有确定性。
        模板目录是一个绝对路径，随构建而变化。因此，使用相对于这个文件的路径，
        它将指向代码生成源，但是会保持稳定。
        """
        # 返回模板目录相对于当前文件所在目录的相对路径
        return os.path.relpath(self.template_dir, os.path.dirname(__file__))
# Helper function to generate file manager
def make_file_manager(
    options: Namespace, install_dir: str | None = None
) -> FileManager:
    # 模板目录为源路径下的 "templates" 目录
    template_dir = os.path.join(options.source_path, "templates")
    # 如果未提供安装目录，则使用选项中的安装目录
    install_dir = install_dir if install_dir else options.install_dir
    # 返回一个 FileManager 对象，指定安装目录、模板目录和是否 dry_run 的选项
    return FileManager(
        install_dir=install_dir, template_dir=template_dir, dry_run=options.dry_run
    )


# Helper function to create a pretty representation for dataclasses
def dataclass_repr(
    obj: Any,
    indent: int = 0,
    width: int = 80,
) -> str:
    # 如果 Python 版本大于等于 3.10，则使用内置的 pprint 模块的 pformat 函数
    if sys.version_info >= (3, 10):
        from pprint import pformat

        return pformat(obj, indent, width)

    # 否则调用 _pformat 函数生成对象的字符串表示
    return _pformat(obj, indent=indent, width=width)


def _pformat(
    obj: Any,
    indent: int,
    width: int,
    curr_indent: int = 0,
) -> str:
    # 断言对象是 dataclass 类型，否则抛出异常
    assert is_dataclass(obj), f"obj should be a dataclass, received: {type(obj)}"

    # 获取对象的类名
    class_name = obj.__class__.__name__
    # 更新当前缩进级别，加上类名长度和一个额外的空格
    curr_indent += len(class_name) + 1

    # 获取对象的字段列表，仅包括有 repr 属性的字段
    fields_list = [(f.name, getattr(obj, f.name)) for f in fields(obj) if f.repr]

    fields_str = []
    for name, attr in fields_list:
        # 更新当前缩进级别，加上字段名长度和一个额外的空格
        _curr_indent = curr_indent + len(name) + 1
        if is_dataclass(attr):
            # 如果字段是 dataclass 类型，则递归调用 _pformat 函数生成其字符串表示
            str_repr = _pformat(attr, indent, width, _curr_indent)
        elif isinstance(attr, dict):
            # 如果字段是字典类型，则调用 _format_dict 函数生成其字符串表示
            str_repr = _format_dict(attr, indent, width, _curr_indent)
        elif isinstance(attr, (list, set, tuple)):
            # 如果字段是列表、集合或元组类型，则调用 _format_list 函数生成其字符串表示
            str_repr = _format_list(attr, indent, width, _curr_indent)
        else:
            # 否则使用 repr 函数生成属性的字符串表示
            str_repr = repr(attr)

        fields_str.append(f"{name}={str_repr}")

    indent_str = curr_indent * " "
    body = f",\n{indent_str}".join(fields_str)
    # 返回带有类名和字段表示的字符串
    return f"{class_name}({body})"


def _format_dict(
    attr: dict[Any, Any],
    indent: int,
    width: int,
    curr_indent: int,
) -> str:
    # 更新当前缩进级别，加上字典格式化输出时的额外空格
    curr_indent += indent + 3
    dict_repr = []
    for k, v in attr.items():
        k_repr = repr(k)
        # 如果字典值是 dataclass 类型，则调用 _pformat 函数生成其字符串表示
        v_str = (
            _pformat(v, indent, width, curr_indent + len(k_repr))
            if is_dataclass(v)
            else repr(v)
        )
        dict_repr.append(f"{k_repr}: {v_str}")

    # 调用 _format 函数生成带有花括号包裹的字典字符串表示
    return _format(dict_repr, indent, width, curr_indent, "{", "}")


def _format_list(
    attr: list[Any] | set[Any] | tuple[Any, ...],
    indent: int,
    width: int,
    curr_indent: int,
) -> str:
    # 更新当前缩进级别，加上列表或集合格式化输出时的额外空格
    curr_indent += indent + 1
    list_repr = [
        _pformat(l, indent, width, curr_indent) if is_dataclass(l) else repr(l)
        for l in attr
    ]
    start, end = ("[", "]") if isinstance(attr, list) else ("(", ")")
    # 调用 _format 函数生成带有方括号或圆括号包裹的列表或集合字符串表示
    return _format(list_repr, indent, width, curr_indent, start, end)


def _format(
    fields_str: list[str],
    indent: int,
    width: int,
    curr_indent: int,
    start: str,
    end: str,
):
    # 生成带有指定缩进、起始字符和结束字符的格式化字符串表示
    indent_str = curr_indent * " "
    body = f",\n{indent_str}".join(fields_str)
    return f"{start}{body}\n{indent_str}{end}"
) -> str:
    delimiter, curr_indent_str = "", ""
    # if it exceed the max width then we place one element per line
    if len(repr(fields_str)) >= width:
        delimiter = "\n"
        curr_indent_str = " " * curr_indent

    indent_str = " " * indent
    body = f", {delimiter}{curr_indent_str}".join(fields_str)
    return f"{start}{indent_str}{body}{end}"

class NamespaceHelper:
    """A helper for constructing the namespace open and close strings for a nested set of namespaces.

    e.g. for namespace_str torch::lazy,

    prologue:
    namespace torch {
    namespace lazy {

    epilogue:
    } // namespace lazy
    } // namespace torch
    """

    def __init__(
        self, namespace_str: str, entity_name: str = "", max_level: int = 2
    ) -> None:
        # cpp_namespace can be a colon joined string such as torch::lazy
        cpp_namespaces = namespace_str.split("::")
        assert (
            len(cpp_namespaces) <= max_level
        ), f"Codegen doesn't support more than {max_level} level(s) of custom namespace. Got {namespace_str}."
        self.cpp_namespace_ = namespace_str
        self.prologue_ = "\n".join([f"namespace {n} {{" for n in cpp_namespaces])
        self.epilogue_ = "\n".join(
            [f"}} // namespace {n}" for n in reversed(cpp_namespaces)]
        )
        self.namespaces_ = cpp_namespaces
        self.entity_name_ = entity_name

    @staticmethod
    def from_namespaced_entity(
        namespaced_entity: str, max_level: int = 2
    ) -> NamespaceHelper:
        """
        Generate helper from nested namespaces as long as class/function name. E.g.: "torch::lazy::add"
        """
        names = namespaced_entity.split("::")
        entity_name = names[-1]
        namespace_str = "::".join(names[:-1])
        return NamespaceHelper(
            namespace_str=namespace_str, entity_name=entity_name, max_level=max_level
        )

    @property
    def prologue(self) -> str:
        return self.prologue_

    @property
    def epilogue(self) -> str:
        return self.epilogue_

    @property
    def entity_name(self) -> str:
        return self.entity_name_

    # Only allow certain level of namespaces
    def get_cpp_namespace(self, default: str = "") -> str:
        """
        Return the namespace string from joining all the namespaces by "::" (hence no leading "::").
        Return default if namespace string is empty.
        """
        return self.cpp_namespace_ if self.cpp_namespace_ else default


class OrderedSet(Generic[T]):
    storage: dict[T, Literal[None]]

    def __init__(self, iterable: Iterable[T] | None = None) -> None:
        if iterable is None:
            self.storage = {}
        else:
            self.storage = dict.fromkeys(iterable)

    def __contains__(self, item: T) -> bool:
        return item in self.storage

    def __iter__(self) -> Iterator[T]:
        return iter(self.storage.keys())
    # 更新当前 OrderedSet 实例的存储，将传入的 items 的存储内容合并进来
    def update(self, items: OrderedSet[T]) -> None:
        self.storage.update(items.storage)

    # 向当前 OrderedSet 实例添加一个新的项 item
    def add(self, item: T) -> None:
        self.storage[item] = None

    # 创建当前 OrderedSet 实例的一个副本，并返回副本
    def copy(self) -> OrderedSet[T]:
        ret: OrderedSet[T] = OrderedSet()
        ret.storage = self.storage.copy()
        return ret

    # 静态方法：计算多个 OrderedSet 实例的并集，并返回结果
    @staticmethod
    def union(*args: OrderedSet[T]) -> OrderedSet[T]:
        ret = args[0].copy()
        for s in args[1:]:
            ret.update(s)
        return ret

    # 重载操作符 | ，计算两个 OrderedSet 实例的并集，并返回结果
    def __or__(self, other: OrderedSet[T]) -> OrderedSet[T]:
        return OrderedSet.union(self, other)

    # 重载操作符 |= ，更新当前 OrderedSet 实例，将另一个 OrderedSet 实例 other 的内容合并进来
    def __ior__(self, other: OrderedSet[T]) -> 'Self':
        self.update(other)
        return self

    # 重载比较操作符 == ，判断当前 OrderedSet 实例与另一个对象 other 是否相等
    def __eq__(self, other: object) -> bool:
        if isinstance(other, OrderedSet):
            return self.storage == other.storage
        else:
            # 如果 other 不是 OrderedSet 类型，则比较当前实例的键集合与 other 是否相等
            return set(self.storage.keys()) == other
```