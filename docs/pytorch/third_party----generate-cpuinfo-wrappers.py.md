# `.\pytorch\third_party\generate-cpuinfo-wrappers.py`

```py
#!/usr/bin/env python3
# 指定使用 Python3 解释器

from __future__ import print_function
# 导入 Python 2.x 的 print 函数，以便在 Python 2.x 中使用 Python 3.x 的 print 语法
import os
# 导入 os 模块

CPUINFO_SOURCES = {
    None: [
        "init.c",
        "api.c",
        "cache.c",
        "log.c",
    ],
    "defined(__linux__)": [
        "linux/multiline.c",
        "linux/cpulist.c",
        "linux/mockfile.c",
        "linux/smallfile.c",
        "linux/processors.c",
    ],
    "defined(__MACH__) && defined(__APPLE__)": [
        "mach/topology.c",
    ],
    "defined(__i386__) || defined(__i686__) || defined(__x86_64__) || defined(_WIN32)": [
        "x86/cache/init.c",
        "x86/cache/deterministic.c",
        "x86/cache/descriptor.c",
        "x86/info.c",
        "x86/mockcpuid.c",
        "x86/isa.c",
        "x86/topology.c",
        "x86/name.c",
        "x86/init.c",
        "x86/uarch.c",
        "x86/vendor.c",
    ],
    "(defined(__i386__) || defined(__i686__) || defined(__x86_64__)) && defined(__linux__)": [
        "x86/linux/init.c",
        "x86/linux/cpuinfo.c",
    ],
    "(defined(__i386__) || defined(__i686__) || defined(__x86_64__)) && defined(__MACH__) && defined(__APPLE__)": [
        "x86/mach/init.c",
    ],
    "defined(_WIN32)": [
        "x86/windows/init.c",
    ],
    "(defined(__arm__) || defined(__aarch64__)) && defined(__linux__)": [
        "arm/linux/cpuinfo.c",
        "arm/linux/hwcap.c",
        "arm/linux/init.c",
        "arm/linux/clusters.c",
        "arm/linux/midr.c",
        "arm/linux/chipset.c",
        "arm/tlb.c",
        "arm/uarch.c",
        "arm/cache.c",
    ],
    "defined(__arm__) && defined(__linux__)": [
        "arm/linux/aarch32-isa.c",
    ],
    "defined(__aarch64__) && defined(__linux__)": [
        "arm/linux/aarch64-isa.c",
    ],
    "(defined(__arm__) || defined(__aarch64__)) && defined(__ANDROID__)": [
        "arm/android/properties.c",
    ],
    "(defined(__arm__) || defined(__aarch64__)) && defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE": [
        "arm/mach/init.c",
    ],
}
# 定义一个字典 CPUINFO_SOURCES，包含不同平台的源文件列表

if __name__ == "__main__":
# 如果当前脚本作为主程序运行
    # 遍历 CPUINFO_SOURCES 字典，其中包含条件和文件名列表
    for condition, filenames in CPUINFO_SOURCES.items():
        # 遍历每个文件名
        for filename in filenames:
            # 构建文件的完整路径
            filepath = os.path.join("cpuinfo/wrappers", filename)
            # 如果文件路径的目录不存在，则创建目录
            if not os.path.exists(os.path.dirname(filepath)):
                # 输出将要创建的文件路径（调试用）
                print(filepath)
                # 创建目录
                os.makedirs(os.path.dirname(filepath))
            # 打开文件以供写入
            with open(filepath, "w") as wrapper:
                # 在文件中写入自动生成的注释
                print("/* Auto-generated by generate-wrappers.py script. Do not modify */", file=wrapper)
                # 在文件中打印一个空行
                print(file=wrapper)
                # 在文件中条件编译的开始标记（针对苹果系统）
                print("#ifdef __APPLE__", file=wrapper)
                # 在文件中包含特定于苹果系统的头文件
                print("\t#include <TargetConditionals.h>", file=wrapper)
                # 在文件中条件编译的结束标记（针对苹果系统）
                print("#endif /* __APPLE__ */", file=wrapper)
                # 在文件中打印一个空行
                print(file=wrapper)

                # 根据条件决定是否包含特定的源文件
                if not condition:
                    # 如果条件未满足，则直接包含文件
                    print("#include <%s>" % filename, file=wrapper)
                else:
                    # 否则，根据条件进行条件编译
                    print("#if %s" % condition, file=wrapper)
                    # 包含特定的源文件
                    print("#include <%s>" % filename, file=wrapper)
                    # 条件编译的结束标记
                    print("#endif /* %s */" % condition, file=wrapper)
```