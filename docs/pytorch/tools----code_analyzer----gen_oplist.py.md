# `.\pytorch\tools\code_analyzer\gen_oplist.py`

```py
#!/usr/bin/env python3



from __future__ import annotations
# 允许使用未来版本的类型注解

import argparse
import json
import os
import sys
from functools import reduce
from typing import Any

import yaml
from tools.lite_interpreter.gen_selected_mobile_ops_header import (
    write_selected_mobile_ops,
)

from torchgen.selective_build.selector import (
    combine_selective_builders,
    SelectiveBuilder,
)
# 导入必要的模块和类

def extract_all_operators(selective_builder: SelectiveBuilder) -> set[str]:
    # 提取所有操作符的名称并返回成一个集合
    return set(selective_builder.operators.keys())


def extract_training_operators(selective_builder: SelectiveBuilder) -> set[str]:
    # 提取用于训练的操作符的名称并返回成一个集合
    ops = []
    for op_name, op in selective_builder.operators.items():
        if op.is_used_for_training:
            ops.append(op_name)
    return set(ops)


def throw_if_any_op_includes_overloads(selective_builder: SelectiveBuilder) -> None:
    # 如果有任何操作符包含所有重载，则抛出异常
    ops = []
    for op_name, op in selective_builder.operators.items():
        if op.include_all_overloads:
            ops.append(op_name)
    if ops:
        raise Exception(  # noqa: TRY002
            (
                "Operators that include all overloads are "
                + "not allowed since --allow-include-all-overloads "
                + "was specified: {}"
            ).format(", ".join(ops))
        )


def gen_supported_mobile_models(model_dicts: list[Any], output_dir: str) -> None:
    # 生成支持的移动模型的注册文件 SupportedMobileModelsRegistration.cpp

    supported_mobile_models_source = """/*
 * Generated by gen_oplist.py
 */
#include "fb/supported_mobile_models/SupportedMobileModels.h"


struct SupportedMobileModelCheckerRegistry {{
  SupportedMobileModelCheckerRegistry() {{
    auto& ref = facebook::pytorch::supported_model::SupportedMobileModelChecker::singleton();
    ref.set_supported_md5_hashes(std::unordered_set<std::string>{{
      {supported_hashes_template}
    }});
  }}
}};

// This is a global object, initializing which causes the registration to happen.
SupportedMobileModelCheckerRegistry register_model_versions;


"""

    # 生成 SupportedMobileModelsRegistration.cpp 文件内容
    md5_hashes = set()
    for model_dict in model_dicts:
        if "debug_info" in model_dict:
            debug_info = json.loads(model_dict["debug_info"][0])
            if debug_info["is_new_style_rule"]:
                for asset_info in debug_info["asset_info"].values():
                    md5_hashes.update(asset_info["md5_hash"])

    supported_hashes = ""
    for md5 in md5_hashes:
        supported_hashes += f'"{md5}",\n'
    with open(
        os.path.join(output_dir, "SupportedMobileModelsRegistration.cpp"), "wb"
    ) as out_file:
        # 将生成的源代码写入输出文件
        source = supported_mobile_models_source.format(
            supported_hashes_template=supported_hashes
        )
        out_file.write(source.encode("utf-8"))


def main(argv: list[Any]) -> None:
    """This binary generates 3 files:

    1. selected_mobile_ops.h: Primary operators used by templated selective build and Kernel Function
       dtypes captured by tracing
    """
    # 主函数，生成3个文件之一 selected_mobile_ops.h，用于模板化选择性构建和内核函数的主要操作符
    """
        2. selected_operators.yaml: Selected root and non-root operators (either via tracing or static analysis)
        """
        # 创建一个参数解析器对象，用于处理命令行参数
        parser = argparse.ArgumentParser(description="Generate operator lists")
        
        # 添加命令行参数：输出目录，用于存储生成的yaml文件（selected_mobile_ops.h、selected_kernel_dtypes.h、selected_operators.yaml）
        parser.add_argument(
            "--output-dir",
            "--output_dir",
            help=(
                "The directory to store the output yaml files (selected_mobile_ops.h, "
                + "selected_kernel_dtypes.h, selected_operators.yaml)"
            ),
            required=True,
        )
        
        # 添加命令行参数：模型文件列表路径，指定包含用到的操作符集合的各个模型yaml文件的位置
        parser.add_argument(
            "--model-file-list-path",
            "--model_file_list_path",
            help=(
                "Path to a file that contains the locations of individual "
                + "model YAML files that contain the set of used operators. This "
                + "file path must have a leading @-symbol, which will be stripped "
                + "out before processing."
            ),
            required=True,
        )
        
        # 添加命令行参数：允许包含所有重载的标志，如果设置，则允许使用包含所有重载的操作符
        parser.add_argument(
            "--allow-include-all-overloads",
            "--allow_include_all_overloads",
            help=(
                "Flag to allow operators that include all overloads. "
                + "If not set, operators registered without using the traced style will"
                + "break the build."
            ),
            action="store_true",
            default=False,
            required=False,
        )
        
        # 解析命令行参数
        options = parser.parse_args(argv)
    
        # 如果模型文件列表路径是一个文件，则处理单个模型文件
        if os.path.isfile(options.model_file_list_path):
            print("Processing model file: ", options.model_file_list_path)
            model_dicts = []
            # 加载模型文件的内容到字典中
            model_dict = yaml.safe_load(open(options.model_file_list_path))
            model_dicts.append(model_dict)
        else:
            # 如果模型文件列表路径是一个目录，则处理目录下的所有模型文件
            print("Processing model directory: ", options.model_file_list_path)
            # 断言模型文件列表路径以@符号开头，去除@符号后进行处理
            assert options.model_file_list_path[0] == "@"
            model_file_list_path = options.model_file_list_path[1:]
    
            model_dicts = []
            # 逐个读取模型文件列表中的文件，并加载其内容到字典中
            with open(model_file_list_path) as model_list_file:
                model_file_names = model_list_file.read().split()
                for model_file_name in model_file_names:
                    with open(model_file_name, "rb") as model_file:
                        model_dict = yaml.safe_load(model_file)
                        model_dicts.append(model_dict)
    
        # 根据加载的模型字典列表创建SelectiveBuilder对象列表
        selective_builders = [SelectiveBuilder.from_yaml_dict(m) for m in model_dicts]
    
        # 根据模型字典列表生成支持的移动模型API，存储到指定的输出目录
        gen_supported_mobile_models(model_dicts, options.output_dir)
    
        # 可能会出现没有可用SelectiveBuilder的情况，此时长度为0，应该引发错误
        # 这里暂时使用空字典创建SelectiveBuilder对象
        selective_builder = SelectiveBuilder.from_yaml_dict({})
        if len(selective_builders) > 0:
            # 如果存在SelectiveBuilder对象，则通过reduce函数组合成一个SelectiveBuilder对象
            selective_builder = reduce(
                combine_selective_builders,
                selective_builders,
            )
    # 如果选项中不允许包含所有重载版本，则执行以下操作
    if not options.allow_include_all_overloads:
        # 调用函数检查是否有任何操作包含了重载版本
        throw_if_any_op_includes_overloads(selective_builder)
    
    # 使用写入模式打开文件 "selected_operators.yaml"，位于选项中指定的输出目录下
    # 将选择生成器的字典表示转换为 YAML 格式，并写入文件
    with open(
        os.path.join(options.output_dir, "selected_operators.yaml"), "wb"
    ) as out_file:
        out_file.write(
            yaml.safe_dump(
                selective_builder.to_dict(), default_flow_style=False
            ).encode("utf-8"),
        )
    
    # 调用函数，将选择生成器写入移动操作到指定的文件 "selected_mobile_ops.h" 中
    write_selected_mobile_ops(
        os.path.join(options.output_dir, "selected_mobile_ops.h"),
        selective_builder,
    )
# 如果当前脚本被直接执行（而不是被导入到其他模块中），则执行以下代码块
if __name__ == "__main__":
    # 调用 main 函数，并传入命令行参数列表（去掉第一个参数，即脚本本身的名称）
    main(sys.argv[1:])
```