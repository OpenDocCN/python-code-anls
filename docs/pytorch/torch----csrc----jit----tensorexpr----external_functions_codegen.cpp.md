# `.\pytorch\torch\csrc\jit\tensorexpr\external_functions_codegen.cpp`

```py
// @generated by torchgen/gen.py from
// external_functions_codegen_template.cpp

// 包含头文件：定义在 external_functions_codegen_template.cpp 中生成的代码
#include <torch/csrc/jit/tensorexpr/external_functions.h>

// 包含 ATen 库的函数定义
#include <ATen/Functions.h>
#include <ATen/NativeFunctions.h>

// 包含外部函数注册相关的头文件
#include <torch/csrc/jit/tensorexpr/external_functions_registry.h>

// 命名空间 torch::jit::tensorexpr 中定义的内容
namespace torch::jit::tensorexpr {

// 在 C10_MOBILE 宏定义下，声明外部 C 函数
#ifdef C10_MOBILE
extern "C" {
#endif

// 定义静态函数 nnc_aten_abs，实现对 ATen 函数 at::abs 的封装
static void nnc_aten_abs(
    int64_t bufs_num,        // 缓冲区数量
    void** buf_data,         // 缓冲区数据数组
    int64_t* buf_ranks,      // 缓冲区秩数组
    int64_t* buf_dims,       // 缓冲区维度数组
    int64_t* buf_strides,    // 缓冲区步长数组
    int8_t* buf_dtypes,      // 缓冲区数据类型数组
    int64_t args_num,        // 参数数量
    int64_t* extra_args      // 额外参数数组
) {
  // 构造张量对象数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);

  // 取得结果张量和输入张量
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];

  // 调用 at::abs 函数处理 self 张量，并将结果存入 r 张量
  try {
    at::abs_out(r, self);
  } catch (...) {
    // 异常处理，这里可以根据实际情况填写异常处理代码
  }
}

// 类似地，定义静态函数 nnc_aten_absolute，封装 ATen 函数 at::absolute
static void nnc_aten_absolute(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::absolute_out(r, self);
  } catch (...) {
  }
}

// 定义静态函数 nnc_aten_angle，封装 ATen 函数 at::angle
static void nnc_aten_angle(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::angle_out(r, self);
  } catch (...) {
  }
}

// 类似地，定义静态函数 nnc_aten_sgn，封装 ATen 函数 at::sgn
static void nnc_aten_sgn(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::sgn_out(r, self);
  } catch (...) {
  }
}

// 类似地，定义静态函数 nnc_aten_acos，封装 ATen 函数 at::acos
static void nnc_aten_acos(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::acos_out(r, self);
  } catch (...) {
  }
}

// 类似地，定义静态函数 nnc_aten_arccos，封装 ATen 函数 at::arccos
static void nnc_aten_arccos(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::arccos_out(r, self);
  } catch (...) {
  }
}

// 以下还有其他函数的定义，可以根据需要继续添加类似的注释
    # 定义一个函数，接受多个输入参数，其中包括指向整数数组的指针
    int64_t* extra_args) {
  # 调用 constructTensors 函数构造张量对象，返回一个张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  # 获取构造的张量向量中的第一个张量，并赋值给 r
  at::Tensor& r = tensors[0];
  # 获取构造的张量向量中的第二个张量，并赋值给 self，这是一个常量引用
  const at::Tensor& self = tensors[1];
  # 尝试计算 self 张量的反余弦值，将结果存储在 r 张量中
  try {
    at::arccos_out(r, self);
  # 捕获所有异常，如果出现异常则不做任何处理
  } catch (...) {
  }
static void nnc_aten_acosh(
    int64_t bufs_num,          // 输入参数：bufs_num，表示缓冲区数量
    void** buf_data,           // 输入参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,        // 输入参数：buf_ranks，指向缓冲区秩的指针数组
    int64_t* buf_dims,         // 输入参数：buf_dims，指向缓冲区维度的指针数组
    int64_t* buf_strides,      // 输入参数：buf_strides，指向缓冲区步长的指针数组
    int8_t* buf_dtypes,        // 输入参数：buf_dtypes，指向缓冲区数据类型的指针数组
    int64_t args_num,          // 输入参数：args_num，表示额外参数的数量
    int64_t* extra_args) {     // 输入参数：extra_args，指向额外参数的指针数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 构建张量列表，使用输入的缓冲区相关信息
  at::Tensor& r = tensors[0];  // 获取第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 获取第二个张量作为输入张量 self
  try {
    at::acosh_out(r, self);   // 调用 PyTorch 中的 acosh_out 函数，计算反双曲余弦函数，并将结果存储在 r 中
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_arccosh(
    int64_t bufs_num,          // 输入参数：bufs_num，表示缓冲区数量
    void** buf_data,           // 输入参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,        // 输入参数：buf_ranks，指向缓冲区秩的指针数组
    int64_t* buf_dims,         // 输入参数：buf_dims，指向缓冲区维度的指针数组
    int64_t* buf_strides,      // 输入参数：buf_strides，指向缓冲区步长的指针数组
    int8_t* buf_dtypes,        // 输入参数：buf_dtypes，指向缓冲区数据类型的指针数组
    int64_t args_num,          // 输入参数：args_num，表示额外参数的数量
    int64_t* extra_args) {     // 输入参数：extra_args，指向额外参数的指针数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 构建张量列表，使用输入的缓冲区相关信息
  at::Tensor& r = tensors[0];  // 获取第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 获取第二个张量作为输入张量 self
  try {
    at::arccosh_out(r, self);  // 调用 PyTorch 中的 arccosh_out 函数，计算反双曲余弦函数，并将结果存储在 r 中
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_asinh(
    int64_t bufs_num,          // 输入参数：bufs_num，表示缓冲区数量
    void** buf_data,           // 输入参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,        // 输入参数：buf_ranks，指向缓冲区秩的指针数组
    int64_t* buf_dims,         // 输入参数：buf_dims，指向缓冲区维度的指针数组
    int64_t* buf_strides,      // 输入参数：buf_strides，指向缓冲区步长的指针数组
    int8_t* buf_dtypes,        // 输入参数：buf_dtypes，指向缓冲区数据类型的指针数组
    int64_t args_num,          // 输入参数：args_num，表示额外参数的数量
    int64_t* extra_args) {     // 输入参数：extra_args，指向额外参数的指针数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 构建张量列表，使用输入的缓冲区相关信息
  at::Tensor& r = tensors[0];  // 获取第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 获取第二个张量作为输入张量 self
  try {
    at::asinh_out(r, self);   // 调用 PyTorch 中的 asinh_out 函数，计算反双曲正弦函数，并将结果存储在 r 中
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_arcsinh(
    int64_t bufs_num,          // 输入参数：bufs_num，表示缓冲区数量
    void** buf_data,           // 输入参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,        // 输入参数：buf_ranks，指向缓冲区秩的指针数组
    int64_t* buf_dims,         // 输入参数：buf_dims，指向缓冲区维度的指针数组
    int64_t* buf_strides,      // 输入参数：buf_strides，指向缓冲区步长的指针数组
    int8_t* buf_dtypes,        // 输入参数：buf_dtypes，指向缓冲区数据类型的指针数组
    int64_t args_num,          // 输入参数：args_num，表示额外参数的数量
    int64_t* extra_args) {     // 输入参数：extra_args，指向额外参数的指针数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 构建张量列表，使用输入的缓冲区相关信息
  at::Tensor& r = tensors[0];  // 获取第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 获取第二个张量作为输入张量 self
  try {
    at::arcsinh_out(r, self);  // 调用 PyTorch 中的 arcsinh_out 函数，计算反双曲正弦函数，并将结果存储在 r 中
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_atanh(
    int64_t bufs_num,          // 输入参数：bufs_num，表示缓冲区数量
    void** buf_data,           // 输入参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,        // 输入参数：buf_ranks，指向缓冲区秩的指针数组
    int64_t* buf_dims,         // 输入参数：buf_dims，指向缓冲区维度的指针数组
    int64_t* buf_strides,      // 输入参数：buf_strides，指向缓冲区步长的指针数组
    int8_t* buf_dtypes,        // 输入参数：buf_dtypes，指向缓冲区数据类型的指针数组
    int64_t args_num,          // 输入参数：args_num，表示额外参数的数量
    int64_t* extra_args) {     // 输入参数：extra_args，指向额外参数的指针数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 构建张量列表，使用输入的缓冲区相关信息
  at::Tensor& r = tensors[0];  // 获取第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 获取第二个张量作为
    int8_t* buf_dtypes,                     // 指向 int8_t 类型数组的指针，用于存储数据类型信息
    int64_t args_num,                       // 参数数量，表示额外参数的数量
    int64_t* extra_args) {                  // 指向 int64_t 类型数组的指针，存储额外的参数信息
  std::vector<
static void nnc_aten_arcsin(
    int64_t bufs_num,         // 参数：缓冲区数量
    void** buf_data,          // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,       // 参数：缓冲区的秩（维数）数组
    int64_t* buf_dims,        // 参数：缓冲区的维度大小数组
    int64_t* buf_strides,     // 参数：缓冲区的步幅数组
    int8_t* buf_dtypes,       // 参数：缓冲区的数据类型数组
    int64_t args_num,         // 参数：额外参数的数量
    int64_t* extra_args) {    // 参数：额外参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  try {
    at::arcsin_out(r, self);    // 调用 PyTorch 的 arcsin_out 函数，计算 self 的反正弦值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}

static void nnc_aten_atan(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  try {
    at::atan_out(r, self);    // 调用 PyTorch 的 atan_out 函数，计算 self 的反正切值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}

static void nnc_aten_arctan(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  try {
    at::arctan_out(r, self);   // 调用 PyTorch 的 arctan_out 函数，计算 self 的反正切值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}

static void nnc_aten_bitwise_not(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  try {
    at::bitwise_not_out(r, self);   // 调用 PyTorch 的 bitwise_not_out 函数，计算 self 的按位取反值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}

static void nnc_aten_copysign(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量
  try {
    at::copysign_out(r, self, other);  // 调用 PyTorch 的 copysign_out 函数，计算 self 和 other 的符号拷贝值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}

static void nnc_aten_logical_not(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出结果
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量
  try {
    at::logical_not_out(r, self);   // 调用 PyTorch 的 logical_not_out 函数，计算 self 的逻辑非值，将结果存入 r
  } catch (...) {
    // 捕获异常，如果出现异常则不进行任何操作
  }
}
    // 定义一个函数，接受多个指针和整数参数作为输入
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构建张量的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 将第一个张量赋值给引用变量 r
  at::Tensor& r = tensors[0];
  // 将第二个张量作为常量引用 self
  const at::Tensor& self = tensors[1];
  // 将第三个张量作为常量引用 other
  const at::Tensor& other = tensors[2];
  // 尝试使用逻辑异或操作符计算 self 和 other 张量，并将结果存储到 r 中
  try {
    at::logical_xor_out(r, self, other);
  // 捕获任何异常（如果有的话）
  } catch (...) {
  }
static void nnc_aten_logical_and(
    // 定义函数 nnc_aten_logical_and，用于执行张量的逻辑与操作
    int64_t bufs_num,
    // 参数 bufs_num: 输入缓冲区的数量
    void** buf_data,
    // 参数 buf_data: 指向缓冲区数据的指针数组
    int64_t* buf_ranks,
    // 参数 buf_ranks: 每个缓冲区的秩（维度数）
    int64_t* buf_dims,
    // 参数 buf_dims: 每个缓冲区的维度数组
    int64_t* buf_strides,
    // 参数 buf_strides: 每个缓冲区的步长数组
    int8_t* buf_dtypes,
    // 参数 buf_dtypes: 每个缓冲区的数据类型数组
    int64_t args_num,
    // 参数 args_num: 额外参数的数量
    int64_t* extra_args) {
    // 参数 extra_args: 额外参数数组

  std::vector<at::Tensor> tensors = constructTensors(
      // 使用构造函数 constructTensors 创建张量数组
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
      // 将输入缓冲区的数据转换为张量数组

  at::Tensor& r = tensors[0];
  // 获取结果张量 r
  const at::Tensor& self = tensors[1];
  // 获取输入张量 self
  const at::Tensor& other = tensors[2];
  // 获取输入张量 other

  try {
    // 尝试执行逻辑与操作，并将结果存储在 r 中
    at::logical_and_out(r, self, other);
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_logical_or(
    // 定义函数 nnc_aten_logical_or，用于执行张量的逻辑或操作
    int64_t bufs_num,
    // 参数 bufs_num: 输入缓冲区的数量
    void** buf_data,
    // 参数 buf_data: 指向缓冲区数据的指针数组
    int64_t* buf_ranks,
    // 参数 buf_ranks: 每个缓冲区的秩（维度数）
    int64_t* buf_dims,
    // 参数 buf_dims: 每个缓冲区的维度数组
    int64_t* buf_strides,
    // 参数 buf_strides: 每个缓冲区的步长数组
    int8_t* buf_dtypes,
    // 参数 buf_dtypes: 每个缓冲区的数据类型数组
    int64_t args_num,
    // 参数 args_num: 额外参数的数量
    int64_t* extra_args) {
    // 参数 extra_args: 额外参数数组

  std::vector<at::Tensor> tensors = constructTensors(
      // 使用构造函数 constructTensors 创建张量数组
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
      // 将输入缓冲区的数据转换为张量数组

  at::Tensor& r = tensors[0];
  // 获取结果张量 r
  const at::Tensor& self = tensors[1];
  // 获取输入张量 self
  const at::Tensor& other = tensors[2];
  // 获取输入张量 other

  try {
    // 尝试执行逻辑或操作，并将结果存储在 r 中
    at::logical_or_out(r, self, other);
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_bmm(
    // 定义函数 nnc_aten_bmm，用于执行批量矩阵乘操作
    int64_t bufs_num,
    // 参数 bufs_num: 输入缓冲区的数量
    void** buf_data,
    // 参数 buf_data: 指向缓冲区数据的指针数组
    int64_t* buf_ranks,
    // 参数 buf_ranks: 每个缓冲区的秩（维度数）
    int64_t* buf_dims,
    // 参数 buf_dims: 每个缓冲区的维度数组
    int64_t* buf_strides,
    // 参数 buf_strides: 每个缓冲区的步长数组
    int8_t* buf_dtypes,
    // 参数 buf_dtypes: 每个缓冲区的数据类型数组
    int64_t args_num,
    // 参数 args_num: 额外参数的数量
    int64_t* extra_args) {
    // 参数 extra_args: 额外参数数组

  std::vector<at::Tensor> tensors = constructTensors(
      // 使用构造函数 constructTensors 创建张量数组
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
      // 将输入缓冲区的数据转换为张量数组

  at::Tensor& r = tensors[0];
  // 获取结果张量 r
  const at::Tensor& self = tensors[1];
  // 获取输入张量 self
  const at::Tensor& mat2 = tensors[2];
  // 获取输入张量 mat2

  try {
    // 尝试执行批量矩阵乘操作，并将结果存储在 r 中
    at::bmm_out(r, self, mat2);
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_ceil(
    // 定义函数 nnc_aten_ceil，用于执行向上取整操作
    int64_t bufs_num,
    // 参数 bufs_num: 输入缓冲区的数量
    void** buf_data,
    // 参数 buf_data: 指向缓冲区数据的指针数组
    int64_t* buf_ranks,
    // 参数 buf_ranks: 每个缓冲区的秩（维度数）
    int64_t* buf_dims,
    // 参数 buf_dims: 每个缓冲区的维度数组
    int64_t* buf_strides,
    // 参数 buf_strides: 每个缓冲区的步长数组
    int8_t* buf_dtypes,
    // 参数 buf_dtypes: 每个缓冲区的数据类型数组
    int64_t args_num,
    // 参数 args_num: 额外参数的数量
    int64_t* extra_args) {
    // 参数 extra_args: 额外参数数组

  std::vector<at::Tensor> tensors = constructTensors(
      // 使用构造函数 constructTensors 创建张量数组
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
      // 将输入缓冲区的数据转换为张量数组

  at::Tensor& r = tensors[0];
  // 获取结果张量 r
  const at::Tensor& self = tensors[1];
  // 获取输入张量 self

  try {
    // 尝试执行向上取整操作，并将结果存储在 r 中
    at::ceil_out(r, self);
  } catch (...) {
    // 捕获任何异常
  }
}

static void nnc_aten_clamp_max(
    // 定义函数 nnc_aten_clamp_max，用于执行张量的最大值截断操作
    int64_t bufs_num,
    // 参数 bufs_num: 输入缓冲区的数量
    void** buf_data,
    // 参数 buf_data: 指向缓冲区数据的指针数组
    int64_t* buf_ranks,
    // 参数 buf_ranks: 每个缓冲区的秩（维度数）
    int64_t* buf_dims,
    // 参数 buf_dims: 每个缓冲区的维度数组
    int64_t* buf_strides,
    // 参数 buf_strides: 每个缓冲区的步长数组
    int8_t* buf_dtypes,
    // 参数 buf_dtypes: 每个缓冲区的数据类型数组
    int64_t args_num,
    // 参数 args_num: 额外参数的数量
    int64_t* extra_args) {
    // 参数 extra_args: 额外参数数组

  std::vector<at::Tensor> tensors = constructTensors(
      // 使用构造函数 constructTensors 创建张量数组
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
      //
    // 构造张量列表，使用给定的缓冲区数据和参数构建张量
    std::vector<at::Tensor> tensors = constructTensors(
        bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
    
    // 获取返回张量列表中的第一个张量作为输出张量 r
    at::Tensor& r = tensors[0];
    
    // 获取返回张量列表中的第二个张量作为输入张量 self
    const at::Tensor& self = tensors[1];
    
    // 获取返回张量列表中的第三个张量作为最小张量 min
    const at::Tensor& min = tensors[2];
    
    // 尝试将输入张量 self 的值限制在最小张量 min 的值以上，并将结果写入输出张量 r
    try {
        at::clamp_min_out(r, self, min);
    } catch (...) {
        // 捕获任何可能抛出的异常，不做任何处理
    }
static void nnc_aten_complex(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得复数的实部张量和虚部张量
  at::Tensor& r = tensors[0];  // 获取复数结果的张量引用
  const at::Tensor& real = tensors[1];  // 获取实部的常量张量引用
  const at::Tensor& imag = tensors[2];  // 获取虚部的常量张量引用
  try {
    // 计算复数值并存入张量 r 中
    at::complex_out(r, real, imag);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}

static void nnc_aten_polar(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得极坐标的模张量和角度张量
  at::Tensor& r = tensors[0];  // 获取极坐标结果的张量引用
  const at::Tensor& abs = tensors[1];  // 获取模的常量张量引用
  const at::Tensor& angle = tensors[2];  // 获取角度的常量张量引用
  try {
    // 计算极坐标值并存入张量 r 中
    at::polar_out(r, abs, angle);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}

static void nnc_aten_cos(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得张量 self，这是要进行余弦计算的张量
  at::Tensor& r = tensors[0];  // 获取余弦结果的张量引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    // 计算张量 self 的余弦值并存入张量 r 中
    at::cos_out(r, self);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}

static void nnc_aten_cosh(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得张量 self，这是要进行双曲余弦计算的张量
  at::Tensor& r = tensors[0];  // 获取双曲余弦结果的张量引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    // 计算张量 self 的双曲余弦值并存入张量 r 中
    at::cosh_out(r, self);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}

static void nnc_aten_div(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得张量 self 和 other，这是要进行除法计算的两个张量
  at::Tensor& r = tensors[0];  // 获取除法结果的张量引用
  const at::Tensor& self = tensors[1];  // 获取被除数张量的常量引用
  const at::Tensor& other = tensors[2];  // 获取除数张量的常量引用
  try {
    // 计算张量 self 除以张量 other 的结果并存入张量 r 中
    at::div_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}

static void nnc_aten_divide(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用构造函数创建张量向量，将输入的数据转换为张量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得张量 self 和 other，这是要进行除法计算的两个张量
  at::Tensor& r = tensors[0];  // 获取除法结果的张量引用
  const at::Tensor& self = tensors[1];  // 获取被除数张量的常量引用
  const at::Tensor& other = tensors[2];  // 获取除数张量的常量引用
  try {
    // 计算张量 self 除以张量 other 的结果并存入张量 r 中
    at::div_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，目前没有定义额外的处理逻辑
  }
}
    // 调用 ATen（PyTorch 的 C++ 后端）中的 divide_out 函数，用于在张量 r 上执行除法操作，
    // 将结果存储在当前对象（this 指针指向的对象）中，被除数是另一个张量 other。
    // 这里使用了 try-catch 块来捕获可能发生的任何异常，但是没有提供异常处理的具体逻辑。
    try {
        at::divide_out(r, self, other);
    } catch (...) {
        // 捕获到任何异常时，不执行任何操作，直接跳过。
    }
static void nnc_aten_true_divide(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 第一个输入张量常量引用
  const at::Tensor& other = tensors[2];  // 第二个输入张量常量引用
  try {
    at::true_divide_out(r, self, other);  // 执行张量的真除操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}

static void nnc_aten_dot(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 第一个输入张量常量引用
  const at::Tensor& tensor = tensors[2];  // 第二个输入张量常量引用
  try {
    at::dot_out(r, self, tensor);    // 执行张量的点积操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}

static void nnc_aten_vdot(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 第一个输入张量常量引用
  const at::Tensor& other = tensors[2];  // 第二个输入张量常量引用
  try {
    at::vdot_out(r, self, other);    // 执行张量的向量点积操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}

static void nnc_aten_erf(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 输入张量常量引用
  try {
    at::erf_out(r, self);            // 执行张量的误差函数操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}

static void nnc_aten_erfc(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 输入张量常量引用
  try {
    at::erfc_out(r, self);           // 执行张量的互补误差函数操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}

static void nnc_aten_exp(
    int64_t bufs_num,                // 传入的张量缓冲区数量
    void** buf_data,                 // 指向张量数据的指针数组
    int64_t* buf_ranks,              // 每个张量的秩（维度数）
    int64_t* buf_dims,               // 每个张量的维度数组
    int64_t* buf_strides,            // 每个张量的步幅数组
    int8_t* buf_dtypes,              // 每个张量的数据类型数组
    int64_t args_num,                // 额外参数的数量
    int64_t* extra_args) {           // 额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];        // 结果张量引用
  const at::Tensor& self = tensors[1];  // 输入张量常量引用
  try {
    at::exp_out(r, self);            // 执行张量的指数函数操作
  } catch (...) {
    // 捕获任何可能发生的异常
  }
}
// 计算指数函数 exp2 的张量操作
static void nnc_aten_exp2(
    int64_t bufs_num,        // 输入张量数组的数量
    void** buf_data,         // 输入张量数据的指针数组
    int64_t* buf_ranks,      // 输入张量的秩数组
    int64_t* buf_dims,       // 输入张量的维度数组
    int64_t* buf_strides,    // 输入张量的步幅数组
    int8_t* buf_dtypes,      // 输入张量的数据类型数组
    int64_t args_num,        // 额外参数的数量
    int64_t* extra_args) {   // 额外参数的数组
  // 使用输入数据构建张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得输出张量 r 和输入张量 self 的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    // 调用 ATen 库的 exp2_out 函数计算指数函数 exp2
    at::exp2_out(r, self);
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}

// 计算 expm1 函数的张量操作
static void nnc_aten_expm1(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::expm1_out(r, self);  // 调用 ATen 库的 expm1_out 函数计算 expm1 函数
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}

// 计算 floor 函数的张量操作
static void nnc_aten_floor(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::floor_out(r, self);  // 调用 ATen 库的 floor_out 函数计算 floor 函数
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}

// 计算 floor_divide 函数的张量操作
static void nnc_aten_floor_divide(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  try {
    at::floor_divide_out(r, self, other);  // 调用 ATen 库的 floor_divide_out 函数计算 floor_divide 函数
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}

// 计算 frac 函数的张量操作
static void nnc_aten_frac(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::frac_out(r, self);  // 调用 ATen 库的 frac_out 函数计算 frac 函数
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}

// 计算 gcd 函数的张量操作
static void nnc_aten_gcd(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  try {
    at::gcd_out(r, self, other);  // 调用 ATen 库的 gcd_out 函数计算 gcd 函数
  } catch (...) {
    // 捕获任何异常并不进行处理
  }
}


这些注释详细说明了每个函数的作用，包括其输入参数的含义以及调用的 ATen 库函数来实现具体的张量操作。
    // 声明一个 C++ 函数，接受多个指针和整数作为参数
    void** buf_data,             // 指向数据缓冲区的指针数组
        int64_t* buf_ranks,      // 指向排名（秩）数组的指针
        int64_t* buf_dims,       // 指向维度大小数组的指针
        int64_t* buf_strides,    // 指向步幅数组的指针
        int8_t* buf_dtypes,      // 指向数据类型数组的指针
        int64_t args_num,        // 参数数量
        int64_t* extra_args) {   // 指向额外参数数组的指针
      // 构造一个包含张量的向量，使用传入的缓冲区数据
      std::vector<at::Tensor> tensors = constructTensors(
          bufs_num,               // 缓冲区数量
          buf_data,               // 数据缓冲区指针数组
          buf_ranks,              // 秩（排名）数组指针
          buf_dims,               // 维度大小数组指针
          buf_strides,            // 步幅数组指针
          buf_dtypes);            // 数据类型数组指针
      at::Tensor& r = tensors[0]; // 获取第一个张量作为输出结果张量的引用
      const at::Tensor& self = tensors[1];  // 获取第二个张量作为 self 张量的常量引用
      const at::Tensor& other = tensors[2]; // 获取第三个张量作为 other 张量的常量引用
      try {
        // 调用 PyTorch 中的 lcm_out 函数，将 self 和 other 张量的最小公倍数写入 r 张量
        at::lcm_out(r, self, other);
      } catch (...) {
        // 捕获任何异常，如果有异常则不进行任何操作
      }
    }
static void nnc_aten_inverse(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取输入张量
  try {
    at::inverse_out(r, self);   // 调用 PyTorch 的 inverse_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}

static void nnc_aten_kron(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2];  // 获取第二个输入张量
  try {
    at::kron_out(r, self, other);   // 调用 PyTorch 的 kron_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}

static void nnc_aten_ldexp(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2];  // 获取第二个输入张量
  try {
    at::ldexp_out(r, self, other);   // 调用 PyTorch 的 ldexp_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}

static void nnc_aten_log(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取输入张量
  try {
    at::log_out(r, self);   // 调用 PyTorch 的 log_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}

static void nnc_aten_log10(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取输入张量
  try {
    at::log10_out(r, self);   // 调用 PyTorch 的 log10_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}

static void nnc_aten_log1p(
    int64_t bufs_num,          // 参数：缓冲区数量
    void** buf_data,           // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,        // 参数：缓冲区的秩数组
    int64_t* buf_dims,         // 参数：缓冲区的维度数组
    int64_t* buf_strides,      // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,        // 参数：缓冲区的数据类型数组
    int64_t args_num,          // 参数：附加参数的数量
    int64_t* extra_args) {     // 参数：附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 创建张量数组
  at::Tensor& r = tensors[0];     // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取输入张量
  try {
    at::log1p_out(r, self);   // 调用 PyTorch 的 log1p_out 函数
  } catch (...) {
    // 异常处理（省略）
  }
}


这段代码是一系列的静态函数，每个函数使用 PyTorch C++ 前端库（即aten）执行不同的张量运算（inverse、kron、ldexp、log、log10、log1p）。这些函数通过构建张量数组并调用相应的 PyTorch 函数来实现其功能。
    // 构造张量并进行对数操作
    void log2_tensors(
        void** buf_data,         // 张量数据的指针数组
        int64_t* buf_ranks,      // 张量的秩数组
        int64_t* buf_dims,       // 张量的维度数组
        int64_t* buf_strides,    // 张量的步幅数组
        int8_t* buf_dtypes,      // 张量的数据类型数组
        int64_t args_num,        // 张量参数的数量
        int64_t* extra_args) {   // 额外参数的指针数组
    
      // 使用给定的缓冲区数据构造张量向量
      std::vector<at::Tensor> tensors = constructTensors(
          bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
    
      // 取得第一个张量作为结果张量
      at::Tensor& r = tensors[0];
    
      // 取得第二个张量作为自变量张量
      const at::Tensor& self = tensors[1];
    
      // 尝试对第二个张量取对数，结果存入第一个张量
      try {
        at::log2_out(r, self);
      } catch (...) {
        // 如果出现异常则不进行任何处理
      }
    }
static void nnc_aten_logaddexp(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量列表，从传入的缓冲区数据和元数据中
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量 r
  at::Tensor& r = tensors[0];
  // 取得输入张量 self
  const at::Tensor& self = tensors[1];
  // 取得输入张量 other
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 logaddexp_out 函数，计算 self 和 other 的对数和，结果存入 r
    at::logaddexp_out(r, self, other);
  } catch (...) {
    // 捕获可能出现的任何异常
  }
}

static void nnc_aten_logaddexp2(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量列表，从传入的缓冲区数据和元数据中
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量 r
  at::Tensor& r = tensors[0];
  // 取得输入张量 self
  const at::Tensor& self = tensors[1];
  // 取得输入张量 other
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 logaddexp2_out 函数，计算 self 和 other 的以2为底的对数和，结果存入 r
    at::logaddexp2_out(r, self, other);
  } catch (...) {
    // 捕获可能出现的任何异常
  }
}

static void nnc_aten_xlogy(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量列表，从传入的缓冲区数据和元数据中
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量 r
  at::Tensor& r = tensors[0];
  // 取得输入张量 self
  const at::Tensor& self = tensors[1];
  // 取得输入张量 other
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 xlogy_out 函数，计算 self 和 other 的乘积的自然对数，结果存入 r
    at::xlogy_out(r, self, other);
  } catch (...) {
    // 捕获可能出现的任何异常
  }
}

void nnc_aten_matmul(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量列表，从传入的缓冲区数据和元数据中
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量 r
  at::Tensor& r = tensors[0];
  // 取得输入张量 self
  const at::Tensor& self = tensors[1];
  // 取得输入张量 other
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 matmul_out 函数，计算 self 和 other 的矩阵乘法，结果存入 r
    at::matmul_out(r, self, other);
  } catch (...) {
    // 捕获可能出现的任何异常
  }
}

static void nnc_aten__compute_linear_combination(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量列表，从传入的缓冲区数据和元数据中
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量 r
  at::Tensor& r = tensors[0];
  // 取得输入张量 input
  const at::Tensor& input = tensors[1];
  // 取得输入张量 coefficients
  const at::Tensor& coefficients = tensors[2];
  try {
    // 调用 PyTorch 中的 _compute_linear_combination_out 函数，计算 input 和 coefficients 的线性组合，结果存入 r
    at::_compute_linear_combination_out(r, input, coefficients);
  } catch (...) {
    // 捕获可能出现的任何异常
  }
}


这段代码是一系列静态函数，用于在 PyTorch 中执行不同的张量操作，如对数和、矩阵乘法以及线性组合计算。每个函数都接收一组缓冲区数据，构造张量后调用相应的 PyTorch 函数进行计算，将结果存储在指定的张量中。
    // 构造张量列表，使用给定的缓冲区数据、秩、维度、步幅和数据类型
    std::vector<at::Tensor> tensors = constructTensors(
        bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
    // 获取结果张量 r
    at::Tensor& r = tensors[0];
    // 获取输入张量 self
    const at::Tensor& self = tensors[1];
    // 获取第二个输入张量 mat2
    const at::Tensor& mat2 = tensors[2];
    try {
        // 调用 PyTorch 的矩阵乘法，将结果存入张量 r 中
        at::mm_out(r, self, mat2);
    } catch (...) {
        // 捕获任何异常，此处未对异常进行处理
    }
static void nnc_aten_mul(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 第一个输入张量
  const at::Tensor& other = tensors[2]; // 第二个输入张量
  try {
    at::mul_out(r, self, other);    // 使用ATen库计算 self * other，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}

static void nnc_aten_multiply(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 第一个输入张量
  const at::Tensor& other = tensors[2]; // 第二个输入张量
  try {
    at::multiply_out(r, self, other); // 使用ATen库计算 self * other，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}

void nnc_aten_mv(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 第一个输入张量
  const at::Tensor& vec = tensors[2];  // 第二个输入张量（向量）
  try {
    at::mv_out(r, self, vec);       // 使用ATen库计算 self * vec，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}

static void nnc_aten_rad2deg(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 输入张量
  try {
    at::rad2deg_out(r, self);       // 使用ATen库计算弧度到角度的转换，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}

static void nnc_aten_deg2rad(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 输入张量
  try {
    at::deg2rad_out(r, self);       // 使用ATen库计算角度到弧度的转换，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}

static void nnc_aten_reciprocal(
    int64_t bufs_num,               // 输入参数：张量缓冲区的数量
    void** buf_data,                // 输入参数：指向张量数据的指针数组
    int64_t* buf_ranks,             // 输入参数：张量的秩数组
    int64_t* buf_dims,              // 输入参数：张量每个维度的大小数组
    int64_t* buf_strides,           // 输入参数：张量每个维度的步长数组
    int8_t* buf_dtypes,             // 输入参数：张量的数据类型数组
    int64_t args_num,               // 输入参数：额外参数的数量
    int64_t* extra_args) {          // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];       // 结果张量
  const at::Tensor& self = tensors[1]; // 输入张量
  try {
    at::reciprocal_out(r, self);    // 使用ATen库计算张量的倒数，并将结果存储到 r 中
  } catch (...) {                   // 捕获任何异常
  }
}
static void nnc_aten_neg(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试计算张量自身元素的负值，将结果存入指定的输出张量 r 中
  try {
    at::neg_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_negative(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试计算张量自身元素的负值，将结果存入指定的输出张量 r 中
  try {
    at::negative_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_round(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试对张量自身元素进行四舍五入，将结果存入指定的输出张量 r 中
  try {
    at::round_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_rsqrt(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试对张量自身元素进行反平方根计算，将结果存入指定的输出张量 r 中
  try {
    at::rsqrt_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_silu(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试对张量自身元素进行 SiLU 激活函数计算，将结果存入指定的输出张量 r 中
  try {
    at::silu_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_mish(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试对张量自身元素进行 Mish 激活函数计算，将结果存入指定的输出张量 r 中
  try {
    at::mish_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_sigmoid(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 构造张量对象数组，根据给定的缓冲区数据、秩、维度、步幅和数据类型
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得自身张量的常量引用
  const at::Tensor& self = tensors[1];
  // 尝试对张量自身元素进行 Sigmoid 激活函数计算，将结果存入指定的输出张量 r 中
  try {
    at::sigmoid_out(r, self);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}
    int8_t* buf_dtypes,
    // 指向数据类型的指针数组
    int64_t args_num,
    // 参数数量，表示传递给函数的参数个数
    int64_t* extra_args) {
  // 使用构造函数将输入的各种缓冲区数据转换为张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得向量中的第一个张量对象并赋值给 r
  at::Tensor& r = tensors[0];
  // 取得向量中的第二个张量对象，并将其设为不可变的 self 引用
  const at::Tensor& self = tensors[1];
  // 尝试在 self 上应用 sigmoid 操作，并将结果存储在 r 中
  try {
    at::sigmoid_out(r, self);
  } catch (...) {
  }
static void nnc_aten_sin(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::sin_out(r, self);        // 调用 PyTorch 的 sin_out 函数计算正弦
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_sinc(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::sinc_out(r, self);       // 调用 PyTorch 的 sinc_out 函数计算正弦余弦
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_sinh(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::sinh_out(r, self);       // 调用 PyTorch 的 sinh_out 函数计算双曲正弦
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_sqrt(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::sqrt_out(r, self);       // 调用 PyTorch 的 sqrt_out 函数计算平方根
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_square(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::square_out(r, self);     // 调用 PyTorch 的 square_out 函数计算平方
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_tan(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::tan_out(r, self);        // 调用 PyTorch 的 tan_out 函数计算正切
  } catch (...) {                // 捕获任何异常
  }
}



static void nnc_aten_tanh(
    int64_t bufs_num,            // 参数：张量缓冲区的数量
    void** buf_data,             // 参数：张量数据的指针数组
    int64_t* buf_ranks,          // 参数：张量的秩数组
    int64_t* buf_dims,           // 参数：张量维度数组
    int64_t* buf_strides,        // 参数：张量步长数组
    int8_t* buf_dtypes,          // 参数：张量数据类型数组
    int64_t args_num,            // 参数：额外参数的数量
    int64_t* extra_args) {       // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];    // 获取结果张量的引用
  const at::Tensor& self = tensors[1];
    // 定义一个接受整数参数的函数，该函数预期参数个数为 args_num
    // 和 extra_args 指向的整数数组
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的多个缓冲区信息构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出构造的张量列表中的第一个张量作为结果张量 r
  at::Tensor& r = tensors[0];
  // 取出构造的张量列表中的第二个张量作为输入张量 self
  const at::Tensor& self = tensors[1];
  // 尝试对输入张量 self 进行双曲正切运算，并将结果存储在结果张量 r 中
  try {
    at::tanh_out(r, self);
  } catch (...) {
  }
static void nnc_aten_trunc(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和第一个输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 的 trunc_out 操作
  try {
    at::trunc_out(r, self);
  } catch (...) {
    // 捕获任何可能的异常
  }
}

static void nnc_aten_fix(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和第一个输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 的 fix_out 操作
  try {
    at::fix_out(r, self);
  } catch (...) {
    // 捕获任何可能的异常
  }
}

static void nnc_aten_heaviside(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& values = tensors[2];
  // 尝试调用 ATen 的 heaviside_out 操作
  try {
    at::heaviside_out(r, self, values);
  } catch (...) {
    // 捕获任何可能的异常
  }
}

static void nnc_aten_hspmm(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& mat1 = tensors[1];
  const at::Tensor& mat2 = tensors[2];
  // 尝试调用 ATen 的 hspmm_out 操作
  try {
    at::hspmm_out(r, mat1, mat2);
  } catch (...) {
    // 捕获任何可能的异常
  }
}

static void nnc_aten_bitwise_and(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  // 尝试调用 ATen 的 bitwise_and_out 操作
  try {
    at::bitwise_and_out(r, self, other);
  } catch (...) {
    // 捕获任何可能的异常
  }
}

static void nnc_aten_bitwise_or(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用输入的数据构造张量列表
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量和输入张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  // 尝试调用 ATen 的 bitwise_or_out 操作
  try {
    at::bitwise_or_out(r, self, other);
  } catch (...) {
    // 捕获任何可能的异常
  }
}
    // 调用 ATen 库中的 bitwise_or_out 函数，计算 self 和 other 张量的按位或操作，并将结果写入 r 张量
    at::bitwise_or_out(r, self, other);
  } catch (...) {
    // 捕获可能发生的任何异常，确保程序不会因此中断
  }
static void nnc_aten_bitwise_xor(
    int64_t bufs_num,                // 参数：bufs_num，表示缓冲区数量
    void** buf_data,                 // 参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,              // 参数：buf_ranks，指向缓冲区秩的指针
    int64_t* buf_dims,               // 参数：buf_dims，指向缓冲区维度的指针
    int64_t* buf_strides,            // 参数：buf_strides，指向缓冲区步长的指针
    int8_t* buf_dtypes,              // 参数：buf_dtypes，指向缓冲区数据类型的指针
    int64_t args_num,                // 参数：args_num，参数数量
    int64_t* extra_args) {           // 参数：extra_args，额外参数的指针
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构造 ATen 张量向量
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量 self
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量 other
  try {
    at::bitwise_xor_out(r, self, other);  // 调用 ATen 库的按位异或操作，将结果存入 r
  } catch (...) {                     // 捕获所有异常
  }
}

static void nnc_aten_ne(
    int64_t bufs_num,                // 参数：bufs_num，表示缓冲区数量
    void** buf_data,                 // 参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,              // 参数：buf_ranks，指向缓冲区秩的指针
    int64_t* buf_dims,               // 参数：buf_dims，指向缓冲区维度的指针
    int64_t* buf_strides,            // 参数：buf_strides，指向缓冲区步长的指针
    int8_t* buf_dtypes,              // 参数：buf_dtypes，指向缓冲区数据类型的指针
    int64_t args_num,                // 参数：args_num，参数数量
    int64_t* extra_args) {           // 参数：extra_args，额外参数的指针
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构造 ATen 张量向量
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量 self
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量 other
  try {
    at::ne_out(r, self, other);     // 调用 ATen 库的不等于比较操作，将结果存入 r
  } catch (...) {                     // 捕获所有异常
  }
}

static void nnc_aten_not_equal(
    int64_t bufs_num,                // 参数：bufs_num，表示缓冲区数量
    void** buf_data,                 // 参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,              // 参数：buf_ranks，指向缓冲区秩的指针
    int64_t* buf_dims,               // 参数：buf_dims，指向缓冲区维度的指针
    int64_t* buf_strides,            // 参数：buf_strides，指向缓冲区步长的指针
    int8_t* buf_dtypes,              // 参数：buf_dtypes，指向缓冲区数据类型的指针
    int64_t args_num,                // 参数：args_num，参数数量
    int64_t* extra_args) {           // 参数：extra_args，额外参数的指针
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构造 ATen 张量向量
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量 self
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量 other
  try {
    at::not_equal_out(r, self, other);  // 调用 ATen 库的不等于比较操作，将结果存入 r
  } catch (...) {                     // 捕获所有异常
  }
}

static void nnc_aten_eq(
    int64_t bufs_num,                // 参数：bufs_num，表示缓冲区数量
    void** buf_data,                 // 参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,              // 参数：buf_ranks，指向缓冲区秩的指针
    int64_t* buf_dims,               // 参数：buf_dims，指向缓冲区维度的指针
    int64_t* buf_strides,            // 参数：buf_strides，指向缓冲区步长的指针
    int8_t* buf_dtypes,              // 参数：buf_dtypes，指向缓冲区数据类型的指针
    int64_t args_num,                // 参数：args_num，参数数量
    int64_t* extra_args) {           // 参数：extra_args，额外参数的指针
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构造 ATen 张量向量
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量 self
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量 other
  try {
    at::eq_out(r, self, other);     // 调用 ATen 库的等于比较操作，将结果存入 r
  } catch (...) {                     // 捕获所有异常
  }
}

static void nnc_aten_ge(
    int64_t bufs_num,                // 参数：bufs_num，表示缓冲区数量
    void** buf_data,                 // 参数：buf_data，指向缓冲区数据的指针数组
    int64_t* buf_ranks,              // 参数：buf_ranks，指向缓冲区秩的指针
    int64_t* buf_dims,               // 参数：buf_dims，指向缓冲区维度的指针
    int64_t* buf_strides,            // 参数：buf_strides，指向缓冲区步长的指针
    int8_t* buf_dtypes,              // 参数：buf_dtypes，指向缓冲区数据类型的指针
    int64_t args_num,                // 参数：args_num，参数数量
    int64_t* extra_args) {           // 参数：extra_args，额外参数的指针
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构造 ATen 张量向量
  at::Tensor& r = tensors[0];       // 取出第一个张量作为输出张量 r
  const at::Tensor& self = tensors[1];  // 取出第二个张量作为输入张量 self
  const at::Tensor& other = tensors[2];  // 取出第三个张量作为输入张量 other
  try {
    at::ge_out(r, self, other);     // 调
    int64_t* extra_args) {
  // 使用传入的多个缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 将第一个张量作为结果张量 r
  at::Tensor& r = tensors[0];
  // 将第二个张量作为 self 张量
  const at::Tensor& self = tensors[1];
  // 将第三个张量作为 other 张量
  const at::Tensor& other = tensors[2];
  try {
    // 使用 greater_equal_out 函数比较 self 和 other 张量，将结果存储到 r 中
    at::greater_equal_out(r, self, other);
  } catch (...) {
  }
}
static void nnc_aten_le(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的参数构造张量数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得第一个输入张量的常量引用
  const at::Tensor& self = tensors[1];
  // 取得第二个输入张量的常量引用
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 at::le_out 函数，计算 self <= other 的结果并存储在 r 中
    at::le_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_less_equal(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的参数构造张量数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得第一个输入张量的常量引用
  const at::Tensor& self = tensors[1];
  // 取得第二个输入张量的常量引用
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 at::less_equal_out 函数，计算 self <= other 的结果并存储在 r 中
    at::less_equal_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_gt(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的参数构造张量数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得第一个输入张量的常量引用
  const at::Tensor& self = tensors[1];
  // 取得第二个输入张量的常量引用
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 at::gt_out 函数，计算 self > other 的结果并存储在 r 中
    at::gt_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_greater(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的参数构造张量数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得第一个输入张量的常量引用
  const at::Tensor& self = tensors[1];
  // 取得第二个输入张量的常量引用
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 at::greater_out 函数，计算 self > other 的结果并存储在 r 中
    at::greater_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_lt(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用给定的参数构造张量数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量的引用
  at::Tensor& r = tensors[0];
  // 取得第一个输入张量的常量引用
  const at::Tensor& self = tensors[1];
  // 取得第二个输入张量的常量引用
  const at::Tensor& other = tensors[2];
  try {
    // 调用 PyTorch 中的 at::lt_out 函数，计算 self < other 的结果并存储在 r 中
    at::lt_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，不进行处理
  }
}

static void nnc_aten_less(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    // 使用给定的参数构造张量列表
    std::vector<at::Tensor> tensors = constructTensors(
        bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
    
    // 将第一个张量指定为输出张量 r
    at::Tensor& r = tensors[0];
    
    // 将第二个张量指定为输入张量 self
    const at::Tensor& self = tensors[1];
    
    // 将第三个张量指定为输入张量 other
    const at::Tensor& other = tensors[2];
    
    // 尝试执行 self < other 的比较操作，并将结果存储到张量 r 中
    try {
        at::less_out(r, self, other);
    } catch (...) {
        // 捕获任何可能发生的异常，但在此处没有特定处理动作
    }
static void nnc_aten_take(
    int64_t bufs_num,                   // 参数：缓冲区数量
    void** buf_data,                    // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,                 // 参数：缓冲区张量的秩数组
    int64_t* buf_dims,                  // 参数：缓冲区张量的维度数组
    int64_t* buf_strides,               // 参数：缓冲区张量的步长数组
    int8_t* buf_dtypes,                 // 参数：缓冲区张量的数据类型数组
    int64_t args_num,                   // 参数：额外参数的数量
    int64_t* extra_args) {              // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes); // 构建张量对象数组
  at::Tensor& r = tensors[0];           // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  const at::Tensor& index = tensors[2]; // 获取索引张量的常量引用
  try {
    at::take_out(r, self, index);       // 调用 ATen 库的 take_out 函数
  } catch (...) {                       // 捕获任何异常
  }
}

static void nnc_aten_masked_select(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes); // 构建张量对象数组
  at::Tensor& r = tensors[0];           // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  const at::Tensor& mask = tensors[2];  // 获取掩码张量的常量引用
  try {
    at::masked_select_out(r, self, mask); // 调用 ATen 库的 masked_select_out 函数
  } catch (...) {                       // 捕获任何异常
  }
}

static void nnc_aten_nonzero(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes); // 构建张量对象数组
  at::Tensor& r = tensors[0];           // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  try {
    at::nonzero_out(r, self);          // 调用 ATen 库的 nonzero_out 函数
  } catch (...) {                       // 捕获任何异常
  }
}

static void nnc_aten_orgqr(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes); // 构建张量对象数组
  at::Tensor& r = tensors[0];           // 获取结果张量的引用
  const at::Tensor& self = tensors[1];  // 获取输入张量的常量引用
  const at::Tensor& input2 = tensors[2]; // 获取第二输入张量的常量引用
  try {
    at::orgqr_out(r, self, input2);     // 调用 ATen 库的 orgqr_out 函数
  } catch (...) {                       // 捕获任何异常
  }
}

static void nnc_aten_lu_solve(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes); // 构建张量对象数组
  at::Tensor& r = tensors[0];            // 获取结果张量的引用
  const at::Tensor& self = tensors[1];   // 获取输入张量的常量引用
  const at::Tensor& LU_data = tensors[2]; // 获取 LU 分解数据张量的常量引用
  const at::Tensor& LU_pivots = tensors[3]; // 获取 LU 分解主元张量的常量引用
  try {
    at::lu_solve_out(r, self, LU_data, LU_pivots); // 调用 ATen 库的 lu_solve_out 函数
  } catch (...) {                        // 捕获任何异常
  }
}

static void nnc_aten_lgamma(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    # 定义一个函数，接受多个参数，其中包括指向 int64_t 类型的指针
    int64_t* extra_args) {
  # 使用 constructTensors 函数构造张量列表，参数包括各种缓冲区数据
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  # 获取返回的第一个张量并引用它
  at::Tensor& r = tensors[0];
  # 获取返回的第二个张量并将其声明为常量引用
  const at::Tensor& self = tensors[1];
  # 尝试计算 self 张量的 lgamma 函数并将结果写入 r 张量
  try {
    at::lgamma_out(r, self);
  } catch (...) {
  }
static void nnc_aten_digamma(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 库中的 digamma_out 函数计算 digamma 函数的输出
  try {
    at::digamma_out(r, self);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_erfinv(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 库中的 erfinv_out 函数计算 erfinv 函数的输出
  try {
    at::erfinv_out(r, self);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_i0(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 库中的 i0_out 函数计算 i0 函数的输出
  try {
    at::i0_out(r, self);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_sign(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 库中的 sign_out 函数计算 sign 函数的输出
  try {
    at::sign_out(r, self);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_signbit(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  // 尝试调用 ATen 库中的 signbit_out 函数计算 signbit 函数的输出
  try {
    at::signbit_out(r, self);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_atan2(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  // 尝试调用 ATen 库中的 atan2_out 函数计算 atan2 函数的输出
  try {
    at::atan2_out(r, self, other);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}

static void nnc_aten_lerp(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的参数构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取得结果张量和自身张量的引用
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& end = tensors[2];
  // 尝试调用 ATen 库中的 lerp_out 函数计算 lerp 函数的输出
  try {
    at::lerp_out(r, self, end, extra_args[0]);
  } catch (...) {
    // 捕获任何异常，暂时不做处理
  }
}
    int64_t* buf_dims,                   // 整型指针，指向存储张量维度信息的数组
    int64_t* buf_strides,                // 整型指针，指向存储张量步长信息的数组
    int8_t* buf_dtypes,                  // 字节型指针，指向存储张量数据类型的数组
    int64_t args_num,                    // 整型变量，表示附加参数的数量
    int64_t* extra_args) {               // 整型指针，指向附加参数的数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num,                          // bufs_num 是传入的参数，用于构造张量的数量
      buf_data,                          // buf_data 是张量数据的指针
      buf_ranks,                         // buf_ranks 是张量秩的指针
      buf_dims,                          // buf_dims 是张量维度的指针
      buf_strides,                       // buf_strides 是张量步长的指针
      buf_dtypes);                       // buf_dtypes 是张量数据类型的指针
  at::Tensor& r = tensors[0];            // 获取第一个张量作为返回结果 r
  const at::Tensor& self = tensors[1];   // 获取第二个张量作为常量引用 self
  const at::Tensor& end = tensors[2];    // 获取第三个张量作为常量引用 end
  const at::Tensor& weight = tensors[3]; // 获取第四个张量作为常量引用 weight
  try {
    at::lerp_out(r, self, end, weight);  // 使用 torch 的 lerp_out 函数对张量进行线性插值
  } catch (...) {
    // 捕获任何异常，这里没有具体处理方法
  }
static void nnc_aten_fmod(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];         // 取得结果张量的引用
  const at::Tensor& self = tensors[1];// 取得第一个输入张量的常量引用
  const at::Tensor& other = tensors[2];// 取得第二个输入张量的常量引用
  try {
    at::fmod_out(r, self, other);     // 调用 PyTorch 的 fmod_out 函数
  } catch (...) {                     // 捕获任何异常
  }
}

static void nnc_aten_hypot(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];         // 取得结果张量的引用
  const at::Tensor& self = tensors[1];// 取得第一个输入张量的常量引用
  const at::Tensor& other = tensors[2];// 取得第二个输入张量的常量引用
  try {
    at::hypot_out(r, self, other);    // 调用 PyTorch 的 hypot_out 函数
  } catch (...) {                     // 捕获任何异常
  }
}

static void nnc_aten_igamma(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];         // 取得结果张量的引用
  const at::Tensor& self = tensors[1];// 取得第一个输入张量的常量引用
  const at::Tensor& other = tensors[2];// 取得第二个输入张量的常量引用
  try {
    at::igamma_out(r, self, other);   // 调用 PyTorch 的 igamma_out 函数
  } catch (...) {                     // 捕获任何异常
  }
}

static void nnc_aten_igammac(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];         // 取得结果张量的引用
  const at::Tensor& self = tensors[1];// 取得第一个输入张量的常量引用
  const at::Tensor& other = tensors[2];// 取得第二个输入张量的常量引用
  try {
    at::igammac_out(r, self, other);  // 调用 PyTorch 的 igammac_out 函数
  } catch (...) {                     // 捕获任何异常
  }
}

static void nnc_aten_nextafter(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];         // 取得结果张量的引用
  const at::Tensor& self = tensors[1];// 取得第一个输入张量的常量引用
  const at::Tensor& other = tensors[2];// 取得第二个输入张量的常量引用
  try {
    at::nextafter_out(r, self, other);// 调用 PyTorch 的 nextafter_out 函数
  } catch (...) {                     // 捕获任何异常
  }
}

static void nnc_aten_remainder(
    int64_t bufs_num,                 // 参数：缓冲区数量
    void** buf_data,                  // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,               // 参数：缓冲区的秩数组
    int64_t* buf_dims,                // 参数：缓冲区的维度数组
    int64_t* buf_strides,             // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,               // 参数：缓冲区的数据类型数组
    int64_t args_num,                 // 参数：参数数量
    int64_t* extra_args) {            // 参数：额外参数数组
    int64_t* extra_args) {
```  
# 定义一个函数，该函数接受多个参数，其中包括一个指向 int64_t 类型的指针。


  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
```py  
# 调用 constructTensors 函数，传入多个参数并将返回结果存储在名为 tensors 的 std::vector<at::Tensor> 中。


  at::Tensor& r = tensors[0];
```  
# 将 tensors 中的第一个元素（at::Tensor 对象）赋值给引用变量 r。


  const at::Tensor& self = tensors[1];
```py  
# 将 tensors 中的第二个元素（at::Tensor 对象）赋值给常量引用变量 self。


  const at::Tensor& other = tensors[2];
```  
# 将 tensors 中的第三个元素（at::Tensor 对象）赋值给常量引用变量 other。


  try {
    at::remainder_out(r, self, other);
```py  
# 尝试调用 at::remainder_out 函数，该函数计算 r = self % other，即求 self 与 other 的余数并将结果存储在 r 中。


  } catch (...) {
```  
# 捕获可能抛出的任何异常，如果有异常发生，则执行空的 catch 块。
static void nnc_aten_fmin(
    int64_t bufs_num,              // 输入参数：张量数组的数量
    void** buf_data,               // 输入参数：张量数据的指针数组
    int64_t* buf_ranks,            // 输入参数：张量的秩数组
    int64_t* buf_dims,             // 输入参数：张量的维度数组
    int64_t* buf_strides,          // 输入参数：张量的步长数组
    int8_t* buf_dtypes,            // 输入参数：张量的数据类型数组
    int64_t args_num,              // 输入参数：额外参数的数量
    int64_t* extra_args) {         // 输入参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::fmin_out(r, self, other);  // 使用ATen库计算 self 和 other 张量的元素级最小值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}

static void nnc_aten_fmax(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::fmax_out(r, self, other);  // 使用ATen库计算 self 和 other 张量的元素级最大值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}

static void nnc_aten_maximum(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::maximum_out(r, self, other);  // 使用ATen库计算 self 和 other 张量的元素级最大值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}

static void nnc_aten_max(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::max_out(r, self, other);   // 使用ATen库计算 self 和 other 张量的元素级最大值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}

static void nnc_aten_minimum(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::minimum_out(r, self, other);  // 使用ATen库计算 self 和 other 张量的元素级最小值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}

static void nnc_aten_min(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];      // 获取结果张量
  const at::Tensor& self = tensors[1];  // 获取第一个输入张量
  const at::Tensor& other = tensors[2]; // 获取第二个输入张量
  try {
    at::min_out(r, self, other);   // 使用ATen库计算 self 和 other 张量的元素级最小值，结果存入 r
  } catch (...) {                  // 捕获可能发生的任何异常
  }
}
    int64_t* extra_args) {
```py  
# 接收一些额外的参数作为输入，类型为 int64_t*


  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
```  
# 使用给定的缓冲区数据，构造张量（Tensor）的向量


  at::Tensor& r = tensors[0];
```py  
# 将第一个张量（Tensor）标记为输出张量 r


  const at::Tensor& self = tensors[1];
```  
# 将第二个张量（Tensor）标记为输入张量 self


  const at::Tensor& other = tensors[2];
```py  
# 将第三个张量（Tensor）标记为输入张量 other


  try {
    at::min_out(r, self, other);
  } catch (...) {
  }
```  
# 尝试调用 PyTorch 中的最小值函数 at::min_out，将 self 和 other 中的最小值写入 r 中，捕获任何可能抛出的异常
// 定义静态函数 nnc_aten_msort，用于执行 PyTorch 的 msort 操作
static void nnc_aten_msort(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  try {
    // 调用 PyTorch 的 msort 函数，将结果保存到 r 中
    at::msort_out(r, self);
  } catch (...) {
    // 捕获可能出现的异常
  }
}

// 定义静态函数 nnc_aten_pow，用于执行 PyTorch 的 pow 操作
static void nnc_aten_pow(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 获取指数张量 exponent
  const at::Tensor& exponent = tensors[2];
  try {
    // 调用 PyTorch 的 pow 函数，将结果保存到 r 中
    at::pow_out(r, self, exponent);
  } catch (...) {
    // 捕获可能出现的异常
  }
}

// 定义静态函数 nnc_aten_float_power，用于执行 PyTorch 的 float_power 操作
static void nnc_aten_float_power(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 获取指数张量 exponent
  const at::Tensor& exponent = tensors[2];
  try {
    // 调用 PyTorch 的 float_power 函数，将结果保存到 r 中
    at::float_power_out(r, self, exponent);
  } catch (...) {
    // 捕获可能出现的异常
  }
}

// 定义静态函数 nnc_aten_hardsigmoid，用于执行 PyTorch 的 hardsigmoid 操作
static void nnc_aten_hardsigmoid(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  try {
    // 调用 PyTorch 的 hardsigmoid 函数，将结果保存到 r 中
    at::hardsigmoid_out(r, self);
  } catch (...) {
    // 捕获可能出现的异常
  }
}

// 定义静态函数 nnc_aten_hardswish，用于执行 PyTorch 的 hardswish 操作
static void nnc_aten_hardswish(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  try {
    // 调用 PyTorch 的 hardswish 函数，将结果保存到 r 中
    at::hardswish_out(r, self);
  } catch (...) {
    // 捕获可能出现的异常
  }
}

// 定义静态函数 nnc_aten_log_sigmoid，用于执行 PyTorch 的 log_sigmoid 操作
static void nnc_aten_log_sigmoid(
    int64_t bufs_num,             // 缓冲区数量
    void** buf_data,              // 缓冲区数据指针数组
    int64_t* buf_ranks,           // 缓冲区秩数组
    int64_t* buf_dims,            // 缓冲区维度数组
    int64_t* buf_strides,         // 缓冲区步长数组
    int8_t* buf_dtypes,           // 缓冲区数据类型数组
    int64_t args_num,             // 参数数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区信息构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取结果张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  try {
    // 调用 PyTorch 的 log_sigmoid 函数，将结果保存到 r 中
    at::log
static void nnc_aten_log_sigmoid_backward(
    int64_t bufs_num,                       // 参数：缓冲区数量
    void** buf_data,                        // 参数：缓冲区数据的指针数组
    int64_t* buf_ranks,                     // 参数：缓冲区的秩数组
    int64_t* buf_dims,                      // 参数：缓冲区的维度数组
    int64_t* buf_strides,                   // 参数：缓冲区的步长数组
    int8_t* buf_dtypes,                     // 参数：缓冲区的数据类型数组
    int64_t args_num,                       // 参数：额外参数的数量
    int64_t* extra_args) {                  // 参数：额外参数数组
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构建张量向量
  at::Tensor& r = tensors[0];               // 参考输出张量 r
  const at::Tensor& grad_output = tensors[1]; // 参考输入张量 grad_output
  const at::Tensor& self = tensors[2];      // 参考输入张量 self
  const at::Tensor& buffer = tensors[3];    // 参考输入张量 buffer
  try {
    at::log_sigmoid_backward_out(r, grad_output, self, buffer);  // 调用 PyTorch 的 log_sigmoid_backward_out 函数
  } catch (...) {
    // 异常处理，这里未指定具体处理方法
  }
}

static void nnc_aten_adaptive_avg_pool3d_backward(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构建张量向量
  at::Tensor& r = tensors[0];               // 参考输出张量 r
  const at::Tensor& grad_output = tensors[1]; // 参考输入张量 grad_output
  const at::Tensor& self = tensors[2];      // 参考输入张量 self
  try {
    at::adaptive_avg_pool3d_backward_out(r, grad_output, self);  // 调用 PyTorch 的 adaptive_avg_pool3d_backward_out 函数
  } catch (...) {
    // 异常处理，这里未指定具体处理方法
  }
}

static void nnc_aten_adaptive_max_pool2d_backward(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构建张量向量
  at::Tensor& r = tensors[0];               // 参考输出张量 r
  const at::Tensor& grad_output = tensors[1]; // 参考输入张量 grad_output
  const at::Tensor& self = tensors[2];      // 参考输入张量 self
  const at::Tensor& indices = tensors[3];   // 参考输入张量 indices
  try {
    at::adaptive_max_pool2d_backward_out(r, grad_output, self, indices);  // 调用 PyTorch 的 adaptive_max_pool2d_backward_out 函数
  } catch (...) {
    // 异常处理，这里未指定具体处理方法
  }
}

static void nnc_aten_adaptive_max_pool3d_backward(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构建张量向量
  at::Tensor& r = tensors[0];               // 参考输出张量 r
  const at::Tensor& grad_output = tensors[1]; // 参考输入张量 grad_output
  const at::Tensor& self = tensors[2];      // 参考输入张量 self
  const at::Tensor& indices = tensors[3];   // 参考输入张量 indices
  try {
    at::adaptive_max_pool3d_backward_out(r, grad_output, self, indices);  // 调用 PyTorch 的 adaptive_max_pool3d_backward_out 函数
  } catch (...) {
    // 异常处理，这里未指定具体处理方法
  }
}

static void nnc_aten_sigmoid_backward(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);  // 构建张量向量
  at::Tensor& r = tensors[0];               // 参考输出张量 r
  const at::Tensor& grad_output = tensors[1]; // 参考输入张量 grad_output
  const at::Tensor& output = tensors[2];     // 参考输入张量 output
  try {
    // 调用 PyTorch 的 sigmoid_backward_out 函数
    at::sigmoid_backward_out(r, grad_output, output);
  } catch (...) {
    // 异常处理，这里未指定具体处理方法
  }
}
    // 使用 ATen 库中的 sigmoid_backward_out 函数，对输入的张量 r 进行反向传播计算
    at::sigmoid_backward_out(r, grad_output, output);
  } catch (...) {
    // 捕获任何异常，此处省略了异常处理的具体逻辑
  }
static void nnc_aten_tanh_backward(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为梯度输出张量
  const at::Tensor& grad_output = tensors[1];
  // 取出张量向量中的第三个张量作为输出张量
  const at::Tensor& output = tensors[2];
  // 调用 PyTorch 的 tanh_backward_out 函数，计算双曲正切函数的反向传播
  try {
    at::tanh_backward_out(r, grad_output, output);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}

static void nnc_aten_isposinf(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为输入张量
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 isposinf_out 函数，判断输入张量中哪些元素是正无穷
  try {
    at::isposinf_out(r, self);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}

static void nnc_aten_isneginf(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为输入张量
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 isneginf_out 函数，判断输入张量中哪些元素是负无穷
  try {
    at::isneginf_out(r, self);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}

static void nnc_aten_special_entr(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为输入张量
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 special_entr_out 函数，计算元素的特殊熵
  try {
    at::special_entr_out(r, self);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}

static void nnc_aten_special_expm1(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为输入张量
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 special_expm1_out 函数，计算元素的指数减一次方
  try {
    at::special_expm1_out(r, self);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}

static void nnc_aten_special_exp2(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  // 使用传入的数据构造张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 取出张量向量中的第一个张量作为输出张量
  at::Tensor& r = tensors[0];
  // 取出张量向量中的第二个张量作为输入张量
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 special_exp2_out 函数，计算元素的 2 的指数次方
  try {
    at::special_exp2_out(r, self);
  } catch (...) {
    // 异常处理代码为空，即不处理任何异常情况
  }
}
// 使用传入的参数构造张量列表
std::vector<at::Tensor> tensors = constructTensors(
    bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
// 获取结果张量 r 和输入张量 self
at::Tensor& r = tensors[0];
const at::Tensor& self = tensors[1];
// 尝试调用 special_gammaln_out 函数计算 self 的伽马对数，将结果存入 r
try {
  at::special_gammaln_out(r, self);
} catch (...) {
}

// 以下函数依次类似，用法和注释类似，只是调用不同的特殊数学函数
// 尝试调用 special_erf_out 函数计算 self 的误差函数，将结果存入 r
static void nnc_aten_special_erf(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::special_erf_out(r, self);
  } catch (...) {
  }
}

// 尝试调用 special_erfc_out 函数计算 self 的余误差函数，将结果存入 r
static void nnc_aten_special_erfc(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::special_erfc_out(r, self);
  } catch (...) {
  }
}

// 尝试调用 special_erfinv_out 函数计算 self 的反误差函数，将结果存入 r
static void nnc_aten_special_erfinv(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::special_erfinv_out(r, self);
  } catch (...) {
  }
}

// 尝试调用 special_xlog1py_out 函数计算 self 和 other 的对数加一函数，将结果存入 r
static void nnc_aten_special_xlog1py(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  try {
    at::special_xlog1py_out(r, self, other);
  } catch (...) {
  }
}

// 尝试调用 special_i0e_out 函数计算 self 的修改的贝塞尔函数 i0e，将结果存入 r
static void nnc_aten_special_i0e(
    int64_t bufs_num,
    void** buf_data,
    int64_t* buf_ranks,
    int64_t* buf_dims,
    int64_t* buf_strides,
    int8_t* buf_dtypes,
    int64_t args_num,
    int64_t* extra_args) {
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  try {
    at::special_i0e_out(r, self);
  } catch (...) {
  }
}
// 定义一个静态函数，用于计算特殊函数 expit 的输出结果
static void nnc_aten_special_expit(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的特殊函数 expit，并将结果存入 r 中
  try {
    at::special_expit_out(r, self);
  } catch (...) {
    // 捕获可能的异常，暂时未处理
  }
}

// 定义一个静态函数，用于计算 Cholesky 分解的输出结果
static void nnc_aten_linalg_cholesky(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的 Cholesky 分解函数，并将结果存入 r 中
  try {
    at::linalg_cholesky_out(r, self);
  } catch (...) {
    // 捕获可能的异常，暂时未处理
  }
}

// 定义一个静态函数，用于计算行列式的输出结果
static void nnc_aten_linalg_det(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的行列式计算函数，并将结果存入 r 中
  try {
    at::linalg_det_out(r, self);
  } catch (...) {
    // 捕获可能的异常，暂时未处理
  }
}

// 定义一个静态函数，用于计算特征值的输出结果
static void nnc_aten_linalg_eigvals(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
  // 调用 PyTorch 的特征值计算函数，并将结果存入 r 中
  try {
    at::linalg_eigvals_out(r, self);
  } catch (...) {
    // 捕获可能的异常，暂时未处理
  }
}

// 定义一个静态函数，用于计算 Householder 乘积的输出结果
static void nnc_aten_linalg_householder_product(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 input
  const at::Tensor& input = tensors[1];
  // 获取输入张量 tau
  const at::Tensor& tau = tensors[2];
  // 调用 PyTorch 的 Householder 乘积计算函数，并将结果存入 r 中
  try {
    at::linalg_householder_product_out(r, input, tau);
  } catch (...) {
    // 捕获可能的异常，暂时未处理
  }
}

// 定义一个静态函数，用于计算矩阵的逆的输出结果
static void nnc_aten_linalg_inv(
    int64_t bufs_num,          // 输入的张量缓冲区数量
    void** buf_data,           // 指向输入张量数据的指针数组
    int64_t* buf_ranks,        // 输入张量的秩数组
    int64_t* buf_dims,         // 输入张量的维度数组
    int64_t* buf_strides,      // 输入张量的步长数组
    int8_t* buf_dtypes,        // 输入张量的数据类型数组
    int64_t args_num,          // 额外参数的数量
    int64_t* extra_args) {     // 指向额外参数的指针
  // 构造张量对象的向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 获取输出张量 r
  at::Tensor& r = tensors[0];
  // 获取输入张量 self
  const at::Tensor& self = tensors[1];
// 定义函数 nnc_aten_inner，接收多个参数来执行内积操作
static void nnc_aten_inner(
    int64_t bufs_num,             // 输入的缓冲区数量
    void** buf_data,              // 缓冲区数据的指针数组
    int64_t* buf_ranks,           // 缓冲区的秩数组
    int64_t* buf_dims,            // 缓冲区的维度数组
    int64_t* buf_strides,         // 缓冲区的步长数组
    int8_t* buf_dtypes,           // 缓冲区的数据类型数组
    int64_t args_num,             // 额外参数的数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 分别引用内积结果张量 r，以及输入张量 self 和 other
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& other = tensors[2];
  // 尝试执行内积操作，并将结果保存在 r 中
  try {
    at::inner_out(r, self, other);
  } catch (...) {  // 捕获任何可能的异常
  }
}

// 定义函数 nnc_aten_outer，接收多个参数来执行外积操作
static void nnc_aten_outer(
    int64_t bufs_num,             // 输入的缓冲区数量
    void** buf_data,              // 缓冲区数据的指针数组
    int64_t* buf_ranks,           // 缓冲区的秩数组
    int64_t* buf_dims,            // 缓冲区的维度数组
    int64_t* buf_strides,         // 缓冲区的步长数组
    int8_t* buf_dtypes,           // 缓冲区的数据类型数组
    int64_t args_num,             // 额外参数的数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 分别引用外积结果张量 r，以及输入张量 self 和 vec2
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& vec2 = tensors[2];
  // 尝试执行外积操作，并将结果保存在 r 中
  try {
    at::outer_out(r, self, vec2);
  } catch (...) {  // 捕获任何可能的异常
  }
}

// 定义函数 nnc_aten_ger，接收多个参数来执行广义外积操作
static void nnc_aten_ger(
    int64_t bufs_num,             // 输入的缓冲区数量
    void** buf_data,              // 缓冲区数据的指针数组
    int64_t* buf_ranks,           // 缓冲区的秩数组
    int64_t* buf_dims,            // 缓冲区的维度数组
    int64_t* buf_strides,         // 缓冲区的步长数组
    int8_t* buf_dtypes,           // 缓冲区的数据类型数组
    int64_t args_num,             // 额外参数的数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 分别引用广义外积结果张量 r，以及输入张量 self 和 vec2
  at::Tensor& r = tensors[0];
  const at::Tensor& self = tensors[1];
  const at::Tensor& vec2 = tensors[2];
  // 尝试执行广义外积操作，并将结果保存在 r 中
  try {
    at::ger_out(r, self, vec2);
  } catch (...) {  // 捕获任何可能的异常
  }
}

// 定义函数 nnc_aten_linalg_svdvals，接收多个参数来执行奇异值分解操作
static void nnc_aten_linalg_svdvals(
    int64_t bufs_num,             // 输入的缓冲区数量
    void** buf_data,              // 缓冲区数据的指针数组
    int64_t* buf_ranks,           // 缓冲区的秩数组
    int64_t* buf_dims,            // 缓冲区的维度数组
    int64_t* buf_strides,         // 缓冲区的步长数组
    int8_t* buf_dtypes,           // 缓冲区的数据类型数组
    int64_t args_num,             // 额外参数的数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 引用奇异值结果张量 r，以及输入张量 input
  at::Tensor& r = tensors[0];
  const at::Tensor& input = tensors[1];
  // 尝试执行奇异值分解操作，并将结果保存在 r 中
  try {
    at::linalg_svdvals_out(r, input);
  } catch (...) {  // 捕获任何可能的异常
  }
}

// 定义函数 nnc_aten_linalg_solve，接收多个参数来执行线性方程组求解操作
static void nnc_aten_linalg_solve(
    int64_t bufs_num,             // 输入的缓冲区数量
    void** buf_data,              // 缓冲区数据的指针数组
    int64_t* buf_ranks,           // 缓冲区的秩数组
    int64_t* buf_dims,            // 缓冲区的维度数组
    int64_t* buf_strides,         // 缓冲区的步长数组
    int8_t* buf_dtypes,           // 缓冲区的数据类型数组
    int64_t args_num,             // 额外参数的数量
    int64_t* extra_args) {        // 额外参数数组
  // 根据传入的缓冲区数据，构建张量向量
  std::vector<at::Tensor> tensors = constructTensors(
      bufs_num, buf_data, buf_ranks, buf_dims, buf_strides, buf_dtypes);
  // 引用求解结果张量 r，以及输入张量 input 和 other
  at::Tensor& r = tensors[0];
  const at::Tensor& input = tensors[1];
  const at::Tensor& other = tensors[2];
  // 尝试执行线性方程组求解操作，并将结果保存在 r 中
  try {
    at::linalg_solve_out(r, input, other, true);
  } catch (...) {  // 捕获任何可能的异常
  }
}

#ifndef C10_MOBILE
// 注册外部函数 nnc_aten_abs 到名为 nnc_abs 的注册表
const static RegisterNNCExternalFunction nnc_abs("nnc_aten_abs", nnc_aten_abs);
// 注册外部函数 nnc_aten_absolute 到名为 nnc_absolute 的注册表
const static RegisterNNCExternalFunction nnc_absolute(
    "nnc_aten_absolute",
    nnc_aten_absolute);
// 注册外部函数 nnc_aten_angle 到名为 nnc_angle 的注册表
const static RegisterNNCExternalFunction nnc_angle(
    "nnc_aten_angle",
    nnc_aten_angle);
// 注册外部函数 nnc_aten_sgn 到名为 nnc_sgn 的注册表
const static RegisterNNCExternalFunction nnc_sgn("nnc_aten_sgn", nnc_aten_sgn);
#endif
const static RegisterNNCExternalFunction nnc_acos(
    "nnc_aten_acos",
    nnc_aten_acos);
// 注册 nnc_aten_acos 函数为 nnc_acos 外部函数

const static RegisterNNCExternalFunction nnc_arccos(
    "nnc_aten_arccos",
    nnc_aten_arccos);
// 注册 nnc_aten_arccos 函数为 nnc_arccos 外部函数

const static RegisterNNCExternalFunction nnc_acosh(
    "nnc_aten_acosh",
    nnc_aten_acosh);
// 注册 nnc_aten_acosh 函数为 nnc_acosh 外部函数

const static RegisterNNCExternalFunction nnc_arccosh(
    "nnc_aten_arccosh",
    nnc_aten_arccosh);
// 注册 nnc_aten_arccosh 函数为 nnc_arccosh 外部函数

const static RegisterNNCExternalFunction nnc_asinh(
    "nnc_aten_asinh",
    nnc_aten_asinh);
// 注册 nnc_aten_asinh 函数为 nnc_asinh 外部函数

const static RegisterNNCExternalFunction nnc_arcsinh(
    "nnc_aten_arcsinh",
    nnc_aten_arcsinh);
// 注册 nnc_aten_arcsinh 函数为 nnc_arcsinh 外部函数

const static RegisterNNCExternalFunction nnc_atanh(
    "nnc_aten_atanh",
    nnc_aten_atanh);
// 注册 nnc_aten_atanh 函数为 nnc_atanh 外部函数

const static RegisterNNCExternalFunction nnc_arctanh(
    "nnc_aten_arctanh",
    nnc_aten_arctanh);
// 注册 nnc_aten_arctanh 函数为 nnc_arctanh 外部函数

const static RegisterNNCExternalFunction nnc_asin(
    "nnc_aten_asin",
    nnc_aten_asin);
// 注册 nnc_aten_asin 函数为 nnc_asin 外部函数

const static RegisterNNCExternalFunction nnc_arcsin(
    "nnc_aten_arcsin",
    nnc_aten_arcsin);
// 注册 nnc_aten_arcsin 函数为 nnc_arcsin 外部函数

const static RegisterNNCExternalFunction nnc_atan(
    "nnc_aten_atan",
    nnc_aten_atan);
// 注册 nnc_aten_atan 函数为 nnc_atan 外部函数

const static RegisterNNCExternalFunction nnc_arctan(
    "nnc_aten_arctan",
    nnc_aten_arctan);
// 注册 nnc_aten_arctan 函数为 nnc_arctan 外部函数

const static RegisterNNCExternalFunction nnc_bitwise_not(
    "nnc_aten_bitwise_not",
    nnc_aten_bitwise_not);
// 注册 nnc_aten_bitwise_not 函数为 nnc_bitwise_not 外部函数

const static RegisterNNCExternalFunction nnc_copysign(
    "nnc_aten_copysign",
    nnc_aten_copysign);
// 注册 nnc_aten_copysign 函数为 nnc_copysign 外部函数

const static RegisterNNCExternalFunction nnc_logical_not(
    "nnc_aten_logical_not",
    nnc_aten_logical_not);
// 注册 nnc_aten_logical_not 函数为 nnc_logical_not 外部函数

const static RegisterNNCExternalFunction nnc_logical_xor(
    "nnc_aten_logical_xor",
    nnc_aten_logical_xor);
// 注册 nnc_aten_logical_xor 函数为 nnc_logical_xor 外部函数

const static RegisterNNCExternalFunction nnc_logical_and(
    "nnc_aten_logical_and",
    nnc_aten_logical_and);
// 注册 nnc_aten_logical_and 函数为 nnc_logical_and 外部函数

const static RegisterNNCExternalFunction nnc_logical_or(
    "nnc_aten_logical_or",
    nnc_aten_logical_or);
// 注册 nnc_aten_logical_or 函数为 nnc_logical_or 外部函数

const static RegisterNNCExternalFunction nnc_bmm("nnc_aten_bmm", nnc_aten_bmm);
// 注册 nnc_aten_bmm 函数为 nnc_bmm 外部函数

const static RegisterNNCExternalFunction nnc_ceil(
    "nnc_aten_ceil",
    nnc_aten_ceil);
// 注册 nnc_aten_ceil 函数为 nnc_ceil 外部函数

const static RegisterNNCExternalFunction nnc_clamp_max(
    "nnc_aten_clamp_max",
    nnc_aten_clamp_max);
// 注册 nnc_aten_clamp_max 函数为 nnc_clamp_max 外部函数

const static RegisterNNCExternalFunction nnc_clamp_min(
    "nnc_aten_clamp_min",
    nnc_aten_clamp_min);
// 注册 nnc_aten_clamp_min 函数为 nnc_clamp_min 外部函数

const static RegisterNNCExternalFunction nnc_complex(
    "nnc_aten_complex",
    nnc_aten_complex);
// 注册 nnc_aten_complex 函数为 nnc_complex 外部函数

const static RegisterNNCExternalFunction nnc_polar(
    "nnc_aten_polar",
    nnc_aten_polar);
// 注册 nnc_aten_polar 函数为 nnc_polar 外部函数

const static RegisterNNCExternalFunction nnc_cos("nnc_aten_cos", nnc_aten_cos);
// 注册 nnc_aten_cos 函数为 nnc_cos 外部函数

const static RegisterNNCExternalFunction nnc_cosh(
    "nnc_aten_cosh",
    nnc_aten_cosh);
// 注册 nnc_aten_cosh 函数为 nnc_cosh 外部函数

const static RegisterNNCExternalFunction nnc_div("nnc_aten_div", nnc_aten_div);
// 注册 nnc_aten_div 函数为 nnc_div 外部函数

const static RegisterNNCExternalFunction nnc_divide(
    "nnc_aten_divide",
    nnc_aten_divide);
// 注册 nnc_aten_divide 函数为 nnc_divide 外部函数

const static RegisterNNCExternalFunction nnc_true_divide(
    "nnc_aten_true_divide",
    nnc_aten_true_divide);
// 注册 nnc_aten_true_divide 函数为 nnc_true_divide 外部函数

const static RegisterNNCExternalFunction nnc_dot("nnc_aten_dot", nnc_aten_dot);
// 注册 nnc_aten_dot 函数为 nnc_dot 外部函数

const static RegisterNNCExternalFunction nnc_vdot(
    "nnc_aten_vdot",  # 字符串："nnc_aten_vdot"，可能是某种标识符或键名
    nnc_aten_vdot);   # 变量或函数调用：nnc_aten_vdot，可能是一个函数或变量的调用或引用
# 注册自定义的NNC外部函数'nnc_aten_erf'，名为'nnc_erf'
const static RegisterNNCExternalFunction nnc_erf("nnc_aten_erf", nnc_aten_erf);

# 注册自定义的NNC外部函数'nnc_aten_erfc'，名为'nnc_erfc'
const static RegisterNNCExternalFunction nnc_erfc(
    "nnc_aten_erfc",
    nnc_aten_erfc);

# 注册自定义的NNC外部函数'nnc_aten_exp'，名为'nnc_exp'
const static RegisterNNCExternalFunction nnc_exp("nnc_aten_exp", nnc_aten_exp);

# 注册自定义的NNC外部函数'nnc_aten_exp2'，名为'nnc_exp2'
const static RegisterNNCExternalFunction nnc_exp2(
    "nnc_aten_exp2",
    nnc_aten_exp2);

# 注册自定义的NNC外部函数'nnc_aten_expm1'，名为'nnc_expm1'
const static RegisterNNCExternalFunction nnc_expm1(
    "nnc_aten_expm1",
    nnc_aten_expm1);

# 注册自定义的NNC外部函数'nnc_aten_floor'，名为'nnc_floor'
const static RegisterNNCExternalFunction nnc_floor(
    "nnc_aten_floor",
    nnc_aten_floor);

# 注册自定义的NNC外部函数'nnc_aten_floor_divide'，名为'nnc_floor_divide'
const static RegisterNNCExternalFunction nnc_floor_divide(
    "nnc_aten_floor_divide",
    nnc_aten_floor_divide);

# 注册自定义的NNC外部函数'nnc_aten_frac'，名为'nnc_frac'
const static RegisterNNCExternalFunction nnc_frac(
    "nnc_aten_frac",
    nnc_aten_frac);

# 注册自定义的NNC外部函数'nnc_aten_gcd'，名为'nnc_gcd'
const static RegisterNNCExternalFunction nnc_gcd("nnc_aten_gcd", nnc_aten_gcd);

# 注册自定义的NNC外部函数'nnc_aten_lcm'，名为'nnc_lcm'
const static RegisterNNCExternalFunction nnc_lcm("nnc_aten_lcm", nnc_aten_lcm);

# 注册自定义的NNC外部函数'nnc_aten_inverse'，名为'nnc_inverse'
const static RegisterNNCExternalFunction nnc_inverse(
    "nnc_aten_inverse",
    nnc_aten_inverse);

# 注册自定义的NNC外部函数'nnc_aten_kron'，名为'nnc_kron'
const static RegisterNNCExternalFunction nnc_kron(
    "nnc_aten_kron",
    nnc_aten_kron);

# 注册自定义的NNC外部函数'nnc_aten_ldexp'，名为'nnc_ldexp'
const static RegisterNNCExternalFunction nnc_ldexp(
    "nnc_aten_ldexp",
    nnc_aten_ldexp);

# 注册自定义的NNC外部函数'nnc_aten_log'，名为'nnc_log'
const static RegisterNNCExternalFunction nnc_log("nnc_aten_log", nnc_aten_log);

# 注册自定义的NNC外部函数'nnc_aten_log10'，名为'nnc_log10'
const static RegisterNNCExternalFunction nnc_log10(
    "nnc_aten_log10",
    nnc_aten_log10);

# 注册自定义的NNC外部函数'nnc_aten_log1p'，名为'nnc_log1p'
const static RegisterNNCExternalFunction nnc_log1p(
    "nnc_aten_log1p",
    nnc_aten_log1p);

# 注册自定义的NNC外部函数'nnc_aten_log2'，名为'nnc_log2'
const static RegisterNNCExternalFunction nnc_log2(
    "nnc_aten_log2",
    nnc_aten_log2);

# 注册自定义的NNC外部函数'nnc_aten_logaddexp'，名为'nnc_logaddexp'
const static RegisterNNCExternalFunction nnc_logaddexp(
    "nnc_aten_logaddexp",
    nnc_aten_logaddexp);

# 注册自定义的NNC外部函数'nnc_aten_logaddexp2'，名为'nnc_logaddexp2'
const static RegisterNNCExternalFunction nnc_logaddexp2(
    "nnc_aten_logaddexp2",
    nnc_aten_logaddexp2);

# 注册自定义的NNC外部函数'nnc_aten_xlogy'，名为'nnc_xlogy'
const static RegisterNNCExternalFunction nnc_xlogy(
    "nnc_aten_xlogy",
    nnc_aten_xlogy);

# 注册自定义的NNC外部函数'nnc_aten_matmul'，名为'nnc_matmul'
const static RegisterNNCExternalFunction nnc_matmul(
    "nnc_aten_matmul",
    nnc_aten_matmul);

# 注册自定义的NNC外部函数'nnc_aten__compute_linear_combination'，名为'nnc__compute_linear_combination'
const static RegisterNNCExternalFunction nnc__compute_linear_combination(
    "nnc_aten__compute_linear_combination",
    nnc_aten__compute_linear_combination);

# 注册自定义的NNC外部函数'nnc_aten_mm'，名为'nnc_mm'
const static RegisterNNCExternalFunction nnc_mm("nnc_aten_mm", nnc_aten_mm);

# 注册自定义的NNC外部函数'nnc_aten_mul'，名为'nnc_mul'
const static RegisterNNCExternalFunction nnc_mul("nnc_aten_mul", nnc_aten_mul);

# 注册自定义的NNC外部函数'nnc_aten_multiply'，名为'nnc_multiply'
const static RegisterNNCExternalFunction nnc_multiply(
    "nnc_aten_multiply",
    nnc_aten_multiply);

# 注册自定义的NNC外部函数'nnc_aten_mv'，名为'nnc_mv'
const static RegisterNNCExternalFunction nnc_mv("nnc_aten_mv", nnc_aten_mv);

# 注册自定义的NNC外部函数'nnc_aten_rad2deg'，名为'nnc_rad2deg'
const static RegisterNNCExternalFunction nnc_rad2deg(
    "nnc_aten_rad2deg",
    nnc_aten_rad2deg);

# 注册自定义的NNC外部函数'nnc_aten_deg2rad'，名为'nnc_deg2rad'
const static RegisterNNCExternalFunction nnc_deg2rad(
    "nnc_aten_deg2rad",
    nnc_aten_deg2rad);

# 注册自定义的NNC外部函数'nnc_aten_reciprocal'，名为'nnc_reciprocal'
const static RegisterNNCExternalFunction nnc_reciprocal(
    "nnc_aten_reciprocal",
    nnc_aten_reciprocal);

# 注册自定义的NNC外部函数'nnc_aten_neg'，名为'nnc_neg'
const static RegisterNNCExternalFunction nnc_neg("nnc_aten_neg", nnc_aten_neg);

# 注册自定义的NNC外部函数'nnc_aten_negative'，名为'nnc_negative'
const static RegisterNNCExternalFunction nnc_negative(
    "nnc_aten_negative",
    nnc_aten_negative);
// 注册名为 nnc_aten_round 的 NNCompiler 外部函数，名称为 "nnc_aten_round"，函数指针为 nnc_aten_round
const static RegisterNNCExternalFunction nnc_round(
    "nnc_aten_round",
    nnc_aten_round);

// 注册名为 nnc_aten_rsqrt 的 NNCompiler 外部函数，名称为 "nnc_aten_rsqrt"，函数指针为 nnc_aten_rsqrt
const static RegisterNNCExternalFunction nnc_rsqrt(
    "nnc_aten_rsqrt",
    nnc_aten_rsqrt);

// 注册名为 nnc_aten_silu 的 NNCompiler 外部函数，名称为 "nnc_aten_silu"，函数指针为 nnc_aten_silu
const static RegisterNNCExternalFunction nnc_silu(
    "nnc_aten_silu",
    nnc_aten_silu);

// 注册名为 nnc_aten_mish 的 NNCompiler 外部函数，名称为 "nnc_aten_mish"，函数指针为 nnc_aten_mish
const static RegisterNNCExternalFunction nnc_mish(
    "nnc_aten_mish",
    nnc_aten_mish);

// 注册名为 nnc_aten_sigmoid 的 NNCompiler 外部函数，名称为 "nnc_aten_sigmoid"，函数指针为 nnc_aten_sigmoid
const static RegisterNNCExternalFunction nnc_sigmoid(
    "nnc_aten_sigmoid",
    nnc_aten_sigmoid);

// 注册名为 nnc_aten_sin 的 NNCompiler 外部函数，名称为 "nnc_aten_sin"，函数指针为 nnc_aten_sin
const static RegisterNNCExternalFunction nnc_sin("nnc_aten_sin", nnc_aten_sin);

// 注册名为 nnc_aten_sinc 的 NNCompiler 外部函数，名称为 "nnc_aten_sinc"，函数指针为 nnc_aten_sinc
const static RegisterNNCExternalFunction nnc_sinc(
    "nnc_aten_sinc",
    nnc_aten_sinc);

// 注册名为 nnc_aten_sinh 的 NNCompiler 外部函数，名称为 "nnc_aten_sinh"，函数指针为 nnc_aten_sinh
const static RegisterNNCExternalFunction nnc_sinh(
    "nnc_aten_sinh",
    nnc_aten_sinh);

// 注册名为 nnc_aten_sqrt 的 NNCompiler 外部函数，名称为 "nnc_aten_sqrt"，函数指针为 nnc_aten_sqrt
const static RegisterNNCExternalFunction nnc_sqrt(
    "nnc_aten_sqrt",
    nnc_aten_sqrt);

// 注册名为 nnc_aten_square 的 NNCompiler 外部函数，名称为 "nnc_aten_square"，函数指针为 nnc_aten_square
const static RegisterNNCExternalFunction nnc_square(
    "nnc_aten_square",
    nnc_aten_square);

// 注册名为 nnc_aten_tan 的 NNCompiler 外部函数，名称为 "nnc_aten_tan"，函数指针为 nnc_aten_tan
const static RegisterNNCExternalFunction nnc_tan("nnc_aten_tan", nnc_aten_tan);

// 注册名为 nnc_aten_tanh 的 NNCompiler 外部函数，名称为 "nnc_aten_tanh"，函数指针为 nnc_aten_tanh
const static RegisterNNCExternalFunction nnc_tanh(
    "nnc_aten_tanh",
    nnc_aten_tanh);

// 注册名为 nnc_aten_trunc 的 NNCompiler 外部函数，名称为 "nnc_aten_trunc"，函数指针为 nnc_aten_trunc
const static RegisterNNCExternalFunction nnc_trunc(
    "nnc_aten_trunc",
    nnc_aten_trunc);

// 注册名为 nnc_aten_fix 的 NNCompiler 外部函数，名称为 "nnc_aten_fix"，函数指针为 nnc_aten_fix
const static RegisterNNCExternalFunction nnc_fix("nnc_aten_fix", nnc_aten_fix);

// 注册名为 nnc_aten_heaviside 的 NNCompiler 外部函数，名称为 "nnc_aten_heaviside"，函数指针为 nnc_aten_heaviside
const static RegisterNNCExternalFunction nnc_heaviside(
    "nnc_aten_heaviside",
    nnc_aten_heaviside);

// 注册名为 nnc_aten_hspmm 的 NNCompiler 外部函数，名称为 "nnc_aten_hspmm"，函数指针为 nnc_aten_hspmm
const static RegisterNNCExternalFunction nnc_hspmm(
    "nnc_aten_hspmm",
    nnc_aten_hspmm);

// 注册名为 nnc_aten_bitwise_and 的 NNCompiler 外部函数，名称为 "nnc_aten_bitwise_and"，函数指针为 nnc_aten_bitwise_and
const static RegisterNNCExternalFunction nnc_bitwise_and(
    "nnc_aten_bitwise_and",
    nnc_aten_bitwise_and);

// 注册名为 nnc_aten_bitwise_or 的 NNCompiler 外部函数，名称为 "nnc_aten_bitwise_or"，函数指针为 nnc_aten_bitwise_or
const static RegisterNNCExternalFunction nnc_bitwise_or(
    "nnc_aten_bitwise_or",
    nnc_aten_bitwise_or);

// 注册名为 nnc_aten_bitwise_xor 的 NNCompiler 外部函数，名称为 "nnc_aten_bitwise_xor"，函数指针为 nnc_aten_bitwise_xor
const static RegisterNNCExternalFunction nnc_bitwise_xor(
    "nnc_aten_bitwise_xor",
    nnc_aten_bitwise_xor);

// 注册名为 nnc_aten_ne 的 NNCompiler 外部函数，名称为 "nnc_aten_ne"，函数指针为 nnc_aten_ne
const static RegisterNNCExternalFunction nnc_ne("nnc_aten_ne", nnc_aten_ne);

// 注册名为 nnc_aten_not_equal 的 NNCompiler 外部函数，名称为 "nnc_aten_not_equal"，函数指针为 nnc_aten_not_equal
const static RegisterNNCExternalFunction nnc_not_equal(
    "nnc_aten_not_equal",
    nnc_aten_not_equal);

// 注册名为 nnc_aten_eq 的 NNCompiler 外部函数，名称为 "nnc_aten_eq"，函数指针为 nnc_aten_eq
const static RegisterNNCExternalFunction nnc_eq("nnc_aten_eq", nnc_aten_eq);

// 注册名为 nnc_aten_ge 的 NNCompiler 外部函数，名称为 "nnc_aten_ge"，函数指针为 nnc_aten_ge
const static RegisterNNCExternalFunction nnc_ge("nnc_aten_ge", nnc_aten_ge);

// 注册名为 nnc_aten_greater_equal 的 NNCompiler 外部函数，名称为 "nnc_aten_greater_equal"，函数指针为 nnc_aten_greater_equal
const static RegisterNNCExternalFunction nnc_greater_equal(
    "nnc_aten_greater_equal",
    nnc_aten_greater_equal);

// 注册名为 nnc_aten_le 的 NNCompiler 外部函数，名称为 "nnc_aten_le"，函数指针为 nnc_aten_le
const static RegisterNNCExternalFunction nnc_le("nnc_aten_le", nnc_aten_le);

// 注册名为 nnc_aten_less_equal 的 NNCompiler 外部函数，名称为 "nnc_aten_less_equal"，函数指针为 nnc_aten_less_equal
const static RegisterNNCExternalFunction nnc_less_equal(
    "nnc_aten_less_equal",
    nnc_aten_less_equal);

// 注册名为 nnc_aten_gt 的 NNCompiler 外部函数，名称为 "nnc_aten_gt"，函数指针为 nnc_aten_gt
const static RegisterNNCExternalFunction nnc_gt("nnc_aten_gt", nnc_aten_gt);

// 注册名为 nnc_aten_greater 的 NNCompiler 外部函数，名称为 "nnc_aten_greater"，函数指针为 nnc_aten_greater
const static RegisterNNCExternalFunction nnc_greater(
    "nnc_aten_greater",
    nnc_aten_greater);

// 注册名为 nnc_aten_lt 的 NNCompiler 外部函数，名称为 "nnc_aten_lt"，函数指针为 nnc_aten_lt
const static RegisterNNCExternalFunction nnc_lt("nnc_aten_lt", nnc_aten_lt);

// 注册名为 nnc_aten_less 的 NNCompiler 外部函数，名称为 "nnc_aten_less"，函数指针为 nnc_aten_less
const static RegisterNNCExternalFunction nnc
    nnc_aten_masked_select);
const static RegisterNNCExternalFunction nnc_nonzero(
    "nnc_aten_nonzero",     // 注册NNC外部函数'nnc_aten_nonzero'，用于非零值检测
    nnc_aten_nonzero);      // 将'nnc_aten_nonzero'函数注册到nnc_nonzero中

const static RegisterNNCExternalFunction nnc_orgqr(
    "nnc_aten_orgqr",       // 注册NNC外部函数'nnc_aten_orgqr'，用于QR分解
    nnc_aten_orgqr);        // 将'nnc_aten_orgqr'函数注册到nnc_orgqr中

const static RegisterNNCExternalFunction nnc_lu_solve(
    "nnc_aten_lu_solve",    // 注册NNC外部函数'nnc_aten_lu_solve'，用于LU分解求解线性方程组
    nnc_aten_lu_solve);     // 将'nnc_aten_lu_solve'函数注册到nnc_lu_solve中

const static RegisterNNCExternalFunction nnc_lgamma(
    "nnc_aten_lgamma",      // 注册NNC外部函数'nnc_aten_lgamma'，用于计算对数Gamma函数
    nnc_aten_lgamma);       // 将'nnc_aten_lgamma'函数注册到nnc_lgamma中

const static RegisterNNCExternalFunction nnc_digamma(
    "nnc_aten_digamma",     // 注册NNC外部函数'nnc_aten_digamma'，用于计算二阶狄伽马函数
    nnc_aten_digamma);      // 将'nnc_aten_digamma'函数注册到nnc_digamma中

const static RegisterNNCExternalFunction nnc_erfinv(
    "nnc_aten_erfinv",      // 注册NNC外部函数'nnc_aten_erfinv'，用于逆误差函数
    nnc_aten_erfinv);       // 将'nnc_aten_erfinv'函数注册到nnc_erfinv中

const static RegisterNNCExternalFunction nnc_i0(
    "nnc_aten_i0",          // 注册NNC外部函数'nnc_aten_i0'，用于修正零阶贝塞尔函数
    nnc_aten_i0);           // 将'nnc_aten_i0'函数注册到nnc_i0中

const static RegisterNNCExternalFunction nnc_sign(
    "nnc_aten_sign",        // 注册NNC外部函数'nnc_aten_sign'，用于获取数值的符号
    nnc_aten_sign);         // 将'nnc_aten_sign'函数注册到nnc_sign中

const static RegisterNNCExternalFunction nnc_signbit(
    "nnc_aten_signbit",     // 注册NNC外部函数'nnc_aten_signbit'，用于判断数值的符号位
    nnc_aten_signbit);      // 将'nnc_aten_signbit'函数注册到nnc_signbit中

const static RegisterNNCExternalFunction nnc_atan2(
    "nnc_aten_atan2",       // 注册NNC外部函数'nnc_aten_atan2'，用于计算反正切值
    nnc_aten_atan2);        // 将'nnc_aten_atan2'函数注册到nnc_atan2中

const static RegisterNNCExternalFunction nnc_lerp(
    "nnc_aten_lerp",        // 注册NNC外部函数'nnc_aten_lerp'，用于线性插值
    nnc_aten_lerp);         // 将'nnc_aten_lerp'函数注册到nnc_lerp中

const static RegisterNNCExternalFunction nnc_fmod(
    "nnc_aten_fmod",        // 注册NNC外部函数'nnc_aten_fmod'，用于浮点取模运算
    nnc_aten_fmod);         // 将'nnc_aten_fmod'函数注册到nnc_fmod中

const static RegisterNNCExternalFunction nnc_hypot(
    "nnc_aten_hypot",       // 注册NNC外部函数'nnc_aten_hypot'，用于计算两个数的平方和的平方根
    nnc_aten_hypot);        // 将'nnc_aten_hypot'函数注册到nnc_hypot中

const static RegisterNNCExternalFunction nnc_igamma(
    "nnc_aten_igamma",      // 注册NNC外部函数'nnc_aten_igamma'，用于不完全Gamma函数
    nnc_aten_igamma);       // 将'nnc_aten_igamma'函数注册到nnc_igamma中

const static RegisterNNCExternalFunction nnc_igammac(
    "nnc_aten_igammac",     // 注册NNC外部函数'nnc_aten_igammac'，用于不完全Gamma补函数
    nnc_aten_igammac);      // 将'nnc_aten_igammac'函数注册到nnc_igammac中

const static RegisterNNCExternalFunction nnc_nextafter(
    "nnc_aten_nextafter",   // 注册NNC外部函数'nnc_aten_nextafter'，用于返回相邻浮点数
    nnc_aten_nextafter);    // 将'nnc_aten_nextafter'函数注册到nnc_nextafter中

const static RegisterNNCExternalFunction nnc_remainder(
    "nnc_aten_remainder",   // 注册NNC外部函数'nnc_aten_remainder'，用于求余数
    nnc_aten_remainder);    // 将'nnc_aten_remainder'函数注册到nnc_remainder中

const static RegisterNNCExternalFunction nnc_fmin(
    "nnc_aten_fmin",        // 注册NNC外部函数'nnc_aten_fmin'，用于获取两个数的最小值
    nnc_aten_fmin);         // 将'nnc_aten_fmin'函数注册到nnc_fmin中

const static RegisterNNCExternalFunction nnc_fmax(
    "nnc_aten_fmax",        // 注册NNC外部函数'nnc_aten_fmax'，用于获取两个数的最大值
    nnc_aten_fmax);         // 将'nnc_aten_fmax'函数注册到nnc_fmax中

const static RegisterNNCExternalFunction nnc_maximum(
    "nnc_aten_maximum",     // 注册NNC外部函数'nnc_aten_maximum'，用于获取两个数或张量的最大值
    nnc_aten_maximum);      // 将'nnc_aten_maximum'函数注册到nnc_maximum中

const static RegisterNNCExternalFunction nnc_max(
    "nnc_aten_max",         // 注册NNC外部函数'nnc_aten_max'，用于获取张量的最大值
    nnc_aten_max);          // 将'nnc_aten_max'函数注册到nnc_max中

const static RegisterNNCExternalFunction nnc_minimum(
    "nnc_aten_minimum",     // 注册NNC外部函数'nnc_aten_minimum'，用于获取两个数或张量的最小值
    nnc_aten_minimum);      // 将'nnc_aten_minimum'函数注册到nnc_minimum中

const static RegisterNNCExternalFunction nnc_min(
    "nnc_aten_min",         // 注册NNC外部函数'nnc_aten_min'，用于获取张量的最小值
    nnc_aten_min);          // 将'nnc_aten_min'函数注册到nnc_min中

const static RegisterNNCExternalFunction nnc_msort(
    "nnc_aten_msort",       // 注册NNC外部函数'nnc_aten_msort'，用于张量的排序
    nnc_aten_msort);        // 将'nnc_aten_msort'函数注册到nnc_msort中

const static RegisterNNCExternalFunction nnc_pow(
    "nnc_aten_pow",         // 注册NNC外部函数'nnc_aten_pow'，用于幂运算
    nnc_aten_pow);          // 将'nnc_aten_pow'函数注册到nnc_pow中

const static RegisterNNCExternalFunction nnc_float_power(
    "nnc_aten_float_power", // 注册NNC外部函数'nnc_aten_float_power'，用于浮点数幂运算
    nnc_aten_float_power);  // 将'nnc_aten_float_power'函数注册到nnc_float_power中

const static RegisterNNCExternalFunction nnc_hardsigmoid(
    "nnc_aten_hardsigmoid", // 注册NNC外部函数'nnc_aten_hardsigmoid'，用于硬S
const static RegisterNNCExternalFunction nnc_adaptive_avg_pool3d_backward(
    "nnc_aten_adaptive_avg_pool3d_backward",
    nnc_aten_adaptive_avg_pool3d_backward);
// 注册自定义的外部函数 nnc_aten_adaptive_avg_pool3d_backward 到 nnc_adaptive_avg_pool3d_backward

const static RegisterNNCExternalFunction nnc_adaptive_max_pool2d_backward(
    "nnc_aten_adaptive_max_pool2d_backward",
    nnc_aten_adaptive_max_pool2d_backward);
// 注册自定义的外部函数 nnc_aten_adaptive_max_pool2d_backward 到 nnc_adaptive_max_pool2d_backward

const static RegisterNNCExternalFunction nnc_adaptive_max_pool3d_backward(
    "nnc_aten_adaptive_max_pool3d_backward",
    nnc_aten_adaptive_max_pool3d_backward);
// 注册自定义的外部函数 nnc_aten_adaptive_max_pool3d_backward 到 nnc_adaptive_max_pool3d_backward

const static RegisterNNCExternalFunction nnc_sigmoid_backward(
    "nnc_aten_sigmoid_backward",
    nnc_aten_sigmoid_backward);
// 注册自定义的外部函数 nnc_aten_sigmoid_backward 到 nnc_sigmoid_backward

const static RegisterNNCExternalFunction nnc_tanh_backward(
    "nnc_aten_tanh_backward",
    nnc_aten_tanh_backward);
// 注册自定义的外部函数 nnc_aten_tanh_backward 到 nnc_tanh_backward

const static RegisterNNCExternalFunction nnc_isposinf(
    "nnc_aten_isposinf",
    nnc_aten_isposinf);
// 注册自定义的外部函数 nnc_aten_isposinf 到 nnc_isposinf

const static RegisterNNCExternalFunction nnc_isneginf(
    "nnc_aten_isneginf",
    nnc_aten_isneginf);
// 注册自定义的外部函数 nnc_aten_isneginf 到 nnc_isneginf

const static RegisterNNCExternalFunction nnc_special_entr(
    "nnc_aten_special_entr",
    nnc_aten_special_entr);
// 注册自定义的外部函数 nnc_aten_special_entr 到 nnc_special_entr

const static RegisterNNCExternalFunction nnc_special_expm1(
    "nnc_aten_special_expm1",
    nnc_aten_special_expm1);
// 注册自定义的外部函数 nnc_aten_special_expm1 到 nnc_special_expm1

const static RegisterNNCExternalFunction nnc_special_exp2(
    "nnc_aten_special_exp2",
    nnc_aten_special_exp2);
// 注册自定义的外部函数 nnc_aten_special_exp2 到 nnc_special_exp2

const static RegisterNNCExternalFunction nnc_special_gammaln(
    "nnc_aten_special_gammaln",
    nnc_aten_special_gammaln);
// 注册自定义的外部函数 nnc_aten_special_gammaln 到 nnc_special_gammaln

const static RegisterNNCExternalFunction nnc_special_erf(
    "nnc_aten_special_erf",
    nnc_aten_special_erf);
// 注册自定义的外部函数 nnc_aten_special_erf 到 nnc_special_erf

const static RegisterNNCExternalFunction nnc_special_erfc(
    "nnc_aten_special_erfc",
    nnc_aten_special_erfc);
// 注册自定义的外部函数 nnc_aten_special_erfc 到 nnc_special_erfc

const static RegisterNNCExternalFunction nnc_special_erfinv(
    "nnc_aten_special_erfinv",
    nnc_aten_special_erfinv);
// 注册自定义的外部函数 nnc_aten_special_erfinv 到 nnc_special_erfinv

const static RegisterNNCExternalFunction nnc_special_xlog1py(
    "nnc_aten_special_xlog1py",
    nnc_aten_special_xlog1py);
// 注册自定义的外部函数 nnc_aten_special_xlog1py 到 nnc_special_xlog1py

const static RegisterNNCExternalFunction nnc_special_i0e(
    "nnc_aten_special_i0e",
    nnc_aten_special_i0e);
// 注册自定义的外部函数 nnc_aten_special_i0e 到 nnc_special_i0e

const static RegisterNNCExternalFunction nnc_special_expit(
    "nnc_aten_special_expit",
    nnc_aten_special_expit);
// 注册自定义的外部函数 nnc_aten_special_expit 到 nnc_special_expit

const static RegisterNNCExternalFunction nnc_linalg_cholesky(
    "nnc_aten_linalg_cholesky",
    nnc_aten_linalg_cholesky);
// 注册自定义的外部函数 nnc_aten_linalg_cholesky 到 nnc_linalg_cholesky

const static RegisterNNCExternalFunction nnc_linalg_det(
    "nnc_aten_linalg_det",
    nnc_aten_linalg_det);
// 注册自定义的外部函数 nnc_aten_linalg_det 到 nnc_linalg_det

const static RegisterNNCExternalFunction nnc_linalg_eigvals(
    "nnc_aten_linalg_eigvals",
    nnc_aten_linalg_eigvals);
// 注册自定义的外部函数 nnc_aten_linalg_eigvals 到 nnc_linalg_eigvals

const static RegisterNNCExternalFunction nnc_linalg_householder_product(
    "nnc_aten_linalg_householder_product",
    nnc_aten_linalg_householder_product);
// 注册自定义的外部函数 nnc_aten_linalg_householder_product 到 nnc_linalg_householder_product

const static RegisterNNCExternalFunction nnc_linalg_inv(
    "nnc_aten_linalg_inv",
    nnc_aten_linalg_inv);
// 注册自定义的外部函数 nnc_aten_linalg_inv 到 nnc_linalg_inv

const static RegisterNNCExternalFunction nnc_inner(
    "nnc_aten_inner",
    nnc_aten_inner);
// 注册自定义的外部函数 nnc_aten_inner 到 nnc_inner

const static RegisterNNCExternalFunction nnc_outer(
    "nnc_aten_outer",
    nnc_aten_outer);
// 注册自定义的外部函数 nnc_aten_outer 到 nnc_outer
# 注册一个名为 nnc_ger 的外部函数，将 nnc_aten_ger 作为其实现
const static RegisterNNCExternalFunction nnc_ger("nnc_aten_ger", nnc_aten_ger);

# 注册一个名为 nnc_linalg_svdvals 的外部函数，将 nnc_aten_linalg_svdvals 作为其实现
const static RegisterNNCExternalFunction nnc_linalg_svdvals(
    "nnc_aten_linalg_svdvals",
    nnc_aten_linalg_svdvals);

# 注册一个名为 nnc_linalg_solve 的外部函数，将 nnc_aten_linalg_solve 作为其实现
const static RegisterNNCExternalFunction nnc_linalg_solve(
    "nnc_aten_linalg_solve",
    nnc_aten_linalg_solve);

#ifdef C10_MOBILE
} // extern "C"
#endif

} // namespace torch::jit::tensorexpr
```