# `.\pytorch\torch\ao\quantization\fx\_model_report\model_report_visualizer.py`

```
# mypy: allow-untyped-defs
# 导入 PyTorch 库
import torch
# 导入类型注解相关的模块
from typing import Any, Set, Dict, List, Tuple, OrderedDict
# 导入并重命名 OrderedDict 为 OrdDict
from collections import OrderedDict as OrdDict

# 尝试导入 tabulate 库
got_tabulate = True
try:
    from tabulate import tabulate
except ImportError:
    # 如果导入失败，设置标志位为 False
    got_tabulate = False

# 尝试导入 matplotlib 库
got_matplotlib = True
try:
    import matplotlib.pyplot as plt
except ImportError:
    # 如果导入失败，设置标志位为 False
    got_matplotlib = False

class ModelReportVisualizer:
    r"""
    The ModelReportVisualizer class aims to provide users a way to visualize some of the statistics
    that were generated by the ModelReport API. However, at a higher level, the class aims to provide
    some level of visualization of statistics to PyTorch in order to make it easier to parse data and
    diagnose any potential issues with data or a specific model. With respect to the visualizations,
    the ModelReportVisualizer class currently supports several methods of visualizing data.

    Supported Visualization Methods Include:
    - Table format
    - Plot format (line graph)
    - Histogram format

    For all of the existing visualization methods, there is the option to filter data based on:
    - A module fqn prefix
    - Feature [required for the plot and histogram]

    * :attr:`generated_reports` The reports generated by the ModelReport class in the structure below
        Ensure sure that features that are the same across different report contain the same name
        Ensure that objects representing the same features are the same type / dimension (where applicable)

    Note:
        Currently, the ModelReportVisualizer class supports visualization of data generated by the
        ModelReport class. However, this structure is extensible and should allow the visualization of
        other information as long as the information is structured in the following general format:

        Report Structure
        -- module_fqn [module with attached detectors]
            |
            -- feature keys [not every detector extracts same information]
                                    [same collected info has same keys, unless can be specific to detector]


    The goal behind the class is that the generated visualizations can be used in conjunction with the generated
    report for people to get a better understanding of issues and what the fix might be. It is also just to provide
    a good visualization platform, since it might be hard to parse through the ModelReport returned dictionary as
    that grows in size.

    General Use Flow Expected
    1.) Initialize ModelReport object with reports of interest by passing in initialized detector objects
    2.) Prepare your model with prepare_fx
    3.) Call model_report.prepare_detailed_calibration on your model to add relevant observers
    4.) Callibrate your model with data
    5.) Call model_report.generate_report on your model to generate report and optionally remove added observers
    # 使用 model_report.generate_report 的输出来初始化 ModelReportVisualizer 实例
    # 通过实例可以查看数据的不同视图，并根据需要应用过滤器
    # 可以查看超详细信息，也可以只查看打印或显示的表格/图表/直方图

    """

    # 表格字典的键
    TABLE_TENSOR_KEY = "tensor_level_info"
    TABLE_CHANNEL_KEY = "channel_level_info"

    # 非特征张量表格的标题值的常量
    NUM_NON_FEATURE_TENSOR_HEADERS = 2
    # 非特征通道表格的标题值的常量
    NUM_NON_FEATURE_CHANNEL_HEADERS = 3

    # 表头中通道号索引的常量
    CHANNEL_NUM_INDEX = 2

    def __init__(self, generated_reports: OrderedDict[str, Any]):
        r"""
        使用生成的报告初始化 ModelReportVisualizer 实例。

        Args:
            generated_reports (Dict[str, Any]): ModelReport 类生成的报告，
                可以是以相同格式生成的字典
        """
        self.generated_reports = generated_reports

    def get_all_unique_module_fqns(self) -> Set[str]:
        r"""
        该方法的目的是提供所有模块全限定名的集合，以便用户在希望使用 ModelReportVisualizer 类的过滤能力时，
        不需要手动解析 generated_reports 字典以获取此信息。

        返回 ModelReportVisualizer 实例初始化时包含的所有报告中的唯一模块全限定名。
        """
        # 返回有序字典的键集合
        return set(self.generated_reports.keys())
    def get_all_unique_feature_names(self, plottable_features_only: bool = True) -> Set[str]:
        r"""
        The purpose of this method is to provide a user the set of all feature names so that if
        they wish to use the filtering capabilities of the generate_table_view(), or use either of
        the generate_plot_view() or generate_histogram_view(), they don't need to manually parse
        the generated_reports dictionary to get this information.

        Args:
            plottable_features_only (bool): True if the user is only looking for plottable features,
                False otherwise
                plottable features are those that are tensor values
                Default: True (only return those feature names that are plottable)

        Returns all the unique module fqns present in the reports the ModelReportVisualizer
        instance was initialized with.
        """
        unique_feature_names = set()  # 初始化一个空集合用于存放唯一的特征名称

        for module_fqn in self.generated_reports:
            # get dict of the features
            feature_dict: Dict[str, Any] = self.generated_reports[module_fqn]
            # 获取特定模块全限定名对应的特征字典

            # loop through features
            for feature_name in feature_dict:
                # if we need plottable, ensure type of val is tensor
                # 如果需要可绘制的特征，确保特征值的类型是 torch.Tensor
                if not plottable_features_only or type(feature_dict[feature_name]) == torch.Tensor:
                    unique_feature_names.add(feature_name)  # 将符合条件的特征名称添加到集合中

        # return our compiled set of unique feature names
        return unique_feature_names  # 返回包含所有唯一特征名称的集合
    def _get_filtered_data(self, feature_filter: str, module_fqn_filter: str) -> OrderedDict[str, Any]:
        r"""
        Filters the data and returns it in the same ordered dictionary format so the relevant views can be displayed.

        Args:
            feature_filter (str): The feature filter, if we want to filter the set of data to only include
                a certain set of features that include feature_filter
                If feature = "", then we do not filter based on any features
            module_fqn_filter (str): The filter on prefix for the module fqn. All modules that have fqn with
                this prefix will be included
                If module_fqn_filter = "" we do not filter based on module fqn, and include all modules

        First, the data is filtered based on module_fqn, and then filtered based on feature
        Returns an OrderedDict (sorted in order of model) mapping:
            module_fqns -> feature_names -> values
        """
        # create return dict
        filtered_dict: OrderedDict[str, Any] = OrdDict()  # 创建一个空的有序字典来存储过滤后的数据

        for module_fqn in self.generated_reports:
            # first filter based on module
            if module_fqn_filter == "" or module_fqn_filter in module_fqn:
                # create entry for module and loop through features
                filtered_dict[module_fqn] = {}  # 为当前模块创建一个空字典，用于存储其特征数据
                module_reports = self.generated_reports[module_fqn]
                for feature_name in module_reports:
                    # check if filtering on features and do so if desired
                    if feature_filter == "" or feature_filter in feature_name:
                        filtered_dict[module_fqn][feature_name] = module_reports[feature_name]
                        # 如果符合特征过滤条件，则将特征及其对应值存入当前模块的字典中

        # we have populated the filtered dict, and must return it
        # 已填充过滤后的字典，现在返回它
        return filtered_dict
        ) -> Tuple[List, List]:
        r"""
        Takes in the filtered data and features list and generates the tensor headers and table

        Currently meant to generate the headers and table for both the tensor information.

        Args:
            filtered_data (OrderedDict[str, Dict[str, Any]]): An OrderedDict (sorted in order of model) mapping:
                module_fqns -> feature_names -> values
            tensor_features (List[str]): A list of the tensor level features

        Returns a tuple with:
            A list of the headers of the tensor table
            A list of lists containing the table information row by row
            The 0th index row will contain the headers of the columns
            The rest of the rows will contain data
        """
        # now we compose the tensor information table

        # Initialize an empty list to store rows of tensor table data
        tensor_table: List[List[Any]] = []
        
        # Initialize an empty list to store headers of the tensor table
        tensor_headers: List[str] = []

        # append the table row to the table only if we have features
        if len(tensor_features) > 0:
            # now we add all the data

            # Iterate through filtered_data, where each module_fqn represents a module
            for index, module_fqn in enumerate(filtered_data):
                # we make a new row for the tensor table
                tensor_table_row = [index, module_fqn]
                
                # Iterate through tensor_features to populate table row
                for feature in tensor_features:
                    # we iterate in same order of added features

                    if feature in filtered_data[module_fqn]:
                        # add value if applicable to module
                        feature_val = filtered_data[module_fqn][feature]
                    else:
                        # add that it is not applicable
                        feature_val = "Not Applicable"

                    # if it's a tensor we want to extract val
                    if isinstance(feature_val, torch.Tensor):
                        feature_val = feature_val.item()

                    # we add to our list of values
                    tensor_table_row.append(feature_val)

                # Append the completed row to tensor_table
                tensor_table.append(tensor_table_row)

        # add row of headers of we actually have something, otherwise just empty
        if len(tensor_table) != 0:
            # Prepare tensor_headers with index, layer_fqn, and tensor_features
            tensor_headers = ["idx", "layer_fqn"] + tensor_features

        # Return tuple containing tensor_headers and tensor_table
        return (tensor_headers, tensor_table)
    def generate_channel_table(filtered_data: OrderedDict[str, Any], 
                               channel_features: List[str], 
                               num_channels: int) -> Tuple[List, List]:
        r"""
        Takes in the filtered data and features list and generates the channels headers and table
    
        Currently meant to generate the headers and table for both the channels information.
    
        Args:
            filtered_data (OrderedDict[str, Any]): An OrderedDict (sorted in order of model) mapping:
                module_fqns -> feature_names -> values
            channel_features (List[str]): A list of the channel level features
            num_channels (int): Number of channels in the channel data
    
        Returns a tuple with:
            A list of the headers of the channel table
            A list of lists containing the table information row by row
            The 0th index row will contain the headers of the columns
            The rest of the rows will contain data
        """
    
        # now we compose the table for the channel information table
        channel_table: List[List[Any]] = []
        channel_headers: List[str] = []
    
        # counter to keep track of number of entries in the channel table
        channel_table_entry_counter: int = 0
    
        if len(channel_features) > 0:
            # now we add all channel data
            for module_fqn in filtered_data:
                # we iterate over all channels
                for channel in range(num_channels):
                    # we make a new row for the channel
                    new_channel_row = [channel_table_entry_counter, module_fqn, channel]
                    for feature in channel_features:
                        if feature in filtered_data[module_fqn]:
                            # add value if applicable to module
                            feature_val = filtered_data[module_fqn][feature][channel]
                        else:
                            # add that it is not applicable
                            feature_val = "Not Applicable"
    
                        # if it's a tensor we want to extract val
                        if type(feature_val) is torch.Tensor:
                            feature_val = feature_val.item()
    
                        # add value to channel specific row
                        new_channel_row.append(feature_val)
    
                    # add to table and increment row index counter
                    channel_table.append(new_channel_row)
                    channel_table_entry_counter += 1
    
        # add row of headers if we actually have something, otherwise just empty
        if len(channel_table) != 0:
            channel_headers = ["idx", "layer_fqn", "channel"] + channel_features
    
        return (channel_headers, channel_table)
```