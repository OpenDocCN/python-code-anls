# `.\pytorch\torch\utils\_freeze.py`

```py
"""
Freeze Python packages.

Freezing makes it possible to ship arbitrary Python modules as part of a C++
library. The Python source of the module is compiled to bytecode and written
to `.c` files, to be imported by Python's built-in FrozenImporter.

In a normal Python installation, FrozenImporter is only used to bootstrap the
initialization of the import machinery. Python's importers are defined in
Python (see `_bootstrap.py` and `_bootstrap_external.py`) but need to be
retrieved before any importers are available. Freezing the module bytecode
resolves this circular dependency.

This script will freeze the Python standard library. It produces two things:
- Bytecode files: A set of `.c` that define C variables containing Python bytecode.
- Main file: A `main.c` file listing all of these modules in the right form to be
  consumed by FrozenImporter.

The library that wishes to these modules make them available to the local
Python instance by extending `PyImport_FrozenModules` appropriately (see
https://docs.python.org/3/c-api/import.html#c.PyImport_FrozenModules).
"""

# Import necessary modules
import argparse         # 导入用于解析命令行参数的模块
import functools        # 导入用于创建高阶函数的模块
import itertools        # 导入用于创建迭代器的模块
import marshal          # 导入用于序列化 Python 对象的模块
import os               # 导入操作系统相关功能的模块
import types            # 导入用于操作 Python 类型和函数的模块
from dataclasses import dataclass  # 导入用于创建数据类的装饰器
from pathlib import Path  # 导入操作路径的模块
from typing import List  # 导入用于类型注解的模块

# 定义常量，用于标记路径
PATH_MARKER = "<Generated by torch::deploy>"
# 主要的 C 头文件包含内容
MAIN_INCLUDES = """#include <Python.h>

"""

# 主文件的前缀模板
MAIN_PREFIX_TEMPLATE = """
// Compiled standard library modules. These should be appended to the existing
// `PyImport_FrozenModules` that ships with CPython.
struct _frozen {}[] = {{
"""

# 用于假的前缀模板
FAKE_PREFIX = MAIN_PREFIX_TEMPLATE.format("_PyImport_FrozenModules")

# 主文件的后缀
MAIN_SUFFIX = """\
    {0, 0, 0} /* sentinel */
};
"""

# 拒绝列表，排除部分标准库模块
DENY_LIST = [
    # Interface to unix databases
    "dbm",
    # ncurses bindings (terminal interfaces)
    "curses",
    # Tcl/Tk GUI
    "tkinter",
    "tkinter",
    # Tests for the standard library
    "test",
    "tests",
    "idle_test",
    "__phello__.foo.py",
    # importlib frozen modules. These are already baked into CPython.
    "_bootstrap.py",
    "_bootstrap_external.py",
]

# 需要生成的字节码文件数量
NUM_BYTECODE_FILES = 5


# 装饰器函数，增加消息的缩进
def indent_msg(fn):
    @functools.wraps(fn)
    def wrapper(*args, **kwargs):
        args[0].indent += 1
        ret = fn(*args, **kwargs)
        args[0].indent -= 1
        return ret

    return wrapper


# 数据类，表示冻结的模块
@dataclass
class FrozenModule:
    # 完全限定的模块名，例如 'foo.bar.baz'
    module_name: str
    # 包含字节码的 C 变量名，例如 'M_foo__bar__baz'
    c_name: str
    # C 变量的大小。如果模块是一个包，则为负数。
    size: int
    # 冻结的字节码
    bytecode: bytes


# 冻结器类，用于冻结 Python 模块
class Freezer:
    def __init__(self, verbose: bool):
        self.frozen_modules: List[FrozenModule] = []  # 初始化冻结的模块列表
        self.indent: int = 0  # 初始缩进级别
        self.verbose: bool = verbose  # 是否显示详细信息
    def msg(self, path: Path, code: str):
        # 如果不是详细模式，直接返回，不输出消息
        if not self.verbose:
            return
        # 根据缩进级别输出空格
        for i in range(self.indent):
            print("    ", end="")
        # 输出消息代码和路径
        print(f"{code} {path}")

    def write_bytecode(self, install_root):
        """
        Write the `.c` files containing the frozen bytecode.

        Shared frozen modules evenly across the files.
        """
        # 生成多个文件名，用于存储冻结的字节码
        bytecode_file_names = [f"bytecode_{i}.c" for i in range(NUM_BYTECODE_FILES)]
        # 打开这些文件以便写入
        bytecode_files = [
            open(os.path.join(install_root, name), "w") for name in bytecode_file_names
        ]
        # 创建一个循环迭代器，用于轮流向不同的文件写入冻结模块
        it = itertools.cycle(bytecode_files)
        # 对每个冻结模块写入到相应的文件中
        for m in self.frozen_modules:
            self.write_frozen(m, next(it))

        # 关闭所有打开的文件
        for f in bytecode_files:
            f.close()

    def write_main(self, install_root, oss, symbol_name):
        """Write the `main.c` file containing a table enumerating all the frozen modules."""
        # 打开 `main.c` 文件以便写入
        with open(os.path.join(install_root, "main.c"), "w") as outfp:
            # 写入头文件和外部变量声明
            outfp.write(MAIN_INCLUDES)
            for m in self.frozen_modules:
                # 写入每个冻结模块的外部变量声明
                outfp.write(f"extern unsigned char {m.c_name}[];\n")

            # 写入主文件的前缀模板
            outfp.write(MAIN_PREFIX_TEMPLATE.format(symbol_name))
            # 枚举所有冻结模块，写入模块名、C变量名和大小信息
            for m in self.frozen_modules:
                outfp.write(f'\t{{"{m.module_name}", {m.c_name}, {m.size}}},\n')
            # 写入主文件的后缀
            outfp.write(MAIN_SUFFIX)
            # 如果是开源软件，写入伪前缀和后缀
            if oss:
                outfp.write(FAKE_PREFIX)
                outfp.write(MAIN_SUFFIX)

    def write_frozen(self, m: FrozenModule, outfp):
        """Write a single frozen module's bytecode out to a C variable."""
        # 将单个冻结模块的字节码写入到C变量中
        outfp.write(f"unsigned char {m.c_name}[] = {{")
        for i in range(0, len(m.bytecode), 16):
            outfp.write("\n\t")
            for c in bytes(m.bytecode[i : i + 16]):
                outfp.write("%d," % c)
        outfp.write("\n};\n")

    def compile_path(self, path: Path, top_package_path: Path):
        """Entry point for compiling a Path object."""
        # 如果路径是目录，则编译整个包
        if path.is_dir():
            self.compile_package(path, top_package_path)
        else:
            # 否则，编译单个文件
            self.compile_file(path, top_package_path)

    @indent_msg
    def compile_package(self, path: Path, top_package_path: Path):
        """Compile all the files within a Python package dir."""
        # 断言路径确实是目录
        assert path.is_dir()
        # 如果目录名在拒绝列表中，则输出消息 "X" 并返回
        if path.name in DENY_LIST:
            self.msg(path, "X")
            return

        # 判断是否是Python包目录，即是否含有 __init__.py 文件
        is_package_dir = any(child.name == "__init__.py" for child in path.iterdir())
        if not is_package_dir:
            # 如果不是Python包目录，则输出消息 "S" 并返回
            self.msg(path, "S")
            return

        # 输出消息 "P" 表示这是一个包目录
        self.msg(path, "P")
        # 递归编译目录下的所有子文件或子目录
        for child in path.iterdir():
            self.compile_path(child, top_package_path)
    # 获取模块的完整限定名列表，从给定文件路径到顶级包路径的相对路径
    def get_module_qualname(self, file_path: Path, top_package_path: Path) -> List[str]:
        # `path` 的格式类似于 'Lib/foo/bar/baz.py'

        # 去掉 'Lib/' 部分，得到一个代表 Python 模块层次结构的路径
        # 例如 'foo/bar/baz.py'，对应到 'foo.bar.baz'
        normalized_path = file_path.relative_to(top_package_path.parent)

        if normalized_path.name == "__init__.py":
            # 对 `__init__.py` 进行特殊处理。在这种情况下，此文件指定其所在目录应被视为一个包。
            # 对于 'foo/bar/baz/__init__.py':
            # - 模块名称是 'baz'
            module_basename = normalized_path.parent.name
            # - 父目录是 foo.bar（需要去掉 'baz' 部分）
            module_parent = normalized_path.parent.parent.parts
        else:
            module_basename = normalized_path.stem
            module_parent = normalized_path.parent.parts
        return list(module_parent) + [module_basename]

    # 编译给定的 Python 源代码字符串为字节码对象
    def compile_string(self, file_content: str) -> types.CodeType:
        # 在调用 'compile' 函数时，不传递真实的构建时路径，而是传递一个标记。这样可以防止构建时路径泄漏到运行时。
        # 在 TorchScripting 过程中，检查模块尝试检索 Python 源代码时，这种设置确保它是一个硬错误，而不是一个不稳定的错误。
        path_marker = PATH_MARKER
        return compile(file_content, path_marker, "exec")

    # 编译给定的 Python 源文件为冻结的字节码，并将结果追加到 `self.frozen_modules`
    @indent_msg
    def compile_file(self, path: Path, top_package_path: Path):
        """
        编译 Python 源文件为冻结字节码。

        将结果追加到 `self.frozen_modules`。
        """
        assert path.is_file()
        if path.suffix != ".py":
            self.msg(path, "N")
            return

        if path.name in DENY_LIST:
            self.msg(path, "X")
            return

        self.msg(path, "F")
        module_qualname = self.get_module_qualname(path, top_package_path)
        module_mangled_name = "__".join(module_qualname)
        c_name = "M_" + module_mangled_name

        with open(path) as src_file:
            co = self.compile_string(src_file.read())

        bytecode = marshal.dumps(co)
        size = len(bytecode)
        if path.name == "__init__.py":
            # Python 包用负数大小表示
            size = -size
        self.frozen_modules.append(
            FrozenModule(".".join(module_qualname), c_name, size, bytecode)
        )
# 定义主函数，程序的入口点
def main() -> None:
    # 创建参数解析器，描述为“编译 Python 源码”
    parser = argparse.ArgumentParser(description="Compile py source")
    # 添加位置参数 paths，可变数量，帮助信息为“要冻结的路径”
    parser.add_argument("paths", nargs="*", help="Paths to freeze.")
    # 添加可选参数 --verbose，设置为真时打印调试日志
    parser.add_argument("--verbose", action="store_true", help="Print debug logs")
    # 添加可选参数 --install-dir 或 --install_dir，帮助信息为“所有输出文件的根目录”
    parser.add_argument(
        "--install-dir", "--install_dir", help="Root directory for all output files"
    )
    # 添加可选参数 --oss，设置为真时，模拟一个 _PyImport_FrozenModules
    parser.add_argument(
        "--oss",
        action="store_true",
        help="If it's OSS build, add a fake _PyImport_FrozenModules",
    )
    # 添加可选参数 --symbol-name 或 --symbol_name，帮助信息为“生成的冻结模块数组符号的名称”，默认为 _PyImport_FrozenModules_torch
    parser.add_argument(
        "--symbol-name",
        "--symbol_name",
        help="The name of the frozen module array symbol to generate",
        default="_PyImport_FrozenModules_torch",
    )

    # 解析命令行参数
    args = parser.parse_args()

    # 创建 Freezer 类的实例 f，传入 verbose 参数
    f = Freezer(args.verbose)

    # 遍历参数中的路径 args.paths
    for p in args.paths:
        # 将每个路径 p 转换为 Path 对象
        path = Path(p)
        # 如果路径是一个目录且不存在 __init__.py 文件
        if path.is_dir() and not Path.exists(path / "__init__.py"):
            # 表示顶层路径 p 是一个标准目录，包含模块，而不是一个模块本身
            # 每个 mod 可能是包含 __init__.py 或 .py 文件的子目录
            # 注意：使用 sorted 确保结果的确定性
            for mod in sorted(path.glob("*")):
                # 编译路径 mod，生成的字节码写入 mod
                f.compile_path(mod, mod)
        else:
            # 否则，编译路径 path，生成的字节码写入 path
            f.compile_path(path, path)

    # 将生成的字节码写入安装目录 args.install_dir
    f.write_bytecode(args.install_dir)
    # 写入主要的启动逻辑到 args.install_dir，根据 args.oss 和 args.symbol_name 的值
    f.write_main(args.install_dir, args.oss, args.symbol_name)


# 如果脚本作为主程序运行，则执行 main 函数（不覆盖测试覆盖率）
if __name__ == "__main__":
    main()  # pragma: no cover
```