# `.\pytorch\tools\lite_interpreter\gen_selected_mobile_ops_header.py`

```
#!/usr/bin/env python3
从 __future__ 模块导入 annotations 特性

导入命令行参数解析工具 argparse
导入操作系统接口模块 os
导入 YAML 解析器 yaml

从 torchgen 库中导入代码模板类 CodeTemplate
从 torchgen.selective_build.selector 中导入选择性构建器类 SelectiveBuilder

# 尝试加载快速的 C 语言版本的 YAML 加载器/转储器，如果不可用则加载安全版本
try:
    from yaml import CSafeLoader as Loader
except ImportError:
    from yaml import SafeLoader as Loader  # type: ignore[assignment, misc]

定义条件语句模板字符串
if_condition_template_str = """if (kernel_tag_sv.compare("$kernel_tag_name") == 0) {
  return $dtype_checks;
}"""
使用条件语句模板字符串创建条件语句模板对象
if_condition_template = CodeTemplate(if_condition_template_str)

定义所选核心数据类型头文件模板字符串
selected_kernel_dtypes_h_template_str = """
#include <c10/core/ScalarType.h>
#include <c10/util/string_view.h>
#include <c10/macros/Macros.h>

namespace at {
inline constexpr bool should_include_kernel_dtype(
  const char *kernel_tag_str,
  at::ScalarType scalar_type
) {
  c10::string_view kernel_tag_sv C10_UNUSED = c10::string_view(kernel_tag_str);
  $body
  return false;
}
}
"""
使用所选核心数据类型头文件模板字符串创建头文件内容模板对象
selected_kernel_dtypes_h_template = CodeTemplate(selected_kernel_dtypes_h_template_str)

定义所选移动操作的引言字符串
selected_mobile_ops_preamble = """#pragma once
/**
 * Generated by gen_selected_mobile_ops_header.py
 */

"""

定义函数 extract_root_operators，接收一个 SelectiveBuilder 对象并返回根操作符的集合
def extract_root_operators(selective_builder: SelectiveBuilder) -> set[str]:
    初始化一个空列表 ops 用于存放根操作符
    for op_name, op in selective_builder.operators.items():
        如果操作 op 是根操作符，则将其名称 op_name 添加到 ops 列表中
        ops.append(op_name)
    将 ops 转换为集合并返回
    return set(ops)

定义函数 get_selected_kernel_dtypes_code，接收一个 SelectiveBuilder 对象并返回生成的所选核心数据类型的代码字符串
def get_selected_kernel_dtypes_code(
    selective_builder: SelectiveBuilder,
) -> str:
    设置默认的返回体内容为 "return true;"
    如果 selective_builder.include_all_operators 为 False 并且 selective_builder.include_all_non_op_selectives 为 False：
        初始化一个空列表 body_parts 用于存放每个核心数据类型的条件判断字符串
        遍历 selective_builder.kernel_metadata 中的每个 kernel_tag 和对应的 dtypes
            对于每个 dtype，生成形如 "scalar_type == at::ScalarType::dtype" 的条件
            将条件加入 conditions 列表中
        将所有条件用 " || " 连接起来，并添加到 body_parts 列表中
        将所有条件语句字符串用 " else " 连接起来作为最终的 body 内容

    使用 selected_kernel_dtypes_h_template 替换 body 部分生成最终的头文件内容
    返回生成的头文件内容

定义函数 write_selected_mobile_ops，接收输出文件路径 output_file_path 和 SelectiveBuilder 对象 selective_builder 作为参数，无返回值
def write_selected_mobile_ops(
    output_file_path: str,
    selective_builder: SelectiveBuilder,
) -> None:
    调用 extract_root_operators 函数获取根操作符的集合
    获取 selective_builder 中的 custom_classes 和 build_features
    # 打开一个文件用于写入，以二进制模式 ("wb")，使用上下文管理器确保文件自动关闭
    with open(output_file_path, "wb") as out_file:
        # 创建一个列表，初始内容包括选定的移动操作前导部分
        body_parts = [selected_mobile_ops_preamble]

        # 检查是否处于选择性构建模式
        # 如果选择性构建宏未包含所有运算符，将白名单操作符添加到代码中
        if not selective_builder.include_all_operators:
            body_parts.append(
                "#define TORCH_OPERATOR_WHITELIST "
                + (";".join(sorted(root_ops)))
                + ";\n\n"
            )

            # 检查是否处于基于跟踪的选择性构建模式
            if selective_builder.include_all_non_op_selectives is False:
                # 将自定义类别白名单添加到代码中
                body_parts.append(
                    "#define TORCH_CUSTOM_CLASS_ALLOWLIST "
                    + (";".join(sorted(custom_classes)))
                    + ";\n\n"
                )
                # 将构建特征白名单添加到代码中
                body_parts.append(
                    "#define TORCH_BUILD_FEATURE_ALLOWLIST "
                    + (";".join(sorted(build_features)))
                    + ";\n\n"
                )

        # 获取选定的内核数据类型代码，并将其添加到主体部分
        body_parts.append(get_selected_kernel_dtypes_code(selective_builder))

        # 将所有部分的内容合并成一个字符串
        header_contents = "".join(body_parts)

        # 将字符串内容按 UTF-8 编码写入到输出文件中
        out_file.write(header_contents.encode("utf-8"))
# root_ops: 选定的根操作符集合，用于选择性地构建
# Write the file selected_mobile_ops.h with optionally:
# 1. The selected root operators from root_ops
# 2. All kernel dtypes

# 定义函数，将选定的移动端操作符与所有内核数据类型写入指定路径的文件中
def write_selected_mobile_ops_with_all_dtypes(
    output_file_path: str,      # 输出文件的路径
    root_ops: set[str],         # 选定的根操作符集合，作为函数的输入参数
) -> None:
    with open(output_file_path, "wb") as out_file:  # 打开输出文件路径，并以二进制写入模式打开文件
        body_parts = [selected_mobile_ops_preamble]  # 初始化一个列表，包含选定移动操作的开头部分

        # 添加选定的根操作符列表到body_parts中
        body_parts.append(
            "#define TORCH_OPERATOR_WHITELIST " + (";".join(sorted(root_ops))) + ";\n\n"
        )

        # 获取选定内核数据类型的代码并添加到body_parts中
        selective_builder = SelectiveBuilder.get_nop_selector()
        body_parts.append(get_selected_kernel_dtypes_code(selective_builder))

        # 将所有部分连接成一个完整的头文件内容
        header_contents = "".join(body_parts)
        # 将头文件内容以UTF-8编码写入输出文件
        out_file.write(header_contents.encode("utf-8"))


# 主函数，程序的入口点
def main() -> None:
    # 创建参数解析器，用于解析命令行参数
    parser = argparse.ArgumentParser(
        description="Generate selected_mobile_ops.h for selective build."
    )
    
    # 添加命令行参数：yaml文件路径，必需参数
    parser.add_argument(
        "-p",
        "--yaml-file-path",
        "--yaml_file_path",
        type=str,
        required=True,
        help="Path to the yaml file with a list of operators used by the model.",
    )
    
    # 添加命令行参数：输出文件路径，必需参数
    parser.add_argument(
        "-o",
        "--output-file-path",
        "--output_file_path",
        type=str,
        required=True,
        help="Path to destination folder where selected_mobile_ops.h will be written.",
    )
    
    # 解析命令行参数
    parsed_args = parser.parse_args()
    model_file_name = parsed_args.yaml_file_path

    print("Loading yaml file: ", model_file_name)
    
    # 初始化加载的模型为空字典
    loaded_model = {}
    
    # 打开yaml文件，加载其中的模型数据
    with open(model_file_name, "rb") as model_file:
        loaded_model = yaml.load(model_file, Loader=Loader)

    # 将加载的模型转换为集合，获取其中的根操作符集合
    root_operators_set = set(loaded_model)
    
    # 打印输出将要写入的头文件的路径
    print("Writing header file selected_mobile_ops.h: ", parsed_args.output_file_path)
    
    # 调用写入函数，将选定的移动端操作符与所有内核数据类型写入指定的输出文件路径
    write_selected_mobile_ops_with_all_dtypes(
        os.path.join(parsed_args.output_file_path, "selected_mobile_ops.h"),
        root_operators_set,
    )


# 如果当前脚本作为主程序运行，则执行主函数
if __name__ == "__main__":
    main()
```