# `.\pytorch\third_party\generate-xnnpack-wrappers.py`

```
#!/usr/bin/env python3
# 指定解释器为 Python 3

from __future__ import print_function
# 引入未来版本兼容模块，确保兼容 Python 2 和 Python 3 的 print 函数

import collections
# 导入 collections 模块，用于高级数据容器

import os
# 导入 os 模块，提供操作系统相关的功能

import sys
# 导入 sys 模块，提供对 Python 解释器的访问

import logging
# 导入 logging 模块，用于记录日志信息

BANNER = "Auto-generated by generate-wrappers.py script. Do not modify"
# 定义一个常量 BANNER，表示这段代码是由 generate-wrappers.py 脚本自动生成的，不允许修改

WRAPPER_SRC_NAMES = {
    "PROD_SCALAR_MICROKERNEL_SRCS": None,
    # 定义一个字典 WRAPPER_SRC_NAMES，包含一系列键值对，用于存储不同的宏定义与条件编译条件的关系
    "PROD_FMA_MICROKERNEL_SRCS": "defined(__riscv) || defined(__riscv__)",
    "PROD_ARMSIMD32_MICROKERNEL_SRCS": "defined(__arm__)",
    "PROD_FP16ARITH_MICROKERNEL_SRCS": "defined(__arm__)",
    "PROD_NEON_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONFP16_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONFMA_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEON_AARCH64_MICROKERNEL_SRCS": "defined(__aarch64__)",
    "PROD_NEONV8_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONFP16ARITH_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONFP16ARITH_AARCH64_MICROKERNEL_SRCS": "defined(__aarch64__)",
    "PROD_NEONDOT_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONDOT_AARCH64_MICROKERNEL_SRCS": "defined(__aarch64__)",
    "PROD_NEONDOTFP16ARITH_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_NEONDOTFP16ARITH_AARCH64_MICROKERNEL_SRCS": "defined(__aarch64__)",
    "PROD_NEONI8MM_MICROKERNEL_SRCS": "defined(__arm__) || defined(__aarch64__)",
    "PROD_SSE_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_SSE2_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_SSSE3_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_SSE41_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_F16C_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_XOP_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_FMA3_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX2_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX512F_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX512SKX_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX512VBMI_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX512VNNI_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_AVX512VNNIGFNI_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
    "PROD_RVV_MICROKERNEL_SRCS": "defined(__riscv) || defined(__riscv__)",
    "PROD_AVXVNNI_MICROKERNEL_SRCS": "defined(__i386__) || defined(__i686__) || defined(__x86_64__)",
}
# 定义一系列特定宏定义与条件编译条件的映射关系，用于不同平台和处理器架构的微内核源文件选择
    # 定义一个名为"AARCH32_ASM_MICROKERNEL_SRCS"的变量，其值为字符串"defined(__arm__)"
    "AARCH32_ASM_MICROKERNEL_SRCS": "defined(__arm__)",
    # 定义一个名为"AARCH64_ASM_MICROKERNEL_SRCS"的变量，其值为字符串"defined(__aarch64__)"
    "AARCH64_ASM_MICROKERNEL_SRCS": "defined(__aarch64__)",

    # 在此处添加非生产环境微内核源码：
    # 这里是一个注释，指示在此处可以添加非生产环境微内核的源代码。
}

SRC_NAMES = set([
    "OPERATOR_SRCS",  # 定义一组源文件名，用于运算符
    "SUBGRAPH_SRCS",  # 子图源文件
    "LOGGING_SRCS",   # 日志记录源文件
    "XNNPACK_SRCS",   # XNNPACK 源文件
    "TABLE_SRCS",     # 表格源文件
    "JIT_SRCS",       # JIT 源文件
    "PROD_SCALAR_MICROKERNEL_SRCS",  # 生产标量微内核源文件
    "PROD_FMA_MICROKERNEL_SRCS",      # 生产 FMA 微内核源文件
    "PROD_ARMSIMD32_MICROKERNEL_SRCS",  # 生产 ARMSIMD32 微内核源文件
    "PROD_FP16ARITH_MICROKERNEL_SRCS",  # 生产 FP16ARITH 微内核源文件
    "PROD_NEON_MICROKERNEL_SRCS",       # 生产 NEON 微内核源文件
    "PROD_NEONFP16_MICROKERNEL_SRCS",   # 生产 NEONFP16 微内核源文件
    "PROD_NEONFMA_MICROKERNEL_SRCS",    # 生产 NEONFMA 微内核源文件
    "PROD_NEON_AARCH64_MICROKERNEL_SRCS",  # 生产 NEON_AARCH64 微内核源文件
    "PROD_NEONV8_MICROKERNEL_SRCS",     # 生产 NEONV8 微内核源文件
    "PROD_NEONFP16ARITH_MICROKERNEL_SRCS",  # 生产 NEONFP16ARITH 微内核源文件
    "PROD_NEONFP16ARITH_AARCH64_MICROKERNEL_SRCS",  # 生产 NEONFP16ARITH_AARCH64 微内核源文件
    "PROD_NEONDOT_MICROKERNEL_SRCS",    # 生产 NEONDOT 微内核源文件
    "PROD_NEONDOT_AARCH64_MICROKERNEL_SRCS",  # 生产 NEONDOT_AARCH64 微内核源文件
    "PROD_NEONDOTFP16ARITH_MICROKERNEL_SRCS",  # 生产 NEONDOTFP16ARITH 微内核源文件
    "PROD_NEONDOTFP16ARITH_AARCH64_MICROKERNEL_SRCS",  # 生产 NEONDOTFP16ARITH_AARCH64 微内核源文件
    "PROD_NEONI8MM_MICROKERNEL_SRCS",   # 生产 NEONI8MM 微内核源文件
    "PROD_SSE_MICROKERNEL_SRCS",        # 生产 SSE 微内核源文件
    "PROD_SSE2_MICROKERNEL_SRCS",       # 生产 SSE2 微内核源文件
    "PROD_SSSE3_MICROKERNEL_SRCS",      # 生产 SSSE3 微内核源文件
    "PROD_SSE41_MICROKERNEL_SRCS",      # 生产 SSE41 微内核源文件
    "PROD_AVX_MICROKERNEL_SRCS",        # 生产 AVX 微内核源文件
    "PROD_F16C_MICROKERNEL_SRCS",       # 生产 F16C 微内核源文件
    "PROD_XOP_MICROKERNEL_SRCS",        # 生产 XOP 微内核源文件
    "PROD_FMA3_MICROKERNEL_SRCS",       # 生产 FMA3 微内核源文件
    "PROD_AVX2_MICROKERNEL_SRCS",       # 生产 AVX2 微内核源文件
    "PROD_AVX512F_MICROKERNEL_SRCS",    # 生产 AVX512F 微内核源文件
    "PROD_AVX512SKX_MICROKERNEL_SRCS",  # 生产 AVX512SKX 微内核源文件
    "PROD_AVX512VBMI_MICROKERNEL_SRCS",  # 生产 AVX512VBMI 微内核源文件
    "PROD_AVX512VNNI_MICROKERNEL_SRCS",  # 生产 AVX512VNNI 微内核源文件
    "PROD_AVX512VNNIGFNI_MICROKERNEL_SRCS",  # 生产 AVX512VNNIGFNI 微内核源文件
    "PROD_RVV_MICROKERNEL_SRCS",        # 生产 RVV 微内核源文件
    "PROD_AVXVNNI_MICROKERNEL_SRCS",    # 生产 AVXVNNI 微内核源文件
    "AARCH32_ASM_MICROKERNEL_SRCS",     # AARCH32_ASM 微内核源文件
    "AARCH64_ASM_MICROKERNEL_SRCS",     # AARCH64_ASM 微内核源文件

    # 在这里添加非生产微内核源文件：
])

def handle_singleline_parse(line):
    start_index = line.find("(")    # 查找行中左括号的位置
    end_index = line.find(")")      # 查找行中右括号的位置
    line = line[start_index+1:end_index]  # 截取括号内的内容
    key_val = line.split(" ")       # 以空格分割内容
    return key_val[0], list(map(lambda x: x[4:], key_val[1:]))  # 返回键和值的列表，值去除前四个字符

def update_sources(xnnpack_path, cmakefile = "XNNPACK/CMakeLists.txt"):
    sources = collections.defaultdict(list)  # 创建一个默认值为列表的字典
    # 使用给定的路径和文件名打开 CMake 文件
    with open(os.path.join(xnnpack_path, cmakefile)) as cmake:
        # 读取所有行到列表中
        lines = cmake.readlines()
        i = 0
        while i < len(lines):
            line = lines[i]
    
            # 检查行是否以 "SET" 开头并且包含 "src/"
            if lines[i].startswith("SET") and "src/" in lines[i]:
                # 调用函数处理单行解析，获取变量名和值
                name, val = handle_singleline_parse(line)
                # 将值添加到名为name的列表中
                sources[name].extend(val)
                i += 1
                continue
    
            # 检查行是否以 "SET" 开头，并且括号内的内容在包含的文件名集合中
            if line.startswith("SET") and line.split('(')[1].strip(' \t\n\r') in set(WRAPPER_SRC_NAMES.keys()) | set(SRC_NAMES):
                # 获取括号内的内容作为变量名
                name = line.split('(')[1].strip(' \t\n\r')
                i += 1
                while i < len(lines) and len(lines[i]) > 0 and ')' not in lines[i]:
                    # 移除行首的 "src/"，移除空白和换行符
                    value = lines[i].strip(' \t\n\r')
                    # 将处理后的值添加到名为name的列表中
                    sources[name].append(value[4:])
                    i += 1
                if i < len(lines) and len(lines[i]) > 4:
                    # 移除行首的 "src/"，可能包含行尾的 ')'
                    value = lines[i].strip(' \t\n\r)')
                    # 将处理后的值添加到名为name的列表中
                    sources[name].append(value[4:])
            else:
                i += 1
    # 返回sources字典，其中包含从CMake文件中提取的变量名和对应值的列表
    return sources
def gen_wrappers(xnnpack_path):
    # 创建一个 defaultdict，用于存储各个 wrapper 源文件的信息
    xnnpack_sources = collections.defaultdict(list)
    
    # 更新 xnnpack 源代码的路径，并获取所有源文件的信息
    sources = update_sources(xnnpack_path)

    # 更新 microkernels 的源文件信息，加入到 sources 中
    microkernels_sources = update_sources(xnnpack_path, "XNNPACK/cmake/microkernels.cmake")
    for key in microkernels_sources:
        sources[key] = microkernels_sources[key]

    # 根据 WRAPPER_SRC_NAMES 中的名称，将各个 wrapper 源文件添加到 xnnpack_sources 中
    for name in WRAPPER_SRC_NAMES:
        xnnpack_sources[WRAPPER_SRC_NAMES[name]].extend(sources[name])

    # 遍历 xnnpack_sources，生成 wrapper 文件
    for condition, filenames in xnnpack_sources.items():
        print(condition)
        for filename in filenames:
            # 构建 wrapper 文件的完整路径
            filepath = os.path.join(xnnpack_path, "xnnpack_wrappers", filename)

            # 如果 wrapper 文件的目录不存在，创建目录
            if not os.path.isdir(os.path.dirname(filepath)):
                os.makedirs(os.path.dirname(filepath))
            
            # 打开 wrapper 文件并写入 banner 注释
            with open(filepath, "w") as wrapper:
                print("/* {} */".format(BANNER), file=wrapper)
                print(file=wrapper)

                # 在 wrapper 文件中添加架构或平台相关的预处理器标志
                # 注意：platform_preprocessor_flags 不能使用，因为被 arc focus & buck project 忽略
                
                if condition is None:
                    # 如果 condition 为 None，则直接包含文件
                    print("#include <%s>" % filename, file=wrapper)
                else:
                    # 否则，根据条件是否满足来包含源文件
                    print("#if %s" % condition, file=wrapper)
                    print("#include <%s>" % filename, file=wrapper)
                    print("#endif /* %s */" % condition, file=wrapper)

    # 更新当前路径下的 xnnpack_wrapper_defs.bzl 文件
    with open(os.path.join(os.path.dirname(__file__), "xnnpack_wrapper_defs.bzl"), 'w') as wrapper_defs:
        print('"""', file=wrapper_defs)
        print(BANNER, file=wrapper_defs)
        print('"""', file=wrapper_defs)
        for name in WRAPPER_SRC_NAMES:
            print('\n' + name + ' = [', file=wrapper_defs)
            for file_name in sources[name]:
                print('    "xnnpack_wrappers/{}",'.format(file_name), file=wrapper_defs)
            print(']', file=wrapper_defs)

    # 更新当前路径下的 xnnpack_src_defs.bzl 文件
    with open(os.path.join(os.path.dirname(__file__), "xnnpack_src_defs.bzl"), 'w') as src_defs:
        print('"""', file=src_defs)
        print(BANNER, file=src_defs)
        print('"""', file=src_defs)
        for name in SRC_NAMES:
            print('\n' + name + ' = [', file=src_defs)
            for file_name in sources[name]:
                print('    "XNNPACK/src/{}",'.format(file_name), file=src_defs)


def main(argv):
    # 如果没有传入参数或参数长度为0，将在当前路径下生成 xnnpack_wrappers 文件夹
    if argv is None or len(argv) == 0:
        gen_wrappers(".")
    else:
        # 否则，在指定路径下生成 xnnpack_wrappers 文件夹
        gen_wrappers(argv[0])

# 第一个参数指定了生成 "xnnpack_wrappers" 文件夹的位置
# 若不带参数运行，将在当前路径生成 "xnnpack_wrappers" 文件夹
# 两个 .bzl 文件将始终在当前路径生成
if __name__ == "__main__":
    main(sys.argv[1:])


# 调用程序的主函数，传入命令行参数列表（不包括脚本名称）
main(sys.argv[1:])


这行代码调用了一个名为 `main` 的函数，并将命令行参数列表 `sys.argv` 的切片作为参数传递给它。`sys.argv` 是一个包含命令行参数的列表，其中第一个元素是脚本的名称，后续元素是用户在命令行中提供的参数。通过使用 `[1:]`，我们传递给 `main` 函数的是除脚本名称外的其余参数列表。
```