# `.\pytorch\torch\utils\hipify\hipify_python.py`

```
#!/usr/bin/env python3
# mypy: allow-untyped-defs
""" The Python Hipify script.
##
# Copyright (c) 2015-2016 Advanced Micro Devices, Inc. All rights reserved.
#               2017-2018 Advanced Micro Devices, Inc. and
#                         Facebook Inc. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
"""

import argparse  # 导入处理命令行参数的模块
import fnmatch  # 导入用于文件名匹配的模块
import re  # 导入正则表达式模块
import shutil  # 导入文件和目录操作相关的模块
import sys  # 导入系统相关的功能模块
import os  # 导入操作系统功能的模块

from . import constants  # 导入当前包中的常量模块
from .cuda_to_hip_mappings import CUDA_TO_HIP_MAPPINGS  # 导入 CUDA 到 HIP 的映射关系
from .cuda_to_hip_mappings import MATH_TRANSPILATIONS  # 导入 CUDA 数学函数的转换映射

from typing import Dict, List, Iterator, Optional  # 导入类型提示相关的模块
from collections.abc import Mapping, Iterable  # 导入集合抽象基类相关的模块
from enum import Enum  # 导入枚举类型相关的模块

class CurrentState(Enum):
    INITIALIZED = 1  # 表示初始化状态的枚举值
    DONE = 2  # 表示完成状态的枚举值

class HipifyResult:
    def __init__(self, current_state, hipified_path):
        self.current_state = current_state  # 初始化 HipifyResult 实例的当前状态
        self.hipified_path = hipified_path  # 初始化 HipifyResult 实例的转换后路径
        self.status = ""  # 初始化 HipifyResult 实例的状态信息，默认为空字符串

    def __str__(self):
        return (f"HipifyResult:: current_state: {self.current_state}, hipified_path : {self.hipified_path}, status: {self.status}")  # 返回 HipifyResult 对象的描述字符串

HipifyFinalResult = Dict[str, HipifyResult]  # Hipify 最终结果的类型定义，字典类型，键为字符串，值为 HipifyResult 对象
HIPIFY_C_BREADCRUMB = "// !!! This is a file automatically generated by hipify!!!\n"  # Hipify 自动生成文件的标记注释
HIPIFY_FINAL_RESULT: HipifyFinalResult = {}  # 存储 Hipify 最终结果的字典，初始化为空字典

# Hardcode the PyTorch template map
"""This dictionary provides the mapping from PyTorch kernel template types
to their actual types."""
PYTORCH_TEMPLATE_MAP = {"Dtype": "scalar_t", "T": "scalar_t"}  # 定义硬编码的 PyTorch 模板映射字典，将模板类型映射到实际类型
# 定义一个模块级别变量，包含程序中公开的名称列表
__all__ = ['InputError', 'openf', 'bcolors', 'GeneratedFileCleaner', 'match_extensions', 'matched_files_iter',
           'preprocess_file_and_save_result', 'compute_stats', 'add_dim3', 'processKernelLaunches', 'find_closure_group',
           'find_bracket_group', 'find_parentheses_group', 'replace_math_functions', 'hip_header_magic', 'replace_extern_shared',
           'get_hip_file_path', 'is_out_of_place', 'is_pytorch_file', 'is_cusparse_file', 'is_special_file', 'is_caffe2_gpu_file',
           'Trie', 'preprocessor', 'file_specific_replacement', 'file_add_header',
           'fix_static_global_kernels', 'extract_arguments', 'str2bool', 'CurrentState', 'HipifyResult', 'hipify']

# 定义一个自定义异常类 InputError，用于处理输入错误
class InputError(Exception):
    # 在输入错误时引发异常。

    def __init__(self, message):
        super().__init__(message)
        self.message = message

    def __str__(self):
        return f"Input error: {self.message}"


# 打开文件的函数，使用指定的文件名和模式打开文件
def openf(filename, mode):
    return open(filename, mode, errors='ignore')


# 用于打印输出时添加颜色的类定义
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


# 生成文件清理的上下文管理器类，用于在 hipify 过程中清理生成的文件
class GeneratedFileCleaner:
    """Context Manager to clean up generated files"""
    def __init__(self, keep_intermediates=False):
        self.keep_intermediates = keep_intermediates
        self.files_to_clean = set()
        self.dirs_to_clean = []

    def __enter__(self):
        return self

    # 打开文件的方法，在文件不存在时将其添加到待清理的文件列表中
    def open(self, fn, *args, **kwargs):
        if not os.path.exists(fn):
            self.files_to_clean.add(os.path.abspath(fn))
        return open(fn, *args, **kwargs)

    # 递归创建目录的方法，将新创建的目录添加到待清理的目录列表中
    def makedirs(self, dn, exist_ok=False):
        parent, n = os.path.split(dn)
        if not n:
            parent, n = os.path.split(parent)
        if parent and n and not os.path.exists(parent):
            self.makedirs(parent, exist_ok=True)
        if not os.path.isdir(dn) or not exist_ok:
            os.mkdir(dn)
            self.dirs_to_clean.append(os.path.abspath(dn))

    # 在退出上下文管理器时根据设定清理生成的文件和目录
    def __exit__(self, type, value, traceback):
        if not self.keep_intermediates:
            for f in self.files_to_clean:
                os.unlink(f)
            for d in self.dirs_to_clean[::-1]:
                os.rmdir(d)


# 检查文件名是否匹配指定的扩展名列表的函数，返回布尔值
def match_extensions(filename: str, extensions: Iterable) -> bool:
    """Helper method to see if filename ends with certain extension"""
    # 检查给定的文件名是否以指定的扩展名之一结尾
    return any(filename.endswith(e) for e in extensions)
def _fnmatch(filepath, patterns):
    return any(fnmatch.fnmatch(filepath, pattern) for pattern in patterns)


def matched_files_iter(
        root_path: str,
        includes: Iterable = (),
        ignores: Iterable = (),
        extensions: Iterable = (),
        out_of_place_only: bool = False,
        is_pytorch_extension: bool = False) -> Iterator[str]:

    exact_matches = set(includes)

    # This is a very rough heuristic; really, we want to avoid scanning
    # any file which is not checked into source control, but this script
    # needs to work even if you're in a Git or Hg checkout, so easier to
    # just block the biggest time sinks that won't matter in the
    # end.
    for (abs_dirpath, dirs, filenames) in os.walk(root_path, topdown=True):
        rel_dirpath = os.path.relpath(abs_dirpath, root_path)
        if rel_dirpath == '.':
            # Exclude certain directories known to not contain relevant files
            if ".git" in dirs:
                dirs.remove(".git")
            if "build" in dirs:
                dirs.remove("build")
            if "third_party" in dirs:
                dirs.remove("third_party")
                dirs.append("third_party/nvfuser")
        for filename in filenames:
            filepath = os.path.join(abs_dirpath, filename)
            rel_filepath = os.path.join(rel_dirpath, filename)
            # Check if the file matches inclusion patterns and does not match exclusion patterns
            if (
                _fnmatch(filepath, includes)
                and (not _fnmatch(filepath, ignores))
                and (match_extensions(filepath, extensions) or filepath in exact_matches)
            ):
                if not is_pytorch_extension:  # Consider specific conditions for PyTorch extensions
                    # Skip non-PyTorch files and Caffe2 GPU files if specified
                    if not is_pytorch_file(rel_filepath) and not is_caffe2_gpu_file(rel_filepath):
                        continue
                    # Skip files not marked as out-of-place if 'out_of_place_only' is True
                    if out_of_place_only and not is_out_of_place(rel_filepath):
                        continue
                # Yield the file path if all conditions are satisfied
                yield filepath


def preprocess_file_and_save_result(
        output_directory: str,
        filepath: str,
        all_files: Iterable,
        header_include_dirs: Iterable,
        stats: Dict[str, List],
        hip_clang_launch: bool,
        is_pytorch_extension: bool,
        clean_ctx: GeneratedFileCleaner,
        show_progress: bool) -> None:
    # Determine the absolute path of the file in the output directory
    fin_path = os.path.abspath(os.path.join(output_directory, filepath))
    # Create a HipifyResult object and store it in a global dictionary
    hipify_result = HipifyResult(current_state=CurrentState.INITIALIZED, hipified_path=fin_path)
    HIPIFY_FINAL_RESULT[fin_path] = hipify_result
    # Invoke the preprocessor function to process the file
    result = preprocessor(output_directory, filepath, all_files, header_include_dirs, stats,
                          hip_clang_launch, is_pytorch_extension, clean_ctx, show_progress)

    # Show processing details if 'show_progress' is True and no 'ignored' status in result
    if show_progress and "ignored" not in result.status:
        print(
            fin_path, "->",
            result.hipified_path, result.status, flush=True)
    # 将变量 result 存入字典 HIPIFY_FINAL_RESULT，键为 fin_path
    HIPIFY_FINAL_RESULT[fin_path] = result
def compute_stats(stats):
    # 从 stats 参数中获取不支持的 CUDA 调用集合
    unsupported_calls = {cuda_call for (cuda_call, _filepath) in stats["unsupported_calls"]}

    # 打印不支持的 CUDA 函数调用数量
    print(f"Total number of unsupported CUDA function calls: {len(unsupported_calls):d}")

    # 打印不支持的 CUDA 函数调用列表
    print(", ".join(unsupported_calls))

    # 打印替换的核函数启动数量
    print(f"\nTotal number of replaced kernel launches: {len(stats['kernel_launches']):d}")


def add_dim3(kernel_string, cuda_kernel):
    '''adds dim3() to the second and third arguments in the kernel launch'''
    count = 0
    closure = 0
    # 移除 CUDA 风格的核函数启动语法 <<< 和 >>>
    kernel_string = kernel_string.replace("<<<", "").replace(">>>", "")
    # 初始化存储参数位置的列表
    arg_locs: List[Dict[str, int]] = [{} for _ in range(2)]
    arg_locs[count]['start'] = 0
    # 遍历核函数字符串，定位参数位置
    for ind, c in enumerate(kernel_string):
        if count > 1:
            break
        if c == "(":
            closure += 1
        elif c == ")":
            closure -= 1
        # 当找到逗号或字符串末尾并且没有未闭合的括号时，确定参数位置
        if (c == "," or ind == len(kernel_string) - 1) and closure == 0:
            arg_locs[count]['end'] = ind + (c != ",")
            count += 1
            if count < 2:
                arg_locs[count]['start'] = ind + 1

    # 提取第一个和第二个参数的原始字符串
    first_arg_raw = kernel_string[arg_locs[0]['start']:arg_locs[0]['end'] + 1]
    second_arg_raw = kernel_string[arg_locs[1]['start']:arg_locs[1]['end']]

    # 清理第一个和第二个参数的字符串，去除空格和换行符
    first_arg_clean = kernel_string[arg_locs[0]['start']:arg_locs[0]['end']].replace("\n", "").strip(" ")
    second_arg_clean = kernel_string[arg_locs[1]['start']:arg_locs[1]['end']].replace("\n", "").strip(" ")

    # 在第一个和第二个参数上添加 dim3() 包装
    first_arg_dim3 = f"dim3({first_arg_clean})"
    second_arg_dim3 = f"dim3({second_arg_clean})"

    # 将 dim3() 添加到原始字符串中
    first_arg_raw_dim3 = first_arg_raw.replace(first_arg_clean, first_arg_dim3)
    second_arg_raw_dim3 = second_arg_raw.replace(second_arg_clean, second_arg_dim3)

    # 将修改后的参数字符串替换回 CUDA 核函数字符串中
    cuda_kernel = cuda_kernel.replace(first_arg_raw + second_arg_raw, first_arg_raw_dim3 + second_arg_raw_dim3)
    return cuda_kernel


RE_KERNEL_LAUNCH = re.compile(r'([ ]+)(detail?)::[ ]+\\\n[ ]+')


def processKernelLaunches(string, stats):
    """ Replace the CUDA style Kernel launches with the HIP style kernel launches."""
    # 替换 CUDA 样式的核函数启动语法为 HIP 样式的核函数启动语法
    string = RE_KERNEL_LAUNCH.sub(lambda inp: f"{inp.group(1)}{inp.group(2)}::", string)
    def grab_method_and_template(in_kernel):
        # 定义用于存储关键组件位置的字典
        pos = {
            "kernel_launch": {"start": in_kernel["start"], "end": in_kernel["end"]},
            "kernel_name": {"start": -1, "end": -1},
            "template": {"start": -1, "end": -1}
        }

        # 初始化模板平衡计数
        count = {"<>": 0}

        # 定义状态常量，用于标识解析过程中的不同阶段
        START = 0
        AT_TEMPLATE = 1
        AFTER_TEMPLATE = 2
        AT_KERNEL_NAME = 3

        status = START  # 初始状态为START

        # 逆序遍历字符串字符
        for i in range(pos["kernel_launch"]["start"] - 1, -1, -1):
            char = string[i]

            # 处理模板参数
            if status in (START, AT_TEMPLATE):
                if char == ">":
                    if status == START:
                        status = AT_TEMPLATE
                        pos["template"]["end"] = i
                    count["<>"] += 1

                if char == "<":
                    count["<>"] -= 1
                    if count["<>"] == 0 and (status == AT_TEMPLATE):
                        pos["template"]["start"] = i
                        status = AFTER_TEMPLATE

            # 处理核函数名称
            if status != AT_TEMPLATE:
                if string[i].isalnum() or string[i] in {'(', ')', '_', ':', '#'}:
                    if status != AT_KERNEL_NAME:
                        status = AT_KERNEL_NAME
                        pos["kernel_name"]["end"] = i

                    # 如果核函数名称从字符串的开头开始
                    if i == 0:
                        pos["kernel_name"]["start"] = 0

                        # 完成解析，返回结果
                        return [(pos["kernel_name"]), (pos["template"]), (pos["kernel_launch"])]

                else:
                    # 如果已经在解析核函数名称，可能是结束点
                    if status == AT_KERNEL_NAME:
                        pos["kernel_name"]["start"] = i

                        # 完成解析，返回结果
                        return [(pos["kernel_name"]), (pos["template"]), (pos["kernel_launch"])]
    # 定义一个函数，用于查找字符串中所有 CUDA 核函数的起始和结束位置
    def find_kernel_bounds(string):
        """Finds the starting and ending points for all kernel launches in the string."""
        kernel_end = 0  # 初始化 CUDA 核函数结束位置
        kernel_positions = []  # 存储所有 CUDA 核函数位置的列表

        # 持续查找直到找不到更多的 CUDA 核函数为止
        while string.find("<<<", kernel_end) != -1:
            # 获取 CUDA 核函数的起始位置（从上一个结束点开始查找）
            kernel_start = string.find("<<<", kernel_end)

            # 获取 CUDA 核函数的结束位置（调整结束点到 >>> 之后）
            kernel_end = string.find(">>>", kernel_start) + 3
            if kernel_end <= 0:
                raise InputError("no kernel end found")  # 如果找不到结束点，抛出输入错误异常

            # 将找到的 CUDA 核函数位置加入列表
            kernel_positions.append({"start": kernel_start, "end": kernel_end,
                                     "group": string[kernel_start: kernel_end]})

        return kernel_positions  # 返回所有 CUDA 核函数位置的列表

    # 替换代码中的注释和字符串字面量，以防止 find_kernel_bounds 错误地捕获注释和字符串字面量中的 CUDA 核函数
    # 这个函数将它们替换为 "x"，以保持位置
    def mask_comments(string):
        in_comment = ''  # 当前注释类型的状态（空字符串表示不在注释中）
        prev_c = ''  # 前一个字符
        new_string = ''  # 替换注释和字符串后的新字符串
        for c in string:
            if in_comment == '':
                # 不在注释中
                if c == '/' and prev_c == '/':
                    in_comment = '//'  # 开始单行注释
                elif c == '*' and prev_c == '/':
                    in_comment = '/*'  # 开始多行注释
                elif c == '"' and prev_c != '\\' and prev_c != "'":
                    in_comment = '"'  # 开始字符串字面量
            elif in_comment == '//':
                # 在单行注释中
                if c == '\r' or c == '\n':
                    in_comment = ''  # 单行注释结束
            elif in_comment == '/*':
                # 在多行注释中
                if c == '/' and prev_c == '*':
                    in_comment = ''  # 多行注释结束
            elif in_comment == '"':
                # 在字符串字面量中
                if c == '"' and prev_c != '\\':
                    in_comment = ''  # 字符串字面量结束
            prev_c = c
            if in_comment == '':
                new_string += c  # 将不在注释或字符串字面量中的字符保留在新字符串中
            else:
                new_string += 'x'  # 将注释和字符串字面量中的内容替换为 "x"
        return new_string  # 返回替换后的新字符串

    # 获取所有 CUDA 核函数的位置范围
    get_kernel_positions = list(find_kernel_bounds(mask_comments(string)))
    output_string = string

    # 替换每个 CUDA 核函数为一个 HIP 核函数。
    # 遍历获取到的所有内核位置信息
    for kernel in get_kernel_positions:
        # 获取内核的方法和模板信息
        params = grab_method_and_template(kernel)

        # 在内核启动之后查找括号位置
        parenthesis = string.find("(", kernel["end"])

        # 提取 CUDA 内核部分
        cuda_kernel = string[params[0]["start"]:parenthesis + 1]

        # 提取内核字符串
        kernel_string = string[kernel['start']:kernel['end']]

        # 确定结束参数索引
        end_param_index = 0 if params[1]['end'] == -1 else 1

        # 提取带有模板的内核名
        kernel_name_with_template = string[params[0]['start']:params[end_param_index]['end'] + 1]

        # 添加 CUDA 内核的维度信息
        cuda_kernel_dim3 = add_dim3(kernel_string, cuda_kernel)

        # 确保内核启动参数数量一致（网格维度、组织维度、流、动态共享内存大小）
        num_klp = len(extract_arguments(0, kernel["group"].replace("<<<", "(").replace(">>>", ")")))

        # 构建 HIP 内核调用字符串
        hip_kernel = "hipLaunchKernelGGL(" + cuda_kernel_dim3[0:-1].replace(
            ">>>", ", 0" * (4 - num_klp) + ">>>").replace("<<<", ", ").replace(
            ">>>", ", ").replace(kernel_name_with_template, "(" + kernel_name_with_template + ")")

        # 替换 CUDA 内核调用为 HIP 内核调用
        output_string = output_string.replace(cuda_kernel, hip_kernel)

        # 更新统计信息中的内核启动列表
        stats["kernel_launches"].append(hip_kernel)

    # 返回替换完 CUDA 内核后的输出字符串
    return output_string
def hip_header_magic(input_string):
    """If the file makes kernel builtin calls and does not include the cuda_runtime.h header,
    then automatically add an #include to match the "magic" includes provided by NVCC.
    TODO:
        Update logic to ignore cases where the cuda_runtime.h is included by another file.
    """

    # 复制输入字符串，以便修改
    output_string = input_string

    # 检查是否已经包含以下任一头文件
    headers = ["hip/hip_runtime.h", "hip/hip_runtime_api.h"]
    如果任何一个头文件已经被包含，则直接返回原始的输出字符串
    if any(re.search(fr'#include ("{ext}"|<{ext}>)', output_string) for ext in headers):
        return output_string

    # 粗略逻辑检测是否在设备代码内部
    hasDeviceLogic: int
    hasDeviceLogic = "hipLaunchKernelGGL" in output_string
    # 检查输出字符串中是否包含 "__global__" 标记，若包含则将 hasDeviceLogic 设置为 True
    hasDeviceLogic += "__global__" in output_string
    # 检查输出字符串中是否包含 "__shared__" 标记，若包含则将 hasDeviceLogic 设置为 True
    hasDeviceLogic += "__shared__" in output_string
    # 使用正则表达式 RE_SYNCTHREADS 搜索输出字符串，若找到则将 hasDeviceLogic 设置为 True
    hasDeviceLogic += RE_SYNCTHREADS.search(output_string) is not None

    # 如果发现设备逻辑存在，添加所需的头文件
    if hasDeviceLogic:
        output_string = '#include "hip/hip_runtime.h"\n' + input_string

    # 返回修改后的输出字符串
    return output_string
# 匹配 extern __shared__ type foo[]; 的语法，并替换为 HIP_DYNAMIC_SHARED() 宏。
# 参考链接：https://github.com/ROCm-Developer-Tools/HIP/blob/master/docs/markdown/hip_kernel_language.md#__shared__
RE_EXTERN_SHARED = re.compile(r"extern\s+([\w\(\)]+)?\s*__shared__\s+([\w:<>\s]+)\s+(\w+)\s*\[\s*\]\s*;")

def replace_extern_shared(input_string):
    """
    替换输入字符串中的 extern __shared__ type foo[]; 语法为 HIP_DYNAMIC_SHARED() 宏。
    示例：
        "extern __shared__ char smemChar[];" => "HIP_DYNAMIC_SHARED( char, smemChar)"
        "extern __shared__ unsigned char smem[];" => "HIP_DYNAMIC_SHARED( unsigned char, my_smem)"
    """
    output_string = input_string
    # 使用正则表达式替换匹配到的 extern __shared__ 语句
    output_string = RE_EXTERN_SHARED.sub(
        lambda inp: f"HIP_DYNAMIC_SHARED({inp.group(1) or ''} {inp.group(2)}, {inp.group(3)})", output_string)

    return output_string


def get_hip_file_path(rel_filepath, is_pytorch_extension=False):
    """
    返回经过 hip 化后的文件名
    """
    # 目前，一些 PyTorch 源文件是原地进行 HIP 化的。is_out_of_place 函数告诉我们是否是这种情况。
    assert not os.path.isabs(rel_filepath)
    if not is_pytorch_extension and not is_out_of_place(rel_filepath):
        return rel_filepath

    dirpath, filename = os.path.split(rel_filepath)
    root, ext = os.path.splitext(filename)

    # 这里是计划：
    #
    # 一般来说，我们需要使经过 HIP 化后的文件名与原文件名有所区别，
    # 避免覆盖原文件。
    #
    # PyTorch 和 Caffe2 中有很多不同的命名约定，但总体的做法是将 cuda/gpu 出现的地方替换为 hip，
    # 如果没有 cuda/gpu 的出现，则在文件名中加入 hip。
    #
    # 具体来说，我们执行以下操作：
    #
    #   - 如果目录名包含 "cuda"，将其替换为 "hip"，并且
    #
    #   - 如果文件名包含 "CUDA"，将其替换为 "HIP"，并且
    #
    #   - 总是将 '.cu' 替换为 '.hip'，因为这些文件包含需要通过 hip 编译器处理的 CUDA 内核
    #
    #   - 如果我们不是在 hip 化 PyTorch 扩展，且父目录名没有因上述转换而改变，将 "hip" 插入到文件路径中
    #     作为文件的直接父目录
    #
    #   - 如果我们正在 hip 化 PyTorch 扩展，且父目录名以及文件名（包括扩展名）没有因上述转换而改变，
    #     在文件名中插入 "_hip"
    #
    # 这些规则可能会根据需要进行调整，以支持其他命名约定。

    if ext == '.cu':
        ext = '.hip'

    orig_filename = filename
    orig_dirpath = dirpath

    # 将目录中的 'cuda' 替换为 'hip'
    dirpath = dirpath.replace('cuda', 'hip')
    # 将目录中的 'CUDA' 替换为 'HIP'
    dirpath = dirpath.replace('CUDA', 'HIP')
    # 将目录中的 'THC' 替换为 'THH'
    dirpath = dirpath.replace('THC', 'THH')

    # 将文件名中的 'cuda' 替换为 'hip'
    root = root.replace('cuda', 'hip')
    # 将字符串中的 'CUDA' 替换为 'HIP'
    root = root.replace('CUDA', 'HIP')
    # 处理特殊情况：处理 caffe2/core/THCCachingAllocator
    if dirpath != "caffe2/core":
        # 将字符串中的 'THC' 替换为 'THH'
        root = root.replace('THC', 'THH')

    # 如果不是 PyTorch 扩展且目录路径未改变，则在目录路径后加上 'hip'
    if not is_pytorch_extension and dirpath == orig_dirpath:
        dirpath = os.path.join(dirpath, 'hip')

    # 如果是 PyTorch 扩展且目录路径未改变，并且根加上扩展名等于原始文件名，则在根后加上 '_hip'
    if is_pytorch_extension and dirpath == orig_dirpath and (root + ext) == orig_filename:
        root = root + "_hip"

    # 返回连接后的目录路径、根和扩展名的完整路径
    return os.path.join(dirpath, root + ext)
def is_out_of_place(rel_filepath):
    # 断言相对文件路径不是绝对路径
    assert not os.path.isabs(rel_filepath)
    # 如果文件路径以"torch/"开头，则认为不是“out of place”
    if rel_filepath.startswith("torch/"):
        return False
    # 如果文件路径以"third_party/nvfuser/"开头，则认为不是“out of place”
    if rel_filepath.startswith("third_party/nvfuser/"):
        return False
    # 如果文件路径以"tools/autograd/templates/"开头，则认为不是“out of place”
    if rel_filepath.startswith("tools/autograd/templates/"):
        return False
    # 否则认为是“out of place”
    return True


# Keep this synchronized with includes/ignores in build_amd.py
def is_pytorch_file(rel_filepath):
    # 断言相对文件路径不是绝对路径
    assert not os.path.isabs(rel_filepath)
    # 如果文件路径以"aten/"开头
    if rel_filepath.startswith("aten/"):
        # 如果文件路径以"aten/src/ATen/core/"开头，则认为不是PyTorch文件
        if rel_filepath.startswith("aten/src/ATen/core/"):
            return False
        # 否则认为是PyTorch文件
        return True
    # 如果文件路径以"torch/"开头，则认为是PyTorch文件
    if rel_filepath.startswith("torch/"):
        return True
    # 如果文件路径以"third_party/nvfuser/"开头，则认为是PyTorch文件
    if rel_filepath.startswith("third_party/nvfuser/"):
        return True
    # 如果文件路径以"tools/autograd/templates/"开头，则认为是PyTorch文件
    if rel_filepath.startswith("tools/autograd/templates/"):
        return True
    # 否则认为不是PyTorch文件
    return False


def is_cusparse_file(rel_filepath):
    # 如果是PyTorch文件，并且文件路径中包含"sparse"，则认为是cusparse文件
    if is_pytorch_file(rel_filepath):
        return "sparse" in rel_filepath.lower()
    # 否则不是cusparse文件
    return False


def is_special_file(rel_filepath):
    # 如果是PyTorch文件
    if is_pytorch_file(rel_filepath):
        # 如果文件路径中包含"sparse"，则认为是特殊文件
        if "sparse" in rel_filepath.lower():
            return True
        # 如果文件路径中包含"linalg"，并且不包含"batchlinearalgebralibblas"，则认为是特殊文件
        elif "linalg" in rel_filepath.lower():
            if "batchlinearalgebralibblas" in rel_filepath.lower():
                return False  # 不对这个特定的linalg cublas文件使用特殊映射
            return True
    # 否则不是特殊文件
    return False


def is_caffe2_gpu_file(rel_filepath):
    # 断言相对文件路径不是绝对路径
    assert not os.path.isabs(rel_filepath)
    # 如果文件路径以"c10/cuda"开头，则认为是caffe2的GPU文件
    if rel_filepath.startswith("c10/cuda"):
        return True
    # 获取文件名
    filename = os.path.basename(rel_filepath)
    # 获取文件扩展名
    _, ext = os.path.splitext(filename)
    # 如果文件名中包含'gpu'，或者扩展名是'.cu'或'.cuh'，并且文件名中不包含'cudnn'，则认为是caffe2的GPU文件
    return ('gpu' in filename or ext in ['.cu', '.cuh']) and ('cudnn' not in filename)


class TrieNode:
    """A Trie node whose children are represented as a directory of char: TrieNode.
       A special char '' represents end of word
    """

    def __init__(self):
        # 初始化Trie节点，子节点用字典表示
        self.children = {}


class Trie:
    """Creates a Trie out of a list of words. The trie can be exported to a Regex pattern.
    The corresponding Regex should match much faster than a simple Regex union."""

    def __init__(self):
        """Initialize the trie with an empty root node."""
        # 初始化Trie，根节点为空节点
        self.root = TrieNode()

    def add(self, word):
        """Add a word to the Trie. """
        node = self.root

        for char in word:
            # 如果字符不存在，则添加新节点
            node.children.setdefault(char, TrieNode())
            # 移动到下一个节点
            node = node.children[char]
        # 标记单词结束
        node.children[''] = True    # Mark the end of the word

    def dump(self):
        """Return the root node of Trie. """
        # 返回Trie的根节点
        return self.root

    def quote(self, char):
        """ Escape a char for regex. """
        # 对字符进行正则表达式转义
        return re.escape(char)
    def search(self, word):
        """在 Trie 中搜索是否存在单词 word。
        如果存在返回 True，否则返回 False"""
        node = self.root  # 从 Trie 的根节点开始搜索
        for char in word:
            if char in node.children:
                node = node.children[char]  # 移动到下一个字符节点
            else:
                return False  # 如果字符不在子节点中，返回 False

        # 确保检查到单词结束标志
        return '' in node.children  # 返回当前节点的子节点中是否包含空字符

    def _pattern(self, root):
        """将 Trie 转换为正则表达式模式"""
        node = root  # 使用传入的根节点开始处理

        if "" in node.children and len(node.children.keys()) == 1:
            return None  # 如果只有一个子节点且为空字符，返回 None

        alt = []    # 存储备选模式
        cc = []     # 存储字符到字符类
        q = 0       # 用于表示单词结束的节点
        for char in sorted(node.children.keys()):
            if isinstance(node.children[char], TrieNode):
                try:
                    recurse = self._pattern(node.children[char])  # 递归处理子节点
                    alt.append(self.quote(char) + recurse)  # 将处理结果添加到备选模式中
                except Exception:
                    cc.append(self.quote(char))  # 如果处理异常，将字符转义后添加到字符类中
            else:
                q = 1  # 发现直接字符，设置 q 为 1
        cconly = not len(alt) > 0  # 判断是否只有字符类

        if len(cc) > 0:
            if len(cc) == 1:
                alt.append(cc[0])  # 如果字符类只有一个字符，直接添加到备选模式中
            else:
                alt.append('[' + ''.join(cc) + ']')  # 否则将字符类合并为字符类模式

        if len(alt) == 1:
            result = alt[0]  # 如果备选模式只有一个，直接使用该模式
        else:
            result = "(?:" + "|".join(alt) + ")"  # 否则将备选模式拼接为 OR 连接的组合模式

        if q:
            if cconly:
                result += "?"  # 如果存在单词结束节点且只有字符类，添加可选匹配
            else:
                result = f"(?:{result})?"  # 否则将整个模式设置为可选匹配的非捕获组

        return result  # 返回最终的正则表达式模式

    def pattern(self):
        """导出 Trie 为正则表达式模式。"""
        return self._pattern(self.root)  # 调用 _pattern 方法导出以根节点为起点的正则表达式模式

    def export_to_regex(self):
        """导出 Trie 为正则表达式模式。"""
        return self._pattern(self.root)  # 调用 _pattern 方法导出以根节点为起点的正则表达式模式
CAFFE2_TRIE = Trie()
CAFFE2_MAP = {}
PYTORCH_TRIE = Trie()
PYTORCH_MAP: Dict[str, object] = {}

# 在 PyTorch 中，我们将 cuBLAS 映射到 rocBLAS，将 cuSPARSE 映射到 hipSPARSE。注意前缀 roc 和 hip 的区别。
# 'hip' API 提供了更直接的 CUDA 友好映射，但直接调用 rocBLAS 有更好的性能。
# 不幸的是，roc* 类型和 hip* 类型不同，比如 rocblas_float_complex 和 hipComplex。
# 在 SPARSE 的情况下，我们必须使用 hip 类型的复数代替 roc 类型，
# 但 pytorch 的映射假定使用 roc。因此，我们创建了一个新的 SPARSE 映射，优先级更高。
# 其映射将首先触发，并且仅当发生未命中时，才会执行较低优先级的 pytorch 映射。
# 当文件名中包含 "sparse" 时，优先使用标记为 API_SPARSE 的映射而不是其他选择。
# 同样地，包含 "linalg" 的文件需要 rocBLAS -> hipSOLVER 的特殊处理。
PYTORCH_SPECIAL_MAP = {}

for mapping in CUDA_TO_HIP_MAPPINGS:
    assert isinstance(mapping, Mapping)
    for src, value in mapping.items():
        dst = value[0]
        meta_data = value[1:]
        if constants.API_CAFFE2 not in meta_data:
            PYTORCH_TRIE.add(src)
            # 如果 src 已经在 PYTORCH_MAP 中，并且 dst 属于 API_SPECIAL
            # 不要覆盖 PYTORCH_MAP，单独存储 dst
            if constants.API_SPECIAL in meta_data and PYTORCH_MAP.get(src, ""):
                PYTORCH_SPECIAL_MAP[src] = dst
            else:
                PYTORCH_MAP[src] = dst
        if constants.API_PYTORCH not in meta_data and constants.API_SPECIAL not in meta_data:
            CAFFE2_TRIE.add(src)
            CAFFE2_MAP[src] = dst

RE_CAFFE2_PREPROCESSOR = re.compile(CAFFE2_TRIE.export_to_regex())
RE_PYTORCH_PREPROCESSOR = re.compile(fr'(?<=\W)({PYTORCH_TRIE.export_to_regex()})(?=\W)')

RE_QUOTE_HEADER = re.compile(r'#include "([^"]+)"')
RE_ANGLE_HEADER = re.compile(r'#include <([^>]+)>')
RE_THC_GENERIC_FILE = re.compile(r'#define THC_GENERIC_FILE "([^"]+)"')
RE_CU_SUFFIX = re.compile(r'\.cu\b')  # 注意不要匹配到 .cuh

"""
返回一个 HipifyResult 对象，包括以下详细信息：
    "hipified_path" : hipified 源文件的绝对路径
    "status"        : "ok"      如果成功写入 hipified 文件
                      "skipped" 如果已经存在相同的 hipified 文件或无法写入 hipified 文件
                      "ignored" 如果源文件本身已经是 hipified 文件或不应该进行 hipification
    "current_state" : 如果源文件首次准备好进行 hipification，则为 CurrentState.INITIALIZED
                      如果源文件完成 hipification 进程，则为 CurrentState.DONE
"""
def preprocessor(
        output_directory: str,
        filepath: str,
        all_files: Iterable,
        header_include_dirs: Iterable,
        stats: Dict[str, List],
        hip_clang_launch: bool,
        is_pytorch_extension: bool,
        clean_ctx: GeneratedFileCleaner,
        show_progress: bool) -> HipifyResult:
    """ Executes the CUDA -> HIP conversion on the specified file. """
    # 获取文件的绝对路径
    fin_path = os.path.abspath(os.path.join(output_directory, filepath))
    # 获取已经进行过hipify处理的结果对象
    hipify_result = HIPIFY_FINAL_RESULT[fin_path]
    # 如果文件路径不在给定的所有文件列表中，则标记为不需要进行hipify转换
    if filepath not in all_files:
        hipify_result.hipified_path = None
        hipify_result.status = "[ignored, not to be hipified]"
        hipify_result.current_state = CurrentState.DONE
        return hipify_result

    # 计算相对路径
    rel_filepath = os.path.relpath(filepath, output_directory)

    # 使用UTF-8编码打开文件
    with open(fin_path, encoding='utf-8') as fin:
        # 如果文件的第一行是特定的标记，表示已经进行了hipify处理，则标记为不需要处理
        if fin.readline() == HIPIFY_C_BREADCRUMB:
            hipify_result.hipified_path = None
            hipify_result.status = "[ignored, input is hipified output]"
            hipify_result.current_state = CurrentState.DONE
            return hipify_result
        fin.seek(0)
        # 读取整个文件内容
        output_source = fin.read()

    # 保存原始的文件内容
    orig_output_source = output_source

    # 生成hip文件的输出路径，需要使用相对路径
    fout_path = os.path.abspath(os.path.join(output_directory, get_hip_file_path(rel_filepath, is_pytorch_extension)))
    # 如果输出路径的父目录不存在，则创建父目录
    if not os.path.exists(os.path.dirname(fout_path)):
        clean_ctx.makedirs(os.path.dirname(fout_path))

    # 对于PyTorch扩展，使用PyTorch的预处理器替换CUDA特定的代码
    def pt_repl(m):
        return PYTORCH_MAP[m.group(0)]

    def pt_special_repl(m):
        # 首先检查特殊映射表，如果未命中则使用PyTorch映射
        return PYTORCH_SPECIAL_MAP.get(m.group(0), pt_repl(m))

    if is_pytorch_extension:
        output_source = RE_PYTORCH_PREPROCESSOR.sub(pt_repl, output_source)
    else:
        # 对于特殊文件和普通PyTorch文件，分别使用特殊或通用的PyTorch预处理器替换CUDA代码
        if is_special_file(rel_filepath):
            output_source = RE_PYTORCH_PREPROCESSOR.sub(pt_special_repl, output_source)
        elif is_pytorch_file(rel_filepath):
            output_source = RE_PYTORCH_PREPROCESSOR.sub(pt_repl, output_source)
        else:
            # 对于其他情况，使用Caffe2的预处理器替换CUDA代码
            def c2_repl(m):
                return CAFFE2_MAP[m.group(0)]
            output_source = RE_CAFFE2_PREPROCESSOR.sub(c2_repl, output_source)

    # 替换文件中的头文件包含语句
    output_source = RE_QUOTE_HEADER.sub(mk_repl('#include "{0}"', True), output_source)
    output_source = RE_ANGLE_HEADER.sub(mk_repl('#include <{0}>', False), output_source)
    output_source = RE_THC_GENERIC_FILE.sub(mk_repl('#define THC_GENERIC_FILE "{0}"'), output_source)

    # 如果文件名以'CMakeLists.txt'结尾，则替换相关内容为HIP相关的
    if filepath.endswith('CMakeLists.txt'):
        output_source = output_source.replace('CUDA', 'HIP')
        output_source = output_source.replace('THC', 'THH')
        output_source = RE_CU_SUFFIX.sub('.hip', output_source)

    # 执行核函数启动的替换操作
    # 如果 hip_clang_launch 为假，执行下面的代码块
    if not hip_clang_launch:
        # 调用 processKernelLaunches 函数处理 output_source，传入 stats 参数
        output_source = processKernelLaunches(output_source, stats)

    # 如果文件路径以 .cu 或者 .cuh 结尾，并且文件路径中不包含 "PowKernel" 字符串
    if (filepath.endswith((".cu", ".cuh"))) and "PowKernel" not in filepath:
        # 调用 replace_math_functions 函数替换 output_source 中的数学函数
        output_source = replace_math_functions(output_source)

    # 调用 hip_header_magic 函数处理 output_source，添加 HIP 头部信息
    output_source = hip_header_magic(output_source)

    # 替换 extern __shared__ 关键字
    # 注意：在从 hcc 迁移到 hipclang 后不再需要这一步骤
    # output_source = replace_extern_shared(output_source)

    # 如果是 PyTorch 扩展文件，并且原始输出和当前输出相同，并且输出路径的目录未改变
    if (
        is_pytorch_extension
        and orig_output_source == output_source
        and os.path.dirname(fin_path) == os.path.dirname(fout_path)
    ):
        # 设置 hipify_result 的路径和状态信息
        hipify_result.hipified_path = fin_path
        hipify_result.status = "[skipped, no changes]"
        hipify_result.current_state = CurrentState.DONE
        return hipify_result

    # 如果输入路径不等于输出路径，并且输入文件扩展名匹配指定的扩展名
    if fin_path != fout_path and match_extensions(fin_path, (".cu", ".cuh", ".c", ".cc", ".cpp", ".h", ".hpp")):
        # 在 output_source 前添加 HIPIFY_C_BREADCRUMB 标记
        output_source = HIPIFY_C_BREADCRUMB + output_source

    # 决定是否执行写入操作
    do_write = True
    # 如果输出路径已经存在
    if os.path.exists(fout_path):
        # 用 utf-8 编码打开输出文件，并检查是否需要写入新内容
        with open(fout_path, encoding='utf-8') as fout_old:
            do_write = fout_old.read() != output_source

    # 如果需要写入新内容
    if do_write:
        try:
            # 使用 clean_ctx.open 打开输出文件，以写入模式写入 output_source
            with clean_ctx.open(fout_path, 'w', encoding='utf-8') as fout:
                fout.write(output_source)
            # 设置 hipify_result 的路径和状态信息
            hipify_result.hipified_path = fout_path
            hipify_result.status = "[ok]"
            hipify_result.current_state = CurrentState.DONE
            return hipify_result
        # 处理权限错误异常
        except PermissionError as e:
            # 输出错误信息到标准错误流
            print(f'{bcolors.WARNING}Failed to save {fout_path} with "{e.strerror}", leaving {fin_path} unchanged.{bcolors.ENDC}',
                  file=sys.stderr)
            # 设置 hipify_result 的路径和状态信息
            hipify_result.hipified_path = fin_path
            hipify_result.status = "[skipped, no permissions]"
            hipify_result.current_state = CurrentState.DONE
            return hipify_result
    else:
        # 设置 hipify_result 的路径和状态信息
        hipify_result.hipified_path = fout_path
        hipify_result.status = "[skipped, already hipified]"
        hipify_result.current_state = CurrentState.DONE
        return hipify_result
# 替换文件中特定字符串为指定字符串，支持严格模式和非严格模式
def file_specific_replacement(filepath, search_string, replace_string, strict=False):
    # 打开文件并读取其内容，支持读写模式
    with openf(filepath, "r+") as f:
        contents = f.read()
        # 如果是严格模式，使用正则表达式进行单词边界替换
        if strict:
            contents = re.sub(fr'\b({re.escape(search_string)})\b', lambda x: replace_string, contents)
        else:
            # 否则直接替换所有匹配的字符串
            contents = contents.replace(search_string, replace_string)
        # 将文件指针移到文件开头
        f.seek(0)
        # 将修改后的内容写入文件
        f.write(contents)
        # 截断文件，确保没有多余内容
        f.truncate()


# 在文件开头添加指定的头文件
def file_add_header(filepath, header):
    # 打开文件并读取其内容，支持读写模式
    with openf(filepath, "r+") as f:
        contents = f.read()
        # 如果头文件不是以 '<' 开头且不是以 '>' 结尾，则添加双引号
        if header[0] != "<" and header[-1] != ">":
            header = f'"{header}"'
        # 在文件开头添加包含指定头文件的预处理指令
        contents = (f'#include {header} \n') + contents
        # 将文件指针移到文件开头
        f.seek(0)
        # 将修改后的内容写入文件
        f.write(contents)
        # 截断文件，确保没有多余内容
        f.truncate()


def fix_static_global_kernels(in_txt):
    """修复HIP中静态全局内核导致的编译错误。"""
    # 替换输入文本中的 ' __global__ static' 为 '__global__'
    in_txt = in_txt.replace(" __global__ static", "__global__")
    return in_txt


# 匹配 #include 开头的预处理指令的正则表达式
RE_INCLUDE = re.compile(r"#include .*\n")


def extract_arguments(start, string):
    """返回即将到来的函数参数闭包中的参数列表。
       例如：
       输入字符串：'(blocks, threads, 0, THCState_getCurrentStream(state))'
       输出参数列表：
           [{'start': 1, 'end': 7},
            {'start': 8, 'end': 16},
            {'start': 17, 'end': 19},
            {'start': 20, 'end': 53}]
    """

    arguments = []
    closures = {
        "<": 0,
        "(": 0
    }
    current_position = start
    argument_start_pos = current_position + 1

    # 查找最终的括号闭合位置
    while current_position < len(string):
        if string[current_position] == "(":
            closures["("] += 1
        elif string[current_position] == ")":
            closures["("] -= 1
        elif string[current_position] == "<":
            closures["<"] += 1
        elif string[current_position] == ">" and string[current_position - 1] != "-" and closures["<"] > 0:
            closures["<"] -= 1

        # 完成所有参数的查找
        if closures["("] == 0 and closures["<"] == 0:
            # 添加最后一个参数
            arguments.append({"start": argument_start_pos, "end": current_position})
            break

        # 完成当前参数的查找
        if closures["("] == 1 and closures["<"] == 0 and string[current_position] == ",":
            arguments.append({"start": argument_start_pos, "end": current_position})
            argument_start_pos = current_position + 1

        current_position += 1

    return arguments


def str2bool(v):
    """ArgumentParser 不支持 type=bool。因此，这个辅助方法将可能的字符串类型转换为 True / False。"""
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        # 如果无法识别的输入字符串，则引发参数解析错误
        raise argparse.ArgumentTypeError('Boolean value expected.')


def hipify(
    project_directory: str,
    show_detailed: bool = False,
    # 定义文件扩展名的可迭代对象，默认包括CUDA相关文件及C/C++文件
    extensions: Iterable = (".cu", ".cuh", ".c", ".cc", ".cpp", ".h", ".in", ".hpp"),
    
    # 定义头文件扩展名的可迭代对象，仅包括.h、.hpp和.cuh
    header_extensions: Iterable = (".cuh", ".h", ".hpp"),
    
    # 指定输出目录的路径，如果为空字符串，则输出到当前工作目录
    output_directory: str = "",
    
    # 定义头文件包含目录的可迭代对象，用于指定额外的头文件搜索路径
    header_include_dirs: Iterable = (),
    
    # 定义需要包含的文件的可迭代对象，缺省为包含所有文件
    includes: Iterable = ('*',),
    
    # 定义额外需要处理的文件的可迭代对象，通常是一些非标准的文件
    extra_files: Iterable = (),
    
    # 是否仅适用于“out-of-place”模式，缺省为False，表示可以在原地修改文件
    out_of_place_only: bool = False,
    
    # 定义需要忽略的文件列表的可迭代对象，用于排除不需要处理的文件
    ignores: Iterable = (),
    
    # 是否显示处理进度，缺省为True，表示显示进度信息
    show_progress: bool = True,
    
    # 是否使用Hipify处理clang启动器，缺省为False，通常与CUDA相关
    hip_clang_launch: bool = False,
    
    # 是否为PyTorch扩展，缺省为False，用于指示特定的处理逻辑
    is_pytorch_extension: bool = False,
    
    # 是否仅处理额外的Hipify文件，缺省为False，表示处理所有文件
    hipify_extra_files_only: bool = False,
    
    # 可选的生成文件清理器的上下文，用于清理生成的临时文件等
    clean_ctx: Optional[GeneratedFileCleaner] = None
) -> HipifyFinalResult:
    # 如果未指定项目目录，则使用当前工作目录
    if project_directory == "":
        project_directory = os.getcwd()

    # 检查项目目录是否存在
    if not os.path.exists(project_directory):
        print("The project folder specified does not exist.")
        sys.exit(1)

    # 如果未指定输出目录，则使用默认的 _amd 后缀作为输出目录名
    if not output_directory:
        project_directory.rstrip("/")
        output_directory = project_directory + "_amd"

    # 如果项目目录和输出目录不同，则更新 includes 和 ignores 列表中的路径
    if project_directory != output_directory:
        includes = [include.replace(project_directory, output_directory) for include in includes]
        ignores = [ignore.replace(project_directory, output_directory) for ignore in ignores]

    # 如果输出目录不存在，则递归复制项目目录到输出目录
    if not os.path.exists(output_directory):
        shutil.copytree(project_directory, output_directory)

    # 获取所有符合条件的文件列表
    all_files = list(matched_files_iter(output_directory, includes=includes,
                                        ignores=ignores, extensions=extensions,
                                        out_of_place_only=out_of_place_only,
                                        is_pytorch_extension=is_pytorch_extension))
    all_files_set = set(all_files)

    # 将额外的文件添加到 all_files 列表中
    for f in extra_files:
        # 如果额外文件路径不是绝对路径，则将其加入到输出目录中
        if not os.path.isabs(f):
            f = os.path.join(output_directory, f)
        # 如果文件不在 all_files_set 中，则添加到 all_files 列表中
        if f not in all_files_set:
            all_files.append(f)

    # 遍历 header_include_dirs 中的目录，确保所有头文件都被处理
    from pathlib import Path
    for header_include_dir in header_include_dirs:
        if os.path.isabs(header_include_dir):
            header_include_dir_path = Path(header_include_dir)
        else:
            header_include_dir_path = Path(os.path.join(output_directory, header_include_dir))
        # 遍历目录下的所有文件和子目录
        for path in header_include_dir_path.rglob('*'):
            # 如果是文件且符合条件，则将其路径加入 all_files 列表中
            if (
                path.is_file()
                and _fnmatch(str(path), includes)
                and (not _fnmatch(str(path), ignores))
                and match_extensions(path.name, header_extensions)
            ):
                all_files.append(str(path))

    # 如果 clean_ctx 未指定，则创建一个 GeneratedFileCleaner 对象
    if clean_ctx is None:
        clean_ctx = GeneratedFileCleaner(keep_intermediates=True)

    # 预处理统计信息的字典
    stats: Dict[str, List] = {"unsupported_calls": [], "kernel_launches": []}

    # 对所有文件进行预处理，并保存结果
    for filepath in (all_files if not hipify_extra_files_only else extra_files):
        preprocess_file_and_save_result(output_directory, filepath, all_files, header_include_dirs,
                                        stats, hip_clang_launch, is_pytorch_extension, clean_ctx, show_progress)

    # 打印预处理完成的消息
    print(bcolors.OKGREEN + "Successfully preprocessed all matching files." + bcolors.ENDC, file=sys.stderr)

    # 如果设置了 show_detailed 标志，则计算并显示详细统计信息
    if show_detailed:
        compute_stats(stats)

    # 返回最终的 hipify 结果
    return HIPIFY_FINAL_RESULT
```