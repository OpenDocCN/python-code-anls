# `.\pytorch\torch\_dynamo\codegen.py`

```py
# mypy: allow-untyped-defs
# 导入需要的模块和库
import collections  # 导入collections模块，用于创建特定类型的容器数据类型
import dataclasses  # 导入dataclasses模块，用于创建和操作数据类
import re  # 导入re模块，用于处理正则表达式的操作
import sys  # 导入sys模块，提供对Python运行时环境的访问
import types  # 导入types模块，用于操作Python对象的类型

import torch.nn  # 导入torch.nn模块，用于神经网络构建和操作
from . import utils  # 从当前包中导入utils模块

from .bytecode_transformation import (  # 导入字节码转换相关的函数和类
    add_push_null,
    create_call_function,
    create_call_method,
    create_dup_top,
    create_instruction,
    create_load_method,
    create_rot_n,
    Instruction,
)
from .exc import unimplemented  # 从当前包中导入unimplemented异常类
from .source import AttrSource, Source  # 从source模块中导入AttrSource和Source类
from .utils import is_safe_constant, rot_n_helper  # 从utils模块中导入特定函数
from .variables.base import VariableTracker  # 从variables包中导入VariableTracker类
from .variables.nn_module import NNModuleVariable  # 从nn_module模块中导入NNModuleVariable类
from .variables.tensor import (  # 从tensor模块中导入多个变量相关的类
    NumpyNdarrayVariable,
    SymNodeVariable,
    TensorVariable,
    UnspecializedPythonVariable,
)
from .variables.torch_function import TensorWithTFOverrideVariable  # 从torch_function模块中导入TensorWithTFOverrideVariable类


@dataclasses.dataclass
class GraphOutputEntry:
    """
    数据类，用于表示图输出的条目

    Attributes:
        index (int): 条目索引
        variable (VariableTracker): 相关联的变量追踪器
    """
    index: int  # 索引值
    variable: VariableTracker  # 变量追踪器对象


class PyCodegen:
    """
    Python字节码构造的辅助类
    """

    def __init__(
        self,
        tx=None,  # tx参数，默认为None
        root: Optional[torch.nn.Module] = None,  # root参数，默认为None，可选的torch.nn.Module对象
        graph_output_var: Optional[str] = None,  # graph_output_var参数，默认为None，可选的字符串类型
        tempvars=None,  # tempvars参数，默认为None
    ):
        """
        初始化方法

        Args:
            tx: 传输对象，用于字节码转换，默认为None
            root (Optional[torch.nn.Module]): 根神经网络模块对象，可选
            graph_output_var (Optional[str]): 图输出变量，可选的字符串
            tempvars: 临时变量，用于存储临时数据，默认为None
        """
        self.root = root  # 初始化root属性
        self.top_of_stack: Optional[VariableTracker] = None  # 栈顶变量追踪器，初始为None
        self.uses: Counter[VariableTracker] = collections.Counter()  # 变量使用计数器
        self.graph_outputs: Dict[int, GraphOutputEntry] = {}  # 图输出字典，索引到GraphOutputEntry的映射
        self._output: List[Instruction] = []  # 指令列表，用于存储指令对象
        self.tempvars = tempvars or {}  # 临时变量字典，初始化为空字典或给定的tempvars
        self.tx = tx  # 传输对象
        self.graph_output_var = graph_output_var  # 图输出变量
        self.code_options = self.tx.output.code_options  # 代码选项，从tx对象中获取输出选项
        self.cell_and_freevars = self.tx.cell_and_freevars  # 单元和自由变量，从tx对象中获取
        self.new_var = self.tx.output.new_var  # 新变量，从tx对象中获取输出的新变量
        self.mutable_side_effects_from_source = False  # 来源可变的副作用，默认为False
        self.value_from_source: bool = True  # 来源值为True，默认为True

    def restore_stack(self, stack_values, *, value_from_source=True):
        """
        恢复堆栈方法

        Args:
            stack_values: 堆栈中的值
            value_from_source (bool): 来源值，是否为True，默认为True
        """
        prior = self.mutable_side_effects_from_source  # 保存之前的来源可变副作用状态
        self.mutable_side_effects_from_source = True  # 设置来源可变副作用为True
        prev = self.value_from_source  # 保存之前的来源值
        self.value_from_source &= value_from_source  # 更新来源值
        try:
            self.foreach(stack_values)  # 对堆栈中的值进行迭代处理
        finally:
            self.mutable_side_effects_from_source = prior  # 恢复之前的来源可变副作用状态
            self.value_from_source = prev  # 恢复之前的来源值

    def graph_output_vars(self):
        """
        返回图输出的变量列表方法

        Returns:
            List[VariableTracker]: 图输出的变量列表
        """
        return [x.variable for x in self.graph_outputs.values()]  # 返回图输出字典中所有条目的变量列表

    def call_reconstruct(self, value):
        """
        调用重构方法

        Args:
            value: 需要重构的值
        """
        res = value.reconstruct(self)  # 调用值的重构方法
        assert res is None, f"reconstruct!=None {value}"  # 断言重构结果为None，否则输出错误信息
    def add_push_null(self, gen_fn):
        """
        `gen_fn` generates instructions via PyCodegen methods
        that push a single callable to the stack.

        `add_push_null` pushes a NULL to the stack before or after the
        instructions generated by `gen_fn`, depending on Python version.

        Will attempt to use the NULL push bit for instructions
        with such bits (LOAD_GLOBAL 3.11+, LOAD_ATTR 3.12+, LOAD_SUPER_ATTR).
        """
        # 记录当前输出的长度
        old_len = len(self._output)
        # 生成指令，将其添加到 self._output
        gen_fn()
        # 获取新添加的指令
        added_insts = self._output[old_len:]
        # 删除原有的指令
        del self._output[old_len:]
        # 向 self._output 中扩展添加 NULL 指令
        self._output.extend(add_push_null(added_insts))
        # 如果 Python 版本大于等于 3.13，清除栈顶元素
        if sys.version_info >= (3, 13):
            # 栈顶元素设为 NULL
            self.clear_tos()

    def add_graph_output(self, value):
        # 计算 value 的 id 作为键
        graph_outputs_key = id(value.as_proxy())
        # 如果键不在 graph_outputs 中，添加新的 GraphOutputEntry
        if graph_outputs_key not in self.graph_outputs:
            self.graph_outputs[graph_outputs_key] = GraphOutputEntry(
                len(self.graph_outputs), value
            )
        # 返回 graph_outputs_key
        return graph_outputs_key

    def load_graph_output(self, index):
        # 将 self._output 赋值给 output
        output = self._output
        # 添加加载指令，加载 graph_output_var
        output.append(self.create_load(self.graph_output_var))
        # 添加加载常量的指令，加载 index
        output.append(self._create_load_const(index))
        # 添加二元子脚本操作指令
        output.append(create_instruction("BINARY_SUBSCR"))

    def add_cache(self, value):
        # 创建新的变量名 var
        var = self.new_var()
        # 将 value 和 var 关联存储到 tempvars 中
        self.tempvars[value] = var
        # 如果 value 是可变的局部变量，也将其与 var 关联存储到 tempvars 中
        if value.mutable_local:
            self.tempvars[value.mutable_local] = var
        # 将创建存储指令的结果添加到 self._output 中
        self._output.append(self.create_store(var))

    def foreach(self, items):
        # 遍历 items 中的每一个元素 i，并调用 self(i)
        for i in items:
            self(i)

    def setup_globally_cached(self, name, value):
        """Store value in a new global"""
        # 根据 name 规范化为合法的全局变量名
        name = re.sub(r"[^a-zA-Z0-9_]+", "_", name)
        # 获取当前线程的全局变量字典 f_globals
        f_globals = self.tx.f_globals
        # 如果 name 已经在 f_globals 中，确保其值与 value 的 id 相同
        if name in f_globals:
            assert id(f_globals[name]) == id(value)
        else:
            # 将 value 存储为新的全局变量
            f_globals[name] = value
        # 返回创建加载全局变量指令的结果列表
        return [self.create_load_global(name, add=True)]

    def clear_tos(self):
        # 将栈顶元素设为 None
        self.top_of_stack = None

    def append_output(self, inst):
        # 断言 inst 是指令的实例
        assert isinstance(inst, Instruction)
        # 将 inst 添加到 self._output 中
        self._output.append(inst)
        # 清除栈顶元素
        self.clear_tos()

    def extend_output(self, insts):
        # 断言 insts 中的每一个元素都是指令的实例
        assert all(isinstance(x, Instruction) for x in insts)
        # 将 insts 中的指令扩展添加到 self._output 中
        self._output.extend(insts)
        # 清除栈顶元素
        self.clear_tos()

    def get_instructions(self) -> List[Instruction]:
        # 返回 self._output 中的指令列表
        return self._output

    def create_load(self, name) -> Instruction:
        # 如果 name 在 cell_and_freevars() 中，创建加载闭包变量指令
        if name in self.cell_and_freevars():
            return create_instruction("LOAD_DEREF", argval=name)
        # 否则，断言 name 在 co_varnames 中，若不在则报错
        assert name in self.code_options["co_varnames"], f"{name} missing"
        # 创建加载局部变量指令
        return create_instruction("LOAD_FAST", argval=name)

    def create_load_closure(self, name) -> Instruction:
        # 断言 name 在 cell_and_freevars() 中
        assert name in self.cell_and_freevars()
        # 创建加载闭包变量指令
        return create_instruction("LOAD_CLOSURE", argval=name)
    # 创建一个存储指令，根据变量名确定是存储到闭包变量或者自由变量
    def create_store(self, name) -> Instruction:
        if name in self.cell_and_freevars():
            return create_instruction("STORE_DEREF", argval=name)
        # 断言确保变量名在代码对象的局部变量名列表中
        assert name in self.code_options["co_varnames"]
        return create_instruction("STORE_FAST", argval=name)

    # 创建一个加载全局变量的指令
    def create_load_global(self, name, add=False) -> Instruction:
        # 如果add为True，则更新输出的常量名称
        if add:
            self.tx.output.update_co_names(name)
        # 断言确保变量名在代码对象的全局变量名列表中，否则抛出异常
        assert name in self.code_options["co_names"], f"{name} not in co_names"
        return create_instruction("LOAD_GLOBAL", argval=name)

    # 创建一个加载常量的指令
    def create_load_const(self, value) -> Instruction:
        # 断言确保常量是安全的，防止不安全的常量被加载
        assert is_safe_constant(value), f"unsafe constant {value}"
        return self._create_load_const(value)

    # 私有方法：创建一个加载常量的指令
    def _create_load_const(self, value) -> Instruction:
        return create_instruction("LOAD_CONST", argval=value)

    # 创建一个加载常量的指令，作为加载输出的别名
    create_load_output = _create_load_const

    # 加载一个方法名，更新输出的常量名称
    def load_method(self, name):
        self.tx.output.update_co_names(name)
        self.append_output(create_load_method(name))

    # 调用一个方法，扩展输出为调用方法的指令序列
    def call_method(self, nargs):
        self.extend_output(create_call_method(nargs))

    # 创建一个加载属性的指令
    def create_load_attr(self, name) -> Instruction:
        # 如果属性名不在代码对象的全局变量名列表中，则将其添加进去
        if name not in self.code_options["co_names"]:
            self.code_options["co_names"] += (name,)
        return create_instruction("LOAD_ATTR", argval=name)

    # 加载一个属性，将创建加载属性的指令添加到输出中
    def load_attr(self, name):
        self.append_output(self.create_load_attr(name))

    # 创建加载多个属性的指令序列
    def create_load_attrs(self, names):
        return [self.create_load_attr(name) for name in names.split(".")]

    # 创建一个存储属性的指令
    def create_store_attr(self, name) -> Instruction:
        # 如果属性名不在代码对象的全局变量名列表中，则将其添加进去
        if name not in self.code_options["co_names"]:
            self.code_options["co_names"] += (name,)
        return create_instruction("STORE_ATTR", argval=name)

    # 存储一个属性，将创建存储属性的指令添加到输出中
    def store_attr(self, name):
        self.append_output(self.create_store_attr(name))

    # 加载函数名称，将全局函数名加载到堆栈的指定位置
    def load_function_name(self, fn_name, push_null, num_on_stack=0):
        """Load the global fn_name on the stack num_on_stack down"""
        output = []
        # 如果push_null为True且Python版本大于等于3.11，则添加推送空值指令
        if push_null and sys.version_info >= (3, 11):
            output.extend(add_push_null(self.create_load_global(fn_name, add=True)))
            if num_on_stack > 0:
                # 对堆栈进行旋转操作，使函数名位于预期的位置
                output.extend(
                    [
                        *self.rot_n(num_on_stack + 2),
                        *self.rot_n(num_on_stack + 2),
                    ]
                )
        else:
            # 否则，添加加载全局变量的指令，并对堆栈进行旋转操作
            output.extend(
                [
                    self.create_load_global(fn_name, add=True),
                    *self.rot_n(num_on_stack + 1),
                ]
            )
        return output
    def rot_n(self, n):
        try:
            # 尝试创建一个指定旋转次数的旋转字节码序列
            return create_rot_n(n)
        except AttributeError:
            # 如果指定的旋转字节码不存在，则生成相应的等效字节码序列
            return [
                create_instruction("BUILD_TUPLE", arg=n),  # 创建一个包含 n 个元素的元组
                self._create_load_const(rot_n_helper(n)),  # 载入旋转帮助函数的常量
                *create_rot_n(2),  # 创建默认的旋转两次的字节码序列
                create_instruction("CALL_FUNCTION_EX", arg=0),  # 调用函数扩展版本，无参数
                create_instruction("UNPACK_SEQUENCE", arg=n),  # 解包序列，将结果拆分为 n 个值
            ]

    def pop_null(self):
        # POP_TOP 指令无法用于 null，因此我们通过推送一个空操作函数、调用它（消耗 null），然后弹出结果来弹出 null
        assert sys.version_info >= (3, 11)
        return [
            self._create_load_const(lambda: None),  # 载入一个返回 None 的 lambda 函数
            *create_call_function(0, False),  # 调用一个函数，不推送空值
            create_instruction("POP_TOP"),  # 弹出栈顶元素
        ]

    def pop_top(self):
        self.append_output(create_instruction("POP_TOP"))  # 将 POP_TOP 指令添加到输出队列中

    def call_function(self, nargs: int, push_null: bool):
        self.extend_output(create_call_function(nargs, push_null=push_null))  # 扩展输出队列以调用函数

    def dup_top(self):
        self.append_output(create_dup_top())  # 将 DUP_TOP 指令添加到输出队列中

    def store(self, varname):
        self.append_output(self.create_store(varname))  # 将存储变量的指令添加到输出队列中

    def make_function_with_closure(
        self, fn_name: str, code: types.CodeType, push_null: bool, num_on_stack=0
    ):
        freevars = code.co_freevars
        assert freevars
        output = self._output

        def gen_fn():
            for var in freevars:
                assert var in self.cell_and_freevars()
                output.append(create_instruction("LOAD_CLOSURE", argval=var))  # 载入闭包变量

            output.append(create_instruction("BUILD_TUPLE", arg=len(freevars)))  # 创建包含闭包变量的元组
            output.append(self.create_load_const(code))  # 载入函数代码对象常量
            if sys.version_info < (3, 11):
                output.append(self.create_load_const(fn_name))  # 载入函数名称常量（Python版本小于3.11时）
            output.append(create_instruction("MAKE_FUNCTION", arg=0x08))  # 创建函数对象

        if push_null and sys.version_info >= (3, 11):
            self.add_push_null(gen_fn)  # 添加推送空值的函数调用
            output.extend(self.rot_n(num_on_stack + 2))  # 扩展输出队列以进行旋转操作
            output.extend(self.rot_n(num_on_stack + 2))  # 再次扩展以进行额外的旋转操作
        else:
            gen_fn()  # 生成函数对象
            output.extend(self.rot_n(num_on_stack + 1))  # 扩展输出队列以进行旋转操作

        self.clear_tos()  # 清除栈顶元素

    def create_load_python_module(self, mod) -> Instruction:
        """
        生成一个 LOAD_GLOBAL 指令，以获取给定的 Python 模块。
        """
        output = self.tx.output  # 获取输出对象
        global_scope = output.global_scope  # 获取全局作用域
        name = re.sub(r"^.*[.]", "", mod.__name__)  # 从模块名称中获取模块的简短名称
        if global_scope.get(name, None) is mod:
            return self.create_load_global(name, add=True)  # 如果模块已存在于全局作用域中，则创建加载全局模块指令
        prefix = f"___module_{name}"
        global_name = self.tx.output.install_global_by_id(prefix, mod)  # 安装全局模块并获取全局名称
        return self.create_load_global(global_name, add=True)  # 创建加载全局模块指令
    # 调用存储在 fn_name 中的生成代码函数
    def make_call_generated_code(self, fn_name: str) -> None:
        """Call the generated code function stored in fn_name"""
        # 将加载函数名的结果扩展到输出
        self.extend_output(self.load_function_name(fn_name, True))

        # 获取图参数
        graphargs = self.tx.output.graphargs
        # 遍历图参数
        for arg in graphargs:
            # 如果参数作为张量传递
            if arg.pass_arg_as_tensor:
                # 添加推送空值指令
                self.add_push_null(
                    # 将以下操作扩展到输出
                    lambda: self.extend_output(
                        [
                            # 创建加载 Python 模块的指令
                            self.create_load_python_module(torch),
                            # 创建加载属性 "as_tensor" 的指令
                            self.create_load_attr("as_tensor"),
                        ]
                    )
                )
                # 调用重构函数处理参数
                self.call_reconstruct(arg)
                # 扩展输出以创建函数调用指令
                self.extend_output(create_call_function(1, False))
            else:
                # 否则，直接调用重构函数处理参数
                self.call_reconstruct(arg)

        # 扩展输出以创建函数调用指令
        self.extend_output(create_call_function(len(graphargs), False))

    # 加载从模块 module_name 中的对象 object_name
    def load_import_from(self, module_name, object_name) -> None:
        self(AttrSource(self.tx.import_source(module_name), object_name))

    # 创建带有关键字参数的函数调用指令列表
    def create_call_function_kw(self, nargs, kw_names, push_null) -> List[Instruction]:
        if sys.version_info >= (3, 11):
            # 创建函数调用指令列表
            output = create_call_function(nargs, push_null)
            # 如果 Python 版本 >= 3.12
            if sys.version_info >= (3, 12):
                idx = -1
                expected_inst = "CALL"
            else:
                idx = -2
                expected_inst = "PRECALL"
            # 断言指令列表中指定位置的操作名称符合预期
            assert output[idx].opname == expected_inst
            # 创建关键字参数名称指令
            kw_names_inst = create_instruction("KW_NAMES", argval=kw_names)
            # 将关键字参数名称指令插入到指令列表中
            output.insert(idx, kw_names_inst)
            return output
        # 否则，创建普通函数调用指令列表
        return [
            self.create_load_const(kw_names),
            create_instruction("CALL_FUNCTION_KW", arg=nargs),
        ]

    # 创建删除操作指令
    def create_delete(self, value) -> Instruction:
        return create_instruction("DELETE_FAST", argval=value)
```