# `.\pytorch\benchmarks\instruction_counts\worker\main.py`

```
"""
File invoked through subprocess to actually carry out measurements.

`worker/main.py` is deliberately isolated from the rest of the benchmark
infrastructure. Other parts of the benchmark rely on this file, but
`worker/` has only one Python file and does not import ANYTHING from the rest
of the benchmark suite. The reason that this is important is that we can't
rely on paths to access the other files (namely `core.api`) since a source
command might change the CWD. It also helps keep startup time down by limiting
spurious definition work.

The life of a worker is very simple:
    It receives a file containing a `WorkerTimerArgs` telling it what to run,
    and writes a `WorkerOutput` result back to the same file.

Because this file only expects to run in a child context, error handling means
plumbing failures up to the caller, not raising in this process.
"""

# Import necessary modules for the script
import argparse               # 用于解析命令行参数
import dataclasses            # 用于定义数据类
import io                     # 提供核心的 Python I/O 功能
import os                     # 提供与操作系统交互的功能
import pickle                 # 用于 Python 对象的序列化和反序列化
import sys                    # 提供对 Python 解释器的访问和控制
import timeit                 # 用于测量小段代码执行时间的模块
import traceback              # 提供访问程序异常的堆栈跟踪的功能
from typing import Any, Tuple, TYPE_CHECKING, Union

# Conditional import based on TYPE_CHECKING for strict type checking
if TYPE_CHECKING:
    # Import specific modules needed for type checking
    from torch.utils.benchmark.utils.timer import Language, Timer
    from torch.utils.benchmark.utils.valgrind_wrapper.timer_interface import (
        CallgrindStats,
    )
else:
    # Import fallback modules if not in type checking mode
    from torch.utils.benchmark import CallgrindStats, Language, Timer

# Get the absolute path of the current script file
WORKER_PATH = os.path.abspath(__file__)


# =============================================================================
# == Interface ================================================================
# =============================================================================

# Minimum run time for measurements in seconds
MIN_RUN_TIME = 5

# Number of times to repeat each measurement for Callgrind
CALLGRIND_NUMBER = 100

# Number of repetitions for each Callgrind measurement
CALLGRIND_REPEATS = 5


@dataclasses.dataclass(frozen=True)
class WorkerTimerArgs:
    """Container for Timer constructor arguments.

    This dataclass serves two roles. First, it is a simple interface for
    defining benchmarks. (See core.api.GroupedStmts and core.api.GroupedModules
    for the advanced interfaces.) Second, it provides serialization for
    controlling workers. `Timer` is not pickleable, so instead the main process
    will pass `WorkerTimerArgs` instances to workers for processing.
    """

    stmt: str                  # 要运行的语句
    setup: str = "pass"        # 准备代码，缺省为 "pass"
    global_setup: str = ""     # 全局准备代码，缺省为空字符串
    num_threads: int = 1       # 线程数，缺省为 1
    language: Language = Language.PYTHON  # 使用的语言，默认为 Python


@dataclasses.dataclass(frozen=True)
class WorkerOutput:
    """Dataclass for the output of worker processes.

    This dataclass defines the structure of output generated by worker processes.
    It is used to serialize and transmit results back to the main process.
    """
    # 声明一个变量 wall_times，类型为元组，包含浮点数值，用于存储一组测量的墙钟时间数据。
    wall_times: Tuple[float, ...]
    
    # 声明一个变量 instructions，类型为元组，包含整数值，用于存储一组指令计数数据。
    instructions: Tuple[int, ...]
@dataclasses.dataclass(frozen=True)
class WorkerFailure:
    # 如果工作进程失败，我们附加异常的字符串内容，而不是异常对象本身。这样做有两个原因：
    #   1) 取决于抛出的类型，`e` 可能是可 pickle 的或不可 pickle 的
    #   2) 如果我们在主进程中重新抛出，我们会丢失真实的堆栈跟踪。
    failure_trace: str


class WorkerUnpickler(pickle.Unpickler):
    def find_class(self, module: str, name: str) -> Any:
        """为 pickle 解析导入。

        当主运行器从这个文件使用符号 `foo` 时，它将其视为 `worker.main.foo`。
        然而，工作进程（作为独立文件调用）将同一符号视为 `__main__.foo`。
        我们必须帮助 pickle 理解它们指的是同一个符号。
        """
        symbol_map = {
            # 只有被认可的接口枚举和数据类需要被映射。
            "WorkerTimerArgs": WorkerTimerArgs,
            "WorkerOutput": WorkerOutput,
            "WorkerFailure": WorkerFailure,
        }

        if name in symbol_map:
            return symbol_map[name]

        return super().find_class(module, name)

    def load_input(self) -> WorkerTimerArgs:
        result = self.load()
        assert isinstance(result, WorkerTimerArgs)
        return result

    def load_output(self) -> Union[WorkerTimerArgs, WorkerOutput, WorkerFailure]:
        """类型安全加载的便利方法。"""
        result = self.load()
        assert isinstance(result, (WorkerTimerArgs, WorkerOutput, WorkerFailure))
        return result


# =============================================================================
# == Execution ================================================================
# =============================================================================


def _run(timer_args: WorkerTimerArgs) -> WorkerOutput:
    timer = Timer(
        stmt=timer_args.stmt,
        setup=timer_args.setup or "pass",
        global_setup=timer_args.global_setup,
        # 在 GPU 构建和 C++ 片段上防止 NotImplementedError
        timer=timeit.default_timer,
        num_threads=timer_args.num_threads,
        language=timer_args.language,
    )

    m = timer.blocked_autorange(min_run_time=MIN_RUN_TIME)

    stats: Tuple[CallgrindStats, ...] = timer.collect_callgrind(
        number=CALLGRIND_NUMBER,
        collect_baseline=False,
        repeats=CALLGRIND_REPEATS,
        retain_out_file=False,
    )

    return WorkerOutput(
        wall_times=tuple(m.times),
        instructions=tuple(s.counts(denoise=True) for s in stats),
    )


def main(communication_file: str) -> None:
    result: Union[WorkerOutput, WorkerFailure]
    try:
        with open(communication_file, "rb") as f:
            timer_args: WorkerTimerArgs = WorkerUnpickler(f).load_input()
            assert isinstance(timer_args, WorkerTimerArgs)
        result = _run(timer_args)
    # 如果发生键盘中断（Ctrl+C），则退出程序
    except KeyboardInterrupt:
        sys.exit()

    # 如果发生任何其它异常
    except BaseException:
        # 创建一个字符串IO对象，用于存储异常的堆栈信息
        trace_f = io.StringIO()
        # 将异常的堆栈信息打印到trace_f中
        traceback.print_exc(file=trace_f)
        # 创建一个WorkerFailure对象，传入异常堆栈信息作为参数
        result = WorkerFailure(failure_trace=trace_f.getvalue())

    # 如果通信文件所在的目录不存在
    if not os.path.exists(os.path.split(communication_file)[0]):
        # 打印消息，说明当前工作进程是一个孤儿进程，父进程已经清理了工作目录，因此可以直接退出
        print(f"Orphaned worker {os.getpid()} exiting.")
        # 返回函数，结束执行
        return

    # 打开通信文件以二进制写入模式
    with open(communication_file, "wb") as f:
        # 使用pickle将result对象序列化并写入文件f中
        pickle.dump(result, f)
# 如果当前脚本被直接执行（而不是被导入到其他模块中），则执行以下代码块
if __name__ == "__main__":
    # 创建一个参数解析器对象
    parser = argparse.ArgumentParser()
    # 添加一个名为 "--communication-file" 或 "--communication_file" 的命令行参数，类型为字符串
    parser.add_argument("--communication-file", "--communication_file", type=str)
    # 解析命令行参数，并获取参数值赋给变量 communication_file
    communication_file = parser.parse_args().communication_file
    # 调用 main 函数，并传递 communication_file 变量作为参数
    main(communication_file)
```