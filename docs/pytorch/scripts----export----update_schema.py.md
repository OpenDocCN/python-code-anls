# `.\pytorch\scripts\export\update_schema.py`

```py
import argparse  # 导入解析命令行参数的模块
import os  # 导入操作系统功能的模块

from yaml import dump, Dumper  # 从 yaml 模块中导入 dump 和 Dumper 函数

from torch._export.serde import schema_check  # 导入用于模型序列化和反序列化的 schema_check 函数

if __name__ == "__main__":
    # 如果脚本直接执行，则开始解析命令行参数
    parser = argparse.ArgumentParser(prog="update_schema")
    parser.add_argument(
        "--prefix", type=str, required=True, help="The root of pytorch directory."
    )  # 添加名为 --prefix 的命令行参数，类型为字符串，必须提供，用于指定 PyTorch 目录的根路径
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the schema instead of writing it to file.",
    )  # 添加名为 --dry-run 的命令行参数，如果提供则只打印模式定义而不写入文件
    parser.add_argument(
        "--force-unsafe",
        action="store_true",
        help="!!! Only use this option when you are a chad. !!! Force to write the schema even if schema validation doesn't pass.",
    )  # 添加名为 --force-unsafe 的命令行参数，如果提供则强制写入模式即使模式验证失败
    args = parser.parse_args()  # 解析命令行参数并存储在 args 变量中

    assert os.path.exists(
        args.prefix
    ), f"Assuming path {args.prefix} is the root of pytorch directory, but it doesn't exist."  # 断言所指定的 PyTorch 目录路径存在，否则抛出异常

    commit = schema_check.update_schema()  # 调用 schema_check 模块的 update_schema 函数来更新模式

    if os.path.exists(args.prefix + commit.path):
        # 如果存在旧的模式文件，则检查是否发生模式版本或树形结构版本的降级
        if commit.result["SCHEMA_VERSION"] < commit.base["SCHEMA_VERSION"]:
            raise RuntimeError(
                f"Schema version downgraded from {commit.base['SCHEMA_VERSION']} to {commit.result['SCHEMA_VERSION']}."
            )  # 如果模式版本下降，则引发运行时错误

        if commit.result["TREESPEC_VERSION"] < commit.base["TREESPEC_VERSION"]:
            raise RuntimeError(
                f"Treespec version downgraded from {commit.base['TREESPEC_VERSION']} to {commit.result['TREESPEC_VERSION']}."
            )  # 如果树形结构版本下降，则引发运行时错误
    else:
        assert (
            args.force_unsafe
        ), "Existing schema yaml file not found, please use --force-unsafe to try again."  # 断言存在的模式 YAML 文件，如果不存在则要求使用 --force-unsafe 选项重试

    next_version, reason = schema_check.check(commit, args.force_unsafe)  # 调用 schema_check 模块的 check 函数来检查下一个模式版本和原因

    if next_version is not None and next_version != commit.result["SCHEMA_VERSION"]:
        raise RuntimeError(
            f"Schema version is not updated from {commit.base['SCHEMA_VERSION']} to {next_version}.\n"
            + "Please either:\n"
            + "    1. update schema.py to not break compatibility.\n"
            + "    or 2. bump the schema version to the expected value.\n"
            + "    or 3. use --force-unsafe to override schema.yaml (not recommended).\n "
            + "and try again.\n"
            + f"Reason: {reason}"
        )  # 如果模式版本未更新，则引发运行时错误，并提供解决方法和原因

    header = (
        "# @" + "generated by " + os.path.basename(__file__).rsplit(".", 1)[0] + ".py"
    )  # 创建注释头部，指示脚本生成
    header += f"\n# checksum<<{commit.checksum_result}>>"  # 添加 checksum 信息到注释头部
    payload = dump(commit.result, Dumper=Dumper, sort_keys=False)  # 将模式结果转储为 YAML 格式的文本

    content = header + "\n" + payload  # 构建完整的文档内容

    if args.dry_run:
        print(content)  # 如果使用了 --dry-run 参数，则打印模式内容
        print("\nWill write the above schema to" + args.prefix + commit.path)  # 打印将要写入的模式文件路径
    else:
        with open(args.prefix + commit.path, "w") as f:
            f.write(content)  # 否则，将构建的文档内容写入到指定路径的文件中
```