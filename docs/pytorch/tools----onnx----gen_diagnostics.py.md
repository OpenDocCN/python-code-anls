# `.\pytorch\tools\onnx\gen_diagnostics.py`

```
#!/usr/bin/env python3

""" Generates PyTorch ONNX Export Diagnostic rules for C++, Python and documentations.
The rules are defined in torch/onnx/_internal/diagnostics/rules.yaml.

Usage:

python -m tools.onnx.gen_diagnostics \
    torch/onnx/_internal/diagnostics/rules.yaml \
    torch/onnx/_internal/diagnostics \
    torch/csrc/onnx/diagnostics/generated \
    torch/docs/source
"""

import argparse  # 导入命令行参数解析模块
import os  # 导入操作系统相关功能模块
import string  # 导入字符串处理模块
import subprocess  # 导入子进程管理模块
import textwrap  # 导入文本包装模块
from typing import Any, Mapping, Sequence  # 引入类型提示

import yaml  # 导入YAML文件处理模块

from torchgen import utils as torchgen_utils  # 导入torchgen工具模块
from torchgen.yaml_utils import YamlLoader  # 从torchgen中导入YAML加载器

_RULES_GENERATED_COMMENT = """\
GENERATED CODE - DO NOT EDIT DIRECTLY
This file is generated by gen_diagnostics.py.
See tools/onnx/gen_diagnostics.py for more information.

Diagnostic rules for PyTorch ONNX export.
"""

_PY_RULE_CLASS_COMMENT = """\
GENERATED CODE - DO NOT EDIT DIRECTLY
The purpose of generating a class for each rule is to override the `format_message`
method to provide more details in the signature about the format arguments.
"""

_PY_RULE_CLASS_TEMPLATE = """\
class _{pascal_case_name}(infra.Rule):
    \"\"\"{short_description}\"\"\"
    def format_message(  # type: ignore[override]
        self,
        {message_arguments}
    ) -> str:
        \"\"\"Returns the formatted default message of this Rule.

        Message template: {message_template}
        \"\"\"
        return self.message_default_template.format({message_arguments_assigned})

    def format(  # type: ignore[override]
        self,
        level: infra.Level,
        {message_arguments}
    ) -> Tuple[infra.Rule, infra.Level, str]:
        \"\"\"Returns a tuple of (Rule, Level, message) for this Rule.

        Message template: {message_template}
        \"\"\"
        return self, level, self.format_message({message_arguments_assigned})

"""

_PY_RULE_COLLECTION_FIELD_TEMPLATE = """\
{snake_case_name}: _{pascal_case_name} = dataclasses.field(
    default=_{pascal_case_name}.from_sarif(**{sarif_dict}),
    init=False,
)
\"\"\"{short_description}\"\"\"
"""

_CPP_RULE_TEMPLATE = """\
/**
 * @brief {short_description}
 */
{name},
"""

_RuleType = Mapping[str, Any]


def _kebab_case_to_snake_case(name: str) -> str:
    return name.replace("-", "_")  # 将连字符形式的命名转换为下划线形式的命名


def _kebab_case_to_pascal_case(name: str) -> str:
    return "".join(word.capitalize() for word in name.split("-"))  # 将连字符形式的命名转换为帕斯卡命名


def _format_rule_for_python_class(rule: _RuleType) -> str:
    pascal_case_name = _kebab_case_to_pascal_case(rule["name"])  # 将规则名称转换为帕斯卡命名
    short_description = rule["short_description"]["text"]  # 获取规则的简短描述文本
    message_template = rule["message_strings"]["default"]["text"]  # 获取规则的默认消息模板
    field_names = [
        field_name
        for _, field_name, _, _ in string.Formatter().parse(message_template)
        if field_name is not None
    ]  # 解析消息模板中的字段名
    # 对于给定的每个字段名，确保其类型是字符串
    for field_name in field_names:
        assert isinstance(
            field_name, str
        ), f"Unexpected field type {type(field_name)} from {field_name}. "
        # 检查字段名必须是字符串，否则引发异常
        "Field name must be string.\nFull message template: {message_template}"
        
        # 确保字段名不是纯数字，因为只支持关键字命名格式
        assert (
            not field_name.isnumeric()
        ), f"Unexpected numeric field name {field_name}. "
        # 若字段名是纯数字，抛出异常并显示完整的消息模板
        "Only keyword name formatting is supported.\nFull message template: {message_template}"
    
    # 将字段名列表转换为逗号分隔的字符串，用于消息参数
    message_arguments = ", ".join(field_names)
    
    # 生成字段名及其值的赋值形式字符串，用于消息模板
    message_arguments_assigned = ", ".join(
        [f"{field_name}={field_name}" for field_name in field_names]
    )
    
    # 返回填充好的 Python 规则类模板，使用给定的参数替换占位符
    return _PY_RULE_CLASS_TEMPLATE.format(
        pascal_case_name=pascal_case_name,
        short_description=short_description,
        message_template=repr(message_template),
        message_arguments=message_arguments,
        message_arguments_assigned=message_arguments_assigned,
    )
def _format_rule_for_python_field(rule: _RuleType) -> str:
    # 将短横线命名法转换为蛇形命名法
    snake_case_name = _kebab_case_to_snake_case(rule["name"])
    # 将短横线命名法转换为帕斯卡命名法
    pascal_case_name = _kebab_case_to_pascal_case(rule["name"])
    # 获取规则的简短描述文本
    short_description = rule["short_description"]["text"]

    # 使用 Python 规则字段的模板格式化字符串
    return _PY_RULE_COLLECTION_FIELD_TEMPLATE.format(
        snake_case_name=snake_case_name,
        pascal_case_name=pascal_case_name,
        sarif_dict=rule,  # 将整个规则字典传入模板
        short_description=short_description,
    )


def _format_rule_for_cpp(rule: _RuleType) -> str:
    # 生成 C++ 规则名称，以 'k' 开头并使用帕斯卡命名法
    name = f"k{_kebab_case_to_pascal_case(rule['name'])}"
    # 获取规则的简短描述文本
    short_description = rule["short_description"]["text"]
    # 使用 C++ 规则模板格式化字符串
    return _CPP_RULE_TEMPLATE.format(name=name, short_description=short_description)


def gen_diagnostics_python(
    rules: Sequence[_RuleType], out_py_dir: str, template_dir: str
) -> None:
    # 为 Python 生成规则类的代码行列表
    rule_class_lines = [_format_rule_for_python_class(rule) for rule in rules]
    # 为 Python 生成规则字段的代码行列表
    rule_field_lines = [_format_rule_for_python_field(rule) for rule in rules]

    # 创建文件管理器对象
    fm = torchgen_utils.FileManager(
        install_dir=out_py_dir, template_dir=template_dir, dry_run=False
    )
    # 使用模板文件生成 '_rules.py'，传入所需的数据
    fm.write_with_template(
        "_rules.py",
        "rules.py.in",
        lambda: {
            "generated_comment": _RULES_GENERATED_COMMENT,  # 生成文件的注释
            "generated_rule_class_comment": _PY_RULE_CLASS_COMMENT,  # 生成规则类的注释
            "rule_classes": "\n".join(rule_class_lines),  # 规则类的代码字符串
            "rules": textwrap.indent("\n".join(rule_field_lines), " " * 4),  # 规则字段的代码字符串，缩进4个空格
        },
    )
    # 对生成的文件进行代码风格检查
    _lint_file(os.path.join(out_py_dir, "_rules.py"))


def gen_diagnostics_cpp(
    rules: Sequence[_RuleType], out_cpp_dir: str, template_dir: str
) -> None:
    # 为 C++ 生成规则的代码行列表
    rule_lines = [_format_rule_for_cpp(rule) for rule in rules]
    # 生成规则名称列表，用于 Python 代码中的引用
    rule_names = [f'"{_kebab_case_to_snake_case(rule["name"])}",' for rule in rules]

    # 创建文件管理器对象
    fm = torchgen_utils.FileManager(
        install_dir=out_cpp_dir, template_dir=template_dir, dry_run=False
    )
    # 使用模板文件生成 'rules.h'，传入所需的数据
    fm.write_with_template(
        "rules.h",
        "rules.h.in",
        lambda: {
            "generated_comment": textwrap.indent(
                _RULES_GENERATED_COMMENT,
                " * ",
                predicate=lambda x: True,  # 不忽略空行
            ),
            "rules": textwrap.indent("\n".join(rule_lines), " " * 2),  # 规则的代码字符串，缩进2个空格
            "py_rule_names": textwrap.indent("\n".join(rule_names), " " * 4),  # Python 规则名称的字符串，缩进4个空格
        },
    )
    # 对生成的文件进行代码风格检查
    _lint_file(os.path.join(out_cpp_dir, "rules.h"))


def gen_diagnostics_docs(
    rules: Sequence[_RuleType], out_docs_dir: str, template_dir: str
) -> None:
    # TODO: 添加文档生成在后续的 PR 中。


def _lint_file(file_path: str) -> None:
    # 运行代码风格检查工具 'lintrunner' 并等待其完成
    p = subprocess.Popen(["lintrunner", "-a", file_path])
    p.wait()


def gen_diagnostics(
    rules_path: str,
    out_py_dir: str,
    out_cpp_dir: str,
    out_docs_dir: str,
) -> None:
    # 使用 YAML 加载器读取规则文件
    with open(rules_path) as f:
        rules = yaml.load(f, Loader=YamlLoader)

    # 确定模板文件所在的目录路径
    template_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "templates")
    # 使用给定的规则生成 Python 诊断代码到指定目录
    gen_diagnostics_python(
        rules,          # 规则列表，用于生成诊断代码
        out_py_dir,     # Python 输出目录，将生成的代码存放在此处
        template_dir,   # 模板目录，包含用于生成代码的模板文件
    )
    
    # 使用给定的规则生成 C++ 诊断代码到指定目录
    gen_diagnostics_cpp(
        rules,          # 规则列表，用于生成诊断代码
        out_cpp_dir,    # C++ 输出目录，将生成的代码存放在此处
        template_dir,   # 模板目录，包含用于生成代码的模板文件
    )
    
    # 使用给定的规则生成文档文件到指定目录
    gen_diagnostics_docs(
        rules,          # 规则列表，用于生成文档
        out_docs_dir,   # 文档输出目录，将生成的文档存放在此处
        template_dir    # 模板目录，包含用于生成文档的模板文件
    )
# 定义程序的主函数入口点，不返回任何值
def main() -> None:
    # 创建参数解析器对象，并设置程序的描述信息
    parser = argparse.ArgumentParser(description="Generate ONNX diagnostics files")
    
    # 添加位置参数 rules_path，用于指定 rules.yaml 文件的路径
    parser.add_argument("rules_path", metavar="RULES", help="path to rules.yaml")
    
    # 添加位置参数 out_py_dir，用于指定 Python 输出目录的路径
    parser.add_argument(
        "out_py_dir",
        metavar="OUT_PY",
        help="path to output directory for Python",
    )
    
    # 添加位置参数 out_cpp_dir，用于指定 C++ 输出目录的路径
    parser.add_argument(
        "out_cpp_dir",
        metavar="OUT_CPP",
        help="path to output directory for C++",
    )
    
    # 添加位置参数 out_docs_dir，用于指定文档输出目录的路径
    parser.add_argument(
        "out_docs_dir",
        metavar="OUT_DOCS",
        help="path to output directory for docs",
    )
    
    # 解析命令行参数，并将其存储到 args 变量中
    args = parser.parse_args()
    
    # 调用 gen_diagnostics 函数，传入解析后的参数，生成诊断文件
    gen_diagnostics(
        args.rules_path,
        args.out_py_dir,
        args.out_cpp_dir,
        args.out_docs_dir,
    )


# 如果脚本直接运行，则调用主函数 main
if __name__ == "__main__":
    main()
```