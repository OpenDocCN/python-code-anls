# `.\pytorch\c10\util\hash.h`

```
#pragma once
// 使用 #pragma once 防止头文件被多次包含

#include <c10/util/Exception.h>
#include <cstddef>
#include <functional>
#include <iomanip>
#include <ios>
#include <sstream>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

#include <c10/util/ArrayRef.h>
#include <c10/util/complex.h>

namespace c10 {

// NOTE: hash_combine and SHA1 hashing is based on implementation from Boost
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// 定义一个内联函数，用于将一个值合并到一个哈希种子中
inline size_t hash_combine(size_t seed, size_t value) {
  return seed ^ (value + 0x9e3779b9 + (seed << 6u) + (seed >> 2u));
}

// Creates the SHA1 hash of a string. A 160-bit hash.
// Based on the implementation in Boost (see notice above).
// Note that SHA1 hashes are no longer considered cryptographically
//   secure, but are the standard hash for generating unique ids.
// Usage:
//   // Let 'code' be a std::string
//   c10::sha1 sha1_hash{code};
//   const auto hash_code = sha1_hash.str();
// TODO: Compare vs OpenSSL and/or CryptoPP implementations
// 定义一个结构体用于计算字符串的 SHA1 哈希值
struct sha1 {
  // 定义 SHA1 哈希值的类型为 unsigned int 数组，长度为 5
  typedef unsigned int(digest_type)[5];

  // 构造函数，接受一个字符串参数并计算其 SHA1 哈希值
  sha1(const std::string& s = "") {
    if (!s.empty()) {
      reset();
      process_bytes(s.c_str(), s.size());
    }
  }

  // 重置 SHA1 状态，设置初始哈希值
  void reset() {
    h_[0] = 0x67452301;
    h_[1] = 0xEFCDAB89;
    h_[2] = 0x98BADCFE;
    h_[3] = 0x10325476;
    h_[4] = 0xC3D2E1F0;

    block_byte_index_ = 0;
    bit_count_low = 0;
    bit_count_high = 0;
  }

  // 计算 SHA1 哈希值并返回其十六进制字符串表示
  std::string str() {
    unsigned int digest[5];
    get_digest(digest);

    std::ostringstream buf;
    for (unsigned int i : digest) {
      buf << std::hex << std::setfill('0') << std::setw(8) << i;
    }
    // 返回 SHA1 哈希值的十六进制字符串表示
    return buf.str();
  }
  
  // 下面省略的部分应继续注释，以完整代码为准
  }

 private:
  // 左旋转函数，将无符号整数 x 左旋转 n 位
  unsigned int left_rotate(unsigned int x, std::size_t n) {
    return (x << n) ^ (x >> (32 - n));
  }

  // 处理消息块的具体实现
  void process_block_impl() {
    // 定义消息扩展数组 w，共 80 个无符号整数
    unsigned int w[80];

    // 将当前块 block_ 的内容转换为 w 数组的格式
    for (std::size_t i = 0; i < 16; ++i) {
      w[i] = (block_[i * 4 + 0] << 24);
      w[i] |= (block_[i * 4 + 1] << 16);
      w[i] |= (block_[i * 4 + 2] << 8);
      w[i] |= (block_[i * 4 + 3]);
    }

    // 根据 SHA-1 算法规则对 w 数组进行扩展
    for (std::size_t i = 16; i < 80; ++i) {
      w[i] = left_rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1);
    }

    // 初始化 SHA-1 算法中的五个寄存器
    unsigned int a = h_[0];
    unsigned int b = h_[1];
    unsigned int c = h_[2];
    unsigned int d = h_[3];
    unsigned int e = h_[4];

    // 进行 80 轮的运算，更新五个寄存器的值
    for (std::size_t i = 0; i < 80; ++i) {
      unsigned int f = 0;
      unsigned int k = 0;

      // 根据当前轮次 i 的不同区间选择不同的运算函数和常数
      if (i < 20) {
        f = (b & c) | (~b & d);
        k = 0x5A827999;
      } else if (i < 40) {
        f = b ^ c ^ d;
        k = 0x6ED9EBA1;
      } else if (i < 60) {
        f = (b & c) | (b & d) | (c & d);
        k = 0x8F1BBCDC;
      } else {
        f = b ^ c ^ d;
        k = 0xCA62C1D6;
      }

      // 更新临时变量 temp，并更新五个寄存器的值
      unsigned temp = left_rotate(a, 5) + f + e + k + w[i];
      e = d;
      d = c;
      c = left_rotate(b, 30);
      b = a;
      a = temp;
    }

    // 更新最终的消息摘要 h_
    h_[0] += a;
    h_[1] += b;
    h_[2] += c;
    h_[3] += d;
    h_[4] += e;
  }

  // 处理单个字节的具体实现
  void process_byte_impl(unsigned char byte) {
    // 将字节 byte 添加到当前块 block_ 中
    block_[block_byte_index_++] = byte;

    // 如果当前块 block_ 已满（64 字节），则进行处理
    if (block_byte_index_ == 64) {
      block_byte_index_ = 0;
      process_block_impl();
    }
  }

  // 处理单个字节的接口函数，同时更新比特计数
  void process_byte(unsigned char byte) {
    // 调用具体实现函数 process_byte_impl 处理字节 byte
    process_byte_impl(byte);

    // 更新比特计数 bit_count_low，防止溢出
    if (bit_count_low < 0xFFFFFFF8) {
      bit_count_low += 8;
    } else {
      bit_count_low = 0;

      // 如果低位比特计数已满，增加高位比特计数
      if (bit_count_high <= 0xFFFFFFFE) {
        ++bit_count_high;
      } else {
        // 若高位比特计数也溢出，则报错
        TORCH_CHECK(false, "sha1 too many bytes");
      }
    }
  }

  // 处理一块字节流，调用 process_byte 处理每个字节
  void process_block(void const* bytes_begin, void const* bytes_end) {
    // 将字节流转换为 unsigned char 指针
    unsigned char const* begin = static_cast<unsigned char const*>(bytes_begin);
    unsigned char const* end = static_cast<unsigned char const*>(bytes_end);
    
    // 遍历字节流，逐字节调用 process_byte 处理
    for (; begin != end; ++begin) {
      process_byte(*begin);
    }
  }

  // 处理一块字节数组，调用 process_block 处理
  void process_bytes(void const* buffer, std::size_t byte_count) {
    // 将字节数组转换为 unsigned char 指针
    unsigned char const* b = static_cast<unsigned char const*>(buffer);
    
    // 调用 process_block 处理整个字节数组
    process_block(b, b + byte_count);
  }

  // 获取最终的 SHA-1 消息摘要
  void get_digest(digest_type& digest) {
    // 在消息末尾添加比特 '1'
    process_byte_impl(0x80);

    // 添加足够的 '0'，使得消息长度模 64 余数为 56
    // 检查填充和比特计数是否有足够的空间
    // 如果当前块的字节索引大于56，则需要填充和处理当前块
    if (block_byte_index_ > 56) {
      // 完成当前块的处理
      while (block_byte_index_ != 0) {
        process_byte_impl(0);
      }

      // 增加一个新的块
      while (block_byte_index_ < 56) {
        process_byte_impl(0);
      }
    } else {
      // 否则，只需填充当前块直到达到56字节
      while (block_byte_index_ < 56) {
        process_byte_impl(0);
      }
    }

    // 将消息长度（预处理前）作为64位大端整数追加
    process_byte_impl(
        static_cast<unsigned char>((bit_count_high >> 24) & 0xFF));
    process_byte_impl(
        static_cast<unsigned char>((bit_count_high >> 16) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_high >> 8) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_high) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_low >> 24) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_low >> 16) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_low >> 8) & 0xFF));
    process_byte_impl(static_cast<unsigned char>((bit_count_low) & 0xFF));

    // 获取最终的摘要值
    digest[0] = h_[0];
    digest[1] = h_[1];
    digest[2] = h_[2];
    digest[3] = h_[3];
    digest[4] = h_[4];
  }

  // 哈希计算中使用的状态变量
  unsigned int h_[5]{};
  // 当前处理的块
  unsigned char block_[64]{};
  // 当前块的字节索引
  std::size_t block_byte_index_{};
  // 消息的位数（低32位）
  std::size_t bit_count_low{};
  // 消息的位数（高32位）
  std::size_t bit_count_high{};
};

////////////////////////////////////////////////////////////////////////////////
// twang_mix64 function: A hash function based on the twang_32 hash function.
////////////////////////////////////////////////////////////////////////////////

constexpr uint64_t twang_mix64(uint64_t key) noexcept {
  key = (~key) + (key << 21); // key *= (1 << 21) - 1; key -= 1;
  key = key ^ (key >> 24);
  key = key + (key << 3) + (key << 8); // key *= 1 + (1 << 3) + (1 << 8)
  key = key ^ (key >> 14);
  key = key + (key << 2) + (key << 4); // key *= 1 + (1 << 2) + (1 << 4)
  key = key ^ (key >> 28);
  key = key + (key << 31); // key *= 1 + (1 << 31)
  return key;
}

////////////////////////////////////////////////////////////////////////////////
// c10::hash implementation
////////////////////////////////////////////////////////////////////////////////

namespace _hash_detail {

// Use template argument deduction to shorten calls to c10::hash
template <typename T>
size_t simple_get_hash(const T& o);

template <typename T, typename V>
using type_if_not_enum = std::enable_if_t<!std::is_enum_v<T>, V>;

// Use SFINAE to dispatch to std::hash if possible, cast enum types to int
// automatically, and fall back to T::hash otherwise. NOTE: C++14 added support
// for hashing enum types to the standard, and some compilers implement it even
// when C++14 flags aren't specified. This is why we have to disable this
// overload if T is an enum type (and use the one below in this case).
template <typename T>
auto dispatch_hash(const T& o)
    -> decltype(std::hash<T>()(o), type_if_not_enum<T, size_t>()) {
  return std::hash<T>()(o);
}

// Special case for enum types, cast to underlying type and hash
template <typename T>
std::enable_if_t<std::is_enum_v<T>, size_t> dispatch_hash(const T& o) {
  using R = std::underlying_type_t<T>;
  return std::hash<R>()(static_cast<R>(o));
}

// Use T::hash function if available, otherwise fall back
template <typename T>
auto dispatch_hash(const T& o) -> decltype(T::hash(o), size_t()) {
  return T::hash(o);
}

} // namespace _hash_detail

// Hasher struct for general types
template <typename T>
struct hash {
  size_t operator()(const T& o) const {
    return _hash_detail::dispatch_hash(o);
  };
};

// Specialization for std::tuple
template <typename... Types>
struct hash<std::tuple<Types...>> {
  // Recursive hashing of tuple elements
  template <size_t idx, typename... Ts>
  struct tuple_hash {
    size_t operator()(const std::tuple<Ts...>& t) const {
      return hash_combine(
          _hash_detail::simple_get_hash(std::get<idx>(t)),
          tuple_hash<idx - 1, Ts...>()(t));
    }
  };

  // Base case for tuple hashing
  template <typename... Ts>
  struct tuple_hash<0, Ts...> {
    size_t operator()(const std::tuple<Ts...>& t) const {
      return _hash_detail::simple_get_hash(std::get<0>(t));
    }
  };

  // Calculate tuple hash using recursive hashing
  size_t operator()(const std::tuple<Types...>& t) const {
    return tuple_hash<sizeof...(Types) - 1, Types...>()(t);
  }
};

// Specialization for std::pair
template <typename T1, typename T2>
struct hash<std::pair<T1, T2>> {
  size_t operator()(const std::pair<T1, T2>& pair) const {
    std::tuple<T1, T2> tuple = std::make_tuple(pair.first, pair.second);
    return _hash_detail::simple_get_hash(tuple);
  }
};

// Specialization for c10::ArrayRef
template <typename T>
struct hash<c10::ArrayRef<T>> {
  size_t operator()(c10::ArrayRef<T> v) const {
    size_t seed = 0;
    // 对于向量 v 中的每个元素 elem，执行以下操作
    for (const auto& elem : v) {
      // 使用简单哈希函数 _hash_detail::simple_get_hash(elem) 计算哈希值，并与当前种子 seed 组合
      seed = hash_combine(seed, _hash_detail::simple_get_hash(elem));
    }
    // 返回最终的哈希种子值
    return seed;
  }
};

// 结构体模板的特化，用于 std::vector
template <typename T>
struct hash<std::vector<T>> {
  // 重载运算符()，计算给定 std::vector 对象的哈希值
  size_t operator()(const std::vector<T>& v) const {
    // 调用 c10::ArrayRef<T> 的哈希函数来计算 std::vector 的哈希值
    return hash<c10::ArrayRef<T>>()(v);
  }
};

namespace _hash_detail {

// 对象的简单哈希函数，接受任意类型 T 的引用并返回其哈希值
template <typename T>
size_t simple_get_hash(const T& o) {
  return c10::hash<T>()(o);
}

} // namespace _hash_detail

// 使用这个函数可以在一行中哈希多个对象
// 调用 c10::hash，因此可以处理容器类型
// 示例：
//
// static size_t hash(const MyStruct& s) {
//   return get_hash(s.member1, s.member2, s.member3);
// }
template <typename... Types>
size_t get_hash(const Types&... args) {
  // 返回调用 std::tie(args...) 的哈希函数得到的哈希值
  return c10::hash<decltype(std::tie(args...))>()(std::tie(args...));
}

// c10::complex 的特化
template <typename T>
struct hash<c10::complex<T>> {
  // 重载运算符()，计算给定 c10::complex 对象的哈希值
  size_t operator()(const c10::complex<T>& c) const {
    // 调用 get_hash 计算 c10::complex 对象的实部和虚部的哈希值
    return get_hash(c.real(), c.imag());
  }
};

} // namespace c10
```