# `D:\src\scipysrc\pandas\pandas\_version.py`

```
# This file helps to compute a version number in source trees obtained from
# git-archive tarball (such as those provided by githubs download-from-tag
# feature). Distribution tarballs (built by setup.py sdist) and build
# directories (produced by setup.py build) will contain a much shorter file
# that just contains the computed version number.

# This file is released into the public domain.
# Generated by versioneer-0.28
# https://github.com/python-versioneer/python-versioneer

"""Git implementation of _version.py."""

# 引入 Callable 类型
from collections.abc import Callable
import errno  # 引入 errno 模块
import functools  # 引入 functools 模块
import os  # 引入 os 模块
import re  # 引入 re 模块
import subprocess  # 引入 subprocess 模块
import sys  # 引入 sys 模块


def get_keywords():
    """Get the keywords needed to look up the version information."""
    # 这些字符串在 git-archive 过程中将被 git 替换。
    # setup.py/versioneer.py 将通过变量名进行匹配，因此每个变量名必须
    # 单独占据一行。_version.py 只会调用 get_keywords()。
    git_refnames = "$Format:%d$"  # Git 中的引用名称
    git_full = "$Format:%H$"  # Git 中的完整哈希值
    git_date = "$Format:%ci$"  # Git 中的提交日期
    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}  # 关键字字典
    return keywords


class VersioneerConfig:
    """Container for Versioneer configuration parameters."""


def get_config():
    """Create, populate and return the VersioneerConfig() object."""
    # 这些字符串在 'setup.py versioneer' 创建 _version.py 时被填充。
    cfg = VersioneerConfig()
    cfg.VCS = "git"  # 版本控制系统为 git
    cfg.style = "pep440"  # 遵循 PEP 440 版本命名规范
    cfg.tag_prefix = "v"  # 标签前缀为 'v'
    cfg.parentdir_prefix = "pandas-"  # 父目录前缀为 'pandas-'
    cfg.versionfile_source = "pandas/_version.py"  # 版本文件源为 'pandas/_version.py'
    cfg.verbose = False  # 是否详细输出为假
    return cfg


class NotThisMethod(Exception):
    """Exception raised if a method is not valid for the current scenario."""


LONG_VERSION_PY: dict[str, str] = {}  # 长版本 _version.py 的空字典
HANDLERS: dict[str, dict[str, Callable]] = {}  # 处理器字典，以 VCS 和方法名为键


def register_vcs_handler(vcs, method):  # 注册 VCS 处理器的装饰器函数
    """Create decorator to mark a method as the handler of a VCS."""

    def decorate(f):
        """Store f in HANDLERS[vcs][method]."""
        if vcs not in HANDLERS:
            HANDLERS[vcs] = {}
        HANDLERS[vcs][method] = f  # 将方法 f 存储在 HANDLERS[vcs][method] 中
        return f

    return decorate


def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):
    """Call the given command(s)."""
    assert isinstance(commands, list)  # 断言 commands 是列表类型
    process = None  # 进程变量初始化为 None

    popen_kwargs = {}  # Popen 的参数字典
    if sys.platform == "win32":
        # 在 Windows 平台下隐藏控制台窗口，如果使用 pythonw.exe
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        popen_kwargs["startupinfo"] = startupinfo
    # 遍历给定的命令列表，尝试执行每一个命令直到成功或全部失败
    for command in commands:
        # 将命令和参数列表转换为字符串以便显示
        dispcmd = str([command] + args)
        try:
            # 尝试启动子进程执行命令
            process = subprocess.Popen(
                [command] + args,         # 执行的命令及其参数列表
                cwd=cwd,                  # 子进程的工作目录
                env=env,                  # 子进程的环境变量
                stdout=subprocess.PIPE,   # 标准输出流，捕获命令的输出
                stderr=(subprocess.PIPE if hide_stderr else None),  # 标准错误流，如果需要的话捕获错误输出
                **popen_kwargs,           # 其它可能的关键字参数，如超时、权限等
            )
            break  # 成功启动子进程，跳出循环
        except OSError:
            e = sys.exc_info()[1]
            if e.errno == errno.ENOENT:
                continue  # 如果是文件不存在的错误，继续尝试下一个命令
            if verbose:
                print(f"unable to run {dispcmd}")  # 如果详细模式，打印无法执行的命令
                print(e)                          # 打印异常信息
            return None, None  # 返回空结果表示执行失败
    else:
        if verbose:
            print(f"unable to find command, tried {commands}")  # 如果详细模式，打印尝试过的所有命令
        return None, None  # 返回空结果表示所有命令都无法执行

    # 读取子进程的标准输出并解码为字符串
    stdout = process.communicate()[0].strip().decode()
    if process.returncode != 0:
        if verbose:
            print(f"unable to run {dispcmd} (error)")  # 如果详细模式，打印命令执行错误
            print(f"stdout was {stdout}")            # 打印标准输出内容
        return None, process.returncode  # 返回标准输出和返回码表示执行失败

    return stdout, process.returncode  # 返回标准输出和返回码表示执行成功
# 从父目录名称中尝试确定版本信息

def versions_from_parentdir(parentdir_prefix, root, verbose):
    """Try to determine the version from the parent directory name.
    
    Source tarballs conventionally unpack into a directory that includes both
    the project name and a version string. We will also support searching up
    two directory levels for an appropriately named parent directory.
    """
    # 初始化一个空列表来存放根目录路径
    rootdirs = []

    # 迭代三次，尝试在父目录中查找版本信息
    for _ in range(3):
        # 获取当前根目录的基础名称（即不包含路径的部分）
        dirname = os.path.basename(root)
        # 如果当前目录名称以给定的父目录前缀开头
        if dirname.startswith(parentdir_prefix):
            # 返回包含版本信息的字典
            return {
                "version": dirname[len(parentdir_prefix):],  # 提取版本信息部分
                "full-revisionid": None,
                "dirty": False,
                "error": None,
                "date": None,
            }
        # 将当前根目录路径添加到 rootdirs 列表中
        rootdirs.append(root)
        # 获取上一级目录的路径
        root = os.path.dirname(root)  # 向上一级目录移动

    # 如果启用了详细模式，并且没有找到以父目录前缀开头的目录，则打印相应的错误信息
    if verbose:
        print(
            f"Tried directories {rootdirs!s} \
            but none started with prefix {parentdir_prefix}"
        )
    # 抛出异常，指示找不到符合条件的根目录
    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")


@register_vcs_handler("git", "get_keywords")
def git_get_keywords(versionfile_abs):
    """Extract version information from the given file."""
    # 从给定文件中提取版本信息的关键字

    # 初始化一个空字典来存放关键字信息
    keywords = {}
    try:
        # 使用 UTF-8 编码打开版本文件
        with open(versionfile_abs, encoding="utf-8") as fobj:
            # 逐行读取文件内容
            for line in fobj:
                # 如果当前行以 "git_refnames =" 开头
                if line.strip().startswith("git_refnames ="):
                    # 使用正则表达式查找匹配引号内的内容
                    mo = re.search(r'=\s*"(.*)"', line)
                    if mo:
                        # 将匹配结果存入关键字字典中的 "refnames" 键
                        keywords["refnames"] = mo.group(1)
                # 如果当前行以 "git_full =" 开头
                if line.strip().startswith("git_full ="):
                    # 使用正则表达式查找匹配引号内的内容
                    mo = re.search(r'=\s*"(.*)"', line)
                    if mo:
                        # 将匹配结果存入关键字字典中的 "full" 键
                        keywords["full"] = mo.group(1)
                # 如果当前行以 "git_date =" 开头
                if line.strip().startswith("git_date ="):
                    # 使用正则表达式查找匹配引号内的内容
                    mo = re.search(r'=\s*"(.*)"', line)
                    if mo:
                        # 将匹配结果存入关键字字典中的 "date" 键
                        keywords["date"] = mo.group(1)
    except OSError:
        pass
    # 返回存放版本信息关键字的字典
    return keywords


@register_vcs_handler("git", "keywords")
def git_versions_from_keywords(keywords, tag_prefix, verbose):
    """Get version information from git keywords."""
    # 从 Git 关键字中获取版本信息

    # 如果关键字字典中没有 "refnames" 键，则抛出异常
    if "refnames" not in keywords:
        raise NotThisMethod("Short version file found")
    # 获取关键字字典中的日期信息
    date = keywords.get("date")
    # 如果日期不为空，则处理日期字符串：
    # - 使用最后一行，因为之前的行可能包含 GPG 签名信息。
    date = date.splitlines()[-1]

    # git-2.2.0 添加了 "%cI"，它会展开为 ISO-8601 兼容的日期时间戳。
    # 我们更倾向于 "%ci"（展开为 "ISO-8601 类似" 字符串），因为它从 git-1.5.3 开始支持，
    # 很难确定我们使用的版本或处理旧版本的方法。
    date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)

refnames = keywords["refnames"].strip()

# 如果 refnames 以 "$Format" 开头，则表示关键字未展开，不适用于 git-archive 生成的 tar 包。
if refnames.startswith("$Format"):
    if verbose:
        print("keywords are unexpanded, not using")
    raise NotThisMethod("unexpanded keywords, not a git-archive tarball")

# 将 refnames 按逗号分隔，去除首尾空格和括号，并转换为集合。
refs = {r.strip() for r in refnames.strip("()").split(",")}

# 在 git-1.8.3 之后，标签以 "tag: " 标识，而不是简单的标签名。
# 如果是以 "tag: " 开头的 ref，则优先处理这些。
TAG = "tag: "
tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}

# 如果没有找到标签，则使用启发式方法判断是否是版本标签。
if not tags:
    # 使用正则表达式匹配是否包含数字，来判断是否是版本标签。
    tags = {r for r in refs if re.search(r"\d", r)}
    if verbose:
        print(f"discarding '{','.join(refs - tags)}', no digits")

if verbose:
    print(f"likely tags: {','.join(sorted(tags))}")

# 对标签进行排序，并找出符合条件的标签。
for ref in sorted(tags):
    # 如果标签以指定的前缀开头，则处理该标签。
    if ref.startswith(tag_prefix):
        r = ref[len(tag_prefix):]
        # 过滤掉与前缀完全匹配或在剥离前缀后不以数字开头的标签。
        if not re.match(r"\d", r):
            continue
        if verbose:
            print(f"picking {r}")
        return {
            "version": r,
            "full-revisionid": keywords["full"].strip(),
            "dirty": False,
            "error": None,
            "date": date,
        }

# 如果没有找到合适的标签，则版本号为 "0+unknown"，但完整的修订 ID 仍然存在。
if verbose:
    print("no suitable tags, using unknown + full revision id")
return {
    "version": "0+unknown",
    "full-revisionid": keywords["full"].strip(),
    "dirty": False,
    "error": "no suitable tags",
    "date": None,
}
# 注册版本控制系统处理器，处理器名为"git"，调用方法为"pieces_from_vcs"
@register_vcs_handler("git", "pieces_from_vcs")
def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):
    """从源代码树的根目录获取'git describe'命令的版本信息。

    仅当未展开git-archive 'subst'关键字并且_version.py尚未使用短版本字符串重写时才调用此函数，
    表示我们处于一个已检出的源代码树内。
    """
    GITS = ["git"]
    if sys.platform == "win32":
        GITS = ["git.cmd", "git.exe"]

    # GIT_DIR 可能会干扰Versioneer的正确操作。
    # 它可能旨在传递给Versioneer版本化的项目，
    # 但这不应改变我们获取版本信息的位置。
    env = os.environ.copy()
    env.pop("GIT_DIR", None)
    runner = functools.partial(runner, env=env)

    # 运行'git rev-parse --git-dir'命令获取Git仓库目录
    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root, hide_stderr=not verbose)
    if rc != 0:
        if verbose:
            print(f"Directory {root} not under git control")
        raise NotThisMethod("'git rev-parse --git-dir' returned error")

    # 运行'git describe'命令获取描述当前版本的详细信息
    # 如果存在与tag_prefix匹配的标签，输出形如TAG-NUM-gHEX[-dirty]
    # 如果不存在匹配的标签，输出形如HEX[-dirty]（没有NUM）
    describe_out, rc = runner(
        GITS,
        [
            "describe",
            "--tags",
            "--dirty",
            "--always",
            "--long",
            "--match",
            f"{tag_prefix}[[:digit:]]*",
        ],
        cwd=root,
    )
    # --long选项从git-1.5.5版本开始支持
    if describe_out is None:
        raise NotThisMethod("'git describe' failed")
    describe_out = describe_out.strip()

    # 运行'git rev-parse HEAD'命令获取当前提交的完整SHA-1哈希值
    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
    if full_out is None:
        raise NotThisMethod("'git rev-parse' failed")
    full_out = full_out.strip()

    # 构建版本信息的字典
    pieces = {}
    pieces["long"] = full_out  # 完整的提交哈希值
    pieces["short"] = full_out[:7]  # 简短的提交哈希值，可能以后会改进
    pieces["error"] = None

    # 运行'git rev-parse --abbrev-ref HEAD'命令获取当前分支名
    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"], cwd=root)
    # --abbrev-ref选项从git-1.6.3版本开始支持
    if rc != 0 or branch_name is None:
        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
    branch_name = branch_name.strip()
    # 如果当前分支名为 "HEAD"
    if branch_name == "HEAD":
        # 如果当前不在一个具体分支上，选择一个代表当前提交的分支。如果一切失败，则表示当前是一个无分支的提交。
        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
        # --contains 参数在 git-1.5.4 版本中添加
        if rc != 0 or branches is None:
            raise NotThisMethod("'git branch --contains' returned error")
        branches = branches.split("\n")

        # 如果处于分离头状态，移除第一行
        if "(" in branches[0]:
            branches.pop(0)

        # 去除分支列表中每个元素开头的 "* "
        branches = [branch[2:] for branch in branches]
        # 如果包含 "master" 分支，则设置 branch_name 为 "master"
        if "master" in branches:
            branch_name = "master"
        # 如果分支列表为空，则设置 branch_name 为 None
        elif not branches:
            branch_name = None
        else:
            # 选择返回的第一个分支作为当前分支
            branch_name = branches[0]

    pieces["branch"] = branch_name

    # 解析 describe_out。其格式类似于 TAG-NUM-gHEX[-dirty] 或 HEX[-dirty]
    git_describe = describe_out

    # 查找是否以 "-dirty" 结尾
    dirty = git_describe.endswith("-dirty")
    pieces["dirty"] = dirty
    if dirty:
        # 如果存在 "-dirty" 后缀，则去除它
        git_describe = git_describe[: git_describe.rindex("-dirty")]

    # 现在 git_describe 的格式为 TAG-NUM-gHEX 或 HEX

    if "-" in git_describe:
        # 解析 TAG-NUM-gHEX 格式
        mo = re.search(r"^(.+)-(\d+)-g([0-9a-f]+)$", git_describe)
        if not mo:
            # 无法解析。可能是 git-describe 返回异常？
            pieces["error"] = f"unable to parse git-describe output: '{describe_out}'"
            return pieces

        # 完整的标签名
        full_tag = mo.group(1)
        # 如果标签名不以指定的 tag_prefix 开头，则记录错误信息
        if not full_tag.startswith(tag_prefix):
            if verbose:
                fmt = "tag '%s' doesn't start with prefix '%s'"
                print(fmt % (full_tag, tag_prefix))
            pieces["error"] = (
                f"tag '{full_tag}' doesn't start with prefix '{tag_prefix}'"
            )
            return pieces
        # 记录最接近的标签名（去除前缀后的部分）
        pieces["closest-tag"] = full_tag[len(tag_prefix):]

        # 记录与标签间的提交次数
        pieces["distance"] = int(mo.group(2))

        # 记录提交的短版本哈希
        pieces["short"] = mo.group(3)

    else:
        # 格式为 HEX，表示没有标签
        pieces["closest-tag"] = None
        # 获取当前提交与主分支间的提交数
        out, rc = runner(GITS, ["rev-list", "HEAD", "--left-right"], cwd=root)
        pieces["distance"] = len(out.split())  # 总提交数

    # 记录提交的日期，格式为 ISO-8601（详见 git_versions_from_keywords()）
    date = runner(GITS, ["show", "-s", "--format=%ci", "HEAD"], cwd=root)[0].strip()
    # 只使用最后一行日期信息，前面可能包含 GPG 签名信息
    date = date.splitlines()[-1]
    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)

    return pieces
# 返回 "+" 或 "."，取决于 pieces 字典中 "closest-tag" 字段是否包含 "+"
def plus_or_dot(pieces) -> str:
    if "+" in pieces.get("closest-tag", ""):
        return "."
    return "+"

# 构建版本字符串，包括后续发布的“本地版本标识符”
# 目标格式：TAG[+DISTANCE.gHEX[.dirty]]。注意，如果获取了已标记的构建，然后对其进行了更改，将得到 TAG+0.gHEX.dirty
# 异常情况：
# 1: 没有标签。git_describe 只返回 HEX。0+untagged.DISTANCE.gHEX[.dirty]
def render_pep440(pieces):
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"] or pieces["dirty"]:
            rendered += plus_or_dot(pieces)
            rendered += f"{pieces['distance']}.g{pieces['short']}"
            if pieces["dirty"]:
                rendered += ".dirty"
    else:
        # 异常情况 #1
        rendered = f"0+untagged.{pieces['distance']}.g{pieces['short']}"
        if pieces["dirty"]:
            rendered += ".dirty"
    return rendered

# 构建分支的 PEP 440 版本字符串
# 格式为：TAG[[.dev0]+DISTANCE.gHEX[.dirty]]。
# 注意 ".dev0" 表示非主分支。注意，.dev0 排序方式与主分支相反（功能分支将显示比主分支“更旧”）。
# 异常情况：
# 1: 没有标签。0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
def render_pep440_branch(pieces):
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"] or pieces["dirty"]:
            if pieces["branch"] != "master":
                rendered += ".dev0"
            rendered += plus_or_dot(pieces)
            rendered += f"{pieces['distance']}.g{pieces['short']}"
            if pieces["dirty"]:
                rendered += ".dirty"
    else:
        # 异常情况 #1
        rendered = "0"
        if pieces["branch"] != "master":
            rendered += ".dev0"
        rendered += f"+untagged.{pieces['distance']}.g{pieces['short']}"
        if pieces["dirty"]:
            rendered += ".dirty"
    return rendered

# 在 pep440 版本字符串中将其拆分为后续发布段
# 返回发布前的版本段和后续发布的版本号（如果不存在后续发布段则返回 -1）
def pep440_split_post(ver):
    vc = str.split(ver, ".post")
    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None

# 构建带有前发布的 PEP 440 版本字符串
# 格式为：TAG[.postN.devDISTANCE] -- 不带 -dirty
# 异常情况：
# 1: 没有标签。0.post0.devDISTANCE
def render_pep440_pre(pieces):
    if pieces["closest-tag"]:
        if pieces["distance"]:
            # 更新后发布段
            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
            rendered = tag_version
            if post_version is not None:
                rendered += f".post{post_version + 1}.dev{pieces['distance']}"
            else:
                rendered += f".post0.dev{pieces['distance']}"
        else:
            # 没有提交，使用标签作为版本
            rendered = pieces["closest-tag"]
    else:
        # 处理条件：当未匹配到任何情况时执行以下代码块
        # 构造一个字符串，包含特定格式的文本和变量 pieces['distance']
        rendered = f"0.post0.dev{pieces['distance']}"
    # 返回构造好的字符串 rendered
    return rendered
# 根据给定的 pieces 字典渲染 PEP 440 格式的版本字符串，表示一种版本的格式化标记
def render_pep440_post(pieces):
    """TAG[.postDISTANCE[.dev0]+gHEX] .

    The ".dev0" means dirty. Note that .dev0 sorts backwards
    (a dirty tree will appear "older" than the corresponding clean one),
    but you shouldn't be releasing software with -dirty anyways.

    Exceptions:
    1: no tags. 0.postDISTANCE[.dev0]
    """
    # 如果有最接近的标签（closest-tag）存在
    if pieces["closest-tag"]:
        # 初始化渲染结果为最接近的标签
        rendered = pieces["closest-tag"]
        # 如果存在 distance 或者 dirty 标记
        if pieces["distance"] or pieces["dirty"]:
            # 添加 .postDISTANCE 到渲染结果中
            rendered += f".post{pieces['distance']}"
            # 如果 dirty 标记存在，添加 .dev0
            if pieces["dirty"]:
                rendered += ".dev0"
            # 添加加号或者点（根据函数 plus_or_dot 的返回结果）
            rendered += plus_or_dot(pieces)
            # 添加 gHEX 到渲染结果中
            rendered += f"g{pieces['short']}"
    else:
        # exception #1 的情况下，初始化渲染结果为 0.postDISTANCE
        rendered = f"0.post{pieces['distance']}"
        # 如果 dirty 标记存在，添加 .dev0
        if pieces["dirty"]:
            rendered += ".dev0"
        # 添加 +gHEX 到渲染结果中
        rendered += f"+g{pieces['short']}"
    # 返回最终渲染结果
    return rendered


# 根据给定的 pieces 字典渲染 PEP 440 格式的版本字符串，包含分支信息的变种
def render_pep440_post_branch(pieces):
    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .

    The ".dev0" means not master branch.

    Exceptions:
    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
    """
    # 如果有最接近的标签（closest-tag）存在
    if pieces["closest-tag"]:
        # 初始化渲染结果为最接近的标签
        rendered = pieces["closest-tag"]
        # 如果存在 distance 或者 dirty 标记
        if pieces["distance"] or pieces["dirty"]:
            # 添加 .postDISTANCE 到渲染结果中
            rendered += f".post{pieces['distance']}"
            # 如果不是 master 分支，添加 .dev0
            if pieces["branch"] != "master":
                rendered += ".dev0"
            # 添加加号或者点（根据函数 plus_or_dot 的返回结果）
            rendered += plus_or_dot(pieces)
            # 添加 gHEX 到渲染结果中
            rendered += f"g{pieces['short']}"
            # 如果 dirty 标记存在，添加 .dirty
            if pieces["dirty"]:
                rendered += ".dirty"
    else:
        # exception #1 的情况下，初始化渲染结果为 0.postDISTANCE+gHEX
        rendered = f"0.post{pieces['distance']}"
        # 如果不是 master 分支，添加 .dev0
        if pieces["branch"] != "master":
            rendered += ".dev0"
        # 添加 +gHEX 到渲染结果中
        rendered += f"+g{pieces['short']}"
        # 如果 dirty 标记存在，添加 .dirty
        if pieces["dirty"]:
            rendered += ".dirty"
    # 返回最终渲染结果
    return rendered


# 根据给定的 pieces 字典渲染旧版 PEP 440 格式的版本字符串
def render_pep440_old(pieces):
    """TAG[.postDISTANCE[.dev0]] .

    The ".dev0" means dirty.

    Exceptions:
    1: no tags. 0.postDISTANCE[.dev0]
    """
    # 如果有最接近的标签（closest-tag）存在
    if pieces["closest-tag"]:
        # 初始化渲染结果为最接近的标签
        rendered = pieces["closest-tag"]
        # 如果存在 distance 或者 dirty 标记
        if pieces["distance"] or pieces["dirty"]:
            # 添加 0.postDISTANCE 到渲染结果中
            rendered += f"0.post{pieces['distance']}"
            # 如果 dirty 标记存在，添加 .dev0
            if pieces["dirty"]:
                rendered += ".dev0"
    else:
        # exception #1 的情况下，初始化渲染结果为 0.postDISTANCE
        rendered = f"0.post{pieces['distance']}"
        # 如果 dirty 标记存在，添加 .dev0
        if pieces["dirty"]:
            rendered += ".dev0"
    # 返回最终渲染结果
    return rendered


# 根据给定的 pieces 字典渲染类似于 'git describe --tags --dirty --always' 的版本字符串
def render_git_describe(pieces):
    """TAG[-DISTANCE-gHEX][-dirty].

    Like 'git describe --tags --dirty --always'.

    Exceptions:
    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
    """
    # 如果有最接近的标签（closest-tag）存在
    if pieces["closest-tag"]:
        # 初始化渲染结果为最接近的标签
        rendered = pieces["closest-tag"]
        # 如果存在 distance 标记
        if pieces["distance"]:
            # 添加 -DISTANCE-gHEX 到渲染结果中
            rendered += f"-{pieces['distance']}-g{pieces['short']}"
    else:
        # exception #1 的情况下，初始化渲染结果为 HEX
        rendered = pieces["short"]
    # 如果 dirty 标记存在，添加 -dirty 到渲染结果中
    if pieces["dirty"]:
        rendered += "-dirty"
    # 返回最终渲染结果
    return rendered


# 根据给定的 pieces 字典渲染详细版的 'git describe --tags --dirty --always' 类似的版本字符串
def render_git_describe_long(pieces):
    """TAG-DISTANCE-gHEX[-dirty].

    Like 'git describe --tags --dirty --always -long'.
    """
    # 如果有最接近的标签（closest-tag）存在
    if pieces["closest-tag"]:
        # 初始化渲染结果为最接近的标签
        rendered = pieces["closest-tag"]
        # 添加 -DISTANCE-gHEX 到渲染结果中
        rendered += f"-{pieces['distance']}-g{pieces['short']}"
    else:
        # 初始化渲染结果为 pieces 的 short 属性
        rendered = pieces["short"]
    # 如果 dirty 标记存在，添加 -dirty 到渲染结果中
    if pieces["dirty"]:
        rendered += "-dirty"
    # 返回最终渲染结果
    return rendered
    """
    无条件距离/哈希。

    异常情况：
    1: 没有标签。HEX[-dirty]（注意：没有 'g' 前缀）
    """
    # 如果存在最接近的标签
    if pieces["closest-tag"]:
        # 将渲染结果初始化为最接近的标签
        rendered = pieces["closest-tag"]
        # 拼接距离和短哈希到渲染结果中
        rendered += f"-{pieces['distance']}-g{pieces['short']}"
    else:
        # 如果没有最接近的标签，使用短哈希作为渲染结果（异常情况 #1）
        rendered = pieces["short"]
    # 如果存在 dirty 标志，添加 '-dirty' 到渲染结果中
    if pieces["dirty"]:
        rendered += "-dirty"
    # 返回最终渲染的结果
    return rendered
# 获取版本信息或者在无法获取时返回默认值
def get_versions():
    """Get version information or return default if unable to do so."""
    # 获取配置信息
    cfg = get_config()
    verbose = cfg.verbose

    try:
        # 尝试从关键字获取 Git 版本信息
        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)
    except NotThisMethod:
        pass

    try:
        # 尝试获取当前文件的真实路径作为根路径
        root = os.path.realpath(__file__)
        # versionfile_source 是从源树顶部到当前文件的相对路径，通过反向操作来找到源树的根
        for _ in cfg.versionfile_source.split("/"):
            root = os.path.dirname(root)
    except NameError:
        # 如果出现 NameError，说明无法找到根路径，返回默认错误信息
        return {
            "version": "0+unknown",
            "full-revisionid": None,
            "dirty": None,
            "error": "unable to find root of source tree",
            "date": None,
        }

    try:
        # 尝试从 VCS（版本控制系统）获取 Git 版本信息的各个部分
        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
        return render(pieces, cfg.style)
    except NotThisMethod:
        pass

    try:
        # 如果配置中指定了 parentdir_prefix，则尝试从父目录中获取版本信息
        if cfg.parentdir_prefix:
            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
    except NotThisMethod:
        pass

    # 如果以上所有尝试都失败，则返回默认的错误信息
    return {
        "version": "0+unknown",
        "full-revisionid": None,
        "dirty": None,
        "error": "unable to compute version",
        "date": None,
    }
```