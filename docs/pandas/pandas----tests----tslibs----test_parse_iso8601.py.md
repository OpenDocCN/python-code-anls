# `D:\src\scipysrc\pandas\pandas\tests\tslibs\test_parse_iso8601.py`

```
# 导入需要的模块和类
from datetime import datetime

# 导入 pytest 测试框架
import pytest

# 导入 pandas 库中的 tslib 模块
from pandas._libs import tslib

# 导入 pandas 库中的 Timestamp 类
from pandas import Timestamp

# 使用 pytest.mark.parametrize 装饰器定义参数化测试
@pytest.mark.parametrize(
    "date_str, exp",
    [
        ("2011-01-02", datetime(2011, 1, 2)),  # 测试标准日期格式
        ("2011-1-2", datetime(2011, 1, 2)),    # 测试无前导零的日期格式
        ("2011-01", datetime(2011, 1, 1)),    # 测试只有年月的日期格式
        ("2011-1", datetime(2011, 1, 1)),     # 测试只有年月的日期格式，无前导零
        ("2011 01 02", datetime(2011, 1, 2)), # 测试使用空格分隔的日期格式
        ("2011.01.02", datetime(2011, 1, 2)), # 测试使用点分隔的日期格式
        ("2011/01/02", datetime(2011, 1, 2)), # 测试使用斜杠分隔的日期格式
        ("2011\\01\\02", datetime(2011, 1, 2)), # 测试使用反斜杠分隔的日期格式
        ("2013-01-01 05:30:00", datetime(2013, 1, 1, 5, 30)),  # 测试带时间的日期时间格式
        ("2013-1-1 5:30:00", datetime(2013, 1, 1, 5, 30)),     # 测试带时间的日期时间格式，无前导零
        ("2013-1-1 5:30:00+01:00", Timestamp(2013, 1, 1, 5, 30, tz="UTC+01:00")),  # 测试带时区信息的日期时间格式
    ],
)
def test_parsers_iso8601(date_str, exp):
    # 标记：参见 GitHub 问题 #12060
    #
    # 仅测试 ISO 解析器 - 对于不同分隔符和前导零的灵活性。
    actual = tslib._test_parse_iso8601(date_str)  # 调用 tslib 模块中的 ISO 8601 时间解析函数
    assert actual == exp  # 断言解析结果与预期结果一致


# 使用 pytest.mark.parametrize 装饰器定义参数化测试
@pytest.mark.parametrize(
    "date_str",
    [
        "2011-01/02",           # 测试包含非法分隔符的日期格式
        "2011=11=11",           # 测试包含非法分隔符的日期格式
        "201401",               # 测试无分隔符的年月格式
        "201111",               # 测试无分隔符的年月格式
        "200101",               # 测试无分隔符的年月格式
        # 混合分隔和无分隔的日期时间格式。
        "2005-0101",            # 测试混合使用分隔符和无分隔符的日期格式
        "200501-01",            # 测试混合使用分隔符和无分隔符的日期格式
        "20010101 12:3456",     # 测试带有非法时间格式的日期时间格式
        "20010101 1234:56",     # 测试带有非法时间格式的日期时间格式
        # 如果 HHMMSS 不是以两位数字开始，则应引发 ValueError。
        "20010101 1",           # 测试带有不正确格式的小时部分
        "20010101 123",         # 测试带有不正确格式的分钟部分
        "20010101 12345",       # 测试带有不正确格式的秒部分
        "20010101 12345Z",      # 测试带有非法时区信息的日期时间格式
    ],
)
def test_parsers_iso8601_invalid(date_str):
    msg = f'Error parsing datetime string "{date_str}"'
    
    # 使用 pytest.raises 断言捕获 ValueError 异常，并验证异常消息
    with pytest.raises(ValueError, match=msg):
        tslib._test_parse_iso8601(date_str)  # 调用 tslib 模块中的 ISO 8601 时间解析函数


def test_parsers_iso8601_invalid_offset_invalid():
    date_str = "2001-01-01 12-34-56"
    msg = f'Timezone hours offset out of range in datetime string "{date_str}"'

    # 使用 pytest.raises 断言捕获 ValueError 异常，并验证异常消息
    with pytest.raises(ValueError, match=msg):
        tslib._test_parse_iso8601(date_str)  # 调用 tslib 模块中的 ISO 8601 时间解析函数


def test_parsers_iso8601_leading_space():
    # GH#25895 确保 isoparser 在长输入时不会溢出
    date_str, expected = ("2013-1-1 5:30:00", datetime(2013, 1, 1, 5, 30))
    actual = tslib._test_parse_iso8601(" " * 200 + date_str)  # 测试长输入时的解析
    assert actual == expected  # 断言解析结果与预期结果一致
    [
        # 示例时间和格式转换的元组列表
        ("2023-01-01 00:00:00", "auto", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00", "seconds", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00", "milliseconds", "2023-01-01T00:00:00.000"),
        ("2023-01-01 00:00:00", "microseconds", "2023-01-01T00:00:00.000000"),
        ("2023-01-01 00:00:00", "nanoseconds", "2023-01-01T00:00:00.000000000"),
        ("2023-01-01 00:00:00.001", "auto", "2023-01-01T00:00:00.001000"),
        ("2023-01-01 00:00:00.001", "seconds", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00.001", "milliseconds", "2023-01-01T00:00:00.001"),
        ("2023-01-01 00:00:00.001", "microseconds", "2023-01-01T00:00:00.001000"),
        ("2023-01-01 00:00:00.001", "nanoseconds", "2023-01-01T00:00:00.001000000"),
        ("2023-01-01 00:00:00.000001", "auto", "2023-01-01T00:00:00.000001"),
        ("2023-01-01 00:00:00.000001", "seconds", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00.000001", "milliseconds", "2023-01-01T00:00:00.000"),
        ("2023-01-01 00:00:00.000001", "microseconds", "2023-01-01T00:00:00.000001"),
        ("2023-01-01 00:00:00.000001", "nanoseconds", "2023-01-01T00:00:00.000001000"),
        ("2023-01-01 00:00:00.000000001", "auto", "2023-01-01T00:00:00.000000001"),
        ("2023-01-01 00:00:00.000000001", "seconds", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00.000000001", "milliseconds", "2023-01-01T00:00:00.000"),
        ("2023-01-01 00:00:00.000000001", "microseconds", "2023-01-01T00:00:00.000000"),
        (
            "2023-01-01 00:00:00.000000001",
            "nanoseconds",
            "2023-01-01T00:00:00.000000001",
        ),
        ("2023-01-01 00:00:00.000001001", "auto", "2023-01-01T00:00:00.000001001"),
        ("2023-01-01 00:00:00.000001001", "seconds", "2023-01-01T00:00:00"),
        ("2023-01-01 00:00:00.000001001", "milliseconds", "2023-01-01T00:00:00.000"),
        ("2023-01-01 00:00:00.000001001", "microseconds", "2023-01-01T00:00:00.000001"),
        (
            "2023-01-01 00:00:00.000001001",
            "nanoseconds",
            "2023-01-01T00:00:00.000001001",
        ),
    ],
# GH#53020
# 根据给定的日期字符串和时间精度，创建一个时间戳对象
ts = Timestamp(date_str)
# 使用给定的时间精度格式化时间戳并与预期结果进行比较，确保一致性
assert ts.isoformat(timespec=timespec) == exp
```