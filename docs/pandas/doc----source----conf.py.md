# `D:\src\scipysrc\pandas\doc\source\conf.py`

```
# pandas documentation build configuration file, created by
# 用于配置 pandas 文档生成的配置文件，由下列代码创建

# This file is execfile()d with the current directory set to its containing
# dir.
# 该文件通过 execfile() 函数执行，当前工作目录被设置为其所在的目录

# Note that not all possible configuration values are present in this
# autogenerated file.
# 注意，这个自动生成的文件中并未包含所有可能的配置值

# All configuration values have a default; values that are commented out
# serve to show the default.
# 所有配置值都有一个默认值；被注释掉的值展示了默认设置

from datetime import datetime  # 导入 datetime 模块中的 datetime 类
import importlib  # 导入 importlib 模块，用于动态导入
import inspect  # 导入 inspect 模块，用于解析对象信息
import logging  # 导入 logging 模块，用于日志记录
import os  # 导入 os 模块，提供操作系统相关功能
import re  # 导入 re 模块，用于正则表达式操作
import sys  # 导入 sys 模块，提供系统相关功能
import warnings  # 导入 warnings 模块，用于警告管理

import jinja2  # 导入 jinja2 模块，模板引擎
from numpydoc.docscrape import NumpyDocString  # 从 numpydoc.docscrape 中导入 NumpyDocString 类
from sphinx.ext.autosummary import _import_by_name  # 从 sphinx.ext.autosummary 中导入 _import_by_name 函数

logger = logging.getLogger(__name__)  # 获取当前模块的日志记录器对象

# https://github.com/sphinx-doc/sphinx/pull/2325/files
# Workaround for sphinx-build recursion limit overflow:
# pickle.dump(doctree, f, pickle.HIGHEST_PROTOCOL)
#  RuntimeError: maximum recursion depth exceeded while pickling an object
#
# Python's default allowed recursion depth is 1000.
sys.setrecursionlimit(5000)  # 设置 Python 解释器递归调用限制为 5000，用于解决 sphinx-build 递归深度溢出的问题

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# 如果扩展（或需要文档化的模块）位于另一个目录中，可以在这里将这些目录添加到 sys.path 中。
# 如果目录相对于文档根目录，则使用 os.path.abspath 将其转换为绝对路径，如下所示。
sys.path.insert(0, os.path.abspath("../sphinxext"))  # 将 "../sphinxext" 目录添加到 sys.path 的最前面
sys.path.extend(
    [
        # numpy standard doc extensions
        os.path.join(os.path.dirname(__file__), "..", "../..", "sphinxext")
        # 添加 numpy 标准文档扩展所在的目录到 sys.path 中
    ]
)

# -- General configuration -----------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# 在这里添加任何 Sphinx 扩展模块的名称作为字符串。
# 它们可以是随 Sphinx 提供的扩展（如 'sphinx.ext.*'）或自定义的扩展。

extensions = [
    "contributors",  # 自定义的 pandas 扩展模块
    "IPython.sphinxext.ipython_directive",  # IPython 指令扩展模块
    "IPython.sphinxext.ipython_console_highlighting",  # IPython 控制台高亮模块
    "matplotlib.sphinxext.plot_directive",  # matplotlib 图形指令模块
    "numpydoc",  # numpydoc 模块
    "sphinx_copybutton",  # 复制按钮模块
    "sphinx_design",  # 设计模块
    "sphinx.ext.autodoc",  # 自动生成文档模块
    "sphinx.ext.autosummary",  # 自动生成摘要模块
    "sphinx.ext.coverage",  # 覆盖率模块
    "sphinx.ext.doctest",  # doctest 模块
    "sphinx.ext.extlinks",  # 外部链接模块
    "sphinx.ext.ifconfig",  # ifconfig 模块
    "sphinx.ext.intersphinx",  # intersphinx 模块
    "sphinx.ext.linkcode",  # linkcode 模块
    "sphinx.ext.mathjax",  # mathjax 模块
    "sphinx.ext.todo",  # 待办事项模块
    "nbsphinx",  # nbsphinx 模块
]

exclude_patterns = [
    "**.ipynb_checkpoints",  # 排除所有 .ipynb_checkpoints 文件
    # to ensure that include files (partial pages) aren't built, exclude them
    # https://github.com/sphinx-doc/sphinx/issues/1965#issuecomment-124732907
    "**/includes/**",  # 排除所有位于 includes 目录下的文件
]
try:
    import nbconvert
except ImportError:
    logger.warning("nbconvert not installed. Skipping notebooks.")
    exclude_patterns.append("**/*.ipynb")  # 如果未安装 nbconvert，排除所有 .ipynb 文件
else:
    try:
        nbconvert.utils.pandoc.get_pandoc_version()
    except nbconvert.utils.pandoc.PandocMissing:
        logger.warning("Pandoc not installed. Skipping notebooks.")
        exclude_patterns.append("**/*.ipynb")  # 如果未安装 Pandoc，排除所有 .ipynb 文件

# sphinx_pattern can be '-api' to exclude the API pages,
# the path to a file, or a Python object
# (e.g. '10min.rst' or 'pandas.DataFrame.head')
# sphinx_pattern 可以是 '-api' 用于排除 API 页面，
# 也可以是文件的路径，或者是 Python 对象（例如 '10min.rst' 或 'pandas.DataFrame.head'）
# 获取当前文件的绝对路径所在的目录
source_path = os.path.dirname(os.path.abspath(__file__))
# 从环境变量中获取 SPHINX_PATTERN 的值
pattern = os.environ.get("SPHINX_PATTERN")
# 根据 SPHINX_PATTERN 的值判断是否为单篇文档模式
single_doc = pattern is not None and pattern not in ("-api", "whatsnew")
# 根据 SPHINX_PATTERN 的值确定是否包含 API 文档
include_api = pattern is None or pattern == "whatsnew"

# 如果存在 SPHINX_PATTERN，则开始遍历源路径下的所有目录和文件
if pattern:
    for dirname, dirs, fnames in os.walk(source_path):
        # 计算当前目录的相对路径
        reldir = os.path.relpath(dirname, source_path)
        # 遍历当前目录下的所有文件
        for fname in fnames:
            # 如果文件扩展名是 .rst 或 .ipynb
            if os.path.splitext(fname)[-1] in (".rst", ".ipynb"):
                # 计算当前文件的相对路径
                rel_fname = os.path.relpath(os.path.join(dirname, fname), source_path)

                # 排除 index.rst 文件，因为它在根目录下
                if rel_fname == "index.rst" and os.path.abspath(dirname) == source_path:
                    continue

                # 根据 SPHINX_PATTERN 的不同值，排除特定的文件
                if pattern == "-api" and reldir.startswith("reference"):
                    exclude_patterns.append(rel_fname)
                elif pattern == "whatsnew" and not reldir.startswith("reference") and reldir != "whatsnew":
                    exclude_patterns.append(rel_fname)
                elif single_doc and rel_fname != pattern:
                    exclude_patterns.append(rel_fname)

# 打开 index.rst.template 文件，并读取其内容作为模板
with open(os.path.join(source_path, "index.rst.template"), encoding="utf-8") as f:
    t = jinja2.Template(f.read())

# 打开 index.rst 文件，以写入模式打开，并使用 UTF-8 编码
with open(os.path.join(source_path, "index.rst"), "w", encoding="utf-8") as f:
    # 使用模板 t 渲染 index.rst 文件，并写入文件 f
    f.write(
        t.render(
            include_api=include_api,
            single_doc=(pattern if single_doc else None),
        )
    )

# 根据 include_api 的值确定是否生成 autosummary
autosummary_generate = True if include_api else ["index"]
# 禁用自动文档生成函数参数的类型提示
autodoc_typehints = "none"

# 设置 numpydoc 配置项
numpydoc_show_class_members = False
numpydoc_show_inherited_class_members = False
numpydoc_attributes_as_param_list = False

# 设置 matplotlib plot directive 配置项
plot_include_source = True
plot_formats = [("png", 90)]
plot_html_show_formats = False
plot_html_show_source_link = False
plot_pre_code = """import numpy as np
import pandas as pd"""

# 设置 nbsphinx 配置项，禁用 requirejs
nbsphinx_requirejs_path = ""

# 设置 toggleprompt_offset_right 的值为 35
toggleprompt_offset_right = 35

# 将模板文件路径添加到 templates_path 中
templates_path = ["../_templates"]

# 源文件名的后缀
source_suffix = [".rst"]

# 源文件的编码方式
source_encoding = "utf-8"

# 主文档的 toctree 文档
master_doc = "index"

# 关于项目的一般信息
project = "pandas"
# 使用当前年份作为版权信息的年份
copyright = f"{datetime.now().year},"

# 获取 pandas 库的版本信息
import pandas  # isort:skip
version = str(pandas.__version__)

# 获取完整的版本信息，包括 alpha/beta/rc 标签
release = version
# Sphinx 自动生成内容的语言设定为英文
language = "en"

# 如果设置了 |today| 的值，则使用该值作为当前日期
# 如果未设置，则使用 today_fmt 作为 strftime 调用的格式
# today = ''
# today_fmt = '%B %d, %Y'

# 不包含在构建中的文档列表
# unused_docs = []

# 搜索源文件时不应该搜索的相对于源目录的目录列表
exclude_trees = []

# reST 默认角色（用于标记语法）的设置，默认为 None
# default_role = None

# 如果为 True，则对 :func: 等交叉引用文本附加 '()' 括号
# add_function_parentheses = True

# 如果为 True，则当前模块名称将添加到所有描述单元标题之前（例如 .. function::）
# add_module_names = True

# 如果为 True，则输出中将显示 sectionauthor 和 moduleauthor 指令，默认情况下会忽略它们
# show_authors = False

# 使用的 Pygments（语法高亮）样式名称
pygments_style = "sphinx"

# 用于模块索引排序时忽略的前缀列表
# modindex_common_prefix = []


# -- HTML 输出选项 --------------------------------------------------------

# 用于 HTML 和 HTML 帮助页面的主题。目前主题包括 'default' 和 'sphinxdoc'。
html_theme = "pydata_sphinx_theme"

# 用于 HTML 和 HTML 帮助页面的样式表。必须存在具有该名称的文件，位于 Sphinx 的 static/ 路径中或自定义路径中的一个。
# html_style = 'statsmodels.css'

# 主题选项是特定主题的设置，用于进一步自定义主题的外观和感觉。有关每个主题可用选项的列表，请参见文档。
html_theme_options = {
    "external_links": [],
    "footer_start": ["pandas_footer", "sphinx-version"],
    "github_url": "https://github.com/pandas-dev/pandas",
    "twitter_url": "https://twitter.com/pandas_dev",
    "analytics": {
        "plausible_analytics_domain": "pandas.pydata.org",
        "plausible_analytics_url": "https://views.scientific-python.org/js/script.js",
    },
    "logo": {"image_dark": "https://pandas.pydata.org/static/img/pandas_white.svg"},
    "navbar_align": "left",
    "navbar_end": ["version-switcher", "theme-switcher", "navbar-icon-links"],
    "switcher": {
        "json_url": "https://pandas.pydata.org/versions.json",
        "version_match": switcher_version,  # 从版本号中匹配出的版本信息
    },
    "show_version_warning_banner": True,
}
    "icon_links": [
        {  # 开始一个包含链接信息的字典
            "name": "Mastodon",  # 链接的名称是 Mastodon
            "url": "https://fosstodon.org/@pandas_dev",  # 链接的 URL 地址
            "icon": "fa-brands fa-mastodon",  # 链接对应的图标样式类
        },  # 结束链接信息的字典
    ],
# }

# Add any paths that contain custom themes here, relative to this directory.
# 定义包含自定义主题的路径列表，相对于当前目录。
html_theme_path = ["themes"]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# Sphinx 文档集的名称。如果为 None，则默认为 "<project> v<release> documentation"。
html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# 导航栏的较短标题。默认与 html_title 相同。
html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# 用于放置在侧边栏顶部的图像文件的名称（相对于当前目录）。
html_logo = "../../web/pandas/static/img/pandas.svg"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# 定义包含自定义静态文件（例如样式表）的路径列表，相对于当前目录。
# 这些文件会复制到内置静态文件之后，因此命名为 "default.css" 的文件将覆盖内置的 "default.css"。
html_static_path = ["_static"]

# Define additional CSS files to be included in the HTML output.
# 定义要包含在 HTML 输出中的额外 CSS 文件列表。
html_css_files = [
    "css/getting_started.css",
    "css/pandas.css",
]

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# 用作文档网站 favicon 的图像文件的名称（相对于静态路径）。
# 该文件应为 Windows 图标文件（.ico），大小为 16x16 或 32x32 像素。
html_favicon = "../../web/pandas/static/img/favicon.ico"

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# 如果不是空字符串，则在每页底部插入“最后更新于”时间戳，使用指定的 strftime 格式。
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# 如果为 True，则使用 SmartyPants 将引号和破折号转换为排版正确的实体。
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# 自定义侧边栏模板，将文档名称映射到模板名称。
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.

# Add redirect for previously existing API pages
# each item is like `(from_old, to_new)`
# To redirect a class and all its methods, see below
# https://github.com/pandas-dev/pandas/issues/16186

# 为先前存在的 API 页面添加重定向
# 每个条目的格式为 `(from_old, to_new)`
# 若要重定向类及其所有方法，请参见下面的链接
# https://github.com/pandas-dev/pandas/issues/16186
moved_api_pages = [
    ("pandas.core.common.isnull", "pandas.isna"),
    ("pandas.core.common.notnull", "pandas.notna"),
    ("pandas.core.reshape.get_dummies", "pandas.get_dummies"),
    ("pandas.tools.merge.concat", "pandas.concat"),
    ("pandas.tools.merge.merge", "pandas.merge"),
    ("pandas.tools.pivot.pivot_table", "pandas.pivot_table"),
    ("pandas.tseries.tools.to_datetime", "pandas.to_datetime"),
    ("pandas.io.clipboard.read_clipboard", "pandas.read_clipboard"),
    ("pandas.io.excel.ExcelFile.parse", "pandas.ExcelFile.parse"),
    ("pandas.io.excel.read_excel", "pandas.read_excel"),
    ("pandas.io.html.read_html", "pandas.read_html"),
    ("pandas.io.json.read_json", "pandas.read_json"),
    ("pandas.io.parsers.read_csv", "pandas.read_csv"),
    ("pandas.io.parsers.read_fwf", "pandas.read_fwf"),
    ("pandas.io.parsers.read_table", "pandas.read_table"),
    ("pandas.io.pickle.read_pickle", "pandas.read_pickle"),
    ("pandas.io.pytables.HDFStore.append", "pandas.HDFStore.append"),
    ("pandas.io.pytables.HDFStore.get", "pandas.HDFStore.get"),
    ("pandas.io.pytables.HDFStore.put", "pandas.HDFStore.put"),
    ("pandas.io.pytables.HDFStore.select", "pandas.HDFStore.select"),
    ("pandas.io.pytables.read_hdf", "pandas.read_hdf"),
]
    # 创建元组，包含函数在模块中的原始位置和新位置的映射关系
    ("pandas.io.sql.read_sql", "pandas.read_sql"),
    # 创建元组，包含函数在模块中的原始位置和新位置的映射关系
    ("pandas.io.sql.read_frame", "pandas.read_frame"),
    # 创建元组，包含函数在模块中的原始位置和新位置的映射关系
    ("pandas.io.sql.write_frame", "pandas.write_frame"),
    # 创建元组，包含函数在模块中的原始位置和新位置的映射关系
    ("pandas.io.stata.read_stata", "pandas.read_stata"),
# Again, tuples of (from_old, to_new)
# 定义包含旧类名到新类名映射的元组列表
moved_classes = [
    ("pandas.tseries.resample.Resampler", "pandas.core.resample.Resampler"),
    ("pandas.formats.style.Styler", "pandas.io.formats.style.Styler"),
]

# Iterate over each tuple in moved_classes
for old, new in moved_classes:
    # the class itself...
    # 将旧类名和新类名的元组添加到moved_api_pages列表中
    moved_api_pages.append((old, new))

    # Split the new class name into module and class name
    # 拆分新类名为模块和类名
    mod, classname = new.rsplit(".", 1)

    # Dynamically import the module and retrieve the class object
    # 动态导入模块，并获取类对象
    klass = getattr(importlib.import_module(mod), classname)

    # List comprehension to filter out private methods and specific dunder methods
    # 列表推导式，筛选出非私有方法和特定的双下划线方法
    methods = [
        x for x in dir(klass) if not x.startswith("_") or x in ("__iter__", "__array__")
    ]

    # ... and each of its public methods
    # 将每个公共方法的旧方法名和新方法名添加到moved_api_pages列表中
    moved_api_pages.extend((f"{old}.{method}", f"{new}.{method}") for method in methods)

# If include_api is true, generate HTML additional pages for API redirects
# 如果include_api为True，则为API重定向生成HTML附加页面
if include_api:
    html_additional_pages = {
        "generated/" + page[0]: "api_redirect.html" for page in moved_api_pages
    }

# Header string for Sphinx documentation
# Sphinx文档的头部字符串
header = f"""\
.. currentmodule:: pandas

.. ipython:: python
   :suppress:

   import numpy as np
   import pandas as pd

   np.random.seed(123456)
   np.set_printoptions(precision=4, suppress=True)
   pd.options.display.max_rows = 15

   import os
   os.chdir(r'{os.path.dirname(os.path.dirname(__file__))}')
"""

# Context dictionary for HTML rendering
# HTML渲染的上下文字典
html_context = {
    "redirects": dict(moved_api_pages),
    "header": header,
}

# If false, no module index is generated.
# 如果为false，则不生成模块索引
html_use_modindex = True

# If false, no index is generated.
# 如果为false，则不生成索引
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# 如果为true，则索引分割成每个字母的单独页面
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# 如果为true，则在页面中添加到reST源文件的链接
# html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# 如果不为空，则是HTML文件的文件名后缀（例如“.xhtml”）
# html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
# 输出的HTML帮助生成器的基本文件名
# html_file_suffix = ''

# Output file base name for HTML help builder.
# HTML帮助生成器的输出文件基本名称
htmlhelp_basename = "pandas"

# -- Options for nbsphinx ------------------------------------------------

# 如果为true，则允许nbsphinx遇到错误时继续执行
nbsphinx_allow_errors = True

# -- Options for LaTeX output --------------------------------------------

latex_elements = {}

# The paper size ('letter' or 'a4').
# 纸张大小（“letter”或“a4”）
# latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
# 字体大小（'10pt'，'11pt'或'12pt'）
# latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples (source start
# file, target name, title, author, documentclass [howto/manual]).
# 将文档树分组为LaTeX文件。元组列表（源开始文件，目标名称，标题，作者，文档类[howto/manual]）
latex_documents = [
    (
        "index",
        "pandas.tex",
        "pandas: powerful Python data analysis toolkit",
        "Wes McKinney and the pandas Development Team",
        "manual",
    )
]

# The name of an image file (relative to this directory) to place at the top of the title page.
# 放置在标题页面顶部的图像文件的名称（相对于此目录）
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts, not chapters.
# 对于“manual”文档，如果为true，则顶级标题是部分而不是章节。
# latex_use_parts = False

# Additional stuff for the LaTeX preamble.
# LaTeX导言中的附加内容
# latex_preamble = ''

# Documents to append as an appendix to all manuals.
# 要附加为所有手册的附录文件。
# latex_appendices = []
# 如果为 False，则不生成模块索引。
# latex_use_modindex = True

# 如果 include_api 为 True，则设置 intersphinx 映射，用于跨文档之间的链接。
if include_api:
    # 定义 intersphinx 映射，将外部文档链接到本文档。
    intersphinx_mapping = {
        "dateutil": ("https://dateutil.readthedocs.io/en/latest/", None),
        "matplotlib": ("https://matplotlib.org/stable/", None),
        "numpy": ("https://numpy.org/doc/stable/", None),
        "python": ("https://docs.python.org/3/", None),
        "scipy": ("https://docs.scipy.org/doc/scipy/", None),
        "pyarrow": ("https://arrow.apache.org/docs/", None),
    }

# 定义外部链接的缩写，用于简化在文档中引用的外部资源链接。
extlinks = {
    "issue": ("https://github.com/pandas-dev/pandas/issues/%s", "GH %s"),
}

# 定义 IPython 执行的命令列表，用于设置文档生成时的环境。
ipython_execlines = [
    "import numpy as np",
    "import pandas as pd",
    # 确保在控制台编码不是 utf8 的系统上也能正确显示。
    # 强制 pandas 使用 utf8 编码其输出 repr，无论文档在何处构建。
    # 文档的目标是浏览器，而不是控制台，因此这样做是安全的。
    'pd.options.display.encoding="utf8"',
]

# 导入特定模块和类，用于扩展 Sphinx 的自动文档功能。
import sphinx  # isort:skip
from sphinx.ext.autodoc import (  # isort:skip
    AttributeDocumenter,
    Documenter,
    MethodDocumenter,
)
from sphinx.ext.autosummary import Autosummary  # isort:skip

# 定义自定义的文档生成器，用于处理 AccessorProperty 的属性和方法。
class AccessorDocumenter(MethodDocumenter):
    """
    用于处理访问器属性的特殊文档生成器子类。
    """

    objtype = "accessor"
    directivetype = "method"

    # 优先级设置为比普通方法文档生成器低，以确保不会被普通方法选中。
    priority = 0.6

    # 覆盖 format_signature 方法，避免对访问器生成错误或警告（因为访问器没有参数）。
    def format_signature(self) -> str:
        return ""

# 定义文档生成器的子类，用于处理 Accessor 层级上的对象（方法、属性等）。
class AccessorLevelDocumenter(Documenter):
    """
    用于处理访问器层级对象（方法、属性等）的特殊文档生成器子类。
    """

    # 这是简单直接的版本
    # modname 是 None，基于最后的元素（例如 'hour'）
    # path 是前面部分（例如 'Series.dt'）
    # def resolve_name(self, modname, parents, path, base):
    #     modname = 'pandas'
    #     mod_cls = path.rstrip('.')
    #     mod_cls = mod_cls.split('.')
    #
    #     return modname, mod_cls + [base]
    # 解析模块名，返回规范化后的模块名和其父模块列表
    def resolve_name(self, modname, parents, path, base):
        # 如果模块名为 None
        if modname is None:
            # 如果给定了路径
            if path:
                # 移除路径末尾的点号，得到模块类
                mod_cls = path.rstrip(".")
            else:
                # 否则模块类为 None
                mod_cls = None
                # 如果正在文档化类级对象且没有路径
                if mod_cls is None:
                    # 从环境临时数据中获取 "autodoc:class" 的值作为当前类
                    mod_cls = self.env.temp_data.get("autodoc:class")
                    # 如果仍为空，则尝试从 "py:class" 获取当前类
                    if mod_cls is None:
                        mod_cls = self.env.temp_data.get("py:class")
                    # 如果还是 None，则无法确定当前类
                    if mod_cls is None:
                        return None, []
                # HACK: 和 ClassLevelDocumenter 相比，这里多了一步，因为 mod_cls 可能是 class.accessor，需要再次分离
                modname, _, accessor = mod_cls.rpartition(".")
                modname, _, cls = modname.rpartition(".")
                # 将 cls 和 accessor 加入父模块列表
                parents = [cls, accessor]
                # 如果模块名仍为空
                if not modname:
                    # 尝试从环境临时数据中获取 "autodoc:module" 作为模块名
                    modname = self.env.temp_data.get("autodoc:module")
                # 如果仍为空
                if not modname:
                    # 如果 Sphinx 版本大于 "1.3"
                    if sphinx.__version__ > "1.3":
                        # 尝试从环境引用上下文中获取 "py:module" 作为模块名
                        modname = self.env.ref_context.get("py:module")
                    else:
                        # 否则尝试从 "py:module" 获取模块名
                        modname = self.env.temp_data.get("py:module")
                # 否则模块名保持 None，表示无效
                # ... else, it stays None, which means invalid
        # 返回解析后的模块名和父模块列表加上基础名称
        return modname, parents + [base]
class AccessorAttributeDocumenter(AccessorLevelDocumenter, AttributeDocumenter):
    objtype = "accessorattribute"
    directivetype = "attribute"

    # 优先级比普通属性的 AttributeDocumenter 低，因此不会被选择用于普通属性的文档生成
    priority = 0.6


class AccessorMethodDocumenter(AccessorLevelDocumenter, MethodDocumenter):
    objtype = "accessormethod"
    directivetype = "method"

    # 优先级比普通方法的 MethodDocumenter 低，因此不会被选择用于普通方法的文档生成
    priority = 0.6


class AccessorCallableDocumenter(AccessorLevelDocumenter, MethodDocumenter):
    """
    This documenter lets us removes .__call__ from the method signature for
    callable accessors like Series.plot
    """

    objtype = "accessorcallable"
    directivetype = "method"

    # 优先级比 MethodDocumenter 低，否则文档生成会打印警告
    priority = 0.5

    def format_name(self):
        return MethodDocumenter.format_name(self).removesuffix(".__call__")


class PandasAutosummary(Autosummary):
    """
    This alternative autosummary class lets us override the table summary for
    Series.plot and DataFrame.plot in the API docs.
    """

    def _replace_pandas_items(self, display_name, sig, summary, real_name):
        # 这是一个 hack：理想情况下应该从 .__call__ 方法中提取签名，而不是硬编码
        if display_name == "DataFrame.plot":
            sig = "([x, y, kind, ax, ....])"
            summary = "DataFrame plotting accessor and method"
        elif display_name == "Series.plot":
            sig = "([kind, ax, figsize, ....])"
            summary = "Series plotting accessor and method"
        return (display_name, sig, summary, real_name)

    @staticmethod
    def _is_deprecated(real_name):
        try:
            obj, parent, modname = _import_by_name(real_name)
        except ImportError:
            return False
        doc = NumpyDocString(obj.__doc__ or "")
        summary = "".join(doc["Summary"] + doc["Extended Summary"])
        return ".. deprecated::" in summary

    def _add_deprecation_prefixes(self, items):
        for item in items:
            display_name, sig, summary, real_name = item
            if self._is_deprecated(real_name):
                summary = f"(DEPRECATED) {summary}"
            yield display_name, sig, summary, real_name

    def get_items(self, names):
        items = Autosummary.get_items(self, names)
        items = [self._replace_pandas_items(*item) for item in items]
        items = list(self._add_deprecation_prefixes(items))
        return items


# 基于 numpy doc/source/conf.py
def linkcode_resolve(domain, info) -> str | None:
    """
    Determine the URL corresponding to Python object
    """
    if domain != "py":
        return None

    modname = info["module"]
    fullname = info["fullname"]

    submod = sys.modules.get(modname)
    if submod is None:
        return None

    obj = submod
    # 根据点号将完整名称分割为各个部分，并逐一处理
    for part in fullname.split("."):
        try:
            # 使用警告过滤器忽略未来警告，以避免访问已弃用的对象时生成的嘈杂警告
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", FutureWarning)
                # 获取对象中指定部分的属性或方法
                obj = getattr(obj, part)
        except AttributeError:
            # 如果属性或方法不存在，返回 None
            return None

    try:
        # 获取对象的源文件路径
        fn = inspect.getsourcefile(inspect.unwrap(obj))
    except TypeError:
        try:  # 处理属性的情况
            fn = inspect.getsourcefile(inspect.unwrap(obj.fget))
        except (AttributeError, TypeError):
            fn = None
    # 如果找不到源文件路径，返回 None
    if not fn:
        return None

    try:
        # 获取对象的源码和起始行号
        source, lineno = inspect.getsourcelines(obj)
    except TypeError:
        try:  # 处理属性的情况
            source, lineno = inspect.getsourcelines(obj.fget)
        except (AttributeError, TypeError):
            lineno = None
    except OSError:
        lineno = None

    # 如果没有有效的行号信息，设置为空字符串
    if lineno:
        linespec = f"#L{lineno}-L{lineno + len(source) - 1}"
    else:
        linespec = ""

    # 将源文件路径转换为相对路径，并基于 pandas 库的安装位置进行调整
    fn = os.path.relpath(fn, start=os.path.dirname(pandas.__file__))

    # 根据 pandas 版本格式化 GitHub 页面链接
    if "+" in pandas.__version__:
        return f"https://github.com/pandas-dev/pandas/blob/main/pandas/{fn}{linespec}"
    else:
        return (
            f"https://github.com/pandas-dev/pandas/blob/"
            f"v{pandas.__version__}/pandas/{fn}{linespec}"
        )
def remove_flags_docstring(app, what, name, obj, options, lines) -> None:
    # 如果当前处理的是属性，并且属性名以 ".flags" 结尾
    if what == "attribute" and name.endswith(".flags"):
        # 删除文档字符串中开头的若干行，以解决文档构建错误（参见 GH 问题 5331）
        del lines[:]


def process_class_docstrings(app, what, name, obj, options, lines) -> None:
    """
    对于那些我们使用 ::

    :template: autosummary/class_without_autosummary.rst

    模板的类，文档化的属性/方法必须在类文档字符串中列出。但是，如果其中一个列表为空，
    我们使用 'None'，这会导致sphinx生成警告/丑陋的HTML输出。这个 "autodoc-process-docstring"
    事件连接器从处理过的文档字符串中删除了这部分内容。
    """
    # 如果当前处理的是类
    if what == "class":
        # 将文档字符串列表连接成一个字符串
        joined = "\n".join(lines)

        # 需要删除的模板列表
        templates = [
            """.. rubric:: Attributes

.. autosummary::
   :toctree:

   None
""",
            """.. rubric:: Methods

.. autosummary::
   :toctree:

   None
""",
        ]

        # 遍历模板列表，删除文档字符串中的特定模板内容
        for template in templates:
            if template in joined:
                joined = joined.replace(template, "")

        # 将处理后的文本重新分割为行，并更新原始文档字符串列表
        lines[:] = joined.split("\n")


_BUSINED_ALIASES = [
    "pandas.tseries.offsets." + name
    for name in [
        "BDay",
        "CDay",
        "BMonthEnd",
        "BMonthBegin",
        "CBMonthEnd",
        "CBMonthBegin",
    ]
]


def process_business_alias_docstrings(app, what, name, obj, options, lines) -> None:
    """
    从sphinx 3.4开始，"autodoc-process-docstring"事件也会被调用用于别名类。这导致
    numpydoc将方法/属性添加到文档字符串中，我们不希望这样做（同时这也会导致sphinx出现警告）。
    """
    # 如果当前处理的是在_BUSINED_ALIASES列表中的别名
    if name in _BUSINED_ALIASES:
        # 清空文档字符串，以删除所有内容
        lines[:] = []


suppress_warnings = [
    # 我们使用PandasAutosummary覆盖了autosummary，但仍希望运行常规的autosummary设置。
    # 因此我们只抑制此警告。
    "app.add_directive"
]
if pattern:
    # 当构建单个文档时，不希望因为对其他文档的引用未知而出现警告，因为这是预期行为
    suppress_warnings.append("ref.ref")


def rstjinja(app, docname, source) -> None:
    """
    为了使用Jinja模板进行漂亮的模板处理，将我们的页面渲染为Jinja模板。
    """
    # 确保输出格式为HTML
    if app.builder.format != "html":
        return
    # 获取源代码内容
    src = source[0]
    # 使用app.builder.templates.render_string方法，结合html_context渲染页面
    rendered = app.builder.templates.render_string(src, app.config.html_context)
    # 更新源代码内容为渲染后的结果
    source[0] = rendered


def setup(app) -> None:
    # 连接source-read事件到rstjinja函数
    app.connect("source-read", rstjinja)
    # 连接autodoc-process-docstring事件到remove_flags_docstring函数
    app.connect("autodoc-process-docstring", remove_flags_docstring)
    # 连接autodoc-process-docstring事件到process_class_docstrings函数
    app.connect("autodoc-process-docstring", process_class_docstrings)
    # 连接autodoc-process-docstring事件到process_business_alias_docstrings函数
    app.connect("autodoc-process-docstring", process_business_alias_docstrings)
    # 添加AccessorDocumenter到应用中作为自动文档生成器
    app.add_autodocumenter(AccessorDocumenter)
    # 向应用程序添加一个自动文档生成器，用于访问器属性的文档生成
    app.add_autodocumenter(AccessorAttributeDocumenter)
    
    # 向应用程序添加一个自动文档生成器，用于访问器方法的文档生成
    app.add_autodocumenter(AccessorMethodDocumenter)
    
    # 向应用程序添加一个自动文档生成器，用于访问器可调用对象的文档生成
    app.add_autodocumenter(AccessorCallableDocumenter)
    
    # 向应用程序添加一个名为"autosummary"的指令，使用Pandas的autosummary功能
    app.add_directive("autosummary", PandasAutosummary)
# 定义一个忽略列表，用于忽略 CI 运行中损坏链接检查的结果

linkcheck_ignore = [
    # 匹配以 "http://" 结尾的链接，将其添加到忽略列表中
    "^http://$",
    # 匹配以 "https://" 结尾的链接，将其添加到忽略列表中
    "^https://$",
    # 使用列表推导式将下列链接逐个转义并添加到忽略列表中
    *[ 
        re.escape(link)
        for link in [
            "http://scatterci.github.io/pydata/pandas",
            "http://specs.frictionlessdata.io/json-table-schema/",
            "https://crates.io/crates/calamine",
            "https://devguide.python.org/setup/#macos",
            "https://en.wikipedia.org/wiki/Imputation_statistics",
            "https://en.wikipedia.org/wiki/Imputation_(statistics",
            "https://github.com/noatamir/pandas-dev",
            "https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1",
            "https://github.com/pandas-dev/pandas/blob/v0.20.2/pandas/core/generic.py#L568",
            "https://github.com/pandas-dev/pandas/blob/v0.20.2/pandas/core/frame.py#L1495",
            "https://github.com/pandas-dev/pandas/issues/174151",
            "https://gitpod.io/#https://github.com/USERNAME/pandas",
            "https://manishamde.github.io/blog/2013/03/07/pandas-and-python-top-10/",
            "https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes.table",
            "https://nipunbatra.github.io/blog/visualisation/2013/05/01/aggregation-timeseries.html",
            "https://nbviewer.ipython.org/gist/metakermit/5720498",
            "https://numpy.org/doc/stable/user/basics.byteswapping.html",
            "https://pandas.pydata.org/pandas-docs/stable/io.html#io-chunking",
            "https://pandas.pydata.org/pandas-docs/stable/ecosystem.html",
            "https://sqlalchemy.readthedocs.io/en/latest/dialects/index.html",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a000245912.htm",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a000214639.htm",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a002283942.htm",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a000245965.htm",
            "https://support.sas.com/documentation/cdl/en/imlug/66845/HTML/default/viewer.htm#imlug_langref_sect455.htm",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a002284668.htm",
            "https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a002978282.htm",
            "https://wesmckinney.com/blog/update-on-upcoming-pandas-v0-10-new-file-parser-other-performance-wins/",
            "https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022",
            "pandas.zip",
        ]
    ],
]
```