# `stable-diffusion-webui\modules\rng_philox.py`

```py
"""RNG imitiating torch cuda randn on CPU. You are welcome.

Usage:


g = Generator(seed=0)
print(g.randn(shape=(3, 4)))


Expected output:

[[-0.92466259 -0.42534415 -2.6438457   0.14518388]
 [-0.12086647 -0.57972564 -0.62285122 -0.32838709]
 [-1.07454231 -0.36314407 -1.67105067  2.26550497]]

"""

import numpy as np

# 定义 Philox 随机数生成器所需的常量
philox_m = [0xD2511F53, 0xCD9E8D57]
philox_w = [0x9E3779B9, 0xBB67AE85]

# 定义常量，用于计算随机数
two_pow32_inv = np.array([2.3283064e-10], dtype=np.float32)
two_pow32_inv_2pi = np.array([2.3283064e-10 * 6.2831855], dtype=np.float32)

# 定义函数，将 np.uint64 数组转换为 np.uint32 数组
def uint32(x):
    """Converts (N,) np.uint64 array into (2, N) np.unit32 array."""
    return x.view(np.uint32).reshape(-1, 2).transpose(1, 0)

# 定义函数，执行 Philox 4x32 随机数生成器的单轮操作
def philox4_round(counter, key):
    """A single round of the Philox 4x32 random number generator."""

    v1 = uint32(counter[0].astype(np.uint64) * philox_m[0])
    v2 = uint32(counter[2].astype(np.uint64) * philox_m[1])

    counter[0] = v2[1] ^ counter[1] ^ key[0]
    counter[1] = v2[0]
    counter[2] = v1[1] ^ counter[3] ^ key[1]
    counter[3] = v1[0]

# 定义函数，执行 Philox 4x32 随机数生成器的多轮操作
def philox4_32(counter, key, rounds=10):
    """Generates 32-bit random numbers using the Philox 4x32 random number generator.

    Parameters:
        counter (numpy.ndarray): A 4xN array of 32-bit integers representing the counter values (offset into generation).
        key (numpy.ndarray): A 2xN array of 32-bit integers representing the key values (seed).
        rounds (int): The number of rounds to perform.

    Returns:
        numpy.ndarray: A 4xN array of 32-bit integers containing the generated random numbers.
    """

    for _ in range(rounds - 1):
        philox4_round(counter, key)

        key[0] = key[0] + philox_w[0]
        key[1] = key[1] + philox_w[1]

    philox4_round(counter, key)
    return counter

# 定义函数，执行 Box-Muller 变换算法生成随机数
def box_muller(x, y):
    """Returns just the first out of two numbers generated by Box–Muller transform algorithm."""
    u = x * two_pow32_inv + two_pow32_inv / 2
    # 计算 v 的值，等于 y 乘以 2^32 除以 2π，再加上 2^32 除以 2π 的一半
    v = y * two_pow32_inv_2pi + two_pow32_inv_2pi / 2

    # 计算 s 的值，等于 -2.0 乘以 自然对数 u 的对数
    s = np.sqrt(-2.0 * np.log(u))

    # 计算 r1 的值，等于 s 乘以 sin(v)
    r1 = s * np.sin(v)
    # 返回 r1 的值，并转换为 np.float32 类型
    return r1.astype(np.float32)
class Generator:
    """RNG that produces same outputs as torch.randn(..., device='cuda') on CPU"""

    def __init__(self, seed):
        # 初始化生成器对象，设置种子和偏移量
        self.seed = seed
        self.offset = 0

    def randn(self, shape):
        """Generate a sequence of n standard normal random variables using the Philox 4x32 random number generator and the Box-Muller transform."""

        # 计算生成的随机数个数
        n = 1
        for x in shape:
            n *= x

        # 初始化计数器数组，用于生成随机数
        counter = np.zeros((4, n), dtype=np.uint32)
        counter[0] = self.offset
        counter[2] = np.arange(n, dtype=np.uint32)  # up to 2^32 numbers can be generated - if you want more you'd need to spill into counter[3]
        self.offset += 1

        # 初始化密钥数组，填充种子值
        key = np.empty(n, dtype=np.uint64)
        key.fill(self.seed)
        key = uint32(key)

        # 使用 Philox 4x32 随机数生成器生成随机数
        g = philox4_32(counter, key)

        # 使用 Box-Muller 变换生成标准正态分布的随机数序列，并根据给定形状进行重塑
        return box_muller(g[0], g[1]).reshape(shape)  # discard g[2] and g[3]
```