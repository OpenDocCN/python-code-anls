# `D:\src\scipysrc\scikit-learn\sklearn\_build_utils\__init__.py`

```
"""
Utilities useful during the build.
"""

# author: Andy Mueller, Gael Varoquaux
# license: BSD

# 导入上下文管理和操作系统模块
import contextlib
import os

# 导入 sklearn 库
import sklearn

# 导入 Cython 最低版本要求
from .._min_dependencies import CYTHON_MIN_VERSION
# 导入版本解析函数
from ..externals._packaging.version import parse
# 导入 OpenMP 支持检查函数
from .openmp_helpers import check_openmp_support
# 导入预构建辅助函数
from .pre_build_helpers import basic_check_build

# 默认根目录
DEFAULT_ROOT = "sklearn"

# 检查 Cython 版本是否满足要求
def _check_cython_version():
    message = (
        "Please install Cython with a version >= {0} in order "
        "to build a scikit-learn from source."
    ).format(CYTHON_MIN_VERSION)
    try:
        import Cython
    except ModuleNotFoundError as e:
        # 如果未找到 Cython 模块，抛出更详细的错误信息
        raise ModuleNotFoundError(message) from e

    # 检查当前 Cython 版本是否符合要求
    if parse(Cython.__version__) < parse(CYTHON_MIN_VERSION):
        message += " The current version of Cython is {} installed in {}.".format(
            Cython.__version__, Cython.__path__
        )
        raise ValueError(message)

# 编译并进行 Cython 化
def cythonize_extensions(extension):
    """Check that a recent Cython is available and cythonize extensions"""
    _check_cython_version()
    from Cython.Build import cythonize

    # 在进行 Cython 化之前，如果编译器在没有 OpenMP 的情况下无法编译基本测试代码，则快速失败
    basic_check_build()

    # 检查是否支持 OpenMP 编译
    # `check_openmp_support` 编译一个小型测试程序，以查看编译器是否正确配置以使用 OpenMP。
    # 这是一个昂贵的操作，我们只想调用这个函数一次。
    # 此检查的结果被缓存为 sklearn 模块的私有属性（仅在构建时），以便在 top-level setup.py 文件中定义的 build_ext 子类中使用，
    # 以实际使用 OpenMP 标志构建编译扩展。
    sklearn._OPENMP_SUPPORTED = check_openmp_support()

    # 获取可用的 CPU 核心数量
    n_jobs = 1
    with contextlib.suppress(ImportError):
        import joblib
        n_jobs = joblib.cpu_count()

    # 额外的 Cython 检查
    cython_enable_debug_directives = (
        os.environ.get("SKLEARN_ENABLE_DEBUG_CYTHON_DIRECTIVES", "0") != "0"
    )

    # 编译器指令设置
    compiler_directives = {
        "language_level": 3,
        "boundscheck": cython_enable_debug_directives,
        "wraparound": False,
        "initializedcheck": False,
        "nonecheck": False,
        "cdivision": True,
        "profile": False,
    }

    # 返回 Cython 化的扩展对象
    return cythonize(
        extension,
        nthreads=n_jobs,
        compiler_directives=compiler_directives,
        annotate=False,
    )

# 从模板生成 Cython 文件
def gen_from_templates(templates):
    """Generate cython files from a list of templates"""
    # 惰性导入，因为 Cython 不是运行时依赖项。
    from Cython import Tempita
    for template in templates:
        # 获取输出文件名，去掉后缀".tp"
        outfile = template.replace(".tp", "")

        # 如果模板没有更新，则不需要输出 Cython 文件
        if not (
            os.path.exists(outfile)
            and os.stat(template).st_mtime < os.stat(outfile).st_mtime
        ):
            # 打开模板文件，读取内容
            with open(template, "r") as f:
                tmpl = f.read()

            # 使用 Tempita 进行模板替换
            tmpl_ = Tempita.sub(tmpl)

            # 生成警告信息，说明该文件是自动生成的
            warn_msg = (
                "# WARNING: Do not edit this file directly.\n"
                f"# It is automatically generated from {template!r}.\n"
                "# Changes must be made there.\n\n"
            )

            # 将警告信息和替换后的模板内容写入输出文件
            with open(outfile, "w") as f:
                f.write(warn_msg)
                f.write(tmpl_)
```