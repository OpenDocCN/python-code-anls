# `D:\src\scipysrc\scikit-learn\sklearn\preprocessing\_csr_polynomial_expansion.pyx`

```
# 从上级目录中的utils模块导入_typedefs模块中定义的uint8_t, int64_t, intp_t类型
from ..utils._typedefs cimport uint8_t, int64_t, intp_t

# 定义一个类型别名FLAG_t为uint8_t

ctypedef uint8_t FLAG_t

# 下面的代码段用来确定当前平台的编译器是否原生支持128位整数值。
# 在64位架构上，这应该适用于GCC和CLANG，但不适用于任何架构上的MSVC。
# 我们倾向于在可能时使用128位整数，因为中间计算有非常小的溢出风险。
# 然而，在普通用例中，64位整数（即`long long`）通常已经足够。
# 在Windows平台上，目前没有有效的方法来有效地减少溢出风险。
# 这可以视为一种“尽力而为”的设计决策，可能会在以后重新审视，如果有人提出了更安全的选项，
# 而不会影响常见用例的性能。
# 详细类型预期信息，请参见`test_sizeof_LARGEST_INT_t()`函数。
cdef extern from *:
    """
    #ifdef __SIZEOF_INT128__
        typedef __int128 LARGEST_INT_t;
    #elif (__clang__ || __EMSCRIPTEN__) && !__i386__
        typedef _BitInt(128) LARGEST_INT_t;
    #else
        typedef long long LARGEST_INT_t;
    #endif
    """
    ctypedef long long LARGEST_INT_t

# 运行时获取`LARGEST_INT_t`的大小。
# 在`test_sizeof_LARGEST_INT_t`中使用。
def _get_sizeof_LARGEST_INT_t():
    return sizeof(LARGEST_INT_t)


# TODO: 在Cython#5230问题解决后，使用`{int,float}{32,64}_t`。
# https://github.com/cython/cython/issues/5230
# 定义一个融合类型别名DATA_t，包括float、double、int和long long。
ctypedef fused DATA_t:
    float
    double
    int
    long long

# INDEX_{A,B}_t用于通过Cython融合类型扩展生成适当的类型笛卡尔积。
# 定义融合类型别名INDEX_A_t，包括signed int和signed long long。
ctypedef fused INDEX_A_t:
    signed int
    signed long long

# 定义融合类型别名INDEX_B_t，包括signed int和signed long long。
ctypedef fused INDEX_B_t:
    signed int
    signed long long

# 计算度为2的扩展中列的索引。
# `n_features`是输入数据的维度，`i`和`j`是扩展中涉及的列的索引。
cdef inline int64_t _deg2_column(
    LARGEST_INT_t n_features,
    LARGEST_INT_t i,
    LARGEST_INT_t j,
    FLAG_t interaction_only
) nogil:
    """Compute the index of the column for a degree 2 expansion

    n_features is the dimensionality of the input data, i and j are the indices
    for the columns involved in the expansion.
    """
    if interaction_only:
        return n_features * i - i * (i + 3) / 2 - 1 + j
    else:
        return n_features * i - i* (i + 1) / 2 + j

# 计算度为3的扩展中列的索引。
# `n_features`是输入数据的维度，`i`, `j`和`k`是扩展中涉及的列的索引。
cdef inline int64_t _deg3_column(
    LARGEST_INT_t n_features,
    LARGEST_INT_t i,
    LARGEST_INT_t j,
    LARGEST_INT_t k,
    FLAG_t interaction_only
) nogil:
    """Compute the index of the column for a degree 3 expansion

    n_features is the dimensionality of the input data, i, j and k are the indices
    for the columns involved in the expansion.
    """
    # 如果设置了 interaction_only 标志为真，则执行以下计算
    if interaction_only:
        # 计算交互项时的复杂表达式
        return (
            (
                (3 * n_features) * (n_features * i - i**2)  # 第一项
                + i * (i**2 + 11) - (3 * j) * (j + 3)      # 第二项
            ) / 6 + i**2 + n_features * (j - 1 - 2 * i) + k  # 汇总并返回结果
        )
    else:
        # 如果不仅仅是交互项，则执行以下计算
        return (
            (
                (3 * n_features) * (n_features * i - i**2)  # 第一项
                + i ** 3 - i - (3 * j) * (j + 1)            # 第二项
            ) / 6 + n_features * j + k  # 汇总并返回结果
        )
# 计算二次多项式扩展后的非零交互项数量
def py_calc_expanded_nnz_deg2(n, interaction_only):
    return n * (n + 1) // 2 - interaction_only * n

# 计算三次多项式扩展后的非零交互项数量
def py_calc_expanded_nnz_deg3(n, interaction_only):
    return n * (n**2 + 3 * n + 2) // 6 - interaction_only * n**2

# 计算扩展后的非零交互项数量，考虑了整数溢出的安全性
cpdef int64_t _calc_expanded_nnz(
    LARGEST_INT_t n,
    FLAG_t interaction_only,
    LARGEST_INT_t degree
):
    """
    Calculates the number of non-zero interaction terms generated by the
    non-zero elements of a single row.
    """
    # 这是在中间计算溢出前的最大值
    # d**2 + d = int64_max 的解
    # SymPy: solve(x**2 + x - int64_max, x)
    cdef int64_t MAX_SAFE_INDEX_CALC_DEG2 = 3037000499

    # 这是在中间计算溢出前的最大值
    # d**3 + 3 * d**2 + 2*d = int64_max 的解
    # SymPy: solve(x * (x**2 + 3 * x + 2) - int64_max, x)
    cdef int64_t MAX_SAFE_INDEX_CALC_DEG3 = 2097151

    if degree == 2:
        # 只有在不使用128位整数时才需要检查
        if sizeof(LARGEST_INT_t) < 16 and n <= MAX_SAFE_INDEX_CALC_DEG2:
            return n * (n + 1) / 2 - interaction_only * n
        return <int64_t> py_calc_expanded_nnz_deg2(n, interaction_only)
    else:
        # 只有在不使用128位整数时才需要检查
        if sizeof(LARGEST_INT_t) < 16 and n <= MAX_SAFE_INDEX_CALC_DEG3:
            return n * (n**2 + 3 * n + 2) / 6 - interaction_only * n**2
        return <int64_t> py_calc_expanded_nnz_deg3(n, interaction_only)

# 计算整个CSR矩阵在给定度数下生成的所有非零交互项的数量
cpdef int64_t _calc_total_nnz(
    INDEX_A_t[:] indptr,
    FLAG_t interaction_only,
    int64_t degree,
):
    """
    Calculates the number of non-zero interaction terms generated by the
    non-zero elements across all rows for a single degree.
    """
    cdef int64_t total_nnz=0
    cdef intp_t row_idx
    for row_idx in range(len(indptr) - 1):
        total_nnz += _calc_expanded_nnz(
            indptr[row_idx + 1] - indptr[row_idx],
            interaction_only,
            degree
        )
    return total_nnz

# 在CSR矩阵上执行二次或三次多项式或交互展开
cpdef void _csr_polynomial_expansion(
    const DATA_t[:] data,           # 只读输入
    const INDEX_A_t[:] indices,     # 只读输入
    const INDEX_A_t[:] indptr,      # 只读输入
    INDEX_A_t n_features,
    DATA_t[:] result_data,          # 输出
    INDEX_B_t[:] result_indices,    # 输出
    INDEX_B_t[:] result_indptr,     # 输出
    FLAG_t interaction_only,
    FLAG_t degree
):
    """
    Perform a second or third degree polynomial or interaction expansion on a
    compressed sparse row (CSR) matrix. The method used only takes products of
    non-zero features. For a matrix with density :math:`d`, this results in a
    speedup on the order of :math:`(1/d)^k` where :math:`k` is the degree of
    the expansion, assuming all rows are of similar density.

    Parameters
    ----------
    data : memory view on nd-array
        The "data" attribute of the input CSR matrix.
    """
    indices : memory view on nd-array
        输入 CSR 矩阵的 "indices" 属性。

    indptr : memory view on nd-array
        输入 CSR 矩阵的 "indptr" 属性。

    n_features : int
        输入 CSR 矩阵的维度。

    result_data : nd-array
        输出 CSR 矩阵的 "data" 属性。
        本函数将修改该属性。

    result_indices : nd-array
        输出 CSR 矩阵的 "indices" 属性。
        本函数将修改该属性。

    result_indptr : nd-array
        输出 CSR 矩阵的 "indptr" 属性。
        本函数将修改该属性。

    interaction_only : int
        如果是多项式展开则为 0，如果是交互展开则为 1。

    degree : int
        展开的次数。必须为 2 或者 3。

    References
    ----------
    "Leveraging Sparsity to Speed Up Polynomial Feature Expansions of CSR
    Matrices Using K-Simplex Numbers" by Andrew Nystrom and John Hughes.
    """

    # 创建形成CSR矩阵扩展的数组。
    # 使用 nogil 语句块以允许释放全局解释锁 (GIL)，提高性能。
    cdef INDEX_A_t row_i, row_starts, row_ends, i, j, k, i_ptr, j_ptr, k_ptr
    cdef INDEX_B_t expanded_index=0, num_cols_in_row, col
    with nogil:
        # 初始化输出矩阵的第一个指针值为输入矩阵的第一个指针值。
        result_indptr[0] = indptr[0]
        # 对于每一行进行迭代，除了最后一行。
        for row_i in range(indptr.shape[0]-1):
            # 获取当前行的起始和结束位置。
            row_starts = indptr[row_i]
            row_ends = indptr[row_i + 1]
            # 当前行中列的数量初始化为 0。
            num_cols_in_row = 0
            # 对于当前行中的每一个元素进行迭代。
            for i_ptr in range(row_starts, row_ends):
                # 获取当前元素的索引。
                i = indices[i_ptr]
                # 对于当前元素后面的每一个元素进行迭代。
                for j_ptr in range(i_ptr + interaction_only, row_ends):
                    # 获取当前元素后面元素的索引。
                    j = indices[j_ptr]
                    # 如果展开的次数为 2。
                    if degree == 2:
                        # 计算二次展开的列。
                        col = <INDEX_B_t> _deg2_column(
                            n_features,
                            i, j,
                            interaction_only
                        )
                        # 将计算的列放入输出矩阵的索引中。
                        result_indices[expanded_index] = col
                        # 计算并放入数据矩阵中。
                        result_data[expanded_index] = (
                            data[i_ptr] * data[j_ptr]
                        )
                        # 更新扩展索引。
                        expanded_index += 1
                        # 更新当前行中的列数。
                        num_cols_in_row += 1
                    else:
                        # degree == 3，如果展开的次数为 3。
                        for k_ptr in range(j_ptr + interaction_only, row_ends):
                            # 获取当前元素后面元素的索引。
                            k = indices[k_ptr]
                            # 计算三次展开的列。
                            col = <INDEX_B_t> _deg3_column(
                                n_features,
                                i, j, k,
                                interaction_only
                            )
                            # 将计算的列放入输出矩阵的索引中。
                            result_indices[expanded_index] = col
                            # 计算并放入数据矩阵中。
                            result_data[expanded_index] = (
                                data[i_ptr] * data[j_ptr] * data[k_ptr]
                            )
                            # 更新扩展索引。
                            expanded_index += 1
                            # 更新当前行中的列数。
                            num_cols_in_row += 1

            # 更新输出矩阵的下一个指针值，为当前行中列数之和。
            result_indptr[row_i+1] = result_indptr[row_i] + num_cols_in_row
    return
```