# `arknights-mower\纯跑单.py`

```py
# 导入必要的模块
from __future__ import annotations
import copy
import ctypes
import cv2
import inspect
import json
import os
import pystray
import smtplib
import sys
import threading
import time
import warnings
from datetime import datetime, timedelta
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from enum import Enum
from tkinter import *
from typing import Optional
from PIL import Image
from pystray import MenuItem, Menu
from arknights_mower.data import agent_list
from arknights_mower.utils import (character_recognize, config, detector, segment)
from arknights_mower.utils import typealias as tp
from arknights_mower.utils.asst import Asst, Message
from arknights_mower.utils.datetime import get_server_weekday, the_same_time
from arknights_mower.utils.device.adb_client import ADBClient
from arknights_mower.utils.device.minitouch import MiniTouch
from arknights_mower.utils.device.scrcpy import Scrcpy
from arknights_mower.utils.digit_reader import DigitReader
from arknights_mower.utils.log import init_fhlr, logger, save_screenshot
from arknights_mower.utils.operators import Operator, Operators
from arknights_mower.utils.pipe import push_operators
from arknights_mower.utils.scheduler_task import SchedulerTask
from arknights_mower.utils.solver import BaseSolver
from arknights_mower.utils.recognize import Recognizer, RecognizeError

# 定义一个空的 warn 函数，用于屏蔽警告
def warn(*args, **kwargs):
    pass

# 将警告函数重定向到空的 warn 函数
warnings.warn = warn

# 导入 PaddleOCR 模块
from paddleocr import PaddleOCR
from arknights_mower.strategy import Solver

# 定义两个常量，分别代表官方服务器和Bilibili服务器
官方服务器 = 'com.hypergryph.arknights'
Bilibili服务器 = 'com.hypergryph.arknights.bilibili'

# 创建一个 Tkinter 窗口
窗口 = Tk()
################################################################################################
# # # # # # # # # # # # # # # # # # # # # # 用户设置区 # # # # # # # # # # # # # # # # # # # # # #
################################################################################################

# 选择要连接的服务器 (官方服务器/Bilibili服务器)
服务器 = 官方服务器

# 设置跑单提前运行时间为 300 秒
跑单提前运行时间 = 300  # 秒
# 设置更换干员前的缓冲时间，单位为秒，需要大于一次跟服务器交换数据的时间，建议大于等于15秒
更换干员前缓冲时间 = 30  

# 设置贸易站的房间以及跑单干员的具体位置
# 请注意手动换班后记得重新运行程序
跑单位置设置 = {
    'B101': ['', '龙舌兰', '但书'],
    'B201': ['', '龙舌兰', '但书'],
}

# 设置龙舌兰和但书的休息状态
龙舌兰和但书休息 = True
宿舍设置 = {'B401': ['当前休息干员', '当前休息干员', '当前休息干员', '龙舌兰', '但书']}

# 设置日志存储目录
日志存储目录 = './log'
# 设置截图存储目录
截图存储目录 = './screenshot'
# 设置每种截图的最大保存数量
每种截图的最大保存数量 = 10
# 设置任务结束后退出游戏的开关
任务结束后退出游戏 = True

# 设置跑单弹窗提醒开关
跑单弹窗提醒开关 = True

# 设置悬浮字幕窗口
# 双击字幕可关闭字幕，在托盘可重新打开
悬浮字幕开关 = True
# 设置窗口宽度
窗口宽度 = 窗口.winfo_screenwidth() / 2
# 设置窗口高度
窗口高度 = 窗口.winfo_screenheight() / 4
# 设置字幕字号
字幕字号 = int(窗口.winfo_screenheight() / 18)  # '50'
# 设置字幕字体
字幕字体 = '楷体'
# 设置字幕颜色
字幕颜色 = '#9966FF'  # 16进制颜色代码

# 设置邮件提醒相关参数
邮件设置 = {
    '邮件提醒开关': True,
    '发信邮箱': "qqqqqqqqqqqqq@qq.com",
    '授权码': 'xxxxxxxxxxxxxxxx',  # 在QQ邮箱“账户设置-账户-开启SMTP服务”中，按照指示开启服务获得授权码
    '收件人邮箱': ['name@example.com']  # 收件人邮箱
}

# 设置MAA相关参数
MAA设置 = {
    'MAA路径': 'K:/MAA',  # 请设置为存放 dll 文件及资源的路径
    'MAA_adb路径': 'C:/Program Files/BlueStacks_bgp64/./HD-Adb.exe',  # 请设置为模拟器的 adb 应用程序路径
    'MAA_adb地址': ['127.0.0.1:5555'],  # 请设置为模拟器的 adb 地址

    # 以下配置，第一个设置为开的首先生效
    '集成战略': False,  # 集成战略开关
    '生息演算': False,  # 生息演算开关
    '保全派驻': False,  # 保全派驻开关
    '周计划': [
        {'日子': '周一', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周二', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周三', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周四', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周五', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周六', '关卡': ['集成战略'], '应急理智药': 0},
        {'日子': '周日', '关卡': ['集成战略'], '应急理智药': 0}
    ]
}

# 初始化OCR对象和任务提示
ocr = None
任务提示 = str()
# 获取当前时间作为下个任务开始时间
下个任务开始时间 = datetime.now()
# 设置字幕内容
字幕 = "Mower的准备阶段..."

# 定义设备控制类
class 设备控制(object):
    # 初始化方法，设备 ID、连接方式和触摸设备信息可选
    def __init__(self, device_id: str = None, connect: str = None, touch_device: str = None) -> None:
        # 初始化设备 ID
        self.device_id = device_id
        # 初始化连接方式
        self.connect = connect
        # 初始化触摸设备信息
        self.touch_device = touch_device
        # 初始化客户端和控制对象
        self.client = None
        self.control = None
        # 调用 start 方法
        self.start()

    # 启动方法
    def start(self) -> None:
        # 创建 ADB 客户端
        self.client = ADBClient(self.device_id, self.connect)
        # 创建设备控制对象
        self.control = 设备控制.Control(self, self.client)

    # 运行命令方法
    def run(self, cmd: str) -> Optional[bytes]:
        return self.client.run(cmd)

    # 启动应用方法
    def launch(self, app: str) -> None:
        """ launch the application """
        # 发送启动应用的命令
        self.run(f'am start -n {app}')

    # 退出应用方法
    def exit(self, app: str) -> None:
        """ exit the application """
        # 发送退出应用的命令
        self.run(f'am force-stop {app}')

    # 发送按键事件方法
    def send_keyevent(self, keycode: int) -> None:
        """ send a key event """
        # 记录按键事件
        logger.debug(f'keyevent: {keycode}')
        # 构造发送按键事件的命令
        command = f'input keyevent {keycode}'
        # 发送按键事件命令
        self.run(command)

    # 发送文本方法
    def send_text(self, text: str) -> None:
        """ send a text """
        # 记录发送的文本
        logger.debug(f'text: {repr(text)}')
        # 替换文本中的双引号
        text = text.replace('"', '\\"')
        # 构造发送文本的命令
        command = f'input text "{text}"'
        # 发送文本命令
        self.run(command)

    # 获取屏幕截图方法
    def screencap(self, save: bool = False) -> bytes:
        """ get a screencap """
        # 构造获取屏幕截图的命令
        command = 'screencap -p 2>/dev/null'
        # 执行获取屏幕截图的命令
        screencap = self.run(command)
        # 如果需要保存截图，则保存截图
        if save:
            save_screenshot(screencap)
        # 返回截图数据
        return screencap

    # 检测当前焦点应用方法
    def current_focus(self) -> str:
        """ detect current focus app """
        # 构造检测当前焦点应用的命令
        command = 'dumpsys window | grep mCurrentFocus'
        # 执行检测当前焦点应用的命令，并解码为字符串
        line = self.run(command).decode('utf8')
        # 返回当前焦点应用的包名
        return line.strip()[:-1].split(' ')[-1]
    # 获取显示帧（如果处于兼容模式）
    def display_frames(self) -> tuple[int, int, int]:
        """ get display frames if in compatibility mode"""
        # 如果不处于兼容模式，则返回空
        if not config.MNT_COMPATIBILITY_MODE:
            return None

        # 执行 shell 命令，获取包含 DisplayFrames 的输出
        command = 'dumpsys window | grep DisplayFrames'
        line = self.run(command).decode('utf8')
        """ eg. DisplayFrames w=1920 h=1080 r=3 """
        # 去除首尾空格，替换等号为空格，然后按空格分割字符串，得到显示帧的宽、高和密度
        res = line.strip().replace('=', ' ').split(' ')
        return int(res[2]), int(res[4]), int(res[6])

    # 点击操作
    def tap(self, point: tuple[int, int]) -> None:
        """ tap """
        # 记录日志，表示进行了点击操作
        logger.debug(f'tap: {point}')
        # 调用控制对象的 tap 方法
        self.control.tap(point)

    # 滑动操作
    def swipe(self, start: tuple[int, int], end: tuple[int, int], duration: int = 100) -> None:
        """ swipe """
        # 记录日志，表示进行了滑动操作
        logger.debug(f'swipe: {start} -> {end}, duration={duration}')
        # 调用控制对象的 swipe 方法
        self.control.swipe(start, end, duration)

    # 复杂滑动操作
    def swipe_ext(self, points: list[tuple[int, int]], durations: list[int], up_wait: int = 500) -> None:
        """ swipe_ext """
        # 记录日志，表示进行了复杂滑动操作
        logger.debug(
            f'swipe_ext: points={points}, durations={durations}, up_wait={up_wait}')
        # 调用控制对象的 swipe_ext 方法
        self.control.swipe_ext(points, durations, up_wait)

    # 检查当前焦点
    def check_current_focus(self):
        """ check if the application is in the foreground """
        # 如果当前焦点不是指定的应用程序，则启动该应用程序
        if self.current_focus() != f"{config.APPNAME}/{config.APP_ACTIVITY_NAME}":
            self.launch(f"{config.APPNAME}/{config.APP_ACTIVITY_NAME}")
            # 等待应用程序启动完成
            time.sleep(10)
# 定义一个枚举类型，包含干员排序的方式
class 干员排序方式(Enum):
    工作状态 = 1
    技能 = 2
    心情 = 3
    信赖值 = 4

# 定义一个字典，包含干员排序方式和它们在屏幕上的位置比例
干员排序方式位置 = {
    干员排序方式.工作状态: (1560 / 2496, 96 / 1404),
    干员排序方式.技能: (1720 / 2496, 96 / 1404),
    干员排序方式.心情: (1880 / 2496, 96 / 1404),
    干员排序方式.信赖值: (2050 / 2496, 96 / 1404),
}

# 定义一个函数，用于设置日志级别为DEBUG
def 调试输出():
    logger.handlers[0].setLevel('DEBUG')

# 定义一个函数，用于设置日志存储目录、截图存储目录、每种截图的最大保存数量和最大重试次数
def 日志设置():
    config.LOGFILE_PATH = 日志存储目录
    config.SCREENSHOT_PATH = 截图存储目录
    config.SCREENSHOT_MAXNUM = 每种截图的最大保存数量 - 1
    config.MAX_RETRYTIME = 10

# 定义一个类，继承自BaseSolver类
class 项目经理(BaseSolver):
    服务器 = ''

    # 初始化方法，接受设备控制和识别器作为参数
    def __init__(self, device: 设备控制 = None, recog: Recognizer = None) -> None:
        super().__init__(device, recog)
        self.plan = None
        self.planned = None
        self.todo_task = None
        self.邮件设置 = None
        self.干员信息 = None
        self.跑单提前运行时间 = 300
        self.digit_reader = DigitReader()
        self.error = False
        self.任务列表 = []
        self.run_order_rooms = {}

    # 返回基建主界面的方法
    def 返回基主界面(self):
        logger.info('返回基建主界面')
        while self.get_infra_scene() != 201:
            if self.find('index_infrastructure') is not None:
                self.tap_element('index_infrastructure')
            else:
                self.back()
            self.recog.update()

    # 运行方法
    def run(self) -> None:
        self.error = False
        if len(self.任务列表) == 0:
            self.recog.update()
            time.sleep(1)
        self.handle_error(True)
        if len(self.任务列表) > 0:
            # 找到时间最近的一次单个任务
            self.任务 = self.任务列表[0]
        else:
            self.任务 = None
        self.todo_task = False
        self.collect_notification = False
        self.planned = False
        if self.干员信息 is None or self.干员信息.operators is None:
            self.initialize_operators()
        return super().run()
    # 定义状态转换方法
    def transition(self) -> None:
        # 更新识别结果
        self.recog.update()
        # 判断当前场景
        if self.scene() == 1:
            # 点击指定元素
            self.tap_element('index_infrastructure')
        elif self.scene() == 201:
            # 调用 infra_main 方法
            return self.infra_main()
        elif self.scene() == 202:
            # 调用 收获产物 方法
            return self.收获产物()
        elif self.scene() == 205:
            # 返回上一级
            self.back()
        elif self.scene() == 9998:
            # 等待1秒
            time.sleep(1)
        elif self.scene() == 9:
            # 等待1秒
            time.sleep(1)
        elif self.get_navigation():
            # 点击指定导航元素
            self.tap_element('nav_infrastructure')
        elif self.scene() == 207:
            # 点击指定元素
            self.tap_element('arrange_blue_yes')
        elif self.scene() != -1:
            # 返回到首页
            self.back_to_index()
            # 重置上一个房间
            self.last_room = ''
        else:
            # 抛出识别错误
            raise RecognizeError('Unknown scene')

    # 查找下一个任务
    def find_next_task(self, compare_time=None, task_type='', compare_type='<'):
        # 判断比较类型
        if compare_type == '=':
            # 返回符合条件的下一个任务
            return next((e for e in self.任务列表 if the_same_time(e.time, compare_time) and (
                True if task_type == '' else task_type in e.type)), None)
        elif compare_type == '>':
            # 返回符合条件的下一个任务
            return next((e for e in self.任务列表 if (True if compare_time is None else e.time > compare_time) and (
                True if task_type == '' else task_type in e.type)), None)
        else:
            # 返回符合条件的下一个任务
            return next((e for e in self.任务列表 if (True if compare_time is None else e.time < compare_time) and (
                True if task_type == '' else task_type in e.type)), None)
    # 定义处理错误的方法，force 参数默认为 False
    def handle_error(self, force=False):
        # 当场景为 -1 时循环执行以下操作
        while self.scene() == -1:
            # 更新识别结果
            self.recog.update()
            # 记录日志，返回基建主界面
            logger.info('返回基建主界面')
            # 初始化未知计数
            unknown_count = 0
            # 当基建场景不为 201 且未知计数小于 5 时执行以下操作
            while self.get_infra_scene() != 201 and unknown_count < 5:
                # 如果找到 'index_infrastructure' 元素，则点击该元素
                if self.find('index_infrastructure') is not None:
                    self.tap_element('index_infrastructure')
                else:
                    # 否则返回上一级
                    self.back()
                # 更新识别结果
                self.recog.update()
                # 等待 1 秒
                time.sleep(1)
                # 未知计数加一
                unknown_count += 1
            # 退出设备
            self.device.exit(self.服务器)
        # 如果出现错误或者 force 参数为 True 时执行以下操作
        if self.error or force:
            # 如果没有任何时间小于当前时间的任务才生成空任务
            if self.find_next_task(datetime.now()) is None:
                logger.debug("由于出现错误情况，生成一次空任务来执行纠错")
                self.任务列表.append(SchedulerTask())
            # 如果没有任何时间小于当前时间的任务-10分钟 则清空任务
            if self.find_next_task(datetime.now() - timedelta(seconds=900)) is not None:
                logger.info("检测到执行超过15分钟的任务，清空全部任务")
                self.任务列表 = []
        # 如果没有出现错误且 force 参数为 False 时执行以下操作
        elif self.find_next_task(datetime.now() + timedelta(hours=2.5)) is None:
            logger.debug("2.5小时内没有其他任务，生成一个空任务")
            self.任务列表.append(SchedulerTask(time=datetime.now() + timedelta(hours=2.5)))
        # 返回 True
        return True
    # 定义基建首页的主要逻辑函数
    def infra_main(self):
        """ 位于基建首页 """
        # 如果找不到控制中心，则返回上一级
        if self.find('control_central') is None:
            self.back()
            return
        # 如果有任务
        if self.任务 is not None:
            try:
                # 如果任务计划中的键数量大于0
                if len(self.任务.plan.keys()) > 0:
                    get_time = False
                    # 如果任务类型是Shift_Change，则需要获取时间
                    if "Shift_Change" == self.任务.type:
                        get_time = True
                    # 执行任务计划中的操作
                    self.跑单(self.任务.plan, get_time)
                    # 如果需要获取时间，则记录计划元数据
                    if get_time:
                        self.plan_metadata()
                # 如果任务类型是'impart'，则跳过计划和收集通知
                # elif self.任务.type == 'impart':
                #     self.skip(['planned', 'collect_notification'])
                # 删除已完成的任务
                del self.任务列表[0]
            except Exception as e:
                # 记录异常并跳过当前任务
                logger.exception(e)
                self.skip()
                self.error = True
            # 重置当前任务为None
            self.任务 = None
        # 如果没有计划
        elif not self.planned:
            try:
                # 执行计划求解器
                self.plan_solver()
            except Exception as e:
                # 记录异常并设置错误标志
                # 重新扫描
                self.error = True
                logger.exception({e})
            # 设置已经有计划
            self.planned = True
        # 如果没有待办任务
        elif not self.todo_task:
            # 设置有待办任务
            self.todo_task = True
        # 如果没有收集通知
        elif not self.collect_notification:
            # 检测基建通知
            notification = detector.infra_notification(self.recog.img)
            # 如果没有检测到通知，则等待1秒后再次检测
            if notification is None:
                time.sleep(1)
                notification = detector.infra_notification(self.recog.img)
            # 如果检测到通知，则点击通知
            if notification is not None:
                self.tap(notification)
            # 设置已经收集通知
            self.collect_notification = True
        else:
            # 处理错误情况
            return self.handle_error()
    # 解决计划任务
    def plan_solver(self):
        # 获取计划
        plan = self.plan
        # 如果下个普通任务在10分钟内，则跳过计划
        if self.find_next_task(datetime.now() + timedelta(seconds=600)) is not None:
            return
        # 如果运行顺序房间数量大于0
        if len(self.run_order_rooms) > 0:
            # 遍历运行顺序房间
            for k, v in self.run_order_rooms.items():
                # 如果当前房间数据中没有计划
                if 'plan' not in v.keys():
                    # 获取当前房间的干员信息
                    v['plan'] = self.干员信息.get_current_room(k)
                # 如果找到下一个任务类型，则继续
                if self.find_next_task(task_type=k) is not None: continue;
                # 创建进出计划字典
                in_out_plan = {k: ['Current'] * len(plan[k])}
                # 遍历计划中的任务
                for idx, x in enumerate(plan[k]):
                    # 如果替换中包含'但书'或'龙舌兰'
                    if '但书' in x['replacement'] or '龙舌兰' in x['replacement']:
                        # 将进出计划中对应位置替换为第一个替换项
                        in_out_plan[k][idx] = x['replacement'][0]
                # 添加任务到任务列表
                self.任务列表.append(
                    SchedulerTask(time=self.读取接单时间(k), task_plan=in_out_plan, task_type=k))
        # 输出干员信息
        logger.debug(self.干员信息.print())

    # 初始化干员信息
    def initialize_operators(self):
        # 获取计划
        plan = self.plan
        # 创建干员信息对象
        self.干员信息 = Operators({}, 4, plan)
        # 遍历计划中的房间
        for room in plan.keys():
            # 遍历房间中的数据
            for idx, data in enumerate(plan[room]):
                # 添加干员信息
                self.干员信息.add(Operator(data["agent"], room, idx, data["group"], data["replacement"], 'high',
                                       operator_type="high"))
        # 初始化已添加列表
        added = []
        # 遍历计划中的项目
        for x, y in self.plan.items():
            # 如果项目不是以'room'开头，则继续
            if not x.startswith('room'): continue
            # 如果替换中包含'但书'或'龙舌兰'
            if any(('但书' in obj['replacement'] or '龙舌兰' in obj['replacement']) for obj in y):
                # 添加到跑单房间中
                self.run_order_rooms[x] = {}
    # 读取接单时间方法，传入参数为房间号
    def 读取接单时间(self, room):
        # 记录日志，提示正在读取接单时间
        logger.info('读取接单时间')
        # 点击进入该房间
        self.进入房间(room)
        # 进入房间详情
        error_count = 0
        # 循环直到找到订单加速按钮，最多尝试5次
        while self.find('bill_accelerate') is None:
            if error_count > 5:
                raise Exception('未成功进入订单界面')
            self.tap((self.recog.w * 0.05, self.recog.h * 0.95), interval=1)
            error_count += 1
        # 读取订单执行时间
        execute_time = self.double_read_time((int(self.recog.w * 650 / 2496), int(self.recog.h * 660 / 1404),
                                              int(self.recog.w * 815 / 2496), int(self.recog.h * 710 / 1404)),
                                             use_digit_reader=True)
        # 记录警告日志，提示房间接单时间
        logger.warning('房间 B' + room[5] + '0' + room[7] + ' 接单时间为 ' + execute_time.strftime("%H:%M:%S"))
        # 计算提前跑单时间
        execute_time = execute_time - timedelta(seconds=(self.跑单提前运行时间))
        # 更新识别器
        self.recog.update()
        # 返回基本主界面
        self.返回基主界面()
        # 返回计算后的执行时间
        return execute_time

    # 读取时间的方法，传入参数为坐标、上限时间和是否使用数字识别器
    def double_read_time(self, cord, upperLimit=None, use_digit_reader=False):
        # 如果上限时间小于36000，则设置上限时间为36000
        if upperLimit is not None and upperLimit < 36000:
            upperLimit = 36000
        # 更新识别器
        self.recog.update()
        # 读取时间并返回执行时间
        time_in_seconds = self.read_time(cord, upperLimit, use_digit_reader)
        if time_in_seconds is None:
            return datetime.now()
        execute_time = datetime.now() + timedelta(seconds=(time_in_seconds))
        return execute_time

    # 初始化 PaddleOCR 方法
    def initialize_paddle(self):
        global ocr
        # 如果 OCR 为空，则初始化 PaddleOCR
        if ocr is None:
            # 如果是 mac 平台，则关闭 mkldnn 加速
            if sys.platform == 'darwin':
                ocr = PaddleOCR(enable_mkldnn=False, use_angle_cls=False, show_log=False)
            else:
                ocr = PaddleOCR(enable_mkldnn=True, use_angle_cls=False, show_log=False)
    # 读取屏幕内容并进行识别
    def read_screen(self, img, type="mood", limit=24, cord=None):
        # 如果给定了坐标范围，则截取对应区域的图像
        if cord is not None:
            img = img[cord[1]:cord[3], cord[0]:cord[2]]
        # 如果类型是心情或时间，则对图像进行处理以提高准确率
        if 'mood' in type or type == "time":
            # 心情图片太小，复制8次提高准确率
            for x in range(0, 4):
                img = cv2.vconcat([img, img])
        try:
            # 初始化 PaddlePaddle OCR
            self.initialize_paddle()
            # 使用 OCR 进行图像识别
            rets = ocr.ocr(img, cls=True)
            line_conf = []
            # 遍历识别结果
            for idx in range(len(rets[0])):
                res = rets[0][idx]
                if 'mood' in type:
                    # 过滤掉不符合规范的结果
                    if ('/' + str(limit)) in res[1][0]:
                        line_conf.append(res[1])
                else:
                    line_conf.append(res[1])
            logger.debug(line_conf)
            # 如果没有识别结果，则根据类型返回相应值
            if len(line_conf) == 0:
                if 'mood' in type:
                    return -1
                elif 'name' in type:
                    logger.debug("使用老版识别")
                    return character_recognize.agent_name(img, self.recog.h)
                else:
                    return ""
            x = [i[0] for i in line_conf]
            __str = max(set(x), key=x.count)
            # 根据类型处理识别结果
            if "mood" in type:
                if '.' in __str:
                    __str = __str.replace(".", "")
                number = int(__str[0:__str.index('/')])
                return number
            elif 'time' in type:
                if '.' in __str:
                    __str = __str.replace(".", ":")
            elif 'name' in type and __str not in agent_list:
                logger.debug("使用老版识别")
                __str = character_recognize.agent_name(img, self.recog.h)
            logger.debug(__str)
            return __str
        except Exception as e:
            logger.exception(e)
            return limit + 1
    # 读取时间信息
    def read_time(self, cord, upperlimit, error_count=0, use_digit_reader=False):
        # 刷新图片
        self.recog.update()
        # 如果使用数字识别器，则调用数字识别器获取时间字符串
        if use_digit_reader:
            time_str = self.digit_reader.get_time(self.recog.gray)
        else:
            # 否则从屏幕中读取时间信息
            time_str = self.read_screen(self.recog.img, type='time', cord=cord)
        try:
            # 尝试将时间字符串分割成时、分、秒
            h, m, s = str(time_str).split(':')
            # 如果分钟或秒钟大于60，则抛出异常
            if int(m) > 60 or int(s) > 60:
                raise Exception(f"读取错误")
            # 计算总秒数
            res = int(h) * 3600 + int(m) * 60 + int(s)
            # 如果超过了上限，则抛出异常
            if upperlimit is not None and res > upperlimit:
                raise Exception(f"超过读取上限")
            else:
                return res
        except:
            # 读取失败时记录错误信息
            logger.error("读取失败")
            # 如果错误次数超过3次，则记录异常并返回None
            if error_count > 3:
                logger.exception(f"读取失败{error_count}次超过上限")
                return None
            else:
                # 否则递归调用自身，增加错误次数
                return self.read_time(cord, upperlimit, error_count + 1, use_digit_reader)

    # 处理基建收获产物列表
    def 收获产物(self) -> None:
        """ 处理基建收获产物列表 """
        # 标记是否已经点击
        tapped = False
        # 查找干员信赖并点击
        trust = self.find('infra_collect_trust')
        if trust is not None:
            logger.info('干员信赖')
            self.tap(trust)
            tapped = True
        # 查找订单交付并点击
        bill = self.find('infra_collect_bill')
        if bill is not None:
            logger.info('订单交付')
            self.tap(bill)
            tapped = True
        # 查找可收获并点击
        factory = self.find('infra_collect_factory')
        if factory is not None:
            logger.info('可收获')
            self.tap(factory)
            tapped = True
        # 如果没有点击任何按钮，则点击屏幕左下角
        if not tapped:
            self.tap((self.recog.w * 0.05, self.recog.h * 0.95))
            self.todo_task = True
    # 进入指定房间，并返回房间的位置信息
    def 进入房间(self, room: str) -> tp.Rectangle:
        """ 获取房间的位置并进入 """

        # 获取基建各个房间的位置
        base_room = segment.base(self.recog.img, self.find('control_central', strict=True))
        # 将画面外的部分删去
        _room = base_room[room]

        for i in range(4):
            # 确保房间位置不超出屏幕范围
            _room[i, 0] = max(_room[i, 0], 0)
            _room[i, 0] = min(_room[i, 0], self.recog.w)
            _room[i, 1] = max(_room[i, 1], 0)
            _room[i, 1] = min(_room[i, 1], self.recog.h)

        # 点击进入指定房间
        self.tap(_room[0], interval=1)
        # 循环检查是否成功进入房间，直到成功为止
        while self.find('control_central') is not None:
            self.tap(_room[0], interval=1)

    # 获取最佳的干员排序方式
    def get_arrange_order(self) -> 干员排序方式:
        best_score, best_order = 0, None
        for order in 干员排序方式:
            # 计算每种排序方式的得分，并找出最佳的排序方式
            score = self.recog.score(干员排序方式位置[order][0])
            if score is not None and score[0] > best_score:
                best_score, best_order = score[0], order
        logger.debug((best_score, best_order))
        return best_order

    # 切换干员排序方式
    def switch_arrange_order(self, index: int, asc="false") -> None:
        # 点击切换到指定排序方式
        self.tap((self.recog.w * 干员排序方式位置[干员排序方式(index)][0],
                  self.recog.h * 干员排序方式位置[干员排序方式(index)][1]), interval=0, rebuild=False)
        # 点击一个不需要的排序方式，用于切换回来
        if index < 4:
            self.tap((self.recog.w * 干员排序方式位置[干员排序方式(index + 1)][0],
                      self.recog.h * 干员排序方式位置[干员排序方式(index)][1]), interval=0, rebuild=False)
        else:
            self.tap((self.recog.w * 干员排序方式位置[干员排序方式(index - 1)][0],
                      self.recog.h * 干员排序方式位置[干员排序方式(index)][1]), interval=0, rebuild=False)
        # 切回指定排序方式
        self.tap((self.recog.w * 干员排序方式位置[干员排序方式(index)][0],
                  self.recog.h * 干员排序方式位置[干员排序方式(index)][1]), interval=0.2, rebuild=True)
        # 如果需要倒序，则再次点击切换排序方式
        if asc != "false":
            self.tap((self.recog.w * 干员排序方式位置[干员排序方式(index)][0],
                      self.recog.h * 干员排序方式位置[干员排序方式(index)][1]), interval=0.2, rebuild=True)
    # 扫描干员，识别干员并返回选择的干员名字和识别结果
    def scan_agant(self, agent: list[str], error_count=0, max_agent_count=-1):
        try:
            # 更新识别器
            self.recog.update()
            # 识别干员
            ret = character_recognize.agent(self.recog.img)  # 返回的顺序是从左往右从上往下
            # 提取识别出来的干员的名字
            select_name = []
            for y in ret:
                name = y[0]
                if name in agent:
                    select_name.append(name)
                    # 点击干员位置
                    self.tap((y[1][0]), interval=0)
                    # 从待选干员列表中移除已选择的干员
                    agent.remove(name)
                    # 如果是按照个数选择 Free
                    if max_agent_count != -1:
                        if len(select_name) >= max_agent_count:
                            return select_name, ret
            return select_name, ret
        except Exception as e:
            # 错误计数加一
            error_count += 1
            if error_count < 3:
                # 记录异常信息
                logger.exception(e)
                # 等待一秒
                time.sleep(1)
                # 递归调用自身
                return self.scan_agant(agent, error_count, max_agent_count)
            else:
                # 如果错误计数达到3次，抛出异常
                raise e

    # 详细筛选，打开或关闭指定类型的筛选
    def detail_filter(self, turn_on, type="not_in_dorm"):
        logger.info(f'开始 {("打开" if turn_on else "关闭")} {type} 筛选')
        # 点击筛选按钮
        self.tap((self.recog.w * 0.95, self.recog.h * 0.05), interval=1)
        if type == "not_in_dorm":
            # 查找非宿舍中的干员
            not_in_dorm = self.find('arrange_non_check_in', score=0.9)
            # 如果需要打开筛选且未找到非宿舍中的干员，或者需要关闭筛选且找到非宿舍中的干员
            if turn_on ^ (not_in_dorm is None):
                # 点击选择按钮
                self.tap((self.recog.w * 0.3, self.recog.h * 0.5), interval=0.5)
        # 确认筛选
        self.tap((self.recog.w * 0.8, self.recog.h * 0.8), interval=0.5)

    # 左滑操作
    def swipe_left(self, right_swipe, w, h):
        for _ in range(right_swipe):
            # 执行左滑操作
            self.swipe_only((w // 2, h // 2), (w // 2, 0), interval=0.5)
        return 0

    # 推送操作
    @push_operators
    # 刷新当前房间信息
    def refresh_current_room(self, room):
        # 获取当前房间信息
        _current_room = self.干员信息.get_current_room(room)
        # 如果当前房间信息为空
        if _current_room is None:
            # 从房间获取干员信息
            self.get_agent_from_room(room)
            # 获取当前房间信息，强制刷新
            _current_room = self.干员信息.get_current_room(room, True)
        # 返回当前房间信息
        return _current_room

    # 跳过指定任务
    def skip(self, task_names='All'):
        # 如果任务名为'All'，则跳过所有任务
        if task_names == 'All':
            task_names = ['planned', 'collect_notification', 'todo_task']
        # 如果计划任务在任务名列表中
        if 'planned' in task_names:
            self.planned = True
        # 如果待办任务在任务名列表中
        if 'todo_task':
            self.todo_task = True
        # 如果收集通知在任务名列表中
        if 'collect_notification':
            self.collect_notification = True

    # MAA 日志回调函数
    @Asst.CallBackType
    def log_maa(msg, details, arg):
        # 创建消息对象
        m = Message(msg)
        # 解析详细信息为 JSON 格式
        d = json.loads(details.decode('utf-8'))
        # 记录日志
        logger.debug(d)
        logger.debug(m)
        logger.debug(arg)

    # 初始化 MAA
    def MAA初始化(self):
        # 加载 MAA 设置路径
        Asst.load(path=self.MAA设置['MAA路径'])
        # 创建 MAA 对象，并传入日志回调函数
        self.MAA = Asst(callback=self.log_maa)
        # 初始化关卡列表
        self.关卡列表 = []
        # 连接到 MAA 设备
        if self.MAA.connect(self.MAA设置['MAA_adb路径'], self.device.client.device_id):
            logger.info("MAA 连接成功")
        else:
            logger.info("MAA 连接失败")
            raise Exception("MAA 连接失败")
    # 向 MAA 任务列表中添加任务
    def append_maa_task(self, type):
        # 如果类型是 ['StartUp', 'Visit', 'Award'] 中的一种
        if type in ['StartUp', 'Visit', 'Award']:
            # 向 MAA 任务列表中添加对应类型的任务
            self.MAA.append_task(type)
        # 如果类型是 'Fight'
        elif type == 'Fight':
            # 获取当前服务器的周计划
            _plan = self.MAA设置['周计划'][get_server_weekday()]
            # 记录当前服务器的日子
            logger.info(f"现在服务器是{_plan['日子']}")
            # 遍历周计划中的关卡
            for stage in _plan["关卡"]:
                # 记录添加的关卡
                logger.info(f"添加关卡:{stage}")
                # 向 MAA 任务列表中添加 'Fight' 类型的任务
                self.MAA.append_task('Fight', {
                    # 关卡名称
                    'stage': stage,
                    # 应急理智药数量
                    '应急理智药': _plan["应急理智药"],
                    # 石头数量
                    'stone': 0,
                    # 次数
                    'times': 999,
                    # 是否向企鹅汇报
                    'report_to_penguin': True,
                    # 客户端类型
                    'client_type': '',
                    # 企鹅 ID
                    'penguin_id': '',
                    # 是否使用 DrGrandet
                    'DrGrandet': False,
                    # 服务器地区
                    'server': 'CN',
                    # 过期药品数量
                    'expiring_medicine': 9999
                })
                # 将关卡名称添加到关卡列表中
                self.关卡列表.append(stage)
        # 如果类型是 'Recruit'
        # elif type == 'Recruit':
        #     # 向 MAA 任务列表中添加 'Recruit' 类型的任务
        #     self.MAA.append_task('Recruit', {
        #         # 选择的招聘类型
        #         'select': [4],
        #         # 确认的招聘类型
        #         'confirm': [3, 4],
        #         # 次数
        #         'times': 4,
        #         # 是否刷新
        #         'refresh': True,
        #         # 招募时间
        #         "recruitment_time": {
        #             "3": 460,
        #             "4": 540
        #         }
        #     })
        # 如果类型是 'Mall'
        # elif type == 'Mall':
        #     # 是否进行信用商店的战斗
        #     credit_fight = False
        #     # 如果关卡列表不为空且最后一个关卡不是空字符串
        #     if len(self.关卡列表) > 0 and self.关卡列表[- 1] != '':
        #         credit_fight = True
        #     # 向 MAA 任务列表中添加 'Mall' 类型的任务
        #     self.MAA.append_task('Mall', {
        #         # 是否购物
        #         'shopping': True,
        #         # 首先购买的物品
        #         'buy_first': ['招聘许可'],
        #         # 黑名单物品
        #         'blacklist': ['家具', '碳', '加急许可'],
        #         # 是否进行信用商店的战斗
        #         'credit_fight': credit_fight
        #     })

    # def maa_plan_solver(self, 任务列表='All', one_time=False):
    # 定义一个发送邮件的方法，可以传入邮件内容、主题和重试次数
    def send_email(self, context=None, subject='', retry_time=3):
        # 声明全局变量，任务
        global 任务
        # 如果邮件设置中包含邮件提醒并且值为0，则不发送邮件，记录日志并返回
        if '邮件提醒' in self.邮件设置.keys() and self.邮件设置['邮件提醒'] == 0:
            logger.info('邮件功能未开启')
            return
        # 当重试次数大于0时，循环发送邮件
        while retry_time > 0:
            try:
                # 创建一个多部分邮件对象
                msg = MIMEMultipart()
                # 如果邮件内容为空，则使用默认的 HTML 格式内容
                if context is None:
                    context = """
                    <html>
                        <body>
                        <table border="1">
                        <tr><th>时间</th><th>房间</th></tr>                    
                    """
                    # 遍历任务列表，将任务的时间和类型添加到邮件内容中
                    for 任务 in self.任务列表:
                        context += f"""<tr><td>{任务.time.strftime('%Y-%m-%d %H:%M:%S')}</td>
                                            <td>{任务.type}</td></tr>    
                                    """
                    context += "</table></body></html>"
                    # 将 HTML 格式的内容添加到邮件中
                    msg.attach(MIMEText(context, 'html'))
                else:
                    # 如果邮件内容不为空，则将内容转换为纯文本格式添加到邮件中
                    msg.attach(MIMEText(str(context), 'plain', 'utf-8'))
                # 设置邮件主题
                msg['Subject'] = ('将在 ' + self.任务列表[0].time.strftime('%H:%M:%S') +
                                  ' 于房间 B' + self.任务列表[0].type[5] + '0' + self.任务列表[0].type[7] + ' 进行跑单')
                # 设置发件人
                msg['From'] = self.邮件设置['发信邮箱']
                # 连接到 QQ 邮箱的 SMTP 服务器
                s = smtplib.SMTP_SSL("smtp.qq.com", 465, timeout=10.0)
                # 登录邮箱
                s.login(self.邮件设置['发信邮箱'], self.邮件设置['授权码'])
                # 开始发送邮件
                s.sendmail(self.邮件设置['发信邮箱'], self.邮件设置['收件人邮箱'], msg.as_string())
                # 发送成功后跳出循环
                break
            except Exception as e:
                # 发送失败时记录错误日志，减少重试次数，等待一秒后继续重试
                logger.error("邮件发送失败")
                logger.exception(e)
                retry_time -= 1
                time.sleep(1)
# 初始化函数，用于设置一些全局配置和创建项目对象
def 初始化(任务列表, scheduler=None):
    # 设置ADB设备地址
    config.ADB_DEVICE = MAA设置['MAA_adb地址']
    # 设置ADB连接地址
    config.ADB_CONNECT = MAA设置['MAA_adb地址']
    # 设置APP名称为服务器
    config.APPNAME = 服务器
    # 设置是否点击启动APP的配置
    config.TAP_TO_LAUNCH = [{"enable": "false", "x": "0", "y": "0"}]
    # 初始化fhlr
    init_fhlr()
    # 创建设备控制对象
    device = 设备控制()
    # 创建Solver对象
    cli = Solver(device)
    # 如果没有调度器，则创建项目经理对象
    if scheduler is None:
        当前项目 = 项目经理(cli.device, cli.recog)
        当前项目.服务器 = 服务器
        当前项目.operators = {}
        当前项目.plan = {}
        当前项目.current_base = {}
        # 遍历跑单位置设置，创建对应的计划
        for 房间 in 跑单位置设置:
            当前项目.plan['room_' + 房间[1] + '_' + 房间[3]] = []
            for 干员 in 跑单位置设置[房间]:
                当前项目.plan['room_' + 房间[1] + '_' + 房间[3]].append(
                    {'agent': '', 'group': '', 'replacement': [干员]})
        # 如果龙舌兰和但书休息为真，则设置宿舍计划
        if 龙舌兰和但书休息:
            global 龙舌兰和但书休息宿舍
            for 宿舍 in 宿舍设置:
                if 宿舍 == 'B401':
                    龙舌兰和但书休息宿舍 = 'dormitory_4'
                else:
                    龙舌兰和但书休息宿舍 = 'dormitory_' + 宿舍[1]
                当前项目.plan[龙舌兰和但书休息宿舍] = []
                for 干员 in 宿舍设置[宿舍]:
                    if 干员 == '当前休息干员':  干员 = 'Current'
                    当前项目.plan[龙舌兰和但书休息宿舍].append({'agent': 干员, 'group': '', 'replacement': ''})
        # 设置项目的任务列表等属性
        当前项目.任务列表 = 任务列表
        当前项目.last_room = ''
        当前项目.MAA = None
        当前项目.邮件设置 = 邮件设置
        当前项目.ADB_CONNECT = config.ADB_CONNECT[0]
        当前项目.MAA设置 = MAA设置
        当前项目.error = False
        当前项目.跑单提前运行时间 = 跑单提前运行时间
        当前项目.更换干员前缓冲时间 = 更换干员前缓冲时间
        return 当前项目
    else:
        # 如果有调度器，则设置调度器的设备和识别器，并处理错误
        scheduler.device = cli.device
        scheduler.recog = cli.recog
        scheduler.handle_error(True)
        return scheduler


# 创建线程类，继承自threading.Thread
class 线程(threading.Thread):

    def __init__(self, *args, **kwargs):
        super(线程, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

# 终止线程报错函数，用于引发异常并进行清理
def 终止线程报错(tid, exctype):
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    # 使用 ctypes 调用 C 语言函数 PyThreadState_SetAsyncExc 来向指定线程发送异步异常
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    # 如果返回值为 0，表示线程 ID 无效，抛出数值错误异常
    if res == 0:
        raise ValueError("invalid thread id")
    # 如果返回值不为 1，表示出现问题，需要再次调用函数并传入 exc=NULL 来撤销效果
    elif res != 1:
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")
# 显示字幕的函数
def 显示字幕():
    窗口.deiconify()


# 当窗口被选中时的事件处理函数
def 选中窗口(event):
    global 鼠标水平初始位置, 鼠标竖直初始位置
    鼠标水平初始位置 = event.x  # 获取鼠标相对于窗体左上角的X坐标
    鼠标竖直初始位置 = event.y  # 获取鼠标相对于窗左上角体的Y坐标


# 拖动窗口时的事件处理函数
def 拖动窗口(event):
    窗口.geometry(f'+{event.x_root - 鼠标水平初始位置}+{event.y_root - 鼠标竖直初始位置}')


# 关闭窗口的函数
def 关闭窗口(icon: pystray.Icon):
    窗口.withdraw()


# 缩放字幕时的事件处理函数
def 缩放字幕(event):
    global 字幕字号
    if event.delta > 0:
        字幕字号 += 1
    else:
        字幕字号 -= 1
    if 字幕字号 < 1:
        字幕字号 = 1
    elif 字幕字号 > 90:
        字幕字号 = 90


# 跑单任务查询的函数
def 跑单任务查询(icon: pystray.Icon):
    icon.notify(任务提示, "Mower跑单任务列表")


# 重新运行Mower的函数
def 重新运行Mower():
    global Mower
    try:
        Mower._stop_event.set()
        终止线程报错(Mower.ident, SystemExit)
    except:
        pass
    Mower = 线程()
    Mower.start()


# 停止运行Mower的函数
def 停止运行Mower():
    Mower._stop_event.set()
    终止线程报错(Mower.ident, SystemExit)
    logger.info('Mower已停止')


# 退出程序的函数
def 退出程序(icon, item):
    icon.stop()  # 对象停止方法
    pid = os.getpid()  # 获取当前进程ID
    try:  # 杀掉后台进程
        if 悬浮字幕开关:  窗口.destroy()
        os.system('taskkill -f -pid %s' % pid)
    except:
        pass


# 更新字幕的函数
def 更新字幕():
    global 字幕
    任务倒计时 = int((下个任务开始时间 - datetime.now()).total_seconds() / 60)
    字幕 = 'Mower的回合！'
    if 任务倒计时 >= 0:
        字幕 = 'Mower将在' + str(任务倒计时) + '分钟后开始跑单'
        if 任务倒计时 <= 5:
            字幕 += '\n跑单即将开始！'
    label.config(text=字幕, font=(字幕字体 + ' ' + 字幕字号), bg=字幕颜色,
                 fg=字幕颜色[:6] + str(int(字幕颜色[5] == '0')))
    窗口.after(100, 更新字幕)


# 托盘菜单
托盘菜单 = (MenuItem(任务提示, 跑单任务查询, default=True, visible=False),
            MenuItem('显示字幕', 显示字幕, visible=悬浮字幕开关),
            MenuItem('重新运行Mower', 重新运行Mower, visible=True),
            MenuItem('停止运行Mower', 停止运行Mower, visible=True),
            Menu.SEPARATOR, MenuItem('退出', 退出程序))
# 创建托盘对象
托盘 = pystray.Icon("Mower 纯跑单", Image.open("logo.png"), "Mower 纯跑单", 托盘菜单)
# 如果悬浮字幕开关打开，则设置窗口的位置和大小
if 悬浮字幕开关:
    窗口.geometry("%dx%d+%d+%d" % (窗口宽度, 窗口高度,
                                   (窗口.winfo_screenwidth() - 窗口宽度) / 2,
                                   窗口.winfo_screenheight() * 3 / 4 - 窗口高度/ 2))
    # 设置窗口为无边框
    窗口.overrideredirect(True)
    # 设置窗口标题
    窗口.title("窗口")
    # 设置窗口始终在顶层显示
    窗口.attributes("-topmost", 1)
    # 设置窗口的透明颜色
    窗口.wm_attributes("-transparentcolor", 字幕颜色)

    # 添加一个标签小部件
    label = Label(窗口)
    # 将标签小部件放置在窗口顶部，并填充整个窗口
    label.pack(side="top", fill="both", expand=True)
    # 绑定鼠标左键单击事件，触发选中窗口函数
    label.bind("<Button-1>", 选中窗口)
    # 绑定鼠标左键拖动事件，触发拖动窗口函数
    label.bind("<B1-Motion>", 拖动窗口)
    # 绑定鼠标左键双击事件，触发关闭窗口函数
    label.bind("<Double-Button-1>", 关闭窗口)
    # 绑定鼠标滚轮事件，触发缩放字幕函数
    label.bind("<MouseWheel>", 缩放字幕)
# 如果当前模块被直接执行，则执行以下代码
if __name__ == "__main__":
    # 设置日志
    日志设置()
    # 创建一个新的线程来运行托盘的功能
    threading.Thread(target=托盘.run, daemon=False).start()
    # 创建一个新的线程对象
    Mower = 线程()
    # 启动线程
    Mower.start()
    # 如果悬浮字幕开关为真，则在窗口中每隔100毫秒更新一次字幕
    if 悬浮字幕开关:
        窗口.after(100, 更新字幕)
        # 进入 Tkinter 的主事件循环
        窗口.mainloop()
```