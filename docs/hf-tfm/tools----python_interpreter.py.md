# `.\transformers\tools\python_interpreter.py`

```py
#!/usr/bin/env python
# coding=utf-8

# Copyright 2023 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import ast  # 导入ast模块
import difflib  # 导入difflib模块
from collections.abc import Mapping  # 从collections.abc模块导入Mapping类
from typing import Any, Callable, Dict  # 从typing模块导入Any、Callable、Dict类


class InterpretorError(ValueError):  # 定义一个名为InterpretorError的类，继承自ValueError类
    """
    An error raised when the interpretor cannot evaluate a Python expression, due to syntax error or unsupported
    operations.
    """
    pass  # 空实现


def evaluate(code: str, tools: Dict[str, Callable], state=None, chat_mode=False):
    """
    Evaluate a python expression using the content of the variables stored in a state and only evaluating a given set
    of functions.

    This function will recurse through the nodes of the tree provided.

    Args:
        code (`str`):
            The code to evaluate.
        tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation. Any call to another function will fail with an
            `InterpretorError`.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` should contain the initial inputs but will be
            updated by this function to contain all variables as they are evaluated.
        chat_mode (`bool`, *optional*, defaults to `False`):
            Whether or not the function is called from `Agent.chat`.
    """
    try:  # 尝试执行以下代码块
        expression = ast.parse(code)  # 解析传入的代码字符串生成抽象语法树对象
    except SyntaxError as e:  # 如果捕获到SyntaxError异常，则执行以下代码块
        print("The code generated by the agent is not valid.\n", e)  # 打印错误消息
        return  # 返回None
    if state is None:  # 如果state为None
        state = {}  # 初始化state为空字典
    result = None  # 初始化result为None
    for idx, node in enumerate(expression.body):  # 遍历抽象语法树的body属性
        try:  # 尝试执行以下代码块
            line_result = evaluate_ast(node, state, tools)  # 调用evaluate_ast函数对当前节点进行解析和计算
        except InterpretorError as e:  # 捕获InterpretorError异常
            msg = f"Evaluation of the code stopped at line {idx} before the end because of the following error"  # 拼接错误消息
            if chat_mode:  # 如果chat_mode为True
                msg += (f". Copy paste the following error message and send it back to the agent:\nI get an error: '{e}'")  # 拼接错误消息
            else:  # 否则
                msg += f":\n{e}"  # 拼接错误消息
            print(msg)  # 打印错误消息
            break  # 跳出循环
        if line_result is not None:  # 如果line_result不为None
            result = line_result  # 更新结果
    return result  # 返回结果


def evaluate_ast(expression: ast.AST, state: Dict[str, Any], tools: Dict[str, Callable]):
    """
    Evaluate an absract syntax tree using the content of the variables stored in a state and only evaluating a given
    set of functions.
    """
    # 该函数将递归遍历提供的树的节点。
    
    Args:
        expression (`ast.AST`):
            要评估的代码，作为抽象语法树。
        state (`Dict[str, Any]`):
            将变量名映射到值的字典。如果需要，评估过程中将更新`state`。
        tools (`Dict[str, Callable]`):
            可以在评估期间调用的函数。对其他函数的调用将引发`InterpretorError`。
    
    如果`expression`是`ast.Assign`类型：
        # 赋值 -> 我们评估赋值，这应该会更新state
        # 我们返回分配的变量，因为它可能被用来确定最终结果。
        返回 evaluate_assign(expression, state, tools)
    如果`expression`是`ast.Call`类型：
        # 函数调用 -> 返回函数调用的值
        返回 evaluate_call(expression, state, tools)
    如果`expression`是`ast.Constant`类型：
        # 常量 -> 只需返回值
        返回 expression.value
    如果`expression`是`ast.Dict`类型：
        # 字典 -> 评估所有键和值
        对于表达式中的每个键k，评估k并存储在keys列表中
        对于表达式中的每个值v，评估v并存储在values列表中
        返回由keys和values组成的字典
    如果`expression`是`ast.Expr`类型：
        # 表达式 -> 评估内容
        返回 evaluate_ast(expression.value, state, tools)
    如果`expression`是`ast.For`类型：
        # For 循环 -> 执行循环
        返回 evaluate_for(expression, state, tools)
    如果`expression`是`ast.FormattedValue`类型：
        # 格式化值（f-string的一部分） -> 评估内容并返回
        返回 evaluate_ast(expression.value, state, tools)
    如果`expression`是`ast.If`类型：
        # If语句 -> 执行正确的分支
        返回 evaluate_if(expression, state, tools)
    如果`expression`的类型为`ast.Index`：
        返回 evaluate_ast(expression.value, state, tools)
    如果`expression`是`ast.JoinedStr`类型：
        对于表达式中的每个值v，评估v并以字符串形式加入到结果中
    如果`expression`是`ast.List`类型：
        # 列表 -> 评估所有元素
        返回由表达式中每个元素elt的评估结果组成的列表
    如果`expression`是`ast.Name`类型：
        # 名称 -> 从状态中取出值
        返回 evaluate_name(expression, state, tools)
    如果`expression`是`ast.Subscript`类型：
        # 下标 -> 返回索引的值
        返回 evaluate_subscript(expression, state, tools)
    否则：
        # 目前我们拒绝任何其他类型。在需要时添加更多支持。
        抛出`InterpretorError`，内容为`{expression.__class__.__name__} is not supported.`
# 评估赋值表达式，将结果存储在状态中
def evaluate_assign(assign, state, tools):
    # 获取赋值目标变量名
    var_names = assign.targets
    # 评估赋值表达式的值
    result = evaluate_ast(assign.value, state, tools)

    # 处理单个变量名的情况
    if len(var_names) == 1:
        state[var_names[0].id] = result
    # 处理多个变量名的情况
    else:
        if len(result) != len(var_names):
            raise InterpretorError(f"Expected {len(var_names)} values but got {len(result)}.")
        for var_name, r in zip(var_names, result):
            state[var_name.id] = r
    return result


# 评估函数调用表达式
def evaluate_call(call, state, tools):
    # 检查函数是否为 ast.Name 类型
    if not isinstance(call.func, ast.Name):
        raise InterpretorError(
            f"It is not permitted to evaluate other functions than the provided tools (tried to execute {call.func} of "
            f"type {type(call.func)}."
        )
    func_name = call.func.id
    # 检查函数是否在提供的工具中
    if func_name not in tools:
        raise InterpretorError(
            f"It is not permitted to evaluate other functions than the provided tools (tried to execute {call.func.id})."
        )

    func = tools[func_name]
    # 处理参数
    args = [evaluate_ast(arg, state, tools) for arg in call.args]
    kwargs = {keyword.arg: evaluate_ast(keyword.value, state, tools) for keyword in call.keywords}
    return func(*args, **kwargs)


# 评估下标表达式
def evaluate_subscript(subscript, state, tools):
    index = evaluate_ast(subscript.slice, state, tools)
    value = evaluate_ast(subscript.value, state, tools)
    if isinstance(value, (list, tuple)):
        return value[int(index)]
    if index in value:
        return value[index]
    if isinstance(index, str) and isinstance(value, Mapping):
        close_matches = difflib.get_close_matches(index, list(value.keys()))
        if len(close_matches) > 0:
            return value[close_matches[0]]

    raise InterpretorError(f"Could not index {value} with '{index}'.")


# 评估变量名表达式
def evaluate_name(name, state, tools):
    if name.id in state:
        return state[name.id]
    close_matches = difflib.get_close_matches(name.id, list(state.keys()))
    if len(close_matches) > 0:
        return state[close_matches[0]]
    raise InterpretorError(f"The variable `{name.id}` is not defined.")


# 评估条件表达式
def evaluate_condition(condition, state, tools):
    if len(condition.ops) > 1:
        raise InterpretorError("Cannot evaluate conditions with multiple operators")

    left = evaluate_ast(condition.left, state, tools)
    comparator = condition.ops[0]
    right = evaluate_ast(condition.comparators[0], state, tools)

    if isinstance(comparator, ast.Eq):
        return left == right
    elif isinstance(comparator, ast.NotEq):
        return left != right
    elif isinstance(comparator, ast.Lt):
        return left < right
    elif isinstance(comparator, ast.LtE):
        return left <= right
    elif isinstance(comparator, ast.Gt):
        return left > right
    elif isinstance(comparator, ast.GtE):
        return left >= right
    elif isinstance(comparator, ast.Is):
        return left is right
    elif isinstance(comparator, ast.IsNot):
        return left is not right
    # 如果比较符号是 'in'，返回左操作数是否包含在右操作数中的结果
    elif isinstance(comparator, ast.In):
        return left in right
    # 如果比较符号是 'not in'，返回左操作数是否不包含在右操作数中的结果
    elif isinstance(comparator, ast.NotIn):
        return left not in right
    # 如果比较符号不是 'in' 或 'not in'，抛出解释器错误，提示不支持该操作符
    else:
        raise InterpretorError(f"Operator not supported: {comparator}")
# 根据 if 语句的条件表达式，执行相应的代码块
def evaluate_if(if_statement, state, tools):
    result = None
    # 判断条件表达式是否为真
    if evaluate_condition(if_statement.test, state, tools):
        # 遍历 if 语句的主体代码块
        for line in if_statement.body:
            # 执行代码块中的每一行，并获取结果
            line_result = evaluate_ast(line, state, tools)
            # 如果结果不为空，则更新最终结果
            if line_result is not None:
                result = line_result
    else:
        # 如果条件表达式为假，则执行 else 语句的代码块
        for line in if_statement.orelse:
            # 遍历 else 语句的代码块
            line_result = evaluate_ast(line, state, tools)
            # 如果结果不为空，则更新最终结果
            if line_result is not None:
                result = line_result
    # 返回最终结果
    return result

# 根据 for 循环的迭代器，执行相应的代码块
def evaluate_for(for_loop, state, tools):
    result = None
    # 获取迭代器对象
    iterator = evaluate_ast(for_loop.iter, state, tools)
    # 遍历迭代器对象
    for counter in iterator:
        # 将迭代器对象的值赋给循环变量
        state[for_loop.target.id] = counter
        # 遍历 for 循环的主体代码块
        for expression in for_loop.body:
            # 执行代码块中的每一行，并获取结果
            line_result = evaluate_ast(expression, state, tools)
            # 如果结果不为空，则更新最终结果
            if line_result is not None:
                result = line_result
    # 返回最终结果
    return result
```