# `D:\src\scipysrc\sympy\sympy\liealgebras\type_c.py`

```
# 从.cartan_type模块中导入Standard_Cartan类
# 从sympy.core.backend模块中导入eye函数
from .cartan_type import Standard_Cartan
from sympy.core.backend import eye

# 定义TypeC类，继承自Standard_Cartan类
class TypeC(Standard_Cartan):

    # __new__方法用于创建TypeC类的新实例
    def __new__(cls, n):
        # 如果n小于3，抛出数值错误异常
        if n < 3:
            raise ValueError("n cannot be less than 3")
        # 调用父类Standard_Cartan的__new__方法来创建实例，并返回
        return Standard_Cartan.__new__(cls, "C", n)

    # dimension方法返回向量空间V的维度
    def dimension(self):
        """Dimension of the vector space V underlying the Lie algebra
        
        Examples
        ========
        
        >>> from sympy.liealgebras.cartan_type import CartanType
        >>> c = CartanType("C3")
        >>> c.dimension()
        3
        """
        # 获取实例的n属性
        n = self.n
        # 返回n作为向量空间V的维度
        return n

    # basic_root方法生成具有第i个位置为1和第j个位置为-1的根
    def basic_root(self, i, j):
        """Generate roots with 1 in ith position and a -1 in jth position
        """
        # 获取实例的n属性
        n = self.n
        # 创建一个长度为n的列表，所有元素初始化为0
        root = [0]*n
        # 设置列表root的第i个位置为1，第j个位置为-1
        root[i] = 1
        root[j] = -1
        # 返回生成的根
        return root

    # simple_root方法返回C系列的第i个简单根
    def simple_root(self, i):
        """The ith simple root for the C series
        
        Every lie algebra has a unique root system.
        Given a root system Q, there is a subset of the
        roots such that an element of Q is called a
        simple root if it cannot be written as the sum
        of two elements in Q.  If we let D denote the
        set of simple roots, then it is clear that every
        element of Q can be written as a linear combination
        of elements of D with all coefficients non-negative.
        
        In C_n, the first n-1 simple roots are the same as
        the roots in A_(n-1) (a 1 in the ith position, a -1
        in the (i+1)th position, and zeroes elsewhere).  The
        nth simple root is the root in which there is a 2 in
        the nth position and zeroes elsewhere.
        
        Examples
        ========
        
        >>> from sympy.liealgebras.cartan_type import CartanType
        >>> c = CartanType("C3")
        >>> c.simple_root(2)
        [0, 1, -1]
        
        """
        # 获取实例的n属性
        n = self.n
        # 如果i小于n，返回basic_root方法生成的简单根
        if i < n:
            return self.basic_root(i-1,i)
        else:
            # 创建一个长度为n的列表，所有元素初始化为0
            root = [0]*self.n
            # 设置列表root的第n-1个位置为2
            root[n-1] = 2
            # 返回生成的根
            return root

    # positive_roots方法生成C_n的所有正根
    def positive_roots(self):
        """Generates all the positive roots of A_n
        
        This is half of all of the roots of C_n; by multiplying all the
        positive roots by -1 we get the negative roots.
        
        Examples
        ========
        
        >>> from sympy.liealgebras.cartan_type import CartanType
        >>> c = CartanType("A3")
        >>> c.positive_roots()
        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}
        
        """
        # 获取实例的n属性
        n = self.n
        # 初始化空字典posroots，用于存储正根
        posroots = {}
        # 初始化计数器k
        k = 0
        # 遍历生成前n-1个简单根的组合
        for i in range(0, n-1):
            for j in range(i+1, n):
               k += 1
               posroots[k] = self.basic_root(i, j)
               k += 1
               root = self.basic_root(i, j)
               root[j] = 1
               posroots[k] = root
        
        # 生成第n个简单根
        for i in range(0, n):
            k += 1
            root = [0]*n
            root[i] = 2
            posroots[k] = root
        
        # 返回所有生成的正根字典
        return posroots
    def roots(self):
        """
        Returns the total number of roots for C_n"
        """

        n = self.n  # 获取实例变量 n 的值
        return 2*(n**2)  # 返回 C_n 的根的总数，计算公式为 2 * n^2

    def cartan_matrix(self):
        """The Cartan matrix for C_n

        The Cartan matrix matrix for a Lie algebra is
        generated by assigning an ordering to the simple
        roots, (alpha[1], ...., alpha[l]).  Then the ijth
        entry of the Cartan matrix is (<alpha[i],alpha[j]>).

        Examples
        ========

        >>> from sympy.liealgebras.cartan_type import CartanType
        >>> c = CartanType('C4')
        >>> c.cartan_matrix()
        Matrix([
        [ 2, -1,  0,  0],
        [-1,  2, -1,  0],
        [ 0, -1,  2, -1],
        [ 0,  0, -2,  2]])

        """

        n = self.n  # 获取实例变量 n 的值
        m = 2 * eye(n)  # 创建一个大小为 n x n 的单位矩阵，并乘以 2
        for i in range(1, n - 1):
           m[i, i+1] = -1  # 设置矩阵 m 中第 i 行、第 i+1 列的值为 -1
           m[i, i-1] = -1  # 设置矩阵 m 中第 i 行、第 i-1 列的值为 -1
        m[0,1] = -1  # 设置矩阵 m 中第 0 行、第 1 列的值为 -1
        m[n-1, n-2] = -2  # 设置矩阵 m 中第 n-1 行、第 n-2 列的值为 -2
        return m  # 返回生成的 Cartan 矩阵 m

    def basis(self):
        """
        Returns the number of independent generators of C_n
        """

        n = self.n  # 获取实例变量 n 的值
        return n*(2*n + 1)  # 返回 C_n 的独立生成元数量，计算公式为 n * (2 * n + 1)

    def lie_algebra(self):
        """
        Returns the Lie algebra associated with C_n"
        """

        n = self.n  # 获取实例变量 n 的值
        return "sp(" + str(2*n) + ")"  # 返回与 C_n 相关联的李代数的字符串表示，形如 "sp(2*n)"

    def dynkin_diagram(self):
        n = self.n  # 获取实例变量 n 的值
        diag = "---".join("0" for i in range(1, n)) + "=<=0\n"  # 生成 Dynkin 图的字符串表示
        diag += "   ".join(str(i) for i in range(1, n+1))  # 添加图中的节点标签
        return diag  # 返回生成的 Dynkin 图字符串
```