# `D:\src\scipysrc\sympy\sympy\parsing\latex\_build_latex_antlr.py`

```
# 导入必要的模块
import os                  # 导入操作系统相关的功能
import subprocess          # 导入子进程管理模块，用于执行外部命令
import glob                # 导入文件名匹配模块

# 导入调试函数
from sympy.utilities.misc import debug

# 获取当前脚本所在目录
here = os.path.dirname(__file__)

# 拼接得到 LaTeX.g4 文件的绝对路径
grammar_file = os.path.abspath(os.path.join(here, "LaTeX.g4"))

# 设置 antlr 生成的输出目录
dir_latex_antlr = os.path.join(here, "_antlr")

# 生成文件的头部注释信息
header = '''\
# *** GENERATED BY `setup.py antlr`, DO NOT EDIT BY HAND ***
#
# Generated from ../LaTeX.g4, derived from latex2sympy
#     latex2sympy is licensed under the MIT license
#     https://github.com/augustt198/latex2sympy/blob/master/LICENSE.txt
#
# Generated with antlr4
#    antlr4 is licensed under the BSD-3-Clause License
#    https://github.com/antlr/antlr4/blob/master/LICENSE.txt
'''

# 检查 antlr4 版本的函数
def check_antlr_version():
    debug("Checking antlr4 version...")

    try:
        # 检查并显示 antlr4 的版本信息
        debug(subprocess.check_output(["antlr4"])
              .decode('utf-8').split("\n")[0])
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        # 处理找不到 antlr4 命令行工具的情况，并提供错误信息
        debug("The 'antlr4' command line tool is not installed, "
              "or not on your PATH.\n"
              "> Please refer to the README.md file for more information.")
        return False

# 构建解析器函数，生成 antlr 代码到指定的输出目录
def build_parser(output_dir=dir_latex_antlr):
    # 检查 antlr4 版本
    check_antlr_version()

    # 打印信息，更新 antlr 生成的代码到指定目录
    debug("Updating ANTLR-generated code in {}".format(output_dir))

    # 如果输出目录不存在，则创建
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # 在输出目录下创建 __init__.py 文件，并写入头部信息
    with open(os.path.join(output_dir, "__init__.py"), "w+") as fp:
        fp.write(header)

    # 设置 antlr4 命令的参数
    args = [
        "antlr4",
        grammar_file,
        "-o", output_dir,
        # 由于 latex2sympy 没有使用访问者和监听者，因此不生成这些文件
        "-no-visitor",
        "-no-listener",
    ]

    # 打印信息，运行代码生成命令
    debug("Running code generation...\n\t$ {}".format(" ".join(args)))
    subprocess.check_output(args, cwd=output_dir)

    # 打印信息，应用头部信息，删除不必要的文件并重命名
    debug("Applying headers, removing unnecessary files and renaming...")
    
    # 处理文件名大小写不敏感的文件系统。如果文件已经生成，它们将写入 latex*，但 LaTeX*.* 将不匹配它们。
    for path in (glob.glob(os.path.join(output_dir, "LaTeX*.*")) or
        glob.glob(os.path.join(output_dir, "latex*.*"))):
        
        # 删除以 .interp 或 .tokens 结尾的文件，因为它们不需要
        if not path.endswith(".py"):
            os.unlink(path)
            continue

        # 将路径转换为小写，确保与新路径一致
        new_path = os.path.join(output_dir, os.path.basename(path).lower())
        
        # 打开文件，读取所有行并写入新文件
        with open(path, 'r') as f:
            lines = [line.rstrip() + '\n' for line in f.readlines()]

        # 删除原文件
        os.unlink(path)

        # 将处理后的行写入新路径
        with open(new_path, "w") as out_file:
            offset = 0
            while lines[offset].startswith('#'):
                offset += 1
            out_file.write(header)
            out_file.writelines(lines[offset:])

        # 打印信息，显示处理后的文件路径
        debug("\t{}".format(new_path))

    return True

# 如果当前脚本作为主程序运行，则执行 build_parser 函数
if __name__ == "__main__":
    build_parser()
```