# `D:\src\scipysrc\sympy\sympy\utilities\tests\test_codegen_octave.py`

```
# 从 io 模块导入 StringIO 类，用于操作字符串的输入输出
from io import StringIO

# 从 sympy.core 模块导入 S, symbols, Eq, pi, Catalan, EulerGamma, Function 等符号和函数
from sympy.core import S, symbols, Eq, pi, Catalan, EulerGamma, Function

# 从 sympy.core.relational 模块导入 Equality 类，用于表示等式
from sympy.core.relational import Equality

# 从 sympy.functions.elementary.piecewise 模块导入 Piecewise 类，处理分段函数
from sympy.functions.elementary.piecewise import Piecewise

# 从 sympy.matrices 模块导入 Matrix, MatrixSymbol 类，用于处理矩阵相关操作
from sympy.matrices import Matrix, MatrixSymbol

# 从 sympy.utilities.codegen 模块导入 OctaveCodeGen, codegen, make_routine 等函数和类
from sympy.utilities.codegen import OctaveCodeGen, codegen, make_routine

# 从 sympy.testing.pytest 模块导入 raises, XFAIL 等测试相关函数和装饰器
from sympy.testing.pytest import raises
from sympy.testing.pytest import XFAIL

# 导入 sympy 库，用于获取 SymPy 的版本信息
import sympy

# 定义符号 x, y, z，用于测试中的符号表示
x, y, z = symbols('x,y,z')

# 定义一个测试函数 test_empty_m_code，用于测试空的 Octave 代码生成
def test_empty_m_code():
    # 创建 OctaveCodeGen 对象
    code_gen = OctaveCodeGen()
    # 创建一个 StringIO 对象，用于捕获输出
    output = StringIO()
    # 调用 OctaveCodeGen 的 dump_m 方法，生成空的 Octave 代码
    code_gen.dump_m([], output, "file", header=False, empty=False)
    # 获取生成的代码字符串
    source = output.getvalue()
    # 断言生成的代码字符串为空
    assert source == ""

# 定义一个测试函数 test_m_simple_code，用于测试简单的 Octave 代码生成
def test_m_simple_code():
    # 定义一个名为 test 的表达式和名称元组
    name_expr = ("test", (x + y)*z)
    # 调用 codegen 函数，生成 Octave 代码，不包含文件头部信息
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 断言生成的代码文件名为 test.m
    assert result[0] == "test.m"
    # 获取生成的代码内容
    source = result[1]
    # 定义预期的代码字符串
    expected = (
        "function out1 = test(x, y, z)\n"
        "  out1 = z.*(x + y);\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码一致
    assert source == expected

# 定义一个测试函数 test_m_simple_code_with_header，用于测试包含头部信息的 Octave 代码生成
def test_m_simple_code_with_header():
    # 定义一个名为 test 的表达式和名称元组
    name_expr = ("test", (x + y)*z)
    # 调用 codegen 函数，生成 Octave 代码，包含文件头部信息
    result, = codegen(name_expr, "Octave", header=True, empty=False)
    # 断言生成的代码文件名为 test.m
    assert result[0] == "test.m"
    # 获取生成的代码内容
    source = result[1]
    # 构建预期的代码字符串，包含 SymPy 版本信息
    expected = (
        "function out1 = test(x, y, z)\n"
        "  %TEST  Autogenerated by SymPy\n"
        "  %   Code generated with SymPy " + sympy.__version__ + "\n"
        "  %\n"
        "  %   See http://www.sympy.org/ for more information.\n"
        "  %\n"
        "  %   This file is part of 'project'\n"
        "  out1 = z.*(x + y);\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码一致
    assert source == expected

# 定义一个测试函数 test_m_simple_code_nameout，用于测试输出变量名的 Octave 代码生成
def test_m_simple_code_nameout():
    # 定义一个等式表达式
    expr = Equality(z, (x + y))
    # 定义一个名为 test 的表达式和名称元组
    name_expr = ("test", expr)
    # 调用 codegen 函数，生成 Octave 代码，不包含文件头部信息
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码内容
    source = result[1]
    # 定义预期的代码字符串
    expected = (
        "function z = test(x, y)\n"
        "  z = x + y;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码一致
    assert source == expected

# 定义一个测试函数 test_m_numbersymbol，用于测试数值符号的 Octave 代码生成
def test_m_numbersymbol():
    # 定义一个名为 test 的表达式和名称元组，包含 pi 和 Catalan 常数
    name_expr = ("test", pi**Catalan)
    # 调用 codegen 函数，生成 Octave 代码，不包含文件头部信息
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码内容
    source = result[1]
    # 构建预期的代码字符串，包含到 17 位有效数字的 Catalan 常数值
    expected = (
        "function out1 = test()\n"
        "  out1 = pi^" + str(Catalan.evalf(17)) + ";\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码一致
    assert source == expected

# 定义一个测试函数 test_m_numbersymbol_no_inline，用于测试禁用内联的 Octave 代码生成（预期测试失败）
@XFAIL
def test_m_numbersymbol_no_inline():
    # 定义一个名为 test 的表达式和名称元组，包含 pi 和 Catalan 常数
    name_expr = ("test", [pi**Catalan, EulerGamma])
    # 调用 codegen 函数，生成 Octave 代码，不包含文件头部信息，禁用内联
    result, = codegen(name_expr, "Octave", header=False,
                      empty=False, inline=False)
    # 获取生成的代码内容
    source = result[1]
    # 定义预期的代码字符串，包含常数值和注释
    expected = (
        "function [out1, out2] = test()\n"
        "  Catalan = 0.915965594177219;  % constant\n"
        "  EulerGamma = 0.5772156649015329;  % constant\n"
        "  out1 = pi^Catalan;\n"
        "  out2 = EulerGamma;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码一致
    assert source == expected

# 定义一个测试函数 test_m_code_argument_order，用于测试 Octave 代码生成的参数顺序
def test_m_code_argument_order():
    # 定义一个简单的表达式
    expr = x + y
    # 使用 make_routine 函数生成名为 test 的 Octave 代码例程，指定参数顺序
    routine = make_routine("test", expr, argument_sequence=[z, x, y], language="octave")
    # 创建 OctaveCodeGen 对象
    code_gen = OctaveCodeGen()
    # 创建一个 StringIO 对象，用于捕获输出
    output = StringIO()
    # 使用 code_gen 对象调用 dump_m 方法，生成指定例程（routine）的代码到 output 中，不包含头部和空行
    code_gen.dump_m([routine], output, "test", header=False, empty=False)
    # 从 output 中获取生成的代码字符串
    source = output.getvalue()
    # 期望的生成代码字符串
    expected = (
        "function out1 = test(z, x, y)\n"
        "  out1 = x + y;\n"
        "end\n"
    )
    # 断言生成的代码与期望的代码相同
    assert source == expected
def test_multiple_results_m():
    # 输出顺序与输入顺序相同
    expr1 = (x + y)*z  # 定义第一个表达式
    expr2 = (x - y)*z  # 定义第二个表达式
    name_expr = ("test", [expr1, expr2])  # 定义名称和表达式列表
    result, = codegen(name_expr, "Octave", header=False, empty=False)  # 生成代码并获取结果
    source = result[1]  # 获取生成的代码
    expected = (
        "function [out1, out2] = test(x, y, z)\n"
        "  out1 = z.*(x + y);\n"
        "  out2 = z.*(x - y);\n"
        "end\n"
    )
    assert source == expected  # 断言生成的代码与期望的代码一致


def test_results_named_unordered():
    # 输出顺序基于 name_expr 定义的顺序
    A, B, C = symbols('A,B,C')  # 定义符号变量
    expr1 = Equality(C, (x + y)*z)  # 定义第一个表达式
    expr2 = Equality(A, (x - y)*z)  # 定义第二个表达式
    expr3 = Equality(B, 2*x)  # 定义第三个表达式
    name_expr = ("test", [expr1, expr2, expr3])  # 定义名称和表达式列表
    result, = codegen(name_expr, "Octave", header=False, empty=False)  # 生成代码并获取结果
    source = result[1]  # 获取生成的代码
    expected = (
        "function [C, A, B] = test(x, y, z)\n"
        "  C = z.*(x + y);\n"
        "  A = z.*(x - y);\n"
        "  B = 2*x;\n"
        "end\n"
    )
    assert source == expected  # 断言生成的代码与期望的代码一致


def test_results_named_ordered():
    A, B, C = symbols('A,B,C')  # 定义符号变量
    expr1 = Equality(C, (x + y)*z)  # 定义第一个表达式
    expr2 = Equality(A, (x - y)*z)  # 定义第二个表达式
    expr3 = Equality(B, 2*x)  # 定义第三个表达式
    name_expr = ("test", [expr1, expr2, expr3])  # 定义名称和表达式列表
    result = codegen(name_expr, "Octave", header=False, empty=False,
                     argument_sequence=(x, z, y))  # 指定参数顺序生成代码
    assert result[0][0] == "test.m"  # 断言文件名为 "test.m"
    source = result[0][1]  # 获取生成的代码
    expected = (
        "function [C, A, B] = test(x, z, y)\n"
        "  C = z.*(x + y);\n"
        "  A = z.*(x - y);\n"
        "  B = 2*x;\n"
        "end\n"
    )
    assert source == expected  # 断言生成的代码与期望的代码一致


def test_complicated_m_codegen():
    from sympy.functions.elementary.trigonometric import (cos, sin, tan)  # 导入三角函数
    name_expr = ("testlong",
            [ ((sin(x) + cos(y) + tan(z))**3).expand(),  # 定义复杂表达式1
            cos(cos(cos(cos(cos(cos(cos(cos(x + y + z))))))))  # 定义复杂表达式2
    ])
    result = codegen(name_expr, "Octave", header=False, empty=False)  # 生成代码并获取结果
    assert result[0][0] == "testlong.m"  # 断言文件名为 "testlong.m"
    source = result[0][1]  # 获取生成的代码
    expected = (
        "function [out1, out2] = testlong(x, y, z)\n"
        "  out1 = sin(x).^3 + 3*sin(x).^2.*cos(y) + 3*sin(x).^2.*tan(z)"
        " + 3*sin(x).*cos(y).^2 + 6*sin(x).*cos(y).*tan(z) + 3*sin(x).*tan(z).^2"
        " + cos(y).^3 + 3*cos(y).^2.*tan(z) + 3*cos(y).*tan(z).^2 + tan(z).^3;\n"
        "  out2 = cos(cos(cos(cos(cos(cos(cos(cos(x + y + z))))))));\n"
        "end\n"
    )
    assert source == expected  # 断言生成的代码与期望的代码一致


def test_m_output_arg_mixed_unordered():
    # 命名输出按字母顺序，未命名输出按给定顺序出现
    from sympy.functions.elementary.trigonometric import (cos, sin)  # 导入三角函数
    a = symbols("a")  # 定义符号变量
    name_expr = ("foo", [cos(2*x), Equality(y, sin(x)), cos(x), Equality(a, sin(2*x))])  # 定义名称和表达式列表
    result, = codegen(name_expr, "Octave", header=False, empty=False)  # 生成代码并获取结果
    assert result[0] == "foo.m"  # 断言文件名为 "foo.m"
    source = result[1];  # 获取生成的代码
    # 定义一个期望的字符串，包含了一个 MATLAB 函数的多行定义
    expected = (
        'function [out1, y, out3, a] = foo(x)\n'
        '  out1 = cos(2*x);\n'
        '  y = sin(x);\n'
        '  out3 = cos(x);\n'
        '  a = sin(2*x);\n'
        'end\n'
    )
    
    # 使用断言来检查变量 source 是否与预期的字符串 expected 相等
    assert source == expected
# 定义测试函数，用于生成一个复杂的分段函数的 Octave 代码
def test_m_piecewise_():
    # 创建 Piecewise 对象 pw，表示一个分段函数，使用 evaluate=False 禁止求值
    pw = Piecewise((0, x < -1), (x**2, x <= 1), (-x+2, x > 1), (1, True), evaluate=False)
    # 定义将要生成的函数的名称和表达式
    name_expr = ("pwtest", pw)
    # 调用 codegen 函数生成 Octave 代码，不包含头部信息和空行
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的 Octave 代码
    source = result[1]
    # 期望的 Octave 代码
    expected = (
        "function out1 = pwtest(x)\n"
        "  out1 = ((x < -1).*(0) + (~(x < -1)).*( ...\n"
        "  (x <= 1).*(x.^2) + (~(x <= 1)).*( ...\n"
        "  (x > 1).*(2 - x) + (~(x > 1)).*(1))));\n"
        "end\n"
    )
    # 断言生成的 Octave 代码与期望的一致
    assert source == expected


@XFAIL
def test_m_piecewise_no_inline():
    # FIXME: 需要将 inline=False 传递给 OctaveCodePrinter，但当前无法实现
    # 创建 Piecewise 对象 pw，表示一个分段函数，不再使用 evaluate=False
    pw = Piecewise((0, x < -1), (x**2, x <= 1), (-x+2, x > 1), (1, True))
    # 定义将要生成的函数的名称和表达式
    name_expr = ("pwtest", pw)
    # 调用 codegen 函数生成 Octave 代码，不包含头部信息和空行，且不内联
    result, = codegen(name_expr, "Octave", header=False, empty=False,
                      inline=False)
    # 获取生成的 Octave 代码
    source = result[1]
    # 期望的 Octave 代码
    expected = (
        "function out1 = pwtest(x)\n"
        "  if (x < -1)\n"
        "    out1 = 0;\n"
        "  elseif (x <= 1)\n"
        "    out1 = x.^2;\n"
        "  elseif (x > 1)\n"
        "    out1 = -x + 2;\n"
        "  else\n"
        "    out1 = 1;\n"
        "  end\n"
        "end\n"
    )
    # 断言生成的 Octave 代码与期望的一致
    assert source == expected


# 测试生成多个函数在同一个文件中的 Octave 代码
def test_m_multifcns_per_file():
    # 定义多个函数名称和表达式的列表
    name_expr = [("foo", [2*x, 3*y]), ("bar", [y**2, 4*y])]
    # 调用 codegen 函数生成 Octave 代码，不包含头部信息和空行
    result = codegen(name_expr, "Octave", header=False, empty=False)
    # 断言第一个文件的文件名为 "foo.m"
    assert result[0][0] == "foo.m"
    # 获取第一个文件的生成的 Octave 代码
    source = result[0][1];
    # 期望的 Octave 代码
    expected = (
        "function [out1, out2] = foo(x, y)\n"
        "  out1 = 2*x;\n"
        "  out2 = 3*y;\n"
        "end\n"
        "function [out1, out2] = bar(y)\n"
        "  out1 = y.^2;\n"
        "  out2 = 4*y;\n"
        "end\n"
    )
    # 断言生成的 Octave 代码与期望的一致
    assert source == expected


# 测试生成多个函数在同一个文件中的 Octave 代码，并包含文件头部信息
def test_m_multifcns_per_file_w_header():
    # 定义多个函数名称和表达式的列表
    name_expr = [("foo", [2*x, 3*y]), ("bar", [y**2, 4*y])]
    # 调用 codegen 函数生成 Octave 代码，包含头部信息和不包含空行
    result = codegen(name_expr, "Octave", header=True, empty=False)
    # 断言第一个文件的文件名为 "foo.m"
    assert result[0][0] == "foo.m"
    # 获取第一个文件的生成的 Octave 代码
    source = result[0][1];
    # 期望的 Octave 代码
    expected = (
        "function [out1, out2] = foo(x, y)\n"
        "  %FOO  Autogenerated by SymPy\n"
        "  %   Code generated with SymPy " + sympy.__version__ + "\n"
        "  %\n"
        "  %   See http://www.sympy.org/ for more information.\n"
        "  %\n"
        "  %   This file is part of 'project'\n"
        "  out1 = 2*x;\n"
        "  out2 = 3*y;\n"
        "end\n"
        "function [out1, out2] = bar(y)\n"
        "  out1 = y.^2;\n"
        "  out2 = 4*y;\n"
        "end\n"
    )
    # 断言生成的 Octave 代码与期望的一致
    assert source == expected


# 测试当函数名称与指定前缀不匹配时，引发 ValueError
def test_m_filename_match_first_fcn():
    # 定义多个函数名称和表达式的列表
    name_expr = [("foo", [2*x, 3*y]), ("bar", [y**2, 4*y])]
    # 断言调用 codegen 函数时会引发 ValueError
    raises(ValueError, lambda: codegen(name_expr,
                        "Octave", prefix="bar", header=False, empty=False))


# 测试生成矩阵命名的 Octave 代码
def test_m_matrix_named():
    # 创建一个矩阵表达式 e2
    e2 = Matrix([[x, 2*y, pi*z]])
    # 定义名称和表达式的元组
    name_expr = ("test", Equality(MatrixSymbol('myout1', 1, 3), e2))
    # 调用 codegen 函数生成 Octave 代码，不包含头部信息和空行
    result = codegen(name_expr, "Octave", header=False, empty=False)
    # 断言生成的文件名为 "test.m"
    assert result[0][0] == "test.m"
    # 获取生成的 Octave 代码
    source = result[0][1]
    # （期望的 Octave 代码在这里不提供，但应与具体实现相关）
    # 预期的字符串，表示一个 MATLAB 函数的定义
    expected = (
        "function myout1 = test(x, y, z)\n"
        "  myout1 = [x 2*y pi*z];\n"
        "end\n"
    )
    # 使用断言检查源代码是否与预期的字符串完全一致
    assert source == expected
# 定义一个测试函数，用于生成 Octave/MATLAB 代码，实现矩阵输出和赋值
def test_m_matrix_named_matsym():
    # 创建一个名为 myout1 的 MatrixSymbol，表示一个1行3列的矩阵
    myout1 = MatrixSymbol('myout1', 1, 3)
    # 定义一个矩阵 e2，包含变量 x, y, z 的表达式
    e2 = Matrix([[x, 2*y, pi*z]])
    # 构造一个名称表达式，表示输出矩阵 myout1 应等于 e2
    name_expr = ("test", Equality(myout1, e2, evaluate=False))
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function myout1 = test(x, y, z)\n"
        "  myout1 = [x 2*y pi*z];\n"
        "end\n"
    )
    # 断言生成的代码与预期代码相同
    assert source == expected


# 定义另一个测试函数，生成 Octave/MATLAB 代码，实现矩阵输出和赋值，自动命名输出变量
def test_m_matrix_output_autoname():
    # 定义一个矩阵表达式 expr，包含变量 x, y 的表达式
    expr = Matrix([[x, x+y, 3]])
    # 构造一个名称表达式，表示输出矩阵 out1 应等于 expr
    name_expr = ("test", expr)
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function out1 = test(x, y)\n"
        "  out1 = [x x + y 3];\n"
        "end\n"
    )
    # 断言生成的代码与预期代码相同
    assert source == expected


# 定义另一个测试函数，生成 Octave/MATLAB 代码，实现多个矩阵输出和赋值，自动命名输出变量
def test_m_matrix_output_autoname_2():
    # 定义表达式 e1, e2, e3, e4 分别包含变量 x, y, z 的表达式
    e1 = (x + y)
    e2 = Matrix([[2*x, 2*y, 2*z]])
    e3 = Matrix([[x], [y], [z]])
    e4 = Matrix([[x, y], [z, 16]])
    # 构造一个名称表达式，表示输出变量 out1, out2, out3, out4 应分别等于 e1, e2, e3, e4
    name_expr = ("test", (e1, e2, e3, e4))
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function [out1, out2, out3, out4] = test(x, y, z)\n"
        "  out1 = x + y;\n"
        "  out2 = [2*x 2*y 2*z];\n"
        "  out3 = [x; y; z];\n"
        "  out4 = [x y; z 16];\n"
        "end\n"
    )
    # 断言生成的代码与预期代码相同
    assert source == expected


# 定义另一个测试函数，生成 Octave/MATLAB 代码，实现多个表达式输出和赋值
def test_m_results_matrix_named_ordered():
    # 定义符号变量 B, C
    B, C = symbols('B,C')
    # 创建一个名为 A 的 MatrixSymbol，表示一个1行3列的矩阵
    A = MatrixSymbol('A', 1, 3)
    # 定义表达式 expr1, expr2, expr3 包含变量 x, y, z 的表达式
    expr1 = Equality(C, (x + y)*z)
    expr2 = Equality(A, Matrix([[1, 2, x]]))
    expr3 = Equality(B, 2*x)
    # 构造一个名称表达式，表示输出变量 C, A, B 应分别等于 expr1, expr2, expr3
    name_expr = ("test", [expr1, expr2, expr3])
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出，指定参数顺序为 (x, z, y)
    result, = codegen(name_expr, "Octave", header=False, empty=False,
                     argument_sequence=(x, z, y))
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function [C, A, B] = test(x, z, y)\n"
        "  C = z.*(x + y);\n"
        "  A = [1 2 x];\n"
        "  B = 2*x;\n"
        "end\n"
    )
    # 断言生成的代码与预期代码相同
    assert source == expected


# 定义另一个测试函数，生成 Octave/MATLAB 代码，实现矩阵切片操作
def test_m_matrixsymbol_slice():
    # 创建名为 A, B, C, D 的 MatrixSymbol，分别表示不同大小的矩阵
    A = MatrixSymbol('A', 2, 3)
    B = MatrixSymbol('B', 1, 3)
    C = MatrixSymbol('C', 1, 3)
    D = MatrixSymbol('D', 2, 1)
    # 构造一个名称表达式，表示输出变量 B, C, D 应分别等于 A 的切片操作结果
    name_expr = ("test", [Equality(B, A[0, :]),
                          Equality(C, A[1, :]),
                          Equality(D, A[:, 2])])
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function [B, C, D] = test(A)\n"
        "  B = A(1, :);\n"
        "  C = A(2, :);\n"
        "  D = A(:, 3);\n"
        "end\n"
    )
    # 断言生成的代码与预期代码相同
    assert source == expected


# 定义另一个测试函数，生成 Octave/MATLAB 代码，实现矩阵切片操作
def test_m_matrixsymbol_slice2():
    # 创建名为 A, B, C 的 MatrixSymbol，分别表示不同大小的矩阵
    A = MatrixSymbol('A', 3, 4)
    B = MatrixSymbol('B', 2, 2)
    C = MatrixSymbol('C', 2, 2)
    # 构造一个名称表达式，表示输出变量 B, C 应分别等于 A 的切片操作结果
    name_expr = ("test", [Equality(B, A[0:2, 0:2]),
                          Equality(C, A[0:2, 1:3])])
    # 调用 codegen 函数生成 Octave/MATLAB 代码，禁用头部信息和空输出
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 获取生成的代码字符串
    source = result[1]
    # 预期生成的 Octave/MATLAB 代码字符串
    expected = (
        "function [B,
    # 使用断言检查变量 source 是否等于变量 expected 的值是否相等
    assert source == expected
def test_m_tensor_loops_multiple_contractions():
    # 导入所需的符号和张量操作模块
    from sympy.tensor import IndexedBase, Idx
    from sympy.core.symbol import symbols
    
    # 定义整数符号变量 n, m, o, p
    n, m, o, p = symbols('n m o p', integer=True)
    
    # 创建 IndexedBase 对象 A, B, y 用于表示张量
    A = IndexedBase('A')
    B = IndexedBase('B')
    y = IndexedBase('y')
    
    # 定义索引变量 i, j, k, l 用于循环索引
    i = Idx('i', m)
    j = Idx('j', n)
    k = Idx('k', o)
    l = Idx('l', p)
    
    # 调用 codegen 函数生成 Octave 语言的代码，第二个返回值是代码本体，非空
    result, = codegen(('tensorthing', Eq(y[i], B[j, k, l]*A[i, j, k, l])),
                      "Octave", header=False, empty=False)
    # 提取生成的 Octave 代码
    source = result[1]

    # 预期的 Octave 代码模板，其中 %(rhs)s 会被后续代码替换
    expected = (
        'function y = tensorthing(A, B, m, n, o, p)\n'
        '  for i = 1:m\n'
        '    y(i) = 0;\n'
        '  end\n'
        '  for i = 1:m\n'
        '    for j = 1:n\n'
        '      for k = 1:o\n'
        '        for l = 1:p\n'
        '          y(i) = %(rhs)s + y(i);\n'
        '        end\n'
        '      end\n'
        '    end\n'
        '  end\n'
        'end\n'
    )
    
    # 断言生成的代码与预期的代码匹配，%(rhs)s 被替换成正确的张量表达式
    assert (source == expected % {'rhs': 'B(j, k, l).*A(i, j, k, l)'} or
            source == expected % {'rhs': 'A(i, j, k, l).*B(j, k, l)'})
    # 定义预期的 MATLAB 函数代码，计算张量乘积并累加到输出向量 y 中
    expected = (
        'function y = tensorthing(A, B, m, n, o, p)\n'  # 定义函数 tensorthing，接受 A, B 两个张量和维度参数 m, n, o, p
        '  for i = 1:m\n'                             # 循环遍历 i，范围是 1 到 m
        '    y(i) = 0;\n'                              # 初始化输出向量 y(i) 为 0
        '  end\n'                                      # 结束循环
        '  for i = 1:m\n'                              # 外层循环，遍历 i，范围是 1 到 m
        '    for j = 1:n\n'                            # 内层循环，遍历 j，范围是 1 到 n
        '      for k = 1:o\n'                          # 更深的内层循环，遍历 k，范围是 1 到 o
        '        for l = 1:p\n'                        # 最深的内层循环，遍历 l，范围是 1 到 p
        '          y(i) = A(i, j, k, l).*B(j, k, l) + y(i);\n'  # 计算张量乘积 A(i, j, k, l).*B(j, k, l)，并累加到 y(i)
        '        end\n'                                # 结束最深层循环
        '      end\n'                                  # 结束更深层循环
        '    end\n'                                    # 结束内层循环
        '  end\n'                                      # 结束外层循环
        'end\n'                                        # 结束函数定义
    )
    # 使用断言检查源代码是否与预期的 MATLAB 函数代码相符合
    assert source == expected
# 定义一个测试函数，用于测试在 Octave 中生成带输入输出参数的函数
def test_m_InOutArgument():
    # 创建一个表达式，表示 x 等于 x 的平方
    expr = Equality(x, x**2)
    # 将函数名和表达式组成元组
    name_expr = ("mysqr", expr)
    # 调用 codegen 函数生成 Octave 代码，返回结果为元组
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 取结果元组中的第二个元素，即生成的 Octave 代码
    source = result[1]
    # 预期的生成的 Octave 代码
    expected = (
        "function x = mysqr(x)\n"
        "  x = x.^2;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected


# 定义一个测试函数，测试在 Octave 中生成带顺序参数的函数
def test_m_InOutArgument_order():
    # 创建一个表达式，表示 x 等于 x 的平方加上 y
    expr = Equality(x, x**2 + y)
    # 将函数名和表达式组成元组
    name_expr = ("test", expr)
    # 调用 codegen 函数生成 Octave 代码，可以指定参数的顺序为 (x, y)
    result, = codegen(name_expr, "Octave", header=False,
                      empty=False, argument_sequence=(x,y))
    # 取结果元组中的第二个元素，即生成的 Octave 代码
    source = result[1]
    # 预期的生成的 Octave 代码
    expected = (
        "function x = test(x, y)\n"
        "  x = x.^2 + y;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected
    
    # 确保生成的代码使用 (x, y) 而不是 (y, x)
    expr = Equality(x, x**2 + y)
    name_expr = ("test", expr)
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    source = result[1]
    expected = (
        "function x = test(x, y)\n"
        "  x = x.^2 + y;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected


# 定义一个测试函数，测试在 Octave 中生成不支持的代码
def test_m_not_supported():
    # 创建一个函数对象 f(x)，并对其求导数
    f = Function('f')
    # 构建一个元组，包含表达式和一个特殊的符号 ComplexInfinity
    name_expr = ("test", [f(x).diff(x), S.ComplexInfinity])
    # 调用 codegen 函数生成 Octave 代码，返回结果为元组
    result, = codegen(name_expr, "Octave", header=False, empty=False)
    # 取结果元组中的第二个元素，即生成的 Octave 代码
    source = result[1]
    # 预期的生成的 Octave 代码
    expected = (
        "function [out1, out2] = test(x)\n"
        "  % unsupported: Derivative(f(x), x)\n"
        "  % unsupported: zoo\n"
        "  out1 = Derivative(f(x), x);\n"
        "  out2 = zoo;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected


# 定义一个测试函数，测试在 Octave 中生成使用全局变量的代码
def test_global_vars_octave():
    # 定义符号变量 x, y, z, t
    x, y, z, t = symbols("x y z t")
    # 生成一个函数 f(x) = x * y 的 Octave 代码，其中 y 是全局变量
    result = codegen(('f', x*y), "Octave", header=False, empty=False,
                     global_vars=(y,))
    # 取结果中第一个元组的第二个元素，即生成的 Octave 代码
    source = result[0][1]
    # 预期的生成的 Octave 代码
    expected = (
        "function out1 = f(x)\n"
        "  global y\n"
        "  out1 = x.*y;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected

    # 生成一个函数 f(x, y) = x * y + z 的 Octave 代码，指定参数顺序为 (x, y)，z 和 t 是全局变量
    result = codegen(('f', x*y+z), "Octave", header=False, empty=False,
                     argument_sequence=(x, y), global_vars=(z, t))
    # 取结果中第一个元组的第二个元素，即生成的 Octave 代码
    source = result[0][1]
    # 预期的生成的 Octave 代码
    expected = (
        "function out1 = f(x, y)\n"
        "  global t z\n"
        "  out1 = x.*y + z;\n"
        "end\n"
    )
    # 断言生成的代码与预期的代码相等
    assert source == expected
```