# `D:\src\scipysrc\sympy\sympy\parsing\latex\lark\latex_parser.py`

```
# 导入必要的库
import os
import logging
import re

# 导入外部模块和函数
from sympy.external import import_module
from sympy.parsing.latex.lark.transformer import TransformToSymPyExpr

# 导入 Lark 解析器
_lark = import_module("lark")

# 定义 LarkLaTeXParser 类，用于将输入的 LaTeX 字符串转换为 SymPy 表达式
class LarkLaTeXParser:
    r"""Class for converting input `\mathrm{\LaTeX}` strings into SymPy Expressions.
    It holds all the necessary internal data for doing so, and exposes hooks for
    customizing its behavior.

    Parameters
    ==========

    print_debug_output : bool, optional
        If set to ``True``, prints debug output to the logger. Defaults to ``False``.

    transform : bool, optional
        If set to ``True``, the class runs the Transformer class on the parse tree
        generated by running ``Lark.parse`` on the input string. Defaults to ``True``.
        Setting it to ``False`` can help with debugging the `\mathrm{\LaTeX}` grammar.

    grammar_file : str, optional
        The path to the grammar file that the parser should use. If set to ``None``,
        it uses the default grammar, which is in ``grammar/latex.lark``, relative to
        the ``sympy/parsing/latex/lark/`` directory.

    transformer : str, optional
        The name of the Transformer class to use. If set to ``None``, it uses the
        default transformer class, which is :py:func:`TransformToSymPyExpr`.
    """

    # 初始化方法，设置解析器和相关参数
    def __init__(self, print_debug_output=False, transform=True, grammar_file=None, transformer=None):
        # 设置 LaTeX 语法文件的路径
        grammar_dir_path = os.path.join(os.path.dirname(__file__), "grammar/")

        # 根据提供的语法文件路径或默认路径，读取 LaTeX 语法文件内容
        if grammar_file is None:
            with open(os.path.join(grammar_dir_path, "latex.lark"), encoding="utf-8") as f:
                latex_grammar = f.read()
        else:
            with open(grammar_file, encoding="utf-8") as f:
                latex_grammar = f.read()

        # 创建 Lark 解析器对象，并设置各种解析参数
        self.parser = _lark.Lark(
            latex_grammar,
            source_path=grammar_dir_path,
            parser="earley",
            start="latex_string",
            lexer="auto",
            ambiguity="explicit",
            propagate_positions=False,
            maybe_placeholders=False,
            keep_all_tokens=True)

        # 设置是否输出调试信息的标志
        self.print_debug_output = print_debug_output
        # 设置是否进行转换的标志
        self.transform_expr = transform

        # 根据提供的转换器类名或默认类名，创建转换器对象
        if transformer is None:
            self.transformer = TransformToSymPyExpr()
        else:
            self.transformer = transformer()
    # 解析器方法，用于解析输入字符串 `s`
    def doparse(self, s: str):
        # 如果需要打印调试输出，则设置日志级别为 DEBUG
        if self.print_debug_output:
            _lark.logger.setLevel(logging.DEBUG)

        # 使用解析器对字符串 `s` 进行解析，得到解析树 `parse_tree`
        parse_tree = self.parser.parse(s)

        # 如果不需要转换表达式，提前退出并返回解析树
        if not self.transform_expr:
            _lark.logger.debug("expression = %s", s)
            _lark.logger.debug(parse_tree)
            _lark.logger.debug(parse_tree.pretty())
            return parse_tree

        # 如果需要打印调试输出，则记录表达式 `s` 和解析树 `parse_tree` 的详细信息
        if self.print_debug_output:
            _lark.logger.debug("expression = %s", s)
            _lark.logger.debug(parse_tree.pretty())

        # 使用转换器对解析树 `parse_tree` 进行转换，得到 SymPy 表达式 `sympy_expression`
        sympy_expression = self.transformer.transform(parse_tree)

        # 如果需要打印调试输出，则记录 SymPy 表达式 `sympy_expression` 的信息
        if self.print_debug_output:
            _lark.logger.debug("SymPy expression = %s", sympy_expression)

        # 返回转换后的 SymPy 表达式 `sympy_expression`
        return sympy_expression
# 如果 _lark 不是 None，则创建一个 LarkLaTeXParser 的实例 _lark_latex_parser
if _lark is not None:
    _lark_latex_parser = LarkLaTeXParser()

# 解析 LaTeX 输入字符串 s，使用 Lark 进行解析
def parse_latex_lark(s: str):
    """
    Experimental LaTeX parser using Lark.

    This function is still under development and its API may change with the
    next releases of SymPy.
    """
    # 如果 _lark 是 None，则抛出 ImportError
    if _lark is None:
        raise ImportError("Lark is probably not installed")
    # 调用 _lark_latex_parser 的 doparse 方法进行解析，并返回结果
    return _lark_latex_parser.doparse(s)


# 用于递归地美化打印 Lark 解析树的函数
def _pretty_print_lark_trees(tree, indent=0, show_expr=True):
    # 如果 tree 是一个 _lark.Token 对象，则返回其值
    if isinstance(tree, _lark.Token):
        return tree.value

    # 获取树的数据表示
    data = str(tree.data)

    # 检查是否为表达式节点
    is_expr = data.startswith("expression")

    # 如果是表达式节点，则简化其表示
    if is_expr:
        data = re.sub(r"^expression", "E", data)

    # 检查是否为模糊节点
    is_ambig = (data == "_ambig")

    # 根据节点类型决定缩进量
    if is_ambig:
        new_indent = indent + 2
    else:
        new_indent = indent

    # 初始化输出字符串
    output = ""
    show_node = not is_expr or show_expr

    # 如果需要显示节点信息，则添加节点名称
    if show_node:
        output += str(data) + "("

    # 根据节点类型递归处理子节点
    if is_ambig:
        output += "\n" + "\n".join([" " * new_indent + _pretty_print_lark_trees(i, new_indent, show_expr) for i in tree.children])
    else:
        output += ",".join([_pretty_print_lark_trees(i, new_indent, show_expr) for i in tree.children])

    # 如果需要显示节点信息，则添加节点结束符号
    if show_node:
        output += ")"

    # 返回美化后的输出结果
    return output
```