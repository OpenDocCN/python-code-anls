# `D:\src\scipysrc\sympy\sympy\combinatorics\perm_groups.py`

```
# 导入数学模块中的阶乘函数，并将其重命名为 _factorial
from math import factorial as _factorial, log, prod
# 导入 itertools 模块中的链式迭代器 chain 和笛卡尔积生成器 product
from itertools import chain, product

# 导入 sympy 中排列组合相关的类和函数
from sympy.combinatorics import Permutation
from sympy.combinatorics.permutations import (_af_commutes_with, _af_invert,
    _af_rmul, _af_rmuln, _af_pow, Cycle)
# 导入 sympy 中排列组合相关的辅助函数和工具函数
from sympy.combinatorics.util import (_check_cycles_alt_sym,
    _distribute_gens_by_base, _orbits_transversals_from_bsgs,
    _handle_precomputed_bsgs, _base_ordering, _strong_gens_from_distr,
    _strip, _strip_af)
# 导入 sympy 中核心模块的基础类 Basic
from sympy.core import Basic
# 导入 sympy 中核心模块的随机数生成函数和随机选择函数
from sympy.core.random import _randrange, randrange, choice
# 导入 sympy 中核心模块的符号类 Symbol
from sympy.core.symbol import Symbol
# 导入 sympy 中核心模块的符号化函数 _sympify
from sympy.core.sympify import _sympify
# 导入 sympy 中组合数学中的阶乘函数 factorial
from sympy.functions.combinatorial.factorials import factorial
# 导入 sympy 中数论相关的质因数分解和筛选素数函数
from sympy.ntheory import primefactors, sieve
# 导入 sympy 中数论中的因数分解函数和因数重数函数
from sympy.ntheory.factor_ import (factorint, multiplicity)
# 导入 sympy 中数论中的素数检测函数 isprime
from sympy.ntheory.primetest import isprime
# 导入 sympy 中迭代工具函数，用于检查序列中是否具有不同的元素、是否为序列、唯一化处理等
from sympy.utilities.iterables import has_variety, is_sequence, uniq

# 将 Permutation 类中的 rmul_with_af 方法赋值给变量 rmul
rmul = Permutation.rmul_with_af
# 将 Permutation 类中的 _af_new 方法赋值给变量 _af_new
_af_new = Permutation._af_new

# 定义一个名为 PermutationGroup 的类，继承自 Basic 类
class PermutationGroup(Basic):
    # PermutationGroup 类的文档字符串，描述了排列群的定义和用法
    r"""The class defining a Permutation group.

    Explanation
    ===========

    ``PermutationGroup([p1, p2, ..., pn])`` returns the permutation group
    generated by the list of permutations. This group can be supplied
    to Polyhedron if one desires to decorate the elements to which the
    indices of the permutation refer.

    Examples
    ========

    >>> from sympy.combinatorics import Permutation, PermutationGroup
    >>> from sympy.combinatorics import Polyhedron

    The permutations corresponding to motion of the front, right and
    bottom face of a $2 \times 2$ Rubik's cube are defined:

    >>> F = Permutation(2, 19, 21, 8)(3, 17, 20, 10)(4, 6, 7, 5)
    >>> R = Permutation(1, 5, 21, 14)(3, 7, 23, 12)(8, 10, 11, 9)
    >>> D = Permutation(6, 18, 14, 10)(7, 19, 15, 11)(20, 22, 23, 21)

    These are passed as permutations to PermutationGroup:

    >>> G = PermutationGroup(F, R, D)
    >>> G.order()
    3674160

    The group can be supplied to a Polyhedron in order to track the
    objects being moved. An example involving the $2 \times 2$ Rubik's cube is
    given there, but here is a simple demonstration:

    >>> a = Permutation(2, 1)
    >>> b = Permutation(1, 0)
    >>> G = PermutationGroup(a, b)
    >>> P = Polyhedron(list('ABC'), pgroup=G)
    >>> P.corners
    (A, B, C)
    >>> P.rotate(0) # apply permutation 0
    >>> P.corners
    (A, C, B)
    >>> P.reset()
    >>> P.corners
    (A, B, C)

    Or one can make a permutation as a product of selected permutations
    and apply them to an iterable directly:

    >>> P10 = G.make_perm([0, 1])
    >>> P10('ABC')
    ['C', 'A', 'B']

    See Also
    ========

    sympy.combinatorics.polyhedron.Polyhedron,
    sympy.combinatorics.permutations.Permutation

    References
    ==========

    .. [1] Holt, D., Eick, B., O'Brien, E.
           "Handbook of Computational Group Theory"

    .. [2] Seress, A.
           "Permutation Group Algorithms"

    """
    # 设置变量 `is_group` 为 True，表示这个模块处理的对象是群（group）的结构
    is_group = True
    
    # 定义一个特殊方法 `__new__`，用于创建新的对象实例
    def __new__(cls, *args, dups=True, **kwargs):
        """The default constructor. Accepts Cycle and Permutation forms.
        Removes duplicates unless `dups` keyword is `False`.
        """
        # 如果没有传入参数，则默认创建一个置换（Permutation）对象
        if not args:
            args = [Permutation()]
        else:
            # 如果传入的参数是序列而不是单独的对象，则转换为列表
            args = list(args[0] if is_sequence(args[0]) else args)
            # 如果参数列表为空，则也创建一个置换对象作为默认值
            if not args:
                args = [Permutation()]
    
        # 如果参数列表中存在循环（Cycle）对象，则将其转换为置换对象
        if any(isinstance(a, Cycle) for a in args):
            args = [Permutation(a) for a in args]
    
        # 如果参数中的对象具有不同的大小，则统一它们的大小
        if has_variety(a.size for a in args):
            degree = kwargs.pop('degree', None)
            if degree is None:
                degree = max(a.size for a in args)
            for i in range(len(args)):
                if args[i].size != degree:
                    args[i] = Permutation(args[i], size=degree)
    
        # 如果 `dups` 为 True，则移除重复的对象
        if dups:
            args = list(uniq([_af_new(list(a)) for a in args]))
    
        # 如果参数列表中超过一个对象，则只保留非恒等的对象
        if len(args) > 1:
            args = [g for g in args if not g.is_identity]
    
        # 调用父类 `Basic` 的构造方法创建新的实例
        return Basic.__new__(cls, *args, **kwargs)
    # 初始化方法，接受任意位置参数和关键字参数
    def __init__(self, *args, **kwargs):
        # 将位置参数转换为生成器列表并赋值给实例变量 `_generators`
        self._generators = list(self.args)
        # 初始化顺序属性为 None
        self._order = None
        # 初始化元素列表为空
        self._elements = []
        # 初始化中心属性为 None
        self._center = None
        # 初始化是否阿贝尔属性为 None
        self._is_abelian = None
        # 初始化是否传递性属性为 None
        self._is_transitive = None
        # 初始化是否对称属性为 None
        self._is_sym = None
        # 初始化是否交错属性为 None
        self._is_alt = None
        # 初始化是否原始属性为 None
        self._is_primitive = None
        # 初始化是否幂零属性为 None
        self._is_nilpotent = None
        # 初始化是否可解属性为 None
        self._is_solvable = None
        # 初始化是否平凡属性为 None
        self._is_trivial = None
        # 初始化传递度属性为 None
        self._transitivity_degree = None
        # 初始化最大除数属性为 None
        self._max_div = None
        # 初始化是否完全属性为 None
        self._is_perfect = None
        # 初始化是否循环属性为 None
        self._is_cyclic = None
        # 初始化是否二面角属性为 None
        self._is_dihedral = None
        # 计算生成器列表的长度并赋值给 `_r`
        self._r = len(self._generators)
        # 将第一个生成器的大小作为度数赋值给 `_degree`
        self._degree = self._generators[0].size

        # 下面的属性在运行 `schreier_sims` 后被赋值
        # 初始化基列表为空列表
        self._base = []
        # 初始化强生成器列表为空列表
        self._strong_gens = []
        # 初始化基的强生成器列表为空列表
        self._strong_gens_slp = []
        # 初始化基本轨道列表为空列表
        self._basic_orbits = []
        # 初始化传递表列表为空列表
        self._transversals = []
        # 初始化传递表的SLP列表为空列表
        self._transversal_slp = []

        # 下面的属性在运行 `_random_pr_init` 后被赋值
        # 初始化随机生成器列表为空列表
        self._random_gens = []

        # 作为 `FpGroup` 实例的有限呈现的群的呈现
        # 初始化群的有限呈现属性为 None
        self._fp_presentation = None

    # 获取生成器列表的索引 `i` 的元素
    def __getitem__(self, i):
        return self._generators[i]

    # 检查 `Permutation` 是否包含在 `PermutationGroup` 中
    def __contains__(self, i):
        """
        如果 *i* 在 `PermutationGroup` 中，则返回 ``True``。

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> p = Permutation(1, 2, 3)
        >>> Permutation(3) in PermutationGroup(p)
        True

        """
        # 如果 `i` 不是 `Permutation` 类型，则抛出类型错误
        if not isinstance(i, Permutation):
            raise TypeError("A PermutationGroup contains only Permutations as "
                            "elements, not elements of type %s" % type(i))
        # 调用 `contains` 方法检查 `i` 是否在 `PermutationGroup` 中
        return self.contains(i)

    # 返回生成器列表的长度
    def __len__(self):
        return len(self._generators)
    def equals(self, other):
        """
        Return ``True`` if PermutationGroup generated by elements in the
        group are same i.e they represent the same PermutationGroup.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> p = Permutation(0, 1, 2, 3, 4, 5)
        >>> G = PermutationGroup([p, p**2])
        >>> H = PermutationGroup([p**2, p])
        >>> G.generators == H.generators
        False
        >>> G.equals(H)
        True

        """
        # 检查参数是否为 PermutationGroup 类型，如果不是则返回 False
        if not isinstance(other, PermutationGroup):
            return False

        # 创建当前对象生成器集合和参数对象生成器集合的集合表示
        set_self_gens = set(self.generators)
        set_other_gens = set(other.generators)

        # 如果两个生成器集合相同，则返回 True
        if set_self_gens == set_other_gens:
            return True

        # 检查每个生成器是否在另一个 PermutationGroup 中，并且互相包含
        for gen1 in set_self_gens:
            if not other.contains(gen1):
                return False
        for gen2 in set_other_gens:
            if not self.contains(gen2):
                return False
        return True

    def __mul__(self, other):
        """
        Return the direct product of two permutation groups as a permutation
        group.

        Explanation
        ===========

        This implementation realizes the direct product by shifting the index
        set for the generators of the second group: so if we have ``G`` acting
        on ``n1`` points and ``H`` acting on ``n2`` points, ``G*H`` acts on
        ``n1 + n2`` points.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import CyclicGroup
        >>> G = CyclicGroup(5)
        >>> H = G*G
        >>> H
        PermutationGroup([
            (9)(0 1 2 3 4),
            (5 6 7 8 9)])
        >>> H.order()
        25

        """
        # 如果 other 是 Permutation 类型，则返回其与 self 的 Coset
        if isinstance(other, Permutation):
            return Coset(other, self, dir='+')

        # 从 self 和 other 中获取生成器的数组形式和次数
        gens1 = [perm._array_form for perm in self.generators]
        gens2 = [perm._array_form for perm in other.generators]
        n1 = self._degree
        n2 = other._degree

        # 创建新的生成器数组，通过偏移生成器索引实现直接乘积
        start = list(range(n1))
        end = list(range(n1, n1 + n2))
        for i in range(len(gens2)):
            gens2[i] = [x + n1 for x in gens2[i]]
        gens2 = [start + gen for gen in gens2]
        gens1 = [gen + end for gen in gens1]
        together = gens1 + gens2
        gens = [_af_new(x) for x in together]
        
        # 返回新生成的 PermutationGroup
        return PermutationGroup(gens)
    def _random_pr_init(self, r, n, _random_prec_n=None):
        r"""Initialize random generators for the product replacement algorithm.

        Explanation
        ===========

        The implementation uses a modification of the original product
        replacement algorithm due to Leedham-Green, as described in [1],
        pp. 69-71; also, see [2], pp. 27-29 for a detailed theoretical
        analysis of the original product replacement algorithm, and [4].

        The product replacement algorithm is used for producing random,
        uniformly distributed elements of a group `G` with a set of generators
        `S`. For the initialization ``_random_pr_init``, a list ``R`` of
        `\max\{r, |S|\}` group generators is created as the attribute
        ``G._random_gens``, repeating elements of `S` if necessary, and the
        identity element of `G` is appended to ``R`` - we shall refer to this
        last element as the accumulator. Then the function ``random_pr()``
        is called ``n`` times, randomizing the list ``R`` while preserving
        the generation of `G` by ``R``. The function ``random_pr()`` itself
        takes two random elements ``g, h`` among all elements of ``R`` but
        the accumulator and replaces ``g`` with a randomly chosen element
        from `\{gh, g(~h), hg, (~h)g\}`. Then the accumulator is multiplied
        by whatever ``g`` was replaced by. The new value of the accumulator is
        then returned by ``random_pr()``.

        The elements returned will eventually (for ``n`` large enough) become
        uniformly distributed across `G` ([5]). For practical purposes however,
        the values ``n = 50, r = 11`` are suggested in [1].

        Notes
        =====

        THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute
        self._random_gens

        See Also
        ========

        random_pr

        """
        # 获取群的阶数
        deg = self.degree
        # 从生成器中提取数组形式的随机生成器
        random_gens = [x._array_form for x in self.generators]
        # 计算生成器的数量
        k = len(random_gens)
        # 如果生成器数量小于 r，则重复生成器，直到数量达到 r
        if k < r:
            for i in range(k, r):
                random_gens.append(random_gens[i - k])
        # 创建包含群单位元素的累加器列表，并将其附加到 random_gens
        acc = list(range(deg))
        random_gens.append(acc)
        # 将生成的 random_gens 赋值给对象的属性 self._random_gens
        self._random_gens = random_gens

        # 处理用于测试目的的随机化输入
        # 如果 _random_prec_n 为 None，则使用默认的 n
        if _random_prec_n is None:
            # 调用 self.random_pr() n 次
            for i in range(n):
                self.random_pr()
        else:
            # 否则使用 _random_prec_n 中提供的随机精度值调用 self.random_pr()
            for i in range(n):
                self.random_pr(_random_prec=_random_prec_n[i])
    def _union_find_merge(self, first, second, ranks, parents, not_rep):
        """Merges two classes in a union-find data structure.

        Explanation
        ===========

        Used in the implementation of Atkinson's algorithm as suggested in [1],
        pp. 83-87. The class merging process uses union by rank as an
        optimization. ([7])

        Notes
        =====

        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,
        ``parents``, the list of class sizes, ``ranks``, and the list of
        elements that are not representatives, ``not_rep``, are changed due to
        class merging.

        See Also
        ========

        minimal_block, _union_find_rep

        References
        ==========

        .. [1] Holt, D., Eick, B., O'Brien, E.
               "Handbook of computational group theory"

        .. [7] https://algorithmist.com/wiki/Union_find

        """
        # Find the representative of the first and second elements
        rep_first = self._union_find_rep(first, parents)
        rep_second = self._union_find_rep(second, parents)
        # Check if they belong to different classes
        if rep_first != rep_second:
            # union by rank: merge the smaller tree under the larger tree
            if ranks[rep_first] >= ranks[rep_second]:
                new_1, new_2 = rep_first, rep_second
            else:
                new_1, new_2 = rep_second, rep_first
            total_rank = ranks[new_1] + ranks[new_2]
            # Check if the merged tree size exceeds a maximum allowed size
            if total_rank > self.max_div:
                return -1
            # Perform the union operation
            parents[new_2] = new_1
            ranks[new_1] = total_rank
            # Add the new representative to the list of non-representatives
            not_rep.append(new_2)
            return 1
        # Return 0 if no merging occurred
        return 0

    def _union_find_rep(self, num, parents):
        """Find representative of a class in a union-find data structure.

        Explanation
        ===========

        Used in the implementation of Atkinson's algorithm as suggested in [1],
        pp. 83-87. After the representative of the class to which ``num``
        belongs is found, path compression is performed as an optimization
        ([7]).

        Notes
        =====

        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,
        ``parents``, is altered due to path compression.

        See Also
        ========

        minimal_block, _union_find_merge

        References
        ==========

        .. [1] Holt, D., Eick, B., O'Brien, E.
               "Handbook of computational group theory"

        .. [7] https://algorithmist.com/wiki/Union_find

        """
        # Initialize variables to find the representative
        rep, parent = num, parents[num]
        # Find the root representative of the class
        while parent != rep:
            rep = parent
            parent = parents[rep]
        # Perform path compression to optimize future queries
        temp, parent = num, parents[num]
        while parent != rep:
            parents[temp] = rep
            temp = parent
            parent = parents[temp]
        # Return the representative of the class
        return rep

    @property
    def base(self):
        r"""Return a base from the Schreier-Sims algorithm.

        Explanation
        ===========

        For a permutation group `G`, a base is a sequence of points
        `B = (b_1, b_2, \dots, b_k)` such that no element of `G` apart
        from the identity fixes all the points in `B`. The concepts of
        a base and strong generating set and their applications are
        discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.

        An alternative way to think of `B` is that it gives the
        indices of the stabilizer cosets that contain more than the
        identity permutation.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])
        >>> G.base
        [0, 2]

        See Also
        ========

        strong_gens, basic_transversals, basic_orbits, basic_stabilizers

        """
        # 如果 _base 属性为空列表，调用 Schreier-Sims 算法计算基本序列
        if self._base == []:
            self.schreier_sims()
        # 返回计算得到的基本序列 _base
        return self._base

    @property
    def basic_orbits(self):
        r"""
        Return the basic orbits relative to a base and strong generating set.

        Explanation
        ===========

        If `(b_1, b_2, \dots, b_k)` is a base for a group `G`, and
        `G^{(i)} = G_{b_1, b_2, \dots, b_{i-1}}` is the ``i``-th basic stabilizer
        (so that `G^{(1)} = G`), the ``i``-th basic orbit relative to this base
        is the orbit of `b_i` under `G^{(i)}`. See [1], pp. 87-89 for more
        information.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import SymmetricGroup
        >>> S = SymmetricGroup(4)
        >>> S.basic_orbits
        [[0, 1, 2, 3], [1, 2, 3], [2, 3]]

        See Also
        ========

        base, strong_gens, basic_transversals, basic_stabilizers

        """
        # 如果 _basic_orbits 属性为空列表，调用 Schreier-Sims 算法计算基本轨道
        if self._basic_orbits == []:
            self.schreier_sims()
        # 返回计算得到的基本轨道 _basic_orbits
        return self._basic_orbits
    def basic_stabilizers(self):
        r"""
        Return a chain of stabilizers relative to a base and strong generating
        set.

        Explanation
        ===========

        The ``i``-th basic stabilizer `G^{(i)}` relative to a base
        `(b_1, b_2, \dots, b_k)` is `G_{b_1, b_2, \dots, b_{i-1}}`. For more
        information, see [1], pp. 87-89.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import AlternatingGroup
        >>> A = AlternatingGroup(4)
        >>> A.schreier_sims()
        >>> A.base
        [0, 1]
        >>> for g in A.basic_stabilizers:
        ...     print(g)
        ...
        PermutationGroup([
            (3)(0 1 2),
            (1 2 3)])
        PermutationGroup([
            (1 2 3)])

        See Also
        ========

        base, strong_gens, basic_orbits, basic_transversals

        """

        if self._transversals == []:
            # 如果还没有计算过基本横截面，进行 Schreier Sims 算法计算
            self.schreier_sims()
        strong_gens = self._strong_gens
        base = self._base
        if not base:  # 例如，如果基集合为空，则返回空列表
            return []
        # 将生成元按照基重新分配
        strong_gens_distr = _distribute_gens_by_base(base, strong_gens)
        basic_stabilizers = []
        # 对于每组生成元，创建置换群并添加到结果列表中
        for gens in strong_gens_distr:
            basic_stabilizers.append(PermutationGroup(gens))
        return basic_stabilizers

    @property
    def basic_transversals(self):
        """
        Return basic transversals relative to a base and strong generating set.

        Explanation
        ===========

        The basic transversals are transversals of the basic orbits. They
        are provided as a list of dictionaries, each dictionary having
        keys - the elements of one of the basic orbits, and values - the
        corresponding transversal elements. See [1], pp. 87-89 for more
        information.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import AlternatingGroup
        >>> A = AlternatingGroup(4)
        >>> A.basic_transversals
        [{0: (3), 1: (3)(0 1 2), 2: (3)(0 2 1), 3: (0 3 1)}, {1: (3), 2: (1 2 3), 3: (1 3 2)}]

        See Also
        ========

        strong_gens, base, basic_orbits, basic_stabilizers

        """

        if self._transversals == []:
            # 如果还没有计算过基本横截面，进行 Schreier Sims 算法计算
            self.schreier_sims()
        return self._transversals
    def composition_series(self):
        r"""
        Return the composition series for a group as a list
        of permutation groups.

        Explanation
        ===========

        The composition series for a group `G` is defined as a
        subnormal series `G = H_0 > H_1 > H_2 \ldots`. A composition
        series is a subnormal series such that each factor group
        `H(i+1) / H(i)` is simple.
        A subnormal series is a composition series only if it is of
        maximum length.

        The algorithm works as follows:
        Starting with the derived series, the idea is to fill
        the gap between `G = der[i]` and `H = der[i+1]` for each
        `i` independently. Since all subgroups of the abelian group
        `G/H` are normal, the first step is to take the generators
        `g` of `G` and add them to the generators of `H` one by one.

        The factor groups formed are not simple in general. Each
        group is obtained from the previous one by adding one
        generator `g`. If the previous group is denoted by `H`,
        then the next group `K` is generated by `g` and `H`.
        The factor group `K/H` is cyclic and its order is
        `K.order() // H.order()`. The series is then extended between
        `K` and `H` by groups generated by powers of `g` and `H`.
        The series formed is then prepended to the already existing
        series.

        Examples
        ========
        >>> from sympy.combinatorics.named_groups import SymmetricGroup
        >>> from sympy.combinatorics.named_groups import CyclicGroup
        >>> S = SymmetricGroup(12)
        >>> G = S.sylow_subgroup(2)
        >>> C = G.composition_series()
        >>> [H.order() for H in C]
        [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
        >>> G = S.sylow_subgroup(3)
        >>> C = G.composition_series()
        >>> [H.order() for H in C]
        [243, 81, 27, 9, 3, 1]
        >>> G = CyclicGroup(12)
        >>> C = G.composition_series()
        >>> [H.order() for H in C]
        [12, 6, 3, 1]

        """
        # 获取导出列
        der = self.derived_series()
        # 如果最后一个生成器不全为单位元，则抛出未实现错误
        if not all(g.is_identity for g in der[-1].generators):
            raise NotImplementedError('Group should be solvable')
        # 初始化空的序列列表
        series = []

        # 对于每个导出列中的元素（除了最后一个）
        for i in range(len(der) - 1):
            # 取下一个子群H
            H = der[i + 1]
            # 初始化上半段为空列表
            up_seg = []
            # 对于导出列中当前元素的所有生成器g
            for g in der[i].generators:
                # 创建由g和H的生成器组成的置换群K
                K = PermutationGroup([g] + H.generators)
                # 计算K/H的阶
                order = K.order() // H.order()
                # 初始化下半段为空列表
                down_seg = []
                # 对于K/H的阶的素因子分解
                for p, e in factorint(order).items():
                    # 对于每个素因子的指数
                    for _ in range(e):
                        # 将由g和H的生成器组成的置换群添加到下半段
                        down_seg.append(PermutationGroup([g] + H.generators))
                        # 更新g为g的p次幂
                        g = g ** p
                # 将下半段加入上半段
                up_seg = down_seg + up_seg
                # 更新H为当前的K
                H = K
            # 将导出列中当前元素加入到上半段的第一个位置
            up_seg[0] = der[i]
            # 将上半段添加到序列中
            series.extend(up_seg)
        # 将导出列中的最后一个元素加入到序列中
        series.append(der[-1])
        # 返回序列
        return series
    def coset_transversal(self, H):
        """Return a transversal of the right cosets of self by its subgroup H
        using the second method described in [1], Subsection 4.6.7

        """
        
        # 检查给定的 H 是否是自身的子群，若不是则抛出 ValueError 异常
        if not H.is_subgroup(self):
            raise ValueError("The argument must be a subgroup")

        # 如果 H 的阶数为 1，直接返回自身的元素作为右陪集的一个穿梭系统
        if H.order() == 1:
            return self.elements

        # 调用内部方法 _schreier_sims，将 G.base 扩展为 H.base 的一个扩展
        self._schreier_sims(base=H.base)

        # 获取基底 base，以及按照 base 的顺序排列的 base_ordering
        base = self.base
        base_ordering = _base_ordering(base, self.degree)

        # 创建单位置换，长度为 self.degree - 1，用于后续计算
        identity = Permutation(self.degree - 1)

        # 获取自身的基本穿梭系统的副本
        transversals = self.basic_transversals[:]
        
        # 对于 transversals 中的每个字典，将其值按照 base[l]^x 的顺序增加排序
        for l, t in enumerate(transversals):
            transversals[l] = sorted(t.values(),
                                key = lambda x: base_ordering[base[l]^x])

        # 获取 H 的基本轨道和基本稳定子群，以及自身的基本稳定子群
        orbits = H.basic_orbits
        h_stabs = H.basic_stabilizers
        g_stabs = self.basic_stabilizers

        # 计算指数列表，每个元素为 self.basic_stabilizers[i] 的阶数除以 h_stabs[i] 的阶数
        indices = [x.order()//y.order() for x, y in zip(g_stabs, h_stabs)]

        # 初始化 T^(l)，作为 G^(l) 中 H^(l) 的右穿梭系统
        if len(g_stabs) > len(h_stabs):
            T = g_stabs[len(h_stabs)].elements
        else:
            T = [identity]
        
        # 设置初始 l 值，用于迭代计算 T^(l)
        l = len(h_stabs)-1
        t_len = len(T)
        
        # 迭代计算 T^(l) 的过程
        while l > -1:
            T_next = []
            for u in transversals[l]:
                if u == identity:
                    continue
                b = base_ordering[base[l]^u]
                for t in T:
                    p = t*u
                    if all(base_ordering[h^p] >= b for h in orbits[l]):
                        T_next.append(p)
                    if t_len + len(T_next) == indices[l]:
                        break
                if t_len + len(T_next) == indices[l]:
                    break
            T += T_next
            t_len += len(T_next)
            l -= 1
        
        # 移除单位置换并将其作为 T 的第一个元素，然后返回 T 作为结果
        T.remove(identity)
        T = [identity] + T
        return T
    def _coset_representative(self, g, H):
        """Return the representative of Hg from the transversal that
        would be computed by ``self.coset_transversal(H)``.
        """
        # 如果H的阶为1，返回g本身作为代表
        if H.order() == 1:
            return g
        # self.base必须是H.base的扩展
        if not(self.base[:len(H.base)] == H.base):
            # 如果不是，则重新计算Schreier Sims基
            self._schreier_sims(base=H.base)
        # 复制H的基本轨道和H的基本横截面到局部变量
        orbits = H.basic_orbits[:]
        h_transversals = [list(_.values()) for _ in H.basic_transversals]
        # 复制self的基本横截面到局部变量
        transversals = [list(_.values()) for _ in self.basic_transversals]
        base = self.base
        # 根据base和self.degree对base进行排序
        base_ordering = _base_ordering(base, self.degree)
        # 定义递归函数step(l, x)
        def step(l, x):
            # 找到base_ordering中最小的轨道元素
            gamma = min(orbits[l], key=lambda y: base_ordering[y^x])
            # 找到h_transversals[l]中与gamma相对应的索引
            i = [base[l]^h for h in h_transversals[l]].index(gamma)
            # 更新x为h_transversals[l][i]*x
            x = h_transversals[l][i]*x
            # 如果l小于orbits的长度减1，递归调用step(l+1, x*u**-1)*u
            if l < len(orbits)-1:
                for u in transversals[l]:
                    if base[l]^u == base[l]^x:
                        break
                x = step(l+1, x*u**-1)*u
            return x
        # 调用递归函数step(0, g)，返回结果
        return step(0, g)

    def coset_table(self, H):
        """Return the standardised (right) coset table of self in H as
        a list of lists.
        """
        # 如果H不是self的子群，抛出错误
        if not H.is_subgroup(self):
            raise ValueError("The argument must be a subgroup")
        # 获取self在H中的右陪集的一个标准化表示
        T = self.coset_transversal(H)
        n = len(T)

        # 生成self的所有生成元及其逆元的列表A
        A = list(chain.from_iterable((gen, gen**-1)
                    for gen in self.generators))

        # 初始化空表table
        table = []
        # 遍历陪集T中的每个元素
        for i in range(n):
            # 对于A中的每个元素x，计算T[i]*x在H中的代表元素并添加到行row中
            row = [self._coset_representative(T[i]*x, H) for x in A]
            # 将代表元素的索引替换为T中的对应元素在行row中
            row = [T.index(r) for r in row]
            # 将行row添加到table中
            table.append(row)

        # 标准化table（这与coset_table中使用的算法相同）
        A = range(len(A))
        gamma = 1
        for alpha, a in product(range(n), A):
            beta = table[alpha][a]
            if beta >= gamma:
                if beta > gamma:
                    for x in A:
                        z = table[gamma][x]
                        table[gamma][x] = table[beta][x]
                        table[beta][x] = z
                        for i in range(n):
                            if table[i][x] == beta:
                                table[i][x] = gamma
                            elif table[i][x] == gamma:
                                table[i][x] = beta
                gamma += 1
            if gamma >= n-1:
                return table
    def center(self):
        r"""
        Return the center of a permutation group.

        Explanation
        ===========

        The center for a group `G` is defined as
        `Z(G) = {z\in G | \forall g\in G, zg = gz }`,
        the set of elements of `G` that commute with all elements of `G`.
        It is equal to the centralizer of `G` inside `G`, and is naturally a
        subgroup of `G` ([9]).

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> D = DihedralGroup(4)
        >>> G = D.center()
        >>> G.order()
        2

        See Also
        ========

        centralizer

        Notes
        =====

        This is a naive implementation that is a straightforward application
        of ``.centralizer()``

        """
        # 如果尚未计算过中心，则计算并缓存结果
        if not self._center:
            self._center = self.centralizer(self)
        # 返回已计算的中心结果
        return self._center

    def commutator(self, G, H):
        """
        Return the commutator of two subgroups.

        Explanation
        ===========

        For a permutation group ``K`` and subgroups ``G``, ``H``, the
        commutator of ``G`` and ``H`` is defined as the group generated
        by all the commutators `[g, h] = hgh^{-1}g^{-1}` for ``g`` in ``G`` and
        ``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,
        ... AlternatingGroup)
        >>> S = SymmetricGroup(5)
        >>> A = AlternatingGroup(5)
        >>> G = S.commutator(S, A)
        >>> G.is_subgroup(A)
        True

        See Also
        ========

        derived_subgroup

        Notes
        =====

        The commutator of two subgroups `H, G` is equal to the normal closure
        of the commutators of all the generators, i.e. `hgh^{-1}g^{-1}` for `h`
        a generator of `H` and `g` a generator of `G` ([1], p.28)

        """
        # 获取子群 G 和 H 的生成器
        ggens = G.generators
        hgens = H.generators
        # 初始化一个空列表用于存放所有的交换子
        commutators = []
        # 遍历 G 的生成器
        for ggen in ggens:
            # 遍历 H 的生成器
            for hgen in hgens:
                # 计算交换子 hgh^{-1}g^{-1}
                commutator = rmul(hgen, ggen, ~hgen, ~ggen)
                # 如果交换子不在列表中，则加入列表
                if commutator not in commutators:
                    commutators.append(commutator)
        # 返回所有交换子的正规闭包结果
        res = self.normal_closure(commutators)
        return res
    def coset_factor(self, g, factor_index=False):
        """Return ``G``'s (self's) coset factorization of ``g``

        Explanation
        ===========
        
        If ``g`` is an element of ``G`` then it can be written as the product
        of permutations drawn from the Schreier-Sims coset decomposition.

        The permutations returned in ``f`` are those for which
        the product gives ``g``: ``g = f[n]*...*f[1]*f[0]`` where ``n = len(B)``
        and ``B = G.base``. ``f[i]`` is one of the permutations in
        ``self._basic_orbits[i]``.

        If ``factor_index==True``,
        returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``
        belongs to ``self._basic_orbits[i]``.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
        >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
        >>> G = PermutationGroup([a, b])

        Define g:

        >>> g = Permutation(7)(1, 2, 4)(3, 6, 5)

        Confirm that it is an element of G:

        >>> G.contains(g)
        True

        Thus, it can be written as a product of factors (up to
        3) drawn from ``u``. See below that a factor from ``u1`` and ``u2``
        and the Identity permutation have been used:

        >>> f = G.coset_factor(g)
        >>> f[2]*f[1]*f[0] == g
        True
        >>> f1 = G.coset_factor(g, True); f1
        [0, 4, 4]
        >>> tr = G.basic_transversals
        >>> f[0] == tr[0][f1[0]]
        True

        If ``g`` is not an element of ``G`` then ``[]`` is returned:

        >>> c = Permutation(5, 6, 7)
        >>> G.coset_factor(c)
        []

        See Also
        ========

        sympy.combinatorics.util._strip

        """
        if isinstance(g, (Cycle, Permutation)):
            g = g.list()  # 如果 g 是循环置换或置换对象，则转换为列表形式
        if len(g) != self._degree:
            # 如果 g 的长度不等于置换群 G 的度数，则抛出值错误异常
            raise ValueError('g should be the same size as permutations of G')
        I = list(range(self._degree))  # 创建 [0, 1, ..., self._degree-1] 的列表
        basic_orbits = self.basic_orbits  # 获取基本轨道
        transversals = self._transversals  # 获取基本横截面
        factors = []  # 初始化 factors 列表
        base = self.base  # 获取置换群 G 的基
        h = g  # 将 h 初始化为 g 的副本
        for i in range(len(base)):
            beta = h[base[i]]  # 获取 h 在 base[i] 处的值
            if beta == base[i]:  # 如果 beta 等于 base[i]，直接将 beta 加入 factors
                factors.append(beta)
                continue
            if beta not in basic_orbits[i]:  # 如果 beta 不在 basic_orbits[i] 中，返回空列表
                return []
            u = transversals[i][beta]._array_form  # 获取 basic_orbits[i][beta] 的逆
            h = _af_rmul(_af_invert(u), h)  # 计算 u 逆与 h 的右乘结果
            factors.append(beta)  # 将 beta 添加到 factors 中
        if h != I:  # 如果 h 不等于 I，返回空列表
            return []
        if factor_index:  # 如果 factor_index 为 True，直接返回 factors
            return factors
        tr = self.basic_transversals  # 获取基本横截面
        factors = [tr[i][factors[i]] for i in range(len(base))]  # 将 factors 转换为真正的置换
        return factors  # 返回 factors 列表
    def generator_product(self, g, original=False):
        r'''
        Return a list of strong generators `[s1, \dots, sn]`
        s.t `g = sn \times \dots \times s1`. If ``original=True``, make the
        list contain only the original group generators

        '''
        product = []  # 初始化一个空列表用于存储生成器的乘积
        if g.is_identity:  # 如果 g 是单位元
            return []  # 返回空列表
        if g in self.strong_gens:  # 如果 g 是强生成元之一
            if not original or g in self.generators:  # 如果不要求只包含原始生成元或者 g 是原始生成元之一
                return [g]  # 返回包含 g 的列表
            else:
                slp = self._strong_gens_slp[g]  # 获取 g 对应的强生成元乘积的表达式
                for s in slp:
                    product.extend(self.generator_product(s, original=True))  # 递归计算强生成元乘积，并扩展到结果列表中
                return product
        elif g**-1 in self.strong_gens:  # 如果 g 的逆是强生成元之一
            g = g**-1  # 将 g 替换为其逆
            if not original or g in self.generators:  # 如果不要求只包含原始生成元或者 g 是原始生成元之一
                return [g**-1]  # 返回包含 g 的逆的列表
            else:
                slp = self._strong_gens_slp[g]  # 获取 g 的逆对应的强生成元乘积的表达式
                for s in slp:
                    product.extend(self.generator_product(s, original=True))  # 递归计算强生成元乘积，并扩展到结果列表中
                l = len(product)
                product = [product[l-i-1]**-1 for i in range(l)]  # 对列表中的元素取逆
                return product

        f = self.coset_factor(g, True)  # 获取 g 的余类因子分解
        for i, j in enumerate(f):
            slp = self._transversal_slp[i][j]  # 获取第 i 个轨道的第 j 个转移链表
            for s in slp:
                if not original:
                    product.append(self.strong_gens[s])  # 如果不要求只包含原始生成元，则将强生成元添加到结果列表中
                else:
                    s = self.strong_gens[s]
                    product.extend(self.generator_product(s, original=True))  # 否则递归计算强生成元乘积，并扩展到结果列表中
        return product  # 返回生成器的乘积列表

    def coset_rank(self, g):
        """rank using Schreier-Sims representation.

        Explanation
        ===========

        The coset rank of ``g`` is the ordering number in which
        it appears in the lexicographic listing according to the
        coset decomposition

        The ordering is the same as in G.generate(method='coset').
        If ``g`` does not belong to the group it returns None.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)
        >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)
        >>> G = PermutationGroup([a, b])
        >>> c = Permutation(7)(2, 4)(3, 5)
        >>> G.coset_rank(c)
        16
        >>> G.coset_unrank(16)
        (7)(2 4)(3 5)

        See Also
        ========

        coset_factor

        """
        factors = self.coset_factor(g, True)  # 获取 g 的余类因子分解
        if not factors:  # 如果余类因子分解为空
            return None  # 返回 None
        rank = 0  # 初始化排名为 0
        b = 1  # 初始化基数为 1
        transversals = self._transversals  # 获取转移系统
        base = self._base  # 获取基
        basic_orbits = self._basic_orbits  # 获取基轨道
        for i in range(len(base)):
            k = factors[i]  # 获取第 i 个基轨道的余类因子
            j = basic_orbits[i].index(k)  # 获取余类因子在基轨道中的索引
            rank += b*j  # 计算排名
            b = b*len(transversals[i])  # 更新基数
        return rank  # 返回计算得到的排名
    def coset_unrank(self, rank, af=False):
        """unrank using Schreier-Sims representation

        coset_unrank is the inverse operation of coset_rank
        if 0 <= rank < order; otherwise it returns None.

        """
        # 如果 rank 不在有效范围内，返回 None
        if rank < 0 or rank >= self.order():
            return None
        base = self.base
        transversals = self.basic_transversals
        basic_orbits = self.basic_orbits
        m = len(base)
        v = [0]*m
        # 使用 Schreier-Sims 表示进行反排列
        for i in range(m):
            rank, c = divmod(rank, len(transversals[i]))
            v[i] = basic_orbits[i][c]
        # 获取对应排列的数组形式
        a = [transversals[i][v[i]]._array_form for i in range(m)]
        # 计算排列乘积
        h = _af_rmuln(*a)
        # 如果 af 参数为 True，则返回乘积结果
        if af:
            return h
        else:
            # 否则返回新的排列对象
            return _af_new(h)

    @property
    def degree(self):
        """Returns the size of the permutations in the group.

        Explanation
        ===========

        The number of permutations comprising the group is given by
        ``len(group)``; the number of permutations that can be generated
        by the group is given by ``group.order()``.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a])
        >>> G.degree
        3
        >>> len(G)
        1
        >>> G.order()
        2
        >>> list(G.generate())
        [(2), (2)(0 1)]

        See Also
        ========

        order
        """
        # 返回置换群中排列的大小（即置换的长度）
        return self._degree

    @property
    def identity(self):
        '''
        Return the identity element of the permutation group.

        '''
        # 返回置换群的单位元素，即对角线排列
        return _af_new(list(range(self.degree)))

    @property
    def elements(self):
        """Returns all the elements of the permutation group as a list

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))
        >>> p.elements
        [(3), (3)(1 2), (1 3), (2 3), (1 2 3), (1 3 2)]

        """
        # 如果元素列表尚未生成，则生成并缓存
        if not self._elements:
            self._elements = list(self.generate())

        return self._elements
    def derived_series(self):
        r"""Return the derived series for the group.

        Explanation
        ===========

        The derived series for a group `G` is defined as
        `G = G_0 > G_1 > G_2 > \ldots` where `G_i = [G_{i-1}, G_{i-1}]`,
        i.e. `G_i` is the derived subgroup of `G_{i-1}`, for
        `i\in\mathbb{N}`. When we have `G_k = G_{k-1}` for some
        `k\in\mathbb{N}`, the series terminates.

        Returns
        =======

        A list of permutation groups containing the members of the derived
        series in the order `G = G_0, G_1, G_2, \ldots`.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,
        ... AlternatingGroup, DihedralGroup)
        >>> A = AlternatingGroup(5)
        >>> len(A.derived_series())
        1
        >>> S = SymmetricGroup(4)
        >>> len(S.derived_series())
        4
        >>> S.derived_series()[1].is_subgroup(AlternatingGroup(4))
        True
        >>> S.derived_series()[2].is_subgroup(DihedralGroup(2))
        True

        See Also
        ========

        derived_subgroup

        """
        res = [self]  # 初始化结果列表，包含当前群本身
        current = self  # 初始化当前群为自身
        nxt = self.derived_subgroup()  # 计算当前群的导出子群作为下一个群
        while not current.is_subgroup(nxt):  # 循环直到当前群不再是下一个群的子群
            res.append(nxt)  # 将下一个群添加到结果列表中
            current = nxt  # 更新当前群为下一个群
            nxt = nxt.derived_subgroup()  # 计算下一个群的导出子群
        return res  # 返回结果列表，包含整个导出级数的群序列

    def derived_subgroup(self):
        r"""Compute the derived subgroup.

        Explanation
        ===========

        The derived subgroup, or commutator subgroup is the subgroup generated
        by all commutators `[g, h] = hgh^{-1}g^{-1}` for `g, h\in G` ; it is
        equal to the normal closure of the set of commutators of the generators
        ([1], p.28, [11]).

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([1, 0, 2, 4, 3])
        >>> b = Permutation([0, 1, 3, 2, 4])
        >>> G = PermutationGroup([a, b])
        >>> C = G.derived_subgroup()
        >>> list(C.generate(af=True))
        [[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]

        See Also
        ========

        derived_series

        """
        r = self._r  # 获取群的维数
        gens = [p._array_form for p in self.generators]  # 获取群的生成元的数组表示形式
        set_commutators = set()  # 创建一个空集合，用于存储群的交换子
        degree = self._degree  # 获取群的度数
        rng = list(range(degree))  # 创建一个包含度数范围的列表
        for i in range(r):  # 外层循环遍历生成元的数组
            for j in range(r):  # 内层循环遍历生成元的数组
                p1 = gens[i]  # 获取第一个生成元的数组表示
                p2 = gens[j]  # 获取第二个生成元的数组表示
                c = list(range(degree))  # 创建一个包含度数范围的列表作为交换子的数组表示
                for k in rng:  # 遍历度数范围
                    c[p2[p1[k]]] = p1[p2[k]]  # 计算生成元之间的交换子
                ct = tuple(c)  # 将交换子数组转换为元组
                if ct not in set_commutators:  # 如果交换子不在集合中
                    set_commutators.add(ct)  # 将交换子添加到集合中
        cms = [_af_new(p) for p in set_commutators]  # 创建交换子的数组表示形式
        G2 = self.normal_closure(cms)  # 计算交换子的正规闭包
        return G2  # 返回计算得到的导出子群
    def generate(self, method="coset", af=False):
        """
        Return iterator to generate the elements of the group.

        Explanation
        ===========

        Iteration is done with one of these methods::

          method='coset'  using the Schreier-Sims coset representation
          method='dimino' using the Dimino method

        If ``af = True`` it yields the array form of the permutations

        Examples
        ========

        >>> from sympy.combinatorics import PermutationGroup
        >>> from sympy.combinatorics.polyhedron import tetrahedron

        The permutation group given in the tetrahedron object is also
        true groups:

        >>> G = tetrahedron.pgroup
        >>> G.is_group
        True

        Also the group generated by the permutations in the tetrahedron
        pgroup -- even the first two -- is a proper group:

        >>> H = PermutationGroup(G[0], G[1])
        >>> J = PermutationGroup(list(H.generate())); J
        PermutationGroup([
            (0 1)(2 3),
            (1 2 3),
            (1 3 2),
            (0 3 1),
            (0 2 3),
            (0 3)(1 2),
            (0 1 3),
            (3)(0 2 1),
            (0 3 2),
            (3)(0 1 2),
            (0 2)(1 3)])
        >>> _.is_group
        True
        """

        # 根据不同的生成方法选择生成器
        if method == "coset":
            return self.generate_schreier_sims(af)  # 使用 Schreier-Sims 方法生成元素
        elif method == "dimino":
            return self.generate_dimino(af)  # 使用 Dimino 方法生成元素
        else:
            raise NotImplementedError('No generation defined for %s' % method)  # 抛出未实现错误，指定的生成方法未定义
    def generate_dimino(self, af=False):
        """Yield group elements using Dimino's algorithm.

        If ``af == True`` it yields the array form of the permutations.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1, 3])
        >>> b = Permutation([0, 2, 3, 1])
        >>> g = PermutationGroup([a, b])
        >>> list(g.generate_dimino(af=True))
        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],
         [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]

        References
        ==========

        .. [1] The Implementation of Various Algorithms for Permutation Groups in
               the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis

        """
        # 初始化单位置换和一些必要的变量
        idn = list(range(self.degree))
        order = 0
        element_list = [idn]  # 初始元素列表包含单位置换
        set_element_list = {tuple(idn)}  # 使用集合记录已生成的置换

        # 如果需要返回数组形式的置换，则生成并返回单位置换的数组形式
        if af:
            yield idn
        else:
            yield _af_new(idn)  # 否则生成并返回单位置换的一般形式

        # 获取生成元素的数组形式列表
        gens = [p._array_form for p in self.generators]

        # 对于每个生成元素进行处理
        for i in range(len(gens)):
            # D 是由 gens[:i] 生成的子群 G_i 的元素列表
            D = element_list[:]
            N = [idn]
            
            # 当 N 非空时循环处理
            while N:
                A = N
                N = []
                
                # 遍历当前处理集合 A 中的元素
                for a in A:
                    # 对于每个生成元素 g，计算 a * g 的数组形式
                    for g in gens[:i + 1]:
                        ag = _af_rmul(a, g)
                        
                        # 如果 ag 的数组形式不在已生成的集合中，则生成该置换
                        if tuple(ag) not in set_element_list:
                            # 生成 G_i * g
                            for d in D:
                                order += 1
                                ap = _af_rmul(d, ag)
                                
                                # 如果需要返回数组形式的置换，则生成并返回 ap 的数组形式
                                if af:
                                    yield ap
                                else:
                                    p = _af_new(ap)
                                    yield p
                                    
                                # 更新元素列表和集合
                                element_list.append(ap)
                                set_element_list.add(tuple(ap))
                                N.append(ap)
        
        # 记录生成的置换个数
        self._order = len(element_list)
    def generate_schreier_sims(self, af=False):
        """生成使用Schreier-Sims表示法的群元素，按照coset_rank顺序生成

        如果 ``af = True``，则生成排列的数组形式

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1, 3])
        >>> b = Permutation([0, 2, 3, 1])
        >>> g = PermutationGroup([a, b])
        >>> list(g.generate_schreier_sims(af=True))
        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],
         [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]
        """

        n = self._degree  # 获取群的阶数
        u = self.basic_transversals  # 获取基本横跨集合
        basic_orbits = self._basic_orbits  # 获取基本轨道
        if len(u) == 0:  # 如果基本横跨集合为空
            for x in self.generators:  # 遍历群的生成元素
                if af:
                    yield x._array_form  # 如果需要数组形式，则生成数组形式的排列
                else:
                    yield x  # 否则生成排列对象本身
            return
        if len(u) == 1:  # 如果只有一个基本横跨集合
            for i in basic_orbits[0]:  # 遍历第一个基本轨道
                if af:
                    yield u[0][i]._array_form  # 如果需要数组形式，则生成数组形式的排列
                else:
                    yield u[0][i]  # 否则生成排列对象本身
            return

        u = list(reversed(u))  # 反转基本横跨集合
        basic_orbits = basic_orbits[::-1]  # 反转基本轨道
        # stg为群元素的堆栈
        stg = [list(range(n))]
        posmax = [len(x) for x in u]  # 记录每个横跨集合的最大长度
        n1 = len(posmax) - 1
        pos = [0]*n1
        h = 0
        while 1:
            # 完成对coset的迭代后回溯
            if pos[h] >= posmax[h]:
                if h == 0:
                    return
                pos[h] = 0
                h -= 1
                stg.pop()
                continue
            p = _af_rmul(u[h][basic_orbits[h][pos[h]]]._array_form, stg[-1])
            pos[h] += 1
            stg.append(p)
            h += 1
            if h == n1:
                if af:
                    for i in basic_orbits[-1]:
                        p = _af_rmul(u[-1][i]._array_form, stg[-1])
                        yield p
                else:
                    for i in basic_orbits[-1]:
                        p = _af_rmul(u[-1][i]._array_form, stg[-1])
                        p1 = _af_new(p)
                        yield p1
                stg.pop()
                h -= 1

    @property
    def generators(self):
        """返回群的生成元素。

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.generators
        [(1 2), (2)(0 1)]

        """
        return self._generators
    def contains(self, g, strict=True):
        """Test if permutation ``g`` belongs to self, ``G``.

        Explanation
        ===========

        If ``g`` is an element of ``G``, it can be written as a product
        of factors drawn from the cosets of ``G``'s stabilizers. To check
        if ``g`` is one of the actual generators defining the group, use
        ``G.has(g)``.

        If ``strict`` is not ``True``, ``g`` will be resized, if necessary,
        to match the size of permutations in ``self``.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup

        >>> a = Permutation(1, 2)
        >>> b = Permutation(2, 3, 1)
        >>> G = PermutationGroup(a, b, degree=5)
        >>> G.contains(G[0]) # trivial check
        True
        >>> elem = Permutation([[2, 3]], size=5)
        >>> G.contains(elem)
        True
        >>> G.contains(Permutation(4)(0, 1, 2, 3))
        False

        If strict is False, a permutation will be resized, if
        necessary:

        >>> H = PermutationGroup(Permutation(5))
        >>> H.contains(Permutation(3))
        False
        >>> H.contains(Permutation(3), strict=False)
        True

        To test if a given permutation is present in the group:

        >>> elem in G.generators
        False
        >>> G.has(elem)
        False

        See Also
        ========

        coset_factor, sympy.core.basic.Basic.has, __contains__

        """
        # 如果 g 不是 Permutation 类型，则直接返回 False
        if not isinstance(g, Permutation):
            return False
        # 如果 g 的大小与 self.degree 不匹配，并且 strict 为 True，则返回 False
        if g.size != self.degree:
            if strict:
                return False
            # 如果 strict 为 False，则将 g 调整为与 self.degree 相同大小的 Permutation
            g = Permutation(g, size=self.degree)
        # 检查 g 是否是 self.generators 中的一个生成元
        if g in self.generators:
            return True
        # 否则，检查 g 是否属于 self 的 coset_factor
        return bool(self.coset_factor(g.array_form, True))

    @property
    def is_perfect(self):
        """Return ``True`` if the group is perfect.
        A group is perfect if it equals its derived subgroup.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation(1,2,3)(4,5)
        >>> b = Permutation(1,2,3,4,5)
        >>> G = PermutationGroup([a, b])
        >>> G.is_perfect
        False

        """
        # 如果 self._is_perfect 尚未计算，则计算并存储结果
        if self._is_perfect is None:
            self._is_perfect = self.equals(self.derived_subgroup())
        # 返回存储的结果
        return self._is_perfect
    def is_abelian(self):
        """Test if the group is Abelian.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.is_abelian
        False
        >>> a = Permutation([0, 2, 1])
        >>> G = PermutationGroup([a])
        >>> G.is_abelian
        True

        """
        # 如果已经计算过是否为阿贝尔群，则直接返回之前的结果
        if self._is_abelian is not None:
            return self._is_abelian
        
        # 默认假设为阿贝尔群
        self._is_abelian = True
        # 获取生成元的数组形式列表
        gens = [p._array_form for p in self.generators]
        
        # 遍历所有生成元的数组形式
        for x in gens:
            for y in gens:
                # 如果 y <= x，跳过当前循环，继续下一个
                if y <= x:
                    continue
                # 检查 x 和 y 是否交换律
                if not _af_commutes_with(x, y):
                    # 如果不满足交换律，将阿贝尔群标记为假，返回 False
                    self._is_abelian = False
                    return False
        
        # 如果所有的生成元都满足交换律，则返回 True
        return True
    def abelian_invariants(self):
        """
        Returns the abelian invariants for the given group.
        Let ``G`` be a nontrivial finite abelian group. Then G is isomorphic to
        the direct product of finitely many nontrivial cyclic groups of
        prime-power order.
        """

        # 检查当前群是否为平凡群（即阶数为1的群），如果是则返回空列表作为其不变量
        if self.is_trivial:
            return []

        # 获取群的生成元
        gns = self.generators
        # 初始化不变量列表
        inv = []
        # 复制群对象到 G
        G = self
        # 计算群的导出子群 H
        H = G.derived_subgroup()
        # 获取导出子群的生成元
        Hgens = H.generators

        # 对群的阶数进行质因数分解，并迭代每个质因数 p
        for p in primefactors(G.order()):
            # 初始化存储 p 的指数的列表
            ranks = []
            while True:
                # 初始化存储 p 的幂的列表
                pows = []
                # 对于群的每个生成元 g，计算其 p 次幂
                for g in gns:
                    elm = g**p
                    # 如果 p 次幂不属于导出子群 H，则加入 pows 列表
                    if not H.contains(elm):
                        pows.append(elm)
                # 构造扩展的群 K，包含导出子群 H 的生成元和新添加的 p 次幂生成元
                K = PermutationGroup(Hgens + pows) if pows else H
                # 计算群 K 的阶数与原群 G 的阶数的商
                r = G.order() // K.order()
                # 更新群 G 为 K，更新生成元列表为 pows
                G = K
                gns = pows
                # 如果 r 等于 1，跳出循环
                if r == 1:
                    break
                # 记录 p 的出现次数（指数）
                ranks.append(multiplicity(p, r))

            # 如果 ranks 列表非空，则计算 p 的指数列表并添加到不变量列表 inv 中
            if ranks:
                pows = [1] * ranks[0]
                for i in ranks:
                    for j in range(i):
                        pows[j] = pows[j] * p
                inv.extend(pows)

        # 对不变量列表 inv 进行排序并返回
        inv.sort()
        return inv
    def is_elementary(self, p):
        """Return ``True`` if the group is elementary abelian. An elementary
        abelian group is a finite abelian group, where every nontrivial
        element has order `p`, where `p` is a prime.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1])
        >>> G = PermutationGroup([a])
        >>> G.is_elementary(2)
        True
        >>> a = Permutation([0, 2, 1, 3])
        >>> b = Permutation([3, 1, 2, 0])
        >>> G = PermutationGroup([a, b])
        >>> G.is_elementary(2)
        True
        >>> G.is_elementary(3)
        False

        """
        # 检查群是否为阿贝尔群，并且群中所有生成元的阶都等于给定的素数 p
        return self.is_abelian and all(g.order() == p for g in self.generators)

    def _eval_is_alt_sym_naive(self, only_sym=False, only_alt=False):
        """A naive test using the group order."""
        # 如果同时设置了 only_sym 和 only_alt，抛出 ValueError 异常
        if only_sym and only_alt:
            raise ValueError(
                "Both {} and {} cannot be set to True"
                .format(only_sym, only_alt))

        # 获取群的阶和对称群的阶
        n = self.degree
        sym_order = _factorial(n)
        order = self.order()

        # 如果群的阶等于对称群的阶，则标记群为对称群，不是交错群，返回 not only_alt
        if order == sym_order:
            self._is_sym = True
            self._is_alt = False
            return not only_alt

        # 如果群的阶是对称群阶的两倍，则标记群为交错群，不是对称群，返回 not only_sym
        if 2*order == sym_order:
            self._is_sym = False
            self._is_alt = True
            return not only_sym

        # 其它情况返回 False
        return False

    def _eval_is_alt_sym_monte_carlo(self, eps=0.05, perms=None):
        """A test using monte-carlo algorithm.

        Parameters
        ==========

        eps : float, optional
            The criterion for the incorrect ``False`` return.

        perms : list[Permutation], optional
            If explicitly given, it tests over the given candidates
            for testing.

            If ``None``, it randomly computes ``N_eps`` and chooses
            ``N_eps`` sample of the permutation from the group.

        See Also
        ========

        _check_cycles_alt_sym
        """
        # 如果 perms 为 None，则计算 N_eps 并从群中随机选择 N_eps 个置换进行测试
        if perms is None:
            n = self.degree
            if n < 17:
                c_n = 0.34
            else:
                c_n = 0.57
            d_n = (c_n*log(2))/log(n)
            N_eps = int(-log(eps)/d_n)

            # 使用生成器表达式随机生成 N_eps 个置换进行测试
            perms = (self.random_pr() for i in range(N_eps))
            return self._eval_is_alt_sym_monte_carlo(perms=perms)

        # 遍历给定的 perms 列表，如果存在置换是交错的，则返回 True
        for perm in perms:
            if _check_cycles_alt_sym(perm):
                return True
        # 如果所有 perms 都不是交错的，则返回 False
        return False
    def is_alt_sym(self, eps=0.05, _random_prec=None):
        r"""Monte Carlo test for the symmetric/alternating group for degrees
        >= 8.

        Explanation
        ===========

        More specifically, it is one-sided Monte Carlo with the
        answer True (i.e., G is symmetric/alternating) guaranteed to be
        correct, and the answer False being incorrect with probability eps.

        For degree < 8, the order of the group is checked so the test
        is deterministic.

        Notes
        =====

        The algorithm itself uses some nontrivial results from group theory and
        number theory:
        1) If a transitive group ``G`` of degree ``n`` contains an element
        with a cycle of length ``n/2 < p < n-2`` for ``p`` a prime, ``G`` is the
        symmetric or alternating group ([1], pp. 81-82)
        2) The proportion of elements in the symmetric/alternating group having
        the property described in 1) is approximately `\log(2)/\log(n)`
        ([1], p.82; [2], pp. 226-227).
        The helper function ``_check_cycles_alt_sym`` is used to
        go over the cycles in a permutation and look for ones satisfying 1).

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> D = DihedralGroup(10)
        >>> D.is_alt_sym()
        False

        See Also
        ========

        _check_cycles_alt_sym

        """
        # 如果提供了随机精度，使用蒙特卡罗方法进行检测
        if _random_prec is not None:
            N_eps = _random_prec['N_eps']
            perms = (_random_prec[i] for i in range(N_eps))
            return self._eval_is_alt_sym_monte_carlo(perms=perms)

        # 如果已经确定是对称或交错群，则直接返回True
        if self._is_sym or self._is_alt:
            return True
        # 如果已确定不是对称且不是交错群，则直接返回False
        if self._is_sym is False and self._is_alt is False:
            return False

        # 获取群的阶数
        n = self.degree
        # 对于阶数小于8的情况，使用简单的确定性算法进行判断
        if n < 8:
            return self._eval_is_alt_sym_naive()
        # 如果群是传递的，则使用蒙特卡罗方法进行判断
        elif self.is_transitive():
            return self._eval_is_alt_sym_monte_carlo(eps=eps)

        # 如果以上条件都不满足，则返回False
        self._is_sym, self._is_alt = False, False
        return False

    @property
    def is_nilpotent(self):
        """Test if the group is nilpotent.

        Explanation
        ===========

        A group `G` is nilpotent if it has a central series of finite length.
        Alternatively, `G` is nilpotent if its lower central series terminates
        with the trivial group. Every nilpotent group is also solvable
        ([1], p.29, [12]).

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,
        ... CyclicGroup)
        >>> C = CyclicGroup(6)
        >>> C.is_nilpotent
        True
        >>> S = SymmetricGroup(5)
        >>> S.is_nilpotent
        False

        See Also
        ========

        lower_central_series, is_solvable

        """
        # 如果未计算过是否幂零
        if self._is_nilpotent is None:
            # 获取群的下中心级数
            lcs = self.lower_central_series()
            # 获取下中心级数的终结子群
            terminator = lcs[len(lcs) - 1]
            # 获取终结子群的生成元
            gens = terminator.generators
            # 获取群的阶数
            degree = self.degree
            # 创建群的单位元素
            identity = _af_new(list(range(degree)))
            # 检查所有生成元是否都是单位元素
            if all(g == identity for g in gens):
                self._is_solvable = True
                self._is_nilpotent = True
                return True
            else:
                self._is_nilpotent = False
                return False
        else:
            # 如果已经计算过，则直接返回之前计算的结果
            return self._is_nilpotent

    def is_normal(self, gr, strict=True):
        """Test if ``G=self`` is a normal subgroup of ``gr``.

        Explanation
        ===========

        G is normal in gr if
        for each g2 in G, g1 in gr, ``g = g1*g2*g1**-1`` belongs to G
        It is sufficient to check this for each g1 in gr.generators and
        g2 in G.generators.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([1, 2, 0])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G1 = PermutationGroup([a, Permutation([2, 0, 1])])
        >>> G1.is_normal(G)
        True

        """
        # 如果self不是gr的子群，则不正常
        if not self.is_subgroup(gr, strict=strict):
            return False
        # 获取self和gr的阶数
        d_self = self.degree
        d_gr = gr.degree
        # 如果self是平凡群并且阶数相同或者不严格模式下，则self是gr的正规子群
        if self.is_trivial and (d_self == d_gr or not strict):
            return True
        # 如果self是阿贝尔群，则self是gr的正规子群
        if self._is_abelian:
            return True
        # 复制self
        new_self = self.copy()
        # 如果不是严格模式且阶数不同，则调整self或gr的阶数
        if not strict and d_self != d_gr:
            if d_self < d_gr:
                new_self = PermGroup(new_self.generators + [Permutation(d_gr - 1)])
            else:
                gr = PermGroup(gr.generators + [Permutation(d_self - 1)])
        # 获取新self和gr的生成元
        gens2 = [p._array_form for p in new_self.generators]
        gens1 = [p._array_form for p in gr.generators]
        # 对于gr的每个生成元g1和新self的每个生成元g2，检查g1*g2*g1**-1是否在self中
        for g1 in gens1:
            for g2 in gens2:
                p = _af_rmuln(g1, g2, _af_invert(g1))
                if not new_self.coset_factor(p, True):
                    return False
        return True
    def is_primitive(self, randomized=True):
        r"""Test if a group is primitive.

        Explanation
        ===========

        A permutation group ``G`` acting on a set ``S`` is called primitive if
        ``S`` contains no nontrivial block under the action of ``G``
        (a block is nontrivial if its cardinality is more than ``1``).

        Notes
        =====

        The algorithm is described in [1], p.83, and uses the function
        minimal_block to search for blocks of the form `\{0, k\}` for ``k``
        ranging over representatives for the orbits of `G_0`, the stabilizer of
        ``0``. This algorithm has complexity `O(n^2)` where ``n`` is the degree
        of the group, and will perform badly if `G_0` is small.

        There are two implementations offered: one finds `G_0`
        deterministically using the function ``stabilizer``, and the other
        (default) produces random elements of `G_0` using ``random_stab``,
        hoping that they generate a subgroup of `G_0` with not too many more
        orbits than `G_0` (this is suggested in [1], p.83). Behavior is changed
        by the ``randomized`` flag.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> D = DihedralGroup(10)
        >>> D.is_primitive()
        False

        See Also
        ========

        minimal_block, random_stab

        """
        # 如果已经计算过结果，则直接返回缓存的结果
        if self._is_primitive is not None:
            return self._is_primitive

        # 如果群不是传递的，则它不可能是原始的
        if self.is_transitive() is False:
            return False

        # 如果选择使用随机生成的方式
        if randomized:
            # 初始化一个空列表来存储随机生成的稳定子群生成元
            random_stab_gens = []
            # 获取关于点0的Schreier向量
            v = self.schreier_vector(0)
            # 随机生成足够多的稳定子群生成元
            for _ in range(len(self)):
                random_stab_gens.append(self.random_stab(0, v))
            # 构建稳定子群
            stab = PermutationGroup(random_stab_gens)
        else:
            # 使用确定性方法找到点0的稳定子群
            stab = self.stabilizer(0)

        # 获取稳定子群的轨道
        orbits = stab.orbits()
        # 遍历每个轨道
        for orb in orbits:
            # 从轨道中取出一个元素作为代表
            x = orb.pop()
            # 如果轨道中的元素不是0，并且存在非零元素在最小块中
            if x != 0 and any(e != 0 for e in self.minimal_block([0, x])):
                # 标记群不是原始的，并返回False
                self._is_primitive = False
                return False

        # 如果所有检查都通过，则标记群是原始的，并返回True
        self._is_primitive = True
        return True

    @property
    # 测试群是否可解

    """Test if the group is solvable.

    ``G`` is solvable if its derived series terminates with the trivial
    group ([1], p.29).

    Examples
    ========

    >>> from sympy.combinatorics.named_groups import SymmetricGroup
    >>> S = SymmetricGroup(3)
    >>> S.is_solvable
    True

    See Also
    ========

    is_nilpotent, derived_series

    """

    # 如果尚未计算过可解性，则进行计算
    if self._is_solvable is None:
        # 如果群的阶数为奇数，则返回 True
        if self.order() % 2 != 0:
            return True
        # 计算群的导出级数
        ds = self.derived_series()
        # 导出级数的最后一个项
        terminator = ds[len(ds) - 1]
        # 获取最后一个项的生成元素
        gens = terminator.generators
        # 群的阶数
        degree = self.degree
        # 创建表示群单位元的对象
        identity = _af_new(list(range(degree)))
        # 检查最后一个项的所有生成元是否都是单位元
        if all(g == identity for g in gens):
            self._is_solvable = True
            return True
        else:
            self._is_solvable = False
            return False
    else:
        # 如果之前已经计算过可解性，则直接返回保存的结果
        return self._is_solvable
    def is_subgroup(self, G, strict=True):
        """Return ``True`` if all elements of ``self`` belong to ``G``.

        If ``strict`` is ``False`` then if ``self``'s degree is smaller
        than ``G``'s, the elements will be resized to have the same degree.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> from sympy.combinatorics import SymmetricGroup, CyclicGroup

        Testing is strict by default: the degree of each group must be the
        same:

        >>> p = Permutation(0, 1, 2, 3, 4, 5)
        >>> G1 = PermutationGroup([Permutation(0, 1, 2), Permutation(0, 1)])
        >>> G2 = PermutationGroup([Permutation(0, 2), Permutation(0, 1, 2)])
        >>> G3 = PermutationGroup([p, p**2])
        >>> assert G1.order() == G2.order() == G3.order() == 6
        >>> G1.is_subgroup(G2)
        True
        >>> G1.is_subgroup(G3)
        False
        >>> G3.is_subgroup(PermutationGroup(G3[1]))
        False
        >>> G3.is_subgroup(PermutationGroup(G3[0]))
        True

        To ignore the size, set ``strict`` to ``False``:

        >>> S3 = SymmetricGroup(3)
        >>> S5 = SymmetricGroup(5)
        >>> S3.is_subgroup(S5, strict=False)
        True
        >>> C7 = CyclicGroup(7)
        >>> G = S5*C7
        >>> S5.is_subgroup(G, False)
        True
        >>> C7.is_subgroup(G, 0)
        False

        """
        # 检查是否为 SymmetricPermutationGroup 类型，如果是，则要求两个群的次数必须相等
        if isinstance(G, SymmetricPermutationGroup):
            if self.degree != G.degree:
                return False
            return True
        # 如果 G 不是 PermutationGroup 类型，则返回 False
        if not isinstance(G, PermutationGroup):
            return False
        # 如果 self 等于 G，或者 self 的生成元为单位置换，则返回 True
        if self == G or self.generators[0]==Permutation():
            return True
        # 如果 G 的阶数不能整除 self 的阶数，则返回 False
        if G.order() % self.order() != 0:
            return False
        # 如果 self 的次数与 G 的次数相等，或者 self 的次数小于 G 的次数且 strict 为 False，则将 self 的生成元赋给 gens
        if self.degree == G.degree or \
                (self.degree < G.degree and not strict):
            gens = self.generators
        else:
            return False
        # 检查 gens 中的每个生成元是否都属于 G，如果都属于，则返回 True，否则返回 False
        return all(G.contains(g, strict=strict) for g in gens)

    @property
    def is_polycyclic(self):
        """Return ``True`` if a group is polycyclic. A group is polycyclic if
        it has a subnormal series with cyclic factors. For finite groups,
        this is the same as if the group is solvable.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1, 3])
        >>> b = Permutation([2, 0, 1, 3])
        >>> G = PermutationGroup([a, b])
        >>> G.is_polycyclic
        True

        """
        # 返回 self 的 is_solvable 属性，即判断群是否可解
        return self.is_solvable
    def is_transitive(self, strict=True):
        """Test if the group is transitive.

        Explanation
        ===========

        A group is transitive if it has a single orbit.

        If ``strict`` is ``False`` the group is transitive if it has
        a single orbit of length different from 1.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1, 3])
        >>> b = Permutation([2, 0, 1, 3])
        >>> G1 = PermutationGroup([a, b])
        >>> G1.is_transitive()
        False
        >>> G1.is_transitive(strict=False)
        True
        >>> c = Permutation([2, 3, 0, 1])
        >>> G2 = PermutationGroup([a, c])
        >>> G2.is_transitive()
        True
        >>> d = Permutation([1, 0, 2, 3])
        >>> e = Permutation([0, 1, 3, 2])
        >>> G3 = PermutationGroup([d, e])
        >>> G3.is_transitive() or G3.is_transitive(strict=False)
        False

        """
        if self._is_transitive:  # 检查是否已经计算过结果，如果已计算直接返回
            return self._is_transitive
        if strict:
            if self._is_transitive is not None:  # 如果strict=True，并且结果已计算，则直接返回已计算的结果
                return self._is_transitive

            ans = len(self.orbit(0)) == self.degree  # 计算第一个点的轨道长度是否等于群的阶
            self._is_transitive = ans  # 将计算结果存储在实例中，避免重复计算
            return ans

        got_orb = False
        for x in self.orbits():  # 遍历所有轨道
            if len(x) > 1:  # 如果找到长度大于1的轨道，则群不是严格传递的
                if got_orb:
                    return False
                got_orb = True
        return got_orb  # 返回是否找到长度大于1的轨道

    @property
    def is_trivial(self):
        """Test if the group is the trivial group.

        This is true if the group contains only the identity permutation.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> G = PermutationGroup([Permutation([0, 1, 2])])
        >>> G.is_trivial
        True

        """
        if self._is_trivial is None:  # 如果还未计算过结果
            self._is_trivial = len(self) == 1 and self[0].is_Identity  # 判断群是否仅包含恒等置换
        return self._is_trivial  # 返回计算结果或已存储的结果
    def lower_central_series(self):
        r"""Return the lower central series for the group.

        The lower central series for a group `G` is the series
        `G = G_0 > G_1 > G_2 > \ldots` where
        `G_k = [G, G_{k-1}]`, i.e. every term after the first is equal to the
        commutator of `G` and the previous term in `G1` ([1], p.29).

        Returns
        =======

        A list of permutation groups in the order `G = G_0, G_1, G_2, \ldots`

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import (AlternatingGroup,
        ... DihedralGroup)
        >>> A = AlternatingGroup(4)
        >>> len(A.lower_central_series())
        2
        >>> A.lower_central_series()[1].is_subgroup(DihedralGroup(2))
        True

        See Also
        ========

        commutator, derived_series

        """
        # 初始化结果列表，初始为包含当前群的列表
        res = [self]
        # 当前群为初始群
        current = self
        # 计算群的第一个次中心级数
        nxt = self.commutator(self, current)
        # 循环直到找到一个不是当前群的子群的群
        while not current.is_subgroup(nxt):
            # 将下一个次中心级数添加到结果列表
            res.append(nxt)
            # 更新当前群为下一个次中心级数
            current = nxt
            # 计算新的下一个次中心级数
            nxt = self.commutator(self, current)
        # 返回结果列表
        return res

    @property
    def max_div(self):
        """Maximum proper divisor of the degree of a permutation group.

        Explanation
        ===========

        Obviously, this is the degree divided by its minimal proper divisor
        (larger than ``1``, if one exists). As it is guaranteed to be prime,
        the ``sieve`` from ``sympy.ntheory`` is used.
        This function is also used as an optimization tool for the functions
        ``minimal_block`` and ``_union_find_merge``.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> G = PermutationGroup([Permutation([0, 2, 1, 3])])
        >>> G.max_div
        2

        See Also
        ========

        minimal_block, _union_find_merge

        """
        # 如果已经计算过最大除数，则直接返回之前计算的结果
        if self._max_div is not None:
            return self._max_div
        # 获取群的度数
        n = self.degree
        # 如果群的度数为1，则最大除数为1
        if n == 1:
            return 1
        # 使用素数筛选器计算最大除数
        for x in sieve:
            if n % x == 0:
                d = n // x
                self._max_div = d
                return d
    def conjugacy_class(self, x):
        r"""Return the conjugacy class of an element in the group.

        Explanation
        ===========

        The conjugacy class of an element ``g`` in a group ``G`` is the set of
        elements ``x`` in ``G`` that are conjugate with ``g``, i.e. for which

            ``g = xax^{-1}``

        for some ``a`` in ``G``.

        Note that conjugacy is an equivalence relation, and therefore that
        conjugacy classes are partitions of ``G``. For a list of all the
        conjugacy classes of the group, use the conjugacy_classes() method.

        In a permutation group, each conjugacy class corresponds to a particular
        `cycle structure': for example, in ``S_3``, the conjugacy classes are:

            * the identity class, ``{()}``
            * all transpositions, ``{(1 2), (1 3), (2 3)}``
            * all 3-cycles, ``{(1 2 3), (1 3 2)}``

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, SymmetricGroup
        >>> S3 = SymmetricGroup(3)
        >>> S3.conjugacy_class(Permutation(0, 1, 2))
        {(0 1 2), (0 2 1)}

        Notes
        =====

        This procedure computes the conjugacy class directly by finding the
        orbit of the element under conjugation in G. This algorithm is only
        feasible for permutation groups of relatively small order, but is like
        the orbit() function itself in that respect.
        """
        # Initialize the conjugacy class with the element x
        new_class = {x}
        # Store the last iteration's conjugacy class for comparison
        last_iteration = new_class

        # Iterate until no new elements are added to the conjugacy class
        while len(last_iteration) > 0:
            # Initialize an empty set for the current iteration
            this_iteration = set()

            # Iterate over the elements in the last iteration's conjugacy class
            for y in last_iteration:
                # Iterate over the generators of the group
                for s in self.generators:
                    # Calculate the conjugated element s * y * s^{-1}
                    conjugated = s * y * (~s)
                    # If the conjugated element is not already in the conjugacy class, add it to the current iteration set
                    if conjugated not in new_class:
                        this_iteration.add(conjugated)

            # Update the conjugacy class with elements from the current iteration
            new_class.update(this_iteration)
            # Update the last iteration's conjugacy class to the current iteration's
            last_iteration = this_iteration

        # Return the computed conjugacy class
        return new_class
    def conjugacy_classes(self):
        r"""Return the conjugacy classes of the group.

        Explanation
        ===========

        As described in the documentation for the .conjugacy_class() function,
        conjugacy is an equivalence relation on a group G which partitions the
        set of elements. This method returns a list of all these conjugacy
        classes of G.

        Examples
        ========

        >>> from sympy.combinatorics import SymmetricGroup
        >>> SymmetricGroup(3).conjugacy_classes()
        [{(2)}, {(0 1 2), (0 2 1)}, {(0 2), (1 2), (2)(0 1)}]

        """
        # 初始化单位元素的表达式
        identity = _af_new(list(range(self.degree)))
        # 存储已知元素的集合，初始包含单位元素
        known_elements = {identity}
        # 存储所有共轭类的列表，初始包含单位元素的集合
        classes = [known_elements.copy()]

        # 遍历生成器产生的所有元素
        for x in self.generate():
            # 如果当前元素不在已知元素集合中
            if x not in known_elements:
                # 计算当前元素的共轭类
                new_class = self.conjugacy_class(x)
                # 将新的共轭类添加到共轭类列表中
                classes.append(new_class)
                # 更新已知元素集合，加入新的共轭类元素
                known_elements.update(new_class)

        # 返回所有共轭类的列表
        return classes

    def orbit(self, alpha, action='tuples'):
        r"""Compute the orbit of alpha `\{g(\alpha) | g \in G\}` as a set.

        Explanation
        ===========

        The time complexity of the algorithm used here is `O(|Orb|*r)` where
        `|Orb|` is the size of the orbit and ``r`` is the number of generators of
        the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.
        Here alpha can be a single point, or a list of points.

        If alpha is a single point, the ordinary orbit is computed.
        if alpha is a list of points, there are three available options:

        'union' - computes the union of the orbits of the points in the list
        'tuples' - computes the orbit of the list interpreted as an ordered
        tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )
        'sets' - computes the orbit of the list interpreted as a set

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([1, 2, 0, 4, 5, 6, 3])
        >>> G = PermutationGroup([a])
        >>> G.orbit(0)
        {0, 1, 2}
        >>> G.orbit([0, 4], 'union')
        {0, 1, 2, 3, 4, 5, 6}

        See Also
        ========

        orbit_transversal

        """
        # 调用内部函数 _orbit 计算轨道
        return _orbit(self.degree, self.generators, alpha, action)
    def orbit_rep(self, alpha, beta, schreier_vector=None):
        """Return a group element which sends ``alpha`` to ``beta``.

        Explanation
        ===========

        If ``beta`` is not in the orbit of ``alpha``, the function returns
        ``False``. This implementation makes use of the Schreier vector.
        For a proof of correctness, see [1], p.80

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import AlternatingGroup
        >>> G = AlternatingGroup(5)
        >>> G.orbit_rep(0, 4)
        (0 4 1 2 3)

        See Also
        ========

        schreier_vector
        """
        # If no Schreier vector is provided, compute it for alpha
        if schreier_vector is None:
            schreier_vector = self.schreier_vector(alpha)
        
        # If beta is not in the orbit of alpha, return False
        if schreier_vector[beta] is None:
            return False
        
        # Initialize k to the position of beta in the Schreier vector
        k = schreier_vector[beta]
        
        # Get the array forms of generators in the group
        gens = [x._array_form for x in self.generators]
        
        # Initialize an empty list to store group elements
        a = []
        
        # Construct the group element which sends alpha to beta
        while k != -1:
            a.append(gens[k])
            beta = gens[k].index(beta)  # Update beta to the result of applying gens[k] to beta
            k = schreier_vector[beta]
        
        # If elements were appended to a, construct and return the new group element
        if a:
            return _af_new(_af_rmuln(*a))
        else:
            # If no elements were appended (shouldn't happen in a valid group), return the identity
            return _af_new(list(range(self._degree)))

    def orbit_transversal(self, alpha, pairs=False):
        r"""Computes a transversal for the orbit of ``alpha`` as a set.

        Explanation
        ===========

        For a permutation group `G`, a transversal for the orbit
        `Orb = \{g(\alpha) | g \in G\}` is a set
        `\{g_\beta | g_\beta(\alpha) = \beta\}` for `\beta \in Orb`.
        Note that there may be more than one possible transversal.
        If ``pairs`` is set to ``True``, it returns the list of pairs
        `(\beta, g_\beta)`. For a proof of correctness, see [1], p.79

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> G = DihedralGroup(6)
        >>> G.orbit_transversal(0)
        [(5), (0 1 2 3 4 5), (0 5)(1 4)(2 3), (0 2 4)(1 3 5), (5)(0 4)(1 3), (0 3)(1 4)(2 5)]

        See Also
        ========

        orbit
        """
        # Call the underlying function to compute the orbit transversal
        return _orbit_transversal(self._degree, self.generators, alpha, pairs)

    def orbits(self, rep=False):
        """Return the orbits of ``self``, ordered according to lowest element
        in each orbit.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation(1, 5)(2, 3)(4, 0, 6)
        >>> b = Permutation(1, 5)(3, 4)(2, 6, 0)
        >>> G = PermutationGroup([a, b])
        >>> G.orbits()
        [{0, 2, 3, 4, 6}, {1, 5}]
        """
        # Call the underlying function to compute the orbits
        return _orbits(self._degree, self._generators)
    def order(self):
        """
        Return the order of the group: the number of permutations that
        can be generated from elements of the group.

        The number of permutations comprising the group is given by
        ``len(group)``; the length of each permutation in the group is
        given by ``group.size``.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup

        >>> a = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a])
        >>> G.degree
        3
        >>> len(G)
        1
        >>> G.order()
        2
        >>> list(G.generate())
        [(2), (2)(0 1)]

        >>> a = Permutation([0, 2, 1])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.order()
        6

        See Also
        ========

        degree
        """
        # 如果已经计算过_order，则直接返回缓存的结果
        if self._order is not None:
            return self._order
        # 如果群是对称群，计算其阶乘
        if self._is_sym:
            n = self._degree
            self._order = factorial(n)
            return self._order
        # 如果群是交替群，计算其阶乘再除以2
        if self._is_alt:
            n = self._degree
            self._order = factorial(n) / 2
            return self._order

        # 计算基本横断面的长度乘积作为群的阶
        m = prod([len(x) for x in self.basic_transversals])
        self._order = m
        return m

    def index(self, H):
        """
        Returns the index of a permutation group.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation(1,2,3)
        >>> b = Permutation(3)
        >>> G = PermutationGroup([a])
        >>> H = PermutationGroup([b])
        >>> G.index(H)
        3

        """
        # 如果H是当前群的子群，返回当前群的阶除以H的阶
        if H.is_subgroup(self):
            return self.order() // H.order()
        """Return ``True`` if the group is symmetric.

        Examples
        ========

        >>> from sympy.combinatorics import SymmetricGroup
        >>> g = SymmetricGroup(5)
        >>> g.is_symmetric
        True

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> g = PermutationGroup(
        ...     Permutation(0, 1, 2, 3, 4),
        ...     Permutation(2, 3))
        >>> g.is_symmetric
        True

        Notes
        =====

        This uses a naive test involving the computation of the full
        group order.
        If you need more quicker taxonomy for large groups, you can use
        :meth:`PermutationGroup.is_alt_sym`.
        However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
        and is not able to distinguish between an alternating group and
        a symmetric group.

        See Also
        ========

        is_alt_sym
        """
        # 获取已缓存的结果，如果存在直接返回
        _is_sym = self._is_sym
        if _is_sym is not None:
            return _is_sym

        # 获取置换群的阶数
        n = self.degree
        # 对于阶数大于等于8的情况
        if n >= 8:
            # 如果置换群是传递的（transitive）
            if self.is_transitive():
                # 使用蒙特卡洛方法评估是否是交替对称群
                _is_alt_sym = self._eval_is_alt_sym_monte_carlo()
                if _is_alt_sym:
                    # 如果是交替对称群并且包含奇置换
                    if any(g.is_odd for g in self.generators):
                        # 标记为对称群但不是交替对称群
                        self._is_sym, self._is_alt = True, False
                        return True

                    # 标记为交替对称群但不是对称群
                    self._is_sym, self._is_alt = False, True
                    return False

                # 如果不是交替对称群，使用朴素方法判断是否是对称群
                return self._eval_is_alt_sym_naive(only_sym=True)

            # 如果不是传递的，不可能是对称群或交替对称群
            self._is_sym, self._is_alt = False, False
            return False

        # 对于阶数小于8的情况，使用朴素方法判断是否是对称群
        return self._eval_is_alt_sym_naive(only_sym=True)
    def is_alternating(self):
        """Return ``True`` if the group is alternating.

        Examples
        ========

        >>> from sympy.combinatorics import AlternatingGroup
        >>> g = AlternatingGroup(5)
        >>> g.is_alternating
        True

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> g = PermutationGroup(
        ...     Permutation(0, 1, 2, 3, 4),
        ...     Permutation(2, 3, 4))
        >>> g.is_alternating
        True

        Notes
        =====

        This uses a naive test involving the computation of the full
        group order.
        If you need more quicker taxonomy for large groups, you can use
        :meth:`PermutationGroup.is_alt_sym`.
        However, :meth:`PermutationGroup.is_alt_sym` may not be accurate
        and is not able to distinguish between an alternating group and
        a symmetric group.

        See Also
        ========

        is_alt_sym
        """
        _is_alt = self._is_alt
        # 如果已经计算过结果，则直接返回保存的结果
        if _is_alt is not None:
            return _is_alt

        n = self.degree
        # 对于度数大于等于 8 的置换群
        if n >= 8:
            # 如果置换群是传递的
            if self.is_transitive():
                # 使用 Monte Carlo 方法评估是否是交错对称群
                _is_alt_sym = self._eval_is_alt_sym_monte_carlo()
                if _is_alt_sym:
                    # 如果是交错对称群，并且所有生成元都是偶置换
                    if all(g.is_even for g in self.generators):
                        self._is_sym, self._is_alt = False, True
                        return True

                    self._is_sym, self._is_alt = True, False
                    return False

                # 否则使用朴素方法评估是否是交错对称群，只关注交错对称性
                return self._eval_is_alt_sym_naive(only_alt=True)

            # 如果不是传递的，则不是交错群也不是对称群
            self._is_sym, self._is_alt = False, False
            return False

        # 对于度数小于 8 的置换群，直接使用朴素方法评估是否是交错对称群，只关注交错对称性
        return self._eval_is_alt_sym_naive(only_alt=True)

    @classmethod
    def _distinct_primes_lemma(cls, primes):
        """Subroutine to test if there is only one cyclic group for the
        order."""
        # 对输入的素数列表进行排序
        primes = sorted(primes)
        l = len(primes)
        # 遍历素数列表，检查是否只有一个循环群的情况
        for i in range(l):
            for j in range(i+1, l):
                if primes[j] % primes[i] == 1:
                    return None
        # 如果不存在多个循环群的情况，则返回 True
        return True
    def is_cyclic(self):
        r"""
        Return ``True`` if the group is Cyclic.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import AbelianGroup
        >>> G = AbelianGroup(3, 4)
        >>> G.is_cyclic
        True
        >>> G = AbelianGroup(4, 4)
        >>> G.is_cyclic
        False

        Notes
        =====

        If the order of a group $n$ can be factored into the distinct
        primes $p_1, p_2, \dots , p_s$ and if

        .. math::
            \forall i, j \in \{1, 2, \dots, s \}:
            p_i \not \equiv 1 \pmod {p_j}

        holds true, there is only one group of the order $n$ which
        is a cyclic group [1]_. This is a generalization of the lemma
        that the group of order $15, 35, \dots$ are cyclic.

        And also, these additional lemmas can be used to test if a
        group is cyclic if the order of the group is already found.

        - If the group is abelian and the order of the group is
          square-free, the group is cyclic.
        - If the order of the group is less than $6$ and is not $4$, the
          group is cyclic.
        - If the order of the group is prime, the group is cyclic.

        References
        ==========

        .. [1] 1978: John S. Rose: A Course on Group Theory,
            Introduction to Finite Group Theory: 1.4
        """
        # 如果已经计算过 `_is_cyclic` 属性，则直接返回其值
        if self._is_cyclic is not None:
            return self._is_cyclic

        # 如果群生成元的数量为 1，那么群是循环群，并且是阿贝尔群
        if len(self.generators) == 1:
            self._is_cyclic = True
            self._is_abelian = True
            return True

        # 如果群不是阿贝尔群，则不是循环群
        if self._is_abelian is False:
            self._is_cyclic = False
            return False

        # 计算群的阶数
        order = self.order()

        # 如果群的阶数小于 6，并且不等于 4，则是循环群
        if order < 6:
            self._is_abelian = True
            if order != 4:
                self._is_cyclic = True
                return True

        # 将群的阶数分解为质因数
        factors = factorint(order)

        # 如果群的阶数是平方数，且群是阿贝尔群，则是循环群
        if all(v == 1 for v in factors.values()):
            if self._is_abelian:
                self._is_cyclic = True
                return True

            # 检查是否满足不同质数的条件
            primes = list(factors.keys())
            if PermutationGroup._distinct_primes_lemma(primes) is True:
                self._is_cyclic = True
                self._is_abelian = True
                return True

        # 如果群不是阿贝尔群，则不是循环群
        if not self.is_abelian:
            self._is_cyclic = False
            return False

        # 判断群是否是循环群，利用群的生成元和其阶数的因子进行判断
        self._is_cyclic = all(
            any(g**(order//p) != self.identity for g in self.generators)
            for p, e in factors.items() if e > 1
        )
        return self._is_cyclic
    def pointwise_stabilizer(self, points, incremental=True):
        r"""Return the pointwise stabilizer for a set of points.

        Explanation
        ===========

        For a permutation group `G` and a set of points
        `\{p_1, p_2,\ldots, p_k\}`, the pointwise stabilizer of
        `p_1, p_2, \ldots, p_k` is defined as
        `G_{p_1,\ldots, p_k} =
        \{g\in G | g(p_i) = p_i \forall i\in\{1, 2,\ldots,k\}\}` ([1],p20).
        It is a subgroup of `G`.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import SymmetricGroup
        >>> S = SymmetricGroup(7)
        >>> Stab = S.pointwise_stabilizer([2, 3, 5])
        >>> Stab.is_subgroup(S.stabilizer(2).stabilizer(3).stabilizer(5))
        True

        See Also
        ========

        stabilizer, schreier_sims_incremental

        Notes
        =====

        When incremental == True,
        rather than the obvious implementation using successive calls to
        ``.stabilizer()``, this uses the incremental Schreier-Sims algorithm
        to obtain a base with starting segment - the given points.

        """
        # 如果 incremental 参数为 True，则使用增量式的 Schreier-Sims 算法获取基础和生成器
        if incremental:
            # 调用增量 Schreier-Sims 算法，获取基础和强生成器
            base, strong_gens = self.schreier_sims_incremental(base=points)
            # 初始化一个空列表来存储稳定生成器
            stab_gens = []
            # 获取置换群的次数（即群的阶）
            degree = self.degree
            # 遍历强生成器列表
            for gen in strong_gens:
                # 检查生成器 gen 是否保持所有给定点不变
                if [gen(point) for point in points] == points:
                    stab_gens.append(gen)
            # 如果没有找到稳定生成器，则创建一个新的生成器列表以包含所有群的可能置换
            if not stab_gens:
                stab_gens = _af_new(list(range(degree)))
            # 返回由稳定生成器构成的置换群对象
            return PermutationGroup(stab_gens)
        else:
            # 如果 incremental 参数为 False，则使用直接的 stabilizer 函数计算稳定器
            gens = self._generators
            degree = self.degree
            # 针对每个点 x 计算稳定器
            for x in points:
                gens = _stabilizer(degree, gens, x)
        # 返回由生成器列表构成的置换群对象
        return PermutationGroup(gens)
    def make_perm(self, n, seed=None):
        """
        Multiply ``n`` randomly selected permutations from
        pgroup together, starting with the identity
        permutation. If ``n`` is a list of integers, those
        integers will be used to select the permutations and they
        will be applied in L to R order: make_perm((A, B, C)) will
        give CBA(I) where I is the identity permutation.

        ``seed`` is used to set the seed for the random selection
        of permutations from pgroup. If this is a list of integers,
        the corresponding permutations from pgroup will be selected
        in the order give. This is mainly used for testing purposes.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a, b = [Permutation([1, 0, 3, 2]), Permutation([1, 3, 0, 2])]
        >>> G = PermutationGroup([a, b])
        >>> G.make_perm(1, [0])
        (0 1)(2 3)
        >>> G.make_perm(3, [0, 1, 0])
        (0 2 3 1)
        >>> G.make_perm([0, 1, 0])
        (0 2 3 1)

        See Also
        ========

        random
        """
        # 如果 n 是一个序列（列表），则设置 n 为其长度，同时将 seed 设置为该序列
        if is_sequence(n):
            # 如果 seed 不为 None，则抛出 ValueError 异常
            if seed is not None:
                raise ValueError('If n is a sequence, seed should be None')
            # 设置 n 为序列的长度，并且将 seed 设置为 n
            n, seed = len(n), n
        else:
            try:
                # 尝试将 n 转换为整数类型
                n = int(n)
            except TypeError:
                # 如果转换失败，抛出 ValueError 异常
                raise ValueError('n must be an integer or a sequence.')
        # 使用 _randrange(seed) 函数生成一个随机范围对象
        randomrange = _randrange(seed)

        # 从单位置换开始
        result = Permutation(list(range(self.degree)))
        # 获取群的长度
        m = len(self)
        # 循环 n 次，每次选择一个随机排列并与结果排列相乘
        for _ in range(n):
            p = self[randomrange(m)]
            result = rmul(result, p)
        # 返回最终的排列结果
        return result

    def random(self, af=False):
        """Return a random group element
        """
        # 生成一个随机排列的秩，取值范围是 [0, 群的阶 - 1]
        rank = randrange(self.order())
        # 使用秩来解析对应的余类
        return self.coset_unrank(rank, af)
    def random_pr(self, gen_count=11, iterations=50, _random_prec=None):
        """Return a random group element using product replacement.

        Explanation
        ===========

        For the details of the product replacement algorithm, see
        ``_random_pr_init``. In ``random_pr``, the actual 'product replacement'
        is performed. If the attribute ``_random_gens`` is empty, it is initialized
        by calling ``_random_pr_init``.

        See Also
        ========

        _random_pr_init

        """
        # 如果 self._random_gens 为空列表，则调用 _random_pr_init 初始化它
        if self._random_gens == []:
            self._random_pr_init(gen_count, iterations)
        # 将 self._random_gens 赋值给 random_gens
        random_gens = self._random_gens
        # 计算随机生成器的个数减一
        r = len(random_gens) - 1

        # 处理用于测试目的的随机输入
        if _random_prec is None:
            s = randrange(r)  # 随机选择 s，范围在 0 到 r-1 之间
            t = randrange(r - 1)  # 随机选择 t，范围在 0 到 r-2 之间
            if t == s:
                t = r - 1
            x = choice([1, 2])  # 随机选择 x，值为 1 或 2
            e = choice([-1, 1])  # 随机选择 e，值为 -1 或 1
        else:
            s = _random_prec['s']
            t = _random_prec['t']
            if t == s:
                t = r - 1
            x = _random_prec['x']
            e = _random_prec['e']

        if x == 1:
            random_gens[s] = _af_rmul(random_gens[s], _af_pow(random_gens[t], e))
            random_gens[r] = _af_rmul(random_gens[r], random_gens[s])
        else:
            random_gens[s] = _af_rmul(_af_pow(random_gens[t], e), random_gens[s])
            random_gens[r] = _af_rmul(random_gens[s], random_gens[r])
        # 返回生成的随机群元素
        return _af_new(random_gens[r])

    def random_stab(self, alpha, schreier_vector=None, _random_prec=None):
        """Random element from the stabilizer of ``alpha``.

        The schreier vector for ``alpha`` is an optional argument used
        for speeding up repeated calls. The algorithm is described in [1], p.81

        See Also
        ========

        random_pr, orbit_rep

        """
        # 如果 schreier_vector 为 None，则计算 alpha 的 schreier 向量
        if schreier_vector is None:
            schreier_vector = self.schreier_vector(alpha)
        # 如果 _random_prec 为 None，则调用 random_pr 获取随机元素
        if _random_prec is None:
            rand = self.random_pr()
        else:
            rand = _random_prec['rand']
        # 使用随机生成的 rand(alpha) 计算 beta
        beta = rand(alpha)
        # 计算 alpha 的轨道代表 h
        h = self.orbit_rep(alpha, beta, schreier_vector)
        # 返回 rmul(~h, rand)
        return rmul(~h, rand)
    def schreier_sims(self):
        """
        Schreier-Sims algorithm.

        Explanation
        ===========

        It computes the generators of the chain of stabilizers
        `G > G_{b_1} > .. > G_{b1,..,b_r} > 1`
        in which `G_{b_1,..,b_i}` stabilizes `b_1,..,b_i`,
        and the corresponding ``s`` cosets.
        An element of the group can be written as the product
        `h_1*..*h_s`.

        We use the incremental Schreier-Sims algorithm.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([0, 2, 1])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.schreier_sims()
        >>> G.basic_transversals
        [{0: (2)(0 1), 1: (2), 2: (1 2)},
         {0: (2), 2: (0 2)}]
        """

        # 如果已经计算过转移系数，则直接返回
        if self._transversals:
            return

        # 调用内部方法计算 Schreier-Sims 算法
        self._schreier_sims()
        return

    def _schreier_sims(self, base=None):
        # 使用增量 Schreier-Sims 算法计算生成器和基
        schreier = self.schreier_sims_incremental(base=base, slp_dict=True)
        base, strong_gens = schreier[:2]

        # 设置基和强生成器
        self._base = base
        self._strong_gens = strong_gens
        self._strong_gens_slp = schreier[2]

        # 如果基为空，则设置结果为空并返回
        if not base:
            self._transversals = []
            self._basic_orbits = []
            return

        # 根据基和强生成器分发生成器
        strong_gens_distr = _distribute_gens_by_base(base, strong_gens)

        # 使用基和分发的生成器计算轨道和转移系数
        basic_orbits, transversals, slps = _orbits_transversals_from_bsgs(base,
                strong_gens_distr, slp=True)

        # 将存储在转移系数中的索引重写为强生成器的形式
        for i, slp in enumerate(slps):
            gens = strong_gens_distr[i]
            for k in slp:
                slp[k] = [strong_gens.index(gens[s]) for s in slp[k]]

        # 设置计算得到的结果
        self._transversals = transversals
        self._basic_orbits = [sorted(x) for x in basic_orbits]
        self._transversal_slp = slps
    def schreier_vector(self, alpha):
        """Computes the schreier vector for ``alpha``.
        
        Explanation
        ===========
        
        The Schreier vector efficiently stores information
        about the orbit of ``alpha``. It can later be used to quickly obtain
        elements of the group that send ``alpha`` to a particular element
        in the orbit. Notice that the Schreier vector depends on the order
        in which the group generators are listed. For a definition, see [3].
        Since list indices start from zero, we adopt the convention to use
        "None" instead of 0 to signify that an element does not belong
        to the orbit.
        For the algorithm and its correctness, see [2], pp.78-80.
        
        Examples
        ========
        
        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([2, 4, 6, 3, 1, 5, 0])
        >>> b = Permutation([0, 1, 3, 5, 4, 6, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.schreier_vector(0)
        [-1, None, 0, 1, None, 1, 0]
        
        See Also
        ========
        
        orbit
        
        """
        n = self.degree  # 获取置换群的次数
        v = [None]*n  # 初始化 Schreier 向量，用于存储轨道信息
        v[alpha] = -1  # 标记起始点 alpha 的位置为 -1
        orb = [alpha]  # 初始化轨道，起始为 alpha
        used = [False]*n  # 用于标记已经处理过的元素
        used[alpha] = True  # 标记起始点 alpha 已使用
        gens = self.generators  # 获取置换群的生成元
        r = len(gens)  # 获取生成元的数量
        for b in orb:  # 遍历当前轨道中的每个元素 b
            for i in range(r):  # 遍历每个生成元
                temp = gens[i]._array_form[b]  # 应用生成元到 b 上得到新位置 temp
                if used[temp] is False:  # 如果 temp 还未处理过
                    orb.append(temp)  # 将 temp 添加到轨道中
                    used[temp] = True  # 标记 temp 已使用
                    v[temp] = i  # 记录应用的生成元在 Schreier 向量中的位置
        return v  # 返回计算得到的 Schreier 向量

    def stabilizer(self, alpha):
        r"""Return the stabilizer subgroup of ``alpha``.
        
        Explanation
        ===========
        
        The stabilizer of `\alpha` is the group `G_\alpha =
        \{g \in G | g(\alpha) = \alpha\}`.
        For a proof of correctness, see [1], p.79.
        
        Examples
        ========
        
        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> G = DihedralGroup(6)
        >>> G.stabilizer(5)
        PermutationGroup([
            (5)(0 4)(1 3)])
        
        See Also
        ========
        
        orbit
        
        """
        return PermGroup(_stabilizer(self._degree, self._generators, alpha))

    @property
    def strong_gens(self):
        r"""Return a strong generating set from the Schreier-Sims algorithm.

        Explanation
        ===========

        A generating set `S = \{g_1, g_2, \dots, g_t\}` for a permutation group
        `G` is a strong generating set relative to the sequence of points
        (referred to as a "base") `(b_1, b_2, \dots, b_k)` if, for
        `1 \leq i \leq k` we have that the intersection of the pointwise
        stabilizer `G^{(i+1)} := G_{b_1, b_2, \dots, b_i}` with `S` generates
        the pointwise stabilizer `G^{(i+1)}`. The concepts of a base and
        strong generating set and their applications are discussed in depth
        in [1], pp. 87-89 and [2], pp. 55-57.

        Examples
        ========

        >>> from sympy.combinatorics.named_groups import DihedralGroup
        >>> D = DihedralGroup(4)
        >>> D.strong_gens
        [(0 1 2 3), (0 3)(1 2), (1 3)]
        >>> D.base
        [0, 1]

        See Also
        ========

        base, basic_transversals, basic_orbits, basic_stabilizers

        """
        # 如果当前对象的强生成集合为空，则调用 Schreier-Sims 算法生成
        if self._strong_gens == []:
            self.schreier_sims()
        # 返回当前对象的强生成集合
        return self._strong_gens

    def subgroup(self, gens):
        """
           Return the subgroup generated by `gens` which is a list of
           elements of the group
        """
        # 检查给定生成器是否都在当前群中
        if not all(g in self for g in gens):
            raise ValueError("The group does not contain the supplied generators")

        # 使用给定生成器列表生成置换群对象
        G = PermutationGroup(gens)
        # 返回生成的子群对象
        return G

    @property
    def transitivity_degree(self):
        r"""Compute the degree of transitivity of the group.

        Explanation
        ===========

        A permutation group `G` acting on `\Omega = \{0, 1, \dots, n-1\}` is
        ``k``-fold transitive, if, for any `k` points
        `(a_1, a_2, \dots, a_k) \in \Omega` and any `k` points
        `(b_1, b_2, \dots, b_k) \in \Omega` there exists `g \in  G` such that
        `g(a_1) = b_1, g(a_2) = b_2, \dots, g(a_k) = b_k`
        The degree of transitivity of `G` is the maximum ``k`` such that
        `G` is ``k``-fold transitive. ([8])

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, PermutationGroup
        >>> a = Permutation([1, 2, 0])
        >>> b = Permutation([1, 0, 2])
        >>> G = PermutationGroup([a, b])
        >>> G.transitivity_degree
        3

        See Also
        ========

        is_transitive, orbit

        """
        # 如果尚未计算过置换群的传递度
        if self._transitivity_degree is None:
            # 置换群的次数
            n = self.degree
            G = self
            # 对每个点 i 从 0 到 n-1
            for i in range(n):
                # 计算 G 在点 i 的轨道
                orb = G.orbit(i)
                # 如果轨道的长度不等于 n - i
                if len(orb) != n - i:
                    # 置换群的传递度为 i
                    self._transitivity_degree = i
                    return i
                # 计算固定 i 点后的稳定子群 G_i
                G = G.stabilizer(i)
            # 置换群的传递度为 n
            self._transitivity_degree = n
            return n
        else:
            # 如果已经计算过置换群的传递度，则直接返回保存的值
            return self._transitivity_degree
    def _p_elements_group(self, p):
        '''
        对于一个 Abel 群的 p-群，返回由所有 p 阶元素（包括单位元素）构成的子群

        '''
        # 复制生成元素列表
        gens = self.generators[:]
        # 根据元素的阶（order）进行降序排序
        gens = sorted(gens, key=lambda x: x.order(), reverse=True)
        # 计算每个生成元素的 p 次方，生成 gens_p 列表
        gens_p = [g**(g.order()/p) for g in gens]
        # 初始化空列表 gens_r 用于存储符合条件的 p-群元素
        gens_r = []
        for i in range(len(gens)):
            x = gens[i]
            x_order = x.order()
            # x_p 是 x 的 p 次方，其阶为 p
            x_p = x**(x_order/p)
            if i > 0:
                # 如果 i > 0，使用 gens_p[:i] 构建置换群 P
                P = PermutationGroup(gens_p[:i])
            else:
                # 如果 i = 0，使用单位元素构建置换群 P
                P = PermutationGroup(self.identity)
            # 如果 x 的 p 次方不在置换群 P 中，则将其加入 gens_r
            if x**(x_order/p) not in P:
                gens_r.append(x**(x_order/p))
            else:
                # 替换 x 为一个阶数为 (x.order()/p) 的元素，确保 gens 仍然生成 G
                g = P.generator_product(x_p, original=True)
                for s in g:
                    x = x*s**-1
                x_order = x_order/p
                # 从 gens 中删除原来的 x
                del gens[i]
                del gens_p[i]
                j = i - 1
                # 插入新的 x 到 gens 中，保持排序顺序
                while j < len(gens) and gens[j].order() >= x_order:
                    j += 1
                gens = gens[:j] + [x] + gens[j:]
                gens_p = gens_p[:j] + [x] + gens_p[j:]
        # 返回由 gens_r 构成的置换群对象
        return PermutationGroup(gens_r)
    def _block_verify(self, L, alpha):
        # 对轨道进行排序并存储在 delta 中
        delta = sorted(self.orbit(alpha))
        
        # p[i] 将是 delta[i] 所属的块的编号
        p = [-1]*len(delta)
        
        # blocks[i] 将是 delta[i] 所属的块的 alpha
        blocks = [-1]*len(delta)

        # B 是未来块的列表
        B = [[]] # future list of blocks
        
        # u[i] 是在 L 中使得 alpha^u[i] = B[0][i] 的元素
        u = [0]*len(delta) # u[i] in L s.t. alpha^u[i] = B[0][i]

        # 使用轨道传递函数生成器，初始化第一个块 B[0]
        t = L.orbit_transversal(alpha, pairs=True)
        for a, beta in t:
            B[0].append(a)
            i_a = delta.index(a)
            p[i_a] = 0
            blocks[i_a] = alpha
            u[i_a] = beta

        # 初始化循环变量
        rho = 0
        m = 0 # number of blocks - 1

        # 开始主循环，直到 rho 大于等于 m
        while rho <= m:
            beta = B[rho][0]
            for g in self.generators:
                d = beta^g
                i_d = delta.index(d)
                sigma = p[i_d]
                if sigma < 0:
                    # 定义一个新的块
                    m += 1
                    sigma = m
                    u[i_d] = u[delta.index(beta)]*g
                    p[i_d] = sigma
                    rep = d
                    blocks[i_d] = rep
                    newb = [rep]
                    for gamma in B[rho][1:]:
                        i_gamma = delta.index(gamma)
                        d = gamma^g
                        i_d = delta.index(d)
                        if p[i_d] < 0:
                            u[i_d] = u[i_gamma]*g
                            p[i_d] = sigma
                            blocks[i_d] = rep
                            newb.append(d)
                        else:
                            # B[rho] 不是一个块
                            s = u[i_gamma]*g*u[i_d]**(-1)
                            return False, s

                    B.append(newb)
                else:
                    for h in B[rho][1:]:
                        if h^g not in B[sigma]:
                            # B[rho] 不是一个块
                            s = u[delta.index(beta)]*g*u[i_d]**(-1)
                            return False, s
            rho += 1

        # 如果所有块都通过验证，则返回 True 和 blocks
        return True, blocks
    def polycyclic_group(self):
        """
        返回带有以下参数的 PolycyclicGroup 实例：

        Explanation
        ===========

        * pc_sequence : Polycyclic sequence 是由给定置换群的导出系列中相邻群之间所有丢失生成元素组成的序列。

        * pc_series : Polycyclic series 是由 ``der[i]`` 中添加所有 ``der[i+1]`` 中丢失的生成元素形成的序列，这里的 ``der`` 表示导出系列。

        * relative_order : 一个列表，由 pc_series 中相邻群的比率计算得到。

        """
        from sympy.combinatorics.pc_groups import PolycyclicGroup
        # 如果群不是可解的，则抛出异常
        if not self.is_polycyclic:
            raise ValueError("The group must be solvable")

        # 计算群的导出系列
        der = self.derived_series()
        pc_series = []
        pc_sequence = []
        relative_order = []
        # 将最后一个群加入到 pc_series 中
        pc_series.append(der[-1])
        # 反转 derived series
        der.reverse()

        # 遍历 derived series 中的每个群
        for i in range(len(der)-1):
            H = der[i]
            # 遍历下一个群的生成元
            for g in der[i+1].generators:
                # 如果生成元不在当前群 H 中，则将其加入到 H 中
                if g not in H:
                    H = PermutationGroup([g] + H.generators)
                    # 在 pc_series 的开头插入新的群 H
                    pc_series.insert(0, H)
                    # 在 pc_sequence 的开头插入丢失的生成元 g
                    pc_sequence.insert(0, g)

                    # 计算相邻两个群的相对阶
                    G1 = pc_series[0].order()
                    G2 = pc_series[1].order()
                    relative_order.insert(0, G1 // G2)

        # 返回 PolycyclicGroup 实例，包括 pc_sequence、pc_series 和 relative_order
        return PolycyclicGroup(pc_sequence, pc_series, relative_order, collector=None)
# 计算生成元 alpha 的轨道 {g(alpha) | g ∈ G} 作为一个集合
def _orbit(degree, generators, alpha, action='tuples'):
    r"""Compute the orbit of alpha `\{g(\alpha) | g \in G\}` as a set.

    Explanation
    ===========

    The time complexity of the algorithm used here is `O(|Orb|*r)` where
    `|Orb|` is the size of the orbit and ``r`` is the number of generators of
    the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.
    Here alpha can be a single point, or a list of points.

    If alpha is a single point, the ordinary orbit is computed.
    if alpha is a list of points, there are three available options:

    'union' - computes the union of the orbits of the points in the list
    'tuples' - computes the orbit of the list interpreted as an ordered
    tuple under the group action ( i.e., g((1, 2, 3)) = (g(1), g(2), g(3)) )
    'sets' - computes the orbit of the list interpreted as a sets

    Examples
    ========

    >>> from sympy.combinatorics import Permutation, PermutationGroup
    >>> from sympy.combinatorics.perm_groups import _orbit
    >>> a = Permutation([1, 2, 0, 4, 5, 6, 3])
    >>> G = PermutationGroup([a])
    >>> _orbit(G.degree, G.generators, 0)
    {0, 1, 2}
    >>> _orbit(G.degree, G.generators, [0, 4], 'union')
    {0, 1, 2, 3, 4, 5, 6}

    See Also
    ========

    orbit, orbit_transversal

    """
    # 如果 alpha 不是可索引对象，则转换为单元素列表
    if not hasattr(alpha, '__getitem__'):
        alpha = [alpha]

    # 将生成元转换为数组形式
    gens = [x._array_form for x in generators]

    # 根据指定的 action 类型进行不同的轨道计算
    if len(alpha) == 1 or action == 'union':
        # 计算普通轨道或多点轨道的并集
        orb = alpha
        used = [False]*degree
        for el in alpha:
            used[el] = True
        for b in orb:
            for gen in gens:
                temp = gen[b]
                if used[temp] == False:
                    orb.append(temp)
                    used[temp] = True
        return set(orb)
    elif action == 'tuples':
        # 计算元组轨道
        alpha = tuple(alpha)
        orb = [alpha]
        used = {alpha}
        for b in orb:
            for gen in gens:
                temp = tuple([gen[x] for x in b])
                if temp not in used:
                    orb.append(temp)
                    used.add(temp)
        return set(orb)
    elif action == 'sets':
        # 计算集合轨道
        alpha = frozenset(alpha)
        orb = [alpha]
        used = {alpha}
        for b in orb:
            for gen in gens:
                temp = frozenset([gen[x] for x in b])
                if temp not in used:
                    orb.append(temp)
                    used.add(temp)
        return {tuple(x) for x in orb}


# 计算生成元 alpha 的轨道并返回其代表元素的列表
def _orbits(degree, generators):
    """Compute the orbits of G.

    If ``rep=False`` it returns a list of sets else it returns a list of
    representatives of the orbits

    Examples
    ========

    >>> from sympy.combinatorics import Permutation
    >>> from sympy.combinatorics.perm_groups import _orbits
    >>> a = Permutation([0, 2, 1])
    >>> b = Permutation([1, 0, 2])
    >>> _orbits(a.size, [a, b])
    [{0, 1, 2}]
    """

    orbs = []
    sorted_I = list(range(degree))
    # 将排序后的索引列表 sorted_I 转换为集合 I
    I = set(sorted_I)
    
    # 当集合 I 非空时循环执行以下操作
    while I:
        # 取排序后索引列表的第一个元素作为当前索引 i
        i = sorted_I[0]
        
        # 计算索引 i 的轨道（orbit），使用给定的 degree 和 generators 参数
        orb = _orbit(degree, generators, i)
        
        # 将计算得到的轨道 orb 添加到 orbs 列表中
        orbs.append(orb)
        
        # 从集合 I 中移除属于此轨道 orb 的所有索引
        I -= orb
        
        # 重新生成 sorted_I 列表，移除已经在轨道 orb 中的索引
        sorted_I = [i for i in sorted_I if i not in orb]
    
    # 返回计算得到的轨道列表 orbs
    return orbs
# 计算轨道的横断面，返回一个集合

def _orbit_transversal(degree, generators, alpha, pairs, af=False, slp=False):
    r"""Computes a transversal for the orbit of ``alpha`` as a set.

    Explanation
    ===========

    generators   generators of the group ``G``

    For a permutation group ``G``, a transversal for the orbit
    `Orb = \{g(\alpha) | g \in G\}` is a set
    `\{g_\beta | g_\beta(\alpha) = \beta\}` for `\beta \in Orb`.
    Note that there may be more than one possible transversal.
    If ``pairs`` is set to ``True``, it returns the list of pairs
    `(\beta, g_\beta)`. For a proof of correctness, see [1], p.79

    if ``af`` is ``True``, the transversal elements are given in
    array form.

    If `slp` is `True`, a dictionary `{beta: slp_beta}` is returned
    for `\beta \in Orb` where `slp_beta` is a list of indices of the
    generators in `generators` s.t. if `slp_beta = [i_1 \dots i_n]`
    `g_\beta = generators[i_n] \times \dots \times generators[i_1]`.

    Examples
    ========

    >>> from sympy.combinatorics.named_groups import DihedralGroup
    >>> from sympy.combinatorics.perm_groups import _orbit_transversal
    >>> G = DihedralGroup(6)
    >>> _orbit_transversal(G.degree, G.generators, 0, False)
    [(5), (0 1 2 3 4 5), (0 5)(1 4)(2 3), (0 2 4)(1 3 5), (5)(0 4)(1 3), (0 3)(1 4)(2 5)]
    """

    # 初始化轨道横断面列表，初始为包含 alpha 的一对 (alpha, [0, 1, ..., degree-1])
    tr = [(alpha, list(range(degree)))]

    # 初始化 SLIP 字典，包含 alpha 对应的空列表
    slp_dict = {alpha: []}

    # 初始化已使用标记列表，全部为 False
    used = [False]*degree
    used[alpha] = True

    # 将 generators 转换为 array form 的列表
    gens = [x._array_form for x in generators]

    # 开始计算轨道的横断面
    for x, px in tr:
        px_slp = slp_dict[x]
        for gen in gens:
            temp = gen[x]
            if used[temp] == False:
                slp_dict[temp] = [gens.index(gen)] + px_slp
                tr.append((temp, _af_rmul(gen, px)))
                used[temp] = True

    # 如果需要返回 pairs
    if pairs:
        if not af:
            # 如果 af 不为 True，则返回形如 (beta, g_beta) 的列表
            tr = [(x, _af_new(y)) for x, y in tr]
        if not slp:
            return tr
        # 如果 slp 为 True，则同时返回 SLIP 字典
        return tr, slp_dict

    # 如果需要返回 af
    if af:
        # 只返回横断面的列表
        tr = [y for _, y in tr]
        if not slp:
            return tr
        # 如果 slp 为 True，则同时返回 SLIP 字典
        return tr, slp_dict

    # 否则返回正常的横断面列表
    tr = [_af_new(y) for _, y in tr]
    if not slp:
        return tr
    # 如果 slp 为 True，则同时返回 SLIP 字典
    return tr, slp_dict


# 返回 alpha 的稳定化子群

def _stabilizer(degree, generators, alpha):
    r"""Return the stabilizer subgroup of ``alpha``.

    Explanation
    ===========

    The stabilizer of `\alpha` is the group `G_\alpha =
    \{g \in G | g(\alpha) = \alpha\}`.
    For a proof of correctness, see [1], p.79.

    degree :       degree of G
    generators :   generators of G

    Examples
    ========

    >>> from sympy.combinatorics.perm_groups import _stabilizer
    >>> from sympy.combinatorics.named_groups import DihedralGroup
    >>> G = DihedralGroup(6)
    >>> _stabilizer(G.degree, G.generators, 5)
    [(5)(0 4)(1 3), (5)]

    See Also
    ========

    orbit

    """

    # 初始化轨道列表，包含 alpha
    orb = [alpha]

    # 初始化表和逆表，alpha 对应到整数序列的映射
    table = {alpha: list(range(degree))}
    table_inv = {alpha: list(range(degree))}

    # 初始化已使用标记列表，全部为 False
    used = [False]*degree
    used[alpha] = True

    # 将 generators 转换为 array form 的列表
    gens = [x._array_form for x in generators]

    # 稳定化子群的生成元列表
    stab_gens = []
    # 对于输入的 orb 列表中的每个元素 b，依次执行以下操作
    for b in orb:
        # 对于生成元素列表 gens 中的每个元素 gen，依次执行以下操作
        for gen in gens:
            # 从生成元素 gen 中获取元素 b 对应的值，并存储在 temp 变量中
            temp = gen[b]
            # 如果 used 中 temp 对应的值为 False（表示 temp 尚未被使用过）
            if used[temp] is False:
                # 将 gen 与 table[b] 的右乘结果存储在 gen_temp 中
                gen_temp = _af_rmul(gen, table[b])
                # 将 temp 添加到 orb 列表末尾
                orb.append(temp)
                # 将 gen_temp 存储在 table[temp] 中
                table[temp] = gen_temp
                # 将 gen_temp 的逆存储在 table_inv[temp] 中
                table_inv[temp] = _af_invert(gen_temp)
                # 将 used[temp] 标记为 True，表示 temp 已经被使用过
                used[temp] = True
            else:
                # 计算 table_inv[temp] 与 gen 的右乘结果，并存储在 schreier_gen 中
                schreier_gen = _af_rmuln(table_inv[temp], gen, table[b])
                # 如果 schreier_gen 不在 stab_gens 列表中
                if schreier_gen not in stab_gens:
                    # 将 schreier_gen 添加到 stab_gens 列表末尾
                    stab_gens.append(schreier_gen)
    # 返回 stab_gens 列表中每个元素经过 _af_new 处理后的结果组成的列表
    return [_af_new(x) for x in stab_gens]
PermGroup = PermutationGroup

# 将 PermutationGroup 赋值给 PermGroup，简化后续代码中的引用


class SymmetricPermutationGroup(Basic):
    """
    The class defining the lazy form of SymmetricGroup.

    deg : int

    """
    def __new__(cls, deg):
        deg = _sympify(deg)
        obj = Basic.__new__(cls, deg)
        return obj

    def __init__(self, *args, **kwargs):
        self._deg = self.args[0]
        self._order = None

# 定义 SymmetricPermutationGroup 类，表示对称置换群的惰性形式，其中 deg 表示阶数


    def __contains__(self, i):
        """Return ``True`` if *i* is contained in SymmetricPermutationGroup.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation, SymmetricPermutationGroup
        >>> G = SymmetricPermutationGroup(4)
        >>> Permutation(1, 2, 3) in G
        True

        """
        if not isinstance(i, Permutation):
            raise TypeError("A SymmetricPermutationGroup contains only Permutations as "
                            "elements, not elements of type %s" % type(i))
        return i.size == self.degree

# 定义 __contains__ 方法，判断是否包含给定的置换对象，只能包含 Permutation 类型的元素


    def order(self):
        """
        Return the order of the SymmetricPermutationGroup.

        Examples
        ========

        >>> from sympy.combinatorics import SymmetricPermutationGroup
        >>> G = SymmetricPermutationGroup(4)
        >>> G.order()
        24
        """
        if self._order is not None:
            return self._order
        n = self._deg
        self._order = factorial(n)
        return self._order

# 定义 order 方法，返回 SymmetricPermutationGroup 的阶乘数


    @property
    def degree(self):
        """
        Return the degree of the SymmetricPermutationGroup.

        Examples
        ========

        >>> from sympy.combinatorics import SymmetricPermutationGroup
        >>> G = SymmetricPermutationGroup(4)
        >>> G.degree
        4

        """
        return self._deg

# 定义 degree 属性，返回 SymmetricPermutationGroup 的阶数


    @property
    def identity(self):
        '''
        Return the identity element of the SymmetricPermutationGroup.

        Examples
        ========

        >>> from sympy.combinatorics import SymmetricPermutationGroup
        >>> G = SymmetricPermutationGroup(4)
        >>> G.identity()
        (3)

        '''
        return _af_new(list(range(self._deg)))

# 定义 identity 属性，返回 SymmetricPermutationGroup 的单位元素


class Coset(Basic):
    """A left coset of a permutation group with respect to an element.

    Parameters
    ==========

    g : Permutation

    H : PermutationGroup

    dir : "+" or "-", If not specified by default it will be "+"
        here ``dir`` specified the type of coset "+" represent the
        right coset and "-" represent the left coset.

    G : PermutationGroup, optional
        The group which contains *H* as its subgroup and *g* as its
        element.

        If not specified, it would automatically become a symmetric
        group ``SymmetricPermutationGroup(g.size)`` and
        ``SymmetricPermutationGroup(H.degree)`` if ``g.size`` and ``H.degree``
        are matching.``SymmetricPermutationGroup`` is a lazy form of SymmetricGroup
        used for representation purpose.

    """

# 定义 Coset 类，表示置换群关于某个元素的左陪集```
    def __new__(cls, g, H, G=None, dir="+"):
        g = _sympify(g)
        # 将输入的 g 转换为符号表示（若可能），确保是 Permutation 类型
        if not isinstance(g, Permutation):
            raise NotImplementedError

        H = _sympify(H)
        # 将输入的 H 转换为符号表示（若可能），确保是 PermutationGroup 类型
        if not isinstance(H, PermutationGroup):
            raise NotImplementedError

        if G is not None:
            G = _sympify(G)
            # 将输入的 G 转换为符号表示（若可能），确保是 PermutationGroup 或 SymmetricPermutationGroup 类型
            if not isinstance(G, (PermutationGroup, SymmetricPermutationGroup)):
                raise NotImplementedError
            # 检查 H 是否是 G 的子群
            if not H.is_subgroup(G):
                raise ValueError("{} must be a subgroup of {}.".format(H, G))
            # 检查 g 是否属于 G
            if g not in G:
                raise ValueError("{} must be an element of {}.".format(g, G))
        else:
            g_size = g.size
            h_degree = H.degree
            # 检查 g 的大小与 H 的度数是否匹配
            if g_size != h_degree:
                raise ValueError(
                    "The size of the permutation {} and the degree of "
                    "the permutation group {} should be matching "
                    .format(g, H))
            # 若 G 未提供，则创建一个大小为 g.size 的 SymmetricPermutationGroup
            G = SymmetricPermutationGroup(g.size)

        if isinstance(dir, str):
            dir = Symbol(dir)
        elif not isinstance(dir, Symbol):
            # 确保 dir 是字符串或符号类型，否则引发类型错误
            raise TypeError("dir must be of type basestring or "
                    "Symbol, not %s" % type(dir))
        # 确保 dir 是 '+' 或 '-' 中的一个
        if str(dir) not in ('+', '-'):
            raise ValueError("dir must be one of '+' or '-' not %s" % dir)
        # 使用基类 Basic 的 __new__ 方法创建对象
        obj = Basic.__new__(cls, g, H, G, dir)
        return obj

    def __init__(self, *args, **kwargs):
        # 初始化函数，获取第四个参数作为方向属性 _dir
        self._dir = self.args[3]

    @property
    def is_left_coset(self):
        """
        检查余等类是否为左余等类，即 gH。
        """
        return str(self._dir) == '-'

    @property
    def is_right_coset(self):
        """
        检查余等类是否为右余等类，即 Hg。
        """
        return str(self._dir) == '+'

    def as_list(self):
        """
        返回余等类中所有元素的列表形式。
        """
        g = self.args[0]
        H = self.args[1]
        cst = []
        if str(self._dir) == '+':
            # 若方向为 '+', 则生成 g * h 的结果列表
            for h in H.elements:
                cst.append(h * g)
        else:
            # 若方向为 '-', 则生成 g * h 的结果列表
            for h in H.elements:
                cst.append(g * h)
        return cst
```