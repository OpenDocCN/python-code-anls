# `D:\src\scipysrc\sympy\sympy\parsing\latex\_antlr\latexparser.py`

```
# *** GENERATED BY `setup.py antlr`, DO NOT EDIT BY HAND ***

# 从antlr4库中导入所有内容
from antlr4 import *
# 从io库中导入StringIO类
from io import StringIO
# 导入sys模块
import sys

# 根据Python版本导入不同的TextIO类型
if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO

# 定义serializedATN函数
def serializedATN():
    # 返回serializedATN函数的空列表
    return []

# 定义LaTeXParser类，继承自Parser类
class LaTeXParser(Parser):
    # 指定语法文件名为"LaTeX.g4"
    grammarFileName = "LaTeX.g4"
    
    # 使用ATNDeserializer类反序列化serializedATN()函数的返回值，生成atn对象
    atn = ATNDeserializer().deserialize(serializedATN())
    
    # 将atn.decisionToState中的每个ds，生成一个DFA对象，并存放在decisionsToDFA列表中
    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]
    
    # 创建共享的预测上下文缓存对象
    sharedContextCache = PredictionContextCache()

    # 定义literalNames列表，包含一系列字符串
    literalNames = [
        "<INVALID>", "','", "'.'", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "'\\quad'", "'\\qquad'",
        "<INVALID>", "'\\negmedspace'", "'\\negthickspace'",
        "'\\left'", "'\\right'", "<INVALID>", "'+'", "'-'",
        "'*'", "'/'", "'('", "')'", "'{'", "'}'", "'\\{'",
        "'\\}'", "'['", "']'", "'|'", "'\\right|'", "'\\left|'",
        "'\\langle'", "'\\rangle'", "'\\lim'", "<INVALID>",
        "<INVALID>", "'\\sum'", "'\\prod'", "'\\exp'", "'\\log'",
        "'\\lg'", "'\\ln'", "'\\sin'", "'\\cos'", "'\\tan'",
        "'\\csc'", "'\\sec'", "'\\cot'", "'\\arcsin'", "'\\arccos'",
        "'\\arctan'", "'\\arccsc'", "'\\arcsec'", "'\\arccot'",
        "'\\sinh'", "'\\cosh'", "'\\tanh'", "'\\arsinh'", "'\\arcosh'",
        "'\\artanh'", "'\\lfloor'", "'\\rfloor'", "'\\lceil'",
        "'\\rceil'", "'\\sqrt'", "'\\overline'", "'\\times'",
        "'\\cdot'", "'\\div'", "<INVALID>", "'\\binom'", "'\\dbinom'",
        "'\\tbinom'", "'\\mathit'", "'_'", "'^'", "':'", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "'\\neq'", "'<'",
        "<INVALID>", "'\\leqq'", "'\\leqslant'", "'>'", "<INVALID>",
        "'\\geqq'", "'\\geqslant'", "'!'"
    ]
    # 定义一个列表，包含一些特定的符号名称，使用 "<INVALID>" 占位符填充空余位置
    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "WS", "THINSPACE",
                      "MEDSPACE", "THICKSPACE", "QUAD", "QQUAD", "NEGTHINSPACE",
                      "NEGMEDSPACE", "NEGTHICKSPACE", "CMD_LEFT", "CMD_RIGHT",
                      "IGNORE", "ADD", "SUB", "MUL", "DIV", "L_PAREN", "R_PAREN",
                      "L_BRACE", "R_BRACE", "L_BRACE_LITERAL", "R_BRACE_LITERAL",
                      "L_BRACKET", "R_BRACKET", "BAR", "R_BAR", "L_BAR",
                      "L_ANGLE", "R_ANGLE", "FUNC_LIM", "LIM_APPROACH_SYM",
                      "FUNC_INT", "FUNC_SUM", "FUNC_PROD", "FUNC_EXP", "FUNC_LOG",
                      "FUNC_LG", "FUNC_LN", "FUNC_SIN", "FUNC_COS", "FUNC_TAN",
                      "FUNC_CSC", "FUNC_SEC", "FUNC_COT", "FUNC_ARCSIN",
                      "FUNC_ARCCOS", "FUNC_ARCTAN", "FUNC_ARCCSC", "FUNC_ARCSEC",
                      "FUNC_ARCCOT", "FUNC_SINH", "FUNC_COSH", "FUNC_TANH",
                      "FUNC_ARSINH", "FUNC_ARCOSH", "FUNC_ARTANH", "L_FLOOR",
                      "R_FLOOR", "L_CEIL", "R_CEIL", "FUNC_SQRT", "FUNC_OVERLINE",
                      "CMD_TIMES", "CMD_CDOT", "CMD_DIV", "CMD_FRAC", "CMD_BINOM",
                      "CMD_DBINOM", "CMD_TBINOM", "CMD_MATHIT", "UNDERSCORE",
                      "CARET", "COLON", "DIFFERENTIAL", "LETTER", "DIGIT",
                      "EQUAL", "NEQ", "LT", "LTE", "LTE_Q", "LTE_S", "GT",
                      "GTE", "GTE_Q", "GTE_S", "BANG", "SINGLE_QUOTES",
                      "SYMBOL" ]

    # 定义一系列规则常量，用于标识不同的语法规则
    RULE_math = 0
    RULE_relation = 1
    RULE_equality = 2
    RULE_expr = 3
    RULE_additive = 4
    RULE_mp = 5
    RULE_mp_nofunc = 6
    RULE_unary = 7
    RULE_unary_nofunc = 8
    RULE_postfix = 9
    RULE_postfix_nofunc = 10
    RULE_postfix_op = 11
    RULE_eval_at = 12
    RULE_eval_at_sub = 13
    RULE_eval_at_sup = 14
    RULE_exp = 15
    RULE_exp_nofunc = 16
    RULE_comp = 17
    RULE_comp_nofunc = 18
    RULE_group = 19
    RULE_abs_group = 20
    RULE_number = 21
    RULE_atom = 22
    RULE_bra = 23
    RULE_ket = 24
    RULE_mathit = 25
    RULE_mathit_text = 26
    RULE_frac = 27
    RULE_binom = 28
    RULE_floor = 29
    RULE_ceil = 30
    RULE_func_normal = 31
    RULE_func = 32
    RULE_args = 33
    RULE_limit_sub = 34
    RULE_func_arg = 35
    RULE_func_arg_noparens = 36
    RULE_subexpr = 37
    RULE_supexpr = 38
    RULE_subeq = 39
    RULE_supeq = 40
    # 定义一个列表，包含数学表达式语法规则的名称
    ruleNames =  [ "math", "relation", "equality", "expr", "additive", "mp",
                   "mp_nofunc", "unary", "unary_nofunc", "postfix", "postfix_nofunc",
                   "postfix_op", "eval_at", "eval_at_sub", "eval_at_sup",
                   "exp", "exp_nofunc", "comp", "comp_nofunc", "group",
                   "abs_group", "number", "atom", "bra", "ket", "mathit",
                   "mathit_text", "frac", "binom", "floor", "ceil", "func_normal",
                   "func", "args", "limit_sub", "func_arg", "func_arg_noparens",
                   "subexpr", "supexpr", "subeq", "supeq" ]
    
    # 定义一个常量，表示文法分析器已到达输入流的末尾
    EOF = Token.EOF
    
    # 下面的代码定义了大量的常量，每个常量对应于文法中的一个特定的词法标记或语法规则
    T__0=1
    T__1=2
    WS=3
    THINSPACE=4
    MEDSPACE=5
    THICKSPACE=6
    QUAD=7
    QQUAD=8
    NEGTHINSPACE=9
    NEGMEDSPACE=10
    NEGTHICKSPACE=11
    CMD_LEFT=12
    CMD_RIGHT=13
    IGNORE=14
    ADD=15
    SUB=16
    MUL=17
    DIV=18
    L_PAREN=19
    R_PAREN=20
    L_BRACE=21
    R_BRACE=22
    L_BRACE_LITERAL=23
    R_BRACE_LITERAL=24
    L_BRACKET=25
    R_BRACKET=26
    BAR=27
    R_BAR=28
    L_BAR=29
    L_ANGLE=30
    R_ANGLE=31
    FUNC_LIM=32
    LIM_APPROACH_SYM=33
    FUNC_INT=34
    FUNC_SUM=35
    FUNC_PROD=36
    FUNC_EXP=37
    FUNC_LOG=38
    FUNC_LG=39
    FUNC_LN=40
    FUNC_SIN=41
    FUNC_COS=42
    FUNC_TAN=43
    FUNC_CSC=44
    FUNC_SEC=45
    FUNC_COT=46
    FUNC_ARCSIN=47
    FUNC_ARCCOS=48
    FUNC_ARCTAN=49
    FUNC_ARCCSC=50
    FUNC_ARCSEC=51
    FUNC_ARCCOT=52
    FUNC_SINH=53
    FUNC_COSH=54
    FUNC_TANH=55
    FUNC_ARSINH=56
    FUNC_ARCOSH=57
    FUNC_ARTANH=58
    L_FLOOR=59
    R_FLOOR=60
    L_CEIL=61
    R_CEIL=62
    FUNC_SQRT=63
    FUNC_OVERLINE=64
    CMD_TIMES=65
    CMD_CDOT=66
    CMD_DIV=67
    CMD_FRAC=68
    CMD_BINOM=69
    CMD_DBINOM=70
    CMD_TBINOM=71
    CMD_MATHIT=72
    UNDERSCORE=73
    CARET=74
    COLON=75
    DIFFERENTIAL=76
    LETTER=77
    DIGIT=78
    EQUAL=79
    NEQ=80
    LT=81
    LTE=82
    LTE_Q=83
    LTE_S=84
    GT=85
    GTE=86
    GTE_Q=87
    GTE_S=88
    BANG=89
    SINGLE_QUOTES=90
    SYMBOL=91
    
    # 构造函数，初始化一个 LaTeXParser 对象
    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        # 调用父类的构造函数，初始化输入和输出
        super().__init__(input, output)
        # 检查文法版本是否为 "4.11.1"
        self.checkVersion("4.11.1")
        # 创建解析器的 ATN 模拟器对象
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        # 初始化预测集合
        self._predicates = None
    
    # 定义一个内部类 MathContext，表示数学表达式的上下文
    class MathContext(ParserRuleContext):
        # 仅定义一个成员变量 parser
        __slots__ = 'parser'
    
        # 构造函数，初始化 MathContext 对象
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的构造函数
            super().__init__(parent, invokingState)
            # 将传入的解析器对象保存到成员变量中
            self.parser = parser
    
        # 返回数学表达式中的 relation 上下文对象
        def relation(self):
            return self.getTypedRuleContext(LaTeXParser.RelationContext,0)
    
        # 返回当前规则的索引，此处为 math 规则
        def getRuleIndex(self):
            return LaTeXParser.RULE_math
    # 定义 math 方法，用于处理数学表达式的解析
    def math(self):
        # 创建一个 MathContext 对象，用于解析数学表达式
        localctx = LaTeXParser.MathContext(self, self._ctx, self.state)
        # 进入 math 规则，设置初始状态
        self.enterRule(localctx, 0, self.RULE_math)
        try:
            # 进入外部选项1
            self.enterOuterAlt(localctx, 1)
            # 设置状态为82，并调用 relation 方法
            self.state = 82
            self.relation(0)
        except RecognitionException as re:
            # 捕捉到识别异常，报告错误并进行恢复
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出当前规则
            self.exitRule()
        # 返回解析后的结果
        return localctx


    # 定义 RelationContext 类，用于处理表达式的关系比较
    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 返回一个 ExprContext 类型的上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)

        # 返回一个或多个 RelationContext 类型的上下文
        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.RelationContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.RelationContext, i)

        # 返回 EQUAL 标记的 token
        def EQUAL(self):
            return self.getToken(LaTeXParser.EQUAL, 0)

        # 返回 LT 标记的 token
        def LT(self):
            return self.getToken(LaTeXParser.LT, 0)

        # 返回 LTE 标记的 token
        def LTE(self):
            return self.getToken(LaTeXParser.LTE, 0)

        # 返回 GT 标记的 token
        def GT(self):
            return self.getToken(LaTeXParser.GT, 0)

        # 返回 GTE 标记的 token
        def GTE(self):
            return self.getToken(LaTeXParser.GTE, 0)

        # 返回 NEQ 标记的 token
        def NEQ(self):
            return self.getToken(LaTeXParser.NEQ, 0)

        # 返回规则索引 LaTeXParser.RULE_relation
        def getRuleIndex(self):
            return LaTeXParser.RULE_relation
    # 定义一个方法relation，用于处理关系表达式，_p是递归深度的参数，默认为0
    def relation(self, _p:int=0):
        # 缓存当前的上下文和状态
        _parentctx = self._ctx
        _parentState = self.state
        # 创建一个新的上下文对象用于处理关系表达式
        localctx = LaTeXParser.RelationContext(self, self._ctx, _parentState)
        # 缓存当前的上下文作为前一个上下文
        _prevctx = localctx
        # 记录进入规则的起始状态
        _startState = 2
        # 进入递归规则，指定局部上下文、规则类型和递归深度参数
        self.enterRecursionRule(localctx, 2, self.RULE_relation, _p)
        # 初始化token类型为0
        self._la = 0 # Token type
        try:
            # 进入外部替代路径，开始处理关系表达式
            self.enterOuterAlt(localctx, 1)
            # 处理表达式，可能涉及到解析其他规则
            self.state = 85
            self.expr()
            # 设置当前上下文的停止位置为当前输入的LT(-1)位置
            self._ctx.stop = self._input.LT(-1)
            # 处理可能的下一个状态
            self.state = 92
            # 同步处理可能出现的错误
            self._errHandler.sync(self)
            # 根据输入的预测来选择路径
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    # 如果有解析监听器，触发退出规则事件
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 更新前一个上下文
                    _prevctx = localctx
                    # 创建一个新的关系上下文对象，继承父上下文和状态
                    localctx = LaTeXParser.RelationContext(self, _parentctx, _parentState)
                    # 推入新的递归上下文，指定起始状态和规则类型
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_relation)
                    # 检查是否符合先前的条件断言，如果不符合，则引发异常
                    self.state = 87
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    # 获取下一个token
                    self.state = 88
                    _la = self._input.LA(1)
                    # 检查是否满足特定的条件来消耗或报告匹配
                    if not((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 207) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    # 处理关系表达式的递归，深度为3
                    self.state = 89
                    self.relation(3)
                # 同步处理可能出现的错误
                self.state = 94
                self._errHandler.sync(self)
                # 根据输入的预测来选择路径
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            # 报告解析过程中出现的异常错误
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恢复解析过程
            self._errHandler.recover(self, re)
        finally:
            # 滚动展开递归上下文到父上下文
            self.unrollRecursionContexts(_parentctx)
        # 返回处理结果的局部上下文对象
        return localctx
    # 定义名为 `equality` 的方法，处理 LaTeXParser.EqualityContext 上下文
    def equality(self):
        # 创建一个局部上下文 `localctx`，表示当前解析的上下文
        localctx = LaTeXParser.EqualityContext(self, self._ctx, self.state)
        # 进入规则处理阶段，设置进入规则的动作
        self.enterRule(localctx, 4, self.RULE_equality)
        try:
            # 进入外层交替处理块
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 95，调用 `expr` 方法处理表达式
            self.state = 95
            self.expr()
            # 匹配等号
            self.state = 96
            self.match(LaTeXParser.EQUAL)
            # 调用 `expr` 方法处理表达式
            self.state = 97
            self.expr()
        except RecognitionException as re:
            # 捕获解析异常，并将其记录和恢复
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则处理阶段
            self.exitRule()
        # 返回局部上下文 `localctx`
        return localctx


    # 定义名为 `ExprContext` 的类，表示表达式的上下文
    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类初始化方法
            super().__init__(parent, invokingState)
            # 设置解析器对象
            self.parser = parser

        # 返回 `additive` 规则的上下文
        def additive(self):
            return self.getTypedRuleContext(LaTeXParser.AdditiveContext,0)

        # 获取规则索引，返回 `LaTeXParser.RULE_expr`
        def getRuleIndex(self):
            return LaTeXParser.RULE_expr




    # 定义名为 `expr` 的方法，处理 LaTeXParser.ExprContext 上下文
    def expr(self):
        # 创建一个局部上下文 `localctx`，表示当前解析的上下文
        localctx = LaTeXParser.ExprContext(self, self._ctx, self.state)
        # 进入规则处理阶段，设置进入规则的动作
        self.enterRule(localctx, 6, self.RULE_expr)
        try:
            # 进入外层交替处理块
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 99，调用 `additive` 方法处理加法表达式
            self.state = 99
            self.additive(0)
        except RecognitionException as re:
            # 捕获解析异常，并将其记录和恢复
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则处理阶段
            self.exitRule()
        # 返回局部上下文 `localctx`
        return localctx


    # 定义名为 `AdditiveContext` 的类，表示加法表达式的上下文
    class AdditiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类初始化方法
            super().__init__(parent, invokingState)
            # 设置解析器对象
            self.parser = parser

        # 返回 `mp` 规则的上下文
        def mp(self):
            return self.getTypedRuleContext(LaTeXParser.MpContext,0)

        # 返回指定索引的 `AdditiveContext` 规则上下文
        def additive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.AdditiveContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.AdditiveContext,i)

        # 获取 `ADD` token
        def ADD(self):
            return self.getToken(LaTeXParser.ADD, 0)

        # 获取 `SUB` token
        def SUB(self):
            return self.getToken(LaTeXParser.SUB, 0)

        # 获取规则索引，返回 `LaTeXParser.RULE_additive`
        def getRuleIndex(self):
            return LaTeXParser.RULE_additive
    # 定义一个方法 additive，接受一个默认参数 _p（整数，默认为0）
    def additive(self, _p:int=0):
        # 获取当前上下文和状态
        _parentctx = self._ctx
        _parentState = self.state
        # 创建一个新的 AdditiveContext 对象作为本地上下文
        localctx = LaTeXParser.AdditiveContext(self, self._ctx, _parentState)
        # 将当前上下文设为前一个上下文
        _prevctx = localctx
        # 设定起始状态为8，并进入递归规则
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_additive, _p)
        # 初始化 token 类型为0
        self._la = 0 # Token type
        try:
            # 进入外层交替路径
            self.enterOuterAlt(localctx, 1)
            # 状态设为102，调用 mp 方法
            self.state = 102
            self.mp(0)
            # 设置上下文停止位置为当前输入流的上一个 token
            self._ctx.stop = self._input.LT(-1)
            # 状态设为109，进行错误处理同步
            self.state = 109
            # 使用自适应预测方法预测下一个输入
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            # 当预测不为2且不为无效的备用路径时执行以下循环
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                # 如果存在解析监听器，则触发退出规则事件
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 将当前上下文设为新的递归上下文
                    _prevctx = localctx
                    localctx = LaTeXParser.AdditiveContext(self, _parentctx, _parentState)
                    # 推入新的递归上下文
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_additive)
                    # 状态设为104，如果前置条件不满足则引发失败的断言异常
                    self.state = 104
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    # 状态设为105，获取下一个 token 类型
                    self.state = 105
                    _la = self._input.LA(1)
                    # 如果不是 token 类型 15 或 16，则尝试内联恢复
                    if not(_la==15 or _la==16):
                        self._errHandler.recoverInline(self)
                    else:
                        # 否则报告匹配成功并消耗该 token
                        self._errHandler.reportMatch(self)
                        self.consume()
                    # 状态设为106，调用 additive 方法，参数设为3
                    self.state = 106
                    self.additive(3)
                # 状态设为111，进行错误处理同步
                self.state = 111
                self._errHandler.sync(self)
                # 使用自适应预测方法预测下一个输入
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        # 捕获 RecognitionException 异常并报告
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恢复上下文
            self._errHandler.recover(self, re)
        finally:
            # 展开所有递归上下文
            self.unrollRecursionContexts(_parentctx)
        # 返回 localctx
        return localctx
    # 定义 MpContext 类，表示语法分析器的上下文
    class MpContext(ParserRuleContext):
        # 定义 __slots__ 属性，限定实例可以拥有的属性，这里只包括 'parser'
        __slots__ = 'parser'

        # 初始化方法，接受 parser 对象和可选的父节点和状态值
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 设置实例变量 parser 为传入的 parser 对象
            self.parser = parser

        # 定义 unary 方法，返回类型为 UnaryContext 的上下文对象
        def unary(self):
            return self.getTypedRuleContext(LaTeXParser.UnaryContext,0)

        # 定义 mp 方法，如果指定了索引 i，返回第 i 个 MpContext 上下文对象，否则返回所有 MpContext 对象的列表
        def mp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.MpContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.MpContext,i)

        # 定义 MUL 方法，返回标记为 LaTeXParser.MUL 的 token 对象
        def MUL(self):
            return self.getToken(LaTeXParser.MUL, 0)

        # 定义 CMD_TIMES 方法，返回标记为 LaTeXParser.CMD_TIMES 的 token 对象
        def CMD_TIMES(self):
            return self.getToken(LaTeXParser.CMD_TIMES, 0)

        # 定义 CMD_CDOT 方法，返回标记为 LaTeXParser.CMD_CDOT 的 token 对象
        def CMD_CDOT(self):
            return self.getToken(LaTeXParser.CMD_CDOT, 0)

        # 定义 DIV 方法，返回标记为 LaTeXParser.DIV 的 token 对象
        def DIV(self):
            return self.getToken(LaTeXParser.DIV, 0)

        # 定义 CMD_DIV 方法，返回标记为 LaTeXParser.CMD_DIV 的 token 对象
        def CMD_DIV(self):
            return self.getToken(LaTeXParser.CMD_DIV, 0)

        # 定义 COLON 方法，返回标记为 LaTeXParser.COLON 的 token 对象
        def COLON(self):
            return self.getToken(LaTeXParser.COLON, 0)

        # 定义 getRuleIndex 方法，返回该上下文对象对应的规则索引 LaTeXParser.RULE_mp
        def getRuleIndex(self):
            return LaTeXParser.RULE_mp
    # 定义一个方法 mp，接受一个名为 _p 的整数参数，默认为 0
    def mp(self, _p:int=0):
        # 备份当前解析器上下文和状态
        _parentctx = self._ctx
        _parentState = self.state
        # 创建当前方法的解析上下文 localctx，并记录之前的上下文和状态
        localctx = LaTeXParser.MpContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        # 进入递归规则，将当前方法设置为递归调用的起点
        self.enterRecursionRule(localctx, 10, self.RULE_mp, _p)
        # 初始化 token 类型为 0
        self._la = 0  # Token type
        try:
            # 进入第一个分支，即第一次递归调用
            self.enterOuterAlt(localctx, 1)
            # 调用 unary 方法，进行解析
            self.state = 113
            self.unary()
            # 设置当前上下文的停止位置为当前输入的前一个 token
            self._ctx.stop = self._input.LT(-1)
            # 进入循环，开始处理递归调用的其他分支
            self.state = 120
            self._errHandler.sync(self)
            # 使用自适应预测器进行下一个 token 的预测
            _alt = self._interp.adaptivePredict(self._input, 2, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    # 如果有解析监听器，触发退出规则事件
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 备份当前上下文，为下一个递归调用做准备
                    _prevctx = localctx
                    # 创建新的解析上下文 localctx，传入父上下文和状态
                    localctx = LaTeXParser.MpContext(self, _parentctx, _parentState)
                    # 将新的上下文推入递归上下文堆栈中
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_mp)
                    self.state = 115
                    # 检查前一个上下文的预测条件是否满足
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    # 消耗当前输入的下一个 token
                    self.state = 116
                    _la = self._input.LA(1)
                    # 检查 token 是否符合特定条件
                    if not((((_la - 17)) & ~0x3f) == 0 and ((1 << (_la - 17)) & 290200700988686339) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    # 对当前方法进行第三次递归调用
                    self.state = 117
                    self.mp(3)
                # 继续同步错误处理器，准备下一个递归调用
                self.state = 122
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 2, self._ctx)
    
        except RecognitionException as re:
            # 如果有解析异常，报告异常并恢复解析器状态
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出递归上下文
            self.unrollRecursionContexts(_parentctx)
        # 返回最终解析上下文
        return localctx
    # 定义 Mp_nofuncContext 类，继承自 ParserRuleContext
    class Mp_nofuncContext(ParserRuleContext):
        # __slots__ 用于限制对象实例可以拥有的属性，这里只允许 'parser'
        __slots__ = 'parser'

        # 初始化方法，接受 parser 对象和可选的父 ParserRuleContext 和 invokingState 参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 将传入的 parser 对象保存到实例变量 self.parser 中
            self.parser = parser

        # 定义 unary_nofunc 方法，返回 Unary_nofuncContext 类型的上下文对象
        def unary_nofunc(self):
            return self.getTypedRuleContext(LaTeXParser.Unary_nofuncContext, 0)

        # 定义 mp_nofunc 方法，接受一个可选的整数参数 i，返回 Mp_nofuncContext 类型的上下文对象或对象数组
        def mp_nofunc(self, i:int=None):
            if i is None:
                # 如果 i 为 None，返回所有 Mp_nofuncContext 类型的上下文对象数组
                return self.getTypedRuleContexts(LaTeXParser.Mp_nofuncContext)
            else:
                # 否则返回第 i 个 Mp_nofuncContext 类型的上下文对象
                return self.getTypedRuleContext(LaTeXParser.Mp_nofuncContext, i)

        # 定义 MUL 方法，返回 'MUL' 标识符的 token
        def MUL(self):
            return self.getToken(LaTeXParser.MUL, 0)

        # 定义 CMD_TIMES 方法，返回 'CMD_TIMES' 标识符的 token
        def CMD_TIMES(self):
            return self.getToken(LaTeXParser.CMD_TIMES, 0)

        # 定义 CMD_CDOT 方法，返回 'CMD_CDOT' 标识符的 token
        def CMD_CDOT(self):
            return self.getToken(LaTeXParser.CMD_CDOT, 0)

        # 定义 DIV 方法，返回 'DIV' 标识符的 token
        def DIV(self):
            return self.getToken(LaTeXParser.DIV, 0)

        # 定义 CMD_DIV 方法，返回 'CMD_DIV' 标识符的 token
        def CMD_DIV(self):
            return self.getToken(LaTeXParser.CMD_DIV, 0)

        # 定义 COLON 方法，返回 'COLON' 标识符的 token
        def COLON(self):
            return self.getToken(LaTeXParser.COLON, 0)

        # 定义 getRuleIndex 方法，返回当前规则的索引（LaTeXParser 中的 RULE_mp_nofunc）
        def getRuleIndex(self):
            return LaTeXParser.RULE_mp_nofunc
    # 定义名为 mp_nofunc 的方法，接受一个名为 _p 的整数参数，默认值为 0
    def mp_nofunc(self, _p:int=0):
        # 保存当前上下文和状态信息
        _parentctx = self._ctx
        _parentState = self.state
        # 创建当前上下文对象 localctx，基于 Mp_nofuncContext 类
        localctx = LaTeXParser.Mp_nofuncContext(self, self._ctx, _parentState)
        # 将当前上下文对象 localctx 设置为前一个上下文对象 _prevctx
        _prevctx = localctx
        # 设置起始状态为 12，并进入递归规则
        _startState = 12
        self.enterRecursionRule(localctx, 12, self.RULE_mp_nofunc, _p)
        # 初始化 Token 类型 _la 为 0
        self._la = 0
        try:
            # 进入第一个交替分支
            self.enterOuterAlt(localctx, 1)
            # 执行 unary_nofunc 方法，设置 self.state 为 124
            self.state = 124
            self.unary_nofunc()
            # 设置当前上下文对象的停止位置
            self._ctx.stop = self._input.LT(-1)
            # 设置 self.state 为 131，同步错误处理器
            self.state = 131
            self._errHandler.sync(self)
            # 使用自适应预测方法，预测下一个动作
            _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)
            # 进入循环，直到预测到第二个交替分支或无效交替分支
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    # 如果存在解析监听器，触发退出规则事件
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 将当前上下文对象 localctx 设置为前一个上下文对象 _prevctx
                    _prevctx = localctx
                    # 创建新的递归上下文对象 localctx
                    localctx = LaTeXParser.Mp_nofuncContext(self, _parentctx, _parentState)
                    # 推入新的递归上下文，设置起始状态为 _startState，规则为 RULE_mp_nofunc
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_mp_nofunc)
                    # 如果不符合第二个交替分支的先行条件，抛出 FailedPredicateException 异常
                    self.state = 126
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    # 获取下一个输入的 Token 类型
                    self.state = 127
                    _la = self._input.LA(1)
                    # 如果 Token 类型不在指定范围内，则内联恢复错误处理
                    if not((((_la - 17)) & ~0x3f) == 0 and ((1 << (_la - 17)) & 290200700988686339) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    # 执行 mp_nofunc 方法，参数为 3
                    self.state = 128
                    self.mp_nofunc(3)
                # 同步错误处理器
                self.state = 133
                self._errHandler.sync(self)
                # 重新预测下一个动作
                _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)

        # 捕获 RecognitionException 异常并处理
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 解开所有递归上下文
            self.unrollRecursionContexts(_parentctx)
        # 返回最终的 localctx 对象
        return localctx
    # 定义名为 UnaryContext 的类，继承自 ParserRuleContext
    class UnaryContext(ParserRuleContext):
        # __slots__ 限定类的实例只能拥有 'parser' 这一个属性，优化内存使用
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 unary 方法，返回类型为 LaTeXParser.UnaryContext 的规则上下文
        def unary(self):
            return self.getTypedRuleContext(LaTeXParser.UnaryContext,0)

        # 定义 ADD 方法，返回 ADD 标识符的 token
        def ADD(self):
            return self.getToken(LaTeXParser.ADD, 0)

        # 定义 SUB 方法，返回 SUB 标识符的 token
        def SUB(self):
            return self.getToken(LaTeXParser.SUB, 0)

        # 定义 postfix 方法，根据索引返回单个或多个 LaTeXParser.PostfixContext 类型的规则上下文
        def postfix(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.PostfixContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.PostfixContext,i)

        # 返回当前规则的索引，用于标识当前规则在语法分析器中的位置
        def getRuleIndex(self):
            return LaTeXParser.RULE_unary



    # 定义 unary 方法
    def unary(self):
        # 创建 UnaryContext 实例 localctx，传入当前的解析器、上下文和状态
        localctx = LaTeXParser.UnaryContext(self, self._ctx, self.state)
        # 进入规则 unary，设置状态为 14，表示进入 unary 规则
        self.enterRule(localctx, 14, self.RULE_unary)
        self._la = 0 # Token type

        try:
            self.state = 141
            # 同步错误处理器，保证解析器和输入的同步
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15, 16]:
                # 进入外层选择1，处理 token 为 15 或 16 的情况
                self.enterOuterAlt(localctx, 1)
                self.state = 134
                _la = self._input.LA(1)
                if not(_la==15 or _la==16):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 135
                self.unary()
                pass
            elif token in [19, 21, 23, 25, 27, 29, 30, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 63, 64, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                # 进入外层选择2，处理 token 为指定数字的情况
                self.enterOuterAlt(localctx, 2)
                self.state = 137
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 136
                        self.postfix()

                    else:
                        raise NoViableAltException(self)
                    self.state = 139
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出当前规则
            self.exitRule()
        # 返回 localctx，即 UnaryContext 实例
        return localctx
    # 定义一个 ParserRuleContext 的子类，表示 unary_nofunc 规则的上下文
    class Unary_nofuncContext(ParserRuleContext):
        # __slots__ 限定该类的实例只能有 'parser' 这一个属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser 对象和可选的父节点和状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 返回 unary_nofunc 规则中的 Unary_nofuncContext 上下文对象
        def unary_nofunc(self):
            return self.getTypedRuleContext(LaTeXParser.Unary_nofuncContext,0)

        # 返回 ADD 标记的 token
        def ADD(self):
            return self.getToken(LaTeXParser.ADD, 0)

        # 返回 SUB 标记的 token
        def SUB(self):
            return self.getToken(LaTeXParser.SUB, 0)

        # 返回 postfix 规则中的 PostfixContext 上下文对象
        def postfix(self):
            return self.getTypedRuleContext(LaTeXParser.PostfixContext,0)

        # 返回 postfix_nofunc 规则中的 Postfix_nofuncContext 上下文对象，支持索引
        def postfix_nofunc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.Postfix_nofuncContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.Postfix_nofuncContext,i)

        # 返回当前规则在解析器中的索引，即 RULE_unary_nofunc 的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_unary_nofunc


    # 定义 unary_nofunc 方法
    def unary_nofunc(self):

        # 创建一个 Unary_nofuncContext 上下文对象，传入当前解析器、当前上下文和状态
        localctx = LaTeXParser.Unary_nofuncContext(self, self._ctx, self.state)
        
        # 进入规则 unary_nofunc，规则索引为 16，状态进入
        self.enterRule(localctx, 16, self.RULE_unary_nofunc)
        
        # 初始化 token 类型为 0
        self._la = 0 
        
        try:
            # 同步错误处理机制，获取第一个 token
            self.state = 152
            self._errHandler.sync(self)
            token = self._input.LA(1)
            
            # 根据 token 类型选择进入不同的语法分支
            if token in [15, 16]:  # 如果 token 是 15 或 16
                self.enterOuterAlt(localctx, 1)
                
                # 处理 ADD 或 SUB token
                self.state = 143
                _la = self._input.LA(1)
                
                # 如果不是 ADD 或 SUB token，则恢复内联错误处理
                if not(_la==15 or _la==16):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                
                # 解析 unary_nofunc 规则的内容
                self.state = 144
                self.unary_nofunc()
                pass
            
            # 如果 token 是 postfix 规则中的任意一种
            elif token in [19, 21, 23, 25, 27, 29, 30, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 63, 64, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                self.enterOuterAlt(localctx, 2)
                
                # 解析 postfix 规则内容
                self.state = 145
                self.postfix()
                
                # 同步错误处理，预测下一个语法分支
                self.state = 149
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
                
                # 循环解析 postfix_nofunc 规则内容，直到预测不再有效
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 146
                        self.postfix_nofunc()
                    self.state = 151
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
                
                pass
            
            # 如果 token 不在预期范围内，则抛出异常
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出当前规则
            self.exitRule()
        
        # 返回解析结果的 localctx 对象
        return localctx
    # 定义后缀表达式的语法上下文类
    class PostfixContext(ParserRuleContext):
        # 声明只有一个实例变量 parser
        __slots__ = 'parser'

        # 构造方法，接受 parser 对象和可选的父节点和当前节点状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 exp 方法，返回类型化的 LaTeXParser.ExpContext 上下文
        def exp(self):
            return self.getTypedRuleContext(LaTeXParser.ExpContext,0)

        # 定义 postfix_op 方法，根据索引返回 LaTeXParser.Postfix_opContext 上下文或列表
        def postfix_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.Postfix_opContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.Postfix_opContext,i)

        # 获取当前规则的索引，这里返回 LaTeXParser.RULE_postfix
        def getRuleIndex(self):
            return LaTeXParser.RULE_postfix




    # 定义不包含函数的后缀表达式的语法上下文类
    class Postfix_nofuncContext(ParserRuleContext):
        # 声明只有一个实例变量 parser
        __slots__ = 'parser'

        # 构造方法，接受 parser 对象和可选的父节点和当前节点状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 exp_nofunc 方法，返回类型化的 LaTeXParser.Exp_nofuncContext 上下文
        def exp_nofunc(self):
            return self.getTypedRuleContext(LaTeXParser.Exp_nofuncContext,0)

        # 定义 postfix_op 方法，根据索引返回 LaTeXParser.Postfix_opContext 上下文或列表
        def postfix_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.Postfix_opContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.Postfix_opContext,i)

        # 获取当前规则的索引，这里返回 LaTeXParser.RULE_postfix_nofunc
        def getRuleIndex(self):
            return LaTeXParser.RULE_postfix_nofunc
    # 定义无后缀函数语法规则的处理方法
    def postfix_nofunc(self):

        # 创建后缀无函数语境的上下文对象
        localctx = LaTeXParser.Postfix_nofuncContext(self, self._ctx, self.state)
        # 进入后缀无函数语境的处理规则
        self.enterRule(localctx, 20, self.RULE_postfix_nofunc)
        try:
            # 设置外部语境为第一个备选项
            self.enterOuterAlt(localctx, 1)
            # 处理表达式无函数的情况
            self.state = 161
            self.exp_nofunc(0)
            # 尝试同步解析器状态，以适应输入的动态预测
            self.state = 165
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                # 如果下一个备选项是第一种情况
                if _alt==1:
                    # 处理后缀操作符的情况
                    self.state = 162
                    self.postfix_op()
                # 尝试同步解析器状态，以适应输入的动态预测
                self.state = 167
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            # 捕获异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恕获异常并恢复
            self._errHandler.recover(self, re)
        finally:
            # 退出处理规则
            self.exitRule()
        # 返回当前处理上下文对象
        return localctx


    # 定义后缀操作符语法规则的处理方法
    class Postfix_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 获取感叹号标记的方法
        def BANG(self):
            return self.getToken(LaTeXParser.BANG, 0)

        # 获取“eval_at”语境的类型上下文对象的方法
        def eval_at(self):
            return self.getTypedRuleContext(LaTeXParser.Eval_atContext,0)

        # 获取语法规则索引的方法
        def getRuleIndex(self):
            return LaTeXParser.RULE_postfix_op


    # 定义后缀操作符处理方法
    def postfix_op(self):

        # 创建后缀操作符语境的上下文对象
        localctx = LaTeXParser.Postfix_opContext(self, self._ctx, self.state)
        # 进入后缀操作符语境的处理规则
        self.enterRule(localctx, 22, self.RULE_postfix_op)
        try:
            # 尝试同步解析器状态，以适应输入的动态预测
            self.state = 170
            self._errHandler.sync(self)
            token = self._input.LA(1)
            # 如果令牌为感叹号
            if token in [89]:
                # 处理第一个备选项
                self.enterOuterAlt(localctx, 1)
                # 匹配感叹号标记
                self.state = 168
                self.match(LaTeXParser.BANG)
                pass
            # 如果令牌为 eval_at
            elif token in [27]:
                # 处理第二个备选项
                self.enterOuterAlt(localctx, 2)
                # 处理 eval_at 方法
                self.state = 169
                self.eval_at()
                pass
            else:
                # 抛出不可用的备选项异常
                raise NoViableAltException(self)

        except RecognitionException as re:
            # 捕获异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 捕获异常并恢复
            self._errHandler.recover(self, re)
        finally:
            # 退出处理规则
            self.exitRule()
        # 返回当前处理上下文对象
        return localctx
    class Eval_atContext(ParserRuleContext):
        # Eval_atContext 类，表示解析器规则的上下文
        __slots__ = 'parser'
    
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 初始化方法，接受解析器对象和父级上下文
            super().__init__(parent, invokingState)
            self.parser = parser
    
        def BAR(self):
            # BAR 方法，返回 BAR 标记的 token
            return self.getToken(LaTeXParser.BAR, 0)
    
        def eval_at_sup(self):
            # 获取 Eval_at_supContext 类型的上下文对象
            return self.getTypedRuleContext(LaTeXParser.Eval_at_supContext, 0)
    
        def eval_at_sub(self):
            # 获取 Eval_at_subContext 类型的上下文对象
            return self.getTypedRuleContext(LaTeXParser.Eval_at_subContext, 0)
    
        def getRuleIndex(self):
            # 返回当前规则的索引（在 LaTeXParser 中定义）
            return LaTeXParser.RULE_eval_at
    
    
    
    
    def eval_at(self):
        # eval_at 方法，执行 "eval_at" 规则的解析
    
        # 创建 Eval_atContext 类的实例 localctx，并设置上下文和状态
        localctx = LaTeXParser.Eval_atContext(self, self._ctx, self.state)
        # 进入规则解析过程，设置当前规则状态为 24，规则索引为 self.RULE_eval_at
        self.enterRule(localctx, 24, self.RULE_eval_at)
        try:
            # 进入外层交替处理路径
            self.enterOuterAlt(localctx, 1)
            # 匹配 BAR 标记的 token
            self.state = 172
            self.match(LaTeXParser.BAR)
            self.state = 178
            # 同步错误处理器状态
            self._errHandler.sync(self)
            # 使用自适应预测确定路径
            la_ = self._interp.adaptivePredict(self._input, 11, self._ctx)
            if la_ == 1:
                # 如果预测为 1，执行 eval_at_sup 方法
                self.state = 173
                self.eval_at_sup()
                pass
            elif la_ == 2:
                # 如果预测为 2，执行 eval_at_sub 方法
                self.state = 174
                self.eval_at_sub()
                pass
            elif la_ == 3:
                # 如果预测为 3，先执行 eval_at_sup 方法，然后执行 eval_at_sub 方法
                self.state = 175
                self.eval_at_sup()
                self.state = 176
                self.eval_at_sub()
                pass
    
        except RecognitionException as re:
            # 捕捉解析过程中的语法错误异常
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则解析
            self.exitRule()
        # 返回当前规则解析得到的 localctx 对象
        return localctx
    
    
    class Eval_at_subContext(ParserRuleContext):
        # Eval_at_subContext 类，表示解析器规则的上下文
        __slots__ = 'parser'
    
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 初始化方法，接受解析器对象和父级上下文
            super().__init__(parent, invokingState)
            self.parser = parser
    
        def UNDERSCORE(self):
            # UNDERSCORE 方法，返回 UNDERSCORE 标记的 token
            return self.getToken(LaTeXParser.UNDERSCORE, 0)
    
        def L_BRACE(self):
            # L_BRACE 方法，返回 L_BRACE 标记的 token
            return self.getToken(LaTeXParser.L_BRACE, 0)
    
        def R_BRACE(self):
            # R_BRACE 方法，返回 R_BRACE 标记的 token
            return self.getToken(LaTeXParser.R_BRACE, 0)
    
        def expr(self):
            # 获取 ExprContext 类型的上下文对象
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)
    
        def equality(self):
            # 获取 EqualityContext 类型的上下文对象
            return self.getTypedRuleContext(LaTeXParser.EqualityContext, 0)
    
        def getRuleIndex(self):
            # 返回当前规则的索引（在 LaTeXParser 中定义）
            return LaTeXParser.RULE_eval_at_sub
    # 定义 eval_at_sub 方法，用于处理下标表达式
    def eval_at_sub(self):

        # 创建局部上下文 localctx，表示 eval_at_sub 的语法分析上下文
        localctx = LaTeXParser.Eval_at_subContext(self, self._ctx, self.state)
        # 进入规则 eval_at_sub 的处理过程
        self.enterRule(localctx, 26, self.RULE_eval_at_sub)
        try:
            # 进入第一个外部选项
            self.enterOuterAlt(localctx, 1)
            # 匹配下划线符号
            self.state = 180
            self.match(LaTeXParser.UNDERSCORE)
            # 匹配左大括号
            self.state = 181
            self.match(LaTeXParser.L_BRACE)
            # 同步错误处理器
            self.state = 184
            self._errHandler.sync(self)
            # 自适应预测输入的下标类型
            la_ = self._interp.adaptivePredict(self._input, 12, self._ctx)
            if la_ == 1:
                # 如果是类型 1，调用表达式解析方法
                self.state = 182
                self.expr()
                pass

            elif la_ == 2:
                # 如果是类型 2，调用等式解析方法
                self.state = 183
                self.equality()
                pass

            # 匹配右大括号
            self.state = 186
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            # 捕捉解析异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恕捉到异常后进行恢复
            self._errHandler.recover(self, re)
        finally:
            # 退出规则 eval_at_sub 的处理
            self.exitRule()
        # 返回当前上下文 localctx
        return localctx


    # 定义 Eval_at_supContext 类，表示上标语法分析上下文
    class Eval_at_supContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 获取上标符号 CARET 的 token
        def CARET(self):
            return self.getToken(LaTeXParser.CARET, 0)

        # 获取左大括号的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 获取右大括号的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 获取表达式规则的上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)

        # 获取等式规则的上下文
        def equality(self):
            return self.getTypedRuleContext(LaTeXParser.EqualityContext, 0)

        # 获取规则的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_eval_at_sup

    # 定义 eval_at_sup 方法，用于处理上标表达式
    def eval_at_sup(self):

        # 创建局部上下文 localctx，表示 eval_at_sup 的语法分析上下文
        localctx = LaTeXParser.Eval_at_supContext(self, self._ctx, self.state)
        # 进入规则 eval_at_sup 的处理过程
        self.enterRule(localctx, 28, self.RULE_eval_at_sup)
        try:
            # 进入第一个外部选项
            self.enterOuterAlt(localctx, 1)
            # 匹配上标符号
            self.state = 188
            self.match(LaTeXParser.CARET)
            # 匹配左大括号
            self.state = 189
            self.match(LaTeXParser.L_BRACE)
            # 同步错误处理器
            self.state = 192
            self._errHandler.sync(self)
            # 自适应预测输入的上标类型
            la_ = self._interp.adaptivePredict(self._input, 13, self._ctx)
            if la_ == 1:
                # 如果是类型 1，调用表达式解析方法
                self.state = 190
                self.expr()
                pass

            elif la_ == 2:
                # 如果是类型 2，调用等式解析方法
                self.state = 191
                self.equality()
                pass

            # 匹配右大括号
            self.state = 194
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            # 捕捉解析异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 捕捉到异常后进行恢复
            self._errHandler.recover(self, re)
        finally:
            # 退出规则 eval_at_sup 的处理
            self.exitRule()
        # 返回当前上下文 localctx
        return localctx
    # 定义一个名为 ExpContext 的类，继承自 ParserRuleContext
    class ExpContext(ParserRuleContext):
        
        # 类的 __slots__ 属性，限定实例只能有 'parser' 这个属性
        __slots__ = 'parser'

        # ExpContext 类的初始化方法
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 设置实例的 parser 属性
            self.parser = parser

        # 定义 comp 方法，返回类型为 LaTeXParser.CompContext 的规则上下文
        def comp(self):
            return self.getTypedRuleContext(LaTeXParser.CompContext,0)

        # 定义 exp 方法，返回类型为 LaTeXParser.ExpContext 的规则上下文
        def exp(self):
            return self.getTypedRuleContext(LaTeXParser.ExpContext,0)

        # 定义 CARET 方法，返回 CARET 标记的 token
        def CARET(self):
            return self.getToken(LaTeXParser.CARET, 0)

        # 定义 atom 方法，返回类型为 LaTeXParser.AtomContext 的规则上下文
        def atom(self):
            return self.getTypedRuleContext(LaTeXParser.AtomContext,0)

        # 定义 L_BRACE 方法，返回 L_BRACE 标记的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 定义 expr 方法，返回类型为 LaTeXParser.ExprContext 的规则上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 定义 R_BRACE 方法，返回 R_BRACE 标记的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 定义 subexpr 方法，返回类型为 LaTeXParser.SubexprContext 的规则上下文
        def subexpr(self):
            return self.getTypedRuleContext(LaTeXParser.SubexprContext,0)

        # 定义 getRuleIndex 方法，返回当前规则的索引 RULE_exp
        def getRuleIndex(self):
            return LaTeXParser.RULE_exp
    # 定义 exp 方法，用于处理表达式解析，支持递归调用
    def exp(self, _p:int=0):
        # 保存当前上下文和状态
        _parentctx = self._ctx
        _parentState = self.state
        # 创建当前表达式的上下文 localctx
        localctx = LaTeXParser.ExpContext(self, self._ctx, _parentState)
        # 记录前一个上下文
        _prevctx = localctx
        # 设置起始状态为 30，并进入递归规则
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_exp, _p)
        try:
            # 进入递归规则的第一步，调用 comp 方法处理比较表达式
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.comp()
            # 更新当前上下文的 stop 标志
            self._ctx.stop = self._input.LT(-1)
            self.state = 213
            self._errHandler.sync(self)
            # 预测下一个输入的可能性，用于决定下一步动作
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            # 循环处理直到没有其他可能性或发生错误
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                # 如果存在监听器，则触发退出规则事件
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 更新前一个上下文为当前上下文，进入新的递归上下文
                    _prevctx = localctx
                    localctx = LaTeXParser.ExpContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                    self.state = 199
                    # 检查当前上下文是否满足特定条件，否则抛出异常
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 200
                    self.match(LaTeXParser.CARET)
                    self.state = 206
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    # 根据下一个 token 类型选择不同的操作
                    if token in [27, 29, 30, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                        self.state = 201
                        self.atom()
                        pass
                    elif token in [21]:
                        self.state = 202
                        self.match(LaTeXParser.L_BRACE)
                        self.state = 203
                        self.expr()
                        self.state = 204
                        self.match(LaTeXParser.R_BRACE)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 209
                    self._errHandler.sync(self)
                    # 预测是否需要进行子表达式的处理
                    la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                    if la_ == 1:
                        self.state = 208
                        self.subexpr()

                # 继续同步处理，预测下一个可能性
                self.state = 215
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            # 捕捉并报告任何识别异常
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 解除递归上下文，返回处理完成的当前上下文
            self.unrollRecursionContexts(_parentctx)
        return localctx
    class Exp_nofuncContext(ParserRuleContext):
        # Exp_nofuncContext 类，用于表示非函数表达式的上下文
        __slots__ = 'parser'
    
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 初始化方法，接受一个 parser 对象和可选的父上下文和状态信息
            super().__init__(parent, invokingState)
            self.parser = parser
    
        def comp_nofunc(self):
            # 返回类型为 Comp_nofuncContext 的规则上下文
            return self.getTypedRuleContext(LaTeXParser.Comp_nofuncContext, 0)
    
        def exp_nofunc(self):
            # 返回类型为 Exp_nofuncContext 的规则上下文
            return self.getTypedRuleContext(LaTeXParser.Exp_nofuncContext, 0)
    
        def CARET(self):
            # 返回 CARET 标记的 token
            return self.getToken(LaTeXParser.CARET, 0)
    
        def atom(self):
            # 返回类型为 AtomContext 的规则上下文
            return self.getTypedRuleContext(LaTeXParser.AtomContext, 0)
    
        def L_BRACE(self):
            # 返回 L_BRACE 标记的 token
            return self.getToken(LaTeXParser.L_BRACE, 0)
    
        def expr(self):
            # 返回类型为 ExprContext 的规则上下文
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)
    
        def R_BRACE(self):
            # 返回 R_BRACE 标记的 token
            return self.getToken(LaTeXParser.R_BRACE, 0)
    
        def subexpr(self):
            # 返回类型为 SubexprContext 的规则上下文
            return self.getTypedRuleContext(LaTeXParser.SubexprContext, 0)
    
        def getRuleIndex(self):
            # 返回此规则的索引，用于 parser 中的规则识别
            return LaTeXParser.RULE_exp_nofunc
    # 定义一个非函数表达式解析方法，带有一个可选的整型参数_p，默认为0
    def exp_nofunc(self, _p:int=0):
        # 保存当前上下文和状态信息
        _parentctx = self._ctx
        _parentState = self.state
        # 创建当前表达式上下文的实例
        localctx = LaTeXParser.Exp_nofuncContext(self, self._ctx, _parentState)
        # 保存当前上下文作为前一上下文
        _prevctx = localctx
        # 进入递归规则的处理
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_exp_nofunc, _p)
        try:
            # 进入递归处理的第一个分支
            self.enterOuterAlt(localctx, 1)
            # 处理非函数的比较表达式
            self.state = 217
            self.comp_nofunc()
            # 设置当前上下文的停止标志
            self._ctx.stop = self._input.LT(-1)
            # 循环处理剩余的输入
            self.state = 233
            self._errHandler.sync(self)
            # 自适应预测下一个输入的处理方式
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                # 根据预测选择相应的处理分支
                if _alt==1:
                    # 触发退出规则事件
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    # 更新当前上下文和状态信息
                    _prevctx = localctx
                    localctx = LaTeXParser.Exp_nofuncContext(self, _parentctx, _parentState)
                    # 推入新的递归上下文
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_exp_nofunc)
                    self.state = 219
                    # 判断当前上下文的先行断言是否为真
                    if not self.precpred(self._ctx, 2):
                        # 引发先行断言失败异常
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    # 处理指数运算符 "^"
                    self.state = 220
                    self.match(LaTeXParser.CARET)
                    self.state = 226
                    self._errHandler.sync(self)
                    # 自适应预测下一个输入的处理方式
                    token = self._input.LA(1)
                    if token in [27, 29, 30, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                        # 处理原子表达式
                        self.state = 221
                        self.atom()
                        pass
                    elif token in [21]:
                        # 处理大括号包裹的表达式
                        self.state = 222
                        self.match(LaTeXParser.L_BRACE)
                        self.state = 223
                        self.expr()
                        self.state = 224
                        self.match(LaTeXParser.R_BRACE)
                        pass
                    else:
                        # 抛出无法识别的备选项异常
                        raise NoViableAltException(self)

                    # 继续自适应预测下一个输入的处理方式
                    self.state = 229
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                    if la_ == 1:
                        self.state = 228
                        # 处理子表达式
                        self.subexpr()

                # 继续自适应预测下一个输入的处理方式
                self.state = 235
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            # 报告识别异常
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恚集处理识别异常
            self._errHandler.recover(self, re)
        finally:
            # 展开所有递归上下文
            self.unrollRecursionContexts(_parentctx)
        # 返回当前上下文
        return localctx
    # 定义一个名为 CompContext 的类，它是 ParserRuleContext 的子类
    class CompContext(ParserRuleContext):
        # 定义 __slots__ 属性，只允许有一个名为 parser 的实例变量
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 三个参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 将 parser 参数赋值给 self.parser 实例变量
            self.parser = parser

        # 下面是一系列方法，每个方法返回特定类型的 ParserRuleContext 子类的实例

        # 返回 GroupContext 类型的实例
        def group(self):
            return self.getTypedRuleContext(LaTeXParser.GroupContext,0)

        # 返回 Abs_groupContext 类型的实例
        def abs_group(self):
            return self.getTypedRuleContext(LaTeXParser.Abs_groupContext,0)

        # 返回 FuncContext 类型的实例
        def func(self):
            return self.getTypedRuleContext(LaTeXParser.FuncContext,0)

        # 返回 AtomContext 类型的实例
        def atom(self):
            return self.getTypedRuleContext(LaTeXParser.AtomContext,0)

        # 返回 FloorContext 类型的实例
        def floor(self):
            return self.getTypedRuleContext(LaTeXParser.FloorContext,0)

        # 返回 CeilContext 类型的实例
        def ceil(self):
            return self.getTypedRuleContext(LaTeXParser.CeilContext,0)

        # 返回规则索引，这里是 LaTeXParser.RULE_comp
        def getRuleIndex(self):
            return LaTeXParser.RULE_comp

    # 定义 comp 方法，用于处理 CompContext 实例
    def comp(self):
        # 创建 CompContext 的实例 localctx，传入当前解析器对象、当前上下文和状态
        localctx = LaTeXParser.CompContext(self, self._ctx, self.state)
        # 进入规则，传入 localctx、规则编号 34、当前状态
        self.enterRule(localctx, 34, self.RULE_comp)
        try:
            # 同步错误处理器
            self.state = 242
            self._errHandler.sync(self)
            # 执行自适应预测，获取 la_ 值
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            # 根据预测值执行不同的外部路径

            # 如果预测值为 1
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                # 进入规则 236，调用 group 方法
                self.state = 236
                self.group()
                pass

            # 如果预测值为 2
            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                # 进入规则 237，调用 abs_group 方法
                self.state = 237
                self.abs_group()
                pass

            # 如果预测值为 3
            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                # 进入规则 238，调用 func 方法
                self.state = 238
                self.func()
                pass

            # 如果预测值为 4
            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                # 进入规则 239，调用 atom 方法
                self.state = 239
                self.atom()
                pass

            # 如果预测值为 5
            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                # 进入规则 240，调用 floor 方法
                self.state = 240
                self.floor()
                pass

            # 如果预测值为 6
            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                # 进入规则 241，调用 ceil 方法
                self.state = 241
                self.ceil()
                pass

        # 捕获词法分析或语法分析中的异常
        except RecognitionException as re:
            # 将异常对象赋值给 localctx 的 exception 属性
            localctx.exception = re
            # 调用错误处理器的报告错误方法
            self._errHandler.reportError(self, re)
            # 调用错误处理器的恢复方法
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx 对象
        return localctx
    # 定义 Comp_nofuncContext 类，表示 LaTeX 解析器中的非函数比较上下文
    class Comp_nofuncContext(ParserRuleContext):
        # __slots__ 指定类的实例可以有的属性，这里只有 'parser'
        __slots__ = 'parser'

        # 初始化方法，接受解析器实例、父上下文和当前状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 返回 group 规则的上下文
        def group(self):
            return self.getTypedRuleContext(LaTeXParser.GroupContext,0)

        # 返回 abs_group 规则的上下文
        def abs_group(self):
            return self.getTypedRuleContext(LaTeXParser.Abs_groupContext,0)

        # 返回 atom 规则的上下文
        def atom(self):
            return self.getTypedRuleContext(LaTeXParser.AtomContext,0)

        # 返回 floor 规则的上下文
        def floor(self):
            return self.getTypedRuleContext(LaTeXParser.FloorContext,0)

        # 返回 ceil 规则的上下文
        def ceil(self):
            return self.getTypedRuleContext(LaTeXParser.CeilContext,0)

        # 返回当前规则的索引，用于标识此规则在解析器中的位置
        def getRuleIndex(self):
            return LaTeXParser.RULE_comp_nofunc

    # 定义 comp_nofunc 方法，用于处理 Comp_nofuncContext 上下文
    def comp_nofunc(self):
        # 创建 Comp_nofuncContext 实例，传入当前解析器实例、当前上下文和状态信息
        localctx = LaTeXParser.Comp_nofuncContext(self, self._ctx, self.state)
        # 进入规则处理阶段，标记为第 36 条规则，传入当前上下文状态
        self.enterRule(localctx, 36, self.RULE_comp_nofunc)
        try:
            # 使用自适应预测方法预测下一个输入的可能情况，返回预测结果 la_
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            # 根据预测结果进行条件分支处理
            if la_ == 1:
                # 第一种情况：调用 group 方法处理
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.group()
                pass
            elif la_ == 2:
                # 第二种情况：调用 abs_group 方法处理
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.abs_group()
                pass
            elif la_ == 3:
                # 第三种情况：调用 atom 方法处理
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.atom()
                pass
            elif la_ == 4:
                # 第四种情况：调用 floor 方法处理
                self.enterOuterAlt(localctx, 4)
                self.state = 247
                self.floor()
                pass
            elif la_ == 5:
                # 第五种情况：调用 ceil 方法处理
                self.enterOuterAlt(localctx, 5)
                self.state = 248
                self.ceil()
                pass
        # 捕获解析异常并处理
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出当前规则处理阶段
            self.exitRule()
        # 返回当前上下文
        return localctx
    # 定义 GroupContext 类，继承自 ParserRuleContext
    class GroupContext(ParserRuleContext):
        # __slots__ 定义仅包含 'parser' 属性的槽
        __slots__ = 'parser'

        # 构造函数，初始化 GroupContext 实例
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            # 调用父类的构造函数
            super().__init__(parent, invokingState)
            # 设置 parser 属性为传入的 parser 对象
            self.parser = parser

        # 获取左括号的 token
        def L_PAREN(self):
            return self.getToken(LaTeXParser.L_PAREN, 0)

        # 获取表达式的上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)

        # 获取右括号的 token
        def R_PAREN(self):
            return self.getToken(LaTeXParser.R_PAREN, 0)

        # 获取左方括号的 token
        def L_BRACKET(self):
            return self.getToken(LaTeXParser.L_BRACKET, 0)

        # 获取右方括号的 token
        def R_BRACKET(self):
            return self.getToken(LaTeXParser.R_BRACKET, 0)

        # 获取左大括号的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 获取右大括号的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 获取左大括号文字的 token
        def L_BRACE_LITERAL(self):
            return self.getToken(LaTeXParser.L_BRACE_LITERAL, 0)

        # 获取右大括号文字的 token
        def R_BRACE_LITERAL(self):
            return self.getToken(LaTeXParser.R_BRACE_LITERAL, 0)

        # 获取当前规则的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_group
    # 定义一个方法 group，处理 LaTeXParser 类中的分组规则
    def group(self):

        # 创建一个 GroupContext 对象，用于处理分组的语境，包括当前解析器、当前上下文和状态信息
        localctx = LaTeXParser.GroupContext(self, self._ctx, self.state)
        
        # 进入分组规则的解析，指定规则编号为 38，进入解析状态
        self.enterRule(localctx, 38, self.RULE_group)
        
        try:
            # 同步输入处理器的状态
            self.state = 267
            
            # 获取当前输入流的第一个标记
            token = self._input.LA(1)
            
            # 根据不同的标记进行不同的处理分支
            if token in [19]:  # 左括号 '('
                self.enterOuterAlt(localctx, 1)
                
                # 匹配左括号 '('
                self.state = 251
                self.match(LaTeXParser.L_PAREN)
                
                # 解析表达式
                self.state = 252
                self.expr()
                
                # 匹配右括号 ')'
                self.state = 253
                self.match(LaTeXParser.R_PAREN)
                pass
            elif token in [25]:  # 左方括号 '['
                self.enterOuterAlt(localctx, 2)
                
                # 匹配左方括号 '['
                self.state = 255
                self.match(LaTeXParser.L_BRACKET)
                
                # 解析表达式
                self.state = 256
                self.expr()
                
                # 匹配右方括号 ']'
                self.state = 257
                self.match(LaTeXParser.R_BRACKET)
                pass
            elif token in [21]:  # 左大括号 '{'
                self.enterOuterAlt(localctx, 3)
                
                # 匹配左大括号 '{'
                self.state = 259
                self.match(LaTeXParser.L_BRACE)
                
                # 解析表达式
                self.state = 260
                self.expr()
                
                # 匹配右大括号 '}'
                self.state = 261
                self.match(LaTeXParser.R_BRACE)
                pass
            elif token in [23]:  # 左大括号字面值 '${'
                self.enterOuterAlt(localctx, 4)
                
                # 匹配左大括号字面值 '${'
                self.state = 263
                self.match(LaTeXParser.L_BRACE_LITERAL)
                
                # 解析表达式
                self.state = 264
                self.expr()
                
                # 匹配右大括号字面值 '}$'
                self.state = 265
                self.match(LaTeXParser.R_BRACE_LITERAL)
                pass
            else:
                # 如果遇到无法处理的标记，抛出 NoViableAltException 异常
                raise NoViableAltException(self)

        except RecognitionException as re:
            # 捕获可能出现的解析异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            
            # 尝试恢复解析器状态
            self._errHandler.recover(self, re)
            
        finally:
            # 无论是否出现异常，最终退出当前规则的解析状态
            self.exitRule()
            
        # 返回解析得到的上下文对象
        return localctx
    # 定义一个方法用于解析绝对值表达式的语法规则
    def abs_group(self):

        # 创建一个绝对值组上下文对象，包含当前解析器、当前上下文和状态信息
        localctx = LaTeXParser.Abs_groupContext(self, self._ctx, self.state)
        # 进入解析该规则的处理流程
        self.enterRule(localctx, 40, self.RULE_abs_group)
        try:
            # 进入第一个可能的语法分支：匹配绝对值表达式起始的竖线 '|'
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            # 匹配竖线 '|'
            self.match(LaTeXParser.BAR)
            self.state = 270
            # 解析表达式的内容
            self.expr()
            self.state = 271
            # 匹配绝对值表达式结束的竖线 '|'
            self.match(LaTeXParser.BAR)
        except RecognitionException as re:
            # 如果解析过程中出现异常，报告错误并尝试恢复
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 无论是否发生异常，最终退出当前规则的解析处理
            self.exitRule()
        # 返回解析结果的上下文对象
        return localctx


    # 定义一个类，表示 LaTeX 解析器中数字的语法规则
    class NumberContext(ParserRuleContext):
        # 定义此类的槽，指定其只有一个成员变量 parser
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            # 初始化时将解析器对象保存到成员变量中
            self.parser = parser

        # 定义 DIGIT 规则的方法，用于匹配数字
        def DIGIT(self, i:int=None):
            if i is None:
                # 返回所有 DIGIT 类型的 token
                return self.getTokens(LaTeXParser.DIGIT)
            else:
                # 返回第 i 个 DIGIT 类型的 token
                return self.getToken(LaTeXParser.DIGIT, i)

        # 获取当前规则在解析器中的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_number
    # 定义 number 方法，处理 LaTeXParser 类的 number 规则
    def number(self):
        # 创建一个 NumberContext 对象，包装当前上下文和状态信息
        localctx = LaTeXParser.NumberContext(self, self._ctx, self.state)
        # 进入规则解析过程
        self.enterRule(localctx, 42, self.RULE_number)
        try:
            # 进入第一个备选路径
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self._errHandler.sync(self)
            _alt = 1
            # 进入循环，匹配 DIGIT 终结符
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 273
                    self.match(LaTeXParser.DIGIT)
                else:
                    raise NoViableAltException(self)
                self.state = 276
                self._errHandler.sync(self)
                # 自适应预测输入，确定下一个路径
                _alt = self._interp.adaptivePredict(self._input, 23, self._ctx)

            self.state = 284
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 24, self._ctx)
            # 第二个备选路径循环，匹配数字后的特定模式
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 278
                    self.match(LaTeXParser.T__0)
                    self.state = 279
                    self.match(LaTeXParser.DIGIT)
                    self.state = 280
                    self.match(LaTeXParser.DIGIT)
                    self.state = 281
                    self.match(LaTeXParser.DIGIT)
                self.state = 286
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 24, self._ctx)

            self.state = 293
            self._errHandler.sync(self)
            # 第三个备选路径，匹配末尾的 T__1 和相关数字
            la_ = self._interp.adaptivePredict(self._input, 26, self._ctx)
            if la_ == 1:
                self.state = 287
                self.match(LaTeXParser.T__1)
                self.state = 289
                self._errHandler.sync(self)
                _alt = 1
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 288
                        self.match(LaTeXParser.DIGIT)
                    else:
                        raise NoViableAltException(self)
                    self.state = 291
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 25, self._ctx)

        except RecognitionException as re:
            # 捕捉到解析异常，报告并恢复处理
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则解析
            self.exitRule()
        # 返回解析得到的 localctx 对象
        return localctx
    # 定义 AtomContext 类，继承自 ParserRuleContext 类，表示解析器上下文中的原子对象
    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受解析器实例、可选的父上下文和状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 获取 LETTER 标记的方法
        def LETTER(self):
            return self.getToken(LaTeXParser.LETTER, 0)

        # 获取 SYMBOL 标记的方法
        def SYMBOL(self):
            return self.getToken(LaTeXParser.SYMBOL, 0)

        # 获取 subexpr 规则的上下文对象的方法
        def subexpr(self):
            return self.getTypedRuleContext(LaTeXParser.SubexprContext,0)

        # 获取 SINGLE_QUOTES 标记的方法
        def SINGLE_QUOTES(self):
            return self.getToken(LaTeXParser.SINGLE_QUOTES, 0)

        # 获取 number 规则的上下文对象的方法
        def number(self):
            return self.getTypedRuleContext(LaTeXParser.NumberContext,0)

        # 获取 DIFFERENTIAL 标记的方法
        def DIFFERENTIAL(self):
            return self.getToken(LaTeXParser.DIFFERENTIAL, 0)

        # 获取 mathit 规则的上下文对象的方法
        def mathit(self):
            return self.getTypedRuleContext(LaTeXParser.MathitContext,0)

        # 获取 frac 规则的上下文对象的方法
        def frac(self):
            return self.getTypedRuleContext(LaTeXParser.FracContext,0)

        # 获取 binom 规则的上下文对象的方法
        def binom(self):
            return self.getTypedRuleContext(LaTeXParser.BinomContext,0)

        # 获取 bra 规则的上下文对象的方法
        def bra(self):
            return self.getTypedRuleContext(LaTeXParser.BraContext,0)

        # 获取 ket 规则的上下文对象的方法
        def ket(self):
            return self.getTypedRuleContext(LaTeXParser.KetContext,0)

        # 获取规则索引的方法
        def getRuleIndex(self):
            return LaTeXParser.RULE_atom




    # 定义 BraContext 类，继承自 ParserRuleContext 类，表示解析器上下文中的 bra 对象
    class BraContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受解析器实例、可选的父上下文和状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 获取 L_ANGLE 标记的方法
        def L_ANGLE(self):
            return self.getToken(LaTeXParser.L_ANGLE, 0)

        # 获取 expr 规则的上下文对象的方法
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 获取 R_BAR 标记的方法
        def R_BAR(self):
            return self.getToken(LaTeXParser.R_BAR, 0)

        # 获取 BAR 标记的方法
        def BAR(self):
            return self.getToken(LaTeXParser.BAR, 0)

        # 获取规则索引的方法
        def getRuleIndex(self):
            return LaTeXParser.RULE_bra




    # 定义 bra 方法
    def bra():

        # 创建 BraContext 类的实例 localctx，传入解析器实例、当前上下文和状态
        localctx = LaTeXParser.BraContext(self, self._ctx, self.state)
        
        # 进入规则处理
        self.enterRule(localctx, 46, self.RULE_bra)
        
        # 清空 token 类型
        self._la = 0 
        
        try:
            # 进入外部交替部分
            self.enterOuterAlt(localctx, 1)
            
            # 设置状态为 319，并匹配 L_ANGLE 标记
            self.state = 319
            self.match(LaTeXParser.L_ANGLE)
            
            # 调用 expr 方法
            self.state = 320
            self.expr()
            
            # 获取下一个 token 类型
            self.state = 321
            _la = self._input.LA(1)
            
            # 如果 token 类型不是 27 或 28，则处理恢复内联
            if not(_la==27 or _la==28):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        
        # 捕获识别异常，将其传递给局部上下文
        except RecognitionException as re:
            localctx.exception = re
            
            # 报告错误
            self._errHandler.reportError(self, re)
            
            # 恜止恢复
            self._errHandler.recover(self, re)
        
        finally:
            # 退出规则处理
            self.exitRule()
        
        # 返回局部上下文
        return localctx
    # 定义 KetContext 类，继承自 ParserRuleContext
    class KetContext(ParserRuleContext):
        # 为类定义 __slots__ 属性，用于限定实例的属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 三个参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 expr 方法，返回类型化的 LaTeXParser.ExprContext 上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 定义 R_ANGLE 方法，返回 R_ANGLE 标记的 token
        def R_ANGLE(self):
            return self.getToken(LaTeXParser.R_ANGLE, 0)

        # 定义 L_BAR 方法，返回 L_BAR 标记的 token
        def L_BAR(self):
            return self.getToken(LaTeXParser.L_BAR, 0)

        # 定义 BAR 方法，返回 BAR 标记的 token
        def BAR(self):
            return self.getToken(LaTeXParser.BAR, 0)

        # 获取规则索引，返回 RULE_ket 的规则索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_ket


    # 定义 ket 函数
    def ket(self):

        # 创建 KetContext 的实例 localctx，传入 parser、当前上下文和状态
        localctx = LaTeXParser.KetContext(self, self._ctx, self.state)
        # 进入规则处理
        self.enterRule(localctx, 48, self.RULE_ket)
        self._la = 0 # Token 类型
        try:
            # 进入外部交替路径
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 323
            self.state = 323
            # 获取当前输入的第一个 token 类型
            _la = self._input.LA(1)
            # 如果不是 27 或者 29，则
            if not(_la==27 or _la==29):
                # 恢复内联错误处理
                self._errHandler.recoverInline(self)
            else:
                # 报告匹配成功
                self._errHandler.reportMatch(self)
                # 消耗当前 token
                self.consume()
            # 设置状态为 324
            self.state = 324
            # 调用 expr 方法
            self.expr()
            # 设置状态为 325
            self.state = 325
            # 匹配 R_ANGLE 标记的 token
            self.match(LaTeXParser.R_ANGLE)
        except RecognitionException as re:
            # 捕获识别异常 re
            localctx.exception = re
            # 报告错误
            self._errHandler.reportError(self, re)
            # 恜止错误
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx
        return localctx


    # 定义 MathitContext 类，继承自 ParserRuleContext
    class MathitContext(ParserRuleContext):
        # 为类定义 __slots__ 属性，用于限定实例的属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 三个参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 CMD_MATHIT 方法，返回 CMD_MATHIT 标记的 token
        def CMD_MATHIT(self):
            return self.getToken(LaTeXParser.CMD_MATHIT, 0)

        # 定义 L_BRACE 方法，返回 L_BRACE 标记的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 定义 mathit_text 方法，返回类型化的 LaTeXParser.Mathit_textContext 上下文
        def mathit_text(self):
            return self.getTypedRuleContext(LaTeXParser.Mathit_textContext,0)

        # 定义 R_BRACE 方法，返回 R_BRACE 标记的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 获取规则索引，返回 RULE_mathit 的规则索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_mathit


    # 定义 mathit 函数
    def mathit(self):

        # 创建 MathitContext 的实例 localctx，传入 parser、当前上下文和状态
        localctx = LaTeXParser.MathitContext(self, self._ctx, self.state)
        # 进入规则处理
        self.enterRule(localctx, 50, self.RULE_mathit)
        try:
            # 进入外部交替路径
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 327
            self.state = 327
            # 匹配 CMD_MATHIT 标记的 token
            self.match(LaTeXParser.CMD_MATHIT)
            # 设置状态为 328
            self.state = 328
            # 匹配 L_BRACE 标记的 token
            self.match(LaTeXParser.L_BRACE)
            # 设置状态为 329
            self.state = 329
            # 调用 mathit_text 方法
            self.mathit_text()
            # 设置状态为 330
            self.state = 330
            # 匹配 R_BRACE 标记的 token
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            # 捕获识别异常 re
            localctx.exception = re
            # 报告错误
            self._errHandler.reportError(self, re)
            # 恜止错误
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx
        return localctx
    class Mathit_textContext(ParserRuleContext):
        """
        定义 Mathit_textContext 类，继承自 ParserRuleContext。
        用于解析 LaTeXParser 中的数学文本上下文。
    
        Attributes:
            parser: 解析器对象，用于处理该上下文的解析操作。
        """
        __slots__ = 'parser'
    
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            """
            初始化 Mathit_textContext 对象。
    
            Args:
                parser: 解析器对象。
                parent: 父节点的 ParserRuleContext 对象，默认为 None。
                invokingState: 该上下文的初始状态，默认为 -1。
            """
            super().__init__(parent, invokingState)
            self.parser = parser
    
        def LETTER(self, i:int=None):
            """
            获取或匹配 LETTER 类型的 token。
    
            Args:
                i: 可选参数，指定匹配的 token 索引，默认为 None。
    
            Returns:
                返回符合条件的 token 或 token 列表。
            """
            if i is None:
                return self.getTokens(LaTeXParser.LETTER)
            else:
                return self.getToken(LaTeXParser.LETTER, i)
    
        def getRuleIndex(self):
            """
            返回该上下文对应的规则索引。
    
            Returns:
                LaTeXParser 中定义的 RULE_mathit_text 规则的索引。
            """
            return LaTeXParser.RULE_mathit_text
    
    
    def mathit_text(self):
        """
        解析 LaTeXParser 中的 mathit_text 规则。
    
        Returns:
            返回解析结果的 Mathit_textContext 对象。
        """
        localctx = LaTeXParser.Mathit_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_mathit_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==77:
                self.state = 332
                self.match(LaTeXParser.LETTER)
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)
    
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
    
    
    class FracContext(ParserRuleContext):
        """
        定义 FracContext 类，继承自 ParserRuleContext。
        用于解析 LaTeXParser 中的分式上下文。
    
        Attributes:
            parser: 解析器对象，用于处理该上下文的解析操作。
            upperd: 分式的上部分的 token 对象。
            upper: 分式的上部分的 ExprContext 对象。
            lowerd: 分式的下部分的 token 对象。
            lower: 分式的下部分的 ExprContext 对象。
        """
        __slots__ = 'parser'
    
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            """
            初始化 FracContext 对象。
    
            Args:
                parser: 解析器对象。
                parent: 父节点的 ParserRuleContext 对象，默认为 None。
                invokingState: 该上下文的初始状态，默认为 -1。
            """
            super().__init__(parent, invokingState)
            self.parser = parser
            self.upperd = None # Token
            self.upper = None # ExprContext
            self.lowerd = None # Token
            self.lower = None # ExprContext
    
        def CMD_FRAC(self):
            """
            获取 CMD_FRAC 类型的 token。
    
            Returns:
                返回 CMD_FRAC 类型的 token。
            """
            return self.getToken(LaTeXParser.CMD_FRAC, 0)
    
        def L_BRACE(self, i:int=None):
            """
            获取或匹配 L_BRACE 类型的 token。
    
            Args:
                i: 可选参数，指定匹配的 token 索引，默认为 None。
    
            Returns:
                返回符合条件的 token 或 token 列表。
            """
            if i is None:
                return self.getTokens(LaTeXParser.L_BRACE)
            else:
                return self.getToken(LaTeXParser.L_BRACE, i)
    
        def R_BRACE(self, i:int=None):
            """
            获取或匹配 R_BRACE 类型的 token。
    
            Args:
                i: 可选参数，指定匹配的 token 索引，默认为 None。
    
            Returns:
                返回符合条件的 token 或 token 列表。
            """
            if i is None:
                return self.getTokens(LaTeXParser.R_BRACE)
            else:
                return self.getToken(LaTeXParser.R_BRACE, i)
    
        def DIGIT(self, i:int=None):
            """
            获取或匹配 DIGIT 类型的 token。
    
            Args:
                i: 可选参数，指定匹配的 token 索引，默认为 None。
    
            Returns:
                返回符合条件的 token 或 token 列表。
            """
            if i is None:
                return self.getTokens(LaTeXParser.DIGIT)
            else:
                return self.getToken(LaTeXParser.DIGIT, i)
    
        def expr(self, i:int=None):
            """
            获取或匹配 ExprContext 类型的上下文对象。
    
            Args:
                i: 可选参数，指定匹配的 ExprContext 索引，默认为 None。
    
            Returns:
                返回符合条件的 ExprContext 或 ExprContext 列表。
            """
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.ExprContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.ExprContext,i)
    
        def getRuleIndex(self):
            """
            返回该上下文对应的规则索引。
    
            Returns:
                LaTeXParser 中定义的 RULE_frac 规则的索引。
            """
            return LaTeXParser.RULE_frac
    # 定义一个方法 frac，用于解析 LaTeX 中的分数表达式
    def frac(self):

        # 创建一个分数解析的上下文对象 localctx
        localctx = LaTeXParser.FracContext(self, self._ctx, self.state)
        # 进入 frac 规则，标记当前状态为 54
        self.enterRule(localctx, 54, self.RULE_frac)
        try:
            # 进入第一个替代分支
            self.enterOuterAlt(localctx, 1)
            # 匹配分数命令 "\frac"
            self.state = 338
            self.match(LaTeXParser.CMD_FRAC)
            # 开始处理上标部分
            self.state = 344
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                # 匹配到数字，存储在 localctx.upperd 中
                self.state = 339
                localctx.upperd = self.match(LaTeXParser.DIGIT)
                pass
            elif token in [21]:
                # 匹配到左花括号 '{'，处理表达式，存储在 localctx.upper 中
                self.state = 340
                self.match(LaTeXParser.L_BRACE)
                self.state = 341
                localctx.upper = self.expr()
                self.state = 342
                self.match(LaTeXParser.R_BRACE)
                pass
            else:
                # 其他情况，抛出异常
                raise NoViableAltException(self)

            # 继续处理下标部分
            self.state = 351
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                # 匹配到数字，存储在 localctx.lowerd 中
                self.state = 346
                localctx.lowerd = self.match(LaTeXParser.DIGIT)
                pass
            elif token in [21]:
                # 匹配到左花括号 '{'，处理表达式，存储在 localctx.lower 中
                self.state = 347
                self.match(LaTeXParser.L_BRACE)
                self.state = 348
                localctx.lower = self.expr()
                self.state = 349
                self.match(LaTeXParser.R_BRACE)
                pass
            else:
                # 其他情况，抛出异常
                raise NoViableAltException(self)

        # 捕获可能发生的词法或语法错误
        except RecognitionException as re:
            localctx.exception = re
            # 报告错误
            self._errHandler.reportError(self, re)
            # 尝试从错误中恢复解析过程
            self._errHandler.recover(self, re)
        finally:
            # 无论如何，退出 frac 规则
            self.exitRule()
        # 返回 frac 方法的结果
        return localctx
    # 定义 BinomContext 类，表示解析器的上下文
    class BinomContext(ParserRuleContext):
        # 限定 BinomContext 类只能拥有 'parser' 这一个属性
        __slots__ = 'parser'

        # 初始化函数，接受解析器和可选的父上下文及初始状态
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # ExprContext，用于存储 n 表达式的上下文
            self.k = None # ExprContext，用于存储 k 表达式的上下文

        # 获取左括号（可能是多个）的 Token 函数
        def L_BRACE(self, i:int=None):
            if i is None:
                return self.getTokens(LaTeXParser.L_BRACE)
            else:
                return self.getToken(LaTeXParser.L_BRACE, i)

        # 获取右括号（可能是多个）的 Token 函数
        def R_BRACE(self, i:int=None):
            if i is None:
                return self.getTokens(LaTeXParser.R_BRACE)
            else:
                return self.getToken(LaTeXParser.R_BRACE, i)

        # 获取 CMD_BINOM Token 函数
        def CMD_BINOM(self):
            return self.getToken(LaTeXParser.CMD_BINOM, 0)

        # 获取 CMD_DBINOM Token 函数
        def CMD_DBINOM(self):
            return self.getToken(LaTeXParser.CMD_DBINOM, 0)

        # 获取 CMD_TBINOM Token 函数
        def CMD_TBINOM(self):
            return self.getToken(LaTeXParser.CMD_TBINOM, 0)

        # 获取表达式（可能是多个）的上下文函数
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(LaTeXParser.ExprContext)
            else:
                return self.getTypedRuleContext(LaTeXParser.ExprContext, i)

        # 返回规则索引函数，指定当前上下文的规则索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_binom
        

    # 定义 binom 函数，用于解析二项式命令
    def binom(self):
        # 创建 BinomContext 实例 localctx，并传入解析器、当前上下文和状态
        localctx = LaTeXParser.BinomContext(self, self._ctx, self.state)
        # 进入规则，指定规则编号为 56，状态为 self.RULE_binom
        self.enterRule(localctx, 56, self.RULE_binom)
        self._la = 0 # Token 类型
        try:
            # 进入第一个替代路径
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 353
            self.state = 353
            # 获取下一个 Token 类型
            _la = self._input.LA(1)
            # 如果不满足以下条件，则进行恢复处理
            if not((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 7) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                # 如果符合条件，则进行消耗当前 Token
                self.consume()
            # 设置状态为 354，匹配左大括号 Token
            self.state = 354
            self.match(LaTeXParser.L_BRACE)
            # 设置状态为 355，获取 n 表达式的上下文
            self.state = 355
            localctx.n = self.expr()
            # 设置状态为 356，匹配右大括号 Token
            self.state = 356
            self.match(LaTeXParser.R_BRACE)
            # 设置状态为 357，匹配左大括号 Token
            self.state = 357
            self.match(LaTeXParser.L_BRACE)
            # 设置状态为 358，获取 k 表达式的上下文
            self.state = 358
            localctx.k = self.expr()
            # 设置状态为 359，匹配右大括号 Token
            self.state = 359
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx，即 BinomContext 实例
        return localctx
    # FloorContext 类定义，用于处理 LaTeX 解析器中的 floor 规则
    class FloorContext(ParserRuleContext):
        # __slots__ 定义以优化内存，仅包含 'parser' 属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser 对象和可选的父级和状态参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.val = None  # 表达式上下文对象

        # 获取左地板符号的 token 方法
        def L_FLOOR(self):
            return self.getToken(LaTeXParser.L_FLOOR, 0)

        # 获取右地板符号的 token 方法
        def R_FLOOR(self):
            return self.getToken(LaTeXParser.R_FLOOR, 0)

        # 获取表达式上下文的方法
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 获取 floor 规则的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_floor


    # floor 方法定义，用于处理 LaTeX 解析器中的 floor 规则
    def floor(self):

        # 创建 FloorContext 对象并传入解析器、当前上下文和状态
        localctx = LaTeXParser.FloorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_floor)
        try:
            # 开始外层交替路径
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            # 匹配左地板符号
            self.match(LaTeXParser.L_FLOOR)
            self.state = 362
            # 获取并设置 val 属性为表达式的结果
            localctx.val = self.expr()
            self.state = 363
            # 匹配右地板符号
            self.match(LaTeXParser.R_FLOOR)
        except RecognitionException as re:
            # 处理识别异常
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx 对象
        return localctx


    # CeilContext 类定义，用于处理 LaTeX 解析器中的 ceil 规则
    class CeilContext(ParserRuleContext):
        # __slots__ 定义以优化内存，仅包含 'parser' 属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser 对象和可选的父级和状态参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.val = None  # 表达式上下文对象

        # 获取左天花板符号的 token 方法
        def L_CEIL(self):
            return self.getToken(LaTeXParser.L_CEIL, 0)

        # 获取右天花板符号的 token 方法
        def R_CEIL(self):
            return self.getToken(LaTeXParser.R_CEIL, 0)

        # 获取表达式上下文的方法
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 获取 ceil 规则的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_ceil


    # ceil 方法定义，用于处理 LaTeX 解析器中的 ceil 规则
    def ceil(self):

        # 创建 CeilContext 对象并传入解析器、当前上下文和状态
        localctx = LaTeXParser.CeilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_ceil)
        try:
            # 开始外层交替路径
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            # 匹配左天花板符号
            self.match(LaTeXParser.L_CEIL)
            self.state = 366
            # 获取并设置 val 属性为表达式的结果
            localctx.val = self.expr()
            self.state = 367
            # 匹配右天花板符号
            self.match(LaTeXParser.R_CEIL)
        except RecognitionException as re:
            # 处理识别异常
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则
            self.exitRule()
        # 返回 localctx 对象
        return localctx
    # 定义一个名为 Func_normalContext 的类，继承自 ParserRuleContext
    class Func_normalContext(ParserRuleContext):
        # 为了提高性能，使用 __slots__ 限制实例能够拥有的属性
        __slots__ = 'parser'
    
        # 初始化方法，接受 parser 参数，同时调用父类的初始化方法
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
    
        # 下面的方法分别用于获取对应于函数表达式的 token
        def FUNC_EXP(self):
            return self.getToken(LaTeXParser.FUNC_EXP, 0)
    
        def FUNC_LOG(self):
            return self.getToken(LaTeXParser.FUNC_LOG, 0)
    
        def FUNC_LG(self):
            return self.getToken(LaTeXParser.FUNC_LG, 0)
    
        def FUNC_LN(self):
            return self.getToken(LaTeXParser.FUNC_LN, 0)
    
        def FUNC_SIN(self):
            return self.getToken(LaTeXParser.FUNC_SIN, 0)
    
        def FUNC_COS(self):
            return self.getToken(LaTeXParser.FUNC_COS, 0)
    
        def FUNC_TAN(self):
            return self.getToken(LaTeXParser.FUNC_TAN, 0)
    
        def FUNC_CSC(self):
            return self.getToken(LaTeXParser.FUNC_CSC, 0)
    
        def FUNC_SEC(self):
            return self.getToken(LaTeXParser.FUNC_SEC, 0)
    
        def FUNC_COT(self):
            return self.getToken(LaTeXParser.FUNC_COT, 0)
    
        def FUNC_ARCSIN(self):
            return self.getToken(LaTeXParser.FUNC_ARCSIN, 0)
    
        def FUNC_ARCCOS(self):
            return self.getToken(LaTeXParser.FUNC_ARCCOS, 0)
    
        def FUNC_ARCTAN(self):
            return self.getToken(LaTeXParser.FUNC_ARCTAN, 0)
    
        def FUNC_ARCCSC(self):
            return self.getToken(LaTeXParser.FUNC_ARCCSC, 0)
    
        def FUNC_ARCSEC(self):
            return self.getToken(LaTeXParser.FUNC_ARCSEC, 0)
    
        def FUNC_ARCCOT(self):
            return self.getToken(LaTeXParser.FUNC_ARCCOT, 0)
    
        def FUNC_SINH(self):
            return self.getToken(LaTeXParser.FUNC_SINH, 0)
    
        def FUNC_COSH(self):
            return self.getToken(LaTeXParser.FUNC_COSH, 0)
    
        def FUNC_TANH(self):
            return self.getToken(LaTeXParser.FUNC_TANH, 0)
    
        def FUNC_ARSINH(self):
            return self.getToken(LaTeXParser.FUNC_ARSINH, 0)
    
        def FUNC_ARCOSH(self):
            return self.getToken(LaTeXParser.FUNC_ARCOSH, 0)
    
        def FUNC_ARTANH(self):
            return self.getToken(LaTeXParser.FUNC_ARTANH, 0)
    
        # 获取规则索引，指示此上下文对应的规则类型
        def getRuleIndex(self):
            return LaTeXParser.RULE_func_normal
    # 定义一个普通函数规则 func_normal
    def func_normal(self):
        # 创建本地上下文 localctx，基于 LaTeXParser.Func_normalContext
        localctx = LaTeXParser.Func_normalContext(self, self._ctx, self.state)
        # 进入规则 func_normal
        self.enterRule(localctx, 62, self.RULE_func_normal)
        # 初始化 _la 为 Token 类型
        self._la = 0
        try:
            # 尝试进入外层规则
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 369
            self.state = 369
            # 获取输入中的下一个 Token 类型
            _la = self._input.LA(1)
            # 检查 Token 类型是否在指定的范围内
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 576460614864470016) != 0):
                # 如果不匹配，使用内联恢复错误处理程序
                self._errHandler.recoverInline(self)
            else:
                # 否则，报告匹配成功并消耗 Token
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            # 捕捉到词法分析异常
            localctx.exception = re
            # 报告错误并恢复异常
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 最终退出规则 func_normal
            self.exitRule()
        # 返回 localctx
        return localctx


    # 定义参数上下文类 ArgsContext，继承自 ParserRuleContext
    class ArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent、invoking 等参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 将 parser 存储在实例变量中
            self.parser = parser

        # 获取 expr 的规则上下文
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 获取 args 的规则上下文
        def args(self):
            return self.getTypedRuleContext(LaTeXParser.ArgsContext,0)

        # 获取规则索引，返回 LaTeXParser.RULE_args
        def getRuleIndex(self):
            return LaTeXParser.RULE_args


    # 定义参数函数 args
    def args(self):
        # 创建本地上下文 localctx，基于 LaTeXParser.ArgsContext
        localctx = LaTeXParser.ArgsContext(self, self._ctx, self.state)
        # 进入规则 args
        self.enterRule(localctx, 66, self.RULE_args)
        try:
            # 同步错误处理程序
            self.state = 467
            # 自适应预测输入中的 la_
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            # 如果预测结果是 1
            if la_ == 1:
                # 进入外层规则 1
                self.enterOuterAlt(localctx, 1)
                # 状态设置为 462
                self.state = 462
                # 调用 expr 规则
                self.expr()
                # 匹配 LaTeXParser.T__0 Token
                self.state = 463
                self.match(LaTeXParser.T__0)
                # 递归调用 args 规则
                self.state = 464
                self.args()
                # 如果预测结果是 2
                pass

            elif la_ == 2:
                # 进入外层规则 2
                self.enterOuterAlt(localctx, 2)
                # 状态设置为 466
                self.state = 466
                # 调用 expr 规则
                self.expr()
                # 如果预测结果是 2，直接通过
                pass

        except RecognitionException as re:
            # 捕捉到词法分析异常
            localctx.exception = re
            # 报告错误并恢复异常
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 最终退出规则 args
            self.exitRule()
        # 返回 localctx
        return localctx
    # 定义 Limit_subContext 类，继承自 ParserRuleContext
    class Limit_subContext(ParserRuleContext):
        # 定义 __slots__，限定类的属性为 'parser'
        __slots__ = 'parser'

        # 初始化方法，接受 parser 参数，并调用父类的初始化方法
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # 定义 UNDERSCORE 方法，返回下划线标记的 token
        def UNDERSCORE(self):
            return self.getToken(LaTeXParser.UNDERSCORE, 0)

        # 定义 L_BRACE 方法，返回左大括号标记的 token 或列表
        def L_BRACE(self, i:int=None):
            if i is None:
                return self.getTokens(LaTeXParser.L_BRACE)
            else:
                return self.getToken(LaTeXParser.L_BRACE, i)

        # 定义 LIM_APPROACH_SYM 方法，返回极限符号的 token
        def LIM_APPROACH_SYM(self):
            return self.getToken(LaTeXParser.LIM_APPROACH_SYM, 0)

        # 定义 expr 方法，返回表达式上下文对象
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext, 0)

        # 定义 R_BRACE 方法，返回右大括号标记的 token 或列表
        def R_BRACE(self, i:int=None):
            if i is None:
                return self.getTokens(LaTeXParser.R_BRACE)
            else:
                return self.getToken(LaTeXParser.R_BRACE, i)

        # 定义 LETTER 方法，返回字母标记的 token
        def LETTER(self):
            return self.getToken(LaTeXParser.LETTER, 0)

        # 定义 SYMBOL 方法，返回符号标记的 token
        def SYMBOL(self):
            return self.getToken(LaTeXParser.SYMBOL, 0)

        # 定义 CARET 方法，返回插入符号标记的 token
        def CARET(self):
            return self.getToken(LaTeXParser.CARET, 0)

        # 定义 ADD 方法，返回加号标记的 token
        def ADD(self):
            return self.getToken(LaTeXParser.ADD, 0)

        # 定义 SUB 方法，返回减号标记的 token
        def SUB(self):
            return self.getToken(LaTeXParser.SUB, 0)

        # 定义 getRuleIndex 方法，返回当前规则的索引
        def getRuleIndex(self):
            return LaTeXParser.RULE_limit_sub
    # 定义名为 limit_sub 的方法，用于处理 LaTeX 解析器中的下标限制
    def limit_sub(self):
        # 创建一个新的限制下标的上下文对象
        localctx = LaTeXParser.Limit_subContext(self, self._ctx, self.state)
        # 进入规则，开始解析限制下标
        self.enterRule(localctx, 68, self.RULE_limit_sub)
        self._la = 0  # 初始化 Token 类型的变量 _la

        try:
            # 设置外部交替路径，即解析的第一个分支
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self.match(LaTeXParser.UNDERSCORE)  # 匹配下标符号 '_'
            self.state = 470
            self.match(LaTeXParser.L_BRACE)  # 匹配左大括号 '{'
            self.state = 471
            _la = self._input.LA(1)
            if not(_la == 77 or _la == 91):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()  # 匹配下标中的特定标识符，77 或者 91
            self.state = 472
            self.match(LaTeXParser.LIM_APPROACH_SYM)  # 匹配极限符号 '\to'
            self.state = 473
            self.expr()  # 调用 expr 方法，处理表达式
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 74:
                self.state = 474
                self.match(LaTeXParser.CARET)  # 匹配上标符号 '^'
                self.state = 480
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [21]:  # 如果下一个 token 是左大括号 '{'
                    self.state = 475
                    self.match(LaTeXParser.L_BRACE)  # 匹配左大括号 '{'
                    self.state = 476
                    _la = self._input.LA(1)
                    if not(_la == 15 or _la == 16):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()  # 匹配 15 或者 16
                    self.state = 477
                    self.match(LaTeXParser.R_BRACE)  # 匹配右大括号 '}'
                    pass
                elif token in [15]:  # 如果下一个 token 是 ADD
                    self.state = 478
                    self.match(LaTeXParser.ADD)  # 匹配 ADD 符号
                    pass
                elif token in [16]:  # 如果下一个 token 是 SUB
                    self.state = 479
                    self.match(LaTeXParser.SUB)  # 匹配 SUB 符号
                    pass
                else:
                    raise NoViableAltException(self)

            self.state = 484
            self.match(LaTeXParser.R_BRACE)  # 匹配右大括号 '}'
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)  # 报告解析错误
            self._errHandler.recover(self, re)  # 恲复解析错误
        finally:
            self.exitRule()  # 退出解析规则
        return localctx  # 返回解析结果的上下文对象
    # 定义函数 func_arg，用于解析 LaTeXParser 中的 func_arg 规则
    def func_arg(self):

        # 创建 Func_argContext 对象 localctx，指定父级和当前状态
        localctx = LaTeXParser.Func_argContext(self, self._ctx, self.state)
        # 进入规则 func_arg
        self.enterRule(localctx, 70, self.RULE_func_arg)
        try:
            # 设置状态为 491
            self.state = 491
            # 同步错误处理器
            self._errHandler.sync(self)
            # 使用自适应预测器分析输入，预测结果存储在 la_ 中
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            # 根据预测结果进行条件判断
            if la_ == 1:
                # 如果预测结果为 1，进入第一分支
                self.enterOuterAlt(localctx, 1)
                # 设置状态为 486，调用 expr 规则
                self.state = 486
                self.expr()
                # 结束第一分支

            elif la_ == 2:
                # 如果预测结果为 2，进入第二分支
                self.enterOuterAlt(localctx, 2)
                # 设置状态为 487，调用 expr 规则
                self.state = 487
                self.expr()
                # 匹配 token T__0
                self.state = 488
                self.match(LaTeXParser.T__0)
                # 设置状态为 489，递归调用 func_arg 规则
                self.state = 489
                self.func_arg()
                # 结束第二分支

        except RecognitionException as re:
            # 捕捉 RecognitionException 异常，将其存储到 localctx 中
            localctx.exception = re
            # 报告错误到错误处理器
            self._errHandler.reportError(self, re)
            # 从异常中恢复，继续处理可能的输入
            self._errHandler.recover(self, re)
        finally:
            # 退出规则 func_arg
            self.exitRule()
        # 返回 localctx 对象
        return localctx


    # 定义 Func_arg_noparensContext 类，继承自 ParserRuleContext
    class Func_arg_noparensContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 设置 parser 属性为传入的 parser 对象
            self.parser = parser

        # 定义 mp_nofunc 方法，返回类型为 Mp_nofuncContext 的 TypedRuleContext
        def mp_nofunc(self):
            return self.getTypedRuleContext(LaTeXParser.Mp_nofuncContext,0)

        # 返回规则索引 LaTeXParser.RULE_func_arg_noparens
        def getRuleIndex(self):
            return LaTeXParser.RULE_func_arg_noparens


    # 定义 func_arg_noparens 方法，解析 LaTeXParser 中的 func_arg_noparens 规则
    def func_arg_noparens(self):

        # 创建 Func_arg_noparensContext 对象 localctx，指定父级和当前状态
        localctx = LaTeXParser.Func_arg_noparensContext(self, self._ctx, self.state)
        # 进入规则 func_arg_noparens
        self.enterRule(localctx, 72, self.RULE_func_arg_noparens)
        try:
            # 进入第一分支，设置状态为 493，调用 mp_nofunc 方法
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.mp_nofunc(0)
        except RecognitionException as re:
            # 捕捉 RecognitionException 异常，将其存储到 localctx 中
            localctx.exception = re
            # 报告错误到错误处理器
            self._errHandler.reportError(self, re)
            # 从异常中恢复，继续处理可能的输入
            self._errHandler.recover(self, re)
        finally:
            # 退出规则 func_arg_noparens
            self.exitRule()
        # 返回 localctx 对象
        return localctx


    # 定义 SubexprContext 类，继承自 ParserRuleContext
    class SubexprContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 设置 parser 属性为传入的 parser 对象
            self.parser = parser

        # 定义 UNDERSCORE 方法，返回 token 类型为 LaTeXParser.UNDERSCORE 的 token
        def UNDERSCORE(self):
            return self.getToken(LaTeXParser.UNDERSCORE, 0)

        # 定义 atom 方法，返回类型为 AtomContext 的 TypedRuleContext
        def atom(self):
            return self.getTypedRuleContext(LaTeXParser.AtomContext,0)

        # 定义 L_BRACE 方法，返回 token 类型为 LaTeXParser.L_BRACE 的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 定义 expr 方法，返回类型为 ExprContext 的 TypedRuleContext
        def expr(self):
            return self.getTypedRuleContext(LaTeXParser.ExprContext,0)

        # 定义 R_BRACE 方法，返回 token 类型为 LaTeXParser.R_BRACE 的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 返回规则索引 LaTeXParser.RULE_subexpr
        def getRuleIndex(self):
            return LaTeXParser.RULE_subexpr
    # 定义名为 subexpr 的方法，用于处理 LaTeXParser 中的子表达式
    def subexpr(self):
        # 创建 SubexprContext 对象，传入当前 parser、父级 context 和当前状态
        localctx = LaTeXParser.SubexprContext(self, self._ctx, self.state)
        # 进入规则，设置当前规则为 subexpr，状态为 74
        self.enterRule(localctx, 74, self.RULE_subexpr)
        try:
            # 进入第一个替代路径
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 495，匹配下划线符号 '_'
            self.state = 495
            self.match(LaTeXParser.UNDERSCORE)
            # 同步错误处理，获取下一个输入的 token 类型
            self.state = 501
            self._errHandler.sync(self)
            token = self._input.LA(1)
            # 根据不同的 token 类型进入不同的处理分支
            if token in [27, 29, 30, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                # 处理原子表达式
                self.state = 496
                self.atom()
                pass
            elif token in [21]:
                # 处理花括号包裹的表达式
                self.state = 497
                self.match(LaTeXParser.L_BRACE)
                self.state = 498
                self.expr()
                self.state = 499
                self.match(LaTeXParser.R_BRACE)
                pass
            else:
                # 抛出无法处理的异常
                raise NoViableAltException(self)

        except RecognitionException as re:
            # 处理语法识别异常，报告错误并尝试恢复
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            # 退出规则处理
            self.exitRule()
        # 返回处理的 localctx 对象
        return localctx
    # 定义一个名为 supexpr 的方法，属于当前对象的一部分
    def supexpr(self):

        # 创建一个新的上下文对象，表示 LaTeXParser.SupexprContext 的实例，使用当前对象和状态初始化
        localctx = LaTeXParser.SupexprContext(self, self._ctx, self.state)
        # 进入 supexpr 规则，标识为第 76 条规则
        self.enterRule(localctx, 76, self.RULE_supexpr)
        try:
            # 进入外层语法替代（alternative），标识为 1
            self.enterOuterAlt(localctx, 1)
            # 设置当前状态为 503
            self.state = 503
            # 匹配 CARET 符号（^）
            self.match(LaTeXParser.CARET)
            # 同步输入并获取当前 token
            self.state = 509
            self._errHandler.sync(self)
            token = self._input.LA(1)
            # 根据 token 类型分支处理
            if token in [27, 29, 30, 68, 69, 70, 71, 72, 76, 77, 78, 91]:
                # 如果 token 类型为指定的值之一，调用 atom 方法
                self.state = 504
                self.atom()
                pass
            elif token in [21]:
                # 如果 token 类型为 21，匹配左大括号，然后调用 expr 方法，最后匹配右大括号
                self.state = 505
                self.match(LaTeXParser.L_BRACE)
                self.state = 506
                self.expr()
                self.state = 507
                self.match(LaTeXParser.R_BRACE)
                pass
            else:
                # 如果 token 类型既不是指定值也不是 21，则抛出 NoViableAltException 异常
                raise NoViableAltException(self)

        except RecognitionException as re:
            # 捕获 RecognitionException 异常并报告错误
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恕获异常后尝试恢复解析过程
            self._errHandler.recover(self, re)
        finally:
            # 最终退出当前规则
            self.exitRule()
        # 返回 localctx 对象
        return localctx


    # 定义一个名为 SubeqContext 的类，继承自 ParserRuleContext 类
    class SubeqContext(ParserRuleContext):
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 设置 parser 属性为传入的 parser 对象
            self.parser = parser

        # 获取 UNDERSCORE 标记的方法
        def UNDERSCORE(self):
            return self.getToken(LaTeXParser.UNDERSCORE, 0)

        # 获取 L_BRACE 标记的方法
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 获取 equality 规则的上下文对象的方法
        def equality(self):
            return self.getTypedRuleContext(LaTeXParser.EqualityContext,0)

        # 获取 R_BRACE 标记的方法
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 获取规则索引的方法，返回 RULE_subeq
        def getRuleIndex(self):
            return LaTeXParser.RULE_subeq


    # 定义一个名为 subeq 的方法，属于当前对象的一部分
    def subeq(self):

        # 创建一个新的上下文对象，表示 LaTeXParser.SubeqContext 的实例，使用当前对象和状态初始化
        localctx = LaTeXParser.SubeqContext(self, self._ctx, self.state)
        # 进入 subeq 规则，标识为第 78 条规则
        self.enterRule(localctx, 78, self.RULE_subeq)
        try:
            # 进入外层语法替代（alternative），标识为 1
            self.enterOuterAlt(localctx, 1)
            # 匹配 UNDERSCORE 标记（_）
            self.state = 511
            self.match(LaTeXParser.UNDERSCORE)
            # 匹配 L_BRACE 标记（{）
            self.state = 512
            self.match(LaTeXParser.L_BRACE)
            # 调用 equality 方法
            self.state = 513
            self.equality()
            # 匹配 R_BRACE 标记（}）
            self.state = 514
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            # 捕获 RecognitionException 异常并报告错误
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 捕获异常后尝试恢复解析过程
            self._errHandler.recover(self, re)
        finally:
            # 最终退出当前规则
            self.exitRule()
        # 返回 localctx 对象
        return localctx
    # 定义一个名为 SupeqContext 的类，继承自 ParserRuleContext
    class SupeqContext(ParserRuleContext):
        # 定义 __slots__，限定实例可以拥有的属性，这里只有 'parser' 一个属性
        __slots__ = 'parser'

        # 初始化方法，接受 parser、parent 和 invokingState 三个参数
        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            # 调用父类的初始化方法
            super().__init__(parent, invokingState)
            # 将 parser 参数赋值给实例的 parser 属性
            self.parser = parser

        # 定义 UNDERSCORE 方法，返回 UNDERSCORE 的 token
        def UNDERSCORE(self):
            return self.getToken(LaTeXParser.UNDERSCORE, 0)

        # 定义 L_BRACE 方法，返回 L_BRACE 的 token
        def L_BRACE(self):
            return self.getToken(LaTeXParser.L_BRACE, 0)

        # 定义 equality 方法，返回 equality 的规则上下文对象
        def equality(self):
            return self.getTypedRuleContext(LaTeXParser.EqualityContext,0)

        # 定义 R_BRACE 方法，返回 R_BRACE 的 token
        def R_BRACE(self):
            return self.getToken(LaTeXParser.R_BRACE, 0)

        # 返回当前规则的索引，此处为 RULE_supeq
        def getRuleIndex(self):
            return LaTeXParser.RULE_supeq


    # 定义 supeq 方法
    def supeq(self):
        # 创建一个 SupeqContext 实例，传入当前解析器、当前上下文和当前状态
        localctx = LaTeXParser.SupeqContext(self, self._ctx, self.state)
        # 进入规则 supeq，索引为 80，进入外部替代位置 1
        self.enterRule(localctx, 80, self.RULE_supeq)
        try:
            # 进入外部替代位置 1
            self.enterOuterAlt(localctx, 1)
            # 设置状态为 516，匹配 UNDERSCORE token
            self.state = 516
            self.match(LaTeXParser.UNDERSCORE)
            # 设置状态为 517，匹配 L_BRACE token
            self.state = 517
            self.match(LaTeXParser.L_BRACE)
            # 设置状态为 518，调用 equality 方法
            self.state = 518
            self.equality()
            # 设置状态为 519，匹配 R_BRACE token
            self.state = 519
            self.match(LaTeXParser.R_BRACE)
        except RecognitionException as re:
            # 捕捉 RecognitionException 异常并报告
            localctx.exception = re
            self._errHandler.reportError(self, re)
            # 恕捉 RecognitionException 并恢复
            self._errHandler.recover(self, re)
        finally:
            # 退出规则 supeq
            self.exitRule()
        # 返回 localctx 对象
        return localctx


    # 定义 sempred 方法
    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        # 如果 _predicates 为空，初始化为一个字典
        if self._predicates == None:
            self._predicates = dict()
        # 设置不同 ruleIndex 对应的 pred 方法
        self._predicates[1] = self.relation_sempred
        self._predicates[4] = self.additive_sempred
        self._predicates[5] = self.mp_sempred
        self._predicates[6] = self.mp_nofunc_sempred
        self._predicates[15] = self.exp_sempred
        self._predicates[16] = self.exp_nofunc_sempred
        # 获取对应 ruleIndex 的 pred 方法
        pred = self._predicates.get(ruleIndex, None)
        # 如果未找到对应的 pred 方法，抛出异常
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            # 调用对应的 pred 方法，传入 localctx 和 predIndex 参数
            return pred(localctx, predIndex)


    # 定义 relation_sempred 方法
    def relation_sempred(self, localctx:RelationContext, predIndex:int):
        # 如果 predIndex 为 0，返回当前上下文和 2 的 precpred 结果
        if predIndex == 0:
            return self.precpred(self._ctx, 2)


    # 定义 additive_sempred 方法
    def additive_sempred(self, localctx:AdditiveContext, predIndex:int):
        # 如果 predIndex 为 1，返回当前上下文和 2 的 precpred 结果
        if predIndex == 1:
            return self.precpred(self._ctx, 2)


    # 定义 mp_sempred 方法
    def mp_sempred(self, localctx:MpContext, predIndex:int):
        # 如果 predIndex 为 2，返回当前上下文和 2 的 precpred 结果
        if predIndex == 2:
            return self.precpred(self._ctx, 2)


    # 定义 mp_nofunc_sempred 方法
    def mp_nofunc_sempred(self, localctx:Mp_nofuncContext, predIndex:int):
        # 如果 predIndex 为 3，返回当前上下文和 2 的 precpred 结果
        if predIndex == 3:
            return self.precpred(self._ctx, 2)


    # 定义 exp_sempred 方法
    def exp_sempred(self, localctx:ExpContext, predIndex:int):
        # 如果 predIndex 为 4，返回当前上下文和 2 的 precpred 结果
        if predIndex == 4:
            return self.precpred(self._ctx, 2)
    # 定义一个名为 exp_nofunc_sempred 的方法，接受 self, localctx 和 predIndex 三个参数
    def exp_nofunc_sempred(self, localctx:Exp_nofuncContext, predIndex:int):
        # 检查 predIndex 是否等于 5，如果是则执行下面的代码
        if predIndex == 5:
            # 调用当前对象（self）的 precpred 方法，传入当前上下文对象（self._ctx）和预测索引值 2 作为参数，并返回结果
            return self.precpred(self._ctx, 2)
```