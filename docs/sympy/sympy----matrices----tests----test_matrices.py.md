# `D:\src\scipysrc\sympy\sympy\matrices\tests\test_matrices.py`

```
#
# 测试已弃用的矩阵类的代码。不应在此处添加新的测试代码。而是应将其添加到 test_matrixbase.py 中。
#

# 将并发执行库导入当前命名空间
import concurrent.futures
# 从 collections.abc 模块中导入 Hashable 抽象基类
from collections.abc import Hashable

# 从 sympy.core.add 模块导入 Add 类
from sympy.core.add import Add
# 从 sympy.core.function 模块导入 Function、diff 和 expand 函数
from sympy.core.function import Function, diff, expand
# 从 sympy.core.numbers 模块导入多个数学常数和类型，如 E、Float、I、Integer、Rational 等
from sympy.core.numbers import (E, Float, I, Integer, Rational, nan, oo, pi)
# 从 sympy.core.power 模块导入 Pow 类
from sympy.core.power import Pow
# 从 sympy.core.singleton 模块导入 S 单例对象
from sympy.core.singleton import S
# 从 sympy.core.symbol 模块导入 Symbol 和 symbols 函数
from sympy.core.symbol import (Symbol, symbols)
# 从 sympy.core.sympify 模块导入 sympify 函数
from sympy.core.sympify import sympify
# 从 sympy.functions.elementary.complexes 模块导入 Abs 函数
from sympy.functions.elementary.complexes import Abs
# 从 sympy.functions.elementary.exponential 模块导入 exp 和 log 函数
from sympy.functions.elementary.exponential import (exp, log)
# 从 sympy.functions.elementary.miscellaneous 模块导入 Max 和 Min 函数
from sympy.functions.elementary.miscellaneous import (Max, Min, sqrt)
# 从 sympy.functions.elementary.trigonometric 模块导入 cos、sin 和 tan 函数
from sympy.functions.elementary.trigonometric import (cos, sin, tan)
# 从 sympy.integrals.integrals 模块导入 integrate 函数
from sympy.integrals.integrals import integrate
# 从 sympy.polys.polytools 模块导入 Poly 和 PurePoly 类
from sympy.polys.polytools import (Poly, PurePoly)
# 从 sympy.polys.rootoftools 模块导入 RootOf 类
from sympy.polys.rootoftools import RootOf
# 从 sympy.printing.str 模块导入 sstr 函数
from sympy.printing.str import sstr
# 从 sympy.sets.sets 模块导入 FiniteSet 类
from sympy.sets.sets import FiniteSet
# 从 sympy.simplify.simplify 模块导入 signsimp 和 simplify 函数
from sympy.simplify.simplify import (signsimp, simplify)
# 从 sympy.simplify.trigsimp 模块导入 trigsimp 函数
from sympy.simplify.trigsimp import trigsimp
# 从 sympy.matrices.exceptions 模块导入 ShapeError、MatrixError 和 NonSquareMatrixError 异常类
from sympy.matrices.exceptions import (ShapeError, MatrixError, NonSquareMatrixError)
# 从 sympy.matrices.matrixbase 模块导入 DeferredVector 类
from sympy.matrices.matrixbase import DeferredVector
# 从 sympy.matrices.determinant 模块导入 _find_reasonable_pivot_naive 函数
from sympy.matrices.determinant import _find_reasonable_pivot_naive
# 从 sympy.matrices.utilities 模块导入 _simplify 函数
from sympy.matrices.utilities import _simplify
# 从 sympy.matrices 模块导入多个矩阵类和函数
from sympy.matrices import (
    GramSchmidt, ImmutableMatrix, ImmutableSparseMatrix, Matrix,
    SparseMatrix, casoratian, diag, eye, hessian,
    matrix_multiply_elementwise, ones, randMatrix, rot_axis1, rot_axis2,
    rot_axis3, wronskian, zeros, MutableDenseMatrix, ImmutableDenseMatrix,
    MatrixSymbol, dotprodsimp, rot_ccw_axis1, rot_ccw_axis2, rot_ccw_axis3)
# 从 sympy.matrices.utilities 模块导入 _dotprodsimp_state 函数
from sympy.matrices.utilities import _dotprodsimp_state
# 从 sympy.core 模块导入 Tuple 和 Wild 类
from sympy.core import Tuple, Wild
# 从 sympy.functions.special.tensor_functions 模块导入 KroneckerDelta 函数
from sympy.functions.special.tensor_functions import KroneckerDelta
# 从 sympy.utilities.iterables 模块导入 flatten、capture 和 iterable 函数
from sympy.utilities.iterables import flatten, capture, iterable
# 从 sympy.utilities.exceptions 模块导入 ignore_warnings 函数
from sympy.utilities.exceptions import ignore_warnings
# 从 sympy.testing.pytest 模块导入多个测试装饰器和函数，如 raises、XFAIL、slow 等
from sympy.testing.pytest import (raises, XFAIL, slow, skip, skip_under_pyodide,
                                  warns_deprecated_sympy)
# 从 sympy.assumptions 模块导入 Q 对象
from sympy.assumptions import Q
# 从 sympy.tensor.array 模块导入 Array 类
from sympy.tensor.array import Array
# 从 sympy.tensor.array.array_derivatives 模块导入 ArrayDerivative 类
from sympy.tensor.array.array_derivatives import ArrayDerivative
# 从 sympy.matrices.expressions 模块导入 MatPow 类
from sympy.matrices.expressions import MatPow
# 从 sympy.algebras 模块导入 Quaternion 类
from sympy.algebras import Quaternion

# 从 sympy.abc 模块导入多个符号变量
from sympy.abc import a, b, c, d, x, y, z, t


# 不要重新排列这个列表
# 定义矩阵类元组
classes = (Matrix, SparseMatrix, ImmutableMatrix, ImmutableSparseMatrix)


# 测试已弃用的 matrixmixins
# 从 sympy.matrices.common 模块导入 _MinimalMatrix 和 _CastableMatrix 类
from sympy.matrices.common import _MinimalMatrix, _CastableMatrix
# 从 sympy.matrices.matrices 模块导入 MatrixSubspaces 和 MatrixReductions 类
from sympy.matrices.matrices import MatrixSubspaces, MatrixReductions

# 使用 warns_deprecated_sympy 上下文管理器
with warns_deprecated_sympy():
    # 定义一个新类 SubspaceOnlyMatrix，继承自 _MinimalMatrix、_CastableMatrix 和 MatrixSubspaces
    class SubspaceOnlyMatrix(_MinimalMatrix, _CastableMatrix, MatrixSubspaces):
        pass

# 使用 warns_deprecated_sympy 上下文管理器
with warns_deprecated_sympy():
    # 继续定义其他已弃用的类或函数，未完整提供代码，继续编辑以包含完整内容
    pass
    # 定义一个类 ReductionsOnlyMatrix，继承自 _MinimalMatrix、_CastableMatrix 和 MatrixReductions
    class ReductionsOnlyMatrix(_MinimalMatrix, _CastableMatrix, MatrixReductions):
        # pass 语句表示类定义结束，不添加任何额外的方法或属性
        pass
# 定义一个函数，返回一个只有主对角线为1的方形矩阵，大小为 n x n
def eye_Reductions(n):
    return ReductionsOnlyMatrix(n, n, lambda i, j: int(i == j))

# 定义一个函数，返回一个全为0的方形矩阵，大小为 n x n
def zeros_Reductions(n):
    return ReductionsOnlyMatrix(n, n, lambda i, j: 0)

# 测试函数，验证各个类的实例方法的行为
def test_args():
    # 遍历 classes 列表中的索引和类对象
    for n, cls in enumerate(classes):
        # 创建一个大小为 (3, 2) 的零矩阵 m
        m = cls.zeros(3, 2)
        # 断言 m 的形状为 (3, 2)，并且每个维度的类型为 int
        assert m.shape == (3, 2) and all(type(i) is int for i in m.shape)
        # 断言 m 的行数为 3，且类型为 int
        assert m.rows == 3 and type(m.rows) is int
        # 断言 m 的列数为 2，且类型为 int
        assert m.cols == 2 and type(m.cols) is int
        # 如果 n 是偶数，断言 m 的 flat 方法返回的类型是 list、tuple 或 Tuple
        if not n % 2:
            assert type(m.flat()) in (list, tuple, Tuple)
        # 如果 n 是奇数，断言 m 的 todok 方法返回的类型是 dict
        else:
            assert type(m.todok()) is dict

# 测试函数，验证矩阵的私有属性 _mat 和 _smat 的行为已过时
def test_deprecated_mat_smat():
    # 遍历 Matrix 和 ImmutableMatrix 类
    for cls in Matrix, ImmutableMatrix:
        # 创建一个大小为 (3, 2) 的零矩阵 m
        m = cls.zeros(3, 2)
        # 使用 warns_deprecated_sympy 上下文，获取 m 的 _mat 属性
        with warns_deprecated_sympy():
            mat = m._mat
        # 断言 _mat 等于 m 的 flat 方法返回值
        assert mat == m.flat()
    # 遍历 SparseMatrix 和 ImmutableSparseMatrix 类
    for cls in SparseMatrix, ImmutableSparseMatrix:
        # 创建一个大小为 (3, 2) 的零矩阵 m
        m = cls.zeros(3, 2)
        # 使用 warns_deprecated_sympy 上下文，获取 m 的 _smat 属性
        with warns_deprecated_sympy():
            smat = m._smat
        # 断言 _smat 等于 m 的 todok 方法返回值
        assert smat == m.todok()

# 测试函数，验证矩阵的除法运算行为
def test_division():
    # 创建一个包含符号 x 和 y 的 1x2 矩阵 v
    v = Matrix(1, 2, [x, y])
    # 断言 v 除以 z 的结果等于包含 x/z 和 y/z 的 1x2 矩阵
    assert v/z == Matrix(1, 2, [x/z, y/z])

# 测试函数，验证矩阵的加法运算行为
def test_sum():
    # 创建一个包含整数和符号的矩阵 m
    m = Matrix([[1, 2, 3], [x, y, x], [2*y, -50, z*x]])
    # 断言 m 加 m 的结果等于对应位置元素相加的矩阵
    assert m + m == Matrix([[2, 4, 6], [2*x, 2*y, 2*x], [4*y, -100, 2*z*x]])
    # 创建一个包含整数的 1x2 矩阵 n
    n = Matrix(1, 2, [1, 2])
    # 断言尝试将 m 与 n 相加会引发 ShapeError 异常
    raises(ShapeError, lambda: m + n)

# 测试函数，验证矩阵的绝对值运算行为
def test_abs():
    # 创建一个包含整数和符号的 1x2 矩阵 m
    m = Matrix(1, 2, [-3, x])
    # 创建一个包含整数和 Abs(x) 的 1x2 矩阵 n
    n = Matrix(1, 2, [3, Abs(x)])
    # 断言 m 的绝对值等于 n
    assert abs(m) == n

# 测试函数，验证矩阵的加法运算和 add 方法的等价性
def test_addition():
    # 创建一个包含整数的 2x2 矩阵 a 和 b
    a = Matrix((
        (1, 2),
        (3, 1),
    ))
    b = Matrix((
        (1, 2),
        (3, 0),
    ))
    # 断言 a 加 b 等于 a.add(b) 等于包含对应位置元素相加的矩阵
    assert a + b == a.add(b) == Matrix([[2, 4], [6, 1]])

# 测试函数，验证矩阵的索引和切片操作行为
def test_fancy_index_matrix():
    # 遍历 Matrix 和 SparseMatrix 类
    for M in (Matrix, SparseMatrix):
        # 创建一个包含 0 到 8 的 3x3 矩阵 a
        a = M(3, 3, range(9))
        # 断言 a 等于 a 的全行全列切片
        assert a == a[:, :]
        # 断言 a 的第1行等于包含 [3, 4, 5] 的 1x3 矩阵
        assert a[1, :] == Matrix(1, 3, [3, 4, 5])
        # 断言 a 的全列第1列等于包含 [1, 4, 7] 的矩阵
        assert a[:, 1] == Matrix([1, 4, 7])
        # 断言 a 的第0行和第1行等于包含 [[0, 1, 2], [3, 4, 5]] 的矩阵
        assert a[[0, 1], :] == Matrix([[0, 1, 2], [3, 4, 5]])
        # 断言 a 的第0行和第1行的第2列等于 a 的第0行和第1行的第2列
        assert a[[0, 1], 2] == a[[0, 1], [2]]
        # 断言 a 的第2行的第0列和第1列等于 a 的第2行的第0列和第1列
        assert a[2, [0, 1]] == a[[2], [0, 1]]
        # 断言 a 的全列的第0列和第1列等于包含 [[0, 1], [3, 4], [6, 7]] 的矩阵
        assert a[:, [0, 1]] == Matrix([[0, 1], [3, 4], [6, 7]])
        # 断言 a 的第0行和第1行的第0列等于 0
        assert a[0, 0] == 0
        # 断言 a 的前两行等于包含 [[0, 1, 2], [3, 4, 5]] 的矩阵
        assert a[0:2, :] == Matrix([[0, 1, 2], [3, 4, 5]])
        # 断言 a 的全列的前两列等于包含 [[0, 1], [3, 4], [6, 7]] 的矩阵
        assert a[:, 0:2] == Matrix([[0, 1], [3, 4], [6, 7]])
        # 断言 a 的每隔两行的第1列等于 a 的包含 [[0, 2], [3, 5]] 的列向量
        assert a[::2, 1] == a[[0, 2], 1]
        # 断言 a 的第1行的每隔两列等于 a 的第1行的包含 [0, 2] 的行向量
        assert a[1, ::
    # 使用断言检查矩阵对象a的extract方法返回的结果是否符合预期
    assert a.extract([1, 0, 1, 2], [2, 0, 1, 0]) == Matrix([
        [2, 0, 0, 0],       # 第一行：期望结果中第一行的数值
        [0, 0, 3, 0],       # 第二行：期望结果中第二行的数值
        [2, 0, 0, 0],       # 第三行：期望结果中第三行的数值
        [0, 4, 0, 4]        # 第四行：期望结果中第四行的数值
    ])
# 定义一个用于测试矩阵乘法及其它功能的函数
def test_multiplication():
    # 创建矩阵 a，包含三行两列的整数数据
    a = Matrix((
        (1, 2),
        (3, 1),
        (0, 6),
    ))

    # 创建矩阵 b，包含两行两列的整数数据
    b = Matrix((
        (1, 2),
        (3, 0),
    ))

    # 计算矩阵 a 和 b 的乘积，结果存储在矩阵 c 中
    c = a*b

    # 断言乘积结果矩阵 c 中特定位置的值
    assert c[0, 0] == 7
    assert c[0, 1] == 2
    assert c[1, 0] == 6
    assert c[1, 1] == 6
    assert c[2, 0] == 18
    assert c[2, 1] == 0

    # 尝试使用 @ 运算符进行矩阵乘法，预期捕获 SyntaxError 异常
    try:
        eval('c = a @ b')
    except SyntaxError:
        pass
    else:
        # 如果没有捕获到 SyntaxError，则再次断言乘积结果矩阵 c 中特定位置的值
        assert c[0, 0] == 7
        assert c[0, 1] == 2
        assert c[1, 0] == 6
        assert c[1, 1] == 6
        assert c[2, 0] == 18
        assert c[2, 1] == 0

    # 对矩阵 a 和 c 进行逐元素乘法，结果存储在矩阵 h 中
    h = matrix_multiply_elementwise(a, c)

    # 断言逐元素乘法函数的结果是否与方法调用结果一致
    assert h == a.multiply_elementwise(c)
    assert h[0, 0] == 7
    assert h[0, 1] == 4
    assert h[1, 0] == 18
    assert h[1, 1] == 6
    assert h[2, 0] == 0
    assert h[2, 1] == 0

    # 检查使用非相容矩阵进行逐元素乘法时是否引发 ShapeError 异常
    raises(ShapeError, lambda: matrix_multiply_elementwise(a, b))

    # 将矩阵 b 与符号 "x" 进行乘法运算，结果存储在矩阵 c 中
    c = b * Symbol("x")

    # 断言乘法结果是否为 Matrix 类型，并检查矩阵 c 中特定位置的值
    assert isinstance(c, Matrix)
    assert c[0, 0] == x
    assert c[0, 1] == 2*x
    assert c[1, 0] == 3*x
    assert c[1, 1] == 0

    # 对矩阵 b 与整数 5 进行乘法运算，结果存储在矩阵 c 中
    c = 5 * b

    # 断言乘法结果是否为 Matrix 类型，并检查矩阵 c 中特定位置的值
    assert isinstance(c, Matrix)
    assert c[0, 0] == 5
    assert c[0, 1] == 2*5
    assert c[1, 0] == 3*5
    assert c[1, 1] == 0

    # 尝试使用 @ 运算符进行矩阵乘法，预期捕获 SyntaxError 异常
    try:
        eval('c = 5 @ b')
    except SyntaxError:
        pass
    else:
        # 如果没有捕获到 SyntaxError，则再次断言乘法结果矩阵 c 中特定位置的值
        assert isinstance(c, Matrix)
        assert c[0, 0] == 5
        assert c[0, 1] == 2*5
        assert c[1, 0] == 3*5
        assert c[1, 1] == 0

    # 创建矩阵 M，包含无穷大元素
    M = Matrix([[oo, 0], [0, oo]])

    # 断言矩阵 M 的平方等于自身
    assert M ** 2 == M

    # 创建矩阵 M，包含无穷大和零元素
    M = Matrix([[oo, oo], [0, 0]])

    # 断言矩阵 M 的平方等于具有 NaN 元素的矩阵
    assert M ** 2 == Matrix([[nan, nan], [nan, nan]])


# 定义一个用于测试矩阵幂运算的函数
def test_power():
    # 检查对非方阵应用幂运算时是否引发 NonSquareMatrixError 异常
    raises(NonSquareMatrixError, lambda: Matrix((1, 2))**2)

    # 定义有理数 R
    R = Rational

    # 创建矩阵 A，包含整数元素
    A = Matrix([[2, 3], [4, 5]])

    # 断言 A 的负三次方和五次方的结果
    assert (A**-3)[:] == [R(-269)/8, R(153)/8, R(51)/2, R(-29)/2]
    assert (A**5)[:] == [6140, 8097, 10796, 14237]

    # 创建矩阵 A，包含整数元素
    A = Matrix([[2, 1, 3], [4, 2, 4], [6, 12, 1]])

    # 断言 A 的三次方结果
    assert (A**3)[:] == [290, 262, 251, 448, 440, 368, 702, 954, 433]

    # 断言 A 的零次方和单位矩阵是否相等
    assert A**0 == eye(3)

    # 断言 A 的一次方等于自身
    assert A**1 == A

    # 断言单元素矩阵的百万次方结果
    assert (Matrix([[2]]) ** 100)[0, 0] == 2**100

    # 断言单位矩阵的百万次方结果
    assert eye(2)**10000000 == eye(2)

    # 断言矩阵的整数次方运算
    assert Matrix([[1, 2], [3, 4]])**Integer(2) == Matrix([[7, 10], [15, 22]])

    # 创建矩阵 A，包含整数元素
    A = Matrix([[33, 24], [48, 57]])

    # 断言 A 的平方根幂运算结果
    assert (A**S.Half)[:] == [5, 2, 4, 7]

    # 创建矩阵 A，包含整数元素
    A = Matrix([[0, 4], [-1, 5]])

    # 断言 A 的平方根幂运算的平方结果等于自身
    assert (A**S.Half)**2 == A

    # 断言矩阵的半整数次方运算结果
    assert Matrix([[1, 0], [1, 1]])**S.Half == Matrix([[1, 0], [S.Half, 1]])
    assert Matrix([[1, 0], [1, 1]])**0.5 == Matrix([[1, 0], [0.5, 1]])

    # 导入符号变量 n
    from sympy.abc import n

    # 断言带有符号变量的矩阵幂运算结果
    assert Matrix([[1, a], [0, 1]])**n == Matrix([[1, a*n], [0, 1]])

    # 断言带有符号变量的矩阵幂运算结果
    assert Matrix([[b, a], [0, b]])**n == Matrix([[b**n, a
    # 创建一个 2x2 的矩阵 A
    A = Matrix([[1, 0], [1, 7]])
    # 使用 Jordan 块的幂方法和递归方法进行三次方的计算，并进行断言验证它们的结果相同
    assert A._matrix_pow_by_jordan_blocks(S(3)) == A._eval_pow_by_recursion(3)
    
    # 创建一个 1x1 的矩阵 A
    A = Matrix([[2]])
    # 断言 A 的十次方等于 Matrix([[2**10]]) 并且使用不同方法计算结果相同
    assert A**10 == Matrix([[2**10]]) == A._matrix_pow_by_jordan_blocks(S(10)) == \
        A._eval_pow_by_recursion(10)

    # 创建一个不可进行 Jordan 块分解的矩阵 m，测试 issue 11766
    m = Matrix([[3, 0, 0, 0, -3], [0, -3, -3, 0, 3], [0, 3, 0, 3, 0], [0, 0, 3, 0, 3], [3, 0, 0, 3, 0]])
    # 使用 lambda 函数检查是否抛出 MatrixError 异常
    raises(MatrixError, lambda: m._matrix_pow_by_jordan_blocks(S(10)))

    # 测试 issue 11964
    raises(MatrixError, lambda: Matrix([[1, 1], [3, 3]])._matrix_pow_by_jordan_blocks(S(-10)))
    # 创建一个 3x3 的矩阵 A，其中存在 Jordan 块的大小为 3
    A = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])
    # 断言 A 的 10.0 次方结果为全零矩阵
    assert A**10.0 == Matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])
    # 使用 lambda 函数检查是否抛出 ValueError 异常
    raises(ValueError, lambda: A**2.1)
    raises(ValueError, lambda: A**Rational(3, 2))

    # 创建一个 2x2 的矩阵 A
    A = Matrix([[8, 1], [3, 2]])
    # 断言 A 的 10.0 次方的结果
    assert A**10.0 == Matrix([[1760744107, 272388050], [817164150, 126415807]])

    # 创建一个 3x3 的矩阵 A，其中存在 Jordan 块的大小为 1
    A = Matrix([[0, 0, 1], [0, 0, 1], [0, 0, 1]])
    # 断言 A 的 10.0 次方结果与 A 的 10 次方结果相同
    assert A**10.0 == Matrix([[0, 0, 1], [0, 0, 1], [0, 0, 1]])

    # 创建一个 3x3 的矩阵 A，其中存在 Jordan 块的大小为 2
    A = Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 1]])
    # 断言 A 的 10.0 次方结果与 A 的 10 次方结果相同
    assert A**10.0 == Matrix([[0, 0, 1], [0, 0, 1], [0, 0, 1]])

    # 创建一个符号变量 n
    n = Symbol('n', integer=True)
    # 断言 A 的 n 次方是 MatPow 对象的实例
    assert isinstance(A**n, MatPow)

    # 创建一个符号变量 n，其值为负数
    n = Symbol('n', integer=True, negative=True)
    # 使用 lambda 函数检查是否抛出 ValueError 异常
    raises(ValueError, lambda: A**n)

    # 创建一个符号变量 n，其值为非负数
    n = Symbol('n', integer=True, nonnegative=True)
    # 断言 A 的 n 次方结果与给定的矩阵相同
    assert A**n == Matrix([
        [KroneckerDelta(0, n), KroneckerDelta(1, n), -KroneckerDelta(0, n) - KroneckerDelta(1, n) + 1],
        [                   0, KroneckerDelta(0, n),                         1 - KroneckerDelta(0, n)],
        [                   0,                    0,                                                1]])
    # 断言 A 的 n+2 次方结果与 A 的 10 次方结果相同
    assert A**(n + 2) == Matrix([[0, 0, 1], [0, 0, 1], [0, 0, 1]])

    # 使用 lambda 函数检查是否抛出 ValueError 异常
    raises(ValueError, lambda: A**Rational(3, 2))

    # 创建一个 3x3 的矩阵 A
    A = Matrix([[0, 0, 1], [3, 0, 1], [4, 3, 1]])
    # 断言 A 的 5.0 次方结果
    assert A**5.0 == Matrix([[168,  72,  89], [291, 144, 161], [572, 267, 329]])
    # 断言 A 的 5.0 次方结果与 A 的 5 次方结果相同
    assert A**5.0 == A**5

    # 创建一个 3x3 的矩阵 A
    A = Matrix([[0, 1, 0],[-1, 0, 0],[0, 0, 0]])
    # 创建一个符号变量 n
    n = Symbol("n")
    # 计算 An 并断言其在 n=2 时的值等于 A 的二次方
    An = A**n
    assert An.subs(n, 2).doit() == A**2
    # 使用 lambda 函数检查是否抛出 ValueError 异常
    raises(ValueError, lambda: An.subs(n, -2).doit())
    # 断言 An 和 An 的乘积等于 A 的 2n 次方结果
    assert An * An == A**(2*n)

    # 创建一个 3x3 的零矩阵 A
    A = Matrix([[0,0,0],[0,0,0],[0,0,0]])
    # 创建一个符号变量 n，其值为正整数
    n = Symbol('n', integer=True, positive=True)
    # 断言 A 的 n 次方结果为 A
    assert A**n == A
    # 创建一个符号变量 n，其值为非负整数
    n = Symbol('n', integer=True, nonnegative=True)
    # 断言 A 的 n 次方结果为对角矩阵，对角线元素为 0 的 n 次方
    assert A**n == diag(0**n, 0**n, 0**n)
    # 断言将 n 替换为 0 后，A 的 n 次方结果为 3x3 的单位矩阵
    assert (A**n).subs(n, 0) == eye(3)
    # 断言将 n 替换为 1 后，A 的 n 次方结果为 3x3 的零矩阵
    assert (A**n).subs(n, 1) == zeros(3)

    # 创建一个 3x3 的矩阵 A，所有元素为 2
    A = Matrix([[2,0,0],[0,2,0],[0,0,2]])
    # 断言 A 的 2.1 次方结果为对角矩阵，对角线元素为 2 的 2.1 次方
    assert A**2.1 == diag (2**2.1, 2**2.1, 2**2.1)
    # 断言 A 的 I 次方结果为对角矩阵，对角线元素为 2 的 I 次方
    assert A**I == diag (2**I, 2**I, 2**I)

    # 创建一个 3x3 的矩阵 A，其中
    # 创建一个2x2的矩阵A，其元素为[[1, 1], [3, 3]]
    A = Matrix([[1, 1], [3, 3]])
    
    # 断言：A的平方根次幂等于[[S.Half, S.Half], [3*S.Half, 3*S.Half]]
    assert A**S.Half == Matrix([[S.Half, S.Half], [3*S.Half, 3*S.Half]])
def test_issue_17247_expression_blowup_1():
    # 创建一个 2x2 的矩阵 M，包含符号 x
    M = Matrix([[1+x, 1-x], [1-x, 1+x]])
    # 使用 dotprodsimp 上下文，简化以下表达式
    with dotprodsimp(True):
        # 断言 M 的指数函数展开结果等于给定的 2x2 矩阵
        assert M.exp().expand() == Matrix([
            [ (exp(2*x) + exp(2))/2, (-exp(2*x) + exp(2))/2],
            [(-exp(2*x) + exp(2))/2,  (exp(2*x) + exp(2))/2]])

def test_issue_17247_expression_blowup_2():
    # 创建一个 2x2 的矩阵 M，包含符号 x
    M = Matrix([[1+x, 1-x], [1-x, 1+x]])
    # 使用 dotprodsimp 上下文
    with dotprodsimp(True):
        # 计算 M 的 Jordan 形式，并分配给 P 和 J
        P, J = M.jordan_form ()
        # 断言 P*J*P.inv()，即 PJP^(-1)
        assert P*J*P.inv()

def test_issue_17247_expression_blowup_3():
    # 创建一个 2x2 的矩阵 M，包含符号 x
    M = Matrix([[1+x, 1-x], [1-x, 1+x]])
    # 使用 dotprodsimp 上下文，简化以下表达式
    with dotprodsimp(True):
        # 断言 M 的 100 次方等于给定的 2x2 矩阵
        assert M**100 == Matrix([
            [633825300114114700748351602688*x**100 + 633825300114114700748351602688, 633825300114114700748351602688 - 633825300114114700748351602688*x**100],
            [633825300114114700748351602688 - 633825300114114700748351602688*x**100, 633825300114114700748351602688*x**100 + 633825300114114700748351602688]])

def test_issue_17247_expression_blowup_4():
    # 这个矩阵在当前主分支上即使进行了中间简化也需要非常长时间，因此使用了缩短版本，保留在这里以备将来优化测试。
    # M = Matrix(S('''[
    #     [             -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64,      1/4 - 5*I/16,      65/128 + 87*I/64,         -9/32 - I/16,      183/256 - 97*I/128,       3/64 + 13*I/64,         -23/32 - 59*I/256,      15/128 - 3*I/32,        19/256 + 551*I/1024],
    #     [-149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128,  85/256 - 33*I/16,  805/128 + 2415*I/512, -219/128 + 115*I/256, 6301/4096 - 6609*I/1024,  119/128 + 143*I/128, -10879/2048 + 4343*I/4096,  129/256 - 549*I/512, 42533/16384 + 29103*I/8192],
    #     [          1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64,         1/4 - 5*I/16,        65/128 + 87*I/64,         -9/32 - I/16,        183/256 - 97*I/128,       3/64 + 13*I/64,          -23/32 - 59*I/256],
    #     [   -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128,     85/256 - 33*I/16,    805/128 + 2415*I/512, -219/128 + 115*I/256,   6301/4096 - 6609*I/1024,  119/128 + 143*I/128,  -10879/2048 + 4343*I/4096],
    #     [            1 + I,         -19/4 + 5*I/4,           1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16,            1/4 + I/2,        -129/64 - 9*I/64,         1/4 - 5*I/16,          65/128 + 87*I/64,         -9/32 - I/16,         183/256 - 97*I/128],
    #     [         21/8 + I,    -537/64 + 143*I/16,    -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128,     125/64 + 87*I/64,   -2063/256 + 541*I/128,     85/256 - 33*I/16,      805/128 + 2415*I/512, -219/128 + 115*I/256,    6301/4096 - 6609*I/1024],
    # '''
    # ))
    pass
# 定义一个包含复数的矩阵，矩阵中的元素是复数值
# 注意：在Python中，虚数单位用大写字母I表示
M = Matrix([
    [               -2,         17/4 - 13*I/2,             1 + I,         -19/4 + 5*I/4,           1/2 - I,         9/4 + 55*I/16,                 -3/4,         45/32 - 37*I/16,            1/4 + I/2,          -129/64 - 9*I/64,         1/4 - 5*I/16,           65/128 + 87*I/64],
    [     1/4 + 13*I/4,    -825/64 - 147*I/32,          21/8 + I,    -537/64 + 143*I/16,    -5/8 - 39*I/16,   2473/256 + 137*I/64,    -149/64 + 49*I/32,   -177/128 - 1369*I/128,     125/64 + 87*I/64,     -2063/256 + 541*I/128,     85/256 - 33*I/16,       805/128 + 2415*I/512],
    [             -4*I,            27/2 + 6*I,                -2,         17/4 - 13*I/2,             1 + I,         -19/4 + 5*I/4,              1/2 - I,           9/4 + 55*I/16,                 -3/4,           45/32 - 37*I/16,            1/4 + I/2,           -129/64 - 9*I/64],
    [      1/4 + 5*I/2,       -23/8 - 57*I/16,      1/4 + 13*I/4,    -825/64 - 147*I/32,          21/8 + I,    -537/64 + 143*I/16,       -5/8 - 39*I/16,     2473/256 + 137*I/64,    -149/64 + 49*I/32,     -177/128 - 1369*I/128,     125/64 + 87*I/64,      -2063/256 + 541*I/128],
    [               -4,               9 - 5*I,              -4*I,            27/2 + 6*I,                -2,         17/4 - 13*I/2,                1 + I,           -19/4 + 5*I/4,              1/2 - I,             9/4 + 55*I/16,                 -3/4,            45/32 - 37*I/16],
    [             -2*I,        119/8 + 29*I/4,       1/4 + 5*I/2,       -23/8 - 57*I/16,      1/4 + 13*I/4,    -825/64 - 147*I/32,             21/8 + I,      -537/64 + 143*I/16,       -5/8 - 39*I/16,       2473/256 + 137*I/64,    -149/64 + 49*I/32,      -177/128 - 1369*I/128]
])
# 断言矩阵M的十次方等于给定的矩阵
# 注意：** 表示幂运算，在这里是计算矩阵M的十次方
assert M**10 == Matrix([
# 定义一个复杂的数学表达式，该表达式被写成一个包含多个复数部分的列表
# 每个复数部分包含实部和虚部，实部由大的整数乘以常数和虚数单位 I 得出，分母是一个大的整数
[
    # 第一个复数部分
    7 * (-221393644768594642173548179825793834595 - 1861633166167425978847110897013541127952 * I) / 9671406556917033397649408,
    # 第二个复数部分
    15 * (31670992489131684885307005100073928751695 + 10329090958303458811115024718207404523808 * I) / 77371252455336267181195264,
    # 第三个复数部分
    7 * (-3710978679372178839237291049477017392703 + 1377706064483132637295566581525806894169 * I) / 19342813113834066795298816,
    # 第四个复数部分
    (9727707023582419994616144751727760051598 - 59261571067013123836477348473611225724433 * I) / 9671406556917033397649408,
    # 第五个复数部分
    (31896723509506857062605551443641668183707 + 54643444538699269118869436271152084599580 * I) / 38685626227668133590597632,
    # 第六个复数部分
    (-2024044860947539028275487595741003997397402 + 130959428791783397562960461903698670485863 * I) / 309485009821345068724781056,
    # 第七个复数部分
    3 * (26190251453797590396533756519358368860907 - 27221191754180839338002754608545400941638 * I) / 77371252455336267181195264,
    # 第八个复数部分
    (1154643595139959842768960128434994698330461 + 3385496216250226964322872072260446072295634 * I) / 618970019642690137449562112,
    # 第九个复数部分
    3 * (-31849347263064464698310044805285774295286 - 11877437776464148281991240541742691164309 * I) / 77371252455336267181195264,
    # 第十个复数部分
    (4661330392283532534549306589669150228040221 - 4171259766019818631067810706563064103956871 * I) / 1237940039285380274899124224,
    # 第十一个复数部分
    (9598353794289061833850770474812760144506 + 358027153990999990968244906482319780943983 * I) / 309485009821345068724781056,
    # 第十二个复数部分
    (-9755135335127734571547571921702373498554177 - 4837981372692695195747379349593041939686540 * I) / 2475880078570760549798248448
]
# 创建一个包含复数的列表，每个复数都表示为实部和虚部的和，并以 I 表示虚部单位
[(-379516731607474268954110071392894274962069 - 422272153179747548473724096872271700878296*I)/77371252455336267181195264, 
 (41324748029613152354787280677832014263339501 - 12715121258662668420833935373453570749288074*I)/1237940039285380274899124224, 
 (-339216903907423793947110742819264306542397 + 494174755147303922029979279454787373566517*I)/77371252455336267181195264, 
 (-18121350839962855576667529908850640619878381 - 37413012454129786092962531597292531089199003*I)/1237940039285380274899124224, 
 (2489661087330511608618880408199633556675926 + 1137821536550153872137379935240732287260863*I)/309485009821345068724781056, 
 (-136644109701594123227587016790354220062972119 + 110130123468183660555391413889600443583585272*I)/4951760157141521099596496896, 
 (1488043981274920070468141664150073426459593 - 9691968079933445130866371609614474474327650*I)/1237940039285380274899124224, 
 27*(4636797403026872518131756991410164760195942 + 3369103221138229204457272860484005850416533*I)/4951760157141521099596496896, 
 (-8534279107365915284081669381642269800472363 + 2241118846262661434336333368511372725482742*I)/1237940039285380274899124224, 
 (60923350128174260992536531692058086830950875 - 263673488093551053385865699805250505661590126*I)/9903520314283042199192993792, 
 (18520943561240714459282253753348921824172569 + 24846649186468656345966986622110971925703604*I)/4951760157141521099596496896, 
 (-232781130692604829085973604213529649638644431 + 35981505277760667933017117949103953338570617*I)/9903520314283042199192993792]
# 创建一个包含复数的列表，每个复数由实部和虚部组成
[
    # 第一个复数：实部和虚部的分子分别是 8742968295129404279528270438201520488950 和 3061473358639249112126847237482570858327，分母是 4835703278458516698824704
    (8742968295129404279528270438201520488950 + 3061473358639249112126847237482570858327*I) / 4835703278458516698824704,

    # 第二个复数：实部和虚部的分子分别是 -245657313712011778432792959787098074935273 和 253113767861878869678042729088355086740856，分母是 38685626227668133590597632
    (-245657313712011778432792959787098074935273 + 253113767861878869678042729088355086740856*I) / 38685626227668133590597632,

    # 第三个复数：实部和虚部的分子分别是 1947031161734702327107371192008011621193 和 -19462330079296259148177542369999791122762，分母是 9671406556917033397649408
    (1947031161734702327107371192008011621193 - 19462330079296259148177542369999791122762*I) / 9671406556917033397649408,

    # 第四个复数：实部和虚部的分子分别是 552856485625209001527688949522750288619217 和 392928441196156725372494335248099016686580，分母是 77371252455336267181195264
    (552856485625209001527688949522750288619217 + 392928441196156725372494335248099016686580*I) / 77371252455336267181195264,

    # 第五个复数：实部和虚部的分子分别是 -44542866621905323121630214897126343414629 和 3265340021421335059323962377647649632959，分母是 19342813113834066795298816
    (-44542866621905323121630214897126343414629 + 3265340021421335059323962377647649632959*I) / 19342813113834066795298816,

    # 第六个复数：实部和虚部的分子分别是 136272594005759723105646069956434264218730 和 -330975364731707309489523680957584684763587，分母是 38685626227668133590597632
    (136272594005759723105646069956434264218730 - 330975364731707309489523680957584684763587*I) / 38685626227668133590597632,

    # 第七个复数：实部和虚部的分子分别是 27392593965554149283318732469825168894401 和 75157071243800133880129376047131061115278，分母是 38685626227668133590597632
    (27392593965554149283318732469825168894401 + 75157071243800133880129376047131061115278*I) / 38685626227668133590597632,

    # 第八个复数：实部和虚部的分子分别是 -357821652913266734749960136017214096276154 和 -45509144466378076475315751988405961498243，分母是 309485009821345068724781056，整体乘以 7
    7*(-357821652913266734749960136017214096276154 - 45509144466378076475315751988405961498243*I) / 309485009821345068724781056,

    # 第九个复数：实部和虚部的分子分别是 104485001373574280824835174390219397141149 和 -99041000529599568255829489765415726168162，分母是 77371252455336267181195264
    (104485001373574280824835174390219397141149 - 99041000529599568255829489765415726168162*I) / 77371252455336267181195264,

    # 第十个复数：实部和虚部的分子分别是 1198066993119982409323525798509037696321291 和 4249784165667887866939369628840569844519936，分母是 618970019642690137449562112
    (1198066993119982409323525798509037696321291 + 4249784165667887866939369628840569844519936*I) / 618970019642690137449562112,

    # 第十一个复数：实部和虚部的分子分别是 -114985392587849953209115599084503853611014 和 -52510376847189529234864487459476242883449，分母是 77371252455336267181195264
    (-114985392587849953209115599084503853611014 - 52510376847189529234864487459476242883449*I) / 77371252455336267181195264,

    # 第十二个复数：实部和虚部的分子分别是 6094620517051332877965959223269600650951573 和 -4683469779240530439185019982269137976201163，分母是 1237940039285380274899124224
    (6094620517051332877965959223269600650951573 - 4683469779240530439185019982269137976201163*I) / 1237940039285380274899124224
]
# 复杂的复数列表，包含多个复数元素
[
    # 第一个复数元素
    (611292255597977285752123848828590587708323 - 216821743518546668382662964473055912169502*I) / 77371252455336267181195264,
    # 第二个复数元素
    (-1144023204575811464652692396337616594307487 + 12295317806312398617498029126807758490062855*I) / 309485009821345068724781056,
    # 第三个复数元素
    (-374093027769390002505693378578475235158281 - 573533923565898290299607461660384634333639*I) / 77371252455336267181195264,
    # 第四个复数元素
    (47405570632186659000138546955372796986832987 - 2837476058950808941605000274055970055096534*I) / 1237940039285380274899124224,
    # 第五个复数元素
    (-571573207393621076306216726219753090535121 + 533381457185823100878764749236639320783831*I) / 77371252455336267181195264,
    # 第六个复数元素
    (-7096548151856165056213543560958582513797519 - 24035731898756040059329175131592138642195366*I) / 618970019642690137449562112,
    # 第七个复数元素
    (2396762128833271142000266170154694033849225 + 1448501087375679588770230529017516492953051*I) / 309485009821345068724781056,
    # 第八个复数元素
    (-150609293845161968447166237242456473262037053 + 92581148080922977153207018003184520294188436*I) / 4951760157141521099596496896,
    # 第九个复数元素
    5 * (270278244730804315149356082977618054486347 - 1997830155222496880429743815321662710091562*I) / 1237940039285380274899124224,
    # 第十个复数元素
    (62978424789588828258068912690172109324360330 + 44803641177219298311493356929537007630129097*I) / 2475880078570760549798248448,
    # 第十一个复数元素
    19 * (-451431106327656743945775812536216598712236 + 114924966793632084379437683991151177407937*I) / 1237940039285380274899124224,
    # 第十二个复数元素
    (63417747628891221594106738815256002143915995 - 261508229397507037136324178612212080871150958*I) / 9903520314283042199192993792
]
# 复杂的数学表达式，可能代表某种数值计算或者模型中的参数值
[(-2144231934021288786200752920446633703357 + 2305614436009705803670842248131563850246*I)/1208925819614629174706176,       
 (-90720949337459896266067589013987007078153 - 221951119475096403601562347412753844534569*I)/19342813113834066795298816,      
 (11590973613116630788176337262688659880376 + 6514520676308992726483494976339330626159*I)/4835703278458516698824704,      
 3*(-131776217149000326618649542018343107657237 + 79095042939612668486212006406818285287004*I)/38685626227668133590597632,       
 (10100577916793945997239221374025741184951 - 28631383488085522003281589065994018550748*I)/9671406556917033397649408,         
 67*(10090295594251078955008130473573667572549 + 10449901522697161049513326446427839676762*I)/77371252455336267181195264,       
 (-54270981296988368730689531355811033930513 - 3413683117592637309471893510944045467443*I)/19342813113834066795298816,         
 (440372322928679910536575560069973699181278 - 736603803202303189048085196176918214409081*I)/77371252455336267181195264,        
 (33220374714789391132887731139763250155295 + 92055083048787219934030779066298919603554*I)/38685626227668133590597632,      
 5*(-594638554579967244348856981610805281527116 - 82309245323128933521987392165716076704057*I)/309485009821345068724781056,       
 (128056368815300084550013708313312073721955 - 114619107488668120303579745393765245911404*I)/77371252455336267181195264,       
 21*(59839959255173222962789517794121843393573 + 241507883613676387255359616163487405826334*I)/618970019642690137449562112]
# 复杂数列表的注释，每个元素都是一个复数对象
[
    # 第一个复数：(-13454485022325376674626653802541391955147 + 184471402121905621396582628515905949793486*I) / 19342813113834066795298816
    (-13454485022325376674626653802541391955147 + 184471402121905621396582628515905949793486*I) / 19342813113834066795298816,
    
    # 第二个复数：(-6158730123400322562149780662133074862437105 - 3416173052604643794120262081623703514107476*I) / 154742504910672534362390528
    (-6158730123400322562149780662133074862437105 - 3416173052604643794120262081623703514107476*I) / 154742504910672534362390528,
    
    # 第三个复数：(770558003844914708453618983120686116100419 - 127758381209767638635199674005029818518766*I) / 77371252455336267181195264
    (770558003844914708453618983120686116100419 - 127758381209767638635199674005029818518766*I) / 77371252455336267181195264,
    
    # 第四个复数：(-4693005771813492267479835161596671660631703 + 12703585094750991389845384539501921531449948*I) / 309485009821345068724781056
    (-4693005771813492267479835161596671660631703 + 12703585094750991389845384539501921531449948*I) / 309485009821345068724781056,
    
    # 第五个复数：(-295028157441149027913545676461260860036601 - 841544569970643160358138082317324743450770*I) / 77371252455336267181195264
    (-295028157441149027913545676461260860036601 - 841544569970643160358138082317324743450770*I) / 77371252455336267181195264,
    
    # 第六个复数：(56716442796929448856312202561538574275502893 + 7216818824772560379753073185990186711454778*I) / 1237940039285380274899124224
    (56716442796929448856312202561538574275502893 + 7216818824772560379753073185990186711454778*I) / 1237940039285380274899124224,
    
    # 第七个复数：15 * (-87061038932753366532685677510172566368387 + 61306141156647596310941396434445461895538*I) / 154742504910672534362390528
    15 * (-87061038932753366532685677510172566368387 + 61306141156647596310941396434445461895538*I) / 154742504910672534362390528,
    
    # 第八个复数：(-3455315109680781412178133042301025723909347 - 24969329563196972466388460746447646686670670*I) / 618970019642690137449562112
    (-3455315109680781412178133042301025723909347 - 24969329563196972466388460746447646686670670*I) / 618970019642690137449562112,
    
    # 第九个复数：(2453418854160886481106557323699250865361849 + 1497886802326243014471854112161398141242514*I) / 309485009821345068724781056
    (2453418854160886481106557323699250865361849 + 1497886802326243014471854112161398141242514*I) / 309485009821345068724781056,
    
    # 第十个复数：(-151343224544252091980004429001205664193082173 + 90471883264187337053549090899816228846836628*I) / 4951760157141521099596496896
    (-151343224544252091980004429001205664193082173 + 90471883264187337053549090899816228846836628*I) / 4951760157141521099596496896,
    
    # 第十一个复数：(1652018205533026103358164026239417416432989 - 9959733619236515024261775397109724431400162*I) / 1237940039285380274899124224
    (1652018205533026103358164026239417416432989 - 9959733619236515024261775397109724431400162*I) / 1237940039285380274899124224,
    
    # 第十二个复数：3 * (40676374242956907656984876692623172736522006 + 31023357083037817469535762230872667581366205*I) / 4951760157141521099596496896
    3 * (40676374242956907656984876692623172736522006 + 31023357083037817469535762230872667581366205*I) / 4951760157141521099596496896
]
# 创建一个复杂数列表，包含了十一个复数值
[(-1226990509403328460274658603410696548387 - 4131739423109992672186585941938392788458*I)/1208925819614629174706176,
 (162392818524418973411975140074368079662703 + 23706194236915374831230612374344230400704*I)/9671406556917033397649408,
 (-3935678233089814180000602553655565621193 + 2283744757287145199688061892165659502483*I)/1208925819614629174706176,
 (-2400210250844254483454290806930306285131 - 315571356806370996069052930302295432758205*I)/19342813113834066795298816,
 (13365917938215281056563183751673390817910 + 15911483133819801118348625831132324863881*I)/4835703278458516698824704,
 3*(-215950551370668982657516660700301003897855 + 51684341999223632631602864028309400489378*I)/38685626227668133590597632,
 (20886089946811765149439844691320027184765 - 30806277083146786592790625980769214361844*I)/9671406556917033397649408,
 (562180634592713285745940856221105667874855 + 1031543963988260765153550559766662245114916*I)/77371252455336267181195264,
 (-65820625814810177122941758625652476012867 - 12429918324787060890804395323920477537595*I)/19342813113834066795298816,
 (319147848192012911298771180196635859221089 - 402403304933906769233365689834404519960394*I)/38685626227668133590597632,
 (23035615120921026080284733394359587955057 + 115351677687031786114651452775242461310624*I)/38685626227668133590597632,
 (-3426830634881892756966440108592579264936130 - 1022954961164128745603407283836365128598559*I)/309485009821345068724781056]
# 定义一个复杂的复数列表，包含了多个复数值
[ (-192574788060137531023716449082856117537757 - 69222967328876859586831013062387845780692*I)/19342813113834066795298816,     
  (2736383768828013152914815341491629299773262 - 2773252698016291897599353862072533475408743*I)/77371252455336267181195264,  
  (-23280005281223837717773057436155921656805 + 214784953368021840006305033048142888879224*I)/19342813113834066795298816,     
  (-3035247484028969580570400133318947903462326 - 2195168903335435855621328554626336958674325*I)/77371252455336267181195264,     
  (984552428291526892214541708637840971548653 - 64006622534521425620714598573494988589378*I)/77371252455336267181195264,      
  (-3070650452470333005276715136041262898509903 + 7286424705750810474140953092161794621989080*I)/154742504910672534362390528,    
  (-147848877109756404594659513386972921139270 - 416306113044186424749331418059456047650861*I)/38685626227668133590597632,    
  (55272118474097814260289392337160619494260781 + 7494019668394781211907115583302403519488058*I)/1237940039285380274899124224,     
  (-581537886583682322424771088996959213068864 + 542191617758465339135308203815256798407429*I)/77371252455336267181195264,    
  (-6422548983676355789975736799494791970390991 - 23524183982209004826464749309156698827737702*I)/618970019642690137449562112,     
  7*(180747195387024536886923192475064903482083 + 84352527693562434817771649853047924991804*I)/154742504910672534362390528, 
  (-135485179036717001055310712747643466592387031 + 102346575226653028836678855697782273460527608*I)/4951760157141521099596496896],
# 创建一个包含复数的列表，每个复数都由实部和虚部组成
[
    # 复数1: 实部是一个很大的整数加上虚部乘以虚数单位i，分母是一个大整数
    (3384238362616083147067025892852431152105 + 156724444932584900214919898954874618256*I)/604462909807314587353088,
    # 复数2: 实部是一个负数加上虚部乘以虚数单位i，分母是一个大整数
    (-59558300950677430189587207338385764871866 + 114427143574375271097298201388331237478857*I)/4835703278458516698824704,
    # 复数3: 实部是一个负数加上虚部乘以虚数单位i，分母是一个大整数
    (-1356835789870635633517710130971800616227 - 7023484098542340388800213478357340875410*I)/1208925819614629174706176,
    # 复数4: 实部是一个很大的整数加上虚部乘以虚数单位i，分母是一个大整数
    (234884918567993750975181728413524549575881 + 79757294640629983786895695752733890213506*I)/9671406556917033397649408,
    # 复数5: 实部是一个负数加上虚部乘以虚数单位i，分母是一个大整数
    (-7632732774935120473359202657160313866419 + 2905452608512927560554702228553291839465*I)/1208925819614629174706176,
    # 复数6: 实部是一个很大的整数减去虚部乘以虚数单位i，分母是一个大整数
    (52291747908702842344842889809762246649489 - 520996778817151392090736149644507525892649*I)/19342813113834066795298816,
    # 复数7: 实部是一个很大的整数加上虚部乘以虚数单位i，分母是一个大整数
    (17472406829219127839967951180375981717322 + 23464704213841582137898905375041819568669*I)/4835703278458516698824704,
    # 复数8: 实部是一个负数加上虚部乘以虚数单位i，分母是一个大整数
    (-911026971811893092350229536132730760943307 + 150799318130900944080399439626714846752360*I)/38685626227668133590597632,
    # 复数9: 实部是一个很大的整数减去虚部乘以虚数单位i，分母是一个大整数
    (26234457233977042811089020440646443590687 - 45650293039576452023692126463683727692890*I)/9671406556917033397649408,
    # 复数10: 实部是一个很大的整数乘以3，加上虚部乘以虚数单位i，分母是一个大整数
    3*(288348388717468992528382586652654351121357 + 454526517721403048270274049572136109264668*I)/77371252455336267181195264,
    # 复数11: 实部是一个负数减去虚部乘以虚数单位i，分母是一个大整数
    (-91583492367747094223295011999405657956347 - 12704691128268298435362255538069612411331*I)/19342813113834066795298816,
    # 复数12: 实部是一个很大的整数加上虚部乘以虚数单位i，分母是一个大整数
    (411208730251327843849027957710164064354221 - 569898526380691606955496789378230959965898*I)/38685626227668133590597632
]
# 定义一个复杂的复数列表，每个元素是一个复数
[    
    # 第一个复数，实部和虚部分别是两个大整数相除的结果
    (27127513117071487872628354831658811211795 - 37765296987901990355760582016892124833857*I) / 4835703278458516698824704,
    
    # 第二个复数，实部和虚部分别是两个大整数相加的结果
    (1741779916057680444272938534338833170625435 + 3083041729779495966997526404685535449810378*I) / 77371252455336267181195264,
    
    # 第三个复数，实部是一个大整数乘以3，虚部是一个大整数乘以3
    3 * (-60642236251815783728374561836962709533401 - 24630301165439580049891518846174101510744*I) / 19342813113834066795298816,
    
    # 第四个复数，实部是一个大整数乘以3，虚部是一个大整数乘以3
    3 * (445885207364591681637745678755008757483408 - 350948497734812895032502179455610024541643*I) / 38685626227668133590597632,
    
    # 第五个复数，实部和虚部分别是一个大整数减去一个大整数乘以I的结果
    (-47373295621391195484367368282471381775684 + 219122969294089357477027867028071400054973*I) / 19342813113834066795298816,
    
    # 第六个复数，实部和虚部分别是两个大整数的差除以一个大整数
    (-2801565819673198722993348253876353741520438 - 2250142129822658548391697042460298703335701*I) / 77371252455336267181195264,
    
    # 第七个复数，实部是一个大整数除以一个大整数，虚部是一个大整数乘以I除以一个大整数
    (801448252275607253266997552356128790317119 - 50890367688077858227059515894356594900558*I) / 77371252455336267181195264,
    
    # 第八个复数，实部和虚部分别是两个大整数的差除以一个大整数
    (-5082187758525931944557763799137987573501207 + 11610432359082071866576699236013484487676124*I) / 309485009821345068724781056,
    
    # 第九个复数，实部和虚部分别是一个大整数减去一个大整数乘以I的结果除以一个大整数
    (-328925127096560623794883760398247685166830 - 643447969697471610060622160899409680422019*I) / 77371252455336267181195264,
    
    # 第十个复数，实部是一个大整数乘以15，虚部是一个大整数乘以15再乘以I除以一个大整数
    15 * (2954944669454003684028194956846659916299765 + 33434406416888505837444969347824812608566*I) / 1237940039285380274899124224,
    
    # 第十一个复数，实部和虚部分别是一个大整数减去一个大整数乘以I的结果除以一个大整数
    (-415749104352001509942256567958449835766827 + 479330966144175743357171151440020955412219*I) / 77371252455336267181195264,
    
    # 第十二个复数，实部是一个大整数乘以3，虚部是一个大整数乘以3再乘以I除以一个大整数
    3 * (-4639987285852134369449873547637372282914255 - 11994411888966030153196659207284951579243273*I) / 1237940039285380274899124224
]
# 给定一个复杂的列表，包含复数的实部和虚部，每个复数都写成 (real_part + imaginary_part*I) 的形式
[       
    # 第一个复数：(-478846096206269117345024348666145495601 + 1249092488629201351470551186322814883283*I) / 302231454903657293676544
    (-478846096206269117345024348666145495601 + 1249092488629201351470551186322814883283j) / 302231454903657293676544,

    # 第二个复数：(-17749319421930878799354766626365926894989 - 18264580106418628161818752318217357231971*I) / 1208925819614629174706176
    (-17749319421930878799354766626365926894989 - 18264580106418628161818752318217357231971j) / 1208925819614629174706176,

    # 第三个复数：(2801110795431528876849623279389579072819 + 363258850073786330770713557775566973248*I) / 604462909807314587353088
    (2801110795431528876849623279389579072819 + 363258850073786330770713557775566973248j) / 604462909807314587353088,

    # 第四个复数：(-59053496693129013745775512127095650616252 + 78143588734197260279248498898321500167517*I) / 4835703278458516698824704
    (-59053496693129013745775512127095650616252 + 78143588734197260279248498898321500167517j) / 4835703278458516698824704,

    # 第五个复数：(-283186724922498212468162690097101115349 - 6443437753863179883794497936345437398276*I) / 1208925819614629174706176
    (-283186724922498212468162690097101115349 - 6443437753863179883794497936345437398276j) / 1208925819614629174706176,

    # 第六个复数：(188799118826748909206887165661384998787543 + 84274736720556630026311383931055307398820*I) / 9671406556917033397649408
    (188799118826748909206887165661384998787543 + 84274736720556630026311383931055307398820j) / 9671406556917033397649408,

    # 第七个复数：(-5482217151670072904078758141270295025989 + 1818284338672191024475557065444481298568*I) / 1208925819614629174706176
    (-5482217151670072904078758141270295025989 + 1818284338672191024475557065444481298568j) / 1208925819614629174706176,

    # 第八个复数：(56564463395350195513805521309731217952281 - 360208541416798112109946262159695452898431*I) / 19342813113834066795298816
    (56564463395350195513805521309731217952281 - 360208541416798112109946262159695452898431j) / 19342813113834066795298816,

    # 第九个复数：11 * (1259539805728870739006416869463689438068 + 1409136581547898074455004171305324917387*I) / 4835703278458516698824704
    11 * (1259539805728870739006416869463689438068 + 1409136581547898074455004171305324917387j) / 4835703278458516698824704,

    # 第十个复数：5 * (-123701190701414554945251071190688818343325 + 30997157322590424677294553832111902279712*I) / 38685626227668133590597632
    5 * (-123701190701414554945251071190688818343325 + 30997157322590424677294553832111902279712j) / 38685626227668133590597632,

    # 第十一个复数：(16130917381301373033736295883982414239781 - 32752041297570919727145380131926943374516*I) / 9671406556917033397649408
    (16130917381301373033736295883982414239781 - 32752041297570919727145380131926943374516j) / 9671406556917033397649408,

    # 第十二个复数：(650301385108223834347093740500375498354925 + 899526407681131828596801223402866051809258*I) / 77371252455336267181195264
    (650301385108223834347093740500375498354925 + 899526407681131828596801223402866051809258j) / 77371252455336267181195264
]
# 定义一个 6x6 复数矩阵 M，其中元素由 lambda 函数生成，表示为 1 + (-1)**(i+j)*I
M = Matrix(S('''[
    [             -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64,      1/4 - 5*I/16,      65/128 + 87*I/64],
    [-149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128,  85/256 - 33*I/16,  805/128 + 2415*I/512],
    [          1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64],
    [   -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128],
    [            1 + I,         -19/4 + 5*I/4,           1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16],
    [         21/8 + I,    -537/64 + 143*I/16,    -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128]]'''))

# 定义一个测试函数 test_issue_17247_expression_blowup_5，测试特定情况下的矩阵特征多项式
def test_issue_17247_expression_blowup_5():
    # 创建一个 6x6 矩阵 M，元素为 1 + (-1)**(i+j)*I
    M = Matrix(6, 6, lambda i, j: 1 + (-1)**(i+j)*I)
    # 使用 dotprodsimp(True) 上下文
    with dotprodsimp(True):
        # 断言矩阵 M 的特征多项式为纯多项式 PurePoly，指定域为 'EX'
        assert M.charpoly('x') == PurePoly(x**6 + (-6 - 6*I)*x**5 + 36*I*x**4, x, domain='EX')

# 定义一个测试函数 test_issue_17247_expression_blowup_6，测试特定情况下的矩阵行列式
def test_issue_17247_expression_blowup_6():
    # 创建一个 8x8 矩阵 M，元素为 x+i，其中 i 为从 0 到 63 的整数
    M = Matrix(8, 8, [x+i for i in range(64)])
    # 使用 dotprodsimp(True) 上下文
    with dotprodsimp(True):
        # 断言矩阵 M 的贝雷斯行列式为 0
        assert M.det('bareiss') == 0

# 定义一个测试函数 test_issue_17247_expression_blowup_7，测试特定情况下的矩阵行列式
def test_issue_17247_expression_blowup_7():
    # 创建一个 6x6 矩阵 M，元素为 1 + (-1)**(i+j)*I
    M = Matrix(6, 6, lambda i, j: 1 + (-1)**(i+j)*I)
    # 使用 dotprodsimp(True) 上下文
    with dotprodsimp(True):
        # 断言矩阵 M 的伯克维茨行列式为 0
        assert M.det('berkowitz') == 0

# 定义一个测试函数 test_issue_17247_expression_blowup_8，创建一个 8x8 矩阵 M，元素为 x+i，其中 i 为从 0 到 63 的整数
def test_issue_17247_expression_blowup_8():
    M = Matrix(8, 8, [x+i for i in range(64)])
    # 使用 `dotprodsimp` 函数，并设置其参数为 `True`
    with dotprodsimp(True):
        # 断言矩阵 M 的行列式（使用 LU 分解计算）等于 0
        assert M.det('lu') == 0
def test_issue_17247_expression_blowup_9():
    # 创建一个 8x8 的矩阵 M，使用表达式 x+i 填充其中的元素，i 的取值范围是 0 到 63
    M = Matrix(8, 8, [x+i for i in range (64)])
    # 启用 dotprodsimp，简化矩阵运算
    with dotprodsimp(True):
        # 断言矩阵 M 的行简化阶梯形式等于给定的矩阵和元组 (0, 1)
        assert M.rref() == (Matrix([
            [1, 0, -1, -2, -3, -4, -5, -6],
            [0, 1,  2,  3,  4,  5,  6,  7],
            [0, 0,  0,  0,  0,  0,  0,  0],
            [0, 0,  0,  0,  0,  0,  0,  0],
            [0, 0,  0,  0,  0,  0,  0,  0],
            [0, 0,  0,  0,  0,  0,  0,  0],
            [0, 0,  0,  0,  0,  0,  0,  0],
            [0, 0,  0,  0,  0,  0,  0,  0]]), (0, 1))

def test_issue_17247_expression_blowup_10():
    # 创建一个 6x6 的矩阵 M，每个元素为 1 + (-1)**(i+j)*I 的 lambda 表达式
    M = Matrix(6, 6, lambda i, j: 1 + (-1)**(i+j)*I)
    # 启用 dotprodsimp，简化矩阵运算
    with dotprodsimp(True):
        # 断言矩阵 M 的 (0, 0) 余子式等于 0
        assert M.cofactor(0, 0) == 0

def test_issue_17247_expression_blowup_11():
    # 创建一个 6x6 的矩阵 M，每个元素为 1 + (-1)**(i+j)*I 的 lambda 表达式
    M = Matrix(6, 6, lambda i, j: 1 + (-1)**(i+j)*I)
    # 启用 dotprodsimp，简化矩阵运算
    with dotprodsimp(True):
        # 断言矩阵 M 的余子式矩阵等于 6x6 的全 0 矩阵
        assert M.cofactor_matrix() == Matrix(6, 6, [0]*36)

def test_issue_17247_expression_blowup_12():
    # 创建一个 6x6 的矩阵 M，每个元素为 1 + (-1)**(i+j)*I 的 lambda 表达式
    M = Matrix(6, 6, lambda i, j: 1 + (-1)**(i+j)*I)
    # 启用 dotprodsimp，简化矩阵运算
    with dotprodsimp(True):
        # 断言矩阵 M 的特征值和其对应的代数重数为指定字典 {6: 1, 6*I: 1, 0: 4}
        assert M.eigenvals() == {6: 1, 6*I: 1, 0: 4}

def test_issue_17247_expression_blowup_13():
    # 创建一个 4x4 的矩阵 M，包含复杂的表达式
    M = Matrix([
        [    0, 1 - x, x + 1, 1 - x],
        [1 - x, x + 1,     0, x + 1],
        [    0, 1 - x, x + 1, 1 - x],
        [    0,     0,     1 - x, 0]])

    # 计算矩阵 M 的特征向量
    ev = M.eigenvects()
    # 断言特定的特征向量及其相关表达式
    assert ev[0] == (0, 2, [Matrix([0, -1, 0, 1])])
    assert ev[1][0] == x - sqrt(2)*(x - 1) + 1
    assert ev[1][1] == 1
    assert ev[1][2][0].expand(deep=False, numer=True) == Matrix([
        [(-x + sqrt(2)*(x - 1) - 1)/(x - 1)],
        [-4*x/(x**2 - 2*x + 1) + (x + 1)*(x - sqrt(2)*(x - 1) + 1)/(x**2 - 2*x + 1)],
        [(-x + sqrt(2)*(x - 1) - 1)/(x - 1)],
        [1]
    ])

    assert ev[2][0] == x + sqrt(2)*(x - 1) + 1
    assert ev[2][1] == 1
    assert ev[2][2][0].expand(deep=False, numer=True) == Matrix([
        [(-x - sqrt(2)*(x - 1) - 1)/(x - 1)],
        [-4*x/(x**2 - 2*x + 1) + (x + 1)*(x + sqrt(2)*(x - 1) + 1)/(x**2 - 2*x + 1)],
        [(-x - sqrt(2)*(x - 1) - 1)/(x - 1)],
        [1]
    ])

def test_issue_17247_expression_blowup_14():
    # 创建一个 8x8 的矩阵 M，使用复杂的表达式填充
    M = Matrix(8, 8, ([1+x, 1-x]*4 + [1-x, 1+x]*4)*4)
    # 启用 dotprodsimp，简化矩阵运算
    with dotprodsimp(True):
        # 断言矩阵 M 的阶梯形式等于指定的 8x8 矩阵
        assert M.echelon_form() == Matrix([
            [x + 1, 1 - x, x + 1, 1 - x, x + 1, 1 - x, x + 1, 1 - x],
            [    0,   4*x,     0,   4*x,     0,   4*x,     0,   4*x],
            [    0,     0,     0,     0,     0,     0,     0,     0],
            [    0,     0,     0,     0,     0,     0,     0,     0],
            [    0,     0,     0,     0,     0,     0,     0,     0],
            [    0,     0,     0,     0,     0,     0,     0,     0],
            [    0,     0,     0,     0,     0,     0,     0,     0],
            [    0,     0,     0,     0,     0,     0,     0,     0]])

def test_issue_17247_expression_blowup_15():
    # 创建一个 8x8 的矩阵 M，使用复杂的表达式填充
    M = Matrix(8, 8, ([1+x, 1-x]*4 + [1-x, 1+x]*4)*4)
    # 使用 dotprodsimp 上下文管理器，设置其参数为 True
    with dotprodsimp(True):
        # 断言 M 的行空间等于指定的两个矩阵列表
        assert M.rowspace() == [
            Matrix([[x + 1, 1 - x, x + 1, 1 - x, x + 1, 1 - x, x + 1, 1 - x]]),
            Matrix([[0, 4*x, 0, 4*x, 0, 4*x, 0, 4*x]])
        ]
def test_issue_17247_expression_blowup_16():
    # 创建一个 8x8 的矩阵 M，其中每个元素为表达式 1+x 或 1-x 的重复组合
    M = Matrix(8, 8, ([1+x, 1-x]*4 + [1-x, 1+x]*4)*4)
    # 开启 dotprodsimp 上下文
    with dotprodsimp(True):
        # 断言 M 的列空间与指定的矩阵列表相等
        assert M.columnspace() == [Matrix([[x + 1],[1 - x],[x + 1],[1 - x],[x + 1],[1 - x],[x + 1],[1 - x]]), Matrix([[1 - x],[x + 1],[1 - x],[x + 1],[1 - x],[x + 1],[1 - x],[x + 1]])]

def test_issue_17247_expression_blowup_17():
    # 创建一个 8x8 的矩阵 M，其中每个元素为 x+i 的迭代组合
    M = Matrix(8, 8, [x+i for i in range (64)])
    # 开启 dotprodsimp 上下文
    with dotprodsimp(True):
        # 断言 M 的零空间与指定的矩阵列表相等
        assert M.nullspace() == [
            Matrix([[1],[-2],[1],[0],[0],[0],[0],[0]]),
            Matrix([[2],[-3],[0],[1],[0],[0],[0],[0]]),
            Matrix([[3],[-4],[0],[0],[1],[0],[0],[0]]),
            Matrix([[4],[-5],[0],[0],[0],[1],[0],[0]]),
            Matrix([[5],[-6],[0],[0],[0],[0],[1],[0]]),
            Matrix([[6],[-7],[0],[0],[0],[0],[0],[1]])]

def test_issue_17247_expression_blowup_18():
    # 创建一个 6x6 的矩阵 M，其中每个元素为表达式 1+x 或 1-x 的重复组合
    M = Matrix(6, 6, ([1+x, 1-x]*3 + [1-x, 1+x]*3)*3)
    # 开启 dotprodsimp 上下文
    with dotprodsimp(True):
        # 断言 M 不是幂零矩阵
        assert not M.is_nilpotent()

def test_issue_17247_expression_blowup_19():
    # 创建一个 4x4 的复数矩阵 M，其元素为给定的复数表达式
    M = Matrix(S('''[
        [             -3/4,                     0,         1/4 + I/2,                     0],
        [                0, -177/128 - 1369*I/128,                 0, -2063/256 + 541*I/128],
        [          1/2 - I,                     0,                 0,                     0],
        [                0,                     0,                 0, -177/128 - 1369*I/128]]'''))
    # 开启 dotprodsimp 上下文
    with dotprodsimp(True):
        # 断言 M 不是可对角化的
        assert not M.is_diagonalizable()

def test_issue_17247_expression_blowup_20():
    # 创建一个 4x4 的矩阵 M，其中每个元素为给定的表达式
    M = Matrix([
    [x + 1,  1 - x,      0,      0],
    [1 - x,  x + 1,      0,  x + 1],
    [    0,  1 - x,  x + 1,      0],
    [    0,      0,      0,  x + 1]])
    # 开启 dotprodsimp 上下文
    with dotprodsimp(True):
        # 断言 M 的对角化结果与指定的两个矩阵相等
        assert M.diagonalize() == (Matrix([
            [1,  1, 0, (x + 1)/(x - 1)],
            [1, -1, 0,               0],
            [1,  1, 1,               0],
            [0,  0, 0,               1]]),
            Matrix([
            [2,   0,     0,     0],
            [0, 2*x,     0,     0],
            [0,   0, x + 1,     0],
            [0,   0,     0, x + 1]]))

def test_issue_17247_expression_blowup_21():
    # 创建一个 4x4 的复数矩阵 M，其中每个元素为给定的复数表达式
    M = Matrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    # 使用 dotprodsimp(True) 设置符号代数简化模式为真
    with dotprodsimp(True):
        # 断言矩阵 M 的逆矩阵是否存在，使用高斯消元法（'GE'）
        assert M.inv(method='GE') == Matrix(S('''[
            # 第一行矩阵元素
            [-26194832/3470993 - 31733264*I/3470993, 156352/3470993 + 10325632*I/3470993, 0, -7741283181072/3306971225785 + 2999007604624*I/3306971225785],
            # 第二行矩阵元素
            [4408224/3470993 - 9675328*I/3470993, -2422272/3470993 + 1523712*I/3470993, 0, -1824666489984/3306971225785 - 1401091949952*I/3306971225785],
            # 第三行矩阵元素
            [-26406945676288/22270005630769 + 10245925485056*I/22270005630769, 7453523312640/22270005630769 + 1601616519168*I/22270005630769, 633088/6416033 - 140288*I/6416033, 872209227109521408/21217636514687010905 + 6066405081802389504*I/21217636514687010905],
            # 第四行矩阵元素
            [0, 0, 0, -11328/952745 + 87616*I/952745]]'''))
# 定义测试函数，用于测试 issue 17247 中的表达式扩展问题（第 22 个测试用例）
def test_issue_17247_expression_blowup_22():
    # 创建一个符号矩阵 M，初始化为给定的复数值列表
    M = Matrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    # 使用 dotprodsimp(True) 上下文，简化矩阵乘法
    with dotprodsimp(True):
        # 断言矩阵 M 的逆矩阵，使用 LU 方法计算，与预期的符号矩阵结果相等
        assert M.inv(method='LU') == Matrix(S('''[
            [-26194832/3470993 - 31733264*I/3470993, 156352/3470993 + 10325632*I/3470993, 0, -7741283181072/3306971225785 + 2999007604624*I/3306971225785],
            [4408224/3470993 - 9675328*I/3470993, -2422272/3470993 + 1523712*I/3470993, 0, -1824666489984/3306971225785 - 1401091949952*I/3306971225785],
            [-26406945676288/22270005630769 + 10245925485056*I/22270005630769, 7453523312640/22270005630769 + 1601616519168*I/22270005630769, 633088/6416033 - 140288*I/6416033, 872209227109521408/21217636514687010905 + 6066405081802389504*I/21217636514687010905],
            [0, 0, 0, -11328/952745 + 87616*I/952745]]'''))

# 定义测试函数，用于测试 issue 17247 中的表达式扩展问题（第 23 个测试用例）
def test_issue_17247_expression_blowup_23():
    # 创建一个符号矩阵 M，初始化为给定的复数值列表
    M = Matrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    # 使用 dotprodsimp(True) 上下文，简化矩阵乘法
    with dotprodsimp(True):
        # 断言矩阵 M 的逆矩阵，使用 ADJ 方法扩展，与预期的符号矩阵结果相等
        assert M.inv(method='ADJ').expand() == Matrix(S('''[
            [-26194832/3470993 - 31733264*I/3470993, 156352/3470993 + 10325632*I/3470993, 0, -7741283181072/3306971225785 + 2999007604624*I/3306971225785],
            [4408224/3470993 - 9675328*I/3470993, -2422272/3470993 + 1523712*I/3470993, 0, -1824666489984/3306971225785 - 1401091949952*I/3306971225785],
            [-26406945676288/22270005630769 + 10245925485056*I/22270005630769, 7453523312640/22270005630769 + 1601616519168*I/22270005630769, 633088/6416033 - 140288*I/6416033, 872209227109521408/21217636514687010905 + 6066405081802389504*I/21217636514687010905],
            [0, 0, 0, -11328/952745 + 87616*I/952745]]'''))

# 定义测试函数，用于测试 issue 17247 中的表达式扩展问题（第 24 个测试用例）
def test_issue_17247_expression_blowup_24():
    # 创建一个稀疏矩阵 M，初始化为给定的复数值列表
    M = SparseMatrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    # 使用 dotprodsimp(True) 上下文环境执行以下代码块
    with dotprodsimp(True):
        # 断言矩阵 M 的逆矩阵，使用 CH 方法求解
        assert M.inv(method='CH') == Matrix(S('''[
            # 第一行矩阵元素
            [-26194832/3470993 - 31733264*I/3470993, 156352/3470993 + 10325632*I/3470993, 0, -7741283181072/3306971225785 + 2999007604624*I/3306971225785],
            # 第二行矩阵元素
            [4408224/3470993 - 9675328*I/3470993, -2422272/3470993 + 1523712*I/3470993, 0, -1824666489984/3306971225785 - 1401091949952*I/3306971225785],
            # 第三行矩阵元素
            [-26406945676288/22270005630769 + 10245925485056*I/22270005630769, 7453523312640/22270005630769 + 1601616519168*I/22270005630769, 633088/6416033 - 140288*I/6416033, 872209227109521408/21217636514687010905 + 6066405081802389504*I/21217636514687010905],
            # 第四行矩阵元素
            [0, 0, 0, -11328/952745 + 87616*I/952745]]'''))
# 定义一个测试函数，用于测试特定问题的矩阵表达式是否导致内存消耗过大
def test_issue_17247_expression_blowup_25():
    # 创建一个稀疏矩阵对象 M，从字符串表达式中初始化
    M = SparseMatrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    # 启用 dotprodsimp 模式以简化点积
    with dotprodsimp(True):
        # 断言矩阵 M 的逆是否等于给定的矩阵表达式
        assert M.inv(method='LDL') == Matrix(S('''[
            [-26194832/3470993 - 31733264*I/3470993, 156352/3470993 + 10325632*I/3470993, 0, -7741283181072/3306971225785 + 2999007604624*I/3306971225785],
            [4408224/3470993 - 9675328*I/3470993, -2422272/3470993 + 1523712*I/3470993, 0, -1824666489984/3306971225785 - 1401091949952*I/3306971225785],
            [-26406945676288/22270005630769 + 10245925485056*I/22270005630769, 7453523312640/22270005630769 + 1601616519168*I/22270005630769, 633088/6416033 - 140288*I/6416033, 872209227109521408/21217636514687010905 + 6066405081802389504*I/21217636514687010905],
            [0, 0, 0, -11328/952745 + 87616*I/952745]]'''))

# 定义另一个测试函数，测试另一个矩阵表达式是否会导致内存消耗过大
def test_issue_17247_expression_blowup_26():
    # 创建一个矩阵对象 M，从字符串表达式中初始化
    M = Matrix(S('''[
        [             -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64,      1/4 - 5*I/16,      65/128 + 87*I/64,         -9/32 - I/16,      183/256 - 97*I/128],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128,  85/256 - 33*I/16,  805/128 + 2415*I/512, -219/128 + 115*I/256, 6301/4096 - 6609*I/1024],
        [          1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16,         1/4 + I/2,      -129/64 - 9*I/64,         1/4 - 5*I/16,        65/128 + 87*I/64],
        [   -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128,  125/64 + 87*I/64, -2063/256 + 541*I/128,     85/256 - 33*I/16,    805/128 + 2415*I/512],
        [            1 + I,         -19/4 + 5*I/4,           1/2 - I,         9/4 + 55*I/16,              -3/4,       45/32 - 37*I/16,            1/4 + I/2,        -129/64 - 9*I/64],
        [         21/8 + I,    -537/64 + 143*I/16,    -5/8 - 39*I/16,   2473/256 + 137*I/64, -149/64 + 49*I/32, -177/128 - 1369*I/128,     125/64 + 87*I/64,   -2063/256 + 541*I/128],
        [               -2,         17/4 - 13*I/2,             1 + I,         -19/4 + 5*I/4,           1/2 - I,         9/4 + 55*I/16,                 -3/4,         45/32 - 37*I/16],
        [     1/4 + 13*I/4,    -825/64 - 147*I/32,          21/8 + I,    -537/64 + 143*I/16,    -5/8 - 39*I/16,   2473/256 + 137*I/64,    -149/64 + 49*I/32,   -177/128 - 1369*I/128]]'''))
    # 启用 dotprodsimp 模式以简化点积
    with dotprodsimp(True):
        # 断言矩阵 M 的秩是否等于 4
        assert M.rank() == 4

# 定义另一个测试函数，测试另一个矩阵的表达式是否会导致内存消耗过大
def test_issue_17247_expression_blowup_27():
    # 创建一个矩阵对象 M，从列表表达式中初始化
    M = Matrix([
        [    0, 1 - x, x + 1, 1 - x],
        [1 - x, x + 1,     0, x + 1],
        [    0, 1 - x, x + 1, 1 - x],
        [    0,     0,     1 - x, 0]])
    # 使用 dotprodsimp 函数设置上下文，确保化简
    with dotprodsimp(True):
        # 调用 Matrix 对象 M 的 jordan_form 方法，获取 Jordan 形式矩阵 P 和相伴矩阵 J
        P, J = M.jordan_form()
        # 断言 P 扩展后等于给定的 Matrix 对象
        assert P.expand() == Matrix(S('''[
            [    0,  4*x/(x**2 - 2*x + 1), -(-17*x**4 + 12*sqrt(2)*x**4 - 4*sqrt(2)*x**3 + 6*x**3 - 6*x - 4*sqrt(2)*x + 12*sqrt(2) + 17)/(-7*x**4 + 5*sqrt(2)*x**4 - 6*sqrt(2)*x**3 + 8*x**3 - 2*x**2 + 8*x + 6*sqrt(2)*x - 5*sqrt(2) - 7), -(12*sqrt(2)*x**4 + 17*x**4 - 6*x**3 - 4*sqrt(2)*x**3 - 4*sqrt(2)*x + 6*x - 17 + 12*sqrt(2))/(7*x**4 + 5*sqrt(2)*x**4 - 6*sqrt(2)*x**3 - 8*x**3 + 2*x**2 - 8*x + 6*sqrt(2)*x - 5*sqrt(2) + 7)],
            [x - 1, x/(x - 1) + 1/(x - 1),                       (-7*x**3 + 5*sqrt(2)*x**3 - x**2 + sqrt(2)*x**2 - sqrt(2)*x - x - 5*sqrt(2) - 7)/(-3*x**3 + 2*sqrt(2)*x**3 - 2*sqrt(2)*x**2 + 3*x**2 + 2*sqrt(2)*x + 3*x - 3 - 2*sqrt(2)),                       (7*x**3 + 5*sqrt(2)*x**3 + x**2 + sqrt(2)*x**2 - sqrt(2)*x + x - 5*sqrt(2) + 7)/(2*sqrt(2)*x**3 + 3*x**3 - 3*x**2 - 2*sqrt(2)*x**2 - 3*x + 2*sqrt(2)*x - 2*sqrt(2) + 3)],
            [    0,                     1,                                                                                            -(-3*x**2 + 2*sqrt(2)*x**2 + 2*x - 3 - 2*sqrt(2))/(-x**2 + sqrt(2)*x**2 - 2*sqrt(2)*x + 1 + sqrt(2)),                                                                                            -(2*sqrt(2)*x**2 + 3*x**2 - 2*x - 2*sqrt(2) + 3)/(x**2 + sqrt(2)*x**2 - 2*sqrt(2)*x - 1 + sqrt(2))],
            [1 - x,                     0,                                                                                                                                                                                               1,                                                                                                                                                                                             1]]''')).expand()
        # 断言 J 等于给定的 Matrix 对象
        assert J == Matrix(S('''[
            [0, 1,                       0,                       0],
            [0, 0,                       0,                       0],
            [0, 0, x - sqrt(2)*(x - 1) + 1,                       0],
            [0, 0,                       0, x + sqrt(2)*(x - 1) + 1]]'''))
# 定义一个测试函数，用于测试问题号为17247的表达式扩张的情况
def test_issue_17247_expression_blowup_28():
    # 创建一个复数矩阵 M，包含四行四列的复数表达式
    M = Matrix(S('''[
        [             -3/4,       45/32 - 37*I/16,                   0,                     0],
        [-149/64 + 49*I/32, -177/128 - 1369*I/128,                   0, -2063/256 + 541*I/128],
        [                0,         9/4 + 55*I/16, 2473/256 + 137*I/64,                     0],
        [                0,                     0,                   0, -177/128 - 1369*I/128]]'''))
    
# 定义一个测试函数，用于测试问题号为16823的情况
def test_issue_16823():
    # 这段代码仍然需要修复，如果不使用 dotprodsimp 的话。
    # 导入 SymPy 库中的 S 函数，用于创建符号表达式
    # 定义一个复数矩阵 M，使用 S 函数将字符串表示的矩阵转换为 SymPy 的 Matrix 对象
    M = Matrix(S('''[
        [1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I,1/4+1/2*I,-129/64-9/64*I,1/4-5/16*I,65/128+87/64*I,-9/32-1/16*I,183/256-97/128*I,3/64+13/64*I,-23/32-59/256*I,15/128-3/32*I,19/256+551/1024*I],
        [21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I,125/64+87/64*I,-2063/256+541/128*I,85/256-33/16*I,805/128+2415/512*I,-219/128+115/256*I,6301/4096-6609/1024*I,119/128+143/128*I,-10879/2048+4343/4096*I,129/256-549/512*I,42533/16384+29103/8192*I],
        [-2,17/4-13/2*I,1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I,1/4+1/2*I,-129/64-9/64*I,1/4-5/16*I,65/128+87/64*I,-9/32-1/16*I,183/256-97/128*I,3/64+13/64*I,-23/32-59/256*I],
        [1/4+13/4*I,-825/64-147/32*I,21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I,125/64+87/64*I,-2063/256+541/128*I,85/256-33/16*I,805/128+2415/512*I,-219/128+115/256*I,6301/4096-6609/1024*I,119/128+143/128*I,-10879/2048+4343/4096*I],
        [-4*I,27/2+6*I,-2,17/4-13/2*I,1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I,1/4+1/2*I,-129/64-9/64*I,1/4-5/16*I,65/128+87/64*I,-9/32-1/16*I,183/256-97/128*I],
        [1/4+5/2*I,-23/8-57/16*I,1/4+13/4*I,-825/64-147/32*I,21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I,125/64+87/64*I,-2063/256+541/128*I,85/256-33/16*I,805/128+2415/512*I,-219/128+115/256*I,6301/4096-6609/1024*I],
        [-4,9-5*I,-4*I,27/2+6*I,-2,17/4-13/2*I,1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I,1/4+1/2*I,-129/64-9/64*I,1/4-5/16*I,65/128+87/64*I],
        [-2*I,119/8+29/4*I,1/4+5/2*I,-23/8-57/16*I,1/4+13/4*I,-825/64-147/32*I,21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I,125/64+87/64*I,-2063/256+541/128*I,85/256-33/16*I,805/128+2415/512*I],
        [0,-6,-4,9-5*I,-4*I,27/2+6*I,-2,17/4-13/2*I,1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I,1/4+1/2*I,-129/64-9/64*I],
        [1,-9/4+3*I,-2*I,119/8+29/4*I,1/4+5/2*I,-23/8-57/16*I,1/4+13/4*I,-825/64-147/32*I,21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I,125/64+87/64*I,-2063/256+541/128*I],
        [0,-4*I,0,-6,-4,9-5*I,-4*I,27/2+6*I,-2,17/4-13/2*I,1+I,-19/4+5/4*I,1/2-I,9/4+55/16*I,-3/4,45/32-37/16*I],
        [0,1/4+1/2*I,1,-9/4+3*I,-2*I,119/8+29/4*I,1/4+5/2*I,-23/8-57/16*I,1/4+13/4*I,-825/64-147/32*I,21/8+I,-537/64+143/16*I,-5/8-39/16*I,2473/256+137/64*I,-149/64+49/32*I,-177/128-1369/128*I]]'''))
    
    # 启用 dotprodsimp，简化矩阵乘法表达式
    with dotprodsimp(True):
        # 断言矩阵 M 的秩为 8
        assert M.rank() == 8
def test_issue_18531():
    # 定义一个名为 test_issue_18531 的测试函数
    M = Matrix([
        [1, 1, 1, 1, 1, 0, 1, 0, 0],  # 创建一个 8x9 的矩阵，填充数值
        [1 + sqrt(2), -1 + sqrt(2), 1 - sqrt(2), -sqrt(2) - 1, 1, 1, -1, 1, 1],  # 填充矩阵的第二行
        [-5 + 2*sqrt(2), -5 - 2*sqrt(2), -5 - 2*sqrt(2), -5 + 2*sqrt(2), -7, 2, -7, -2, 0],  # 填充矩阵的第三行
        [-3*sqrt(2) - 1, 1 - 3*sqrt(2), -1 + 3*sqrt(2), 1 + 3*sqrt(2), -7, -5, 7, -5, 3],  # 填充矩阵的第四行
        [7 - 4*sqrt(2), 4*sqrt(2) + 7, 4*sqrt(2) + 7, 7 - 4*sqrt(2), 7, -12, 7, 12, 0],  # 填充矩阵的第五行
        [-1 + 3*sqrt(2), 1 + 3*sqrt(2), -3*sqrt(2) - 1, 1 - 3*sqrt(2), 7, -5, -7, -5, 3],  # 填充矩阵的第六行
        [-3 + 2*sqrt(2), -3 - 2*sqrt(2), -3 - 2*sqrt(2), -3 + 2*sqrt(2), -1, 2, -1, -2, 0],  # 填充矩阵的第七行
        [1 - sqrt(2), -sqrt(2) - 1, 1 + sqrt(2), -1 + sqrt(2), -1, 1, 1, 1, 1]  # 填充矩阵的第八行
        ])
    # 使用 dotprodsimp 来简化矩阵操作，在此设置为 True
    with dotprodsimp(True):
        # 断言矩阵 M 的行简化行阶梯形式与给定值相等，并返回元组及其列交换信息
        assert M.rref() == (Matrix([
            [1, 0, 0, 0, 0, 0, 0, 0,  S(1)/2],  # 第一行简化结果
            [0, 1, 0, 0, 0, 0, 0, 0, -S(1)/2],  # 第二行简化结果
            [0, 0, 1, 0, 0, 0, 0, 0,  S(1)/2],  # 第三行简化结果
            [0, 0, 0, 1, 0, 0, 0, 0, -S(1)/2],  # 第四行简化结果
            [0, 0, 0, 0, 1, 0, 0, 0,    0],     # 第五行简化结果
            [0, 0, 0, 0, 0, 1, 0, 0, -S(1)/2],  # 第六行简化结果
            [0, 0, 0, 0, 0, 0, 1, 0,    0],     # 第七行简化结果
            [0, 0, 0, 0, 0, 0, 0, 1, -S(1)/2]]), (0, 1, 2, 3, 4, 5, 6, 7))  # 返回的元组信息


def test_creation():
    # 断言创建 5x5 的矩阵会引发 ValueError
    raises(ValueError, lambda: Matrix(5, 5, range(20)))
    # 断言创建列数为负数的矩阵会引发 ValueError
    raises(ValueError, lambda: Matrix(5, -1, []))
    # 断言从一个元组索引超出边界会引发 IndexError
    raises(IndexError, lambda: Matrix((1, 2))[2])
    # 使用 with 语句断言从一个元组索引超出边界会引发 IndexError
    with raises(IndexError):
        Matrix((1, 2))[3] = 5

    # 断言空矩阵对象的各种形式相等
    assert Matrix() == Matrix([]) == Matrix([[]]) == Matrix(0, 0, [])

    # 使用 warns_deprecated_sympy 断言允许在矩阵中包含任何对象，但已被弃用
    with warns_deprecated_sympy():
        assert Matrix([[[1], (2,)]]).tolist() == [[[1], (2,)]]
    # 使用 warns_deprecated_sympy 断言矩阵转置操作已被弃用
    with warns_deprecated_sympy():
        assert Matrix([[[1], (2,)]]).T.tolist() == [[[1]], [(2,)]]

    # 创建矩阵 M，然后将其元素修改为空集
    M = Matrix([[0]])
    with warns_deprecated_sympy():
        M[0, 0] = S.EmptySet

    # 断言矩阵 a 的列数等于行数，且为 2
    a = Matrix([[x, 0], [0, 0]])
    m = a
    assert m.cols == m.rows
    assert m.cols == 2
    # 断言矩阵 a 的平铺列表为 [x, 0, 0, 0]
    assert m[:] == [x, 0, 0, 0]

    # 创建矩阵 b，并将其赋值给 m
    b = Matrix(2, 2, [x, 0, 0, 0])
    m = b
    # 断言矩阵 b 的列数等于行数，且为 2
    assert m.cols == m.rows
    assert m.cols == 2
    # 断言矩阵 b 的平铺列表为 [x, 0, 0, 0]
    assert m[:] == [x, 0, 0, 0]

    # 断言矩阵 a 与矩阵 b 相等
    assert a == b

    # 断言 Matrix(b) 等于 b
    assert Matrix(b) == b

    # 创建不同形状的两个子矩阵 c23 和 c13，将它们合并成 c
    c23 = Matrix(2, 3, range(1, 7))
    c13 = Matrix(1, 3, range(7, 10))
    c = Matrix([c23, c13])
    # 断言矩阵 c 的列数为 3，行数为 3
    assert c.cols == 3
    assert c.rows == 3
    # 断言矩阵 c 的平铺列表为 [1, 2, 3, 4, 5, 6, 7, 8, 9]
    assert c[:] == [1, 2, 3, 4, 5, 6, 7, 8, 9]

    # 断言单位矩阵与指定的单位矩阵对象相等
    assert Matrix(eye(2)) == eye(2)
    # 断言不可变矩阵与其对应的不可变矩阵对象相等
    assert ImmutableMatrix(ImmutableMatrix(eye(2))) == ImmutableMatrix(eye(2))
    # 断言不可变矩阵与 c 的不可变版本相等
    assert ImmutableMatrix(c) == c.as_immutable()
    # 断言从不可变矩阵创建的可变矩阵与不可变矩阵的可变版本相等
    assert Matrix(ImmutableMatrix
    # 创建一个符号矩阵符号对象 A，表示一个 2x2 的矩阵
    A = MatrixSymbol("A", 2, 2)
    # 定义一个包含两个元素的列表 dat，第一个元素是一个 2x2 的全为 1 的矩阵，第二个元素是符号矩阵 A
    dat = [ones(2), A]
    # 使用 dat 列表创建一个 Matrix 对象，并断言其等于指定的矩阵
    assert Matrix(dat) == Matrix([
        [      1,       1],
        [      1,       1],
        [A[0, 0], A[0, 1]],
        [A[1, 0], A[1, 1]]
    ])
    # 在使用旧版本 sympy 时，断言使用 evaluate=False 创建的 Matrix 对象转换为列表后与预期结果相等
    with warns_deprecated_sympy():
        assert Matrix(dat, evaluate=False).tolist() == [[i] for i in dat]

    # 0 维容忍度测试
    # 断言包含两个元素的 Matrix 对象与仅包含一个元素的 Matrix 对象相等
    assert Matrix([ones(2), ones(0)]) == Matrix([ones(2)])
    # 断言尝试创建包含不合法维度的 Matrix 对象时会引发 ValueError
    raises(ValueError, lambda: Matrix([ones(2), ones(0, 3)]))
    raises(ValueError, lambda: Matrix([ones(2), ones(3, 0)]))

    # Matrix 和可迭代对象的混合使用
    # 创建一个 2x2 的矩阵 M
    M = Matrix([[1, 2], [3, 4]])
    # 使用 Matrix 和元组 (5, 6) 创建新的 Matrix 对象 M2，并断言其与指定矩阵相等
    assert M2 == Matrix([[1, 2], [3, 4], [5, 6]])
def test_irregular_block():
    # 断言矩阵的不规则块处理是否正确
    assert Matrix.irregular(3, ones(2,1), ones(3,3)*2, ones(2,2)*3,
        ones(1,1)*4, ones(2,2)*5, ones(1,2)*6, ones(1,2)*7) == Matrix([
        [1, 2, 2, 2, 3, 3],
        [1, 2, 2, 2, 3, 3],
        [4, 2, 2, 2, 5, 5],
        [6, 6, 7, 7, 5, 5]])


def test_tolist():
    # 创建矩阵并验证其转换为列表格式的正确性
    lst = [[S.One, S.Half, x*y, S.Zero], [x, y, z, x**2], [y, -S.One, z*x, 3]]
    m = Matrix(lst)
    assert m.tolist() == lst


def test_as_mutable():
    # 验证转换为可变和不可变矩阵的正确性
    assert zeros(0, 3).as_mutable() == zeros(0, 3)
    assert zeros(0, 3).as_immutable() == ImmutableMatrix(zeros(0, 3))
    assert zeros(3, 0).as_immutable() == ImmutableMatrix(zeros(3, 0))


def test_slicing():
    # 测试矩阵切片操作的正确性
    m0 = eye(4)
    assert m0[:3, :3] == eye(3)
    assert m0[2:4, 0:2] == zeros(2)

    m1 = Matrix(3, 3, lambda i, j: i + j)
    assert m1[0, :] == Matrix(1, 3, (0, 1, 2))
    assert m1[1:3, 1] == Matrix(2, 1, (2, 3))

    m2 = Matrix([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])
    assert m2[:, -1] == Matrix(4, 1, [3, 7, 11, 15])
    assert m2[-2:, :] == Matrix([[8, 9, 10, 11], [12, 13, 14, 15]])


def test_submatrix_assignment():
    # 测试子矩阵赋值操作的正确性
    m = zeros(4)
    m[2:4, 2:4] = eye(2)
    assert m == Matrix(((0, 0, 0, 0),
                        (0, 0, 0, 0),
                        (0, 0, 1, 0),
                        (0, 0, 0, 1)))
    m[:2, :2] = eye(2)
    assert m == eye(4)
    m[:, 0] = Matrix(4, 1, (1, 2, 3, 4))
    assert m == Matrix(((1, 0, 0, 0),
                        (2, 1, 0, 0),
                        (3, 0, 1, 0),
                        (4, 0, 0, 1)))
    m[:, :] = zeros(4)
    assert m == zeros(4)
    m[:, :] = [(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16)]
    assert m == Matrix(((1, 2, 3, 4),
                        (5, 6, 7, 8),
                        (9, 10, 11, 12),
                        (13, 14, 15, 16)))
    m[:2, 0] = [0, 0]
    assert m == Matrix(((0, 2, 3, 4),
                        (0, 6, 7, 8),
                        (9, 10, 11, 12),
                        (13, 14, 15, 16)))


def test_extract():
    # 测试矩阵抽取操作的正确性
    m = Matrix(4, 3, lambda i, j: i*3 + j)
    assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])
    assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])
    assert m.extract(range(4), range(3)) == m
    raises(IndexError, lambda: m.extract([4], [0]))
    raises(IndexError, lambda: m.extract([0], [3]))


def test_reshape():
    # 测试矩阵重塑操作的正确性
    m0 = eye(3)
    assert m0.reshape(1, 9) == Matrix(1, 9, (1, 0, 0, 0, 1, 0, 0, 0, 1))
    m1 = Matrix(3, 4, lambda i, j: i + j)
    assert m1.reshape(
        4, 3) == Matrix(((0, 1, 2), (3, 1, 2), (3, 4, 2), (3, 4, 5)))
    assert m1.reshape(2, 6) == Matrix(((0, 1, 2, 3, 1, 2), (3, 4, 2, 3, 4, 5)))


def test_applyfunc():
    # 测试矩阵元素函数应用的正确性
    m0 = eye(3)
    assert m0.applyfunc(lambda x: 2*x) == eye(3)*2
    assert m0.applyfunc(lambda x: 0) == zeros(3)


def test_expand():
    # 测试矩阵展开操作的正确性
    m0 = Matrix([[x*(x + y), 2], [((x + y)*y)*x, x*(y + x*(x + y))]])
    # Test if expand() returns a matrix
    # 测试展开操作是否返回一个矩阵
    # 将 m0 矩阵进行展开，得到 m1 矩阵
    m1 = m0.expand()
    
    # 断言 m1 矩阵与指定的矩阵相等
    assert m1 == Matrix(
        [[x*y + x**2, 2], [x*y**2 + y*x**2, x*y + y*x**2 + x**3]])

    # 创建一个实数符号变量 'a'
    a = Symbol('a', real=True)

    # 断言对复数进行展开后，指定的矩阵等于复数展开的结果
    assert Matrix([exp(I*a)]).expand(complex=True) == \
        Matrix([cos(a) + I*sin(a)])

    # 断言对指定矩阵进行指数运算后，得到的矩阵等于指定的结果矩阵
    assert Matrix([[0, 1, 2], [0, 0, -1], [0, 0, 0]]).exp() == Matrix([
        [1, 1, Rational(3, 2)],
        [0, 1, -1],
        [0, 0, 1]]
    )
# 定义函数用于测试 Matrix 对象的 refine 方法
def test_refine():
    # 创建一个 2x2 的矩阵 m0，包含表达式 Abs(x)**2 和 sqrt(x**2)
    m0 = Matrix([[Abs(x)**2, sqrt(x**2)],
                 [sqrt(x**2)*Abs(y)**2, sqrt(y**2)*Abs(x)**2]])
    # 使用 refine 方法，对矩阵 m0 进行实数域条件的精化，期望得到特定的矩阵 m1
    m1 = m0.refine(Q.real(x) & Q.real(y))
    # 断言 m1 等于特定的矩阵
    assert m1 == Matrix([[x**2, Abs(x)], [y**2*Abs(x), x**2*Abs(y)]])

    # 对 m0 进行正数域条件的精化，期望得到特定的矩阵 m1
    m1 = m0.refine(Q.positive(x) & Q.positive(y))
    # 断言 m1 等于特定的矩阵
    assert m1 == Matrix([[x**2, x], [x*y**2, x**2*y]])

    # 对 m0 进行负数域条件的精化，期望得到特定的矩阵 m1
    m1 = m0.refine(Q.negative(x) & Q.negative(y))
    # 断言 m1 等于特定的矩阵
    assert m1 == Matrix([[x**2, -x], [-x*y**2, -x**2*y]])

# 定义函数用于测试 randMatrix 函数
def test_random():
    # 生成一个 3x3 的随机矩阵 M
    M = randMatrix(3, 3)
    # 生成一个种子为 3 的随机矩阵 M，覆盖之前的 M
    M = randMatrix(3, 3, seed=3)
    # 断言新生成的 M 等于使用相同种子生成的随机矩阵
    assert M == randMatrix(3, 3, seed=3)

    # 生成一个元素范围在 0 到 150 的 3x4 随机矩阵 M
    M = randMatrix(3, 4, 0, 150)
    # 生成一个种子为 4，对称的 3x3 随机矩阵 M，覆盖之前的 M
    M = randMatrix(3, seed=4, symmetric=True)
    # 断言新生成的 M 等于使用相同参数生成的随机矩阵
    assert M == randMatrix(3, seed=4, symmetric=True)

    # 创建一个矩阵 S，复制 M 的内容
    S = M.copy()
    # 简化矩阵 S
    S.simplify()
    # 断言简化后的 S 等于原始的 M，即简化操作不改变矩阵内容
    assert S == M  # 当元素为数字而非整数时不会失败

    # 创建一个种子为 4 的随机数生成器 rng
    rng = random.Random(4)
    # 断言使用相同的随机数生成器 rng，生成的随机矩阵等于 M
    assert M == randMatrix(3, symmetric=True, prng=rng)

    # 确保对称性
    for size in (10, 11):  # 测试奇数和偶数尺寸
        for percent in (100, 70, 30):
            # 使用相同的随机数生成器 rng，生成百分比对称的随机矩阵 M
            M = randMatrix(size, symmetric=True, percent=percent, prng=rng)
            # 断言 M 等于其转置矩阵
            assert M == M.T

    # 生成一个 10x10 的随机矩阵 M，最小元素为 1，期望零元素数为 30
    M = randMatrix(10, min=1, percent=70)
    zero_count = 0
    # 统计 M 中的零元素个数
    for i in range(M.shape[0]):
        for j in range(M.shape[1]):
            if M[i, j] == 0:
                zero_count += 1
    # 断言统计的零元素个数等于期望的 30
    assert zero_count == 30

# 定义函数用于测试 Matrix 对象的逆矩阵计算
def test_inverse():
    # 创建一个 4x4 的单位矩阵 A
    A = eye(4)
    # 断言 A 的逆矩阵等于单位矩阵
    assert A.inv() == eye(4)
    # 使用 LU 分解计算 A 的逆矩阵，断言结果等于单位矩阵
    assert A.inv(method="LU") == eye(4)
    # 使用伴随矩阵方法计算 A 的逆矩阵，断言结果等于单位矩阵
    assert A.inv(method="ADJ") == eye(4)
    # 使用初等行变换方法计算 A 的逆矩阵，断言结果等于单位矩阵
    assert A.inv(method="CH") == eye(4)
    # 使用 LDL 分解计算 A 的逆矩阵，断言结果等于单位矩阵
    assert A.inv(method="LDL") == eye(4)
    # 使用 QR 分解计算 A 的逆矩阵，断言结果等于单位矩阵
    assert A.inv(method="QR") == eye(4)

    # 创建一个 3x3 的矩阵 A
    A = Matrix([[2, 3, 5],
                [3, 6, 2],
                [8, 3, 6]])
    # 计算 A 的逆矩阵 Ainv
    Ainv = A.inv()
    # 断言 A 乘以 A 的逆矩阵等于单位矩阵
    assert A*Ainv == eye(3)
    # 使用 LU 分解计算 A 的逆矩阵，断言结果等于预期的逆矩阵 Ainv
    assert A.inv(method="LU") == Ainv
    # 使用伴随矩阵方法计算 A 的逆矩阵，断言结果等于预期的逆矩阵 Ainv
    assert A.inv(method="ADJ") == Ainv
    # 使用初等行变换方法计算 A 的逆矩阵，断言结果等于预期的逆矩阵 Ainv
    assert A.inv(method="CH") == Ainv
    # 使用 LDL 分解计算 A 的逆矩阵，断言结果等于预期的逆矩阵 Ainv
    assert A.inv(method="LDL") == Ainv
    # 使用 QR 分解计算 A 的逆矩阵，断言结果等于预期的逆矩阵 Ainv
    assert A.inv(method="QR") == Ainv
    # 创建一个名为 AA 的矩阵对象，包含一个 25x25 的整数矩阵
    AA = Matrix([[0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0],
                [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0],
                [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
                [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1],
                [0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0],
                [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1],
                [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0],
                [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0],
                [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1],
                [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0],
                [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0],
                [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0],
                [0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1],
                [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],
                [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
                [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1],
                [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0],
                [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0]])
    
    # 断言：使用 BLOCK 方法求逆矩阵，乘以自身应等于单位矩阵
    assert AA.inv(method="BLOCK") * AA == eye(AA.shape[0])
    
    # 测试不可变性不会成为问题
    # 设置类别为 ImmutableMatrix
    cls = ImmutableMatrix
    # 创建一个 3x3 的不可变矩阵 m
    m = cls([[48, 49, 31],
             [ 9, 71,
def test_jacobian_hessian():
    # 创建一个矩阵 L，包含两个表达式 x**2*y 和 2*y**2 + x*y
    L = Matrix(1, 2, [x**2*y, 2*y**2 + x*y])
    syms = [x, y]
    # 断言 L 对于变量列表 syms 的雅可比矩阵等于给定的 Matrix 对象
    assert L.jacobian(syms) == Matrix([[2*x*y, x**2], [y, 4*y + x]])

    # 重新赋值矩阵 L，包含表达式 x 和 x**2*y**3
    L = Matrix(1, 2, [x, x**2*y**3])
    # 断言 L 对于变量列表 syms 的雅可比矩阵等于给定的 Matrix 对象
    assert L.jacobian(syms) == Matrix([[1, 0], [2*x*y**3, x**2*3*y**2]])

    # 定义函数 f = x**2*y
    f = x**2*y
    syms = [x, y]
    # 断言 f 对于变量列表 syms 的黑塞矩阵等于给定的 Matrix 对象
    assert hessian(f, syms) == Matrix([[2*y, 2*x], [2*x, 0]])

    # 重新定义函数 f = x**2*y**3
    f = x**2*y**3
    # 断言 f 对于变量列表 syms 的黑塞矩阵等于给定的 Matrix 对象
    assert hessian(f, syms) == \
        Matrix([[2*y**3, 6*x*y**2], [6*x*y**2, 6*x**2*y]])

    # 定义函数 f 和 g
    f = z + x*y**2
    g = x**2 + 2*y**3
    # 定义预期的结果矩阵 ans
    ans = Matrix([[0,   2*y],
                  [2*y, 2*x]])
    # 断言函数 f 对于变量列表 Matrix([x, y]) 的黑塞矩阵等于给定的 Matrix 对象 ans
    assert ans == hessian(f, Matrix([x, y]))
    # 断言函数 f 对于变量列表 Matrix([x, y]).T 的黑塞矩阵等于给定的 Matrix 对象 ans
    assert ans == hessian(f, Matrix([x, y]).T)
    # 断言函数 f 对于变量列表 (y, x) 和约束条件 [g] 的黑塞矩阵等于给定的 Matrix 对象
    assert hessian(f, (y, x), [g]) == Matrix([
        [     0, 6*y**2, 2*x],
        [6*y**2,    2*x, 2*y],
        [   2*x,    2*y,   0]])


def test_wronskian():
    # 断言给定的函数列表的朗斯基行列式等于 cos(x)**2 + sin(x)**2
    assert wronskian([cos(x), sin(x)], x) == cos(x)**2 + sin(x)**2
    # 断言给定的函数列表的朗斯基行列式等于 exp(3*x)
    assert wronskian([exp(x), exp(2*x)], x) == exp(3*x)
    # 断言给定的函数列表的朗斯基行列式等于 exp(x) - x*exp(x)
    assert wronskian([exp(x), x], x) == exp(x) - x*exp(x)
    # 断言给定的函数列表的朗斯基行列式等于 2
    assert wronskian([1, x, x**2], x) == 2
    # 计算并断言给定的函数列表的朗斯基行列式的展开式等于预期的 w1
    w1 = -6*exp(x)*sin(x)*x + 6*cos(x)*exp(x)*x**2 - 6*exp(x)*cos(x)*x - \
        exp(x)*cos(x)*x**3 + exp(x)*sin(x)*x**3
    assert wronskian([exp(x), cos(x), x**3], x).expand() == w1
    # 计算并断言给定的函数列表的朗斯基行列式的展开式等于预期的 w1，使用 Berkowitz 方法
    assert wronskian([exp(x), cos(x), x**3], x, method='berkowitz').expand() \
        == w1
    # 计算并断言给定的函数列表的朗斯基行列式的展开式等于预期的 w2
    w2 = -x**3*cos(x)**2 - x**3*sin(x)**2 - 6*x*cos(x)**2 - 6*x*sin(x)**2
    assert wronskian([sin(x), cos(x), x**3], x).expand() == w2
    # 计算并断言给定的函数列表的朗斯基行列式的展开式等于预期的 w2，使用 Berkowitz 方法
    assert wronskian([sin(x), cos(x), x**3], x, method='berkowitz').expand() \
        == w2
    # 断言空列表的朗斯基行列式等于 1
    assert wronskian([], x) == 1


def test_subs():
    # 断言对矩阵进行 x 替换后得到预期的结果
    assert Matrix([[1, x], [x, 4]]).subs(x, 5) == Matrix([[1, 5], [5, 4]])
    # 断言对矩阵进行多个符号替换后得到预期的结果
    assert Matrix([[x, 2], [x + y, 4]]).subs([[x, -1], [y, -2]]) == \
        Matrix([[-1, 2], [-3, 4]])
    # 断言对矩阵进行多个符号替换后得到预期的结果
    assert Matrix([[x, 2], [x + y, 4]]).subs([(x, -1), (y, -2)]) == \
        Matrix([[-1, 2], [-3, 4]])
    # 断言对矩阵进行字典形式的符号替换后得到预期的结果
    assert Matrix([[x, 2], [x + y, 4]]).subs({x: -1, y: -2}) == \
        Matrix([[-1, 2], [-3, 4]])
    # 断言对矩阵进行多个符号替换后得到预期的结果
    assert Matrix([x*y]).subs({x: y - 1, y: x - 1}, simultaneous=True) == \
        Matrix([(x - 1)*(y - 1)])

    # 对于 classes 列表中的每个类，断言单位矩阵的结果等于给定类的单位矩阵替换 1 为 2 后的结果
    for cls in classes:
        assert Matrix([[2, 0], [0, 2]]) == cls.eye(2).subs(1, 2)


def test_xreplace():
    # 断言对矩阵进行 x 替换后得到预期的结果
    assert Matrix([[1, x], [x, 4]]).xreplace({x: 5}) == \
        Matrix([[1, 5], [5, 4]])
    # 断言对矩阵进行多个符号替换后得到预期的结果
    assert Matrix([[x, 2], [x + y, 4]]).xreplace({x: -1, y: -2}) == \
        Matrix([[-1, 2], [-3, 4]])
    # 对于 classes 列表中的每个类，断言单位矩阵的结果等于给定类的单位矩阵替换 1 为 2 后的结果
    for cls in classes:
        assert Matrix([[2, 0], [0, 2]]) == cls.eye(2).xreplace({1: 2})


def test_simplify():
    n = Symbol('n')
    f = Function('f')

    # 定义一个符号矩阵 M
    M = Matrix([[            1/x + 1/y,                 (x + x*y) / x  ],
    M.simplify(ratio=oo)
    # 对矩阵 M 进行简化操作，其中 ratio=oo 表示使用无穷大的精度进行简化

    assert M == Matrix([[eq.simplify(ratio=oo)]])
    # 使用简化后的方程 eq 对象构建一个包含单个元素的矩阵，并断言矩阵 M 与之相等
# 定义一个名为 test_transpose 的测试函数
def test_transpose():
    # 创建一个 2x10 的矩阵 M
    M = Matrix([[1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
                [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]])
    # 断言 M 的转置等于指定的 10x2 矩阵
    assert M.T == Matrix( [ [1, 1],
                            [2, 2],
                            [3, 3],
                            [4, 4],
                            [5, 5],
                            [6, 6],
                            [7, 7],
                            [8, 8],
                            [9, 9],
                            [0, 0] ])
    # 断言 M 的转置的转置等于 M 自身
    assert M.T.T == M
    # 断言 M 的转置等于 M 的 transpose() 方法的结果
    assert M.T == M.transpose()


# 定义一个名为 test_conjugate 的测试函数
def test_conjugate():
    # 创建一个 2x3 的复数矩阵 M
    M = Matrix([[0, I, 5],
                [1, 2, 0]])

    # 断言 M 的转置等于指定的 3x2 矩阵
    assert M.T == Matrix([[0, 1],
                          [I, 2],
                          [5, 0]])

    # 断言 M 的共轭等于指定的 2x3 矩阵
    assert M.C == Matrix([[0, -I, 5],
                          [1,  2, 0]])
    # 断言 M 的共轭等于 M 的 conjugate() 方法的结果
    assert M.C == M.conjugate()

    # 断言 M 的厄米共轭等于 M 的转置的共轭
    assert M.H == M.T.C
    # 断言 M 的厄米共轭等于指定的 3x2 矩阵
    assert M.H == Matrix([[ 0, 1],
                          [-I, 2],
                          [ 5, 0]])


# 定义一个名为 test_conj_dirac 的测试函数
def test_conj_dirac():
    # 使用 lambda 函数断言 eye(3).D 会引发 AttributeError 异常
    raises(AttributeError, lambda: eye(3).D)

    # 创建一个 4x4 的矩阵 M
    M = Matrix([[1, I, I, I],
                [0, 1, I, I],
                [0, 0, 1, I],
                [0, 0, 0, 1]])

    # 断言 M 的 Dirac 表示等于指定的 4x4 矩阵
    assert M.D == Matrix([[ 1,  0,  0,  0],
                          [-I,  1,  0,  0],
                          [-I, -I, -1,  0],
                          [-I, -I,  I, -1]])


# 定义一个名为 test_trace 的测试函数
def test_trace():
    # 创建一个 3x3 的矩阵 M
    M = Matrix([[1, 0, 0],
                [0, 5, 0],
                [0, 0, 8]])
    # 断言 M 的迹(trace)等于 14
    assert M.trace() == 14


# 定义一个名为 test_shape 的测试函数
def test_shape():
    # 创建一个 2x3 的矩阵 M，其中元素为符号 x 和 y
    M = Matrix([[x, 0, 0],
                [0, y, 0]])
    # 断言 M 的形状为 (2, 3)
    assert M.shape == (2, 3)


# 定义一个名为 test_col_row_op 的测试函数
def test_col_row_op():
    # 创建一个 2x3 的矩阵 M，其中元素为符号 x 和 y
    M = Matrix([[x, 0, 0],
                [0, y, 0]])
    
    # 对 M 的第 1 行应用行操作
    M.row_op(1, lambda r, j: r + j + 1)
    # 断言 M 等于指定的 2x3 矩阵
    assert M == Matrix([[x,     0, 0],
                        [1, y + 2, 3]])

    # 对 M 的第 0 列应用列操作
    M.col_op(0, lambda c, j: c + y**j)
    # 断言 M 等于指定的 2x3 矩阵
    assert M == Matrix([[x + 1,     0, 0],
                        [1 + y, y + 2, 3]])

    # 断言 M 的第 0 行等于指定的 1x3 矩阵
    assert M.row(0) == Matrix([[x + 1, 0, 0]])
    # 获取 M 的第 0 行，并进行修改
    r1 = M.row(0)
    r1[0] = 42
    # 断言 M 的特定元素值未发生变化
    assert M[0, 0] == x + 1
    # 获取 M 的第 0 行的切片，并进行修改，同时测试负索引切片
    r1 = M[0, :-1]
    r1[0] = 42
    # 断言 M 的特定元素值未发生变化
    assert M[0, 0] == x + 1
    # 获取 M 的第 0 列，并进行修改
    c1 = M.col(0)
    assert c1 == Matrix([x + 1, 1 + y])
    c1[0] = 0
    # 断言 M 的特定元素值未发生变化
    assert M[0, 0] == x + 1
    # 获取 M 的第 0 列的切片，并进行修改
    c1 = M[:, 0]
    c1[0] = 42
    # 断言 M 的特定元素值未发生变化
    assert M[0, 0] == x + 1


# 定义一个名为 test_row_mult 的测试函数
def test_row_mult():
    # 创建一个 2x3 的矩阵 M
    M = Matrix([[1,2,3],
               [4,5,6]])
    # 对 M 的第 1 行应用行乘法操作
    M.row_mult(1,3)
    # 断言 M 的特定元素值符合预期
    assert M[1,0] == 12
    assert M[0,0] == 1
    assert M[1,2] == 18


# 定义一个名为 test_row_add 的测试函数
def test_row_add():
    # 创建一个 3x3 的矩阵 M
    M = Matrix([[1,2,3],
               [4,5,6],
               [1,1,1]])
    # 对 M 的第 2 行应用行加法操作
    M.row_add(2,0,5)
    # 断言 M 的特定元素值符合预期
    assert M[0,0] == 6
    assert M[1,0] == 4
    assert M[0,2] == 8


def test_zip_row_op():
    # 这个函数还未实现，因此没有代码。
    # 遍历前两个类别（classes[:2]），执行以下操作：
    for cls in classes[:2]: # XXX: immutable matrices don't support row ops
        # 创建一个 3x3 的单位矩阵，根据当前类别的类型（cls）进行操作
        M = cls.eye(3)
        # 在矩阵 M 上应用行操作，将第1行加上第0行的两倍
        M.zip_row_op(1, 0, lambda v, u: v + 2*u)
        # 断言矩阵 M 等于指定的矩阵
        assert M == cls([[1, 0, 0],
                         [2, 1, 0],
                         [0, 0, 1]])

        # 创建一个 3x3 的单位矩阵，并乘以2
        M = cls.eye(3)*2
        # 设置矩阵 M 中第0行第1列的元素为 -1
        M[0, 1] = -1
        # 在矩阵 M 上应用行操作，将第1行加上第0行的两倍
        M.zip_row_op(1, 0, lambda v, u: v + 2*u); M
        # 断言矩阵 M 等于指定的矩阵
        assert M == cls([[2, -1, 0],
                         [4,  0, 0],
                         [0,  0, 2]])
def test_issue_3950():
    # 创建三个 Matrix 对象并赋值给变量 m, a, b
    m = Matrix([1, 2, 3])
    a = Matrix([1, 2, 3])
    b = Matrix([2, 2, 3])
    # 断言 m 不在空列表中
    assert not (m in [])
    # 断言 m 不在包含一个元素的列表 [1] 中
    assert not (m in [1])
    # 断言 m 不等于整数 1
    assert m != 1
    # 断言 m 等于 a
    assert m == a
    # 断言 m 不等于 b
    assert m != b


def test_issue_3981():
    # 定义两个类 Index1 和 Index2，它们包含 __index__ 方法返回 1 和 2
    class Index1:
        def __index__(self):
            return 1

    class Index2:
        def __index__(self):
            return 2
    # 创建 Index1 和 Index2 的实例
    index1 = Index1()
    index2 = Index2()

    # 创建一个 Matrix 对象并赋值给变量 m
    m = Matrix([1, 2, 3])

    # 断言 m[index2] 的值为 3
    assert m[index2] == 3

    # 将 m[index2] 的值设置为 5
    m[index2] = 5
    # 断言 m[2] 的值为 5
    assert m[2] == 5

    # 创建一个包含两个子列表的 Matrix 对象并赋值给变量 m
    m = Matrix([[1, 2, 3], [4, 5, 6]])
    # 断言 m[index1, index2] 的值为 6
    assert m[index1, index2] == 6
    # 断言 m[1, index2] 的值为 6
    assert m[1, index2] == 6
    # 断言 m[index1, 2] 的值为 6
    assert m[index1, 2] == 6

    # 将 m[index1, index2] 的值设置为 4
    m[index1, index2] = 4
    # 断言 m[1, 2] 的值为 4
    assert m[1, 2] == 4
    # 将 m[1, index2] 的值设置为 6
    m[1, index2] = 6
    # 断言 m[1, 2] 的值为 6
    assert m[1, 2] == 6
    # 将 m[index1, 2] 的值设置为 8
    m[index1, 2] = 8
    # 断言 m[1, 2] 的值为 8
    assert m[1, 2] == 8


def test_evalf():
    # 创建包含表达式的 Matrix 对象并赋值给变量 a
    a = Matrix([sqrt(5), 6])
    # 断言 a.evalf() 中的每个元素等于 a 中对应位置元素的数值表达式
    assert all(a.evalf()[i] == a[i].evalf() for i in range(2))
    # 断言 a.evalf(2) 中的每个元素等于 a 中对应位置元素保留两位小数的数值表达式
    assert all(a.evalf(2)[i] == a[i].evalf(2) for i in range(2))
    # 断言 a.n(2) 中的每个元素等于 a 中对应位置元素保留两位小数的数值表达式
    assert all(a.n(2)[i] == a[i].n(2) for i in range(2))


def test_is_symbolic():
    # 创建包含符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[x, x], [x, x]])
    # 断言 a 是否包含符号变量，应为 True
    assert a.is_symbolic() is True
    # 创建不包含符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, 2, 3, 4], [5, 6, 7, 8]])
    # 断言 a 是否包含符号变量，应为 False
    assert a.is_symbolic() is False
    # 创建部分包含符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, 2, 3, 4], [5, 6, x, 8]])
    # 断言 a 是否包含符号变量，应为 True
    assert a.is_symbolic() is True
    # 创建包含部分符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, x, 3]])
    # 断言 a 是否包含符号变量，应为 True
    assert a.is_symbolic() is True
    # 创建不包含符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, 2, 3]])
    # 断言 a 是否包含符号变量，应为 False
    assert a.is_symbolic() is False
    # 创建包含部分符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1], [x], [3]])
    # 断言 a 是否包含符号变量，应为 True
    assert a.is_symbolic() is True
    # 创建不包含符号变量的 Matrix 对象并赋值给变量 a
    a = Matrix([[1], [2], [3]])
    # 断言 a 是否包含符号变量，应为 False
    assert a.is_symbolic() is False


def test_is_upper():
    # 创建包含单行的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, 2, 3]])
    # 断言 a 是否为上三角矩阵，应为 True
    assert a.is_upper is True
    # 创建包含单列的 Matrix 对象并赋值给变量 a
    a = Matrix([[1], [2], [3]])
    # 断言 a 是否为上三角矩阵，应为 False
    assert a.is_upper is False
    # 创建指定维度的零矩阵并赋值给变量 a
    a = zeros(4, 2)
    # 断言 a 是否为上三角矩阵，应为 True
    assert a.is_upper is True


def test_is_lower():
    # 创建包含单行的 Matrix 对象并赋值给变量 a
    a = Matrix([[1, 2, 3]])
    # 断言 a 是否为下三角矩阵，应为 False
    assert a.is_lower is False
    # 创建包含单列的 Matrix 对象并赋值给变量 a
    a = Matrix([[1], [2], [3]])
    # 断言 a 是否为下三角矩阵，应为 True
    assert a.is_lower is True


def test_is_nilpotent():
    # 创建一个特定的 4x4 Matrix 对象并赋值给变量 a
    a = Matrix(4, 4, [0, 2, 1, 6, 0, 0, 1, 2, 0, 0, 0, 3, 0, 0, 0, 0])
    # 断言 a 是否为幂零矩阵，应为 True
    assert a.is_nilpotent()
    # 创建一个对角矩阵并赋值给变量 a
    a = Matrix([[1, 0], [0, 1]])
    # 断言 a 是否为幂零矩阵，应为 False
    assert not a.is_nilpotent()
    # 创建一个空的 Matrix 对象并赋值给变量 a
    a = Matrix([])
    # 断言 a 是否为幂零矩阵，应为 True
    assert a.is_nilpotent()


def test_zeros_ones_fill():
    # 定义维度 n, m
    n, m = 3, 5

    # 创建一个零矩阵并赋值给变量 a
    a = zeros(n, m)
    # 用值 5 填充矩阵 a
    a.fill(5)

    #
    # 断言：计算矩阵在 x 趋向无穷时的极限，验证是否等于指定的极限矩阵
    assert Matrix([
        [x, -x, x**2],
        [exp(x), 1/x - exp(-x), x + 1/x]
    ]).limit(x, oo) == \
    Matrix([[oo, -oo, oo], [oo, 0, oo]])
    
    # 断言：计算矩阵在 x 趋向 0 时的极限，验证是否等于指定的极限矩阵
    assert Matrix([
        [(exp(x) - 1)/x, 2*x + y*x, x**x ],
        [1/x, abs(x), abs(sin(x + 1))]
    ]).limit(x, 0) == \
    Matrix([[1, 0, 1], [oo, 0, sin(1)]])
    
    # 断言：验证矩阵 a 在变量 x 上的积分结果是否等于指定的矩阵
    assert a.integrate(x) == Matrix([
        [Rational(1, 3)*x**3, y*x**2/2],
        [x**2*sin(y)/2, x**2*cos(y)/2]
    ])
def test_inv_iszerofunc():
    # 创建一个4x4的单位矩阵A
    A = eye(4)
    # 交换A的第0列和第1列
    A.col_swap(0, 1)
    # 对于方法"GE"和"LU"，验证A的逆矩阵是否等于使用"iszerofunc"函数为lambda x: x == 0的方法"ADJ"计算得到的逆矩阵
    for method in "GE", "LU":
        assert A.inv(method=method, iszerofunc=lambda x: x == 0) == \
            A.inv(method="ADJ")


def test_jacobian_metrics():
    # 定义符号变量rho和phi
    rho, phi = symbols("rho,phi")
    # 定义向量X和Y，其中X是一个2x1的矩阵
    X = Matrix([rho*cos(phi), rho*sin(phi)])
    # Y是一个2x1的矩阵
    Y = Matrix([rho, phi])
    # 计算X对于Y的雅可比矩阵J
    J = X.jacobian(Y)
    # 验证J与X对于转置后的Y计算得到的雅可比矩阵是否相等
    assert J == X.jacobian(Y.T)
    # 验证J与X的转置对于Y计算得到的雅可比矩阵是否相等
    assert J == (X.T).jacobian(Y)
    # 验证J与X的转置对于转置后的Y计算得到的雅可比矩阵是否相等
    assert J == (X.T).jacobian(Y.T)
    # 计算度规张量g，使用J的转置乘以单位矩阵，再对每个元素应用trigsimp函数
    g = J.T*eye(J.shape[0])*J
    g = g.applyfunc(trigsimp)
    # 验证计算得到的度规张量g是否为[[1, 0], [0, rho**2]]的矩阵
    assert g == Matrix([[1, 0], [0, rho**2]])


def test_jacobian2():
    # 定义符号变量rho和phi
    rho, phi = symbols("rho,phi")
    # 定义向量X和Y，其中X是一个3x1的矩阵
    X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])
    # Y是一个2x1的矩阵
    Y = Matrix([rho, phi])
    # 计算X对于Y的雅可比矩阵J
    J = Matrix([
        [cos(phi), -rho*sin(phi)],
        [sin(phi),  rho*cos(phi)],
        [   2*rho,             0],
    ])
    # 验证计算得到的雅可比矩阵J是否与预定义的矩阵相等
    assert X.jacobian(Y) == J


def test_issue_4564():
    # 定义矩阵X，其元素为exp(x + y + z)的三个复制
    X = Matrix([exp(x + y + z), exp(x + y + z), exp(x + y + z)])
    # 定义矩阵Y，包含变量x, y, z
    Y = Matrix([x, y, z])
    # 遍历范围为1到2的i和j值
    for i in range(1, 3):
        for j in range(1, 3):
            # 切片X和Y，分别取前i行和前j列
            X_slice = X[:i, :]
            Y_slice = Y[:j, :]
            # 计算X_slice对于Y_slice的雅可比矩阵J
            J = X_slice.jacobian(Y_slice)
            # 验证J的行数是否等于i
            assert J.rows == i
            # 验证J的列数是否等于j
            assert J.cols == j
            # 对于每个k在范围内，验证J的第k列是否等于X_slice
            for k in range(j):
                assert J[:, k] == X_slice


def test_nonvectorJacobian():
    # 定义矩阵X，包含元素exp(x + y + z)的两个复制
    X = Matrix([[exp(x + y + z), exp(x + y + z)],
                [exp(x + y + z), exp(x + y + z)]])
    # 使用Lambda函数验证X对于3x1矩阵Y的雅可比矩阵计算是否会引发TypeError异常
    raises(TypeError, lambda: X.jacobian(Matrix([x, y, z])))
    # 从X中取第0行，并定义矩阵Y
    X = X[0, :]
    Y = Matrix([[x, y], [x, z]])
    # 使用Lambda函数验证X对于Y的雅可比矩阵计算是否会引发TypeError异常
    raises(TypeError, lambda: X.jacobian(Y))
    # 使用Lambda函数验证X对于不对称Y的雅可比矩阵计算是否会引发TypeError异常
    raises(TypeError, lambda: X.jacobian(Matrix([ [x, y], [x, z] ])))


def test_vec():
    # 定义2x2的整数矩阵m
    m = Matrix([[1, 3], [2, 4]])
    # 计算矩阵m的列向量m_vec
    m_vec = m.vec()
    # 验证m_vec的列数是否为1
    assert m_vec.cols == 1
    # 遍历范围为0到3的i值
    for i in range(4):
        # 验证m_vec的第i个元素是否等于i+1
        assert m_vec[i] == i + 1


def test_vech():
    # 定义2x2的整数矩阵m
    m = Matrix([[1, 2], [2, 3]])
    # 计算矩阵m的vech形式m_vech
    m_vech = m.vech()
    # 验证m_vech的列数是否为1
    assert m_vech.cols == 1
    # 遍历范围为0到2的i值
    for i in range(3):
        # 验证m_vech的第i个元素是否等于i+1
        assert m_vech[i] == i + 1
    # 计算矩阵m的非对角vech形式m_vech
    m_vech = m.vech(diagonal=False)
    # 验证m_vech的第0个元素是否等于2
    assert m_vech[0] == 2

    # 定义带有变量x和y的2x2矩阵m
    m = Matrix([[1, x*(x + y)], [y*x + x**2, 1]])
    # 计算矩阵m的非对角vech形式m_vech
    m_vech = m.vech(diagonal=False)
    # 验证m_vech的第0个元素是否等于y*x + x**2
    assert m_vech[0] == y*x + x**2

    # 定义带有变量x和y的2x2矩阵m
    m = Matrix([[1, x*(x + y)], [y*x, 1]])
    # 计算矩阵m的非对称和不检查对称性的vech形式m_vech
    m_vech = m.vech(diagonal=False, check_symmetry=False)
    # 验证m_vech的第0个元素是否等于y*x
    assert m_vech[0] == y*x

    # 验证Matrix([[1, 3]])调用vech方法是否会引发ShapeError异常
    raises(ShapeError, lambda: Matrix([[1, 3]]).vech())
    # 验证Matrix([[1, 3], [2, 4]])调用vech方法是否会引发ValueError异常
    raises(ValueError, lambda: Matrix([[1, 3], [2, 4]]).vech())


def test_diag():
    # 断言diag([1, 2, 3])等于Matrix([1, 2, 3])
    assert diag([1, 2, 3]) == Matrix([1, 2, 3])
    #
def test_get_diag_blocks2():
    # 创建矩阵 a 和 b
    a = Matrix([[1, 2], [2, 3]])
    b = Matrix([[3, x], [y, 3]])
    # 创建矩阵 c
    c = Matrix([[3, x, 3], [y, 3, z], [x, y, z]])
    
    # 检查 diag 函数对 a, b, b 的对角块提取是否正确
    assert diag(a, b, b).get_diag_blocks() == [a, b, b]
    # 检查 diag 函数对 a, b, c 的对角块提取是否正确
    assert diag(a, b, c).get_diag_blocks() == [a, b, c]
    # 检查 diag 函数对 a, c, b 的对角块提取是否正确
    assert diag(a, c, b).get_diag_blocks() == [a, c, b]
    # 检查 diag 函数对 c, c, b 的对角块提取是否正确
    assert diag(c, c, b).get_diag_blocks() == [c, c, b]


def test_inv_block():
    # 创建矩阵 a 和 b
    a = Matrix([[1, 2], [2, 3]])
    b = Matrix([[3, x], [y, 3]])
    # 创建矩阵 c
    c = Matrix([[3, x, 3], [y, 3, z], [x, y, z]])
    
    # 对 diag(a, b, b) 进行逆运算，检查是否正确
    A = diag(a, b, b)
    assert A.inv(try_block_diag=True) == diag(a.inv(), b.inv(), b.inv())
    # 对 diag(a, b, c) 进行逆运算，检查是否正确
    A = diag(a, b, c)
    assert A.inv(try_block_diag=True) == diag(a.inv(), b.inv(), c.inv())
    # 对 diag(a, c, b) 进行逆运算，检查是否正确
    A = diag(a, c, b)
    assert A.inv(try_block_diag=True) == diag(a.inv(), c.inv(), b.inv())
    # 对 diag(a, a, b, a, c, a) 进行逆运算，检查是否正确
    A = diag(a, a, b, a, c, a)
    assert A.inv(try_block_diag=True) == diag(
        a.inv(), a.inv(), b.inv(), a.inv(), c.inv(), a.inv())
    # 使用 ADJ 方法对 diag(a, a, b, a, c, a) 进行逆运算，检查是否正确
    assert A.inv(try_block_diag=True, method="ADJ") == diag(
        a.inv(method="ADJ"), a.inv(method="ADJ"), b.inv(method="ADJ"),
        a.inv(method="ADJ"), c.inv(method="ADJ"), a.inv(method="ADJ"))


def test_creation_args():
    """
    检查可以使用任何合理类型来指定矩阵维度（参见 issue 4614）。
    """
    # 测试创建维度为负数的矩阵是否引发 ValueError
    raises(ValueError, lambda: zeros(3, -1))
    # 测试使用多于两个参数创建矩阵是否引发 TypeError
    raises(TypeError, lambda: zeros(1, 2, 3, 4))
    # 测试整数类型参数创建矩阵是否正确
    assert zeros(int(3)) == zeros(3)
    assert zeros(Integer(3)) == zeros(3)
    # 测试创建维度为浮点数的矩阵是否引发 ValueError
    raises(ValueError, lambda: zeros(3.))
    # 测试整数类型参数创建单位矩阵是否正确
    assert eye(int(3)) == eye(3)
    assert eye(Integer(3)) == eye(3)
    # 测试创建行列数为整数类型的全 1 矩阵是否正确
    assert ones(int(3), Integer(4)) == ones(3, 4)
    # 测试传入单个参数为整数的 Matrix 是否引发 TypeError
    raises(TypeError, lambda: Matrix(5))
    # 测试传入的列表参数含有非法嵌套的 Matrix 是否引发 ValueError
    raises(TypeError, lambda: Matrix(1, 2))
    raises(ValueError, lambda: Matrix([1, [2]]))


def test_diagonal_symmetrical():
    # 创建对称矩阵 m
    m = Matrix(2, 2, [0, 1, 1, 0])
    # 检查矩阵 m 是否为对角矩阵和对称矩阵
    assert not m.is_diagonal()
    assert m.is_symmetric()
    assert m.is_symmetric(simplify=False)

    # 创建对角矩阵 m
    m = Matrix(2, 2, [1, 0, 0, 1])
    assert m.is_diagonal()

    # 创建 diag(1, 2, 3) 矩阵并检查其为对角矩阵和对称矩阵
    m = diag(1, 2, 3)
    assert m.is_diagonal()
    assert m.is_symmetric()

    # 创建与 diag(1, 2, 3) 相等的矩阵 m 并检查其是否相等
    m = Matrix(3, 3, [1, 0, 0, 0, 2, 0, 0, 0, 3])
    assert m == diag(1, 2, 3)

    # 创建零矩阵 m 并检查其是否对称但不是对角矩阵
    m = Matrix(2, 3, zeros(2, 3))
    assert not m.is_symmetric()
    assert m.is_diagonal()

    # 创建对角矩阵 m 并检查其是否为对角矩阵
    m = Matrix(((5, 0), (0, 6), (0, 0)))
    assert m.is_diagonal()

    # 创建对角矩阵 m 并检查其是否为对角矩阵
    m = Matrix(((5, 0, 0), (0, 6, 0)))
    assert m.is_diagonal()

    # 创建矩阵 m 并检查其是否对称但未简化的对称性
    m = Matrix(3, 3, [1, x**2 + 2*x + 1, y, (x + 1)**2, 2, 0, y, 0, 3])
    assert m.is_symmetric()
    assert not m.is_symmetric(simplify=False)
    assert m.expand().is_symmetric(simplify=False)


def test_diagonalization():
    # 创建矩阵 m
    m = Matrix([[1, 2+I], [2-I, 3]])
    # 检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()

    # 创建矩阵 m
    m = Matrix(3, 2, [-3, 1, -3, 20, 3, 10])
    # 检查矩阵 m 是否不可对角化和非对称
    assert not m.is_diagonalizable()
    assert not m.is_symmetric()
    # 检查对非方阵使用 diagonalize 方法是否引发 NonSquareMatrixError
    raises(NonSquareMatrixError, lambda: m.diagonalize())

    # 创建对角矩阵 m
    m = diag(1, 2, 3)
    # 检查对 diag(1, 2, 3) 使用 diagonalize 方法是否得到正确的 P 和 D
    (P, D) = m.diagonalize()
    assert P == eye(3)
    assert D == m
    # 创建一个 2x2 的矩阵对象 m，初始值为 [0, 1, 1, 0]
    m = Matrix(2, 2, [0, 1, 1, 0])
    # 断言检查矩阵 m 是否对称
    assert m.is_symmetric()
    # 断言检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    
    # 创建一个 2x2 的矩阵对象 m，初始值为 [1, 0, 0, 3]
    m = Matrix(2, 2, [1, 0, 0, 3])
    # 断言检查矩阵 m 是否对称
    assert m.is_symmetric()
    # 断言检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    # 断言检查矩阵 P 是否为单位矩阵
    assert P == eye(2)
    # 断言检查对角化后的矩阵 D 是否与原始矩阵 m 相等
    assert D == m
    
    # 创建一个 2x2 的矩阵对象 m，初始值为 [1, 1, 0, 0]
    m = Matrix(2, 2, [1, 1, 0, 0])
    # 断言检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    
    # 创建一个 3x3 的矩阵对象 m，初始值为 [1, 2, 0, 0, 3, 0, 2, -4, 2]
    m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])
    # 断言检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    # 对矩阵 P 的每一行进行迭代
    for i in P:
        # 断言检查矩阵 P 的每一行的分母是否为1，即每个元素是整数
        assert i.as_numer_denom()[1] == 1
    
    # 创建一个 2x2 的矩阵对象 m，初始值为 [1, 0, 0, 0]
    m = Matrix(2, 2, [1, 0, 0, 0])
    # 断言检查矩阵 m 是否为对角矩阵
    assert m.is_diagonal()
    # 断言检查矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    # 断言检查矩阵 P 是否等于 [[0, 1], [1, 0]]
    assert P == Matrix([[0, 1], [1, 0]])
    
    # 创建一个 2x2 的复数矩阵对象 m，初始值为 [0, 1, -1, 0]
    m = Matrix(2, 2, [0, 1, -1, 0])
    # 断言检查复数矩阵 m 是否不可对角化
    assert not m.is_diagonalizable(True)
    # 使用 lambda 函数包裹对不可对角化的矩阵 m 调用 diagonalize 方法，断言期望引发 MatrixError 异常
    raises(MatrixError, lambda: m.diagonalize(True))
    # 断言检查复数矩阵 m 是否可对角化
    assert m.is_diagonalizable()
    # 对复数矩阵 m 进行对角化，返回对角化后的矩阵 P 和对角线上的元素组成的矩阵 D
    (P, D) = m.diagonalize()
    # 断言检查对角化后的结果是否符合对角化的定义
    assert P.inv() * m * P == D
    
    # 创建一个 2x2 的矩阵对象 m，初始值为 [0, 1, 0, 0]
    m = Matrix(2, 2, [0, 1, 0, 0])
    # 断言检查矩阵 m 是否不可对角化
    assert not m.is_diagonalizable()
    # 使用 lambda 函数包裹对不可对角化的矩阵 m 调用 diagonalize 方法，断言期望引发 MatrixError 异常
    raises(MatrixError, lambda: m.diagonalize())
    
    # 创建一个 3x3 的矩阵对象 m，初始值为 [-3, 1, -3, 20, 3, 10, 2, -2, 4]
    m = Matrix(3, 3, [-3, 1, -3, 20, 3, 10, 2, -2, 4])
    # 断言检查矩阵 m 是否不可对角化
    assert not m.is_diagonalizable()
    # 使用 lambda 函数包裹对不可对角化的矩阵 m 调用 diagonalize 方法，断言期望引发 MatrixError 异常
    raises(MatrixError, lambda: m.diagonalize())
    
    # 定义符号变量 a, b, c, d
    a, b, c, d = symbols('a b c d')
    # 创建一个 2x2 的符号矩阵对象 m，初始值为 [a, c, c, b]
    m = Matrix(2, 2, [a, c, c, b])
    # 断言检查符号矩阵 m 是否对称
    assert m.is_symmetric()
    # 断言检查符号矩阵 m 是否可对角化
    assert m.is_diagonalizable()
def test_issue_15887():
    # Mutable matrix should not use cache

    # 创建一个可变密集矩阵 a
    a = MutableDenseMatrix([[0, 1], [1, 0]])
    # 断言矩阵 a 可对角化
    assert a.is_diagonalizable() is True
    # 修改矩阵 a 中的元素
    a[1, 0] = 0
    # 断言矩阵 a 不可对角化
    assert a.is_diagonalizable() is False

    # 重新初始化矩阵 a
    a = MutableDenseMatrix([[0, 1], [1, 0]])
    # 对矩阵 a 进行对角化
    a.diagonalize()
    # 修改矩阵 a 中的元素
    a[1, 0] = 0
    # 使用 lambda 表达式检查对角化操作是否引发异常
    raises(MatrixError, lambda: a.diagonalize())


def test_jordan_form():

    # 创建一个 3x2 的矩阵 m
    m = Matrix(3, 2, [-3, 1, -3, 20, 3, 10])
    # 使用 lambda 表达式检查非方阵错误是否会被引发
    raises(NonSquareMatrixError, lambda: m.jordan_form())

    # 创建一个对角化矩阵 m
    m = Matrix(3, 3, [7, -12, 6, 10, -19, 10, 12, -24, 13])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(3, 3, [-1, 0, 0, 0, 1, 0, 0, 0, 1])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J
    assert Jmust == m.diagonalize()[1]

    # 创建一个对角化矩阵 m，复杂性仅限于复数域
    m = Matrix(3, 3, [0, 1, 0, -4, 4, 0, -2, 1, 2])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(3, 3, [2, 1, 0, 0, 2, 0, 0, 0, 2])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个对角化矩阵 m，其所有特征值相等
    m = Matrix(3, 3, [2, 6, -15, 1, 1, -5, 1, 2, -6])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(3, 3, [-1, 1, 0, 0, -1, 0, 0, 0, -1])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个对角化矩阵 m，其两个特征值为零
    m = Matrix(3, 3, [4, -5, 2, 5, -7, 3, 6, -9, 4])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(3, 3, [0, 1, 0, 0, 0, 0, 0, 0, 1])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个 4x4 的矩阵 m
    m = Matrix(4, 4, [6, 5, -2, -3, -3, -1, 3, 3, 2, 1, -2, -3, -1, 1, 5, 5])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(4, 4, [2, 1, 0, 0,
                          0, 2, 0, 0,
                          0, 0, 2, 1,
                          0, 0, 0, 2])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个 4x4 的矩阵 m
    m = Matrix(4, 4, [6, 2, -8, -6, -3, 2, 9, 6, 2, -2, -8, -6, -1, 0, 3, 4])
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(4, 4, [-2, 0, 0, 0,
                         0, 2, 1, 0,
                         0, 0, 2, 0,
                         0, 0, 0, 2])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个 4x4 的矩阵 m
    m = Matrix(4, 4, [5, 4, 2, 1, 0, 1, -1, -1, -1, -1, 3, 0, 1, 1, -1, 2])
    # 断言矩阵 m 不可对角化
    assert not m.is_diagonalizable()
    # 创建一个预期的 Jordan 形式矩阵 Jmust
    Jmust = Matrix(4, 4, [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 1, 0, 0, 0, 4])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并进行断言比较
    P, J = m.jordan_form()
    assert Jmust == J

    # 创建一个 2x2 的精度最大的矩阵 m
    m = Matrix([[Float('1.0', precision=110), Float('2.0', precision=110)],
                [Float('3.14159265358979323846264338327', precision=110), Float('4.0', precision=110)]])
    # 获取矩阵 m 的 Jordan 形式 P 和 J，并断言每个值的精度是否保持不变
    P, J = m.jordan_form()
    for term in J.values():
        if isinstance(term, Float):
            assert term._prec == 110
def test_jordan_form_complex_issue_9274():
    # 定义一个 4x4 的矩阵 A
    A = Matrix([[ 2,  4,  1,  0],
                [-4,  2,  0,  1],
                [ 0,  0,  2,  4],
                [ 0,  0, -4,  2]])
    # 定义复数 p 和 q
    p = 2 - 4*I;
    q = 2 + 4*I;
    # 定义两个 Jordan 形式的矩阵 Jmust1 和 Jmust2
    Jmust1 = Matrix([[p, 1, 0, 0],
                     [0, p, 0, 0],
                     [0, 0, q, 1],
                     [0, 0, 0, q]])
    Jmust2 = Matrix([[q, 1, 0, 0],
                     [0, q, 0, 0],
                     [0, 0, p, 1],
                     [0, 0, 0, p]])
    # 计算矩阵 A 的 Jordan 形式 P 和 J
    P, J = A.jordan_form()
    # 断言 J 必须等于 Jmust1 或者 Jmust2
    assert J == Jmust1 or J == Jmust2
    # 断言 P*J*P^(-1) 简化后必须等于 A
    assert simplify(P*J*P.inv()) == A

def test_issue_10220():
    # 定义矩阵 M
    # 其中包含两个非正交的 Jordan 块，特征值为 1
    M = Matrix([[1, 0, 0, 1],
                [0, 1, 1, 0],
                [0, 0, 1, 1],
                [0, 0, 0, 1]])
    # 计算矩阵 M 的 Jordan 形式 P 和 J
    P, J = M.jordan_form()
    # 断言 P 必须等于指定的矩阵
    assert P == Matrix([[0, 1, 0, 1],
                        [1, 0, 0, 0],
                        [0, 1, 0, 0],
                        [0, 0, 1, 0]])
    # 断言 J 必须等于指定的矩阵
    assert J == Matrix([
                        [1, 1, 0, 0],
                        [0, 1, 1, 0],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]])

def test_jordan_form_issue_15858():
    # 定义矩阵 A
    A = Matrix([
        [1, 1, 1, 0],
        [-2, -1, 0, -1],
        [0, 0, -1, -1],
        [0, 0, 2, 1]])
    # 计算矩阵 A 的 Jordan 形式 P 和 J
    (P, J) = A.jordan_form()
    # 断言 P 展开后必须等于指定的矩阵
    assert P.expand() == Matrix([
        [    -I,          -I/2,      I,           I/2],
        [-1 + I,             0, -1 - I,             0],
        [     0, -S(1)/2 - I/2,      0, -S(1)/2 + I/2],
        [     0,             1,      0,             1]])
    # 断言 J 必须等于指定的矩阵
    assert J == Matrix([
        [-I, 1, 0, 0],
        [0, -I, 0, 0],
        [0, 0, I, 1],
        [0, 0, 0, I]])

def test_Matrix_berkowitz_charpoly():
    # 定义符号变量
    UA, K_i, K_w = symbols('UA K_i K_w')

    # 定义矩阵 A
    A = Matrix([[-K_i - UA + K_i**2/(K_i + K_w),       K_i*K_w/(K_i + K_w)],
                [           K_i*K_w/(K_i + K_w), -K_w + K_w**2/(K_i + K_w)]])

    # 计算矩阵 A 的特征多项式 charpoly
    charpoly = A.charpoly(x)

    # 断言 charpoly 必须等于指定的多项式
    assert charpoly == \
        Poly(x**2 + (K_i*UA + K_w*UA + 2*K_i*K_w)/(K_i + K_w)*x +
        K_i*K_w*UA/(K_i + K_w), x, domain='ZZ(K_i,K_w,UA)')

    # 断言 charpoly 的类型必须为 PurePoly
    assert type(charpoly) is PurePoly

    # 定义不同类型的矩阵 A，进行特征多项式的计算和断言
    A = Matrix([[1, 3], [2, 0]])
    assert A.charpoly() == A.charpoly(x) == PurePoly(x**2 - x - 6)

    A = Matrix([[1, 2], [x, 0]])
    p = A.charpoly(x)
    # 断言 p 的生成元不等于 x
    assert p.gen != x
    # 断言 p 替换生成元后等于指定的表达式
    assert p.as_expr().subs(p.gen, x) == x**2 - 3*x

def test_exp_jordan_block():
    l = Symbol('lamda')

    # 生成 Jordan 块的矩阵 m，进行指数函数计算和断言
    m = Matrix.jordan_block(1, l)
    assert m._eval_matrix_exp_jblock() == Matrix([[exp(l)]])

    m = Matrix.jordan_block(3, l)
    assert m._eval_matrix_exp_jblock() == \
        Matrix([
            [exp(l), exp(l), exp(l)/2],
            [0, exp(l), exp(l)],
            [0, 0, exp(l)]])

def test_exp():
    # 定义矩阵 m 和其指数函数的结果
    m = Matrix([[3, 4], [0, -2]])
    m_exp = Matrix([[exp(3), -4*exp(-2)/5 + 4*exp(3)/5], [0, exp(-2)]])
    # 断言 m 的指数函数计算结果必须等于指定的矩阵 m_exp
    assert m.exp() == m_exp
    assert exp(m) == m_exp

    # 定义不同类型的矩阵 m，进行指数函数的计算和断言
    m = Matrix([[1, 0], [0, 1]])
    # 断言：检查矩阵 m 的指数函数是否等于给定的矩阵
    assert m.exp() == Matrix([[E, 0], [0, E]])
    
    # 断言：检查指数函数 exp(m) 是否等于给定的矩阵
    assert exp(m) == Matrix([[E, 0], [0, E]])
    
    # 创建矩阵 m，包含给定的值
    m = Matrix([[1, -1], [1, 1]])
    
    # 断言：检查矩阵 m 的指数函数是否等于给定的矩阵
    assert m.exp() == Matrix([[E*cos(1), -E*sin(1)], [E*sin(1), E*cos(1)]])
def test_log():
    # 创建一个表示 lambda 符号的 Symbol 对象
    l = Symbol('lamda')

    # 创建一个 Jordan 块矩阵，对其进行对数运算，验证结果是否为对数矩阵
    m = Matrix.jordan_block(1, l)
    assert m._eval_matrix_log_jblock() == Matrix([[log(l)]])

    # 创建另一个 Jordan 块矩阵，对其进行对数运算，验证结果是否正确
    m = Matrix.jordan_block(4, l)
    assert m._eval_matrix_log_jblock() == \
        Matrix(
            [
                [log(l), 1/l, -1/(2*l**2), 1/(3*l**3)],
                [0, log(l), 1/l, -1/(2*l**2)],
                [0, 0, log(l), 1/l],
                [0, 0, 0, log(l)]
            ]
        )

    # 创建一个特定的矩阵，尝试对其进行对数运算，预期引发 MatrixError 异常
    m = Matrix(
        [[0, 0, 1],
        [0, 0, 0],
        [-1, 0, 0]]
    )
    raises(MatrixError, lambda: m.log())


def test_has():
    # 创建一个 2x2 的矩阵 A
    A = Matrix(((x, y), (2, 3)))
    # 验证矩阵 A 是否包含符号 x
    assert A.has(x)
    # 验证矩阵 A 是否不包含符号 z
    assert not A.has(z)
    # 验证矩阵 A 是否包含符号对象 Symbol
    assert A.has(Symbol)

    # 对矩阵 A 中的符号 x 进行替换为具体值 2，然后验证是否不再包含符号 x
    A = A.subs(x, 2)
    assert not A.has(x)


def test_find_reasonable_pivot_naive_finds_guaranteed_nonzero1():
    # 测试 matrices._find_reasonable_pivot_naive() 函数能否在候选主元包含符号表达式时找到保证非零的主元
    # 关键字参数 simpfunc=None 表示搜索过程中不进行任何简化操作
    x = Symbol('x')
    column = Matrix(3, 1, [x, cos(x)**2 + sin(x)**2, S.Half])
    pivot_offset, pivot_val, pivot_assumed_nonzero, simplified =\
        _find_reasonable_pivot_naive(column)
    assert pivot_val == S.Half

def test_find_reasonable_pivot_naive_finds_guaranteed_nonzero2():
    # 测试 matrices._find_reasonable_pivot_naive() 函数能否在候选主元包含符号表达式时找到保证非零的主元
    # 关键字参数 simpfunc=_simplify 表示搜索过程中尝试简化候选主元
    x = Symbol('x')
    column = Matrix(3, 1,
                    [x,
                     cos(x)**2+sin(x)**2+x**2,
                     cos(x)**2+sin(x)**2])
    pivot_offset, pivot_val, pivot_assumed_nonzero, simplified =\
        _find_reasonable_pivot_naive(column, simpfunc=_simplify)
    assert pivot_val == 1

def test_find_reasonable_pivot_naive_simplifies():
    # 测试 matrices._find_reasonable_pivot_naive() 函数能否简化候选主元，并正确报告其偏移量
    x = Symbol('x')
    column = Matrix(3, 1,
                    [x,
                     cos(x)**2+sin(x)**2+x,
                     cos(x)**2+sin(x)**2])
    pivot_offset, pivot_val, pivot_assumed_nonzero, simplified =\
        _find_reasonable_pivot_naive(column, simpfunc=_simplify)

    # 验证简化后的候选主元列表长度是否为 2
    assert len(simplified) == 2
    # 验证简化后的候选主元的偏移量及其值是否正确
    assert simplified[0][0] == 1
    assert simplified[0][1] == 1+x
    assert simplified[1][0] == 2
    assert simplified[1][1] == 1

def test_errors():
    # 测试在创建矩阵时可能引发的各种错误
    raises(ValueError, lambda: Matrix([[1, 2], [1]]))
    raises(IndexError, lambda: Matrix([[1, 2]])[1.2, 5])
    raises(IndexError, lambda: Matrix([[1, 2]])[1, 5.2])
    raises(ValueError, lambda: randMatrix(3, c=4, symmetric=True))
    raises(ValueError, lambda: Matrix([1, 2]).reshape(4, 6))
    # 抛出 ShapeError 异常，测试 Matrix 类的 copyin_matrix 方法
    raises(ShapeError,
        lambda: Matrix([[1, 2], [3, 4]]).copyin_matrix([1, 0], Matrix([1, 2])))

    # 抛出 TypeError 异常，测试 Matrix 类的 copyin_list 方法
    raises(TypeError, lambda: Matrix([[1, 2], [3, 4]]).copyin_list([0,
           1], set()))

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 inv 方法
    raises(NonSquareMatrixError, lambda: Matrix([[1, 2, 3], [2, 3, 0]]).inv())

    # 抛出 ShapeError 异常，测试 Matrix 类的 row_join 方法
    raises(ShapeError,
        lambda: Matrix(1, 2, [1, 2]).row_join(Matrix([[1, 2], [3, 4]])))

    # 抛出 ShapeError 异常，测试 Matrix 类的 col_join 方法
    raises(
        ShapeError, lambda: Matrix([1, 2]).col_join(Matrix([[1, 2], [3, 4]])))

    # 抛出 ShapeError 异常，测试 Matrix 类的 row_insert 方法
    raises(ShapeError, lambda: Matrix([1]).row_insert(1, Matrix([[1,
           2], [3, 4]])))

    # 抛出 ShapeError 异常，测试 Matrix 类的 col_insert 方法
    raises(ShapeError, lambda: Matrix([1]).col_insert(1, Matrix([[1,
           2], [3, 4]])))

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 trace 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).trace())

    # 抛出 TypeError 异常，测试 Matrix 类的 applyfunc 方法
    raises(TypeError, lambda: Matrix([1]).applyfunc(1))

    # 抛出 ValueError 异常，测试 Matrix 类的 minor 方法
    raises(ValueError, lambda: Matrix([[1, 2], [3, 4]]).minor(4, 5))

    # 抛出 ValueError 异常，测试 Matrix 类的 minor_submatrix 方法
    raises(ValueError, lambda: Matrix([[1, 2], [3, 4]]).minor_submatrix(4, 5))

    # 抛出 TypeError 异常，测试 Matrix 类的 cross 方法
    raises(TypeError, lambda: Matrix([1, 2, 3]).cross(1))

    # 抛出 TypeError 异常，测试 Matrix 类的 dot 方法
    raises(TypeError, lambda: Matrix([1, 2, 3]).dot(1))

    # 抛出 ShapeError 异常，测试 Matrix 类的 dot 方法
    raises(ShapeError, lambda: Matrix([1, 2, 3]).dot(Matrix([1, 2])))

    # 抛出 ShapeError 异常，测试 Matrix 类的 dot 方法
    raises(ShapeError, lambda: Matrix([1, 2]).dot([]))

    # 抛出 TypeError 异常，测试 Matrix 类的 dot 方法
    raises(TypeError, lambda: Matrix([1, 2]).dot('a'))

    # 抛出 ShapeError 异常，测试 Matrix 类的 dot 方法
    raises(ShapeError, lambda: Matrix([1, 2]).dot([1, 2, 3]))

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 exp 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2, 3]).exp())

    # 抛出 ShapeError 异常，测试 Matrix 类的 normalized 方法
    raises(ShapeError, lambda: Matrix([[1, 2], [3, 4]]).normalized())

    # 抛出 ValueError 异常，测试 Matrix 类的 inv 方法
    raises(ValueError, lambda: Matrix([1, 2]).inv(method='not a method'))

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 inverse_GE 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).inverse_GE())

    # 抛出 ValueError 异常，测试 Matrix 类的 inverse_GE 方法
    raises(ValueError, lambda: Matrix([[1, 2], [1, 2]]).inverse_GE())

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 inverse_ADJ 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).inverse_ADJ())

    # 抛出 ValueError 异常，测试 Matrix 类的 inverse_ADJ 方法
    raises(ValueError, lambda: Matrix([[1, 2], [1, 2]]).inverse_ADJ())

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 inverse_LU 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).inverse_LU())

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 is_nilpotent 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).is_nilpotent())

    # 抛出 NonSquareMatrixError 异常，测试 Matrix 类的 det 方法
    raises(NonSquareMatrixError, lambda: Matrix([1, 2]).det())

    # 抛出 ValueError 异常，测试 Matrix 类的 det 方法
    raises(ValueError,
        lambda: Matrix([[1, 2], [3, 4]]).det(method='Not a real method'))

    # 抛出 ValueError 异常，测试 Matrix 类的 det 方法
    raises(ValueError,
        lambda: Matrix([[1, 2, 3, 4], [5, 6, 7, 8],
        [9, 10, 11, 12], [13, 14, 15, 16]]).det(iszerofunc="Not function"))

    # 抛出 ValueError 异常，测试 Matrix 类的 det 方法
    raises(ValueError,
        lambda: Matrix([[1, 2, 3, 4], [5, 6, 7, 8],
        [9, 10, 11, 12], [13, 14, 15, 16]]).det(iszerofunc=False))

    # 抛出 ValueError 异常，测试 hessian 函数
    raises(ValueError,
        lambda: hessian(Matrix([[1, 2], [3, 4]]), Matrix([[1, 2], [2, 1]])))

    # 抛出 ValueError 异常，测试 hessian 函数
    raises(ValueError, lambda: hessian(Matrix([[1, 2], [3, 4]]), []))

    # 抛出 ValueError 异常，测试 hessian 函数
    raises(ValueError, lambda: hessian(Symbol('x')**2, 'a'))

    # 抛出 IndexError 异常，测试 eye 函数的索引越界情况
    raises(IndexError, lambda: eye(3)[5, 2])

    # 抛出 IndexError 异常，测试 eye 函数的索引越界情况
    raises(IndexError, lambda: eye(3)[2, 5])

    # 定义 Matrix M 和 V，测试 Matrix 类的 det 方法
    M = Matrix(((1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16)))
    raises(ValueError, lambda: M.det('method=LU_decomposition()'))

    # 定义 Matrix M 和 V，测试 Matrix 类的 row_insert 方法
    V = Matrix([[10, 10, 10]])
    M = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    raises(ValueError, lambda: M.row_insert(4.7, V))
    # 创建一个 3x3 的矩阵对象 M，包含指定的行和列
    M = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 使用 Lambda 表达式和 raises 函数验证在列插入操作时抛出 ValueError 异常
    raises(ValueError, lambda: M.col_insert(-4.2, V))
def test_diff_by_matrix():

    # 矩阵对矩阵求导：

    A = MutableDenseMatrix([[x, y], [z, t]])
    # 对矩阵 A 自己进行求导，返回一个四维数组表示偏导数
    assert A.diff(A) == Array([[[[1, 0], [0, 0]], [[0, 1], [0, 0]]], [[[0, 0], [1, 0]], [[0, 0], [0, 1]]]])
    # 使用 diff 函数同样对矩阵 A 自己进行求导
    assert diff(A, A) == Array([[[[1, 0], [0, 0]], [[0, 1], [0, 0]]], [[[0, 0], [1, 0]], [[0, 0], [0, 1]]]])

    A_imm = A.as_immutable()
    # 对不可变矩阵 A_imm 自己进行求导，返回一个四维数组表示偏导数
    assert A_imm.diff(A_imm) == Array([[[[1, 0], [0, 0]], [[0, 1], [0, 0]]], [[[0, 0], [1, 0]], [[0, 0], [0, 1]]]])
    # 使用 diff 函数同样对不可变矩阵 A_imm 自己进行求导
    assert diff(A_imm, A_imm) == Array([[[[1, 0], [0, 0]], [[0, 1], [0, 0]]], [[[0, 0], [1, 0]], [[0, 0], [0, 1]]]])

    # 对常数矩阵进行求导，应返回全零矩阵
    assert A.diff(a) == MutableDenseMatrix([[0, 0], [0, 0]])

    B = ImmutableDenseMatrix([a, b])
    # 对矩阵 A 求对 B 的偏导数，应返回一个三维全零数组
    assert A.diff(B) == Array.zeros(2, 1, 2, 2)
    # 再次验证使用 diff 函数求导的结果
    assert A.diff(A) == Array([[[[1, 0], [0, 0]], [[0, 1], [0, 0]]], [[[0, 0], [1, 0]], [[0, 0], [0, 1]]]])

    # 使用元组进行求导的测试：

    dB = B.diff([[a, b]])
    # 对 B 进行 [a, b] 元组的求导，应返回一个三维数组
    assert dB.shape == (2, 2, 1)
    # 确认求导的具体数值
    assert dB == Array([[[1], [0]], [[0], [1]]])

    f = Function("f")
    fxyz = f(x, y, z)
    # 对多变量函数 fxyz 求对 [x, y, z] 元组的求导，应返回一个数组，包含每个变量的偏导数
    assert fxyz.diff([[x, y, z]]) == Array([fxyz.diff(x), fxyz.diff(y), fxyz.diff(z)])
    # 使用断言测试 fxyz 对象的二阶偏导数矩阵是否与给定的数组相等
    assert fxyz.diff(([x, y, z], 2)) == Array([
        [fxyz.diff(x, 2), fxyz.diff(x, y), fxyz.diff(x, z)],
        [fxyz.diff(x, y), fxyz.diff(y, 2), fxyz.diff(y, z)],
        [fxyz.diff(x, z), fxyz.diff(z, y), fxyz.diff(z, 2)],
    ])

    # 定义表达式 sin(x)*exp(y)
    expr = sin(x)*exp(y)
    # 使用 assert 测试 expr 对 (x, y) 的偏导数是否等于给定的数组
    assert expr.diff([[x, y]]) == Array([cos(x)*exp(y), sin(x)*exp(y)])
    # 使用 assert 测试 expr 对 y 的偏导数（使用元组表达）是否等于给定的数组
    assert expr.diff(y, ((x, y),)) == Array([cos(x)*exp(y), sin(x)*exp(y)])
    # 使用 assert 测试 expr 对 x 的偏导数（使用元组表达）是否等于给定的数组
    assert expr.diff(x, ((x, y),)) == Array([-sin(x)*exp(y), cos(x)*exp(y)])
    # 使用 assert 测试 expr 对 (y, x) 的偏导数（使用元组和列表混合表达）是否等于给定的数组
    assert expr.diff(((y, x),), [[x, y]]) == Array([[cos(x)*exp(y), -sin(x)*exp(y)], [sin(x)*exp(y), cos(x)*exp(y)]])

    # 测试不同的表达方式：

    # 使用 assert 测试 fxyz 对 x 的三阶偏导数是否等于给定的数值
    assert fxyz.diff(x).diff(y).diff(x) == fxyz.diff(((x, y, z),), 3)[0, 1, 0]
    # 使用 assert 测试 fxyz 对 z 的二阶偏导数、y 的一阶偏导数和 x 的零阶偏导数是否等于给定的数组
    assert fxyz.diff(z).diff(y).diff(x) == fxyz.diff(((x, y, z),), 3)[2, 1, 0]
    # 使用 assert 测试 fxyz 对 (x, y, z) 的偏导数矩阵是否与给定的矩阵相等
    assert fxyz.diff([[x, y, z]], ((z, y, x),)) == Array([[fxyz.diff(i).diff(j) for i in (x, y, z)] for j in (z, y, x)])

    # 测试标量通过矩阵派生仍为矩阵：

    # 计算 x 对矩阵 [[x, y]] 的偏导数，并使用 assert 测试结果是否为不可变的稠密矩阵
    res = x.diff(Matrix([[x, y]]))
    assert isinstance(res, ImmutableDenseMatrix)
    assert res == Matrix([[1, 0]])
    # 计算 x^3 对矩阵 [[x, y]] 的偏导数，并使用 assert 测试结果是否为不可变的稠密矩阵
    res = (x**3).diff(Matrix([[x, y]]))
    assert isinstance(res, ImmutableDenseMatrix)
    assert res == Matrix([[3*x**2, 0]])
def test_matrix_norm():
    # Vector Tests

    # 创建一个实数符号 x
    x = Symbol('x', real=True)
    # 创建一个包含 cos(x) 和 sin(x) 的向量
    v = Matrix([cos(x), sin(x)])
    # 断言向量的二范数等于 1
    assert trigsimp(v.norm(2)) == 1
    # 断言向量的 10 范数计算结果
    assert v.norm(10) == Pow(cos(x)**10 + sin(x)**10, Rational(1, 10))

    # Test Rows

    # 创建一个包含单行 [5, 3/2] 的矩阵 A
    A = Matrix([[5, Rational(3, 2)]])
    # 断言默认情况下矩阵的二范数
    assert A.norm() == Pow(25 + Rational(9, 4), S.Half)
    # 断言计算无穷范数
    assert A.norm(oo) == max(A)
    # 断言计算负无穷范数
    assert A.norm(-oo) == min(A)

    # Matrix Tests


这段代码主要用于测试矩阵和向量的范数计算功能，包括向量的不同范数（二范数和任意范数）以及矩阵的默认范数、无穷范数和负无穷范数。
    # Intuitive test
    # 创建一个 2x2 的矩阵 A
    A = Matrix([[1, 1], [1, 1]])
    # 检验矩阵 A 的不同范数计算结果
    assert A.norm(2) == 2  # 2-范数
    assert A.norm(-2) == 0  # -2-范数
    assert A.norm('frobenius') == 2  # Frobenius 范数
    assert eye(10).norm(2) == eye(10).norm(-2) == 1  # 单位矩阵的2-范数和-2-范数均为1
    assert A.norm(oo) == 2  # 无穷范数

    # Test with Symbols and more complex entries
    # 创建一个包含符号和复杂元素的矩阵 A
    A = Matrix([[3, y, y], [x, S.Half, -pi]])
    # 计算矩阵 A 的 Frobenius 范数
    assert (A.norm('fro')
           == sqrt(Rational(37, 4) + 2*abs(y)**2 + pi**2 + x**2))

    # Check non-square
    # 创建一个非方阵 A
    A = Matrix([[1, 2, -3], [4, 5, Rational(13, 2)]])
    # 计算矩阵 A 的2-范数
    assert A.norm(2) == sqrt(Rational(389, 8) + sqrt(78665)/8)
    # 计算矩阵 A 的-2-范数
    assert A.norm(-2) is S.Zero
    # 计算矩阵 A 的Frobenius 范数
    assert A.norm('frobenius') == sqrt(389)/2

    # Test properties of matrix norms
    # https://en.wikipedia.org/wiki/Matrix_norm#Definition
    # Two matrices
    # 定义四个矩阵 A, B, C, D
    A = Matrix([[1, 2], [3, 4]])
    B = Matrix([[5, 5], [-2, 2]])
    C = Matrix([[0, -I], [I, 0]])
    D = Matrix([[1, 0], [0, -1]])
    L = [A, B, C, D]
    alpha = Symbol('alpha', real=True)

    for order in ['fro', 2, -2]:
        # Zero Check
        # 零矩阵的各种范数均为零
        assert zeros(3).norm(order) is S.Zero
        # Check Triangle Inequality for all Pairs of Matrices
        # 检查所有矩阵对的三角不等式性质
        for X in L:
            for Y in L:
                dif = (X.norm(order) + Y.norm(order) -
                    (X + Y).norm(order))
                assert (dif >= 0)
        # Scalar multiplication linearity
        # 标量乘法的线性性质
        for M in [A, B, C, D]:
            dif = simplify((alpha*M).norm(order) -
                    abs(alpha) * M.norm(order))
            assert dif == 0

    # Test Properties of Vector Norms
    # https://en.wikipedia.org/wiki/Vector_norm
    # Two column vectors
    # 定义五个列向量 a, b, c, d, e
    a = Matrix([1, 1 - 1*I, -3])
    b = Matrix([S.Half, 1*I, 1])
    c = Matrix([-1, -1, -1])
    d = Matrix([3, 2, I])
    e = Matrix([Integer(1e2), Rational(1, 1e2), 1])
    L = [a, b, c, d, e]
    alpha = Symbol('alpha', real=True)

    for order in [1, 2, -1, -2, S.Infinity, S.NegativeInfinity, pi]:
        # Zero Check
        # 零向量的各种范数均为零
        if order > 0:
            assert Matrix([0, 0, 0]).norm(order) is S.Zero
        # Triangle inequality on all pairs
        # 所有向量对的三角不等式性质
        if order >= 1:  # Triangle InEq holds only for these norms
            for X in L:
                for Y in L:
                    dif = (X.norm(order) + Y.norm(order) -
                        (X + Y).norm(order))
                    assert simplify(dif >= 0) is S.true
        # Linear to scalar multiplication
        # 标量乘法的线性性质
        if order in [1, 2, -1, -2, S.Infinity, S.NegativeInfinity]:
            for X in L:
                dif = simplify((alpha*X).norm(order) -
                    (abs(alpha) * X.norm(order)))
                assert dif == 0

    # ord=1
    # 创建一个3x3的矩阵 M
    M = Matrix(3, 3, [1, 3, 0, -2, -1, 0, 3, 9, 6])
    # 计算矩阵 M 的1-范数
    assert M.norm(1) == 13
# 定义测试函数 test_condition_number
def test_condition_number():
    # 定义符号变量 x，并指定其为实数
    x = Symbol('x', real=True)
    # 创建一个 3x3 的单位矩阵 A
    A = eye(3)
    # 修改单位矩阵 A 的元素 A[0, 0] 为 10
    A[0, 0] = 10
    # 修改单位矩阵 A 的元素 A[2, 2] 为 1/10
    A[2, 2] = Rational(1, 10)
    # 断言计算矩阵 A 的条件数是否为 100
    assert A.condition_number() == 100

    # 修改单位矩阵 A 的元素 A[1, 1] 为符号变量 x
    A[1, 1] = x
    # 断言计算矩阵 A 的条件数是否符合最大值为 10 和 |x|，最小值为 1/10 和 |x| 的比较
    assert A.condition_number() == Max(10, Abs(x)) / Min(Rational(1, 10), Abs(x))

    # 创建一个 2x2 的旋转矩阵 M，其中元素使用符号变量 x 表示
    M = Matrix([[cos(x), sin(x)], [-sin(x), cos(x)]])
    # 计算矩阵 M 的条件数，并赋值给变量 Mc
    Mc = M.condition_number()
    # 断言对于变量 x 取不同值（1/5, 1/2, 1/10, π/2, π, 7π/4），矩阵 M 的条件数是否与浮点数 1. 的误差相等
    assert all(Float(1.).epsilon_eq(Mc.subs(x, val).evalf()) for val in
        [Rational(1, 5), S.Half, Rational(1, 10), pi/2, pi, pi*Rational(7, 4) ])

    # issue 10782 的问题断言：空矩阵的条件数为 0
    assert Matrix([]).condition_number() == 0


# 定义测试函数 test_equality
def test_equality():
    # 创建一个 3x3 的矩阵 A
    A = Matrix(((1, 2, 3), (4, 5, 6), (7, 8, 9)))
    # 创建一个 3x3 的矩阵 B，元素值逆序于 A
    B = Matrix(((9, 8, 7), (6, 5, 4), (3, 2, 1)))
    # 断言矩阵 A 等于 A 的所有列（即 A[:, :]）
    assert A == A[:, :]
    # 断言矩阵 A 不不等于 A 的所有列（即 A[:, :]）
    assert not A != A[:, :]
    # 断言矩阵 A 不等于矩阵 B
    assert not A == B
    # 断言矩阵 A 不等于矩阵 B
    assert A != B
    # 断言矩阵 A 不等于整数 10
    assert A != 10
    # 断言矩阵 A 不等于整数 10
    assert not A == 10

    # 创建一个稀疏矩阵 C
    C = SparseMatrix(((1, 0, 0), (0, 1, 0), (0, 0, 1)))
    # 创建一个矩阵 D，元素与稀疏矩阵 C 相同
    D = Matrix(((1, 0, 0), (0, 1, 0), (0, 0, 1)))
    # 断言矩阵 C 等于矩阵 D
    assert C == D
    # 断言矩阵 C 不不等于矩阵 D
    assert not C != D


# 定义测试函数 test_col_join
def test_col_join():
    # 断言单位矩阵 eye(3) 与矩阵 [[7, 7, 7]] 的列连接结果
    assert eye(3).col_join(Matrix([[7, 7, 7]])) == \
        Matrix([[1, 0, 0],
                [0, 1, 0],
                [0, 0, 1],
                [7, 7, 7]])


# 定义测试函数 test_row_insert
def test_row_insert():
    # 创建一个 1x3 的矩阵 r4
    r4 = Matrix([[4, 4, 4]])
    # 循环从 -4 到 4
    for i in range(-4, 5):
        # 创建一个列表 l
        l = [1, 0, 0]
        # 在列表 l 的第 i 位置插入数字 4
        l.insert(i, 4)
        # 断言对于单位矩阵 eye(3)，在第 i 行插入 r4 后，第 0 列的扁平化结果是否等于列表 l
        assert flatten(eye(3).row_insert(i, r4).col(0).tolist()) == l


# 定义测试函数 test_col_insert
def test_col_insert():
    # 创建一个 3x1 的矩阵 c4
    c4 = Matrix([4, 4, 4])
    # 循环从 -4 到 4
    for i in range(-4, 5):
        # 创建一个列表 l
        l = [0, 0, 0]
        # 在列表 l 的第 i 位置插入数字 4
        l.insert(i, 4)
        # 断言对于全零矩阵 zeros(3)，在第 i 列插入 c4 后，第 0 行的扁平化结果是否等于列表 l
        assert flatten(zeros(3).col_insert(i, c4).row(0).tolist()) == l


# 定义测试函数 test_normalized
def test_normalized():
    # 断言向量 [3, 4] 的归一化结果
    assert Matrix([3, 4]).normalized() == \
        Matrix([Rational(3, 5), Rational(4, 5)])

    # 零向量的特殊情况
    assert Matrix([0, 0, 0]).normalized() == Matrix([0, 0, 0])

    # 机器精度误差截断的特殊情况
    m = Matrix([0,0,1.e-100])
    assert m.normalized(
    iszerofunc=lambda x: x.evalf(n=10, chop=True).is_zero
    ) == Matrix([0, 0, 0])


# 定义测试函数 test_print_nonzero
def test_print_nonzero():
    # 断言打印单位矩阵 eye(3) 的非零元素结果，使用 'X' 表示非零元素
    assert capture(lambda: eye(3).print_nonzero()) == \
        '[X  ]\n[ X ]\n[  X]\n'
    # 断言打印单位矩阵 eye(3) 的非零元素结果，使用 '.' 表示非零元素
    assert capture(lambda: eye(3).print_nonzero('.')) == \
        '[.  ]\n[ . ]\n[  .]\n'


# 定义测试函数 test_zeros_eye
def test_zeros_eye():
    # 断言 Matrix 类的单位矩阵方法与 eye(3) 的结果相等
    assert Matrix.eye(3) == eye(3)
    # 断言 Matrix 类的全零矩阵方法与 zeros(3) 的结果相等
    assert Matrix.zeros(3) == zeros(3)
    # 断言创建 3x4 的全一矩阵与 Matrix 类的结果相等
    assert ones(3, 4) == Matrix(3, 4, [1]*12)

    # 创建一个单位矩阵 i 和全零矩阵 z
    i = Matrix([[1, 0], [0, 1]])
    z = Matrix([[0, 0], [0, 0]])
    # 循环遍历 classes 中的每个类
    for cls in classes:
        # 使用类的 eye(2) 方法创建一个
    # 创建稀疏矩阵并检查是否为零矩阵，预期结果为 None
    assert SparseMatrix([[x, 0], [0, 0]]).is_zero_matrix == None
    
    # 创建不可变矩阵并检查是否为零矩阵，预期结果为 None
    assert ImmutableMatrix([[x, 0], [0, 0]]).is_zero_matrix == None
    
    # 创建不可变稀疏矩阵并检查是否为零矩阵，预期结果为 None
    assert ImmutableSparseMatrix([[x, 0], [0, 0]]).is_zero_matrix == None
    
    # 创建一般矩阵并检查是否为零矩阵，预期结果为 False
    assert Matrix([[x, 1], [0, 0]]).is_zero_matrix == False
    
    # 创建一个具有非零元素 'a' 的符号，并创建矩阵检查是否为零矩阵，预期结果为 False
    a = Symbol('a', nonzero=True)
    assert Matrix([[a, 0], [0, 0]]).is_zero_matrix == False
# 测试旋转矩阵的功能
def test_rotation_matrices():
    # 定义角度为 pi/3
    theta = pi/3
    # 使用 rot_axis3 函数创建绕第三轴旋转 theta 角度的旋转矩阵 r3_plus 和逆矩阵 r3_minus
    r3_plus = rot_axis3(theta)
    r3_minus = rot_axis3(-theta)
    # 使用 rot_axis2 函数创建绕第二轴旋转 theta 角度的旋转矩阵 r2_plus 和逆矩阵 r2_minus
    r2_plus = rot_axis2(theta)
    r2_minus = rot_axis2(-theta)
    # 使用 rot_axis1 函数创建绕第一轴旋转 theta 角度的旋转矩阵 r1_plus 和逆矩阵 r1_minus
    r1_plus = rot_axis1(theta)
    r1_minus = rot_axis1(-theta)
    # 断言旋转矩阵的逆矩阵乘积为单位矩阵
    assert r3_minus*r3_plus*eye(3) == eye(3)
    assert r2_minus*r2_plus*eye(3) == eye(3)
    assert r1_minus*r1_plus*eye(3) == eye(3)

    # 检查旋转矩阵迹的正确性
    assert r1_plus.trace() == 1 + 2*cos(theta)
    assert r2_plus.trace() == 1 + 2*cos(theta)
    assert r3_plus.trace() == 1 + 2*cos(theta)

    # 检查零角度旋转不改变任何内容
    assert rot_axis1(0) == eye(3)
    assert rot_axis2(0) == eye(3)
    assert rot_axis3(0) == eye(3)

    # 检查左手约定
    # 参见问题 #24529
    q1 = Quaternion.from_axis_angle([1, 0, 0], pi / 2)
    q2 = Quaternion.from_axis_angle([0, 1, 0], pi / 2)
    q3 = Quaternion.from_axis_angle([0, 0, 1], pi / 2)
    assert rot_axis1(- pi / 2) == q1.to_rotation_matrix()
    assert rot_axis2(- pi / 2) == q2.to_rotation_matrix()
    assert rot_axis3(- pi / 2) == q3.to_rotation_matrix()
    # 检查右手约定
    assert rot_ccw_axis1(+ pi / 2) == q1.to_rotation_matrix()
    assert rot_ccw_axis2(+ pi / 2) == q2.to_rotation_matrix()
    assert rot_ccw_axis3(+ pi / 2) == q3.to_rotation_matrix()
    # 断言：验证矩阵 m 的最后一行等于 Matrix([[2, 3]])，Matrix 是矩阵对象，.T 表示转置
    assert m[-1, :] == Matrix([[2, 3]])
    
    # 断言：验证矩阵 m 的第一列等于 Matrix([[1, 3]]).T，.T 表示转置
    assert m[:, 1] == Matrix([[1, 3]]).T
    
    # 断言：验证矩阵 m 的最后一列等于 Matrix([[1, 3]]).T，.T 表示转置
    assert m[:, -1] == Matrix([[1, 3]]).T
    
    # 断言：验证索引 m[2, :] 会引发 IndexError 异常，表明矩阵 m 的第三行不存在
    raises(IndexError, lambda: m[2, :])
    
    # 断言：验证索引 m[2, 2] 会引发 IndexError 异常，表明矩阵 m 的第三行第三列不存在
    raises(IndexError, lambda: m[2, 2])
def test_slice_issue_3401():
    # 断言切片操作对零矩阵的最后一列形状为 (0, 1)
    assert zeros(0, 3)[:, -1].shape == (0, 1)
    # 断言切片操作对零矩阵的第一行为空矩阵
    assert zeros(3, 0)[0, :] == Matrix(1, 0, [])


def test_copyin():
    # 创建一个 3x3 的零矩阵
    s = zeros(3, 3)
    # 在第四行赋值为 1
    s[3] = 1
    # 断言矩阵 s 的第一列为 Matrix([0, 1, 0])
    assert s[:, 0] == Matrix([0, 1, 0])
    # 断言矩阵 s 的第四行为 1
    assert s[3] == 1
    # 断言矩阵 s 的第四行到第五行（实际为第四行）为 [1]
    assert s[3: 4] == [1]
    # 修改矩阵 s 中第二行第二列的值为 42
    s[1, 1] = 42
    # 断言矩阵 s 的第二行第二列为 42
    assert s[1, 1] == 42
    # 断言矩阵 s 的第二行第二列到最后一列为 Matrix([[42, 0]])
    assert s[1, 1:] == Matrix([[42, 0]])
    # 将矩阵 s 中第二行第二列到最后一列的值修改为 Matrix([[5, 6]])
    s[1, 1:] = Matrix([[5, 6]])
    # 断言矩阵 s 的第二行为 Matrix([[1, 5, 6]])
    assert s[1, :] == Matrix([[1, 5, 6]])
    # 将矩阵 s 中第二行第二列到最后一列的值修改为 [[42, 43]]
    s[1, 1:] = [[42, 43]]
    # 断言矩阵 s 的第二行为 Matrix([[1, 42, 43]])
    assert s[1, :] == Matrix([[1, 42, 43]])
    # 将矩阵 s 中第一行第一列的值修改为 17
    s[0, 0] = 17
    # 断言矩阵 s 的前三行第一列为 Matrix([17, 1, 0])
    assert s[:, :1] == Matrix([17, 1, 0])
    # 将矩阵 s 中第一行第一列的值修改为 [1, 1, 1]
    s[0, 0] = [1, 1, 1]
    # 断言矩阵 s 的第一列为 Matrix([1, 1, 1])
    assert s[:, 0] == Matrix([1, 1, 1])
    # 将矩阵 s 中第一行第一列的值修改为 Matrix([1, 1, 1])
    s[0, 0] = Matrix([1, 1, 1])
    # 断言矩阵 s 的第一列为 Matrix([1, 1, 1])
    assert s[:, 0] == Matrix([1, 1, 1])
    # 将矩阵 s 中第一行第一列的值修改为 SparseMatrix([1, 1, 1])
    s[0, 0] = SparseMatrix([1, 1, 1])
    # 断言矩阵 s 的第一列为 Matrix([1, 1, 1])


def test_invertible_check():
    # 断言特定矩阵的行简化阶梯形式结果及其主元位置
    assert Matrix([[1, 2], [1, 2]]).rref() == (Matrix([[1, 2], [0, 0]]), (0,))
    # 断言尝试对不可逆矩阵求逆将引发 ValueError 异常
    raises(ValueError, lambda: Matrix([[1, 2], [1, 2]]).inv())
    # 创建一个带符号的矩阵 m
    m = Matrix([
        [-1, -1,  0],
        [ x,  1,  1],
        [ 1,  x, -1],
    ])
    # 断言矩阵 m 的简化阶梯形式结果的主元位置数不等于其行数
    assert len(m.rref()[1]) != m.rows
    # 断言调用 rref 函数时，即使 m 不可逆，返回的结果并非单位矩阵
    assert m.rref()[0] != eye(3)
    # 断言调用 rref 函数时，使用 signsimp 参数简化结果后，结果仍不是单位矩阵
    assert m.rref(simplify=signsimp)[0] != eye(3)
    # 断言尝试使用 "ADJ" 方法对 m 求逆将引发 ValueError 异常
    raises(ValueError, lambda: m.inv(method="ADJ"))
    # 断言尝试使用 "GE" 方法对 m 求逆将引发 ValueError 异常
    raises(ValueError, lambda: m.inv(method="GE"))
    # 断言尝试使用 "LU" 方法对 m 求逆将引发 ValueError 异常
    raises(ValueError, lambda: m.inv(method="LU"))


def test_issue_3959():
    # 定义符号变量 x, y
    x, y = symbols('x, y')
    # 创建一个表达式 e
    e = x*y
    # 断言用 x=Matrix([3, 5, 3]) 替换表达式 e 中的 x，得到 Matrix([3, 5, 3])*y
    assert e.subs(x, Matrix([3, 5, 3])) == Matrix([3, 5, 3])*y


def test_issue_5964():
    # 断言将矩阵转换为字符串结果为 'Matrix([[1, 2], [3, 4]])'
    assert str(Matrix([[1, 2], [3, 4]])) == 'Matrix([[1, 2], [3, 4]])'


def test_issue_7604():
    # 定义符号变量 x, y
    x, y = symbols("x y")
    # 断言将矩阵转换为人类可读字符串的结果
    assert sstr(Matrix([[x, 2*y], [y**2, x + 3]])) == \
        'Matrix([\n[   x,   2*y],\n[y**2, x + 3]])'


def test_is_Identity():
    # 断言单位矩阵是否被正确识别
    assert eye(3).is_Identity
    # 断言通过 as_immutable 方法生成的单位矩阵是否被正确识别
    assert eye(3).as_immutable().is_Identity
    # 断言全零矩阵不被错误识别为单位矩阵
    assert not zeros(3).is_Identity
    # 断言全一矩阵不被错误识别为单位矩阵
    assert not ones(3).is_Identity
    # issue 6242
    # 断言具有特定行的矩阵不被错误识别为单位矩阵
    assert not Matrix([[1, 0, 0]]).is_Identity
    # issue 8854
    # 断言特定稀疏矩阵被正确识别为单位矩阵
    assert SparseMatrix(3,3, {(0,0):1, (1,1):1, (2,2):1}).is_Identity
    # 断言不具备单位矩阵属性的稀疏矩阵不被错误识别为单位矩阵
    assert not SparseMatrix(2,3, range(6)).is_Identity
    # 断言部分单位元素的稀疏矩阵不被错误识别为
    # 使用 SymPy 中的 Matrix 类创建矩阵，并进行点乘操作，验证结果是否等于 4 + 8*I
    assert Matrix([1, 2, 3*I]).dot(Matrix([4, 5*I, 6]), hermitian=True, conjugate_convention="right") == 4 + 8*I
    
    # 使用 SymPy 中的 Matrix 类创建矩阵，并进行点乘操作，验证结果是否等于 4 - 8*I
    assert Matrix([1, 2, 3*I]).dot(Matrix([4, 5*I, 6]), hermitian=True, conjugate_convention="left") == 4 - 8*I
    
    # 使用 SymPy 中的 Matrix 类创建矩阵，并进行点乘操作，验证结果是否等于 -5，不使用共轭转置
    assert Matrix([I, 2*I]).dot(Matrix([I, 2*I]), hermitian=False, conjugate_convention="left") == -5
    
    # 使用 SymPy 中的 Matrix 类创建矩阵，并进行点乘操作，验证结果是否等于 5，使用默认的共轭转置
    assert Matrix([I, 2*I]).dot(Matrix([I, 2*I]), conjugate_convention="left") == 5
    
    # 使用 SymPy 中的 raises 函数，验证在给定条件下是否会抛出 ValueError 异常
    raises(ValueError, lambda: Matrix([1, 2]).dot(Matrix([3, 4]), hermitian=True, conjugate_convention="test"))
# 定义一个测试函数 test_dual，用于测试符号和矩阵操作的功能
def test_dual():
    # 创建符号变量 B_x, B_y, B_z, E_x, E_y, E_z，要求其为实数
    B_x, B_y, B_z, E_x, E_y, E_z = symbols('B_x B_y B_z E_x E_y E_z', real=True)
    # 创建一个 4x4 的矩阵 F，表示电磁场张量
    F = Matrix((
        (   0,  E_x,  E_y,  E_z),
        (-E_x,    0,  B_z, -B_y),
        (-E_y, -B_z,    0,  B_x),
        (-E_z,  B_y, -B_x,    0)
    ))
    # 创建 F 的对偶矩阵 Fd
    Fd = Matrix((
        (  0, -B_x, -B_y, -B_z),
        (B_x,    0,  E_z, -E_y),
        (B_y, -E_z,    0,  E_x),
        (B_z,  E_y, -E_x,    0)
    ))
    # 断言 F 的对偶矩阵等于 Fd
    assert F.dual().equals(Fd)
    # 断言单位矩阵的对偶矩阵为全零矩阵
    assert eye(3).dual().equals(zeros(3))
    # 断言 F 的双重对偶矩阵等于 -F
    assert F.dual().dual().equals(-F)


# 定义一个测试函数 test_anti_symmetric，用于测试矩阵的反对称性质
def test_anti_symmetric():
    # 断言长度为 2 的矩阵 [1, 2] 不是反对称矩阵
    assert Matrix([1, 2]).is_anti_symmetric() is False
    # 创建一个 3x3 的矩阵 m，具有特定的数值
    m = Matrix(3, 3, [0, x**2 + 2*x + 1, y, -(x + 1)**2, 0, x*y, -y, -x*y, 0])
    # 断言 m 是反对称矩阵
    assert m.is_anti_symmetric() is True
    # 断言未简化的 m 不是反对称矩阵
    assert m.is_anti_symmetric(simplify=False) is None
    # 断言通过给定简化函数不是反对称矩阵
    assert m.is_anti_symmetric(simplify=lambda x: x) is None

    # 修改矩阵 m 使其不再是反对称的
    m[2, 1] = -m[2, 1]
    # 断言 m 不再是反对称矩阵
    assert m.is_anti_symmetric() is None
    # 恢复修改
    m[2, 1] = -m[2, 1]

    # 对 m 进行展开
    m = m.expand()
    # 断言展开后的 m 是反对称矩阵（不简化）
    assert m.is_anti_symmetric(simplify=False) is True
    # 修改 m 的元素使其不再是反对称矩阵
    m[0, 0] = 1
    # 断言 m 不再是反对称矩阵
    assert m.is_anti_symmetric() is False


# 定义一个测试函数 test_normalize_sort_diogonalization，用于测试矩阵的对角化功能
def test_normalize_sort_diogonalization():
    # 创建一个 2x2 的矩阵 A
    A = Matrix(((1, 2), (2, 1)))
    # 对矩阵 A 进行对角化，同时归一化和排序
    P, Q = A.diagonalize(normalize=True)
    # 断言 P*P^T 和 P^T*P 是单位矩阵
    assert P*P.T == P.T*P == eye(P.cols)
    # 再次对矩阵 A 进行对角化，仅归一化并排序
    P, Q = A.diagonalize(normalize=True, sort=True)
    # 断言 P*P^T 和 P^T*P 是单位矩阵
    assert P*P.T == P.T*P == eye(P.cols)
    # 断言 P*Q*P^(-1) 等于原始矩阵 A
    assert P*Q*P.inv() == A


# 定义一个测试函数 test_issue_5321，用于测试特定问题的异常处理
def test_issue_5321():
    # 断言 Lambda 表达式引发 ValueError，验证特定条件下的异常处理
    raises(ValueError, lambda: Matrix([[1, 2, 3], Matrix(0, 1, [])]))


# 定义一个测试函数 test_issue_5320，用于测试特定问题的矩阵堆叠功能
def test_issue_5320():
    # 断言水平堆叠单位矩阵和其倍数
    assert Matrix.hstack(eye(2), 2*eye(2)) == Matrix([
        [1, 0, 2, 0],
        [0, 1, 0, 2]
    ])
    # 断言垂直堆叠单位矩阵和其倍数
    assert Matrix.vstack(eye(2), 2*eye(2)) == Matrix([
        [1, 0],
        [0, 1],
        [2, 0],
        [0, 2]
    ])
    # 使用 SparseMatrix 类进行水平堆叠单位矩阵和其倍数
    cls = SparseMatrix
    assert cls.hstack(cls(eye(2)), cls(2*eye(2))) == Matrix([
        [1, 0, 2, 0],
        [0, 1, 0, 2]
    ])


# 定义一个测试函数 test_issue_11944，用于测试特定问题的矩阵堆叠功能
def test_issue_11944():
    # 创建一个单元素矩阵 A
    A = Matrix([[1]])
    # 使用 sympify 将 A 转换为符号形式 AIm
    AIm = sympify(A)
    # 断言水平堆叠 AIm 和 A 后得到的矩阵
    assert Matrix.hstack(AIm, A) == Matrix([[1, 1]])
    # 断言垂直堆叠 AIm 和 A 后得到的矩阵
    assert Matrix.vstack(AIm, A) == Matrix([[1], [1]])


# 定义一个测试函数 test_cross，用于测试向量的叉乘功能
def test_cross():
    # 定义两个向量 a 和 b
    a = [1, 2, 3]
    b = [3, 4, 5]
    # 创建预期的列向量 col 和行向量 row
    col = Matrix([-2, 4, -2])
    row = col.T

    # 定义一个用于测试的函数 test
    def test(M, ans):
        # 断言 M 等于 ans，并且 M 的类型是 cls
        assert ans == M
        assert type(M) == cls

    # 遍历各个矩阵类进行测试
    for cls in classes:
        # 创建向量 A 和 B 的矩阵表示
        A = cls(a)
        B = cls(b)
        # 测试 A 叉乘 B 的结果，应与预期的列向量 col 相等
        test(A.cross(B), col)
        # 测试 A 转置叉乘 B 的结果，应与预期的列向量 col 相等
        test(A.cross(B.T), col)
        # 测试 A 转置叉乘 B 转置的结果，应与预期的行向量 row 相等
        test(A.T.cross(B.T), row)
        # 测试 A 转置叉乘 B 的结果，应与预期的行向量 row 相等
        test(A.T.cross(B), row)

    # 断言 ShapeError，验证矩阵形状不匹配时引发异常
    # 选择列表 classes 中的第一个元素赋值给 cls 变量
    cls = classes[0]
    # 使用 lambda 函数测试调用 cls 对象的 eye 方法，预期会抛出 AttributeError 异常
    raises(AttributeError, lambda: hash(cls.eye(1)))
# 定义一个测试函数，用于测试 adjoint 方法的正确性
def test_adjoint():
    # 定义一个包含复数和复数单位的二维列表
    dat = [[0, I], [1, 0]]
    # 预期的结果是一个 Matrix 对象，其元素为复数的共轭转置
    ans = Matrix([[0, 1], [-I, 0]])
    # 遍历 classes 列表中的每个类
    for cls in classes:
        # 断言调用 adjoint 方法后返回的结果等于预期的 ans
        assert ans == cls(dat).adjoint()

# 定义一个测试函数，用于测试 simplify 方法对 ImmutableMatrix 的操作
def test_simplify_immutable():
    # 断言对不可变矩阵调用 simplify 方法后，结果等于预期的不可变单位矩阵
    assert simplify(ImmutableMatrix([[sin(x)**2 + cos(x)**2]])) == \
                    ImmutableMatrix([[1]])

# 定义一个测试函数，用于测试 replace 方法
def test_replace():
    # 定义符号 F 和 G 为函数符号，并创建一个元素为函数值的 2x2 矩阵 K 和 M
    F, G = symbols('F, G', cls=Function)
    K = Matrix(2, 2, lambda i, j: G(i+j))
    M = Matrix(2, 2, lambda i, j: F(i+j))
    # 使用 replace 方法替换 M 中的函数符号 F 为 G，赋值给 N
    N = M.replace(F, G)
    # 断言替换后的结果 N 等于预期的矩阵 K
    assert N == K

# 定义一个测试函数，用于测试 atoms 方法
def test_atoms():
    # 创建一个包含符号和表达式的矩阵 m
    m = Matrix([[1, 2], [x, 1 - 1/x]])
    # 断言矩阵 m 的原子元素是 {1, 2, -1, x}
    assert m.atoms() == {S.One, S(2), S.NegativeOne, x}
    # 断言矩阵 m 的符号类型的原子元素是 {x}
    assert m.atoms(Symbol) == {x}

# 定义一个测试函数，用于测试 pinv 方法
def test_pinv():
    # 测试可逆矩阵的伪逆是其逆矩阵
    A1 = Matrix([[a, b], [c, d]])
    assert simplify(A1.pinv(method="RD")) == simplify(A1.inv())

    # 对多个矩阵进行伪逆测试，验证其四个性质
    As = [Matrix([[13, 104], [2212, 3], [-3, 5]]),
          Matrix([[1, 7, 9], [11, 17, 19]]),
          Matrix([a, b])]

    for A in As:
        A_pinv = A.pinv(method="RD")
        AAp = A * A_pinv
        ApA = A_pinv * A
        # 断言 A * pinv(A) * A 等于 A
        assert simplify(AAp * A) == A
        # 断言 pinv(A) * A * pinv(A) 等于 pinv(A)
        assert simplify(ApA * A_pinv) == A_pinv
        # 断言 AAp 的共轭转置等于自身
        assert AAp.H == AAp
        # 断言 ApA 的共轭转置等于自身
        assert ApA.H == ApA

    # 对使用对角化方法计算伪逆的测试，略过复杂表达式
    for A in As:
        A_pinv = simplify(A.pinv(method="ED"))
        AAp = A * A_pinv
        ApA = A_pinv * A
        # 断言 A * pinv(A) * A 等于 A
        assert simplify(AAp * A) == A
        # 断言 pinv(A) * A * pinv(A) 等于 pinv(A)
        assert simplify(ApA * A_pinv) == A_pinv
        # 断言 AAp 的共轭转置等于自身
        assert AAp.H == AAp
        # 断言 ApA 的共轭转置等于自身
        assert ApA.H == ApA

    # 对使用对角化方法计算伪逆的测试，略过复杂表达式
    # A1 = Matrix([[a, b], [c, d]])
    # assert simplify(A1.pinv(method="ED")) == simplify(A1.inv())
    # 这部分在一个固定的随机点上数值测试

    # 使用 comp 方法在一个固定的随机点上数值测试 pinv
    from sympy.core.numbers import comp
    q = A1.pinv(method="ED")
    w = A1.inv()
    reps = {a: -73633, b: 11362, c: 55486, d: 62570}
    # 断言 pinv(A1) 在指定替换下与 inv(A1) 的每个元素数值相等
    assert all(
        comp(i.n(), j.n())
        for i, j in zip(q.subs(reps), w.subs(reps))
        )

# 定义一个慢速测试函数，用于测试当对角化失败时的伪逆计算
@slow
def test_pinv_rank_deficient_when_diagonalization_fails():
    # 对当 A.H*A 的对角化失败时的伪逆的四个性质进行测试
    As = [
        Matrix([
            [61, 89, 55, 20, 71, 0],
            [62, 96, 85, 85, 16, 0],
            [69, 56, 17,  4, 54, 0],
            [10, 54, 91, 41, 71, 0],
            [ 7, 30, 10, 48, 90, 0],
            [0, 0, 0, 0, 0, 0]])
    ]
    for A in As:
        # 计算 A 的伪逆矩阵 A_pinv，使用方法 "ED"
        A_pinv = A.pinv(method="ED")
        # 计算 A 和其伪逆矩阵的乘积 AAp
        AAp = A * A_pinv
        # 计算 伪逆矩阵和 A 的乘积 ApA
        ApA = A_pinv * A
        # 断言 AAp 的共轭转置与自身相等
        assert AAp.H == AAp

        # 这里 ApA.H 和 ApA 是等价的表达式，但它们涉及到 RootOfs，非常复杂。
        # 使用 simplify 太慢，evalf 也很慢，因此我们用 RootOfs 的近似值替换，
        # 然后再用 evalf，这样虽然不太精确，但足以确认这两个矩阵是等价的。

        def allclose(M1, M2):
            # 获取 M1 中的所有 RootOf 对象
            rootofs = M1.atoms(RootOf)
            # 对每个 RootOf 对象求近似值
            rootofs_approx = {r: r.evalf() for r in rootofs}
            # 用近似值替换 M1 和 M2 中的 RootOf 对象，然后求差并 evalf
            diff_approx = (M1 - M2).xreplace(rootofs_approx).evalf()
            # 检查差的每个元素是否都小于 1e-10
            return all(abs(e) < 1e-10 for e in diff_approx)

        # 断言 ApA 的共轭转置与自身非常接近
        assert allclose(ApA.H, ApA)
def test_issue_7201():
    # 断言检查调用 ones(0, 1) 和 ones(0, 1) 后返回的 Matrix 对象是否符合预期值
    assert ones(0, 1) + ones(0, 1) == Matrix(0, 1, [])
    # 断言检查调用 ones(1, 0) 和 ones(1, 0) 后返回的 Matrix 对象是否符合预期值
    assert ones(1, 0) + ones(1, 0) == Matrix(1, 0, [])

def test_free_symbols():
    # 遍历不同类型的矩阵类，验证其在特定输入下的 free_symbols 属性是否正确返回 {x}
    for M in ImmutableMatrix, ImmutableSparseMatrix, Matrix, SparseMatrix:
        assert M([[x], [0]]).free_symbols == {x}

def test_from_ndarray():
    """See issue 7465."""
    try:
        from numpy import array
    except ImportError:
        skip('NumPy must be available to test creating matrices from ndarrays')

    # 断言验证通过 numpy 数组创建的 Matrix 对象是否与预期的 Matrix 对象相等
    assert Matrix(array([1, 2, 3])) == Matrix([1, 2, 3])
    assert Matrix(array([[1, 2, 3]])) == Matrix([[1, 2, 3]])
    assert Matrix(array([[1, 2, 3], [4, 5, 6]])) == \
        Matrix([[1, 2, 3], [4, 5, 6]])
    assert Matrix(array([x, y, z])) == Matrix([x, y, z])
    # 断言检查创建超过二维的 numpy 数组时是否抛出 NotImplementedError
    raises(NotImplementedError,
        lambda: Matrix(array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])))
    assert Matrix([array([1, 2]), array([3, 4])]) == Matrix([[1, 2], [3, 4]])
    assert Matrix([array([1, 2]), [3, 4]]) == Matrix([[1, 2], [3, 4]])
    assert Matrix([array([]), array([])]) == Matrix([])

def test_17522_numpy():
    from sympy.matrices.common import _matrixify
    try:
        from numpy import array, matrix
    except ImportError:
        skip('NumPy must be available to test indexing matrixified NumPy ndarrays and matrices')

    # 使用 _matrixify 函数将 numpy 数组转换为 Matrix 对象，并验证索引和列表化的正确性
    m = _matrixify(array([[1, 2], [3, 4]]))
    assert m[3] == 4
    assert list(m) == [1, 2, 3, 4]

    with ignore_warnings(PendingDeprecationWarning):
        m = _matrixify(matrix([[1, 2], [3, 4]]))
    assert m[3] == 4
    assert list(m) == [1, 2, 3, 4]

def test_17522_mpmath():
    from sympy.matrices.common import _matrixify
    try:
        from mpmath import matrix
    except ImportError:
        skip('mpmath must be available to test indexing matrixified mpmath matrices')

    # 使用 _matrixify 函数将 mpmath 矩阵转换为 Matrix 对象，并验证索引和列表化的正确性
    m = _matrixify(matrix([[1, 2], [3, 4]]))
    assert m[3] == 4.0
    assert list(m) == [1.0, 2.0, 3.0, 4.0]

def test_17522_scipy():
    from sympy.matrices.common import _matrixify
    try:
        from scipy.sparse import csr_matrix
    except ImportError:
        skip('SciPy must be available to test indexing matrixified SciPy sparse matrices')

    # 使用 _matrixify 函数将 SciPy 稀疏矩阵转换为 Matrix 对象，并验证索引和列表化的正确性
    m = _matrixify(csr_matrix([[1, 2], [3, 4]]))
    assert m[3] == 4
    assert list(m) == [1, 2, 3, 4]

def test_hermitian():
    # 创建一个复数矩阵 a，并验证其是否为 Hermite 矩阵，随后修改元素并重新验证
    a = Matrix([[1, I], [-I, 1]])
    assert a.is_hermitian
    a[0, 0] = 2*I
    assert a.is_hermitian is False
    a[0, 0] = x
    assert a.is_hermitian is None
    a[0, 1] = a[1, 0]*I
    assert a.is_hermitian is False

def test_doit():
    # 创建一个包含未求值的加法表达式的 Matrix 对象，验证 doit 方法的行为
    a = Matrix([[Add(x,x, evaluate=False)]])
    assert a[0] != 2*x
    assert a.doit() == Matrix([[2*x]])

def test_issue_9457_9467_9876():
    # 针对 row_del(index) 方法的测试，创建不同的 Matrix 对象并测试其删除行的功能
    M = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    M.row_del(1)
    assert M == Matrix([[1, 2, 3], [3, 4, 5]])
    N = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    N.row_del(-2)
    assert N == Matrix([[1, 2, 3], [3, 4, 5]])
    O = Matrix([[1, 2, 3], [5, 6, 7], [9, 10, 11]])
    O.row_del(-1)
    # 断言确保 O 等于给定的矩阵
    assert O == Matrix([[1, 2, 3], [5, 6, 7]])
    # 创建一个新的矩阵 P
    P = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 测试删除行的操作，期望引发 IndexError 异常，因为索引超出范围
    raises(IndexError, lambda: P.row_del(10))
    # 创建一个新的矩阵 Q
    Q = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 测试删除行的操作，期望引发 IndexError 异常，因为负索引超出范围
    raises(IndexError, lambda: Q.row_del(-10))

    # for col_del(index)
    # 创建一个新的矩阵 M
    M = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 删除索引为 1 的列
    M.col_del(1)
    # 断言确保 M 等于删除列后的预期结果矩阵
    assert M == Matrix([[1, 3], [2, 4], [3, 5]])
    # 创建一个新的矩阵 N
    N = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 删除倒数第二列
    N.col_del(-2)
    # 断言确保 N 等于删除列后的预期结果矩阵
    assert N == Matrix([[1, 3], [2, 4], [3, 5]])
    # 重新赋值矩阵 P
    P = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 测试删除列的操作，期望引发 IndexError 异常，因为索引超出范围
    raises(IndexError, lambda: P.col_del(10))
    # 创建一个新的矩阵 Q
    Q = Matrix([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    # 测试删除列的操作，期望引发 IndexError 异常，因为负索引超出范围
    raises(IndexError, lambda: Q.col_del(-10))
def test_issue_9422():
    # 定义非交换符号变量 x, y
    x, y = symbols('x y', commutative=False)
    # 定义符号变量 a, b
    a, b = symbols('a b')
    # 创建一个 2x2 的单位矩阵 M
    M = eye(2)
    # 创建一个 2x2 的矩阵 M1，其中元素为 [x, y, y, z]
    M1 = Matrix(2, 2, [x, y, y, z])
    # 断言，验证矩阵乘法的非交换性质
    assert y*x*M != x*y*M
    # 断言，验证矩阵乘法的交换性质
    assert b*a*M == a*b*M
    # 断言，验证矩阵与矩阵乘法的非交换性质
    assert x*M1 != M1*x
    # 断言，验证矩阵与矩阵乘法的交换性质
    assert a*M1 == M1*a
    # 断言，验证特定矩阵乘法结果是否正确
    assert y*x*M == Matrix([[y*x, 0], [0, y*x]])


def test_issue_10770():
    # 创建一个空矩阵 M
    M = Matrix([])
    # 定义操作和相应的矩阵 m，执行操作并验证结果
    a = ['col_insert', 'row_join'], Matrix([9, 6, 3])
    b = ['row_insert', 'col_join'], a[1].T
    c = ['row_insert', 'col_insert'], Matrix([[1, 2], [3, 4]])
    for ops, m in (a, b, c):
        for op in ops:
            f = getattr(M, op)
            # 执行操作并断言结果正确，且对象的地址不同
            new = f(m) if 'join' in op else f(42, m)
            assert new == m and id(new) != id(m)


def test_issue_10658():
    # 创建一个 3x3 的矩阵 A
    A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    # 断言，验证矩阵按指定条件提取子矩阵的正确性
    assert A.extract([0, 1, 2], [True, True, False]) == \
        Matrix([[1, 2], [4, 5], [7, 8]])
    assert A.extract([0, 1, 2], [True, False, False]) == Matrix([[1], [4], [7]])
    assert A.extract([True, False, False], [0, 1, 2]) == Matrix([[1, 2, 3]])
    assert A.extract([True, False, True], [0, 1, 2]) == \
        Matrix([[1, 2, 3], [7, 8, 9]])
    assert A.extract([0, 1, 2], [False, False, False]) == Matrix(3, 0, [])
    assert A.extract([False, False, False], [0, 1, 2]) == Matrix(0, 3, [])
    assert A.extract([True, False, True], [False, True, False]) == \
        Matrix([[2], [8]])


def test_opportunistic_simplification():
    # 这个测试与问题 #10718, #9480, #11434 有关

    # issue #9480
    # 创建一个包含符号表达式的矩阵 m，验证其秩是否正确
    m = Matrix([[-5 + 5*sqrt(2), -5], [-5*sqrt(2)/2 + 5, -5*sqrt(2)/2]])
    assert m.rank() == 1

    # issue #10781
    # 创建一个包含符号表达式的矩阵 m，验证其行阶梯形式和简化后的结果
    m = Matrix([[3+3*sqrt(3)*I, -9],[4,-3+3*sqrt(3)*I]])
    assert simplify(m.rref()[0] - Matrix([[1, -9/(3 + 3*sqrt(3)*I)], [0, 0]])) == zeros(2, 2)

    # issue #11434
    # 定义多个符号变量，并创建一个包含符号表达式的矩阵 m，验证其秩是否正确
    ax,ay,bx,by,cx,cy,dx,dy,ex,ey,t0,t1 = symbols('a_x a_y b_x b_y c_x c_y d_x d_y e_x e_y t_0 t_1')
    m = Matrix([[ax,ay,ax*t0,ay*t0,0],[bx,by,bx*t0,by*t0,0],[cx,cy,cx*t0,cy*t0,1],[dx,dy,dx*t0,dy*t0,1],[ex,ey,2*ex*t1-ex*t0,2*ey*t1-ey*t0,0]])
    assert m.rank() == 4


def test_partial_pivoting():
    # 来自 https://en.wikipedia.org/wiki/Pivot_element 的示例
    # 使用部分主元选取和回代得到完美结果
    # 简单主元选取产生的误差约为 1e-13，因此小于 1e-15 就是好的
    mm=Matrix([[0.003, 59.14, 59.17], [5.291, -6.13, 46.78]])
    assert (mm.rref()[0] - Matrix([[1.0,   0, 10.0],
                                   [  0, 1.0,  1.0]])).norm() < 1e-15

    # issue #11549
    # 创建一个数值上不稳定的例子，包含一个矩阵及其逆矩阵
    m_mixed = Matrix([[6e-17, 1.0, 4],
                      [ -1.0,   0, 8],
                      [    0,   0, 1]])
    m_float = Matrix([[6e-17,  1.0, 4.],
                      [ -1.0,   0., 8.],
                      [   0.,   0., 1.]])
    m_inv = Matrix([[  0,    -1.0,  8.0],
                    [1.0, 6.0e-17, -4.0],
                    [  0,       0,    1]])
    # 这个例子在数值上不稳定，包含一个范数大于等于 8 的矩阵
    # 断言：比较混合精度矩阵 m_mixed 的逆矩阵与标准精度矩阵 m_inv 的差异是否小于 1e-15，这是数值上合理的比较。
    assert (m_mixed.inv() - m_inv).norm() < 1e-15
    # 断言：比较浮点数矩阵 m_float 的逆矩阵与标准精度矩阵 m_inv 的差异是否小于 1e-15，这也是数值上合理的比较。
    assert (m_float.inv() - m_inv).norm() < 1e-15
def test_iszero_substitution():
    """ When doing numerical computations, all elements that pass
    the iszerofunc test should be set to numerically zero if they
    aren't already. """
    
    # 创建一个 3x4 的矩阵，包含特定的数值
    m = Matrix([[0.9, -0.1, -0.2, 0],[-0.8, 0.9, -0.4, 0],[-0.1, -0.8, 0.6, 0]])
    # 对该矩阵进行行简化（RREF），使用自定义的 iszerofunc 函数来判断是否为零
    m_rref = m.rref(iszerofunc=lambda x: abs(x)<6e-15)[0]
    # 创建一个预期的正确的矩阵
    m_correct = Matrix([[1.0,   0, -0.301369863013699, 0],[  0, 1.0, -0.712328767123288, 0],[  0,   0,                  0, 0]])
    # 计算简化后的矩阵与预期正确矩阵的差异
    m_diff = m_rref - m_correct
    # 断言差异的 Frobenius 范数小于给定的阈值
    assert m_diff.norm() < 1e-15
    # 断言简化后矩阵的特定元素为零
    assert m_rref[2,2] == 0

def test_issue_11238():
    from sympy.geometry.point import Point
    # 计算 xx 和 yy 的值
    xx = 8*tan(pi*Rational(13, 45))/(tan(pi*Rational(13, 45)) + sqrt(3))
    yy = (-8*sqrt(3)*tan(pi*Rational(13, 45))**2 + 24*tan(pi*Rational(13, 45)))/(-3 + tan(pi*Rational(13, 45))**2)
    # 创建三个点对象
    p1 = Point(0, 0)
    p2 = Point(1, -sqrt(3))
    p0 = Point(xx,yy)
    # 创建三个矩阵，用于表示点的位置关系
    m1 = Matrix([p1 - simplify(p0), p2 - simplify(p0)])
    m2 = Matrix([p1 - p0, p2 - p0])
    m3 = Matrix([simplify(p1 - p0), simplify(p2 - p0)])

    # 这个系统包含一些被认为为零的表达式，
    # 而这些表达式不容易证明确实是零，因此在没有
    # 数值测试的情况下，这些断言可能会失败。
    Z = lambda x: abs(x.n()) < 1e-20
    # 断言简化后的矩阵的秩为1
    assert m1.rank(simplify=True, iszerofunc=Z) == 1
    assert m2.rank(simplify=True, iszerofunc=Z) == 1
    assert m3.rank(simplify=True, iszerofunc=Z) == 1

def test_as_real_imag():
    # 创建一个 2x2 的矩阵 m1
    m1 = Matrix(2,2,[1,2,3,4])
    # 将 m1 与虚数单位相乘，得到 m2
    m2 = m1*S.ImaginaryUnit
    # 计算 m1 和 m2 的和，得到 m3
    m3 = m1 + m2

    # 对于 classes 中的每个类，执行以下操作：
    for kls in classes:
        # 将 m3 转换为实部和虚部
        a,b = kls(m3).as_real_imag()
        # 断言转换后的实部与 m1 的列表形式相同
        assert list(a) == list(m1)
        # 断言转换后的虚部与 m1 的列表形式相同
        assert list(b) == list(m1)

def test_deprecated():
    # 维护废弃函数的测试。必须捕获
    # 废弃警告。当废弃功能被移除时，应该删除
    # 相应的测试。
    
    # 创建一个特定的 3x3 矩阵 m
    m = Matrix(3, 3, [0, 1, 0, -4, 4, 0, -2, 1, 2])
    # 计算 m 的 Jordan 细胞分解
    P, Jcells = m.jordan_cells()
    # 断言 Jcells 的第二个元素是一个特定的 1x1 矩阵
    assert Jcells[1] == Matrix(1, 1, [2])
    # 断言 Jcells 的第一个元素是一个特定的 2x2 矩阵
    assert Jcells[0] == Matrix(2, 2, [2, 1, 0, 2])

def test_issue_14489():
    from sympy.core.mod import Mod
    # 创建一个特定的列向量 A
    A = Matrix([-1, 1, 2])
    # 断言 A 对 3 取模后的结果与给定的矩阵相同
    assert Mod(A, 3) == Matrix([2, 1, 2])

def test_issue_14943():
    # 测试 __array__ 方法接受可选的 dtype 参数
    try:
        from numpy import array
    except ImportError:
        skip('NumPy must be available to test creating matrices from ndarrays')

    # 创建一个特定的 2x2 矩阵 M
    M = Matrix([[1,2], [3,4]])
    # 断言将 M 转换为 ndarray，并指定数据类型为 float 后得到的 dtype 名称为 'float64'
    assert array(M, dtype=float).dtype.name == 'float64'

def test_case_6913():
    # 创建一个符号 m 的 1x1 矩阵
    m = MatrixSymbol('m', 1, 1)
    # 创建一个符号 a
    a = Symbol("a")
    # 将 a 设置为 m[0, 0] > 0 的表达式
    a = m[0, 0]>0
    # 断言 a 的字符串表示为 'm[0, 0] > 0'
    assert str(a) == 'm[0, 0] > 0'

def test_issue_11948():
    # 创建一个符号 A 的 3x3 矩阵
    A = MatrixSymbol('A', 3, 3)
    # 创建一个通配符 a
    a = Wild('a')
    # 使用 match 方法匹配 A 与通配符 a 的关系
    assert A.match(a) == {a: A}

def test_gramschmidt_conjugate_dot():
    # 创建一个包含两个向量的列表
    vecs = [Matrix([1, I]), Matrix([1, -I])]
    # 对给定向量集合进行正交化，并断言结果是否符合预期
    assert Matrix.orthogonalize(*vecs) == \
        [Matrix([[1], [I]]), Matrix([[1], [-I]])]
    
    # 定义向量集合vecs，包含两个复数向量
    vecs = [Matrix([1, I, 0]), Matrix([I, 0, -I])]
    # 对给定向量集合进行正交化，并断言结果是否符合预期
    assert Matrix.orthogonalize(*vecs) == \
        [Matrix([[1], [I], [0]]), Matrix([[I/2], [S(1)/2], [-I]])]
    
    # 定义一个复数矩阵mat
    mat = Matrix([[1, I], [1, -I]])
    # 对矩阵mat进行QR分解，分别得到Q和R
    Q, R = mat.QRdecomposition()
    # 断言Q乘以其共轭转置等于单位矩阵
    assert Q * Q.H == Matrix.eye(2)
# 测试函数，用于验证 GitHub 上的 issue 8207
def test_issue_8207():
    # 创建 3x1 的 MatrixSymbol 对象 'a'
    a = Matrix(MatrixSymbol('a', 3, 1))
    # 创建 3x1 的 MatrixSymbol 对象 'b'
    b = Matrix(MatrixSymbol('b', 3, 1))
    # 计算矩阵 a 和 b 的点积
    c = a.dot(b)
    # 计算 c 对 a[0, 0] 的偏导数
    d = diff(c, a[0, 0])
    # 计算 d 对 a[0, 0] 的偏导数
    e = diff(d, a[0, 0])
    # 断言 d 等于 b[0, 0]
    assert d == b[0, 0]
    # 断言 e 等于 0
    assert e == 0

# 测试函数，验证 sympy 中的各种函数功能
def test_func():
    # 导入 nthroot 函数
    from sympy.simplify.simplify import nthroot

    # 创建 2x2 矩阵 A
    A = Matrix([[1, 2],[0, 3]])
    # 断言 A 对 sin(x*t) 函数的解析函数等于指定矩阵
    assert A.analytic_func(sin(x*t), x) == Matrix([[sin(t), sin(3*t) - sin(t)], [0, sin(3*t)]])

    # 重新赋值给 A
    A = Matrix([[2, 1],[1, 2]])
    # 断言 (pi * A / 6) 对 cos(x) 函数的解析函数等于指定矩阵
    assert (pi * A / 6).analytic_func(cos(x), x) == Matrix([[sqrt(3)/4, -sqrt(3)/4], [-sqrt(3)/4, sqrt(3)/4]])

    # 断言 zeros(5) 对 log(x) 函数抛出 ValueError 异常
    raises(ValueError, lambda : zeros(5).analytic_func(log(x), x))
    # 断言 (A*x) 对 log(x) 函数抛出 ValueError 异常
    raises(ValueError, lambda : (A*x).analytic_func(log(x), x))

    # 创建 4x4 矩阵 A
    A = Matrix([[0, -1, -2, 3], [0, -1, -2, 3], [0, 1, 0, -1], [0, 0, -1, 1]])
    # 断言 A 对 exp(x) 函数的解析函数等于 A 的指数函数
    assert A.analytic_func(exp(x), x) == A.exp()
    # 断言 A 对 sqrt(x) 函数抛出 ValueError 异常
    raises(ValueError, lambda : A.analytic_func(sqrt(x), x))

    # 创建 2x2 矩阵 A
    A = Matrix([[41, 12],[12, 34]])
    # 断言 simplify(A 对 sqrt(x) 函数的解析函数的平方) 等于 A
    assert simplify(A.analytic_func(sqrt(x), x)**2) == A

    # 创建 3x3 矩阵 A
    A = Matrix([[3, -12, 4], [-1, 0, -2], [-1, 5, -1]])
    # 断言 simplify(A 对 nthroot(x, 3) 函数的解析函数的立方) 等于 A
    assert simplify(A.analytic_func(nthroot(x, 3), x)**3) == A

    # 创建 4x4 矩阵 A
    A = Matrix([[2, 0, 0, 0], [1, 2, 0, 0], [0, 1, 3, 0], [0, 0, 1, 3]])
    # 断言 A 对 exp(x) 函数的解析函数等于 A 的指数函数
    assert A.analytic_func(exp(x), x) == A.exp()

    # 创建 4x4 矩阵 A
    A = Matrix([[0, 2, 1, 6], [0, 0, 1, 2], [0, 0, 0, 3], [0, 0, 0, 0]])
    # 断言 A 对 exp(x*t) 函数的解析函数等于 A*t 的指数函数的展开和简化结果
    assert A.analytic_func(exp(x*t), x) == expand(simplify((A*t).exp()))

# 根据 pyodide 不支持创建线程的条件，跳过测试函数
@skip_under_pyodide("Cannot create threads under pyodide.")
def test_issue_19809():

    # 内部函数定义
    def f():
        # 断言 _dotprodsimp_state.state 为 None
        assert _dotprodsimp_state.state == None
        # 创建 1x1 矩阵 m，并计算 m 的平方
        m = Matrix([[1]])
        m = m * m
        return True

    # 使用 dotprodsimp(True) 上下文管理器
    with dotprodsimp(True):
        # 使用 ThreadPoolExecutor 创建线程池
        with concurrent.futures.ThreadPoolExecutor() as executor:
            # 提交任务 f 到线程池，并断言任务结果为真
            future = executor.submit(f)
            assert future.result()


# 测试函数，验证 issue 23276 的情况
def test_issue_23276():
    # 创建包含变量 x 和 y 的 Matrix 对象 M
    M = Matrix([x, y])
    # 断言对 M 进行积分，给定 x 和 y 的范围为 [0, 1]，结果等于指定的矩阵
    assert integrate(M, (x, 0, 1), (y, 0, 1)) == Matrix([
        [S.Half],
        [S.Half]])

# SubspaceOnlyMatrix 类的测试函数，测试列空间
def test_columnspace_one():
    # 创建 SubspaceOnlyMatrix 对象 m
    m = SubspaceOnlyMatrix([[ 1,  2,  0,  2,  5],
                            [-2, -5,  1, -1, -8],
                            [ 0, -3,  3,  4,  1],
                            [ 3,  6,  0, -7,  2]])

    # 计算 m 的列空间基
    basis = m.columnspace()
    # 断言列空间的第一个基向量等于指定的矩阵
    assert basis[0] == Matrix([1, -2, 0, 3])
    # 断言列空间的第二个基向量等于指定的矩阵
    assert basis[1] == Matrix([2, -5, -3, 6])
    # 断言列空间的第三个基向量等于指定的矩阵
    assert basis[2] == Matrix([2, -1, 4, -7])

    # 断言列空间基的数量为 3
    assert len(basis) == 3
    # 断言 m 以及列空间的所有基向量组成的矩阵的列空间等于原来的列空间基
    assert Matrix.hstack(m, *basis).columnspace() == basis

# SubspaceOnlyMatrix 类的测试函数，测试行空间
def test_rowspace():
    # 创建 SubspaceOnlyMatrix 对象 m
    m = SubspaceOnlyMatrix([[ 1,  2,  0,  2,  5],
                            [-2, -5,  1, -1, -8],
                            [ 0, -3,  3,  4,  1],
                            [ 3,  6,  0, -7,  2]])

    # 计算 m 的行空间基
    basis = m.rowspace()
    # 断言行空间的第一个基向量等于指定的矩阵
    assert basis[0] == Matrix([[1, 2, 0, 2, 5]])
    # 断言行空间的第二个基向量等于指定的矩阵
    assert basis[1] == Matrix([[0, -1, 1, 3, 2]])
    # 断言行空间的第三个基向量等于指定的矩阵
    assert basis[2] == Matrix([[0, 0, 0, 5,
    # 创建一个特定的子空间矩阵 `m`
    m = SubspaceOnlyMatrix([[ 1,  2,  0,  2,  5],
                            [-2, -5,  1, -1, -8],
                            [ 0, -3,  3,  4,  1],
                            [ 3,  6,  0, -7,  2]])
    
    # 求解矩阵 `m` 的零空间（核空间），即所有使得 `m * x = 0` 成立的向量 `x` 组成的基
    basis = m.nullspace()
    
    # 断言第一个基向量与给定的矩阵 `Matrix([-2, 1, 1, 0, 0])` 相等
    assert basis[0] == Matrix([-2, 1, 1, 0, 0])
    
    # 断言第二个基向量与给定的矩阵 `Matrix([-1, -1, 0, -1, 1])` 相等
    assert basis[1] == Matrix([-1, -1, 0, -1, 1])
    
    # 确保第一个基向量乘以 `m` 后的所有元素都为零
    assert all(e.is_zero for e in m * basis[0])
    
    # 确保第二个基向量乘以 `m` 后的所有元素都为零
    assert all(e.is_zero for e in m * basis[1])
# ReductionsOnlyMatrix tests
def test_row_op():
    e = eye_Reductions(3)

    # 检查异常情况：传入非法的操作字符串
    raises(ValueError, lambda: e.elementary_row_op("abc"))
    # 检查异常情况：未传入任何参数
    raises(ValueError, lambda: e.elementary_row_op())
    # 检查异常情况：行变换中指定的行数超出矩阵范围
    raises(ValueError, lambda: e.elementary_row_op('n->kn', row=5, k=5))
    # 检查异常情况：行变换中指定的行数为负数
    raises(ValueError, lambda: e.elementary_row_op('n->kn', row=-5, k=5))
    # 检查异常情况：交换行操作中指定的行数超出矩阵范围
    raises(ValueError, lambda: e.elementary_row_op('n<->m', row1=1, row2=5))
    # 检查异常情况：交换行操作中指定的行数超出矩阵范围
    raises(ValueError, lambda: e.elementary_row_op('n<->m', row1=5, row2=1))
    # 检查异常情况：交换行操作中指定的行数为负数
    raises(ValueError, lambda: e.elementary_row_op('n<->m', row1=-5, row2=1))
    # 检查异常情况：交换行操作中指定的行数为负数
    raises(ValueError, lambda: e.elementary_row_op('n<->m', row1=1, row2=-5))
    # 检查异常情况：行线性组合操作中指定的行数超出矩阵范围
    raises(ValueError, lambda: e.elementary_row_op('n->n+km', row1=1, row2=5, k=5))
    # 检查异常情况：行线性组合操作中指定的行数超出矩阵范围
    raises(ValueError, lambda: e.elementary_row_op('n->n+km', row1=5, row2=1, k=5))
    # 检查异常情况：行线性组合操作中指定的行数为负数
    raises(ValueError, lambda: e.elementary_row_op('n->n+km', row1=-5, row2=1, k=5))
    # 检查异常情况：行线性组合操作中指定的行数为负数
    raises(ValueError, lambda: e.elementary_row_op('n->n+km', row1=1, row2=-5, k=5))
    # 检查异常情况：行线性组合操作中指定的行数相同
    raises(ValueError, lambda: e.elementary_row_op('n->n+km', row1=1, row2=1, k=5))

    # 测试不同参数设置方式下的行操作功能
    assert e.elementary_row_op("n->kn", 0, 5) == Matrix([[5, 0, 0], [0, 1, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->kn", 1, 5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->kn", row=1, k=5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->kn", row1=1, k=5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_row_op("n<->m", 0, 1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_row_op("n<->m", row1=0, row2=1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_row_op("n<->m", row=0, row2=1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->n+km", 0, 5, 1) == Matrix([[1, 5, 0], [0, 1, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->n+km", row=0, k=5, row2=1) == Matrix([[1, 5, 0], [0, 1, 0], [0, 0, 1]])
    assert e.elementary_row_op("n->n+km", row1=0, k=5, row2=1) == Matrix([[1, 5, 0], [0, 1, 0], [0, 0, 1]])

    # 确保矩阵尺寸不改变的情况
    a = ReductionsOnlyMatrix(2, 3, [0]*6)
    assert a.elementary_row_op("n->kn", 1, 5) == Matrix(2, 3, [0]*6)
    assert a.elementary_row_op("n<->m", 0, 1) == Matrix(2, 3, [0]*6)
    assert a.elementary_row_op("n->n+km", 0, 5, 1) == Matrix(2, 3, [0]*6)


def test_col_op():
    e = eye_Reductions(3)

    # 检查异常情况：传入非法的操作字符串
    raises(ValueError, lambda: e.elementary_col_op("abc"))
    # 检查异常情况：未传入任何参数
    raises(ValueError, lambda: e.elementary_col_op())
    # 检查异常情况：列变换中指定的列数超出矩阵范围
    raises(ValueError, lambda: e.elementary_col_op('n->kn', col=5, k=5))
    # 检查异常情况：列变换中指定的列数为负数
    raises(ValueError, lambda: e.elementary_col_op('n->kn', col=-5, k=5))
    # 检查异常情况：交换列操作中指定的列数超出矩阵范围
    raises(ValueError, lambda: e.elementary_col_op('n<->m', col1=1, col2=5))
    # 检查异常情况：交换列操作中指定的列数超出矩阵范围
    raises(ValueError, lambda: e.elementary_col_op('n<->m', col1=5, col2=1))
    # 检查异常情况：交换列操作中指定的列数为负数
    raises(ValueError, lambda: e.elementary_col_op('n<->m', col1=-5, col2=1))
    # 调用 e 对象的 elementary_col_op 方法，测试不同的参数设置是否会引发 ValueError 异常
    raises(ValueError, lambda: e.elementary_col_op('n<->m', col1=1, col2=-5))
    raises(ValueError, lambda: e.elementary_col_op('n->n+km', col1=1, col2=5, k=5))
    raises(ValueError, lambda: e.elementary_col_op('n->n+km', col1=5, col2=1, k=5))
    raises(ValueError, lambda: e.elementary_col_op('n->n+km', col1=-5, col2=1, k=5))
    raises(ValueError, lambda: e.elementary_col_op('n->n+km', col1=1, col2=-5, k=5))
    raises(ValueError, lambda: e.elementary_col_op('n->n+km', col1=1, col2=1, k=5))

    # 测试 elementary_col_op 方法的不同参数设置，确保返回的 Matrix 对象符合预期
    assert e.elementary_col_op("n->kn", 0, 5) == Matrix([[5, 0, 0], [0, 1, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->kn", 1, 5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->kn", col=1, k=5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->kn", col1=1, k=5) == Matrix([[1, 0, 0], [0, 5, 0], [0, 0, 1]])
    assert e.elementary_col_op("n<->m", 0, 1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_col_op("n<->m", col1=0, col2=1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_col_op("n<->m", col=0, col2=1) == Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->n+km", 0, 5, 1) == Matrix([[1, 0, 0], [5, 1, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->n+km", col=0, k=5, col2=1) == Matrix([[1, 0, 0], [5, 1, 0], [0, 0, 1]])
    assert e.elementary_col_op("n->n+km", col1=0, k=5, col2=1) == Matrix([[1, 0, 0], [5, 1, 0], [0, 0, 1]])

    # 确保 ReductionsOnlyMatrix 对象在进行 elementary_col_op 操作后，矩阵尺寸不变
    a = ReductionsOnlyMatrix(2, 3, [0]*6)
    assert a.elementary_col_op("n->kn", 1, 5) == Matrix(2, 3, [0]*6)
    assert a.elementary_col_op("n<->m", 0, 1) == Matrix(2, 3, [0]*6)
    assert a.elementary_col_op("n->n+km", 0, 5, 1) == Matrix(2, 3, [0]*6)
def test_is_echelon():
    # 创建一个大小为3的零矩阵对象
    zro = zeros_Reductions(3)
    # 创建一个3阶单位矩阵对象
    ident = eye_Reductions(3)

    # 断言零矩阵对象为梯形矩阵
    assert zro.is_echelon
    # 断言单位矩阵对象为梯形矩阵
    assert ident.is_echelon

    # 创建一个0行0列的矩阵对象
    a = ReductionsOnlyMatrix(0, 0, [])
    # 断言该矩阵对象为梯形矩阵
    assert a.is_echelon

    # 创建一个2行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(2, 3, [3, 2, 1, 0, 0, 6])
    # 断言该矩阵对象为梯形矩阵
    assert a.is_echelon

    # 创建一个2行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(2, 3, [0, 0, 6, 3, 2, 1])
    # 断言该矩阵对象不是梯形矩阵
    assert not a.is_echelon

    # 创建一个包含符号'x'的3行1列的矩阵对象
    x = Symbol('x')
    a = ReductionsOnlyMatrix(3, 1, [x, 0, 0])
    # 断言该矩阵对象为梯形矩阵
    assert a.is_echelon

    # 创建一个包含符号'x'的3行1列的矩阵对象
    a = ReductionsOnlyMatrix(3, 1, [x, x, 0])
    # 断言该矩阵对象不是梯形矩阵
    assert not a.is_echelon

    # 创建一个3行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(3, 3, [0, 0, 0, 1, 2, 3, 0, 0, 0])
    # 断言该矩阵对象不是梯形矩阵
    assert not a.is_echelon


def test_echelon_form():
    # 梯形形式可能不唯一，但结果必须与原矩阵在行等价且处于梯形形式

    # 创建一个大小为3的零矩阵对象
    a = zeros_Reductions(3)
    # 创建一个3阶单位矩阵对象
    e = eye_Reductions(3)

    # 断言零矩阵对象的梯形形式等于其自身
    assert a.echelon_form() == a
    # 断言单位矩阵对象的梯形形式等于其自身
    assert e.echelon_form() == e

    # 创建一个0行0列的矩阵对象
    a = ReductionsOnlyMatrix(0, 0, [])
    # 断言该矩阵对象的梯形形式等于其自身
    assert a.echelon_form() == a

    # 创建一个1行1列的矩阵对象，指定数据为5
    a = ReductionsOnlyMatrix(1, 1, [5])
    # 断言该矩阵对象的梯形形式等于其自身
    assert a.echelon_form() == a

    # 创建一个3行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
    # 定义零空间和行向量
    nulls = [Matrix([
                     [ 1],
                     [-2],
                     [ 1]])]
    rows = [a[i, :] for i in range(a.rows)]
    # 获取该矩阵对象的梯形形式
    a_echelon = a.echelon_form()
    # 断言该梯形形式为梯形矩阵
    assert a_echelon.is_echelon
    # 验证零空间和行向量
    verify_row_null_space(a, rows, nulls)

    # 创建一个3行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 8])
    # 定义空零空间
    nulls = []
    rows = [a[i, :] for i in range(a.rows)]
    # 获取该矩阵对象的梯形形式
    a_echelon = a.echelon_form()
    # 断言该梯形形式为梯形矩阵
    assert a_echelon.is_echelon
    # 验证零空间和行向量
    verify_row_null_space(a, rows, nulls)

    # 创建一个3行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(3, 3, [2, 1, 3, 0, 0, 0, 2, 1, 3])
    # 定义非零零空间
    nulls = [Matrix([
             [Rational(-1, 2)],
             [   1],
             [   0]]),
             Matrix([
             [Rational(-3, 2)],
             [   0],
             [   1]])]
    rows = [a[i, :] for i in range(a.rows)]
    # 获取该矩阵对象的梯形形式
    a_echelon = a.echelon_form()
    # 断言该梯形形式为梯形矩阵
    assert a_echelon.is_echelon
    # 验证零空间和行向量
    verify_row_null_space(a, rows, nulls)

    # 创建一个3行3列的矩阵对象，指定数据，需要行交换
    a = ReductionsOnlyMatrix(3, 3, [2, 1, 3, 0, 0, 0, 1, 1, 3])
    # 定义非零零空间
    nulls = [Matrix([
             [   0],
             [  -3],
             [   1]])]
    rows = [a[i, :] for i in range(a.rows)]
    # 获取该矩阵对象的梯形形式
    a_echelon = a.echelon_form()
    # 断言该梯形形式为梯形矩阵
    assert a_echelon.is_echelon
    # 验证零空间和行向量
    verify_row_null_space(a, rows, nulls)

    # 创建一个3行3列的矩阵对象，指定数据
    a = ReductionsOnlyMatrix(3, 3, [0, 3, 3, 0, 2, 2, 0, 1, 1])
    # 定义非零零空间
    nulls = [Matrix([
             [1],
             [0],
             [0]]),
             Matrix([
             [ 0],
             [-1],
             [ 1]])]
    # 从矩阵 a 中按行提取所有行向量，形成列表
    rows = [a[i, :] for i in range(a.rows)]
    # 计算矩阵 a 的阶梯形式
    a_echelon = a.echelon_form()
    # 断言检查计算得到的阶梯形式是否符合阶梯形的定义
    assert a_echelon.is_echelon
    # 验证矩阵 a 的行空间和零空间的关系
    verify_row_null_space(a, rows, nulls)

    # 创建一个 ReductionsOnlyMatrix 对象 a，表示一个 2x3 的矩阵，提供指定数据
    a = ReductionsOnlyMatrix(2, 3, [2, 2, 3, 3, 3, 0])
    # 定义一个包含一个 Matrix 对象的列表，表示零空间的一组向量
    nulls = [Matrix([
             [-1],
             [1],
             [0]])]
    # 从新的矩阵 a 中按行提取所有行向量，形成列表
    rows = [a[i, :] for i in range(a.rows)]
    # 计算新矩阵 a 的阶梯形式
    a_echelon = a.echelon_form()
    # 断言检查计算得到的阶梯形式是否符合阶梯形的定义
    assert a_echelon.is_echelon
    # 验证新矩阵 a 的行空间和零空间的关系
    verify_row_null_space(a, rows, nulls)
# 定义测试函数 test_rref
def test_rref():
    # 创建一个零矩阵 e
    e = ReductionsOnlyMatrix(0, 0, [])
    # 断言零矩阵 e 经过行简化形式操作后仍等于自身
    assert e.rref(pivots=False) == e

    # 创建单元素矩阵 e 和 a
    e = ReductionsOnlyMatrix(1, 1, [1])
    a = ReductionsOnlyMatrix(1, 1, [5])
    # 断言单元素矩阵经过行简化形式操作后都等于矩阵 e 自身
    assert e.rref(pivots=False) == a.rref(pivots=False) == e

    # 创建包含三个元素的列向量矩阵 a
    a = ReductionsOnlyMatrix(3, 1, [1, 2, 3])
    # 断言 a 经过行简化形式操作后得到单位矩阵的第一列
    assert a.rref(pivots=False) == Matrix([[1], [0], [0]])

    # 创建包含三个元素的行向量矩阵 a
    a = ReductionsOnlyMatrix(1, 3, [1, 2, 3])
    # 断言 a 经过行简化形式操作后仍等于矩阵 a 自身
    assert a.rref(pivots=False) == Matrix([[1, 2, 3]])

    # 创建一个 3x3 矩阵 a
    a = ReductionsOnlyMatrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9])
    # 断言 a 经过行简化形式操作后得到特定的行简化阶梯形式矩阵
    assert a.rref(pivots=False) == Matrix([
                                     [1, 0, -1],
                                     [0, 1,  2],
                                     [0, 0,  0]])

    # 创建一个 3x3 矩阵 a，所有元素相同
    a = ReductionsOnlyMatrix(3, 3, [1, 2, 3, 1, 2, 3, 1, 2, 3])
    # 创建特定的零矩阵 b、c、d
    b = ReductionsOnlyMatrix(3, 3, [1, 2, 3, 0, 0, 0, 0, 0, 0])
    c = ReductionsOnlyMatrix(3, 3, [0, 0, 0, 1, 2, 3, 0, 0, 0])
    d = ReductionsOnlyMatrix(3, 3, [0, 0, 0, 0, 0, 0, 1, 2, 3])
    # 断言 a、b、c、d 经过行简化形式操作后都等于零矩阵 b
    assert a.rref(pivots=False) == \
            b.rref(pivots=False) == \
            c.rref(pivots=False) == \
            d.rref(pivots=False) == b

    # 创建单位矩阵 e 和零矩阵 z
    e = eye_Reductions(3)
    z = zeros_Reductions(3)
    # 断言单位矩阵和零矩阵经过行简化形式操作后分别等于自身
    assert e.rref(pivots=False) == e
    assert z.rref(pivots=False) == z

    # 创建特定的 4x7 矩阵 a
    a = ReductionsOnlyMatrix([
            [ 0, 0,  1,  2,  2, -5,  3],
            [-1, 5,  2,  2,  1, -7,  5],
            [ 0, 0, -2, -3, -3,  8, -5],
            [-1, 5,  0, -1, -2,  1,  0]])
    # 对矩阵 a 进行行简化形式操作，得到简化矩阵 mat 和主元偏移 pivot_offsets
    mat, pivot_offsets = a.rref()
    # 断言 mat 和 pivot_offsets 的值符合预期
    assert mat == Matrix([
                     [1, -5, 0, 0, 1,  1, -1],
                     [0,  0, 1, 0, 0, -1,  1],
                     [0,  0, 0, 1, 1, -2,  1],
                     [0,  0, 0, 0, 0,  0,  0]])
    assert pivot_offsets == (0, 2, 3)

    # 创建包含有理数的 4x4 矩阵 a
    a = ReductionsOnlyMatrix([[Rational(1, 19),  Rational(1, 5),    2,    3],
                        [   4,    5,    6,    7],
                        [   8,    9,   10,   11],
                        [  12,   13,   14,   15]])
    # 断言 a 经过行简化形式操作后得到特定的简化矩阵
    assert a.rref(pivots=False) == Matrix([
                                         [1, 0, 0, Rational(-76, 157)],
                                         [0, 1, 0,  Rational(-5, 157)],
                                         [0, 0, 1, Rational(238, 157)],
                                         [0, 0, 0,       0]])

    # 创建包含符号的 2x3 矩阵 a
    x = Symbol('x')
    a = ReductionsOnlyMatrix(2, 3, [x, 1, 1, sqrt(x), x, 1])
    # 遍历 a 经过行简化形式操作后的每一行，并与预期的结果进行比较
    for i, j in zip(a.rref(pivots=False),
            [1, 0, sqrt(x)*(-x + 1)/(-x**Rational(5, 2) + x),
                0, 1, 1/(sqrt(x) + x + 1)]):
        # 断言简化后的结果与预期的符号化简结果相等
        assert simplify(i - j).is_zero


# 定义测试函数 test_rref_rhs
def test_rref_rhs():
    # 定义符号变量 a, b, c, d
    a, b, c, d = symbols('a b c d')
    # 创建 4x2 矩阵 A 和 4x1 矩阵 B
    A = Matrix([[0, 0], [0, 0], [1, 2], [3, 4]])
    B = Matrix([a, b, c, d])
    # 断言 A 经过右手边简化形式操作后得到特定的简化矩阵
    assert A.rref_rhs(B) == (Matrix([
    [1, 0],
    [0, 1],
    [0, 0],
    [0, 0]]), Matrix([
    [   -2*c + d],
    [3*c/2 - d/2],
    [          a],
    [          b]]))


# 定义测试函数 test_issue_17827
def test_issue_17827():
    # 这个函数暂时没有实现，只是定义了一个空的函数体
    pass
    # 创建一个 6x4 的矩阵 C，表示一个包含有理数的矩阵
    C = Matrix([
        [3, 4, -1, 1],
        [9, 12, -3, 3],
        [0, 2, 1, 3],
        [2, 3, 0, -2],
        [0, 3, 3, -5],
        [8, 15, 0, 6]
    ])
    # 对行操作的测试，确保行和列在有效范围内
    D = C.elementary_row_op('n<->m', row1=2, row2=5)
    # 对行操作的测试，将第5行的元素乘以-4加到第3行
    E = C.elementary_row_op('n->n+km', row1=5, row2=3, k=-4)
    # 对行操作的测试，将第5行的元素乘以2
    F = C.elementary_row_op('n->kn', row=5, k=2)
    # 断言：确保行操作的结果符合预期
    assert(D[5, :] == Matrix([[0, 2, 1, 3]]))
    assert(E[5, :] == Matrix([[0, 3, 0, 14]]))
    assert(F[5, :] == Matrix([[16, 30, 0, 12]]))
    # 对行和列超出范围的情况进行测试，应该引发 ValueError 异常
    raises(ValueError, lambda: C.elementary_row_op('n<->m', row1=2, row2=6))
    raises(ValueError, lambda: C.elementary_row_op('n->kn', row=7, k=2))
    raises(ValueError, lambda: C.elementary_row_op('n->n+km', row1=-1, row2=5, k=2))
# 定义一个函数用于测试矩阵的秩
def test_rank():
    # 创建一个2x2的矩阵对象m，包含具体值和符号x
    m = Matrix([[1, 2], [x, 1 - 1/x]])
    # 断言矩阵m的秩为2
    assert m.rank() == 2
    # 创建一个3x3的矩阵对象n，包含数值1到9
    n = Matrix(3, 3, range(1, 10))
    # 断言矩阵n的秩为2
    assert n.rank() == 2
    # 创建一个3x1的零矩阵对象p
    p = zeros(3)
    # 断言矩阵p的秩为0
    assert p.rank() == 0

# 定义一个函数用于测试特定问题的矩阵M的秩
def test_issue_11434():
    # 定义符号变量
    ax, ay, bx, by, cx, cy, dx, dy, ex, ey, t0, t1 = \
        symbols('a_x a_y b_x b_y c_x c_y d_x d_y e_x e_y t_0 t_1')
    # 创建一个5x5的矩阵对象M，包含符号变量和表达式
    M = Matrix([[ax, ay, ax*t0, ay*t0, 0],
                [bx, by, bx*t0, by*t0, 0],
                [cx, cy, cx*t0, cy*t0, 1],
                [dx, dy, dx*t0, dy*t0, 1],
                [ex, ey, 2*ex*t1 - ex*t0, 2*ey*t1 - ey*t0, 0]])
    # 断言矩阵M的秩为4
    assert M.rank() == 4

# 定义一个函数用于测试从Stack Overflow问题反馈的矩阵A的秩
def test_rank_regression_from_so():
    # 定义符号变量
    nu, lamb = symbols('nu, lambda')
    # 创建一个4x4的矩阵对象A，包含符号变量和表达式
    A = Matrix([[-3*nu,         1,                  0,  0],
                [ 3*nu, -2*nu - 1,                  2,  0],
                [    0,      2*nu, (-1*nu) - lamb - 2,  3],
                [    0,         0,          nu + lamb, -3]])
    # 预期的行简化阶梯形矩阵
    expected_reduced = Matrix([[1, 0, 0, 1/(nu**2*(-lamb - nu))],
                               [0, 1, 0,    3/(nu*(-lamb - nu))],
                               [0, 0, 1,         3/(-lamb - nu)],
                               [0, 0, 0,                      0]])
    # 预期的主元位置元组
    expected_pivots = (0, 1, 2)

    # 对矩阵A进行行简化阶梯形操作
    reduced, pivots = A.rref()

    # 断言简化后的矩阵与预期的简化矩阵相差零
    assert simplify(expected_reduced - reduced) == zeros(*A.shape)
    # 断言计算得到的主元位置与预期的主元位置相符
    assert pivots == expected_pivots

# 定义一个函数用于测试特定问题的矩阵A和其幂次的秩
def test_issue_15872():
    # 创建一个4x4的矩阵对象A，包含具体值
    A = Matrix([[1, 1, 1, 0], [-2, -1, 0, -1], [0, 0, -1, -1], [0, 0, 2, 1]])
    # 构造一个新的矩阵B，其为A与单位矩阵乘积的差
    B = A - Matrix.eye(4) * I
    # 断言矩阵B的秩为3
    assert B.rank() == 3
    # 断言矩阵B的平方的秩为2
    assert (B**2).rank() == 2
    # 断言矩阵B的立方的秩为2
    assert (B**3).rank() == 2
```