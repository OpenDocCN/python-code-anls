# `D:\src\scipysrc\sympy\sympy\parsing\autolev\_build_autolev_antlr.py`

```
# 导入必要的模块
import os  # 导入操作系统接口模块
import subprocess  # 导入子进程管理模块
import glob  # 导入文件名模式匹配模块

from sympy.utilities.misc import debug  # 从 sympy.utilities.misc 模块导入 debug 函数

# 获取当前脚本文件所在目录路径
here = os.path.dirname(__file__)
# 构建语法文件的绝对路径
grammar_file = os.path.abspath(os.path.join(here, "Autolev.g4"))
# 设置存放 ANTLR 生成代码的目录路径
dir_autolev_antlr = os.path.join(here, "_antlr")

# 头部信息，包含自动生成警告和版权声明
header = '''\
# *** GENERATED BY `setup.py antlr`, DO NOT EDIT BY HAND ***
#
# Generated with antlr4
#    antlr4 is licensed under the BSD-3-Clause License
#    https://github.com/antlr/antlr4/blob/master/LICENSE.txt
'''


def check_antlr_version():
    debug("Checking antlr4 version...")  # 输出调试信息：检查 antlr4 版本

    try:
        # 尝试执行 `antlr4` 命令并获取输出的第一行作为版本信息
        debug(subprocess.check_output(["antlr4"])
              .decode('utf-8').split("\n")[0])
        return True  # 如果成功，返回 True
    except (subprocess.CalledProcessError, FileNotFoundError):
        # 如果执行 `antlr4` 命令失败或未找到，输出错误信息并返回 False
        debug("The 'antlr4' command line tool is not installed, "
              "or not on your PATH.\n"
              "> Please refer to the README.md file for more information.")
        return False


def build_parser(output_dir=dir_autolev_antlr):
    check_antlr_version()  # 检查 ANTLR 版本

    debug("Updating ANTLR-generated code in {}".format(output_dir))  # 输出调试信息：更新生成的代码位置

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)  # 如果目录不存在，则创建目录

    with open(os.path.join(output_dir, "__init__.py"), "w+") as fp:
        fp.write(header)  # 将头部信息写入 __init__.py 文件

    args = [
        "antlr4",  # ANTLR 工具命令
        grammar_file,  # 语法文件路径
        "-o", output_dir,  # 输出目录
        "-no-visitor",  # 不生成 visitor 相关代码
    ]

    debug("Running code generation...\n\t$ {}".format(" ".join(args)))  # 输出调试信息：运行代码生成命令
    subprocess.check_output(args, cwd=output_dir)  # 在指定目录中运行 ANTLR 命令

    debug("Applying headers, removing unnecessary files and renaming...")
    # 处理不区分大小写的文件系统。如果文件已生成，则会写入 autolev*，但 Autolev*.* 不会匹配它们。
    for path in (glob.glob(os.path.join(output_dir, "Autolev*.*")) or
                 glob.glob(os.path.join(output_dir, "autolev*.*"))):

        # 删除不需要的 .interp 或 .tokens 结尾的文件
        if not path.endswith(".py"):
            os.unlink(path)
            continue

        # 将文件名转换为小写，并修改 import 语句中的 AutolevParser 为 autolevparser
        new_path = os.path.join(output_dir, os.path.basename(path).lower())
        with open(path, 'r') as f:
            # 处理每一行：去除末尾空白字符并替换 import 语句
            lines = [line.rstrip().replace('AutolevParser import', 'autolevparser import') + '\n'
                     for line in f.readlines()]

        os.unlink(path)  # 删除原文件

        with open(new_path, "w") as out_file:
            offset = 0
            while lines[offset].startswith('#'):
                offset += 1
            out_file.write(header)  # 写入头部信息
            out_file.writelines(lines[offset:])  # 写入处理过的代码行

        debug("\t{}".format(new_path))  # 输出调试信息：处理完成的文件路径

    return True  # 返回 True 表示构建成功


if __name__ == "__main__":
    build_parser()  # 如果作为主程序运行，则执行构建解析器的函数
```