# `D:\src\scipysrc\sympy\sympy\simplify\ratsimp.py`

```
# 从 itertools 模块导入 combinations_with_replacement 函数
from itertools import combinations_with_replacement
# 从 sympy.core 模块导入 symbols, Add, Dummy
from sympy.core import symbols, Add, Dummy
# 从 sympy.core.numbers 模块导入 Rational
from sympy.core.numbers import Rational
# 从 sympy.polys 模块导入 cancel, ComputationFailed, parallel_poly_from_expr, reduced, Poly
from sympy.polys import cancel, ComputationFailed, parallel_poly_from_expr, reduced, Poly
# 从 sympy.polys.monomials 模块导入 Monomial, monomial_div
from sympy.polys.monomials import Monomial, monomial_div
# 从 sympy.polys.polyerrors 模块导入 DomainError, PolificationFailed
from sympy.polys.polyerrors import DomainError, PolificationFailed
# 从 sympy.utilities.misc 模块导入 debug, debugf
from sympy.utilities.misc import debug, debugf

# 定义函数 ratsimp，对表达式进行通分、约分和化简
def ratsimp(expr):
    """
    Put an expression over a common denominator, cancel and reduce.

    Examples
    ========

    >>> from sympy import ratsimp
    >>> from sympy.abc import x, y
    >>> ratsimp(1/x + 1/y)
    (x + y)/(x*y)
    """

    # 对表达式 expr 进行通分并得到分子和分母
    f, g = cancel(expr).as_numer_denom()
    try:
        # 尝试使用给定的 Groebner 基 G 对分子 f 进行有限域上的约简
        Q, r = reduced(f, [g], field=True, expand=False)
    except ComputationFailed:
        # 如果约简失败则返回原始表达式
        return f/g

    # 返回化简后的结果
    return Add(*Q) + cancel(r/g)


# 定义函数 ratsimpmodprime，对有理表达式 expr 在素理想 G 生成的模空间中进行化简
def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):
    """
    Simplifies a rational expression ``expr`` modulo the prime ideal
    generated by ``G``.  ``G`` should be a Groebner basis of the
    ideal.

    Examples
    ========

    >>> from sympy.simplify.ratsimp import ratsimpmodprime
    >>> from sympy.abc import x, y
    >>> eq = (x + y**5 + y)/(x - y)
    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')
    (-x**2 - x*y - x - y)/(-x**2 + x*y)

    If ``polynomial`` is ``False``, the algorithm computes a rational
    simplification which minimizes the sum of the total degrees of
    the numerator and the denominator.

    If ``polynomial`` is ``True``, this function just brings numerator and
    denominator into a canonical form. This is much faster, but has
    potentially worse results.

    References
    ==========

    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial
        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809
        (specifically, the second algorithm)
    """
    # 从 sympy.solvers.solvers 模块导入 solve 函数
    from sympy.solvers.solvers import solve

    # 打印调试信息 'ratsimpmodprime' 和表达式 expr
    debug('ratsimpmodprime', expr)

    # 对表达式 expr 进行通分并得到分子和分母
    num, denom = cancel(expr).as_numer_denom()

    try:
        # 尝试使用给定的生成器 gens 和参数 args 将表达式转换为多项式列表
        polys, opt = parallel_poly_from_expr([num, denom] + G, *gens, **args)
    except PolificationFailed:
        # 如果转换失败则返回原始表达式
        return expr

    # 获取多项式的定义域
    domain = opt.domain

    # 如果定义域有关联字段则将 opt.domain 设置为该字段
    if domain.has_assoc_Field:
        opt.domain = domain.get_field()
    else:
        # 否则抛出域错误异常
        raise DomainError(
            "Cannot compute rational simplification over %s" % domain)

    # 返回已计算的结果
    leading_monomials = [g.LM(opt.order) for g in polys[2:]]
    tested = set()
    # 定义一个函数 `staircase`，用于计算所有次数小于 `n` 的单项式，这些单项式不能被 `leading_monomials` 中任何元素整除。
    def staircase(n):
        """
        Compute all monomials with degree less than ``n`` that are
        not divisible by any element of ``leading_monomials``.
        """
        
        # 如果 n 等于 0，则返回单项式列表中只有常数项 1
        if n == 0:
            return [1]
        
        # 初始化一个空列表 S，用于存储符合条件的单项式
        S = []
        
        # 使用 itertools 库的 `combinations_with_replacement` 函数生成所有元素不超过 `len(opt.gens)` 的长度为 `n` 的组合
        for mi in combinations_with_replacement(range(len(opt.gens)), n):
            # 初始化一个长度为 `len(opt.gens)` 的列表 m，用于记录每个生成器的次数
            m = [0]*len(opt.gens)
            
            # 根据生成的组合 mi 更新 m 列表中对应位置的次数
            for i in mi:
                m[i] += 1
            
            # 检查 m 是否不能被 leading_monomials 中的任何元素整除
            if all(monomial_div(m, lmg) is None for lmg in leading_monomials):
                S.append(m)  # 将符合条件的 m 加入到列表 S 中
        
        # 返回 S 中每个 m 转换为 Monomial 对象后的表达式列表，同时递归调用 staircase 函数计算次数小于 n-1 的单项式并合并结果
        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)

    # 预处理步骤，当 num 和 denom 的次数较大时，能稍微提高性能：
    num = reduced(num, G, opt.gens, order=opt.order)[1]  # 对 num 进行约化处理
    denom = reduced(denom, G, opt.gens, order=opt.order)[1]  # 对 denom 进行约化处理

    # 如果 polynomial 为真，则返回 num/denom 的约分结果
    if polynomial:
        return (num/denom).cancel()

    # 否则，使用 _ratsimpmodprime 函数进行有理函数简化，并获取结果 c, d, allsol
    c, d, allsol = _ratsimpmodprime(
        Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])

    # 如果 quick 不为真且 allsol 不为空，则寻找最佳的最小解决方案
    if not quick and allsol:
        debugf('Looking for best minimal solution. Got: %s', len(allsol))
        newsol = []
        for c_hat, d_hat, S, ng in allsol:
            # 使用 solve 函数解决 S，ng 的特定解，quick 为假
            sol = solve(S, ng, particular=True, quick=False)
            # 检查 sol 中所有值是否为数字，若不是则 solve 函数出错
            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))
        # 选择具有最少项数的 c 和 d
        c, d = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))

    # 如果 domain 不是一个 Field，则对 c 和 d 进行分母消除处理，并将结果转换为有理数 Rational 对象
    if not domain.is_Field:
        cn, c = c.clear_denoms(convert=True)
        dn, d = d.clear_denoms(convert=True)
        r = Rational(cn, dn)
    else:
        r = Rational(1)  # 否则，r 设置为有理数 1

    # 返回最终结果，即 (c * r.q) / (d * r.p)
    return (c*r.q)/(d*r.p)
```