# `D:\src\scipysrc\sympy\sympy\polys\matrices\tests\test_rref.py`

```
# 导入 sympy 库中的特定模块和类
from sympy import ZZ, QQ, EX, Matrix, eye, zeros, symbols
# 导入 sympy.polys.matrices 包中的 DomainMatrix 和相关方法
from sympy.polys.matrices import DM, DomainMatrix
# 导入 sympy.polys.matrices.dense 包中的稠密矩阵相关方法
from sympy.polys.matrices.dense import ddm_irref_den, ddm_irref
# 导入 sympy.polys.matrices.ddm 和 sympy.polys.matrices.sdm 包中的稀疏矩阵相关方法
from sympy.polys.matrices.ddm import DDM
from sympy.polys.matrices.sdm import SDM, sdm_irref, sdm_rref_den

# 导入 pytest 库，用于单元测试
import pytest


# 下面是一些关于 rref_den 方法的说明：
#
# 稠密和稀疏矩阵的 rref_den 方法分别为 ddm_irref_den 和 sdm_irref_den。
# 它们可能由于某些因素得出不同的结果，并且如果行的顺序改变，也会得到不同的结果。
# 下面的测试用例展示了这些方法返回的结果都应当是通过 cancel_denom 转换成最简形式的结果。
#
# EX 域也是一个特例，其中稠密和稀疏实现可能给出不同形式的结果：它们应当是等价的，但由于 EX 没有
# 规范的形式，它们不是规范形式。
#

# 定义符号变量 a, b, c, d
a, b, c, d = symbols('a, b, c, d')

# 定义一个大型的有理数域稠密矩阵 qq_large_1
qq_large_1 = DM([
    [(1,2),  (1,3),  (1,5),  (1,7), (1,11), (1,13), (1,17), (1,19), (1,23), (1,29), (1,31)],
    [(1,37), (1,41), (1,43), (1,47), (1,53), (1,59), (1,61), (1,67), (1,71), (1,73), (1,79)],
    [(1,83), (1,89), (1,97),(1,101),(1,103),(1,107),(1,109),(1,113),(1,127),(1,131),(1,137)],
    [(1,139),(1,149),(1,151),(1,157),(1,163),(1,167),(1,173),(1,179),(1,181),(1,191),(1,193)],
    [(1,197),(1,199),(1,211),(1,223),(1,227),(1,229),(1,233),(1,239),(1,241),(1,251),(1,257)],
    [(1,263),(1,269),(1,271),(1,277),(1,281),(1,283),(1,293),(1,307),(1,311),(1,313),(1,317)],
    [(1,331),(1,337),(1,347),(1,349),(1,353),(1,359),(1,367),(1,373),(1,379),(1,383),(1,389)],
    [(1,397),(1,401),(1,409),(1,419),(1,421),(1,431),(1,433),(1,439),(1,443),(1,449),(1,457)],
    [(1,461),(1,463),(1,467),(1,479),(1,487),(1,491),(1,499),(1,503),(1,509),(1,521),(1,523)],
    [(1,541),(1,547),(1,557),(1,563),(1,569),(1,571),(1,577),(1,587),(1,593),(1,599),(1,601)],
    [(1,607),(1,613),(1,617),(1,619),(1,631),(1,641),(1,643),(1,647),(1,653),(1,659),(1,661)]
], QQ)

# 在 qq_large_1 的基础上加上一个非常大的单位矩阵，形成 qq_large_2
qq_large_2 = qq_large_1 + 10**100 * DomainMatrix.eye(11, QQ)

# 定义 RREF_EXAMPLES 列表，包含了多个 rref 方法的测试例子
RREF_EXAMPLES = [
    (
        'zz_1',
         DM([[1, 2, 3]], ZZ),
         DM([[1, 2, 3]], ZZ),
         ZZ(1),
    ),

    (
        'zz_2',
         DomainMatrix([], (0, 0), ZZ),
         DomainMatrix([], (0, 0), ZZ),
         ZZ(1),
    ),

    (
        'zz_3',
        DM([[1, 2],
            [3, 4]], ZZ),
        DM([[1, 0],
            [0, 1]], ZZ),
        ZZ(1),
    ),

    (
        'zz_4',
        DM([[1, 0],
            [3, 4]], ZZ),
        DM([[1, 0],
            [0, 1]], ZZ),
        ZZ(1),
    ),

    (
        'zz_5',
        DM([[0, 2],
            [3, 4]], ZZ),
        DM([[1, 0],
            [0, 1]], ZZ),
        ZZ(1),
    ),

    (
        'zz_6',
        DM([[1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]], ZZ),
        DM([[1, 0, -1],
            [0, 1,  2],
            [0, 0,  0]], ZZ),
        ZZ(1),
    ),
    (
        'zz_7',  # 第一个元组，标识为 'zz_7'
        DM([[0, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 0],
            [1, 0, 0]], ZZ),
        DM([[1, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 0],
            [0, 0, 0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_8',  # 第二个元组，标识为 'zz_8'
        DM([[0, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 0],
            [0, 0, 0]], ZZ),
        DM([[0, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 0],
            [0, 0, 0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_9',  # 第三个元组，标识为 'zz_9'
        DM([[1, 1, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 2],
            [0, 0, 0]], ZZ),
        DM([[1, 1, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 1],
            [0, 0, 0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_10',  # 第四个元组，标识为 'zz_10'
        DM([[2, 2, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 2],
            [0, 0, 0]], ZZ),
        DM([[1, 1, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 0, 1],
            [0, 0, 0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_11',  # 第五个元组，标识为 'zz_11'
        DM([[2, 2, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 2, 2],
            [0, 0, 2]], ZZ),
        DM([[1, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 1, 0],
            [0, 0, 1]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_12',  # 第六个元组，标识为 'zz_12'
        DM([[ 1,  2,  3],  # 密集矩阵定义，元素为 ZZ 类型
            [ 4,  5,  6],
            [ 7,  8,  9],
            [10, 11, 12]], ZZ),
        DM([[1,  0, -1],  # 密集矩阵定义，元素为 ZZ 类型
            [0,  1,  2],
            [0,  0,  0],
            [0,  0,  0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_13',  # 第七个元组，标识为 'zz_13'
        DM([[ 1,  2,  3],  # 密集矩阵定义，元素为 ZZ 类型
            [ 4,  5,  6],
            [ 7,  8,  9],
            [10, 11, 13]], ZZ),
        DM([[ 1,  0,  0],  # 密集矩阵定义，元素为 ZZ 类型
            [ 0,  1,  0],
            [ 0,  0,  1],
            [ 0,  0,  0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_14',  # 第八个元组，标识为 'zz_14'
        DM([[1, 2,  4, 3],  # 密集矩阵定义，元素为 ZZ 类型
            [4, 5, 10, 6],
            [7, 8, 16, 9]], ZZ),
        DM([[1, 0, 0, -1],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 1, 2,  2],
            [0, 0, 0,  0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_15',  # 第九个元组，标识为 'zz_15'
        DM([[1, 2,  4, 3],  # 密集矩阵定义，元素为 ZZ 类型
            [4, 5, 10, 6],
            [7, 8, 17, 9]], ZZ),
        DM([[1, 0, 0, -1],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 1, 0,  2],
            [0, 0, 1,  0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_16',  # 第十个元组，标识为 'zz_16'
        DM([[1, 2, 0, 1],  # 密集矩阵定义，元素为 ZZ 类型
            [1, 1, 9, 0]], ZZ),
        DM([[1, 0, 18, -1],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 1, -9,  1]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        'zz_17',  # 第十一个元组，标识为 'zz_17'
        DM([[1, 1, 1],  # 密集矩阵定义，元素为 ZZ 类型
            [1, 2, 2]], ZZ),
        DM([[1, 0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [0, 1, 1]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        # 在这里，稀疏实现和密集实现具有非常不同的分母：4061232 和 -1765176。
        'zz_18',  # 第十二个元组，标识为 'zz_18'
        DM([[94, 24,  0, 27, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [79,  0,  0,  0, 0],
            [85, 16, 71, 81, 0],
            [ 0,  0, 72, 77, 0],
            [21,  0, 34,  0, 0]], ZZ),
        DM([[ 1,  0,  0,  0, 0],  # 密集矩阵定义，元素为 ZZ 类型
            [ 0,  1,  0,  0, 0],
            [ 0,  0,  1,  0, 0],
            [ 0,  0,  0,  1, 0],
            [ 0,  0,  0,  0, 0]], ZZ),
        ZZ(1),  # 整数类型对象
    ),

    (
        # 让我们有一个不能被取消的分母。
        'zz_19',  # 第十三个元组，标识为 'zz_19'
        DM([[1, 2, 4],
    (
        'zz_20',  # 第一个元组的标识符
        DM([[0, 0, 0, 0, 0],  # 第一个矩阵的定义
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 4]], ZZ),  # 第一个矩阵的值及其类型
        DM([[0, 0, 0, 0, 1],  # 第二个矩阵的定义
            [0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0]], ZZ),  # 第二个矩阵的值及其类型
        ZZ(1),  # 第三个对象的值及其类型
    ),

    (
        'zz_21',  # 第二个元组的标识符
        DM([[0, 0, 0, 0, 0, 1, 0, 0, 0, 0],  # 第一个矩阵的定义
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 1]], ZZ),  # 第一个矩阵的值及其类型
        DM([[1, 0, 0, 0, 0, 0, 1, 0, 0, 0],  # 第二个矩阵的定义
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]], ZZ),  # 第二个矩阵的值及其类型
        ZZ(1),  # 第三个对象的值及其类型
    ),

    (
        'zz_22',  # 第三个元组的标识符
        DM([[1, 1, 1, 0, 1],  # 第一个矩阵的定义
            [1, 1, 0, 1, 0],
            [1, 0, 1, 0, 1],
            [1, 1, 0, 1, 0],
            [1, 0, 0, 0, 0]], ZZ),  # 第一个矩阵的值及其类型
        DM([[1, 0, 0, 0, 0],  # 第二个矩阵的定义
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 1],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0]], ZZ),  # 第二个矩阵的值及其类型
        ZZ(1),  # 第三个对象的值及其类型
    ),

    (
        'zz_large_1',  # 第四个元组的标识符
        DM([  # 第一个矩阵的定义（此处省略部分）
# 定义一个二维列表，包含多个内部列表，每个内部列表都包含20个整数元素
[
# 第一个内部列表
[ 0,  0,  0, 81,  0,  0, 75,  0,  0,  0,  0,  0,  0, 27,  0,  0,  0,  0,  0,  0],
# 第二个内部列表
[ 0,  0,  0,  0,  0, 86,  0, 92, 79, 54,  0,  7,  0,  0,  0,  0, 79,  0,  0,  0],
# 第三个内部列表
[89, 54, 81,  0,  0, 20,  0,  0,  0,  0,  0,  0, 51,  0, 94,  0,  0, 77,  0,  0],
# 第四个内部列表
[ 0,  0,  0, 96,  0,  0,  0,  0,  0,  0,  0,  0, 48, 29,  0,  0,  5,  0, 32,  0],
# 第五个内部列表
[ 0, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 60,  0,  0,  0, 11],
# 第六个内部列表
[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37,  0, 43,  0,  0],
# 第七个内部列表
[ 0,  0,  0,  0,  0, 38, 91,  0,  0,  0,  ```
# 第七个内部列表（续）
[ 0,  0,  0,  0, 38,  0,  0,  0,  0,  0, 26,  0,  0, 69,  0,  0,  0,  0,  0, 55],
# 第八个内部列表
[ 0, 13, 18, 49, 49, 88,  0,  0, 35, 54,  0,  0, 51,  0,  0,  0,  0,  0,  0, 87],
# 第九个内部列表
[ 0,  0,  0,  0, 31,  0, 40,  0,  0,  0,  0,  0,  0, 50,  0,  0,  0,  0, 88,  0],
# 第十个内部列表
[ 0,  0,  0,  0,  0,  0,  0,  0, 98,  0,  0,  0, 15, 53,  0, 92,  0,  0,  0,  0],
# 第十一个内部列表
[ 0,  0,  0, 95,  0,  0,  0, 36,  0,  0,  0,  0,  0, 72,  0,  0,  0,  0, 73, 19],
# 第十二个内部列表
[ 0, 65, 14, 96,  0,  0,  0,  0,  0,  0,  0,  0,  0, 90,  0,  0,  0, 34,  0,  0],
# 第十三个内部列表
[ 0,  0,  0, 16, 39, 44,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0,  0],
# 第十四个内部列表
[ 0, 17,  ```
# 第十四个内部列表（续）
0,  0,  0,  0, 99, 84, 13, 50, 84,  0,  0,  0,  0, 95,  0, 43, 33, 20,  0],
# 第十五个内部列表
[79,  0, 17, 52, 99, 12, 69,  0, 98,  0, 68,  0,  0,  0,  0,  0,  0,  0,  0,  0],
# 第十六个内部列表
[ 0,  0,  0, 82,  0, 44,  0,  0,  0, 97,  0,  0,  0,  0,  0, 10,  0,  0, 31,  0],
# 第十七个内部列表
[ 0,  0, 21,  0, 67,  0,  0,  0,  0,  0,  4,  0, 50,  0,  0,  0, 33,  0,  0,  0],
# 第十八个内部列表
[ 0,  0,  0,  0,  9, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8]
]
    (
        'zz_large_2',  # 定义元组的第一个元素，表示数据集的名称
        DM([  # 创建一个矩阵对象，矩阵的每一行是一个列表
            [ 0,  0,  0,  0, 50,  0,  6, 81,  0,  1, 86,  0,  0, 98, 82, 94,  4,  0,  0, 29],  # 第一行数据
            [ 0, 44, 43,  0, 62,  0,  0,  0, 60,  0,  0,  0,  0, 71,  9,  0, 57, 41,  0, 93],  # 第二行数据
            [ 0,  0, 28,  0, 74, 89, 42,  0, 28,  0,  6,  0,  0,  0, 44,  0,  0,  0, 77, 19],  # 第三行数据
            [ 0, 21, 82,  0, 30, 88,  0, 89, 68,  0,  0,  0, 79, 41,  0,  0, 99,  0,  0,  0],  # 第四行数据
            [31,  0,  0,  0, 19, 64,  0,  0, 79,  0,  5,  0, 72, 10, 60, 32, 64, 59,  0, 24],  # 第五行数据
            [ 0,  0,  0,  0,  0, 57,  0, 94,  0, 83, 20,  0,  0,  9, 31,  0, 49, 26, 58,  0],  # 第六行数据
            [ 0, 65, 56, 31, 64,  0,  0,  0,  0,  0,  0, 52, 85,  0,  0,  0,  0, 51,  0,  0],  # 第七行数据
            [ 0, 35,  0,  0,  0, 69,  0,  0, 64,  0,  0,  0,  0, 70,  0,  0, 90,  0, 75, 76],  # 第八行数据
            [69,  7,  0, 90,  0,  0, 84,  0, 47, 69, 19, 20, 42,  0,  0, 32, 71, 35,  0,  0],  # 第九行数据
            [39,  0, 90,  ```
0,  0,  0,  0,  0,  4, 85,  0,  0, 55,  0,  0,  0, 35, 67, 40,  0, 40,  0, 77],  # 第十行数据
[98, 63,  0, 71,  0, 50,  0,  2, 61,  0, 38,  0,  0,  0,  0, 75,  0, 40, 33, 56],  # 第十一行数据
[ 0, 73,  0, 64,  0, 38,  0, 35, 61,  0,  0, 52,  0,  7,  0, 51,  0,  0,  0, 34],  # 第十二行数据
[ 0,  0, 28,  0, 34,  5, 63, 45, 14, 42, 60, 16, 76, 54, 99,  0, 28, 30,  0,  0],  # 第十三行数据
[58, 37, 14,  0,  0,  0, 94,  0,  0, 90,  0,  0,  0,  0,  0,  0,  0,  8, 90, 53],  # 第十四行数据
[86, 74, 94,  0, 49, 10, 60,  0, 40, 18,  0,  0,  0, 31, 60, 24,  0,  1,  0, 29],  # 第十五行数据
[53,  0,  0, 97,  0,  0, 58,  0,  0, 39, 44, 47,  0,  0,  0, 12, 50,  0,  0, 11],  # 第十六行数据
[
[ 4,  0, 92, 10, 28,  0,  0, 89,  0,  0, 18, 54, 23, 39,  0,  2,  0, 48,  0, 92],
# 第一个列表，包含20个整数值，每个值之间用逗号分隔
[ 0,  0, 90, 77, 95, 33,  0,  0, 49, 22, 39,  0,  0,  0,  0,  0,  0, 40,  0,  0],
# 第二个列表，包含20个整数值，每个值之间用逗号分隔
[96,  0,  0,  0,  0, 38, 86,  0, 22, 76,  0,  0,  0,  0, 83, 88, 95, 65, 72,  0],
# 第三个列表，包含20个整数值，每个值之间用逗号分隔
[81, 65,  0,  4, 60,  0, 19,  0,  0, 68,  0,  0, 89,  0, 67, 22,  0,  0, 55, 33]],
# 第四个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
           ZZ),
# ZZ对象，可能是一个变量名或类名，后面跟着一个右括号
        DM([
# DM对象，可能是一个变量名或类名，后面跟着一个左方括号
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第一个列表，包含20个整数值，每个值之间用逗号分隔
[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第二个列表，包含20个整数值，每个值之间用逗号分隔
[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第三个列表，包含20个整数值，每个值之间用逗号分隔
[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第四个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第五个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第六个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第七个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第八个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第九个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第十个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# 第十一个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
# 第十二个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
# 第十三个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
# 第十四个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
# 第十五个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
# 第十六个列表，包含20个整数值，每个值之间用逗号分隔，后面跟着两个方括号
[0, 0, 0, 0,
# 创建一个包含两个列表的矩阵，每个列表是包含整数的行
[
    [32,62,47,80,51,66,17,1,9,30,65,75,75,88,99,92,64,53,53,86,38,51,41,14,35,18,39,25,26,32],
    [39,21,8,16,33,6,35,85,75,62,43,34,18,68,71,28,32,18,12,0,81,53,1,99,3,5,45,99,35,33],
    [19,95,89,45,75,94,92,5,84,93,34,17,50,56,79,98,68,82,65,81,51,90,5,95,33,71,46,61,14,7],
    [53,92,8,49,67,84,21,79,49,95,66,48,36,14,62,97,26,45,58,31,83,48,11,89,67,72,91,34,56,89],
    [56,76,99,92,40,8,0,16,15,48,35,72,91,46,81,14,86,60,51,7,33,12,53,78,48,21,3,89,15,79],
    [81,43,33,49,6,49,36,32,57,74,87,91,17,37,31,17,67,1,40,38,69,8,3,48,59,37,64,97,11,3],
    [98,48,77,16,2,48,57,38,63,59,79,35,16,71,60,86,71,41,14,76,80,97,77,69,4,58,22,55,26,73],
    [80,47,78,44,31,48,47,29,29,62,19,21,17,24,19,3,53,93,97,57,13,54,12,10,77,66,60,75,32,21],
    [86,63,2,13,71,38,86,23,18,15,91,65,77,65,9,92,50,0,17,42,99,80,99,27,10,99,92,9,87,84],
    [66,27,72,13,13,15,72,75,39,3,14,71,15,68,10,19,49,54,11,29,47,20,63,13,97,47,24,62,16,96],
    [42,63,83,60,49,68,9,53,75,87,40,25,12,63,0,12,0,95,46,46,55,25,89,1,51,1,1,96,80,52],
    [35,9,97,13,86,39,66,48,41,57,23,38,11,9,35,72,88,13,41,60,10,64,71,23,1,5,23,57,6,19],
    [70,61,5,50,72,60,77,13,41,94,1,45,52,22,99,47,27,18,99,42,16,48,26,9,88,77,10,94,11,92],
    [55,68,58,2,72,56,81,52,79,37,1,40,21,46,27,60,37,13,97,42,85,98,69,60,76,44,42,46,29,73],
    [73,0,43,17,89,97,45,2,68,14,55,60,95,2,74,85,88,68,93,76,38,76,2,51,45,76,50,79,56,18],
    [72,58,41,39,24,80,23,79,44,7,98,75,30,6,85,60,20,58,77,71,90,51,38,80,30,15,33,10,82,8]
]
    (
        # 创建一个元组，包含多个元素
        [eye(29) * 2028539767964472550625641331179545072876560857886207583101,
         Matrix([ 4260575808093245475167216057435155595594339172099000182569,
                  169148395880755256182802335904188369274227936894862744452,
                  4915975976683942569102447281579134986891620721539038348914,
                  6113916866367364958834844982578214901958429746875633283248,
                  5585689617819894460378537031623265659753379011388162534838,
                  359776822829880747716695359574308645968094838905181892423,
                  -2800926112141776386671436511182421432449325232461665113305,
                  941642292388230001722444876624818265766384442910688463158,
                  3648811843256146649321864698600908938933015862008642023935,
                  -4104526163246702252932955226754097174212129127510547462419,
                  -704814955438106792441896903238080197619233342348191408078,
                  1640882266829725529929398131287244562048075707575030019335,
                  -4068330845192910563212155694231438198040299927120544468520,
                  136589038308366497790495711534532612862715724187671166593,
                  2544937011460702462290799932536905731142196510605191645593,
                  755591839174293940486133926192300657264122907519174116472,
                  -3683838489869297144348089243628436188645897133242795965021,
                  -522207137101161299969706310062775465103537953077871128403,
                  -2260451796032703984456606059649402832441331339246756656334,
                  -6476809325293587953616004856993300606040336446656916663680,
                  3521944238996782387785653800944972787867472610035040989081,
                  2270762115788407950241944504104975551914297395787473242379,
                  -3259947194628712441902262570532921252128444706733549251156,
                  -5624569821491886970999097239695637132075823246850431083557,
                  -3262698255682055804320585332902837076064075936601504555698,
                  5786719943788937667411185880136324396357603606944869545501,
                  -955257841973865996077323863289453200904051299086000660036,
                  -1294235552446355326174641248209752679127075717918392702116,
                  -3718353510747301598130831152458342785269166356215331448279,
                 ]),],
        # 创建一个元组，包含两个元素，每个元素是一个矩阵
        [zeros(1, 29), zeros(1, 1)],
        # 调用链式方法 to_DM().to_dense()，将数据转换成密集型矩阵
        ]).to_DM().to_dense(),
        # 创建一个有理数对象，使用给定的整数作为分子和分母
        ZZ(2028539767964472550625641331179545072876560857886207583101),
    ),

    (
        # 元组中的第一个元素名称
        'qq_1',
        # 创建一个有理数域上的矩阵对象，参数为一个元组，元组中包含两个矩阵
        DM([[(1,2), 0], [0, 2]], QQ),
        # 创建一个有理数域上的矩阵对象，参数为一个二维列表
        DM([[1, 0], [0, 1]], QQ),
        # 创建一个有理数对象，值为整数 1
        QQ(1),
    ),

    (
        # 元组中的第一个元素名称
        'qq_2',
        # 创建一个有理数域上的矩阵对象，参数为一个二维列表
        DM([[0, 1],
            [1, 1]], QQ),
        # 创建一个有理数域上的矩阵对象，参数为一个二维列表
        DM([[1, 0],
            [0, 1]], QQ),
        # 创建一个有理数对象，值为整数 1
        QQ(1),
    ),

    (
        # 元组中的第一个元素名称
        'qq_3',
        # 创建一个有理数域上的矩阵对象，参数为一个二维列表
        DM([[1, 2, 1],
            [3, 4, 1]], QQ),
        # 创建一个有理数域上的矩阵对象，参数为一个二维列表
        DM([[1, 0, -1],
            [0, 1,  1]], QQ),
        # 创建一个有理数对象，值为整数 1
        QQ(1),
    ),
    (
        # 同样是 m < n 但是顺序相反的情况
        'qq_4',
        DM([[3, 4, 1],
            [1, 2, 1]], QQ),
        DM([[1, 0, -1],
            [0, 1,  1]], QQ),
        QQ(1),
    ),

    (
        # m > n 的情况
        'qq_5',
        DM([[1, 0],
            [1, 3],
            [0, 1]], QQ),
        DM([[1, 0],
            [0, 1],
            [0, 0]], QQ),
        QQ(1),
    ),

    (
        # 存在缺失主元的例子
        'qq_6',
        DM([[1, 0, 1],
            [3, 0, 1]], QQ),
        DM([[1, 0, 0],
            [0, 0, 1]], QQ),
        QQ(1),
    ),

    (
        # 该示例意在触发阈值，放弃清除分母的情况。
        'qq_large_1',
        qq_large_1,
        DomainMatrix.eye(11, QQ).to_dense(),
        QQ(1),
    ),

    (
        # 该示例意在触发阈值，在 QQ 上使用 rref_den 的情况。
        'qq_large_2',
        qq_large_2,
        DomainMatrix.eye(11, QQ).to_dense(),
        QQ(1),
    ),

    (
        # 存在缺失主元且无替换的例子

        # 这个例子足以展示算法的稠密版本和稀疏版本有不同的结果：
        #
        #   >>> A = Matrix([[0, 1], [0, 2], [1, 0]])
        #   >>> A.to_DM().to_sparse().rref_den()[0].to_Matrix()
        #   Matrix([
        #   [1, 0],
        #   [0, 1],
        #   [0, 0]])
        #   >>> A.to_DM().to_dense().rref_den()[0].to_Matrix()
        #   Matrix([
        #   [2, 0],
        #   [0, 2],
        #   [0, 0]])
        #
        'qq_7',
        DM([[0, 1],
            [0, 2],
            [1, 0]], QQ),
        DM([[1, 0],
            [0, 1],
            [0, 0]], QQ),
        QQ(1),
    ),

    (
        # 高斯整数的例子
        'zz_i_1',
        DM([[(0,1), 1, 1],
            [    1, 1, 1]], ZZ_I),
        DM([[1, 0, 0],
            [0, 1, 1]], ZZ_I),
        ZZ_I(1),
    ),

    (
        # EX: 测试问题 23718
        'EX_1',
        DM([
        [a, b, 1],
        [c, d, 1]], EX),
        DM([[a*d - b*c,         0, -b + d],
            [        0, a*d - b*c,  a - c]], EX),
        EX(a*d - b*c),
    ),
# 导入 pytest 模块，用于编写和运行测试用例
import pytest


def _to_DM(A, ans):
    """将答案转换为 DomainMatrix 类型。"""
    if isinstance(A, DomainMatrix):
        return A.to_dense()
    elif isinstance(A, Matrix):
        return A.to_DM(ans.domain).to_dense()

    # 如果 A 没有 shape 和 domain 属性，则使用 ans 的 shape 和 domain
    if not (hasattr(A, 'shape') and hasattr(A, 'domain')):
        shape, domain = ans.shape, ans.domain
    else:
        shape, domain = A.shape, A.domain

    # 根据 A 的类型进行转换成 DomainMatrix 类型并转换为稠密表示
    if isinstance(A, (DDM, list)):
        return DomainMatrix(list(A), shape, domain).to_dense()
    elif isinstance(A, (SDM, dict)):
        return DomainMatrix(dict(A), shape, domain).to_dense()
    else:
        assert False  # 如果出现未知类型，则断言错误


def _pivots(A_rref):
    """从 A 的行简化阶梯形式 (rref) 中返回主元组成的元组。"""
    return tuple(sorted(map(min, A_rref.to_sdm().values())))


def _check_cancel(result, rref_ans, den_ans):
    """检查取消操作后的结果。"""
    rref, den, pivots = result
    if isinstance(rref, (DDM, SDM, list, dict)):
        assert type(pivots) is list
        pivots = tuple(pivots)

    # 将 rref 转换为与 rref_ans 相同类型的 DomainMatrix，然后进行分母取消操作
    rref = _to_DM(rref, rref_ans)
    rref2, den2 = rref.cancel_denom(den)

    # 断言取消操作后的结果是否符合预期
    assert rref2 == rref_ans
    assert den2 == den_ans
    assert pivots == _pivots(rref)


def _check_divide(result, rref_ans, den_ans):
    """检查除法操作后的结果。"""
    rref, pivots = result
    if isinstance(rref, (DDM, SDM, list, dict)):
        assert type(pivots) is list
        pivots = tuple(pivots)

    # 将 rref 转换为与 rref_ans 相同类型的 DomainMatrix，然后进行除法操作
    rref_ans = rref_ans.to_field() / den_ans
    rref = _to_DM(rref, rref_ans)

    # 断言除法操作后的结果是否符合预期
    assert rref == rref_ans
    assert _pivots(rref) == pivots


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_Matrix_rref(name, A, A_rref, den):
    """测试 Matrix 类的行简化阶梯形式 (rref) 方法。"""
    K = A.domain
    A = A.to_Matrix()
    A_rref_found, pivots = A.rref()

    # 如果 K 是 EX 类型，则展开 A_rref_found
    if K.is_EX:
        A_rref_found = A_rref_found.expand()

    # 检查除法操作后的结果是否符合预期
    _check_divide((A_rref_found, pivots), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_dense_rref(name, A, A_rref, den):
    """测试 DomainMatrix 稠密表示的行简化阶梯形式 (rref) 方法。"""
    A = A.to_field()
    _check_divide(A.rref(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_dense_rref_den(name, A, A_rref, den):
    """测试 DomainMatrix 稠密表示的分母取消操作。"""
    _check_cancel(A.rref_den(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_sparse_rref(name, A, A_rref, den):
    """测试 DomainMatrix 稀疏表示的行简化阶梯形式 (rref) 方法。"""
    A = A.to_field().to_sparse()
    _check_divide(A.rref(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_sparse_rref_den(name, A, A_rref, den):
    """测试 DomainMatrix 稀疏表示的分母取消操作。"""
    A = A.to_sparse()
    _check_cancel(A.rref_den(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_sparse_rref_den_keep_domain(name, A, A_rref, den):
    """测试 DomainMatrix 稀疏表示的分母取消操作，保持域的情况。"""
    A = A.to_sparse()
    A_rref_f, den_f, pivots_f = A.rref_den(keep_domain=False)
    A_rref_f = A_rref_f.to_field() / den_f
    _check_divide((A_rref_f, pivots_f), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
def test_dm_sparse_rref_den_keep_domain_CD(name, A, A_rref, den):
    """测试 DomainMatrix 稀疏表示的分母取消操作，保持域的情况 (CD)。"""
    A = A.to_sparse()
    # 对矩阵 A 进行行简化阶梯形式处理，返回简化阶梯形矩阵 A_rref_f、分母 den_f 和主元 pivots_f
    A_rref_f, den_f, pivots_f = A.rref_den(keep_domain=False, method='CD')
    
    # 将简化阶梯形矩阵 A_rref_f 转换为域上的元素，然后除以分母 den_f，得到最终的简化阶梯形矩阵 A_rref_f
    A_rref_f = A_rref_f.to_field() / den_f
    
    # 检查除法结果 (A_rref_f, pivots_f) 是否与期望的简化阶梯形矩阵 A_rref 相符，以及分母 den 是否有效
    _check_divide((A_rref_f, pivots_f), A_rref, den)
# 使用 pytest 模块的 mark.parametrize 装饰器，参数化测试函数，根据给定的 RREF_EXAMPLES 参数执行多次测试
@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_dm_sparse_rref_den_keep_domain_GJ，接受参数 name, A, A_rref, den
def test_dm_sparse_rref_den_keep_domain_GJ(name, A, A_rref, den):
    # 将 A 转换为稀疏格式
    A = A.to_sparse()
    # 调用 A 的 rref_den 方法，不保留域，使用 'GJ' 方法进行行简化阶梯形
    A_rref_f, den_f, pivots_f = A.rref_den(keep_domain=False, method='GJ')
    # 将 A_rref_f 转换为域的字段表示，并除以 den_f
    A_rref_f = A_rref_f.to_field() / den_f
    # 调用辅助函数 _check_divide 检查结果 (A_rref_f, pivots_f) 是否等于期望的 (A_rref, den)
    _check_divide((A_rref_f, pivots_f), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_ddm_rref_den，接受参数 name, A, A_rref, den
def test_ddm_rref_den(name, A, A_rref, den):
    # 将 A 转换为密集矩阵格式
    A = A.to_ddm()
    # 调用辅助函数 _check_cancel 检查 A 的 rref_den 方法的结果是否等于期望的 (A_rref, den)
    _check_cancel(A.rref_den(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_sdm_rref_den，接受参数 name, A, A_rref, den
def test_sdm_rref_den(name, A, A_rref, den):
    # 将 A 转换为对称稀疏矩阵格式
    A = A.to_sdm()
    # 调用辅助函数 _check_cancel 检查 A 的 rref_den 方法的结果是否等于期望的 (A_rref, den)
    _check_cancel(A.rref_den(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_ddm_rref，接受参数 name, A, A_rref, den
def test_ddm_rref(name, A, A_rref, den):
    # 将 A 转换为域的字段表示，再转换为密集矩阵格式
    A = A.to_field().to_ddm()
    # 调用辅助函数 _check_divide 检查 A 的 rref 方法的结果是否等于期望的 (A_rref, den)
    _check_divide(A.rref(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_sdm_rref，接受参数 name, A, A_rref, den
def test_sdm_rref(name, A, A_rref, den):
    # 将 A 转换为域的字段表示，再转换为对称稀疏矩阵格式
    A = A.to_field().to_sdm()
    # 调用辅助函数 _check_divide 检查 A 的 rref 方法的结果是否等于期望的 (A_rref, den)
    _check_divide(A.rref(), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_ddm_irref，接受参数 name, A, A_rref, den
def test_ddm_irref(name, A, A_rref, den):
    # 将 A 转换为域的字段表示，再转换为密集矩阵格式，创建副本
    A = A.to_field().to_ddm().copy()
    # 调用 ddm_irref 函数，返回 A 的不可简化形式的主元位置
    pivots_found = ddm_irref(A)
    # 调用辅助函数 _check_divide 检查结果 (A, pivots_found) 是否等于期望的 (A_rref, den)
    _check_divide((A, pivots_found), A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_ddm_irref_den，接受参数 name, A, A_rref, den
def test_ddm_irref_den(name, A, A_rref, den):
    # 将 A 转换为密集矩阵格式，创建副本
    A = A.to_ddm().copy()
    # 调用 ddm_irref_den 函数，返回 A 的不可简化形式的主元位置和其定义域
    (den_found, pivots_found) = ddm_irref_den(A, A.domain)
    # 组装结果元组
    result = (A, den_found, pivots_found)
    # 调用辅助函数 _check_cancel 检查 result 是否等于期望的 (A_rref, den)
    _check_cancel(result, A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_sparse_sdm_rref，接受参数 name, A, A_rref, den
def test_sparse_sdm_rref(name, A, A_rref, den):
    # 将 A 转换为域的字段表示，再转换为对称稀疏矩阵格式
    A = A.to_field().to_sdm()
    # 调用辅助函数 _check_divide 检查 sdm_irref 函数的结果 (前两个元素) 是否等于期望的 (A_rref, den)
    _check_divide(sdm_irref(A)[:2], A_rref, den)


@pytest.mark.parametrize('name, A, A_rref, den', RREF_EXAMPLES)
# 定义测试函数 test_sparse_sdm_rref_den，接受参数 name, A, A_rref, den
def test_sparse_sdm_rref_den(name, A, A_rref, den):
    # 将 A 转换为对称稀疏矩阵格式，创建副本
    A = A.to_sdm().copy()
    # 获取 A 的定义域
    K = A.domain
    # 调用辅助函数 _check_cancel 检查 sdm_rref_den 函数的结果是否等于期望的 (A_rref, den)
    _check_cancel(sdm_rref_den(A, K), A_rref, den)
```