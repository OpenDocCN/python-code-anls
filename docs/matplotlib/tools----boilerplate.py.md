# `D:\src\scipysrc\matplotlib\tools\boilerplate.py`

```py
"""
Script to autogenerate pyplot wrappers.

When this script is run, the current contents of pyplot are
split into generatable and non-generatable content (via the magic header
:attr:`PYPLOT_MAGIC_HEADER`) and the generatable content is overwritten.
Hence, the non-generatable content should be edited in the pyplot.py file
itself, whereas the generatable content must be edited via templates in
this file.
"""

# Although it is possible to dynamically generate the pyplot functions at
# runtime with the proper signatures, a static pyplot.py is simpler for static
# analysis tools to parse.

# 导入必要的库和模块
import ast                     # 用于抽象语法树分析的模块
from enum import Enum          # 枚举类型的支持
import functools              # 函数工具模块
import inspect                # 获取对象信息的模块
from inspect import Parameter # 参数对象
from pathlib import Path      # 操作文件和目录路径的模块
import sys                    # 系统相关的功能
import subprocess             # 启动子进程并与其通信的模块


# This line imports the installed copy of matplotlib, and not the local copy.
# 导入安装的 matplotlib 库，而不是本地的副本
import numpy as np            # 数值计算库
from matplotlib import _api, mlab  # matplotlib 的一些核心模块
from matplotlib.axes import Axes   # 图形的轴对象
from matplotlib.backend_bases import MouseButton  # 鼠标按钮枚举类型
from matplotlib.figure import Figure  # 图形对象


# we need to define a custom str because py310 change
# In Python 3.10 the repr and str representation of Enums changed from
#
#  str: 'ClassName.NAME' -> 'NAME'
#  repr: '<ClassName.NAME: value>' -> 'ClassName.NAME'
#
# which is more consistent with what str/repr should do, however this breaks
# boilerplate which needs to get the ClassName.NAME version in all versions of
# Python. Thus, we locally monkey patch our preferred str representation in
# here.
#
# bpo-40066
# https://github.com/python/cpython/pull/22392/
# 定义自定义的 str 方法，用于兼容 Python 3.10 枚举类的修改
def enum_str_back_compat_patch(self):
    return f'{type(self).__name__}.{self.name}'

# only monkey patch if we have to.
# 只有在必要时才进行 monkey patch
if str(MouseButton.LEFT) != 'MouseButton.Left':
    MouseButton.__str__ = enum_str_back_compat_patch


# This is the magic line that must exist in pyplot, after which the boilerplate
# content will be appended.
# 这是在 pyplot 中必须存在的魔法行，此行之后的内容将被附加上去
PYPLOT_MAGIC_HEADER = (
    "################# REMAINING CONTENT GENERATED BY boilerplate.py "
    "##############\n")

AUTOGEN_MSG = """

# Autogenerated by boilerplate.py.  Do not edit as changes will be lost."""

# 定义 Axes 对象的可映射方法的模板字符串
AXES_CMAPPABLE_METHOD_TEMPLATE = AUTOGEN_MSG + """
@_copy_docstring_and_deprecators(Axes.{called_name})
def {name}{signature}:
    __ret = gca().{called_name}{call}
    {sci_command}
    return __ret
"""

# 定义 Axes 对象的方法的模板字符串
AXES_METHOD_TEMPLATE = AUTOGEN_MSG + """
@_copy_docstring_and_deprecators(Axes.{called_name})
def {name}{signature}:
    {return_statement}gca().{called_name}{call}
"""

# 定义 Figure 对象的方法的模板字符串
FIGURE_METHOD_TEMPLATE = AUTOGEN_MSG + """
@_copy_docstring_and_deprecators(Figure.{called_name})
def {name}{signature}:
    {return_statement}gcf().{called_name}{call}
"""

# 定义 colormap 函数的模板字符串
CMAP_TEMPLATE = '''
def {name}() -> None:
    """
    Set the colormap to {name!r}.

    This changes the default colormap as well as the colormap of the current
    image if there is one. See ``help(colormaps)`` for more information.
    """
    set_cmap({name!r})
'''  # Colormap functions.

# 定义值格式化器类
class value_formatter:
    """
    Format function default values as needed for inspect.formatargspec.
    The interesting part is a hard-coded list of functions used
    as defaults in pyplot methods.
    """

    # 初始化函数，接收一个值作为参数
    def __init__(self, value):
        # 检查传入的值是否为 mlab.detrend_none 函数
        if value is mlab.detrend_none:
            # 如果是，则设置表示字符串为 "mlab.detrend_none"
            self._repr = "mlab.detrend_none"
        # 检查传入的值是否为 mlab.window_hanning 函数
        elif value is mlab.window_hanning:
            # 如果是，则设置表示字符串为 "mlab.window_hanning"
            self._repr = "mlab.window_hanning"
        # 检查传入的值是否为 np.mean 函数
        elif value is np.mean:
            # 如果是，则设置表示字符串为 "np.mean"
            self._repr = "np.mean"
        # 检查传入的值是否为 _api.deprecation._deprecated_parameter 函数
        elif value is _api.deprecation._deprecated_parameter:
            # 如果是，则设置表示字符串为 "_api.deprecation._deprecated_parameter"
            self._repr = "_api.deprecation._deprecated_parameter"
        # 检查传入的值是否为枚举类型
        elif isinstance(value, Enum):
            # 如果是枚举类型，则将其转换为字符串赋值给表示字符串
            # 枚举类型的字符串形式为 Class.Name，而其表示形式为 <Class.Name: value>
            self._repr = str(value)
        else:
            # 否则，使用 repr() 函数获取传入值的字符串表示形式
            self._repr = repr(value)

    # 返回对象的表示字符串形式
    def __repr__(self):
        return self._repr
    """
    A placeholder class to destringify annotations from ast
    """
    # 定义一个占位类，用于从 ast 中去字符串化的注释
    def __init__(self, value):
        self._repr = value

    # 返回该类实例的字符串表示形式
    def __repr__(self):
        return self._repr


def generate_function(name, called_fullname, template, **kwargs):
    """
    Create a wrapper function *pyplot_name* calling *call_name*.

    Parameters
    ----------
    name : str
        The function to be created.
    called_fullname : str
        The method to be wrapped in the format ``"Class.method"``.
    template : str
        The template to be used. The template must contain {}-style format
        placeholders. The following placeholders are filled in:

        - name: The function name.
        - signature: The function signature (including parentheses).
        - called_name: The name of the called function.
        - call: Parameters passed to *called_name* (including parentheses).

    **kwargs
        Additional parameters are passed to ``template.format()``.
    """
    # 根据 called_fullname 解析类名和方法名
    class_name, called_name = called_fullname.split('.')
    # 根据类名选择正确的类对象（Axes 或 Figure）
    class_ = {'Axes': Axes, 'Figure': Figure}[class_name]

    # 获取指定类中对应方法的引用
    meth = getattr(class_, called_name)
    # 获取方法的装饰器信息
    decorator = _api.deprecation.DECORATORS.get(meth)
    
    # 生成包装函数的主要签名，将可能的装饰器去除，使其能被 make_keyword_only 重新装饰
    if decorator and decorator.func is _api.make_keyword_only:
        meth = meth.__wrapped__

    # 获取方法在类继承体系中的 AST 树
    annotated_trees = get_ast_mro_trees(class_)
    # 获取方法的匹配签名
    signature = get_matching_signature(meth, annotated_trees)

    # 替换签名中的 self 参数
    params = list(signature.parameters.values())[1:]
    has_return_value = str(signature.return_annotation) != 'None'
    # 将参数的默认值转换成适当的格式字符串
    signature = str(signature.replace(parameters=[
        param.replace(default=value_formatter(param.default))
        if param.default is not param.empty else param
        for param in params]))
    # 调用被包装函数的方式
    # 构建函数调用的字符串表示，包括参数的格式化
    call = '(' + ', '.join((
           # 根据参数类型和默认值，选择合适的参数格式
           '{0}'  # 位置或关键字参数，无默认值
           if param.kind in [
               Parameter.POSITIONAL_OR_KEYWORD]
              and param.default is Parameter.empty else
           # 如果有数据参数且设置了值，则以关键字参数形式传递
           '**({{"data": data}} if data is not None else {{}})'
           if param.name == "data" else
           '{0}={0}'  # 位置或关键字参数，有默认值
           if param.kind in [
               Parameter.POSITIONAL_OR_KEYWORD,
               Parameter.KEYWORD_ONLY] else
           '{0}'  # 仅限位置参数
           if param.kind is Parameter.POSITIONAL_ONLY else
           '*{0}'  # 可变位置参数（*args）
           if param.kind is Parameter.VAR_POSITIONAL else
           '**{0}'  # 可变关键字参数（**kwargs）
           if param.kind is Parameter.VAR_KEYWORD else
           None).format(param.name)
       for param in params) + ')'

    # 根据是否有返回值，构建返回语句的字符串表示
    return_statement = 'return ' if has_return_value else ''

    # 检查参数中是否存在保留的名称，如果有，则引发 ValueError 异常
    for reserved in ('gca', 'gci', 'gcf', '__ret'):
        if reserved in params:
            raise ValueError(
                f'Method {called_fullname} has kwarg named {reserved}')

    # 使用给定的模板格式化函数的调用字符串和其它参数，生成最终的字符串表示
    return template.format(
        name=name,
        called_name=called_name,
        signature=signature,
        call=call,
        return_statement=return_statement,
        **kwargs)
def boilerplate_gen():
    """生成pyplot自动生成部分的行生成器。"""

    # 这些方法都是对应Axes方法的简单封装。
    _figure_commands = (
        'figimage',              # 添加图像到图形
        'figtext:text',          # 在图形中添加文本
        'gca',                   # 获取当前坐标轴
        'gci:_gci',              # 获取当前图像
        'ginput',                # 获取用户输入
        'subplots_adjust',       # 调整子图布局
        'suptitle',              # 设置图形标题
        'tight_layout',          # 调整子图参数以填充布局
        'waitforbuttonpress',    # 等待按钮按下
    )

    # 这些方法都是对应Axes方法的简单封装。
    _axes_commands = (
        'acorr',                 # 绘制自相关图
        'angle_spectrum',        # 绘制角谱
        'annotate',              # 在图上添加注释
        'arrow',                 # 绘制箭头
        'autoscale',             # 自动缩放轴范围
        'axhline',               # 添加水平线
        'axhspan',               # 添加水平色块
        'axis',                  # 设置轴限
        'axline',                # 添加轴线
        'axvline',               # 添加垂直线
        'axvspan',               # 添加垂直色块
        'bar',                   # 绘制条形图
        'barbs',                 # 绘制风羽图
        'barh',                  # 绘制水平条形图
        'bar_label',             # 添加条形图标签
        'boxplot',               # 绘制箱线图
        'broken_barh',           # 绘制中断水平条形图
        'clabel',                # 添加等高线标签
        'cohere',                # 绘制相干性图
        'contour',               # 绘制等高线图
        'contourf',              # 绘制填充等高线图
        'csd',                   # 绘制交叉谱密度图
        'ecdf',                  # 绘制经验累积分布函数
        'errorbar',              # 绘制误差条形图
        'eventplot',             # 绘制事件图
        'fill',                  # 绘制填充曲线
        'fill_between',          # 填充两条曲线之间的区域
        'fill_betweenx',         # 填充两条水平曲线之间的区域
        'grid',                  # 显示网格
        'hexbin',                # 绘制六边形图
        'hist',                  # 绘制直方图
        'stairs',                # 绘制阶梯线图
        'hist2d',                # 绘制二维直方图
        'hlines',                # 绘制水平线
        'imshow',                # 显示图像
        'legend',                # 设置图例
        'locator_params',        # 设置刻度定位器参数
        'loglog',                # 绘制对数-对数图
        'magnitude_spectrum',    # 绘制幅度谱
        'margins',               # 设置图的边距
        'minorticks_off',        # 关闭次刻度
        'minorticks_on',         # 打开次刻度
        'pcolor',                # 绘制伪彩色图
        'pcolormesh',            # 绘制伪彩色网格
        'phase_spectrum',        # 绘制相位谱
        'pie',                   # 绘制饼图
        'plot',                  # 绘制线条
        'plot_date',             # 绘制日期线条
        'psd',                   # 绘制功率谱密度图
        'quiver',                # 绘制矢量图
        'quiverkey',             # 绘制矢量图例
        'scatter',               # 绘制散点图
        'semilogx',              # 绘制半对数-x图
        'semilogy',              # 绘制半对数-y图
        'specgram',              # 绘制谱图
        'spy',                   # 绘制稀疏矩阵
        'stackplot',             # 绘制堆叠图
        'stem',                  # 绘制柴火图
        'step',                  # 绘制阶梯图
        'streamplot',            # 绘制流线图
        'table',                 # 添加表格
        'text',                  # 添加文本
        'tick_params',           # 设置刻度参数
        'ticklabel_format',      # 设置刻度标签格式
        'tricontour',            # 绘制三角形等高线图
        'tricontourf',           # 绘制填充的三角形等高线图
        'tripcolor',             # 绘制三角形伪彩色图
        'triplot',               # 绘制三角图
        'violinplot',            # 绘制小提琴图
        'vlines',                # 绘制垂直线
        'xcorr',                 # 绘制互相关图
        # pyplot名称：真实方法名
        'sci:_sci',              # 设置科学计数器
        'title:set_title',       # 设置图标题
        'xlabel:set_xlabel',     # 设置x轴标签
        'ylabel:set_ylabel',     # 设置y轴标签
        'xscale:set_xscale',     # 设置x轴刻度
        'yscale:set_yscale',     # 设置y轴刻度
    )
    cmappable = {
        'contour': (
            'if __ret._A is not None:  # type: ignore[attr-defined]\n'
            '        sci(__ret)'
        ),
        'contourf': (
            'if __ret._A is not None:  # type: ignore[attr-defined]\n'
            '        sci(__ret)'
        ),
        'hexbin': 'sci(__ret)',
        'scatter': 'sci(__ret)',
        'pcolor': 'sci(__ret)',
        'pcolormesh': 'sci(__ret)',
        'hist2d': 'sci(__ret[-1])',
        'imshow': 'sci(__ret)',
        'spy': 'if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa',
        'quiver': 'sci(__ret)',
        'specgram': 'sci(__ret[-1])',
        'streamplot': 'sci(__ret.lines)',
        'tricontour': (
            'if __ret._A is not None:  # type: ignore[attr-defined]\n'
            '        sci(__ret)'
        ),
        'tricontourf': (
            'if __ret._A is not None:  # type: ignore[attr-defined]\n'
            '        sci(__ret)'
        ),
        'tripcolor': 'sci(__ret)',
    }


    # 定义一个字典 cmappable，包含不同图形类型到对应科学计数法函数的映射关系

    for spec in _figure_commands:
        # 遍历 _figure_commands 列表中的每个元素
        if ':' in spec:
            # 如果 spec 中包含冒号
            name, called_name = spec.split(':')
        else:
            # 如果 spec 中没有冒号，则两者相同
            name = called_name = spec
        # 调用 generate_function 函数，生成 Figure 对象的特定方法，并使用 FIGURE_METHOD_TEMPLATE 模板
        yield generate_function(name, f'Figure.{called_name}', FIGURE_METHOD_TEMPLATE)

    for spec in _axes_commands:
        # 遍历 _axes_commands 列表中的每个元素
        if ':' in spec:
            # 如果 spec 中包含冒号
            name, called_name = spec.split(':')
        else:
            # 如果 spec 中没有冒号，则两者相同
            name = called_name = spec

        # 根据图形类型选择合适的模板：如果在 cmappable 中则使用 AXES_CMAPPABLE_METHOD_TEMPLATE，否则使用 AXES_METHOD_TEMPLATE
        template = (AXES_CMAPPABLE_METHOD_TEMPLATE if name in cmappable else
                    AXES_METHOD_TEMPLATE)
        # 调用 generate_function 函数，生成 Axes 对象的特定方法，并使用相应的模板
        yield generate_function(name, f'Axes.{called_name}', template,
                                sci_command=cmappable.get(name))

    cmaps = (
        'autumn',
        'bone',
        'cool',
        'copper',
        'flag',
        'gray',
        'hot',
        'hsv',
        'jet',
        'pink',
        'prism',
        'spring',
        'summer',
        'winter',
        'magma',
        'inferno',
        'plasma',
        'viridis',
        "nipy_spectral"
    )
    # 遍历颜色映射名称列表 cmaps
    # 添加所有的颜色映射（例如 autumn, hsv, ...）
    for name in cmaps:
        # 生成自动化消息的 yield
        yield AUTOGEN_MSG
        # 使用 CMAP_TEMPLATE 格式化当前颜色映射的消息，并生成 yield
        yield CMAP_TEMPLATE.format(name=name)
# 从指定路径读取 matplotlib.pyplot 文件的内容并按行分割，保留行尾的换行符
pyplot_orig = pyplot_path.read_text().splitlines(keepends=True)

try:
    # 尝试找到并截取包含特定标头（PYPLOT_MAGIC_HEADER）的部分
    pyplot_orig = pyplot_orig[:pyplot_orig.index(PYPLOT_MAGIC_HEADER) + 1]
except IndexError as err:
    # 如果找不到特定标头，则抛出异常并提示错误信息
    raise ValueError('The pyplot.py file *must* have the exact line: %s' % PYPLOT_MAGIC_HEADER) from err

# 使用写模式打开 pyplot_path 文件，并将原始内容写入文件
with pyplot_path.open('w') as pyplot:
    pyplot.writelines(pyplot_orig)  # 写入截取后的内容
    pyplot.writelines(boilerplate_gen())  # 写入生成的模板代码

# 运行 black 工具自动格式化 pyplot 文件
subprocess.run(
    [sys.executable, "-m", "black", "--line-length=88", pyplot_path],
    check=True
)



# 从给定类获取源文件路径，并尝试找到对应的 .pyi 文件，若不存在则使用 .py 文件
path = Path(inspect.getfile(cls))
stubpath = path.with_suffix(".pyi")
path = stubpath if stubpath.exists() else path

# 解析文件内容为抽象语法树（AST）
tree = ast.parse(path.read_text())

# 遍历 AST 中的每个顶级元素，寻找类定义（ClassDef），并匹配给定的类名
for item in tree.body:
    if isinstance(item, ast.ClassDef) and item.name == cls.__name__:
        return item  # 找到则返回该类的 AST 节点

# 若未找到对应类名的节点，则抛出 ValueError 异常
raise ValueError(f"Cannot find {cls.__name__} in ast")



# 使用 functools.lru_cache 装饰器缓存结果，加快后续对同一参数的调用速度
@functools.lru_cache
def get_ast_mro_trees(cls):
    # 返回所有在类的方法解析树中找到的 AST 节点列表
    return [get_ast_tree(c) for c in cls.__mro__ if c.__module__ != "builtins"]



# 获取指定方法的签名对象，用于后续分析和更新
sig = inspect.signature(method)

# 遍历所有给定的 AST 树（trees），查找与方法名称匹配的函数定义（FunctionDef）
for tree in trees:
    for item in tree.body:
        if not isinstance(item, ast.FunctionDef):
            continue
        if item.name == method.__name__:
            return update_sig_from_node(item, sig)  # 更新并返回方法的签名信息

# 如果未找到匹配的函数定义，则返回原始的方法签名对象
# 注：以下方法实现在 Axes 的 MRO 之外，当前代码不会找到它们的带注释版本
#     stackplot
#     streamplot
#     table
#     tricontour
#     tricontourf
#     tripcolor
#     triplot
# 发出警告，提示未找到指定方法名称的函数定义
# import warnings
# warnings.warn(f"'{method.__name__}' not found")
return sig



# 根据 AST 节点更新方法的签名对象
def update_sig_from_node(node, sig):
    params = dict(sig.parameters)  # 将方法的参数转换为字典
    args = node.args  # 获取 AST 节点的参数列表

    # 汇总所有参数类型
    allargs = (
        *args.posonlyargs,
        *args.args,
        args.vararg,
        *args.kwonlyargs,
        args.kwarg,
    )

    # 遍历参数列表，如果存在注释则更新参数的类型注释
    for param in allargs:
        if param is None:
            continue
        if param.annotation is None:
            continue
        annotation = direct_repr(ast.unparse(param.annotation))
        params[param.arg] = params[param.arg].replace(annotation=annotation)

    # 如果节点有返回类型，则创建新的方法签名对象并返回，否则保持原样返回
    if node.returns is not None:
        return inspect.Signature(
            params.values(),
            return_annotation=direct_repr(ast.unparse(node.returns))
        )
    else:
        return inspect.Signature(params.values())



# 主程序入口，用于生成并写入 matplotlib.pyplot 文件
if __name__ == '__main__':
    # 检查命令行参数是否存在，如果存在则使用第一个参数作为 pyplot 文件路径，否则使用默认路径
    if len(sys.argv) > 1:
        pyplot_path = Path(sys.argv[1])
    else:
        pyplot_path = Path(__file__).parent / "../lib/matplotlib/pyplot.py"

    # 调用 build_pyplot 函数生成 pyplot 文件
    build_pyplot(pyplot_path)
```