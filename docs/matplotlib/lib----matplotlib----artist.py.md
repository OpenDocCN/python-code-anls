# `D:\src\scipysrc\matplotlib\lib\matplotlib\artist.py`

```
def allow_rasterization(draw):
    """
    Decorator for Artist.draw method. Provides routines
    that run before and after the draw call. The before and after functions
    are useful for changing artist-dependent renderer attributes or making
    other setup function calls, such as starting and flushing a mixed-mode
    renderer.
    """

    @wraps(draw)
    # 定义装饰器函数的内部包装函数，接受与原函数相同的参数
    def draw_wrapper(artist, renderer, *args, **kwargs):
        # 如果渲染器的 _raster_depth 为 0 并且正在进行光栅化
        if renderer._raster_depth == 0 and renderer._rasterizing:
            # 只有当我们不在一个光栅化的父级内，并且自上次停止光栅化以来已经光栅化了某些内容时，我们才停止光栅化
            renderer.stop_rasterizing()
            renderer._rasterizing = False

        # 调用原始的 draw 函数并返回其结果
        return draw(artist, renderer, *args, **kwargs)

    # 设置装饰器函数的属性，表示不支持光栅化
    draw_wrapper._supports_rasterization = False
    return draw_wrapper
    # 定义一个函数 draw_wrapper，接受 artist 和 renderer 两个参数
    def draw_wrapper(artist, renderer):
        # 尝试执行以下代码块，确保程序的稳定性
        try:
            # 如果 artist 要求进行光栅化处理
            if artist.get_rasterized():
                # 如果当前渲染器不在光栅化过程中，并且深度为 0
                if renderer._raster_depth == 0 and not renderer._rasterizing:
                    # 开始光栅化过程
                    renderer.start_rasterizing()
                    renderer._rasterizing = True
                # 增加光栅化深度计数
                renderer._raster_depth += 1
            else:
                # 如果当前渲染器正在进行光栅化，并且深度为 0
                if renderer._raster_depth == 0 and renderer._rasterizing:
                    # 仅在不在光栅化父级中并且自上次停止光栅化以来有光栅化时，才停止光栅化
                    renderer.stop_rasterizing()
                    renderer._rasterizing = False

            # 如果 artist 有聚合过滤器
            if artist.get_agg_filter() is not None:
                # 开始应用过滤器
                renderer.start_filter()

            # 调用 draw 函数进行绘制，并返回其结果
            return draw(artist, renderer)
        
        # 无论是否发生异常，都会执行以下代码块
        finally:
            # 如果 artist 有聚合过滤器
            if artist.get_agg_filter() is not None:
                # 停止应用该过滤器
                renderer.stop_filter(artist.get_agg_filter())
            # 如果 artist 要求进行光栅化处理
            if artist.get_rasterized():
                # 减少光栅化深度计数
                renderer._raster_depth -= 1
            # 如果当前正在进行光栅化，并且 artist 的 figure 存在且禁止合成
            if (renderer._rasterizing and artist.figure and
                    artist.figure.suppressComposite):
                # 停止当前光栅化过程
                renderer.stop_rasterizing()
                # 重新开始光栅化，以防止合并操作

    # 为 draw_wrapper 函数添加一个属性 _supports_rasterization，表示它支持光栅化处理
    draw_wrapper._supports_rasterization = True
    # 返回定义好的 draw_wrapper 函数
    return draw_wrapper
# 定义一个装饰器函数，用于处理Artist.draw方法的最终渲染步骤，当渲染仍处于栅格化模式时，在最外层的Artist即Figure上需要使用此装饰器。
def _finalize_rasterization(draw):
    @wraps(draw)
    def draw_wrapper(artist, renderer, *args, **kwargs):
        # 调用原始的draw方法
        result = draw(artist, renderer, *args, **kwargs)
        # 如果渲染器仍处于栅格化模式，停止栅格化并设置_rasterizing标志为False
        if renderer._rasterizing:
            renderer.stop_rasterizing()
            renderer._rasterizing = False
        return result
    return draw_wrapper


# 当self.axes存在时，设置其stale属性为给定的val值的回调函数
def _stale_axes_callback(self, val):
    if self.axes:
        self.axes.stale = val


# 定义一个命名元组_XYPair，表示具有x和y属性的对
_XYPair = namedtuple("_XYPair", "x y")


# 定义一个名为_Unset的类，其__repr__方法返回"<UNSET>"，用于表示未设置的值
class _Unset:
    def __repr__(self):
        return "<UNSET>"
_UNSET = _Unset()


# 定义Artist类，用于所有能够渲染到FigureCanvas的对象的抽象基类
class Artist:
    """
    Abstract base class for objects that render into a FigureCanvas.

    Typically, all visible elements in a figure are subclasses of Artist.
    """

    zorder = 0

    def __init_subclass__(cls):

        # 装饰draw()方法，使得所有的Artist都能在必要时停止栅格化渲染。
        # 如果Artist的draw方法已经被装饰过（有'_supports_rasterization'属性），则不会再次装饰。
        if not hasattr(cls.draw, "_supports_rasterization"):
            cls.draw = _prevent_rasterization(cls.draw)

        # 注入自定义的set()方法到子类中，方法签名和文档字符串基于子类的属性生成。
        if not hasattr(cls.set, '_autogenerated_signature'):
            # 如果子类或其父类已定义了set方法，则不覆盖cls.set。
            # 如果没有显式定义，cls.set将从自动生成的set方法层次结构中继承，并带有_autogenerated_signature标志。
            return

        # 使用lambda表达式定义一个新的set()方法，将其名字和限定名设置为标准形式。
        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)
        cls.set.__name__ = "set"
        cls.set.__qualname__ = f"{cls.__qualname__}.set"
        cls._update_set_signature_and_docstring()

    # 在set()方法中排除的属性列表
    _PROPERTIES_EXCLUDED_FROM_SET = [
        'navigate_mode',  # 不是用户可见的函数
        'figure',         # 更改Figure是一个重要操作，不应该出现在set()方法中
        '3d_properties',  # 由于以数字开头，无法作为关键字使用
    ]

    @classmethod
    def _update_set_signature_and_docstring(cls):
        """
        Update the signature of the set function to list all properties
        as keyword arguments.

        Property aliases are not listed in the signature for brevity, but
        are still accepted as keyword arguments.
        """
        # 设置函数的签名，列出所有属性作为关键字参数
        cls.set.__signature__ = Signature(
            [Parameter("self", Parameter.POSITIONAL_OR_KEYWORD),
             *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_UNSET)
               for prop in ArtistInspector(cls).get_setters()
               if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])
        # 标记此签名是自动生成的
        cls.set._autogenerated_signature = True

        # 设置函数的文档字符串
        cls.set.__doc__ = (
            "Set multiple properties at once.\n\n"
            "Supported properties are\n\n"
            + kwdoc(cls))

    def __init__(self):
        # 初始化对象的属性
        self._stale = True
        self.stale_callback = None
        self._axes = None
        self.figure = None

        self._transform = None
        self._transformSet = False
        self._visible = True
        self._animated = False
        self._alpha = None
        self.clipbox = None
        self._clippath = None
        self._clipon = True
        self._label = ''
        self._picker = None
        self._rasterized = False
        self._agg_filter = None
        # 通常情况下，如果对象覆盖了 get_cursor_data 方法，才需要查询鼠标悬停信息
        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data
        # 初始化回调函数注册表，包含信号 "pchanged"
        self._callbacks = cbook.CallbackRegistry(signals=["pchanged"])
        try:
            self.axes = None
        except AttributeError:
            # 处理 self.axes 作为只读属性的情况，例如在 Figure 类中
            pass
        self._remove_method = None
        self._url = None
        self._gid = None
        self._snap = None
        # 获取当前配置中的笔触风格信息
        self._sketch = mpl.rcParams['path.sketch']
        # 获取当前配置中的路径效果信息
        self._path_effects = mpl.rcParams['path.effects']
        # 初始化粘性边缘
        self._sticky_edges = _XYPair([], [])
        # 设置对象在布局中
        self._in_layout = True

    def __getstate__(self):
        # 获取对象状态的字典表示
        d = self.__dict__.copy()
        # 清除 'stale_callback' 键对应的值
        d['stale_callback'] = None
        return d
    def remove(self):
        """
        Remove the artist from the figure if possible.

        The effect will not be visible until the figure is redrawn, e.g.,
        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to
        update the Axes limits if desired.

        Note: `~.axes.Axes.relim` will not see collections even if the
        collection was added to the Axes with *autolim* = True.

        Note: there is no support for removing the artist's legend entry.
        """

        # 如果存在移除方法，则调用该方法来移除当前的艺术对象
        if self._remove_method is not None:
            self._remove_method(self)
            # 清除过时的回调
            self.stale_callback = None
            _ax_flag = False
            # 如果存在属性 'axes' 并且非空，则从鼠标悬停列表中移除当前对象
            if hasattr(self, 'axes') and self.axes:
                self.axes._mouseover_set.discard(self)
                self.axes.stale = True  # 标记 Axes 需要更新
                self.axes = None  # 将艺术对象与 Axes 解绑定
                _ax_flag = True

            # 如果存在 Figure 对象，则标记 Figure 需要更新
            if self.figure:
                if not _ax_flag:
                    self.figure.stale = True
                self.figure = None

        else:
            # 如果没有移除方法，则抛出未实现错误
            raise NotImplementedError('cannot remove artist')
        
        # TODO: 修复 collections relim 问题的方法是将限制计算移动到艺术对象本身，
        # 包括艺术对象是否应影响限制的属性。然后，axes.add_line、axes.add_patch 等
        # 之间将不再有区别。
        # TODO: 添加图例支持

    def have_units(self):
        """Return whether units are set on any axis."""
        ax = self.axes
        # 返回当前艺术对象是否设置了单位
        return ax and any(axis.have_units() for axis in ax._axis_map.values())

    def convert_xunits(self, x):
        """
        Convert *x* using the unit type of the xaxis.

        If the artist is not contained in an Axes or if the xaxis does not
        have units, *x* itself is returned.
        """
        ax = getattr(self, 'axes', None)
        # 如果不存在 Axes 或者 xaxis 没有设置单位，则直接返回 x
        if ax is None or ax.xaxis is None:
            return x
        # 否则，使用 xaxis 的单位类型来转换 x
        return ax.xaxis.convert_units(x)

    def convert_yunits(self, y):
        """
        Convert *y* using the unit type of the yaxis.

        If the artist is not contained in an Axes or if the yaxis does not
        have units, *y* itself is returned.
        """
        ax = getattr(self, 'axes', None)
        # 如果不存在 Axes 或者 yaxis 没有设置单位，则直接返回 y
        if ax is None or ax.yaxis is None:
            return y
        # 否则，使用 yaxis 的单位类型来转换 y
        return ax.yaxis.convert_units(y)

    @property
    def axes(self):
        """The `~.axes.Axes` instance the artist resides in, or *None*."""
        # 返回当前艺术对象所在的 Axes 实例，如果未指定则返回 None
        return self._axes

    @axes.setter
    # 定义一个方法用于设置对象的坐标轴
    def axes(self, new_axes):
        # 检查新坐标轴是否不为 None，且当前对象已有坐标轴，且新坐标轴与当前对象的坐标轴不同
        if (new_axes is not None and self._axes is not None
                and new_axes != self._axes):
            # 如果尝试重置坐标轴，则抛出数值错误异常
            raise ValueError("Can not reset the Axes. You are probably trying to reuse "
                             "an artist in more than one Axes which is not supported")
        # 将对象的 _axes 属性设置为新的坐标轴
        self._axes = new_axes
        # 如果新坐标轴不为 None 且不等于当前对象自身，则设置对象的 stale_callback 为 _stale_axes_callback

    # 定义一个属性方法，用于返回对象的 'stale' 属性
    @property
    def stale(self):
        """
        Whether the artist is 'stale' and needs to be re-drawn for the output
        to match the internal state of the artist.
        """
        return self._stale

    # 定义 'stale' 属性的 setter 方法，用于设置 'stale' 属性的值
    @stale.setter
    def stale(self, val):
        # 将 'stale' 属性设置为指定的值
        self._stale = val

        # 如果对象是动画的，则不会正常参与绘制堆栈，并且不会作为正常绘制循环的一部分被绘制（非保存状态）
        if self._animated:
            return

        # 如果 'stale' 为 True 且 stale_callback 不为 None，则调用 stale_callback 方法
        if val and self.stale_callback is not None:
            self.stale_callback(self, val)

    # 定义一个方法，用于获取艺术家在显示空间中的边界框
    def get_window_extent(self, renderer=None):
        """
        Get the artist's bounding box in display space.

        The bounding box' width and height are nonnegative.

        Subclasses should override for inclusion in the bounding box
        "tight" calculation. Default is to return an empty bounding
        box at 0, 0.

        Be careful when using this function, the results will not update
        if the artist window extent of the artist changes.  The extent
        can change due to any changes in the transform stack, such as
        changing the Axes limits, the figure size, or the canvas used
        (as is done when saving a figure).  This can lead to unexpected
        behavior where interactive figures will look fine on the screen,
        but will save incorrectly.
        """
        # 默认返回一个空的边界框，左上角和右下角均为 [0, 0]
        return Bbox([[0, 0], [0, 0]])

    # 定义一个方法，类似于 get_window_extent，但包括任何剪辑
    def get_tightbbox(self, renderer=None):
        """
        Like `.Artist.get_window_extent`, but includes any clipping.

        Parameters
        ----------
        renderer : `~matplotlib.backend_bases.RendererBase` subclass, optional
            renderer that will be used to draw the figures (i.e.
            ``fig.canvas.get_renderer()``)

        Returns
        -------
        `.Bbox` or None
            The enclosing bounding box (in figure pixel coordinates).
            Returns None if clipping results in no intersection.
        """
        # 获取艺术家在显示空间中的边界框
        bbox = self.get_window_extent(renderer)
        # 如果设置了剪辑，则进行相应的剪辑处理
        if self.get_clip_on():
            # 获取剪辑框
            clip_box = self.get_clip_box()
            if clip_box is not None:
                bbox = Bbox.intersection(bbox, clip_box)
            # 获取剪辑路径
            clip_path = self.get_clip_path()
            if clip_path is not None and bbox is not None:
                # 对剪辑路径进行完全变换处理
                clip_path = clip_path.get_fully_transformed_path()
                bbox = Bbox.intersection(bbox, clip_path.get_extents())
        # 返回包含剪辑的边界框，以图像像素坐标表示；如果剪辑结果为空，则返回 None
        return bbox
    def add_callback(self, func):
        """
        Add a callback function that will be called whenever one of the
        `.Artist`'s properties changes.

        Parameters
        ----------
        func : callable
            The callback function. It must have the signature::

                def func(artist: Artist) -> Any

            where *artist* is the calling `.Artist`. Return values may exist
            but are ignored.

        Returns
        -------
        int
            The observer id associated with the callback. This id can be
            used for removing the callback with `.remove_callback` later.

        See Also
        --------
        remove_callback
        """
        # 将 func 包装在 lambda 中，确保可以多次连接而不会因为弱引用而被回收
        return self._callbacks.connect("pchanged", lambda: func(self))

    def remove_callback(self, oid):
        """
        Remove a callback based on its observer id.

        See Also
        --------
        add_callback
        """
        self._callbacks.disconnect(oid)

    def pchanged(self):
        """
        Call all of the registered callbacks.

        This function is triggered internally when a property is changed.

        See Also
        --------
        add_callback
        remove_callback
        """
        self._callbacks.process("pchanged")

    def is_transform_set(self):
        """
        Return whether the Artist has an explicitly set transform.

        This is *True* after `.set_transform` has been called.
        """
        return self._transformSet

    def set_transform(self, t):
        """
        Set the artist transform.

        Parameters
        ----------
        t : `~matplotlib.transforms.Transform`
        """
        self._transform = t
        self._transformSet = True
        self.pchanged()
        self.stale = True

    def get_transform(self):
        """Return the `.Transform` instance used by this artist."""
        if self._transform is None:
            self._transform = IdentityTransform()
        elif (not isinstance(self._transform, Transform)
              and hasattr(self._transform, '_as_mpl_transform')):
            self._transform = self._transform._as_mpl_transform(self.axes)
        return self._transform

    def get_children(self):
        r"""Return a list of the child `.Artist`\s of this `.Artist`."""
        return []
    def _different_canvas(self, event):
        """
        Check whether an *event* occurred on a canvas other that this artist's canvas.

        If this method returns True, the event definitely occurred on a different
        canvas; if it returns False, either it occurred on the same canvas, or we may
        not have enough information to know.

        Subclasses should start their definition of `contains` as follows::

            if self._different_canvas(mouseevent):
                return False, {}
            # subclass-specific implementation follows
        """
        # 判断事件是否发生在一个与当前艺术家不同的画布上
        return (getattr(event, "canvas", None) is not None and self.figure is not None
                and event.canvas is not self.figure.canvas)

    def contains(self, mouseevent):
        """
        Test whether the artist contains the mouse event.

        Parameters
        ----------
        mouseevent : `~matplotlib.backend_bases.MouseEvent`

        Returns
        -------
        contains : bool
            Whether any values are within the radius.
        details : dict
            An artist-specific dictionary of details of the event context,
            such as which points are contained in the pick radius. See the
            individual Artist subclasses for details.
        """
        # 发出警告，提醒需要定义 `contains` 方法的子类
        _log.warning("%r needs 'contains' method", self.__class__.__name__)
        # 默认情况下，艺术家不包含鼠标事件，返回空字典表示没有额外的事件细节
        return False, {}

    def pickable(self):
        """
        Return whether the artist is pickable.

        See Also
        --------
        .Artist.set_picker, .Artist.get_picker, .Artist.pick
        """
        # 返回艺术家是否可以被选中的状态，基于是否有图形和是否设置了 picker
        return self.figure is not None and self._picker is not None
    def pick(self, mouseevent):
        """
        Process a pick event.

        Each child artist will fire a pick event if *mouseevent* is over
        the artist and the artist has picker set.

        See Also
        --------
        .Artist.set_picker, .Artist.get_picker, .Artist.pickable
        """
        from .backend_bases import PickEvent  # 导入PickEvent类，处理选择事件的基类（可能会存在循环导入问题）

        # Pick self
        # 检查当前对象是否可被选择
        if self.pickable():
            # 获取当前对象的选择器
            picker = self.get_picker()
            # 如果选择器是可调用的
            if callable(picker):
                # 调用选择器函数，判断鼠标事件是否在当前对象内
                inside, prop = picker(self, mouseevent)
            else:
                # 否则，调用当前对象的contains方法判断鼠标事件是否在当前对象内
                inside, prop = self.contains(mouseevent)
            # 如果鼠标事件在当前对象内
            if inside:
                # 创建PickEvent对象并处理选择事件
                PickEvent("pick_event", self.figure.canvas,
                          mouseevent, self, **prop)._process()

        # Pick children
        # 遍历当前对象的所有子对象
        for a in self.get_children():
            # 确保事件发生在相同的Axes上
            ax = getattr(a, 'axes', None)
            # 如果子对象是SubFigure类型或者鼠标事件不属于任何Axes，或者ax为空，或者鼠标事件的Axes与子对象的Axes相同
            if (isinstance(a, mpl.figure.SubFigure)
                    or mouseevent.inaxes is None or ax is None
                    or mouseevent.inaxes == ax):
                # 需要检查mouseevent.inaxes是否为None，因为与Axes关联的某些对象（如刻度标签）可能在Axes的边界框之外，inaxes会是None
                # 同时也要检查ax是否为None，以便遍历没有axes属性但可能有子对象的对象
                # 递归调用pick方法处理子对象的选择事件
                a.pick(mouseevent)

    def set_picker(self, picker):
        """
        Define the picking behavior of the artist.

        Parameters
        ----------
        picker : None or bool or float or callable
            This can be one of the following:

            - *None*: Picking is disabled for this artist (default).

            - A boolean: If *True* then picking will be enabled and the
              artist will fire a pick event if the mouse event is over
              the artist.

            - A float: If picker is a number it is interpreted as an
              epsilon tolerance in points and the artist will fire
              off an event if its data is within epsilon of the mouse
              event.  For some artists like lines and patch collections,
              the artist may provide additional data to the pick event
              that is generated, e.g., the indices of the data within
              epsilon of the pick event

            - A function: If picker is callable, it is a user supplied
              function which determines whether the artist is hit by the
              mouse event::

                hit, props = picker(artist, mouseevent)

              to determine the hit test.  if the mouse event is over the
              artist, return *hit=True* and props is a dictionary of
              properties you want added to the PickEvent attributes.
        """
        # 设置当前对象的选择器属性
        self._picker = picker
    def get_picker(self):
        """
        返回艺术家的选取行为。

        可能的取值详见 `.Artist.set_picker`。

        参见
        --------
        .Artist.set_picker, .Artist.pickable, .Artist.pick
        """
        return self._picker

    def get_url(self):
        """返回 URL。"""
        return self._url

    def set_url(self, url):
        """
        设置艺术家的 URL。

        参数
        ----------
        url : str
        """
        self._url = url

    def get_gid(self):
        """返回组 ID。"""
        return self._gid

    def set_gid(self, gid):
        """
        设置艺术家的（组）ID。

        参数
        ----------
        gid : str
        """
        self._gid = gid

    def get_snap(self):
        """
        返回对齐设置。

        查看 `.set_snap` 获取详细信息。
        """
        if mpl.rcParams['path.snap']:
            return self._snap
        else:
            return False

    def set_snap(self, snap):
        """
        设置对齐行为。

        对齐将位置与像素网格对齐，可以产生更清晰的图像。例如，如果在两个像素之间的位置定义了一个1像素宽的黑线，
        结果图像将在像素网格中包含该线的插值值，这将导致邻近像素位置的灰色值。而使用对齐功能将使该线移动到
        最接近的整数像素值，因此结果图像将真正包含一个1像素宽的黑线。

        对齐目前仅由 Agg 和 MacOSX 后端支持。

        参数
        ----------
        snap : bool 或 None
            可能的取值:

            - *True*: 将顶点对齐到最近的像素中心。
            - *False*: 不修改顶点位置。
            - *None*: (自动) 如果路径只包含直角线段，将四舍五入到最近的像素中心。
        """
        self._snap = snap
        self.stale = True

    def get_sketch_params(self):
        """
        返回艺术家的素描参数。

        返回
        -------
        tuple 或 None

            包含以下元素的3元组:

            - *scale*: 垂直于源线的摆动幅度。
            - *length*: 沿着线的摆动长度。
            - *randomness*: 长度的缩放因子，用于收缩或扩展。

            如果未设置素描参数，则返回 *None*。
        """
        return self._sketch
    def set_sketch_params(self, scale=None, length=None, randomness=None):
        """
        Set the sketch parameters.

        Parameters
        ----------
        scale : float, optional
            The amplitude of the wiggle perpendicular to the source
            line, in pixels.  If scale is `None`, or not provided, no
            sketch filter will be provided.
        length : float, optional
             The length of the wiggle along the line, in pixels
             (default 128.0)
        randomness : float, optional
            The scale factor by which the length is shrunken or
            expanded (default 16.0)

            The PGF backend uses this argument as an RNG seed and not as
            described above. Using the same seed yields the same random shape.

            .. ACCEPTS: (scale: float, length: float, randomness: float)
        """
        # 如果 scale 是 None，将 _sketch 设为 None，表示不使用 sketch filter
        if scale is None:
            self._sketch = None
        else:
            # 否则，设置 _sketch 为一个元组，包含 scale、length（默认为128.0）、randomness（默认为16.0）
            self._sketch = (scale, length or 128.0, randomness or 16.0)
        # 设置 stale 属性为 True，表示对象状态需要更新
        self.stale = True

    def set_path_effects(self, path_effects):
        """
        Set the path effects.

        Parameters
        ----------
        path_effects : list of `.AbstractPathEffect`
        """
        # 设置 _path_effects 属性为传入的 path_effects 列表
        self._path_effects = path_effects
        # 设置 stale 属性为 True，表示对象状态需要更新
        self.stale = True

    def get_path_effects(self):
        # 返回当前对象的 _path_effects 属性
        return self._path_effects

    def get_figure(self):
        """Return the `.Figure` instance the artist belongs to."""
        # 返回当前对象所属的 figure 对象
        return self.figure

    def set_figure(self, fig):
        """
        Set the `.Figure` instance the artist belongs to.

        Parameters
        ----------
        fig : `~matplotlib.figure.Figure`
        """
        # 如果当前 figure 已经是新传入的 fig，则直接返回，不做任何操作
        if self.figure is fig:
            return
        # 如果当前已经有一个 figure 与该对象关联，则抛出 RuntimeError
        if self.figure is not None:
            raise RuntimeError("Can not put single artist in "
                               "more than one figure")
        # 将该对象的 figure 设置为新传入的 fig
        self.figure = fig
        # 如果设置了新的 figure，并且新 figure 不是 self 自身，则调用 pchanged() 方法
        if self.figure and self.figure is not self:
            self.pchanged()
        # 设置 stale 属性为 True，表示对象状态需要更新
        self.stale = True
    def set_clip_box(self, clipbox):
        """
        Set the artist's clip `.Bbox`.

        Parameters
        ----------
        clipbox : `~matplotlib.transforms.BboxBase` or None
            Will typically be created from a `.TransformedBbox`. For instance,
            ``TransformedBbox(Bbox([[0, 0], [1, 1]]), ax.transAxes)`` is the default
            clipping for an artist added to an Axes.

        """
        # 检查 clipbox 参数的类型是否是 BboxBase 或者 None
        _api.check_isinstance((BboxBase, None), clipbox=clipbox)
        # 如果 clipbox 与当前的 self.clipbox 不同，则更新 self.clipbox
        if clipbox != self.clipbox:
            self.clipbox = clipbox
            # 调用 pchanged 方法，表示属性变化
            self.pchanged()
            # 将 stale 标志设置为 True，表示需要重新绘制
            self.stale = True

    def set_clip_path(self, path, transform=None):
        """
        Set the artist's clip path.

        Parameters
        ----------
        path : `~matplotlib.patches.Patch` or `.Path` or `.TransformedPath` or None
            The clip path. If given a `.Path`, *transform* must be provided as
            well. If *None*, a previously set clip path is removed.
        transform : `~matplotlib.transforms.Transform`, optional
            Only used if *path* is a `.Path`, in which case the given `.Path`
            is converted to a `.TransformedPath` using *transform*.

        Notes
        -----
        For efficiency, if *path* is a `.Rectangle` this method will set the
        clipping box to the corresponding rectangle and set the clipping path
        to ``None``.

        For technical reasons (support of `~.Artist.set`), a tuple
        (*path*, *transform*) is also accepted as a single positional
        parameter.

        .. ACCEPTS: Patch or (Path, Transform) or None
        """
        from matplotlib.patches import Patch, Rectangle

        success = False
        # 如果 transform 参数为 None
        if transform is None:
            # 如果 path 是 Rectangle 类型，则设置 self.clipbox
            if isinstance(path, Rectangle):
                self.clipbox = TransformedBbox(Bbox.unit(),
                                               path.get_transform())
                # 将 self._clippath 设置为 None
                self._clippath = None
                success = True
            # 如果 path 是 Patch 类型，则将其转换为 TransformedPatchPath 类型
            elif isinstance(path, Patch):
                self._clippath = TransformedPatchPath(path)
                success = True
            # 如果 path 是 tuple 类型，则解包为 path 和 transform
            elif isinstance(path, tuple):
                path, transform = path

        # 如果 path 为 None，则移除之前设置的 clip path
        if path is None:
            self._clippath = None
            success = True
        # 如果 path 是 Path 类型，则设置 self._clippath 为 TransformedPath
        elif isinstance(path, Path):
            self._clippath = TransformedPath(path, transform)
            success = True
        # 如果 path 是 TransformedPatchPath 类型，则直接设置为 self._clippath
        elif isinstance(path, TransformedPatchPath):
            self._clippath = path
            success = True
        # 如果 path 是 TransformedPath 类型，则直接设置为 self._clippath
        elif isinstance(path, TransformedPath):
            self._clippath = path
            success = True

        # 如果没有成功设置 clip path，则抛出类型错误异常
        if not success:
            raise TypeError(
                "Invalid arguments to set_clip_path, of type "
                f"{type(path).__name__} and {type(transform).__name__}")
        
        # 调用 pchanged 方法，表示属性变化
        self.pchanged()
        # 将 stale 标志设置为 True，表示需要重新绘制
        self.stale = True
    def get_alpha(self):
        """
        Return the alpha value used for blending - not supported on all
        backends.
        """
        # 返回当前对象的 alpha 值，用于混合效果，但不是所有后端都支持
        return self._alpha

    def get_visible(self):
        """Return the visibility."""
        # 返回当前对象的可见性状态
        return self._visible

    def get_animated(self):
        """Return whether the artist is animated."""
        # 返回当前对象是否被设置为动画
        return self._animated

    def get_in_layout(self):
        """
        Return boolean flag, ``True`` if artist is included in layout
        calculations.

        E.g. :ref:`constrainedlayout_guide`,
        `.Figure.tight_layout()`, and
        ``fig.savefig(fname, bbox_inches='tight')``.
        """
        # 返回一个布尔值，如果该艺术家对象被包含在布局计算中，则返回 True
        return self._in_layout

    def _fully_clipped_to_axes(self):
        """
        Return a boolean flag, ``True`` if the artist is clipped to the Axes
        and can thus be skipped in layout calculations. Requires `get_clip_on`
        is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents``
        is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch``
        is equivalent to ``ax.patch`` (if set).
        """
        # 返回一个布尔值，如果艺术家对象被剪切到坐标轴范围内并且可以在布局计算中跳过，则返回 True。
        # 要求 get_clip_on 返回 True，其中之一 clip_box 或 clip_path 被设置，
        # clip_box.extents 等同于 ax.bbox.extents（如果设置），并且 clip_path._patch 等同于 ax.patch（如果设置）。
        clip_box = self.get_clip_box()
        clip_path = self.get_clip_path()
        return (self.axes is not None
                and self.get_clip_on()
                and (clip_box is not None or clip_path is not None)
                and (clip_box is None
                     or np.all(clip_box.extents == self.axes.bbox.extents))
                and (clip_path is None
                     or isinstance(clip_path, TransformedPatchPath)
                     and clip_path._patch is self.axes.patch))

    def get_clip_on(self):
        """Return whether the artist uses clipping."""
        # 返回当前艺术家对象是否使用剪切功能
        return self._clipon

    def get_clip_box(self):
        """Return the clipbox."""
        # 返回当前艺术家对象的剪切框
        return self.clipbox

    def get_clip_path(self):
        """Return the clip path."""
        # 返回当前艺术家对象的剪切路径
        return self._clippath

    def get_transformed_clip_path_and_affine(self):
        """
        Return the clip path with the non-affine part of its
        transformation applied, and the remaining affine part of its
        transformation.
        """
        # 如果存在剪切路径（_clippath），则返回经过其非仿射部分转换后的剪切路径及其剩余的仿射部分。
        if self._clippath is not None:
            return self._clippath.get_transformed_path_and_affine()
        return None, None
    def set_clip_on(self, b):
        """
        设置是否使用裁剪来控制图形的可见性。

        当参数 b 为 False 时，图形可能会超出 Axes 的范围，导致意外的结果。

        Parameters
        ----------
        b : bool
            控制是否启用裁剪
        """
        # 将 self._clipon 属性设置为参数 b
        self._clipon = b
        # 这可能导致回调函数被调用两次，但至少保证它们至少被调用一次
        self.pchanged()
        self.stale = True

    def _set_gc_clip(self, gc):
        """
        根据当前对象的裁剪状态设置绘图上下文（gc）的裁剪区域。

        Parameters
        ----------
        gc : GraphicsContext
            绘图上下文对象
        """
        if self._clipon:
            # 如果启用了裁剪，并且存在裁剪框，则设置裁剪矩形
            if self.clipbox is not None:
                gc.set_clip_rectangle(self.clipbox)
            # 设置裁剪路径
            gc.set_clip_path(self._clippath)
        else:
            # 如果未启用裁剪，则清除裁剪矩形和裁剪路径
            gc.set_clip_rectangle(None)
            gc.set_clip_path(None)

    def get_rasterized(self):
        """
        返回当前对象是否将被栅格化处理。

        Returns
        -------
        bool
            返回当前对象的栅格化状态
        """
        return self._rasterized

    def set_rasterized(self, rasterized):
        """
        设置是否强制将对象绘制为栅格化图像（位图），用于矢量图输出。

        栅格化绘制并非所有图形对象都支持。如果尝试在不支持的对象上启用栅格化，
        则该设置不会生效，并且会发出警告信息。

        对于基于像素的输出，此设置将被忽略。

        Parameters
        ----------
        rasterized : bool
            控制是否启用栅格化绘制
        """
        supports_rasterization = getattr(self.draw,
                                         "_supports_rasterization", False)
        if rasterized and not supports_rasterization:
            # 如果要求栅格化绘制但对象不支持，则发出警告
            _api.warn_external(f"Rasterization of '{self}' will be ignored")

        # 设置对象的栅格化状态
        self._rasterized = rasterized

    def get_agg_filter(self):
        """
        返回用于聚合滤波器的过滤函数。

        Returns
        -------
        callable
            返回当前对象的聚合滤波器函数
        """
        return self._agg_filter

    def set_agg_filter(self, filter_func):
        """
        设置聚合滤波器函数。

        Parameters
        ----------
        filter_func : callable
            一个滤波器函数，接受一个 (m, n, depth) 的浮点数组和 dpi 值作为输入，
            返回一个相同形状的数组以及图像左下角的两个偏移量。

            .. ACCEPTS: 一个滤波器函数，接受一个 (m, n, 3) 的浮点数组和 dpi 值作为输入，
               返回一个 (m, n, 3) 的数组以及图像左下角的两个偏移量
        """
        # 设置对象的聚合滤波器函数
        self._agg_filter = filter_func
        self.stale = True
    def draw(self, renderer):
        """
        Draw the Artist (and its children) using the given renderer.

        This has no effect if the artist is not visible (`.Artist.get_visible`
        returns False).

        Parameters
        ----------
        renderer : `~matplotlib.backend_bases.RendererBase` subclass.

        Notes
        -----
        This method is overridden in the Artist subclasses.
        """
        # 如果艺术对象不可见，则不执行绘制操作
        if not self.get_visible():
            return
        # 标记为不需要重新绘制
        self.stale = False

    def set_alpha(self, alpha):
        """
        Set the alpha value used for blending - not supported on all backends.

        Parameters
        ----------
        alpha : scalar or None
            *alpha* must be within the 0-1 range, inclusive.
        """
        # 如果 alpha 不为 None 且不是实数类型，则抛出类型错误异常
        if alpha is not None and not isinstance(alpha, Real):
            raise TypeError(
                f'alpha must be numeric or None, not {type(alpha)}')
        # 如果 alpha 不为 None 且不在 [0, 1] 的范围内，则抛出数值错误异常
        if alpha is not None and not (0 <= alpha <= 1):
            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')
        # 如果 alpha 和当前 alpha 值不同，则更新 alpha 值，并标记为需要重新绘制
        if alpha != self._alpha:
            self._alpha = alpha
            self.pchanged()
            self.stale = True

    def _set_alpha_for_array(self, alpha):
        """
        Set the alpha value used for blending - not supported on all backends.

        Parameters
        ----------
        alpha : array-like or scalar or None
            All values must be within the 0-1 range, inclusive.
            Masked values and nans are not supported.
        """
        # 如果 alpha 是字符串类型，则抛出类型错误异常
        if isinstance(alpha, str):
            raise TypeError("alpha must be numeric or None, not a string")
        # 如果 alpha 不可迭代，则调用父类的 set_alpha 方法
        if not np.iterable(alpha):
            Artist.set_alpha(self, alpha)
            return
        # 将 alpha 转换为 NumPy 数组
        alpha = np.asarray(alpha)
        # 如果 alpha 中有值不在 [0, 1] 范围内，则抛出数值错误异常
        if not (0 <= alpha.min() and alpha.max() <= 1):
            raise ValueError('alpha must be between 0 and 1, inclusive, '
                             f'but min is {alpha.min()}, max is {alpha.max()}')
        # 更新 alpha 值，并标记为需要重新绘制
        self._alpha = alpha
        self.pchanged()
        self.stale = True

    def set_visible(self, b):
        """
        Set the artist's visibility.

        Parameters
        ----------
        b : bool
        """
        # 如果 b 和当前可见性状态不同，则更新可见性状态，并标记为需要重新绘制
        if b != self._visible:
            self._visible = b
            self.pchanged()
            self.stale = True

    def set_animated(self, b):
        """
        Set whether the artist is intended to be used in an animation.

        If True, the artist is excluded from regular drawing of the figure.
        You have to call `.Figure.draw_artist` / `.Axes.draw_artist`
        explicitly on the artist. This approach is used to speed up animations
        using blitting.

        See also `matplotlib.animation` and
        :ref:`blitting`.

        Parameters
        ----------
        b : bool
        """
        # 如果 b 和当前动画状态不同，则更新动画状态，并标记为需要重新绘制
        if self._animated != b:
            self._animated = b
            self.pchanged()
    # 设置是否将艺术对象包含在布局计算中，例如 constrainedlayout_guide、Figure.tight_layout() 和 fig.savefig(fname, bbox_inches='tight')。
    # 这里的 in_layout 是一个布尔类型参数，用于控制是否将该艺术对象包含在布局计算中。
    def set_in_layout(self, in_layout):
        self._in_layout = in_layout

    # 返回用于在图例中显示的艺术对象的标签。
    def get_label(self):
        return self._label

    # 设置在图例中显示的标签。
    # 参数 s 将被转换为字符串形式。
    def set_label(self, s):
        label = str(s) if s is not None else None
        # 如果新的标签与当前标签不同，则更新标签，并标记对象为已修改和过时。
        if label != self._label:
            self._label = label
            self.pchanged()  # 标记对象属性已更改
            self.stale = True  # 标记对象为过时

    # 返回艺术对象的 zorder（绘制顺序）。
    def get_zorder(self):
        return self.zorder

    # 设置艺术对象的绘制顺序 zorder。较低 zorder 值的对象将先绘制。
    def set_zorder(self, level):
        if level is None:
            level = self.__class__.zorder
        # 如果新的 zorder 与当前 zorder 不同，则更新 zorder，并标记对象为已修改和过时。
        if level != self.zorder:
            self.zorder = level
            self.pchanged()  # 标记对象属性已更改
            self.stale = True  # 标记对象为过时

    # 返回自动缩放时的粘性边界（sticky edges）列表，用于 x 和 y 轴。
    # 粘性边界指的是当数据极限与粘性边界列表中的值重合时，不会添加边界。
    # 例如在直方图中，通常希望底部边缘（0）不添加边界。
    @property
    def sticky_edges(self):
        return self._sticky_edges
    def update_from(self, other):
        """
        Copy properties from *other* to *self*.
        """
        # 将 *other* 的 _transform 属性复制给 self 的 _transform 属性
        self._transform = other._transform
        # 将 *other* 的 _transformSet 属性复制给 self 的 _transformSet 属性
        self._transformSet = other._transformSet
        # 将 *other* 的 _visible 属性复制给 self 的 _visible 属性
        self._visible = other._visible
        # 将 *other* 的 _alpha 属性复制给 self 的 _alpha 属性
        self._alpha = other._alpha
        # 将 *other* 的 clipbox 属性复制给 self 的 clipbox 属性
        self.clipbox = other.clipbox
        # 将 *other* 的 _clipon 属性复制给 self 的 _clipon 属性
        self._clipon = other._clipon
        # 将 *other* 的 _clippath 属性复制给 self 的 _clippath 属性
        self._clippath = other._clippath
        # 将 *other* 的 _label 属性复制给 self 的 _label 属性
        self._label = other._label
        # 将 *other* 的 _sketch 属性复制给 self 的 _sketch 属性
        self._sketch = other._sketch
        # 将 *other* 的 _path_effects 属性复制给 self 的 _path_effects 属性
        self._path_effects = other._path_effects
        # 将 *other* 的 sticky_edges.x 属性的复制结果赋值给 self 的 sticky_edges.x 属性
        self.sticky_edges.x[:] = other.sticky_edges.x.copy()
        # 将 *other* 的 sticky_edges.y 属性的复制结果赋值给 self 的 sticky_edges.y 属性
        self.sticky_edges.y[:] = other.sticky_edges.y.copy()
        # 调用 self 的 pchanged() 方法，表示属性已更改
        self.pchanged()
        # 设置 self 的 stale 属性为 True，表示需要刷新
        self.stale = True

    def properties(self):
        """
        Return a dictionary of all the properties of the artist.
        """
        # 调用 ArtistInspector 类的构造函数，返回 self 对象的属性字典
        return ArtistInspector(self).properties()

    def _update_props(self, props, errfmt):
        """
        Helper for `.Artist.set` and `.Artist.update`.

        *errfmt* is used to generate error messages for invalid property
        names; it gets formatted with ``type(self)`` and the property name.
        """
        # 初始化空列表 ret
        ret = []
        # 禁用事件监听
        with cbook._setattr_cm(self, eventson=False):
            # 遍历 props 字典中的键值对
            for k, v in props.items():
                # 如果键为 "axes"，直接将其值赋给 self 的 axes 属性
                if k == "axes":
                    ret.append(setattr(self, k, v))
                else:
                    # 否则，获取以 "set_" 开头的方法名
                    func = getattr(self, f"set_{k}", None)
                    # 如果该方法不存在或者不可调用，抛出 AttributeError 异常
                    if not callable(func):
                        raise AttributeError(
                            errfmt.format(cls=type(self), prop_name=k))
                    # 调用相应的 set_ 方法，传入 v 作为参数，并将返回值添加到 ret 列表中
                    ret.append(func(v))
        # 如果 ret 列表不为空，调用 self 的 pchanged() 方法，表示属性已更改
        if ret:
            self.pchanged()
            # 设置 self 的 stale 属性为 True，表示需要刷新
            self.stale = True
        # 返回 ret 列表
        return ret

    def update(self, props):
        """
        Update this artist's properties from the dict *props*.

        Parameters
        ----------
        props : dict
            A dictionary containing properties to update.
        """
        # 调用 _update_props 方法，传入 props 字典和错误格式字符串，返回更新的结果
        return self._update_props(
            props, "{cls.__name__!r} object has no property {prop_name!r}")

    def _internal_update(self, kwargs):
        """
        Update artist properties without prenormalizing them, but generating
        errors as if calling `set`.

        The lack of prenormalization is to maintain backcompatibility.
        """
        # 调用 _update_props 方法，传入 kwargs 字典和错误格式字符串，返回更新的结果
        return self._update_props(
            kwargs, "{cls.__name__}.set() got an unexpected keyword argument "
            "{prop_name!r}")

    def set(self, **kwargs):
        """
        Update this artist's properties from the keyword arguments.

        Parameters
        ----------
        **kwargs : dict
            Keyword arguments specifying properties to update.
        """
        # 调用 cbook.normalize_kwargs 方法，对 kwargs 进行规范化处理
        return self._internal_update(cbook.normalize_kwargs(kwargs, self))

    @contextlib.contextmanager
    def _cm_set(self, **kwargs):
        """
        `.Artist.set` context-manager that restores original values at exit.
        """
        # 获取当前对象中指定属性的原始值，并存储在字典 orig_vals 中
        orig_vals = {k: getattr(self, f"get_{k}")() for k in kwargs}
        try:
            # 设置当前对象的指定属性为传入的参数 kwargs 指定的值
            self.set(**kwargs)
            # 返回 yield，即进入上下文管理器的主体部分
            yield
        finally:
            # 恢复原始的属性值
            self.set(**orig_vals)

    def findobj(self, match=None, include_self=True):
        """
        Find artist objects.

        Recursively find all `.Artist` instances contained in the artist.

        Parameters
        ----------
        match
            A filter criterion for the matches. This can be

            - *None*: Return all objects contained in artist.
            - A function with signature ``def match(artist: Artist) -> bool``.
              The result will only contain artists for which the function
              returns *True*.
            - A class instance: e.g., `.Line2D`. The result will only contain
              artists of this class or its subclasses (``isinstance`` check).

        include_self : bool
            Include *self* in the list to be checked for a match.

        Returns
        -------
        list of `.Artist`

        """
        if match is None:  # always return True
            # 如果 match 为 None，则返回一个始终返回 True 的匿名函数
            def matchfunc(x):
                return True
        elif isinstance(match, type) and issubclass(match, Artist):
            # 如果 match 是一个类，并且是 Artist 的子类，则返回一个函数，
            # 判断传入对象 x 是否是 match 类或其子类的实例
            def matchfunc(x):
                return isinstance(x, match)
        elif callable(match):
            # 如果 match 是一个可调用对象（函数），直接将 matchfunc 设置为 match
            matchfunc = match
        else:
            # 如果 match 不符合以上条件，抛出 ValueError 异常
            raise ValueError('match must be None, a matplotlib.artist.Artist '
                             'subclass, or a callable')

        # 递归查找所有子节点中符合条件的 Artist 对象，并将结果扁平化为一个列表
        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])
        if include_self and matchfunc(self):
            # 如果 include_self 为 True 并且当前对象自身符合匹配条件，则加入结果列表
            artists.append(self)
        return artists

    def get_cursor_data(self, event):
        """
        Return the cursor data for a given event.

        .. note::
            This method is intended to be overridden by artist subclasses.
            As an end-user of Matplotlib you will most likely not call this
            method yourself.

        Cursor data can be used by Artists to provide additional context
        information for a given event. The default implementation just returns
        *None*.

        Subclasses can override the method and return arbitrary data. However,
        when doing so, they must ensure that `.format_cursor_data` can convert
        the data to a string representation.

        The only current use case is displaying the z-value of an `.AxesImage`
        in the status bar of a plot window, while moving the mouse.

        Parameters
        ----------
        event : `~matplotlib.backend_bases.MouseEvent`

        See Also
        --------
        format_cursor_data

        """
        # 默认情况下返回 None，表示不返回任何光标数据
        return None
    # 返回一个表示数据 *data* 的字符串表示形式
    def format_cursor_data(self, data):
        """
        Return a string representation of *data*.

        .. note::
            This method is intended to be overridden by artist subclasses.
            As an end-user of Matplotlib you will most likely not call this
            method yourself.

        The default implementation converts ints and floats and arrays of ints
        and floats into a comma-separated string enclosed in square brackets,
        unless the artist has an associated colorbar, in which case scalar
        values are formatted using the colorbar's formatter.

        See Also
        --------
        get_cursor_data
        """
        # 检查数据的维度是否为0，同时检查当前对象是否为 ScalarMappable 的实例
        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):
            # 如果数据被掩码了，返回空列表的字符串表示
            if np.ma.getmask(data):
                return "[]"
            # 对数据进行归一化处理
            normed = self.norm(data)
            # 如果归一化后的值是有限的
            if np.isfinite(normed):
                # 如果当前对象的归一化函数是 BoundaryNorm 类型
                if isinstance(self.norm, BoundaryNorm):
                    # 找到距离数据最近的边界值的索引
                    cur_idx = np.argmin(np.abs(self.norm.boundaries - data))
                    neigh_idx = max(0, cur_idx - 1)
                    # 计算相邻边界值的最大差值，避免 delta == 0
                    delta = np.diff(
                        self.norm.boundaries[neigh_idx:cur_idx + 2]
                    ).max()

                else:
                    # 计算归一化后值对应的颜色区间的中点
                    neighbors = self.norm.inverse(
                        (int(normed * n) + np.array([0, 1])) / n)
                    delta = abs(neighbors - data).max()
                # 根据数据值和最大差值计算有效数字位数
                g_sig_digits = cbook._g_sig_digits(data, delta)
            else:
                g_sig_digits = 3  # 与默认值保持一致
            # 使用格式化字符串返回数据值的字符串表示，保留 g_sig_digits 位有效数字
            return f"[{data:-#.{g_sig_digits}g}]"
        else:
            # 如果数据不是标量或者当前对象不是 ScalarMappable 的实例
            try:
                # 尝试访问数据的第一个元素，处理可能的 TypeError 或 IndexError 异常
                data[0]
            except (TypeError, IndexError):
                # 如果访问失败，将数据转换为列表形式
                data = [data]
            # 使用逗号分隔的形式，将数据中所有数字类型的元素格式化为 0.3g 的字符串表示
            data_str = ', '.join(f'{item:0.3g}' for item in data
                                 if isinstance(item, Number))
            # 返回将格式化后的字符串表示形式包含在方括号内的结果
            return "[" + data_str + "]"

    # 返回当前对象是否被查询以获取鼠标悬停时的自定义上下文信息
    def get_mouseover(self):
        """
        Return whether this artist is queried for custom context information
        when the mouse cursor moves over it.
        """
        return self._mouseover
    def set_mouseover(self, mouseover):
        """
        Set whether this artist is queried for custom context information when
        the mouse cursor moves over it.

        Parameters
        ----------
        mouseover : bool
            A boolean indicating whether mouseover functionality is enabled (True) or disabled (False).

        See Also
        --------
        get_cursor_data
            Method for retrieving cursor data.
        .ToolCursorPosition
            Position of the tool cursor.
        .NavigationToolbar2
            Navigation toolbar for the plot.

        This method sets the `_mouseover` attribute of the current object and updates
        the `_mouseover_set` attribute of its associated axes accordingly.
        """
        self._mouseover = bool(mouseover)  # Set `_mouseover` attribute based on input boolean value
        ax = self.axes  # Retrieve the axes associated with this artist
        if ax:
            if self._mouseover:
                ax._mouseover_set.add(self)  # Add current artist to the set of mouseover artists in the axes
            else:
                ax._mouseover_set.discard(self)  # Remove current artist from the set of mouseover artists

    mouseover = property(get_mouseover, set_mouseover)  # backcompat.
    def _get_tightbbox_for_layout_only(obj, *args, **kwargs):
        """
        Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a
        *for_layout_only* kwarg; this helper tries to use the kwarg but skips it
        when encountering third-party subclasses that do not support it.
        """
        try:
            # 尝试调用对象的 get_tightbbox 方法，传入参数和额外的 "for_layout_only" 关键字参数设为 True
            return obj.get_tightbbox(*args, **{**kwargs, "for_layout_only": True})
        except TypeError:
            # 如果遇到 TypeError，再次尝试调用 get_tightbbox 方法，传入原始的参数和关键字参数
            return obj.get_tightbbox(*args, **kwargs)


    class ArtistInspector:
        """
        A helper class to inspect an `~matplotlib.artist.Artist` and return
        information about its settable properties and their current values.
        """

        def __init__(self, o):
            r"""
            Initialize the artist inspector with an `Artist` or an iterable of
            `Artist`\s.  If an iterable is used, we assume it is a homogeneous
            sequence (all `Artist`\s are of the same type) and it is your
            responsibility to make sure this is so.
            """
            if not isinstance(o, Artist):
                if np.iterable(o):
                    # 如果 o 是可迭代的对象，将其转换为列表并检查第一个元素的类型
                    o = list(o)
                    if len(o):
                        o = o[0]

            # 将原始对象保存在 self.oorig 中
            self.oorig = o
            # 如果 o 不是 Artist 的实例，尝试获取其类型并保存在 self.o 中
            if not isinstance(o, type):
                o = type(o)
            self.o = o

            # 调用 get_aliases 方法，获取属性别名字典并保存在 self.aliasd 中
            self.aliasd = self.get_aliases()

        def get_aliases(self):
            """
            Get a dict mapping property fullnames to sets of aliases for each alias
            in the :class:`~matplotlib.artist.ArtistInspector`.

            e.g., for lines::

              {'markerfacecolor': {'mfc'},
               'linewidth'      : {'lw'},
              }
            """
            # 获取 self.o 对象中以 'set_' 或 'get_' 开头并且可调用的属性名列表
            names = [name for name in dir(self.o)
                     if name.startswith(('set_', 'get_'))
                        and callable(getattr(self.o, name))]
            aliases = {}
            for name in names:
                func = getattr(self.o, name)
                if not self.is_alias(func):
                    continue
                # 从函数文档字符串中提取属性名，并将其添加到 aliases 字典中
                propname = re.search(f"`({name[:4].*})`",  # get_.*/set_.*
                                     inspect.getdoc(func)).group(1)
                aliases.setdefault(propname[4:], set()).add(name[4:])
            return aliases

        _get_valid_values_regex = re.compile(
            r"\n\s*(?:\.\.\s+)?ACCEPTS:\s*((?:.|\n)*?)(?:$|(?:\n\n))"
        )
    def get_valid_values(self, attr):
        """
        Get the legal arguments for the setter associated with *attr*.

        This is done by querying the docstring of the setter for a line that
        begins with "ACCEPTS:" or ".. ACCEPTS:", and then by looking for a
        numpydoc-style documentation for the setter's first argument.
        """

        # 构建 setter 方法的名称
        name = 'set_%s' % attr
        # 检查对象 self.o 是否具有该 setter 方法，若不存在则抛出 AttributeError 异常
        if not hasattr(self.o, name):
            raise AttributeError(f'{self.o} has no function {name}')
        # 获取对象 self.o 中名称为 name 的方法对象
        func = getattr(self.o, name)

        # 如果方法 func 具有 _kwarg_doc 属性，则返回该属性值
        if hasattr(func, '_kwarg_doc'):
            return func._kwarg_doc

        # 获取 func 方法的文档字符串
        docstring = inspect.getdoc(func)
        # 如果文档字符串为 None，则返回 'unknown'
        if docstring is None:
            return 'unknown'

        # 如果文档字符串以 'Alias for ' 开头，则返回 None
        if docstring.startswith('Alias for '):
            return None

        # 使用正则表达式匹配文档字符串中以 "ACCEPTS:" 开头的内容
        match = self._get_valid_values_regex.search(docstring)
        # 如果匹配成功，则返回匹配组中第一个子组匹配的内容，经过格式化处理
        if match is not None:
            return re.sub("\n *", " ", match.group(1))

        # 获取方法的第一个参数名
        param_name = func.__code__.co_varnames[1]
        # 使用正则表达式匹配文档字符串中以参数名开头的行
        match = re.search(fr"(?m)^ *\*?{param_name} : (.+)", docstring)
        # 如果匹配成功，则返回匹配组中第一个子组匹配的内容
        if match:
            return match.group(1)

        # 如果以上条件均不满足，则返回 'unknown'
        return 'unknown'

    def _replace_path(self, source_class):
        """
        Changes the full path to the public API path that is used
        in sphinx. This is needed for links to work.
        """
        # 定义替换规则字典
        replace_dict = {'_base._AxesBase': 'Axes',
                        '_axes.Axes': 'Axes'}
        # 遍历替换规则字典，将 source_class 中的 key 替换为对应的 value
        for key, value in replace_dict.items():
            source_class = source_class.replace(key, value)
        # 返回替换后的 source_class
        return source_class

    def get_setters(self):
        """
        Get the attribute strings with setters for object.

        For example, for a line, return ``['markerfacecolor', 'linewidth',
        ....]``.
        """
        # 初始化空列表 setters，用于存储找到的 setter 方法名
        setters = []
        # 遍历对象 self.o 的所有属性名
        for name in dir(self.o):
            # 如果属性名不以 'set_' 开头，则跳过本次循环
            if not name.startswith('set_'):
                continue
            # 获取属性名对应的方法对象
            func = getattr(self.o, name)
            # 如果 func 不是可调用的方法，或者 func 方法的参数个数小于 2，或者是别名，则跳过本次循环
            if (not callable(func)
                    or self.number_of_parameters(func) < 2
                    or self.is_alias(func)):
                continue
            # 将有效的 setter 方法名添加到 setters 列表中（去掉 'set_' 后的部分）
            setters.append(name[4:])
        # 返回找到的所有 setter 方法名组成的列表
        return setters

    @staticmethod
    @cache
    def number_of_parameters(func):
        """Return number of parameters of the callable *func*."""
        # 返回 func 方法的参数个数
        return len(inspect.signature(func).parameters)

    @staticmethod
    @cache
    def is_alias(method):
        """
        Return whether the object *method* is an alias for another method.
        """

        # 获取方法 method 的文档字符串
        ds = inspect.getdoc(method)
        # 如果文档字符串为 None，则返回 False
        if ds is None:
            return False

        # 如果文档字符串以 'Alias for ' 开头，则返回 True，否则返回 False
        return ds.startswith('Alias for ')
    def aliased_name(self, s):
        """
        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.

        For example, for the line markerfacecolor property, which has an
        alias, return 'markerfacecolor or mfc' and for the transform
        property, which does not, return 'transform'.
        """
        # 获取给定属性名 s 的所有别名，并按字母顺序排列
        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))
        # 返回格式化后的属性名，包括可能的别名
        return s + aliases

    _NOT_LINKABLE = {
        # 一组在当前文档中不可用的属性设置器方法。这是一个解决方案，用于避免尝试链接这些设置器，否则会在文档构建过程中引发“目标引用未找到”的警告。
        'matplotlib.image._ImageBase.set_alpha',
        'matplotlib.image._ImageBase.set_array',
        'matplotlib.image._ImageBase.set_data',
        'matplotlib.image._ImageBase.set_filternorm',
        'matplotlib.image._ImageBase.set_filterrad',
        'matplotlib.image._ImageBase.set_interpolation',
        'matplotlib.image._ImageBase.set_interpolation_stage',
        'matplotlib.image._ImageBase.set_resample',
        'matplotlib.text._AnnotationBase.set_annotation_clip',
    }

    def aliased_name_rest(self, s, target):
        """
        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',
        formatted for reST.

        For example, for the line markerfacecolor property, which has an
        alias, return 'markerfacecolor or mfc' and for the transform
        property, which does not, return 'transform'.
        """
        # workaround to prevent "reference target not found"
        # 如果目标在 _NOT_LINKABLE 集合中，返回用反引号包裹的属性名 s
        if target in self._NOT_LINKABLE:
            return f'``{s}``'

        # 获取给定属性名 s 的所有别名，并按字母顺序排列
        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))
        # 返回格式化后的 reST 链接格式，包括可能的别名
        return f':meth:`{s} <{target}>`{aliases}'

    def pprint_setters(self, prop=None, leadingspace=2):
        """
        If *prop* is *None*, return a list of strings of all settable
        properties and their valid values.

        If *prop* is not *None*, it is a valid property name and that
        property will be returned as a string of property : valid
        values.
        """
        # 根据 leadingspace 决定是否添加前导空格
        if leadingspace:
            pad = ' ' * leadingspace
        else:
            pad = ''

        if prop is not None:
            # 获取给定属性 prop 的有效值列表
            accepts = self.get_valid_values(prop)
            # 返回格式化后的字符串，显示属性名和其有效值
            return f'{pad}{prop}: {accepts}'

        lines = []
        # 遍历所有可设置属性，返回格式化后的列表，显示属性名（包括可能的别名）和其有效值
        for prop in sorted(self.get_setters()):
            accepts = self.get_valid_values(prop)
            name = self.aliased_name(prop)
            lines.append(f'{pad}{name}: {accepts}')
        return lines
    def pprint_setters_rest(self, prop=None, leadingspace=4):
        """
        如果 *prop* 为 *None*，返回所有可设置属性及其有效值的 reST 格式字符串列表。

        如果 *prop* 不为 *None*，则是一个有效的属性名称，返回格式为 "property : valid" 的字符串值。
        """
        # 根据 leadingspace 的值确定填充空格的字符串
        if leadingspace:
            pad = ' ' * leadingspace
        else:
            pad = ''

        # 如果 prop 不为 None，获取其有效值并返回格式化的字符串
        if prop is not None:
            accepts = self.get_valid_values(prop)
            return f'{pad}{prop}: {accepts}'

        # 获取所有可设置属性的方法和完全限定名
        prop_and_qualnames = []
        for prop in sorted(self.get_setters()):
            # 查找实际提供文档字符串的父方法
            for cls in self.o.__mro__:
                method = getattr(cls, f"set_{prop}", None)
                if method and method.__doc__ is not None:
                    break
            else:  # 如果没有可用的文档字符串
                method = getattr(self.o, f"set_{prop}")
            prop_and_qualnames.append(
                (prop, f"{method.__module__}.{method.__qualname__}"))

        # 对属性和目标进行别名处理，并替换特定的字符串
        names = [self.aliased_name_rest(prop, target)
                 .replace('_base._AxesBase', 'Axes')
                 .replace('_axes.Axes', 'Axes')
                 for prop, target in prop_and_qualnames]

        # 获取所有属性的有效值
        accepts = [self.get_valid_values(prop)
                   for prop, _ in prop_and_qualnames]

        # 计算表格列的长度
        col0_len = max(len(n) for n in names)
        col1_len = max(len(a) for a in accepts)
        table_formatstr = pad + '   ' + '=' * col0_len + '   ' + '=' * col1_len

        # 返回格式化的表格字符串列表
        return [
            '',
            pad + '.. table::',
            pad + '   :class: property-table',
            '',
            table_formatstr,
            pad + '   ' + 'Property'.ljust(col0_len)
            + '   ' + 'Description'.ljust(col1_len),
            table_formatstr,
            *[pad + '   ' + n.ljust(col0_len) + '   ' + a.ljust(col1_len)
              for n, a in zip(names, accepts)],
            table_formatstr,
            '',
        ]

    def properties(self):
        """返回一个将属性名称映射到值的字典。"""
        # 获取原始对象
        o = self.oorig

        # 获取所有以 'get_' 开头且可调用的方法列表，并按字母顺序排序
        getters = [name for name in dir(o)
                   if name.startswith('get_') and callable(getattr(o, name))]
        getters.sort()
        d = {}

        # 遍历每个获取器方法，忽略别名方法，捕获可能的异常并存储属性值到字典
        for name in getters:
            func = getattr(o, name)
            if self.is_alias(func):
                continue
            try:
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore')
                    val = func()
            except Exception:
                continue
            else:
                d[name[4:]] = val

        # 返回属性名称映射到值的字典
        return d
    # 定义一个方法，用于返回对象的属性名及其实际值的列表形式
    def pprint_getters(self):
        """Return the getters and actual values as list of strings."""
        # 初始化一个空列表，用于存储格式化后的属性名和值的字符串
        lines = []
        # 遍历对象的属性，按属性名排序
        for name, val in sorted(self.properties().items()):
            # 检查属性值是否具有'shape'属性且长度大于6
            if getattr(val, 'shape', ()) != () and len(val) > 6:
                # 如果是数组类型且长度大于6，截取前6个元素并加上省略号
                s = str(val[:6]) + '...'
            else:
                # 否则直接转换属性值为字符串
                s = str(val)
            # 替换字符串中的换行符为空格
            s = s.replace('\n', ' ')
            # 如果字符串长度超过50，截取前50个字符并加上省略号
            if len(s) > 50:
                s = s[:50] + '...'
            # 使用对象的别名方法转换属性名
            name = self.aliased_name(name)
            # 将格式化后的属性名和值字符串添加到列表中
            lines.append(f'    {name} = {s}')
        # 返回格式化后的属性名和值列表
        return lines
def getp(obj, property=None):
    """
    Return the value of an `.Artist`'s *property*, or print all of them.

    Parameters
    ----------
    obj : `~matplotlib.artist.Artist`
        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.

    property : str or None, default: None
        If *property* is 'somename', this function returns
        ``obj.get_somename()``.

        If it's None (or unset), it *prints* all gettable properties from
        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is
        an alias for 'linewidth'.  In the output, aliases and full property
        names will be listed as:

          property or alias = value

        e.g.:

          linewidth or lw = 2

    See Also
    --------
    setp
    """
    # 如果 property 参数为 None，则创建一个 ArtistInspector 对象用于检查 obj 的属性
    if property is None:
        insp = ArtistInspector(obj)
        # 调用 ArtistInspector 对象的 pprint_getters 方法，获取并打印所有属性的信息
        ret = insp.pprint_getters()
        # 将打印内容连接成字符串，并打印出来
        print('\n'.join(ret))
        # 返回 None，表示没有返回值
        return
    # 如果 property 参数不为 None，则根据 property 获取对应的方法并调用，返回结果
    return getattr(obj, 'get_' + property)()

# alias
get = getp


def setp(obj, *args, file=None, **kwargs):
    """
    Set one or more properties on an `.Artist`, or list allowed values.

    Parameters
    ----------
    obj : `~matplotlib.artist.Artist` or list of `.Artist`
        The artist(s) whose properties are being set or queried.  When setting
        properties, all artists are affected; when querying the allowed values,
        only the first instance in the sequence is queried.

        For example, two lines can be made thicker and red with a single call:

        >>> x = arange(0, 1, 0.01)
        >>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))
        >>> setp(lines, linewidth=2, color='r')

    file : file-like, default: `sys.stdout`
        Where `setp` writes its output when asked to list allowed values.

        >>> with open('output.log') as file:
        ...     setp(line, file=file)

        The default, ``None``, means `sys.stdout`.

    *args, **kwargs
        The properties to set.  The following combinations are supported:

        - Set the linestyle of a line to be dashed:

          >>> line, = plot([1, 2, 3])
          >>> setp(line, linestyle='--')

        - Set multiple properties at once:

          >>> setp(line, linewidth=2, color='r')

        - List allowed values for a line's linestyle:

          >>> setp(line, 'linestyle')
          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}

        - List all properties that can be set, and their allowed values:

          >>> setp(line)
          agg_filter: a filter function, ...
          [long output listing omitted]

        `setp` also supports MATLAB style string/value pairs.  For example, the
        following are equivalent:

        >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style
        >>> setp(lines, linewidth=2, color='r')        # Python style

    See Also
    --------
    getp
    """

    # 如果 obj 是单个 Artist 对象，则将其转换为列表形式
    if isinstance(obj, Artist):
        objs = [obj]
    else:
        # 如果 obj 是多个 Artist 对象组成的序列，则使用 cbook.flatten 将其展平为列表
        objs = list(cbook.flatten(obj))
    # 如果没有传入任何对象，则直接返回
    if not objs:
        return

    # 使用第一个对象创建 ArtistInspector 的实例
    insp = ArtistInspector(objs[0])

    # 如果未传入关键字参数并且位置参数少于2个
    if not kwargs and len(args) < 2:
        # 如果有位置参数，则打印指定属性的设置方法到文件中
        if args:
            print(insp.pprint_setters(prop=args[0]), file=file)
        # 否则，打印所有属性的设置方法到文件中
        else:
            print('\n'.join(insp.pprint_setters()), file=file)
        # 函数执行完毕，返回
        return

    # 如果位置参数的数量为奇数，抛出 ValueError 异常
    if len(args) % 2:
        raise ValueError('The set args must be string, value pairs')

    # 将位置参数转化为字典，偶数索引作为键，后续偶数索引作为值
    funcvals = dict(zip(args[::2], args[1::2]))
    # 对每个对象执行 update 方法，并将结果保存到列表中；同时对每个对象执行 set 方法，并将结果也保存到列表中
    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]
    # 将嵌套的列表展开为一维列表，并返回结果
    return list(cbook.flatten(ret))
def kwdoc(artist):
    r"""
    Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and
    return information about its settable properties and their current values.

    Parameters
    ----------
    artist : `~matplotlib.artist.Artist` or an iterable of `Artist`\s

    Returns
    -------
    str
        The settable properties of *artist*, as plain text if
        :rc:`docstring.hardcopy` is False and as a rst table (intended for
        use in Sphinx) if it is True.
    """
    # 使用ArtistInspector类检查给定的artist对象或对象集合
    ai = ArtistInspector(artist)
    # 如果配置为硬拷贝，则返回以rst表格形式（适合Sphinx使用）显示的可设置属性和其当前值
    # 否则，返回以纯文本形式显示的可设置属性和其当前值
    return ('\n'.join(ai.pprint_setters_rest(leadingspace=4))
            if mpl.rcParams['docstring.hardcopy'] else
            'Properties:\n' + '\n'.join(ai.pprint_setters(leadingspace=4)))

# 将Artist类的更新签名和文档字符串延迟到模块末尾执行，因为这需要ArtistInspector已定义
Artist._update_set_signature_and_docstring()
```