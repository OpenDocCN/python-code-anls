# `D:\src\scipysrc\matplotlib\tools\embed_js.py`

```
"""
Script to embed JavaScript dependencies in mpl.js.
"""

from collections import namedtuple  # 导入 namedtuple 类
from pathlib import Path  # 导入 Path 类用于处理路径操作
import re  # 导入 re 模块用于正则表达式操作
import shutil  # 导入 shutil 模块用于文件操作
import subprocess  # 导入 subprocess 模块用于执行外部命令
import sys  # 导入 sys 模块用于系统相关操作


Package = namedtuple('Package', [  # 定义 namedtuple 类 Package，用于表示包信息
    # The package to embed, in some form that `npm install` can use.
    'name',  # 包的名称，用于 npm install 命令
    # The path to the source file within the package to embed.
    'source',  # 包中要嵌入的源文件路径
    # The path to the license file within the package to embed.
    'license'  # 包中要嵌入的许可证文件路径
])
# The list of packages to embed, in some form that `npm install` can use.
JAVASCRIPT_PACKAGES = [
    # Polyfill/ponyfill for ResizeObserver.
    Package('@jsxtools/resize-observer', 'index.js', 'LICENSE.md'),
]
# This is the magic line that must exist in mpl.js, after which the embedded
# JavaScript will be appended.
MPLJS_MAGIC_HEADER = (
    "///////////////// REMAINING CONTENT GENERATED BY embed_js.py "
    "/////////////////\n")


def safe_name(name):
    """
    Make *name* safe to use as a JavaScript variable name.
    """
    return '_'.join(re.split(r'[@/-]', name)).upper()


def prep_package(web_backend_path, pkg):
    """
    Prepare the package by ensuring source and license files exist,
    and install the package if necessary.
    """
    source = web_backend_path / 'node_modules' / pkg.name / pkg.source
    license = web_backend_path / 'node_modules' / pkg.name / pkg.license
    if not source.exists():
        # Exact version should already be saved in package.json, so we use
        # --no-save here.
        try:
            subprocess.run(['npm', 'install', '--no-save', pkg.name],
                           cwd=web_backend_path)
        except FileNotFoundError as err:
            raise ValueError(
                f'npm must be installed to fetch {pkg.name}') from err
    if not source.exists():
        raise ValueError(
            f'{pkg.name} package is missing source in {pkg.source}')
    elif not license.exists():
        raise ValueError(
            f'{pkg.name} package is missing license in {pkg.license}')

    return source, license


def gen_embedded_lines(pkg, source):
    """
    Generate lines for embedding JavaScript from source file into mpl.js.
    """
    name = safe_name(pkg.name)
    print('Embedding', source, 'as', name)
    yield '// prettier-ignore\n'  # 输出 prettier-ignore 注释行
    for line in source.read_text().splitlines():
        yield (line.replace('module.exports=function', f'var {name}=function')
               + ' // eslint-disable-line\n')


def build_mpljs(web_backend_path, license_path):
    """
    Build mpl.js file by embedding JavaScript from specified packages.
    """
    mpljs_path = web_backend_path / "js/mpl.js"
    mpljs_orig = mpljs_path.read_text().splitlines(keepends=True)
    try:
        mpljs_orig = mpljs_orig[:mpljs_orig.index(MPLJS_MAGIC_HEADER) + 1]
    except IndexError as err:
        raise ValueError(
            f'The mpl.js file *must* have the exact line: {MPLJS_MAGIC_HEADER}'
        ) from err

    with mpljs_path.open('w') as mpljs:
        mpljs.writelines(mpljs_orig)

        for pkg in JAVASCRIPT_PACKAGES:
            source, license = prep_package(web_backend_path, pkg)
            mpljs.writelines(gen_embedded_lines(pkg, source))

            shutil.copy(license,
                        license_path / f'LICENSE{safe_name(pkg.name)}')
if __name__ == '__main__':
    # 检查当前脚本是否作为主程序运行

    # 如果命令行参数个数大于1，将第一个参数作为web_backend_path
    if len(sys.argv) > 1:
        web_backend_path = Path(sys.argv[1])
    else:
        # 否则，设置web_backend_path为matplotlib的web后端路径
        web_backend_path = (Path(__file__).parent.parent /
                            "lib/matplotlib/backends/web_backend")

    # 如果命令行参数个数大于2，将第二个参数作为license_path
    if len(sys.argv) > 2:
        license_path = Path(sys.argv[2])
    else:
        # 否则，设置license_path为项目根目录下的LICENSE文件路径
        license_path = Path(__file__).parent.parent / "LICENSE"

    # 调用build_mpljs函数，传递web_backend_path和license_path作为参数
    build_mpljs(web_backend_path, license_path)
```